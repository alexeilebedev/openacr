//
// cpp/gen/dev_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dev.Arch.arch
const char *dev_Arch_arch_         = "";
const char *dev_Arch_arch_amd64    = "amd64";
const char *dev_Arch_arch_i686     = "i686";
const char *dev_Arch_arch_i86pc    = "i86pc";
const char *dev_Arch_arch_x64      = "x64";
const char *dev_Arch_arch_x86_64   = "x86_64";

// compile-time string constants for dev.Builddir.builddir
const char *dev_Builddir_builddir_Darwin_clangPP_coverage_x86_64   = "Darwin-clang++.coverage-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_debug_x86_64      = "Darwin-clang++.debug-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_profile_x86_64    = "Darwin-clang++.profile-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_release_x86_64    = "Darwin-clang++.release-x86_64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_coverage_amd64   = "FreeBSD-clang++.coverage-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_debug_amd64      = "FreeBSD-clang++.debug-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_profile_amd64    = "FreeBSD-clang++.profile-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_release_amd64    = "FreeBSD-clang++.release-amd64";
const char *dev_Builddir_builddir_Linux_gPP_9_coverage_x86_64      = "Linux-g++-9.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_debug_x86_64         = "Linux-g++-9.debug-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_profile_x86_64       = "Linux-g++-9.profile-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_release_x86_64       = "Linux-g++-9.release-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_coverage_x86_64        = "Linux-g++.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_debug_x86_64           = "Linux-g++.debug-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_profile_x86_64         = "Linux-g++.profile-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_release_x86_64         = "Linux-g++.release-x86_64";

// compile-time string constants for dev.Cfg.cfg
const char *dev_Cfg_cfg_   = "";

const char *dev_Cfg_cfg_coverage   = "coverage";
const char *dev_Cfg_cfg_debug      = "debug";

const char *dev_Cfg_cfg_profile   = "profile";
const char *dev_Cfg_cfg_release   = "release";

// compile-time string constants for dev.Compiler.compiler
const char *dev_Compiler_compiler_          = "";
const char *dev_Compiler_compiler_cl        = "cl";
const char *dev_Compiler_compiler_clangPP   = "clang++";
const char *dev_Compiler_compiler_gPP       = "g++";
const char *dev_Compiler_compiler_gPP_9     = "g++-9";

// compile-time string constants for dev.License.license
const char *dev_License_license_      = "";
const char *dev_License_license_GPL   = "GPL";

// compile-time string constants for dev.Sandbox.sandbox
const char *dev_Sandbox_sandbox_abt_md   = "abt_md";

const char *dev_Sandbox_sandbox_acr_ed     = "acr_ed";
const char *dev_Sandbox_sandbox_amc        = "amc";
const char *dev_Sandbox_sandbox_amc_gc     = "amc_gc";
const char *dev_Sandbox_sandbox_atf_ci     = "atf_ci";
const char *dev_Sandbox_sandbox_atf_fuzz   = "atf_fuzz";

// compile-time string constants for dev.Target.target
const char *dev_Target_target_            = "";
const char *dev_Target_target_abt         = "abt";
const char *dev_Target_target_abt_md      = "abt_md";
const char *dev_Target_target_acr         = "acr";
const char *dev_Target_target_acr_compl   = "acr_compl";
const char *dev_Target_target_acr_ed      = "acr_ed";
const char *dev_Target_target_acr_in      = "acr_in";
const char *dev_Target_target_acr_my      = "acr_my";
const char *dev_Target_target_algo_lib    = "algo_lib";
const char *dev_Target_target_algo_pch    = "algo_pch";
const char *dev_Target_target_amc         = "amc";

const char *dev_Target_target_amc_gc    = "amc_gc";
const char *dev_Target_target_amc_vis   = "amc_vis";

const char *dev_Target_target_ams_cat        = "ams_cat";
const char *dev_Target_target_ams_sendtest   = "ams_sendtest";
const char *dev_Target_target_atf_amc        = "atf_amc";
const char *dev_Target_target_atf_ci         = "atf_ci";
const char *dev_Target_target_atf_cmdline    = "atf_cmdline";
const char *dev_Target_target_atf_comp       = "atf_comp";
const char *dev_Target_target_atf_cov        = "atf_cov";
const char *dev_Target_target_atf_fuzz       = "atf_fuzz";
const char *dev_Target_target_atf_gcli       = "atf_gcli";
const char *dev_Target_target_atf_nrun       = "atf_nrun";
const char *dev_Target_target_atf_unit       = "atf_unit";
const char *dev_Target_target_bash2html      = "bash2html";
const char *dev_Target_target_gcli           = "gcli";
const char *dev_Target_target_lib_ams        = "lib_ams";
const char *dev_Target_target_lib_ctype      = "lib_ctype";
const char *dev_Target_target_lib_exec       = "lib_exec";
const char *dev_Target_target_lib_fm         = "lib_fm";

const char *dev_Target_target_lib_git      = "lib_git";
const char *dev_Target_target_lib_iconv    = "lib_iconv";
const char *dev_Target_target_lib_json     = "lib_json";
const char *dev_Target_target_lib_mysql    = "lib_mysql";
const char *dev_Target_target_lib_prot     = "lib_prot";
const char *dev_Target_target_lib_sql      = "lib_sql";
const char *dev_Target_target_mdbg         = "mdbg";
const char *dev_Target_target_mysql2ssim   = "mysql2ssim";
const char *dev_Target_target_orgfile      = "orgfile";

const char *dev_Target_target_sandbox      = "sandbox";
const char *dev_Target_target_src_func     = "src_func";
const char *dev_Target_target_src_hdr      = "src_hdr";
const char *dev_Target_target_src_lim      = "src_lim";
const char *dev_Target_target_ssim2csv     = "ssim2csv";
const char *dev_Target_target_ssim2mysql   = "ssim2mysql";
const char *dev_Target_target_ssimfilt     = "ssimfilt";
const char *dev_Target_target_strconv      = "strconv";
const char *dev_Target_target_sv2ssim      = "sv2ssim";

namespace dev { // gen:ns_print_proto
    static void          SizeCheck();
} // gen:ns_print_proto

// --- dev.Arch..ReadFieldMaybe
bool dev::Arch_ReadFieldMaybe(dev::Arch &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_arch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Arch..ReadStrptrMaybe
// Read fields of dev::Arch from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Arch_ReadStrptrMaybe(dev::Arch &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.arch") || algo::StripTypeTag(in_str, "dev.Arch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Arch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Arch..Print
// print string representation of dev::Arch to string LHS, no header -- cprint:dev.Arch.String
void dev::Arch_Print(dev::Arch & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.arch";

    algo::Smallstr50_Print(row.arch, temp);
    PrintAttrSpaceReset(str,"arch", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Badline..ReadFieldMaybe
bool dev::Badline_ReadFieldMaybe(dev::Badline &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_badline: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badline, strval); break;
        case dev_FieldId_expr: retval = algo::Smallstr200_ReadStrptrMaybe(parent.expr, strval); break;
        case dev_FieldId_targsrc_regx: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsrc_regx, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Badline..ReadStrptrMaybe
// Read fields of dev::Badline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Badline_ReadStrptrMaybe(dev::Badline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.badline") || algo::StripTypeTag(in_str, "dev.Badline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Badline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Badline..Print
// print string representation of dev::Badline to string LHS, no header -- cprint:dev.Badline.String
void dev::Badline_Print(dev::Badline & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.badline";

    algo::Smallstr50_Print(row.badline, temp);
    PrintAttrSpaceReset(str,"badline", temp);

    algo::Smallstr200_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr50_Print(row.targsrc_regx, temp);
    PrintAttrSpaceReset(str,"targsrc_regx", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Builddir.uname.Get
algo::Smallstr50 dev::uname_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.uname.Get2
algo::Smallstr50 dev::Builddir_uname_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.compiler.Get2
algo::Smallstr50 dev::Builddir_compiler_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.cfg.Get2
algo::Smallstr50 dev::Builddir_cfg_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.arch.Get
algo::Smallstr50 dev::arch_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LR"));
    return ret;
}

// --- dev.Builddir.arch.Get2
algo::Smallstr50 dev::Builddir_arch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LR"));
    return ret;
}

// --- dev.Builddir..Concat_uname_compiler_cfg_arch
tempstr dev::Builddir_Concat_uname_compiler_cfg_arch( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch ;
}

// --- dev.Builddir..ReadFieldMaybe
bool dev::Builddir_ReadFieldMaybe(dev::Builddir &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_builddir: retval = algo::Smallstr50_ReadStrptrMaybe(parent.builddir, strval); break;
        case dev_FieldId_uname: retval = false; break;
        case dev_FieldId_compiler: retval = false; break;
        case dev_FieldId_cfg: retval = false; break;
        case dev_FieldId_arch: retval = false; break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Builddir..ReadStrptrMaybe
// Read fields of dev::Builddir from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Builddir_ReadStrptrMaybe(dev::Builddir &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.builddir") || algo::StripTypeTag(in_str, "dev.Builddir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Builddir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Builddir..Print
// print string representation of dev::Builddir to string LHS, no header -- cprint:dev.Builddir.String
void dev::Builddir_Print(dev::Builddir & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.builddir";

    algo::Smallstr50_Print(row.builddir, temp);
    PrintAttrSpaceReset(str,"builddir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Cfg..ReadFieldMaybe
bool dev::Cfg_ReadFieldMaybe(dev::Cfg &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_suffix: retval = algo::Smallstr5_ReadStrptrMaybe(parent.suffix, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Cfg..ReadStrptrMaybe
// Read fields of dev::Cfg from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Cfg_ReadStrptrMaybe(dev::Cfg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.cfg") || algo::StripTypeTag(in_str, "dev.Cfg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Cfg..Print
// print string representation of dev::Cfg to string LHS, no header -- cprint:dev.Cfg.String
void dev::Cfg_Print(dev::Cfg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.cfg";

    algo::Smallstr50_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr5_Print(row.suffix, temp);
    PrintAttrSpaceReset(str,"suffix", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Compiler..ReadFieldMaybe
bool dev::Compiler_ReadFieldMaybe(dev::Compiler &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_compiler: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval); break;
        case dev_FieldId_ranlib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ranlib, strval); break;
        case dev_FieldId_ar: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ar, strval); break;
        case dev_FieldId_link: retval = algo::Smallstr50_ReadStrptrMaybe(parent.link, strval); break;
        case dev_FieldId_libext: retval = algo::Smallstr50_ReadStrptrMaybe(parent.libext, strval); break;
        case dev_FieldId_exeext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.exeext, strval); break;
        case dev_FieldId_pchext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.pchext, strval); break;
        case dev_FieldId_objext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.objext, strval); break;
        case dev_FieldId_rc: retval = algo::Smallstr50_ReadStrptrMaybe(parent.rc, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Compiler..ReadStrptrMaybe
// Read fields of dev::Compiler from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Compiler_ReadStrptrMaybe(dev::Compiler &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.compiler") || algo::StripTypeTag(in_str, "dev.Compiler");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Compiler_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Compiler..Print
// print string representation of dev::Compiler to string LHS, no header -- cprint:dev.Compiler.String
void dev::Compiler_Print(dev::Compiler & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.compiler";

    algo::Smallstr50_Print(row.compiler, temp);
    PrintAttrSpaceReset(str,"compiler", temp);

    algo::Smallstr50_Print(row.ranlib, temp);
    PrintAttrSpaceReset(str,"ranlib", temp);

    algo::Smallstr50_Print(row.ar, temp);
    PrintAttrSpaceReset(str,"ar", temp);

    algo::Smallstr50_Print(row.link, temp);
    PrintAttrSpaceReset(str,"link", temp);

    algo::Smallstr50_Print(row.libext, temp);
    PrintAttrSpaceReset(str,"libext", temp);

    algo::Smallstr20_Print(row.exeext, temp);
    PrintAttrSpaceReset(str,"exeext", temp);

    algo::Smallstr20_Print(row.pchext, temp);
    PrintAttrSpaceReset(str,"pchext", temp);

    algo::Smallstr20_Print(row.objext, temp);
    PrintAttrSpaceReset(str,"objext", temp);

    algo::Smallstr50_Print(row.rc, temp);
    PrintAttrSpaceReset(str,"rc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Covfile..ReadFieldMaybe
bool dev::Covfile_ReadFieldMaybe(dev::Covfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_covfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.covfile, strval); break;
        case dev_FieldId_total: retval = u32_ReadStrptrMaybe(parent.total, strval); break;
        case dev_FieldId_nonexe: retval = u32_ReadStrptrMaybe(parent.nonexe, strval); break;
        case dev_FieldId_exe: retval = u32_ReadStrptrMaybe(parent.exe, strval); break;
        case dev_FieldId_exer: retval = algo::U32Dec2_ReadStrptrMaybe(parent.exer, strval); break;
        case dev_FieldId_hit: retval = u32_ReadStrptrMaybe(parent.hit, strval); break;
        case dev_FieldId_cov: retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covfile..ReadStrptrMaybe
// Read fields of dev::Covfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covfile_ReadStrptrMaybe(dev::Covfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covfile") || algo::StripTypeTag(in_str, "dev.Covfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covfile..Print
// print string representation of dev::Covfile to string LHS, no header -- cprint:dev.Covfile.String
void dev::Covfile_Print(dev::Covfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.covfile";

    algo::Smallstr200_Print(row.covfile, temp);
    PrintAttrSpaceReset(str,"covfile", temp);

    u32_Print(row.total, temp);
    PrintAttrSpaceReset(str,"total", temp);

    u32_Print(row.nonexe, temp);
    PrintAttrSpaceReset(str,"nonexe", temp);

    u32_Print(row.exe, temp);
    PrintAttrSpaceReset(str,"exe", temp);

    algo::U32Dec2_Print(row.exer, temp);
    PrintAttrSpaceReset(str,"exer", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::U32Dec2_Print(row.cov, temp);
    PrintAttrSpaceReset(str,"cov", temp);
}

// --- dev.Covline.src.Get
algo::Smallstr200 dev::src_Get(dev::Covline& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.covline, ":RL"));
    return ret;
}

// --- dev.Covline.src.Get2
algo::Smallstr200 dev::Covline_src_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":RL"));
    return ret;
}

// --- dev.Covline.line.Get
u32 dev::line_Get(dev::Covline& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.covline, ":RR"));
    return ret;
}

// --- dev.Covline.line.Get2
u32 dev::Covline_line_Get(algo::strptr arg) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(arg, ":RR"));
    return ret;
}

// --- dev.Covline.flag.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::flag_ToCstr(const dev::Covline& parent) {
    const char *ret = NULL;
    switch(flag_GetEnum(parent)) {
        case dev_Covline_flag_N            : ret = "N";  break;
        case dev_Covline_flag_E            : ret = "E";  break;
        case dev_Covline_flag_P            : ret = "P";  break;
    }
    return ret;
}

// --- dev.Covline.flag.Print
// Convert flag to a string. First, attempt conversion to a known string.
// If no string matches, print flag as a numeric value.
void dev::flag_Print(const dev::Covline& parent, algo::cstring &lhs) {
    const char *strval = flag_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.flag;
    }
}

// --- dev.Covline.flag.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::flag_SetStrptrMaybe(dev::Covline& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'E': {
                    flag_SetEnum(parent,dev_Covline_flag_E); ret = true; break;
                }
                case 'N': {
                    flag_SetEnum(parent,dev_Covline_flag_N); ret = true; break;
                }
                case 'P': {
                    flag_SetEnum(parent,dev_Covline_flag_P); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.Covline.flag.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::flag_SetStrptr(dev::Covline& parent, algo::strptr rhs, dev_Covline_flag_Enum dflt) {
    if (!flag_SetStrptrMaybe(parent,rhs)) flag_SetEnum(parent,dflt);
}

// --- dev.Covline.flag.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::flag_ReadStrptrMaybe(dev::Covline& parent, algo::strptr rhs) {
    bool retval = false;
    retval = flag_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = char_ReadStrptrMaybe(parent.flag,rhs);
    }
    return retval;
}

// --- dev.Covline..Concat_src_line
tempstr dev::Covline_Concat_src_line( const algo::strptr& src ,u32 line ) {
    return tempstr() << src <<':'<< line ;
}

// --- dev.Covline..ReadFieldMaybe
bool dev::Covline_ReadFieldMaybe(dev::Covline &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_covline: retval = algo::Smallstr200_ReadStrptrMaybe(parent.covline, strval); break;
        case dev_FieldId_src: retval = false; break;
        case dev_FieldId_line: retval = false; break;
        case dev_FieldId_flag: retval = flag_ReadStrptrMaybe(parent, strval); break;
        case dev_FieldId_hit: retval = u32_ReadStrptrMaybe(parent.hit, strval); break;
        case dev_FieldId_text: retval = algo::cstring_ReadStrptrMaybe(parent.text, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covline..ReadStrptrMaybe
// Read fields of dev::Covline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covline_ReadStrptrMaybe(dev::Covline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covline") || algo::StripTypeTag(in_str, "dev.Covline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covline..Print
// print string representation of dev::Covline to string LHS, no header -- cprint:dev.Covline.String
void dev::Covline_Print(dev::Covline & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.covline";

    algo::Smallstr200_Print(row.covline, temp);
    PrintAttrSpaceReset(str,"covline", temp);

    dev::flag_Print(row, temp);
    PrintAttrSpaceReset(str,"flag", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::cstring_Print(row.text, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- dev.Covtarget..ReadFieldMaybe
bool dev::Covtarget_ReadFieldMaybe(dev::Covtarget &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_covtarget: retval = algo::Smallstr16_ReadStrptrMaybe(parent.covtarget, strval); break;
        case dev_FieldId_total: retval = u32_ReadStrptrMaybe(parent.total, strval); break;
        case dev_FieldId_nonexe: retval = u32_ReadStrptrMaybe(parent.nonexe, strval); break;
        case dev_FieldId_exe: retval = u32_ReadStrptrMaybe(parent.exe, strval); break;
        case dev_FieldId_exer: retval = algo::U32Dec2_ReadStrptrMaybe(parent.exer, strval); break;
        case dev_FieldId_hit: retval = u32_ReadStrptrMaybe(parent.hit, strval); break;
        case dev_FieldId_cov: retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covtarget..ReadStrptrMaybe
// Read fields of dev::Covtarget from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covtarget_ReadStrptrMaybe(dev::Covtarget &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covtarget") || algo::StripTypeTag(in_str, "dev.Covtarget");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covtarget_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covtarget..Print
// print string representation of dev::Covtarget to string LHS, no header -- cprint:dev.Covtarget.String
void dev::Covtarget_Print(dev::Covtarget & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.covtarget";

    algo::Smallstr16_Print(row.covtarget, temp);
    PrintAttrSpaceReset(str,"covtarget", temp);

    u32_Print(row.total, temp);
    PrintAttrSpaceReset(str,"total", temp);

    u32_Print(row.nonexe, temp);
    PrintAttrSpaceReset(str,"nonexe", temp);

    u32_Print(row.exe, temp);
    PrintAttrSpaceReset(str,"exe", temp);

    algo::U32Dec2_Print(row.exer, temp);
    PrintAttrSpaceReset(str,"exer", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::U32Dec2_Print(row.cov, temp);
    PrintAttrSpaceReset(str,"cov", temp);
}

// --- dev.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::value_ToCstr(const dev::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dev_FieldId_arch              : ret = "arch";  break;
        case dev_FieldId_comment           : ret = "comment";  break;
        case dev_FieldId_badline           : ret = "badline";  break;
        case dev_FieldId_expr              : ret = "expr";  break;
        case dev_FieldId_targsrc_regx      : ret = "targsrc_regx";  break;
        case dev_FieldId_builddir          : ret = "builddir";  break;
        case dev_FieldId_uname             : ret = "uname";  break;
        case dev_FieldId_compiler          : ret = "compiler";  break;
        case dev_FieldId_cfg               : ret = "cfg";  break;
        case dev_FieldId_suffix            : ret = "suffix";  break;
        case dev_FieldId_ranlib            : ret = "ranlib";  break;
        case dev_FieldId_ar                : ret = "ar";  break;
        case dev_FieldId_link              : ret = "link";  break;
        case dev_FieldId_libext            : ret = "libext";  break;
        case dev_FieldId_exeext            : ret = "exeext";  break;
        case dev_FieldId_pchext            : ret = "pchext";  break;
        case dev_FieldId_objext            : ret = "objext";  break;
        case dev_FieldId_rc                : ret = "rc";  break;
        case dev_FieldId_covfile           : ret = "covfile";  break;
        case dev_FieldId_total             : ret = "total";  break;
        case dev_FieldId_nonexe            : ret = "nonexe";  break;
        case dev_FieldId_exe               : ret = "exe";  break;
        case dev_FieldId_exer              : ret = "exer";  break;
        case dev_FieldId_hit               : ret = "hit";  break;
        case dev_FieldId_cov               : ret = "cov";  break;
        case dev_FieldId_covline           : ret = "covline";  break;
        case dev_FieldId_src               : ret = "src";  break;
        case dev_FieldId_line              : ret = "line";  break;
        case dev_FieldId_flag              : ret = "flag";  break;
        case dev_FieldId_text              : ret = "text";  break;
        case dev_FieldId_covtarget         : ret = "covtarget";  break;
        case dev_FieldId_gitfile           : ret = "gitfile";  break;
        case dev_FieldId_ext               : ret = "ext";  break;
        case dev_FieldId_gitinfo           : ret = "gitinfo";  break;
        case dev_FieldId_author            : ret = "author";  break;
        case dev_FieldId_compver           : ret = "compver";  break;
        case dev_FieldId_package           : ret = "package";  break;
        case dev_FieldId_hilite            : ret = "hilite";  break;
        case dev_FieldId_color             : ret = "color";  break;
        case dev_FieldId_htmlentity        : ret = "htmlentity";  break;
        case dev_FieldId_code              : ret = "code";  break;
        case dev_FieldId_include           : ret = "include";  break;
        case dev_FieldId_srcfile           : ret = "srcfile";  break;
        case dev_FieldId_filename          : ret = "filename";  break;
        case dev_FieldId_sys               : ret = "sys";  break;
        case dev_FieldId_issue             : ret = "issue";  break;
        case dev_FieldId_project           : ret = "project";  break;
        case dev_FieldId_assignee          : ret = "assignee";  break;
        case dev_FieldId_labels            : ret = "labels";  break;
        case dev_FieldId_milestone         : ret = "milestone";  break;
        case dev_FieldId_iid               : ret = "iid";  break;
        case dev_FieldId_title             : ret = "title";  break;
        case dev_FieldId_license           : ret = "license";  break;
        case dev_FieldId_nlongline         : ret = "nlongline";  break;
        case dev_FieldId_longestline       : ret = "longestline";  break;
        case dev_FieldId_nbadws            : ret = "nbadws";  break;
        case dev_FieldId_maxws             : ret = "maxws";  break;
        case dev_FieldId_nlongfunc         : ret = "nlongfunc";  break;
        case dev_FieldId_longestfunc       : ret = "longestfunc";  break;
        case dev_FieldId_nmysteryfunc      : ret = "nmysteryfunc";  break;
        case dev_FieldId_badness           : ret = "badness";  break;
        case dev_FieldId_mr                : ret = "mr";  break;
        case dev_FieldId_source_branch     : ret = "source_branch";  break;
        case dev_FieldId_pipeline_status   : ret = "pipeline_status";  break;
        case dev_FieldId_strict            : ret = "strict";  break;
        case dev_FieldId_opt_type          : ret = "opt_type";  break;
        case dev_FieldId_sep               : ret = "sep";  break;
        case dev_FieldId_inl               : ret = "inl";  break;
        case dev_FieldId_sandbox           : ret = "sandbox";  break;
        case dev_FieldId_filter            : ret = "filter";  break;
        case dev_FieldId_sbpath            : ret = "sbpath";  break;
        case dev_FieldId_ssimfs            : ret = "ssimfs";  break;
        case dev_FieldId_ssimfile          : ret = "ssimfile";  break;
        case dev_FieldId_file              : ret = "file";  break;
        case dev_FieldId_lscmd             : ret = "lscmd";  break;
        case dev_FieldId_excl              : ret = "excl";  break;
        case dev_FieldId_syscmd            : ret = "syscmd";  break;
        case dev_FieldId_execkey           : ret = "execkey";  break;
        case dev_FieldId_command           : ret = "command";  break;
        case dev_FieldId_pid               : ret = "pid";  break;
        case dev_FieldId_status            : ret = "status";  break;
        case dev_FieldId_nprereq           : ret = "nprereq";  break;
        case dev_FieldId_fail_prereq       : ret = "fail_prereq";  break;
        case dev_FieldId_completed         : ret = "completed";  break;
        case dev_FieldId_maxtime           : ret = "maxtime";  break;
        case dev_FieldId_syscmddep         : ret = "syscmddep";  break;
        case dev_FieldId_child             : ret = "child";  break;
        case dev_FieldId_parent            : ret = "parent";  break;
        case dev_FieldId_syslib            : ret = "syslib";  break;
        case dev_FieldId_targdep           : ret = "targdep";  break;
        case dev_FieldId_target            : ret = "target";  break;
        case dev_FieldId_compat            : ret = "compat";  break;
        case dev_FieldId_targsrc           : ret = "targsrc";  break;
        case dev_FieldId_targsyslib        : ret = "targsyslib";  break;
        case dev_FieldId_cov_min           : ret = "cov_min";  break;
        case dev_FieldId_maxerr            : ret = "maxerr";  break;
        case dev_FieldId_timefmt           : ret = "timefmt";  break;
        case dev_FieldId_dirname           : ret = "dirname";  break;
        case dev_FieldId_tool_opt          : ret = "tool_opt";  break;
        case dev_FieldId_opt               : ret = "opt";  break;
        case dev_FieldId_sortfld           : ret = "sortfld";  break;
        case dev_FieldId_field             : ret = "field";  break;
        case dev_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- dev.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dev::value_Print(const dev::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dev.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('a','r'): {
                    value_SetEnum(parent,dev_FieldId_ar); ret = true; break;
                }
                case LE_STR2('m','r'): {
                    value_SetEnum(parent,dev_FieldId_mr); ret = true; break;
                }
                case LE_STR2('r','c'): {
                    value_SetEnum(parent,dev_FieldId_rc); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,dev_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('c','o','v'): {
                    value_SetEnum(parent,dev_FieldId_cov); ret = true; break;
                }
                case LE_STR3('e','x','e'): {
                    value_SetEnum(parent,dev_FieldId_exe); ret = true; break;
                }
                case LE_STR3('e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_ext); ret = true; break;
                }
                case LE_STR3('h','i','t'): {
                    value_SetEnum(parent,dev_FieldId_hit); ret = true; break;
                }
                case LE_STR3('i','i','d'): {
                    value_SetEnum(parent,dev_FieldId_iid); ret = true; break;
                }
                case LE_STR3('i','n','l'): {
                    value_SetEnum(parent,dev_FieldId_inl); ret = true; break;
                }
                case LE_STR3('o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_opt); ret = true; break;
                }
                case LE_STR3('p','i','d'): {
                    value_SetEnum(parent,dev_FieldId_pid); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dev_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_src); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dev_FieldId_sys); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,dev_FieldId_arch); ret = true; break;
                }
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,dev_FieldId_code); ret = true; break;
                }
                case LE_STR4('e','x','c','l'): {
                    value_SetEnum(parent,dev_FieldId_excl); ret = true; break;
                }
                case LE_STR4('e','x','e','r'): {
                    value_SetEnum(parent,dev_FieldId_exer); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dev_FieldId_expr); ret = true; break;
                }
                case LE_STR4('f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_file); ret = true; break;
                }
                case LE_STR4('f','l','a','g'): {
                    value_SetEnum(parent,dev_FieldId_flag); ret = true; break;
                }
                case LE_STR4('l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_line); ret = true; break;
                }
                case LE_STR4('l','i','n','k'): {
                    value_SetEnum(parent,dev_FieldId_link); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_text); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('c','h','i','l','d'): {
                    value_SetEnum(parent,dev_FieldId_child); ret = true; break;
                }
                case LE_STR5('c','o','l','o','r'): {
                    value_SetEnum(parent,dev_FieldId_color); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,dev_FieldId_field); ret = true; break;
                }
                case LE_STR5('i','s','s','u','e'): {
                    value_SetEnum(parent,dev_FieldId_issue); ret = true; break;
                }
                case LE_STR5('l','s','c','m','d'): {
                    value_SetEnum(parent,dev_FieldId_lscmd); ret = true; break;
                }
                case LE_STR5('m','a','x','w','s'): {
                    value_SetEnum(parent,dev_FieldId_maxws); ret = true; break;
                }
                case LE_STR5('t','i','t','l','e'): {
                    value_SetEnum(parent,dev_FieldId_title); ret = true; break;
                }
                case LE_STR5('t','o','t','a','l'): {
                    value_SetEnum(parent,dev_FieldId_total); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dev_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','u','t','h','o','r'): {
                    value_SetEnum(parent,dev_FieldId_author); ret = true; break;
                }
                case LE_STR6('c','o','m','p','a','t'): {
                    value_SetEnum(parent,dev_FieldId_compat); ret = true; break;
                }
                case LE_STR6('e','x','e','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_exeext); ret = true; break;
                }
                case LE_STR6('f','i','l','t','e','r'): {
                    value_SetEnum(parent,dev_FieldId_filter); ret = true; break;
                }
                case LE_STR6('h','i','l','i','t','e'): {
                    value_SetEnum(parent,dev_FieldId_hilite); ret = true; break;
                }
                case LE_STR6('l','a','b','e','l','s'): {
                    value_SetEnum(parent,dev_FieldId_labels); ret = true; break;
                }
                case LE_STR6('l','i','b','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_libext); ret = true; break;
                }
                case LE_STR6('m','a','x','e','r','r'): {
                    value_SetEnum(parent,dev_FieldId_maxerr); ret = true; break;
                }
                case LE_STR6('n','b','a','d','w','s'): {
                    value_SetEnum(parent,dev_FieldId_nbadws); ret = true; break;
                }
                case LE_STR6('n','o','n','e','x','e'): {
                    value_SetEnum(parent,dev_FieldId_nonexe); ret = true; break;
                }
                case LE_STR6('o','b','j','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_objext); ret = true; break;
                }
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_parent); ret = true; break;
                }
                case LE_STR6('p','c','h','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_pchext); ret = true; break;
                }
                case LE_STR6('r','a','n','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_ranlib); ret = true; break;
                }
                case LE_STR6('s','b','p','a','t','h'): {
                    value_SetEnum(parent,dev_FieldId_sbpath); ret = true; break;
                }
                case LE_STR6('s','s','i','m','f','s'): {
                    value_SetEnum(parent,dev_FieldId_ssimfs); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,dev_FieldId_status); ret = true; break;
                }
                case LE_STR6('s','t','r','i','c','t'): {
                    value_SetEnum(parent,dev_FieldId_strict); ret = true; break;
                }
                case LE_STR6('s','u','f','f','i','x'): {
                    value_SetEnum(parent,dev_FieldId_suffix); ret = true; break;
                }
                case LE_STR6('s','y','s','c','m','d'): {
                    value_SetEnum(parent,dev_FieldId_syscmd); ret = true; break;
                }
                case LE_STR6('s','y','s','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_syslib); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,dev_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_badline); ret = true; break;
                }
                case LE_STR7('b','a','d','n','e','s','s'): {
                    value_SetEnum(parent,dev_FieldId_badness); ret = true; break;
                }
                case LE_STR7('c','o','m','m','a','n','d'): {
                    value_SetEnum(parent,dev_FieldId_command); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','m','p','v','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compver); ret = true; break;
                }
                case LE_STR7('c','o','v','_','m','i','n'): {
                    value_SetEnum(parent,dev_FieldId_cov_min); ret = true; break;
                }
                case LE_STR7('c','o','v','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_covfile); ret = true; break;
                }
                case LE_STR7('c','o','v','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_covline); ret = true; break;
                }
                case LE_STR7('d','i','r','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_dirname); ret = true; break;
                }
                case LE_STR7('e','x','e','c','k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_execkey); ret = true; break;
                }
                case LE_STR7('g','i','t','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_gitfile); ret = true; break;
                }
                case LE_STR7('g','i','t','i','n','f','o'): {
                    value_SetEnum(parent,dev_FieldId_gitinfo); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,dev_FieldId_include); ret = true; break;
                }
                case LE_STR7('l','i','c','e','n','s','e'): {
                    value_SetEnum(parent,dev_FieldId_license); ret = true; break;
                }
                case LE_STR7('m','a','x','t','i','m','e'): {
                    value_SetEnum(parent,dev_FieldId_maxtime); ret = true; break;
                }
                case LE_STR7('n','p','r','e','r','e','q'): {
                    value_SetEnum(parent,dev_FieldId_nprereq); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,dev_FieldId_package); ret = true; break;
                }
                case LE_STR7('p','r','o','j','e','c','t'): {
                    value_SetEnum(parent,dev_FieldId_project); ret = true; break;
                }
                case LE_STR7('s','a','n','d','b','o','x'): {
                    value_SetEnum(parent,dev_FieldId_sandbox); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,dev_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('t','a','r','g','d','e','p'): {
                    value_SetEnum(parent,dev_FieldId_targdep); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_targsrc); ret = true; break;
                }
                case LE_STR7('t','i','m','e','f','m','t'): {
                    value_SetEnum(parent,dev_FieldId_timefmt); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','s','s','i','g','n','e','e'): {
                    value_SetEnum(parent,dev_FieldId_assignee); ret = true; break;
                }
                case LE_STR8('b','u','i','l','d','d','i','r'): {
                    value_SetEnum(parent,dev_FieldId_builddir); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('f','i','l','e','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_filename); ret = true; break;
                }
                case LE_STR8('o','p','t','_','t','y','p','e'): {
                    value_SetEnum(parent,dev_FieldId_opt_type); ret = true; break;
                }
                case LE_STR8('s','s','i','m','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_ssimfile); ret = true; break;
                }
                case LE_STR8('t','o','o','l','_','o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_tool_opt); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','m','p','l','e','t','e'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dev_FieldId_completed); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','v','t','a','r','g','e'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dev_FieldId_covtarget); ret = true; break; }
                    break;
                }
                case LE_STR8('m','i','l','e','s','t','o','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_milestone); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','f','u','n'): {
                    if (memcmp(rhs.elems+8,"c",1)==0) { value_SetEnum(parent,dev_FieldId_nlongfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','l','i','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_nlongline); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','s','c','m','d','d','e'): {
                    if (memcmp(rhs.elems+8,"p",1)==0) { value_SetEnum(parent,dev_FieldId_syscmddep); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('h','t','m','l','e','n','t','i'): {
                    if (memcmp(rhs.elems+8,"ty",2)==0) { value_SetEnum(parent,dev_FieldId_htmlentity); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,dev_FieldId_targsyslib); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','a','i','l','_','p','r','e'): {
                    if (memcmp(rhs.elems+8,"req",3)==0) { value_SetEnum(parent,dev_FieldId_fail_prereq); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','f'): {
                    if (memcmp(rhs.elems+8,"unc",3)==0) { value_SetEnum(parent,dev_FieldId_longestfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dev_FieldId_longestline); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('n','m','y','s','t','e','r','y'): {
                    if (memcmp(rhs.elems+8,"func",4)==0) { value_SetEnum(parent,dev_FieldId_nmysteryfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','r','c','_'): {
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,dev_FieldId_targsrc_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','o','u','r','c','e','_','b'): {
                    if (memcmp(rhs.elems+8,"ranch",5)==0) { value_SetEnum(parent,dev_FieldId_source_branch); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','i','p','e','l','i','n','e'): {
                    if (memcmp(rhs.elems+8,"_status",7)==0) { value_SetEnum(parent,dev_FieldId_pipeline_status); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::value_SetStrptr(dev::FieldId& parent, algo::strptr rhs, dev_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dev.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::value_ReadStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dev.FieldId..ReadStrptrMaybe
// Read fields of dev::FieldId from an ascii string.
// The format of the string is the format of the dev::FieldId's only field
bool dev::FieldId_ReadStrptrMaybe(dev::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dev.FieldId..Print
// print string representation of dev::FieldId to string LHS, no header -- cprint:dev.FieldId.String
void dev::FieldId_Print(dev::FieldId & row, algo::cstring &str) {
    dev::value_Print(row, str);
}

// --- dev.Gitfile.ext.Get
algo::Smallstr50 dev::ext_Get(dev::Gitfile& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gitfile, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile.ext.Get2
algo::Smallstr50 dev::Gitfile_ext_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile..ReadFieldMaybe
bool dev::Gitfile_ReadFieldMaybe(dev::Gitfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_ext: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitfile..ReadStrptrMaybe
// Read fields of dev::Gitfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitfile_ReadStrptrMaybe(dev::Gitfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitfile") || algo::StripTypeTag(in_str, "dev.Gitfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitfile..Print
// print string representation of dev::Gitfile to string LHS, no header -- cprint:dev.Gitfile.String
void dev::Gitfile_Print(dev::Gitfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);
}

// --- dev.Gitinfo..ReadFieldMaybe
bool dev::Gitinfo_ReadFieldMaybe(dev::Gitinfo &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitinfo: retval = algo::Smallstr40_ReadStrptrMaybe(parent.gitinfo, strval); break;
        case dev_FieldId_author: retval = algo::Smallstr50_ReadStrptrMaybe(parent.author, strval); break;
        case dev_FieldId_cfg: retval = algo::Smallstr40_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_compver: retval = algo::Smallstr20_ReadStrptrMaybe(parent.compver, strval); break;
        case dev_FieldId_package: retval = algo::Smallstr40_ReadStrptrMaybe(parent.package, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitinfo..ReadStrptrMaybe
// Read fields of dev::Gitinfo from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitinfo_ReadStrptrMaybe(dev::Gitinfo &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitinfo") || algo::StripTypeTag(in_str, "dev.Gitinfo");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitinfo_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitinfo..Print
// print string representation of dev::Gitinfo to string LHS, no header -- cprint:dev.Gitinfo.String
void dev::Gitinfo_Print(dev::Gitinfo & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitinfo";

    algo::Smallstr40_Print(row.gitinfo, temp);
    PrintAttrSpaceReset(str,"gitinfo", temp);

    algo::Smallstr50_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr40_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr20_Print(row.compver, temp);
    PrintAttrSpaceReset(str,"compver", temp);

    algo::Smallstr40_Print(row.package, temp);
    PrintAttrSpaceReset(str,"package", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Hilite..ReadFieldMaybe
bool dev::Hilite_ReadFieldMaybe(dev::Hilite &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_hilite: retval = algo::Smallstr50_ReadStrptrMaybe(parent.hilite, strval); break;
        case dev_FieldId_color: retval = algo::Smallstr50_ReadStrptrMaybe(parent.color, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Hilite..ReadStrptrMaybe
// Read fields of dev::Hilite from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Hilite_ReadStrptrMaybe(dev::Hilite &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.hilite") || algo::StripTypeTag(in_str, "dev.Hilite");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hilite_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Hilite..Print
// print string representation of dev::Hilite to string LHS, no header -- cprint:dev.Hilite.String
void dev::Hilite_Print(dev::Hilite & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.hilite";

    algo::Smallstr50_Print(row.hilite, temp);
    PrintAttrSpaceReset(str,"hilite", temp);

    algo::Smallstr50_Print(row.color, temp);
    PrintAttrSpaceReset(str,"color", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Htmlentity..ReadFieldMaybe
bool dev::Htmlentity_ReadFieldMaybe(dev::Htmlentity &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_htmlentity: retval = algo::Smallstr50_ReadStrptrMaybe(parent.htmlentity, strval); break;
        case dev_FieldId_code: retval = i32_ReadStrptrMaybe(parent.code, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Htmlentity..ReadStrptrMaybe
// Read fields of dev::Htmlentity from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Htmlentity_ReadStrptrMaybe(dev::Htmlentity &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.htmlentity") || algo::StripTypeTag(in_str, "dev.Htmlentity");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Htmlentity_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Htmlentity..Print
// print string representation of dev::Htmlentity to string LHS, no header -- cprint:dev.Htmlentity.String
void dev::Htmlentity_Print(dev::Htmlentity & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.htmlentity";

    algo::Smallstr50_Print(row.htmlentity, temp);
    PrintAttrSpaceReset(str,"htmlentity", temp);

    i32_Print(row.code, temp);
    PrintAttrSpaceReset(str,"code", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Include.srcfile.Get
algo::Smallstr200 dev::srcfile_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LL"));
    return ret;
}

// --- dev.Include.srcfile.Get2
algo::Smallstr200 dev::Include_srcfile_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dev.Include.filename.Get
algo::Smallstr200 dev::filename_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LR"));
    return ret;
}

// --- dev.Include.filename.Get2
algo::Smallstr200 dev::Include_filename_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dev.Include..Concat_srcfile_filename
tempstr dev::Include_Concat_srcfile_filename( const algo::strptr& srcfile ,const algo::strptr& filename ) {
    return tempstr() << srcfile <<':'<< filename ;
}

// --- dev.Include..ReadFieldMaybe
bool dev::Include_ReadFieldMaybe(dev::Include &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_include: retval = algo::Smallstr200_ReadStrptrMaybe(parent.include, strval); break;
        case dev_FieldId_srcfile: retval = false; break;
        case dev_FieldId_filename: retval = false; break;
        case dev_FieldId_sys: retval = bool_ReadStrptrMaybe(parent.sys, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Include..ReadStrptrMaybe
// Read fields of dev::Include from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Include_ReadStrptrMaybe(dev::Include &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Include");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Include_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Include..Print
// print string representation of dev::Include to string LHS, no header -- cprint:dev.Include.String
void dev::Include_Print(dev::Include & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Include";

    algo::Smallstr200_Print(row.include, temp);
    PrintAttrSpaceReset(str,"include", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Issue.project.Get
algo::Smallstr50 dev::project_Get(dev::Issue& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issue, ".RL"));
    return ret;
}

// --- dev.Issue.project.Get2
algo::Smallstr50 dev::Issue_project_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Issue.iid.Get
u32 dev::iid_Get(dev::Issue& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.issue, ".RR"));
    return ret;
}

// --- dev.Issue.iid.Get2
u32 dev::Issue_iid_Get(algo::strptr arg) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Issue..Concat_project_iid
tempstr dev::Issue_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- dev.Issue..ReadFieldMaybe
bool dev::Issue_ReadFieldMaybe(dev::Issue &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_issue: retval = algo::Smallstr50_ReadStrptrMaybe(parent.issue, strval); break;
        case dev_FieldId_project: retval = false; break;
        case dev_FieldId_assignee: retval = algo::Smallstr50_ReadStrptrMaybe(parent.assignee, strval); break;
        case dev_FieldId_labels: retval = algo::cstring_ReadStrptrMaybe(parent.labels, strval); break;
        case dev_FieldId_milestone: retval = algo::cstring_ReadStrptrMaybe(parent.milestone, strval); break;
        case dev_FieldId_iid: retval = false; break;
        case dev_FieldId_title: retval = algo::cstring_ReadStrptrMaybe(parent.title, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Issue..ReadStrptrMaybe
// Read fields of dev::Issue from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Issue_ReadStrptrMaybe(dev::Issue &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Issue");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Issue_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Issue..Print
// print string representation of dev::Issue to string LHS, no header -- cprint:dev.Issue.String
void dev::Issue_Print(dev::Issue & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Issue";

    algo::Smallstr50_Print(row.issue, temp);
    PrintAttrSpaceReset(str,"issue", temp);

    algo::Smallstr50_Print(row.assignee, temp);
    PrintAttrSpaceReset(str,"assignee", temp);

    algo::cstring_Print(row.labels, temp);
    PrintAttrSpaceReset(str,"labels", temp);

    algo::cstring_Print(row.milestone, temp);
    PrintAttrSpaceReset(str,"milestone", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);
}

// --- dev.License..ReadFieldMaybe
bool dev::License_ReadFieldMaybe(dev::License &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_license: retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.License..ReadStrptrMaybe
// Read fields of dev::License from an ascii string.
// The format of the string is an ssim Tuple
bool dev::License_ReadStrptrMaybe(dev::License &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.license") || algo::StripTypeTag(in_str, "dev.License");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && License_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.License..Print
// print string representation of dev::License to string LHS, no header -- cprint:dev.License.String
void dev::License_Print(dev::License & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.license";

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Linelim..ReadFieldMaybe
bool dev::Linelim_ReadFieldMaybe(dev::Linelim &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_nlongline: retval = u32_ReadStrptrMaybe(parent.nlongline, strval); break;
        case dev_FieldId_longestline: retval = u32_ReadStrptrMaybe(parent.longestline, strval); break;
        case dev_FieldId_nbadws: retval = u32_ReadStrptrMaybe(parent.nbadws, strval); break;
        case dev_FieldId_maxws: retval = u32_ReadStrptrMaybe(parent.maxws, strval); break;
        case dev_FieldId_nlongfunc: retval = u32_ReadStrptrMaybe(parent.nlongfunc, strval); break;
        case dev_FieldId_longestfunc: retval = u32_ReadStrptrMaybe(parent.longestfunc, strval); break;
        case dev_FieldId_nmysteryfunc: retval = u32_ReadStrptrMaybe(parent.nmysteryfunc, strval); break;
        case dev_FieldId_badness: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badness, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Linelim..ReadStrptrMaybe
// Read fields of dev::Linelim from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Linelim_ReadStrptrMaybe(dev::Linelim &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.linelim") || algo::StripTypeTag(in_str, "dev.Linelim");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Linelim_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Linelim..Print
// print string representation of dev::Linelim to string LHS, no header -- cprint:dev.Linelim.String
void dev::Linelim_Print(dev::Linelim & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.linelim";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    u32_Print(row.nlongline, temp);
    PrintAttrSpaceReset(str,"nlongline", temp);

    u32_Print(row.longestline, temp);
    PrintAttrSpaceReset(str,"longestline", temp);

    u32_Print(row.nbadws, temp);
    PrintAttrSpaceReset(str,"nbadws", temp);

    u32_Print(row.maxws, temp);
    PrintAttrSpaceReset(str,"maxws", temp);

    u32_Print(row.nlongfunc, temp);
    PrintAttrSpaceReset(str,"nlongfunc", temp);

    u32_Print(row.longestfunc, temp);
    PrintAttrSpaceReset(str,"longestfunc", temp);

    u32_Print(row.nmysteryfunc, temp);
    PrintAttrSpaceReset(str,"nmysteryfunc", temp);

    algo::Smallstr50_Print(row.badness, temp);
    PrintAttrSpaceReset(str,"badness", temp);
}

// --- dev.Mr.project.Get
algo::Smallstr50 dev::project_Get(dev::Mr& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.mr, ".RL"));
    return ret;
}

// --- dev.Mr.project.Get2
algo::Smallstr50 dev::Mr_project_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Mr.iid.Get
u32 dev::iid_Get(dev::Mr& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.mr, ".RR"));
    return ret;
}

// --- dev.Mr.iid.Get2
u32 dev::Mr_iid_Get(algo::strptr arg) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Mr..Concat_project_iid
tempstr dev::Mr_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- dev.Mr..ReadFieldMaybe
bool dev::Mr_ReadFieldMaybe(dev::Mr &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_mr: retval = algo::Smallstr50_ReadStrptrMaybe(parent.mr, strval); break;
        case dev_FieldId_project: retval = false; break;
        case dev_FieldId_iid: retval = false; break;
        case dev_FieldId_title: retval = algo::cstring_ReadStrptrMaybe(parent.title, strval); break;
        case dev_FieldId_source_branch: retval = algo::cstring_ReadStrptrMaybe(parent.source_branch, strval); break;
        case dev_FieldId_pipeline_status: retval = algo::Smallstr20_ReadStrptrMaybe(parent.pipeline_status, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Mr..ReadStrptrMaybe
// Read fields of dev::Mr from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Mr_ReadStrptrMaybe(dev::Mr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Mr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Mr..Print
// print string representation of dev::Mr to string LHS, no header -- cprint:dev.Mr.String
void dev::Mr_Print(dev::Mr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Mr";

    algo::Smallstr50_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.source_branch, temp);
    PrintAttrSpaceReset(str,"source_branch", temp);

    algo::Smallstr20_Print(row.pipeline_status, temp);
    PrintAttrSpaceReset(str,"pipeline_status", temp);
}

// --- dev.Msgfile..ReadFieldMaybe
bool dev::Msgfile_ReadFieldMaybe(dev::Msgfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_strict: retval = bool_ReadStrptrMaybe(parent.strict, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Msgfile..ReadStrptrMaybe
// Read fields of dev::Msgfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Msgfile_ReadStrptrMaybe(dev::Msgfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.msgfile") || algo::StripTypeTag(in_str, "dev.Msgfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Msgfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Msgfile..Print
// print string representation of dev::Msgfile to string LHS, no header -- cprint:dev.Msgfile.String
void dev::Msgfile_Print(dev::Msgfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.msgfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Noindent..ReadFieldMaybe
bool dev::Noindent_ReadFieldMaybe(dev::Noindent &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Noindent..ReadStrptrMaybe
// Read fields of dev::Noindent from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Noindent_ReadStrptrMaybe(dev::Noindent &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.noindent") || algo::StripTypeTag(in_str, "dev.Noindent");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Noindent_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Noindent..Print
// print string representation of dev::Noindent to string LHS, no header -- cprint:dev.Noindent.String
void dev::Noindent_Print(dev::Noindent & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.noindent";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.OptType..ReadFieldMaybe
bool dev::OptType_ReadFieldMaybe(dev::OptType &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_opt_type: retval = algo::Smallstr50_ReadStrptrMaybe(parent.opt_type, strval); break;
        case dev_FieldId_sep: retval = algo::RspaceStr4_ReadStrptrMaybe(parent.sep, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.OptType..ReadStrptrMaybe
// Read fields of dev::OptType from an ascii string.
// The format of the string is an ssim Tuple
bool dev::OptType_ReadStrptrMaybe(dev::OptType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.opt_type") || algo::StripTypeTag(in_str, "dev.OptType");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptType_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.OptType..Print
// print string representation of dev::OptType to string LHS, no header -- cprint:dev.OptType.String
void dev::OptType_Print(dev::OptType & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.opt_type";

    algo::Smallstr50_Print(row.opt_type, temp);
    PrintAttrSpaceReset(str,"opt_type", temp);

    algo::RspaceStr4_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Readme..ReadFieldMaybe
bool dev::Readme_ReadFieldMaybe(dev::Readme &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_inl: retval = bool_ReadStrptrMaybe(parent.inl, strval); break;
        case dev_FieldId_sandbox: retval = bool_ReadStrptrMaybe(parent.sandbox, strval); break;
        case dev_FieldId_filter: retval = algo::Smallstr100_ReadStrptrMaybe(parent.filter, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Readme..ReadStrptrMaybe
// Read fields of dev::Readme from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Readme_ReadStrptrMaybe(dev::Readme &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.readme") || algo::StripTypeTag(in_str, "dev.Readme");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Readme_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Readme..Print
// print string representation of dev::Readme to string LHS, no header -- cprint:dev.Readme.String
void dev::Readme_Print(dev::Readme & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.readme";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    bool_Print(row.inl, temp);
    PrintAttrSpaceReset(str,"inl", temp);

    bool_Print(row.sandbox, temp);
    PrintAttrSpaceReset(str,"sandbox", temp);

    algo::Smallstr100_Print(row.filter, temp);
    PrintAttrSpaceReset(str,"filter", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Sandbox..ReadFieldMaybe
bool dev::Sandbox_ReadFieldMaybe(dev::Sandbox &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_sandbox: retval = algo::Smallstr50_ReadStrptrMaybe(parent.sandbox, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Sandbox..ReadStrptrMaybe
// Read fields of dev::Sandbox from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Sandbox_ReadStrptrMaybe(dev::Sandbox &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.sandbox") || algo::StripTypeTag(in_str, "dev.Sandbox");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sandbox_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Sandbox..Print
// print string representation of dev::Sandbox to string LHS, no header -- cprint:dev.Sandbox.String
void dev::Sandbox_Print(dev::Sandbox & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.sandbox";

    algo::Smallstr50_Print(row.sandbox, temp);
    PrintAttrSpaceReset(str,"sandbox", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Sbpath..ReadFieldMaybe
bool dev::Sbpath_ReadFieldMaybe(dev::Sbpath &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_sbpath: retval = algo::Smallstr50_ReadStrptrMaybe(parent.sbpath, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Sbpath..ReadStrptrMaybe
// Read fields of dev::Sbpath from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Sbpath_ReadStrptrMaybe(dev::Sbpath &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.sbpath") || algo::StripTypeTag(in_str, "dev.Sbpath");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sbpath_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Sbpath..Print
// print string representation of dev::Sbpath to string LHS, no header -- cprint:dev.Sbpath.String
void dev::Sbpath_Print(dev::Sbpath & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.sbpath";

    algo::Smallstr50_Print(row.sbpath, temp);
    PrintAttrSpaceReset(str,"sbpath", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Scriptfile..ReadFieldMaybe
bool dev::Scriptfile_ReadFieldMaybe(dev::Scriptfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_license: retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Scriptfile..ReadStrptrMaybe
// Read fields of dev::Scriptfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Scriptfile_ReadStrptrMaybe(dev::Scriptfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.scriptfile") || algo::StripTypeTag(in_str, "dev.Scriptfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Scriptfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Scriptfile..Print
// print string representation of dev::Scriptfile to string LHS, no header -- cprint:dev.Scriptfile.String
void dev::Scriptfile_Print(dev::Scriptfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.scriptfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Srcfile.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Srcfile& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.srcfile, ".RR"));
    return ret;
}

// --- dev.Srcfile.ext.Get2
algo::Smallstr10 dev::Srcfile_ext_Get(algo::strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Srcfile..ReadFieldMaybe
bool dev::Srcfile_ReadFieldMaybe(dev::Srcfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_srcfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.srcfile, strval); break;
        case dev_FieldId_ext: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Srcfile..ReadStrptrMaybe
// Read fields of dev::Srcfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Srcfile_ReadStrptrMaybe(dev::Srcfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.srcfile") || algo::StripTypeTag(in_str, "dev.Srcfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Srcfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Srcfile..Print
// print string representation of dev::Srcfile to string LHS, no header -- cprint:dev.Srcfile.String
void dev::Srcfile_Print(dev::Srcfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.srcfile";

    algo::Smallstr200_Print(row.srcfile, temp);
    PrintAttrSpaceReset(str,"srcfile", temp);
}

// --- dev.Ssimfs.ssimfile.Get
algo::Smallstr50 dev::ssimfile_Get(dev::Ssimfs& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ssimfs, ":LL"));
    return ret;
}

// --- dev.Ssimfs.ssimfile.Get2
algo::Smallstr50 dev::Ssimfs_ssimfile_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dev.Ssimfs.file.Get
algo::Smallstr150 dev::file_Get(dev::Ssimfs& parent) {
    algo::Smallstr150 ret(algo::Pathcomp(parent.ssimfs, ":LR"));
    return ret;
}

// --- dev.Ssimfs.file.Get2
algo::Smallstr150 dev::Ssimfs_file_Get(algo::strptr arg) {
    algo::Smallstr150 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dev.Ssimfs.excl.Print
// Print back to string
void dev::excl_Print(dev::Ssimfs& parent, algo::cstring &out) {
    Regx_Print(parent.excl, out);
}

// --- dev.Ssimfs.excl.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool dev::excl_ReadStrptrMaybe(dev::Ssimfs& parent, algo::strptr in) {
    Regx_ReadSql(parent.excl, in, false);
    bool retval = true;// !parent.excl.parseerror; -- TODO: uncomment
    return retval;
}

// --- dev.Ssimfs..Concat_ssimfile_file
tempstr dev::Ssimfs_Concat_ssimfile_file( const algo::strptr& ssimfile ,const algo::strptr& file ) {
    return tempstr() << ssimfile <<':'<< file ;
}

// --- dev.Ssimfs..ReadFieldMaybe
bool dev::Ssimfs_ReadFieldMaybe(dev::Ssimfs &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_ssimfs: retval = algo::Smallstr200_ReadStrptrMaybe(parent.ssimfs, strval); break;
        case dev_FieldId_ssimfile: retval = false; break;
        case dev_FieldId_file: retval = false; break;
        case dev_FieldId_lscmd: retval = algo::cstring_ReadStrptrMaybe(parent.lscmd, strval); break;
        case dev_FieldId_excl: retval = excl_ReadStrptrMaybe(parent, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Ssimfs..ReadStrptrMaybe
// Read fields of dev::Ssimfs from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Ssimfs_ReadStrptrMaybe(dev::Ssimfs &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.ssimfs") || algo::StripTypeTag(in_str, "dev.Ssimfs");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimfs_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Ssimfs..Print
// print string representation of dev::Ssimfs to string LHS, no header -- cprint:dev.Ssimfs.String
void dev::Ssimfs_Print(dev::Ssimfs & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.ssimfs";

    algo::Smallstr200_Print(row.ssimfs, temp);
    PrintAttrSpaceReset(str,"ssimfs", temp);

    algo::cstring_Print(row.lscmd, temp);
    PrintAttrSpaceReset(str,"lscmd", temp);

    dev::excl_Print(row, temp);
    PrintAttrSpaceReset(str,"excl", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Syscmd..ReadFieldMaybe
bool dev::Syscmd_ReadFieldMaybe(dev::Syscmd &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syscmd: retval = i64_ReadStrptrMaybe(parent.syscmd, strval); break;
        case dev_FieldId_execkey: retval = false; break;
        case dev_FieldId_command: retval = algo::cstring_ReadStrptrMaybe(parent.command, strval); break;
        case dev_FieldId_pid: retval = i32_ReadStrptrMaybe(parent.pid, strval); break;
        case dev_FieldId_status: retval = i32_ReadStrptrMaybe(parent.status, strval); break;
        case dev_FieldId_nprereq: retval = i32_ReadStrptrMaybe(parent.nprereq, strval); break;
        case dev_FieldId_fail_prereq: retval = bool_ReadStrptrMaybe(parent.fail_prereq, strval); break;
        case dev_FieldId_completed: retval = bool_ReadStrptrMaybe(parent.completed, strval); break;
        case dev_FieldId_maxtime: retval = i32_ReadStrptrMaybe(parent.maxtime, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmd..ReadStrptrMaybe
// Read fields of dev::Syscmd from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmd_ReadStrptrMaybe(dev::Syscmd &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmd");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmd_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmd..Print
// print string representation of dev::Syscmd to string LHS, no header -- cprint:dev.Syscmd.String
void dev::Syscmd_Print(dev::Syscmd & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmd";

    i64_Print(row.syscmd, temp);
    PrintAttrSpaceReset(str,"syscmd", temp);

    algo::cstring_Print(row.command, temp);
    PrintAttrSpaceReset(str,"command", temp);

    i32_Print(row.pid, temp);
    PrintAttrSpaceReset(str,"pid", temp);

    i32_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    i32_Print(row.nprereq, temp);
    PrintAttrSpaceReset(str,"nprereq", temp);

    bool_Print(row.fail_prereq, temp);
    PrintAttrSpaceReset(str,"fail_prereq", temp);

    bool_Print(row.completed, temp);
    PrintAttrSpaceReset(str,"completed", temp);

    i32_Print(row.maxtime, temp);
    PrintAttrSpaceReset(str,"maxtime", temp);
}

// --- dev.Syscmddep..ReadFieldMaybe
bool dev::Syscmddep_ReadFieldMaybe(dev::Syscmddep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syscmddep: retval = false; break;
        case dev_FieldId_child: retval = i64_ReadStrptrMaybe(parent.child, strval); break;
        case dev_FieldId_parent: retval = i64_ReadStrptrMaybe(parent.parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmddep..ReadStrptrMaybe
// Read fields of dev::Syscmddep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmddep_ReadStrptrMaybe(dev::Syscmddep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmddep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmddep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmddep..Print
// print string representation of dev::Syscmddep to string LHS, no header -- cprint:dev.Syscmddep.String
void dev::Syscmddep_Print(dev::Syscmddep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmddep";

    i64_Print(row.child, temp);
    PrintAttrSpaceReset(str,"child", temp);

    i64_Print(row.parent, temp);
    PrintAttrSpaceReset(str,"parent", temp);
}

// --- dev.Syslib..ReadFieldMaybe
bool dev::Syslib_ReadFieldMaybe(dev::Syslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.syslib, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syslib..ReadStrptrMaybe
// Read fields of dev::Syslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syslib_ReadStrptrMaybe(dev::Syslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syslib") || algo::StripTypeTag(in_str, "dev.Syslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syslib..Print
// print string representation of dev::Syslib to string LHS, no header -- cprint:dev.Syslib.String
void dev::Syslib_Print(dev::Syslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.syslib";

    algo::Smallstr50_Print(row.syslib, temp);
    PrintAttrSpaceReset(str,"syslib", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targdep.target.Get
algo::Smallstr16 dev::target_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RL"));
    return ret;
}

// --- dev.Targdep.target.Get2
algo::Smallstr16 dev::Targdep_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targdep.parent.Get
algo::Smallstr16 dev::parent_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RR"));
    return ret;
}

// --- dev.Targdep.parent.Get2
algo::Smallstr16 dev::Targdep_parent_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targdep..Concat_target_parent
tempstr dev::Targdep_Concat_target_parent( const algo::strptr& target ,const algo::strptr& parent ) {
    return tempstr() << target <<'.'<< parent ;
}

// --- dev.Targdep..ReadFieldMaybe
bool dev::Targdep_ReadFieldMaybe(dev::Targdep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targdep: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targdep, strval); break;
        case dev_FieldId_target: retval = false; break;
        case dev_FieldId_parent: retval = false; break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targdep..ReadStrptrMaybe
// Read fields of dev::Targdep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targdep_ReadStrptrMaybe(dev::Targdep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targdep") || algo::StripTypeTag(in_str, "dev.Targdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targdep..Print
// print string representation of dev::Targdep to string LHS, no header -- cprint:dev.Targdep.String
void dev::Targdep_Print(dev::Targdep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targdep";

    algo::Smallstr50_Print(row.targdep, temp);
    PrintAttrSpaceReset(str,"targdep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Target..ReadFieldMaybe
bool dev::Target_ReadFieldMaybe(dev::Target &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case dev_FieldId_compat: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compat, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Target..ReadStrptrMaybe
// Read fields of dev::Target from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Target_ReadStrptrMaybe(dev::Target &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.target") || algo::StripTypeTag(in_str, "dev.Target");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Target_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Target..Print
// print string representation of dev::Target to string LHS, no header -- cprint:dev.Target.String
void dev::Target_Print(dev::Target & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.target";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::Smallstr50_Print(row.compat, temp);
    PrintAttrSpaceReset(str,"compat", temp);
}

// --- dev.Targsrc.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsrc& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsrc, "/LL"));
    return ret;
}

// --- dev.Targsrc.target.Get2
algo::Smallstr16 dev::Targsrc_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Targsrc.src.Get
algo::Smallstr200 dev::src_Get(dev::Targsrc& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.targsrc, "/LR"));
    return ret;
}

// --- dev.Targsrc.src.Get2
algo::Smallstr200 dev::Targsrc_src_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dev.Targsrc.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Targsrc& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.targsrc, ".RR"));
    return ret;
}

// --- dev.Targsrc.ext.Get2
algo::Smallstr10 dev::Targsrc_ext_Get(algo::strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsrc..Concat_target_src
tempstr dev::Targsrc_Concat_target_src( const algo::strptr& target ,const algo::strptr& src ) {
    return tempstr() << target <<'/'<< src ;
}

// --- dev.Targsrc..ReadFieldMaybe
bool dev::Targsrc_ReadFieldMaybe(dev::Targsrc &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsrc: retval = algo::Smallstr100_ReadStrptrMaybe(parent.targsrc, strval); break;
        case dev_FieldId_target: retval = false; break;
        case dev_FieldId_src: retval = false; break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        case dev_FieldId_ext: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsrc..ReadStrptrMaybe
// Read fields of dev::Targsrc from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsrc_ReadStrptrMaybe(dev::Targsrc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsrc") || algo::StripTypeTag(in_str, "dev.Targsrc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsrc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsrc..Print
// print string representation of dev::Targsrc to string LHS, no header -- cprint:dev.Targsrc.String
void dev::Targsrc_Print(dev::Targsrc & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsrc";

    algo::Smallstr100_Print(row.targsrc, temp);
    PrintAttrSpaceReset(str,"targsrc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targsyslib.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsyslib& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsyslib, ".RL"));
    return ret;
}

// --- dev.Targsyslib.target.Get2
algo::Smallstr16 dev::Targsyslib_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get
algo::Smallstr50 dev::syslib_Get(dev::Targsyslib& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsyslib, ".RR"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get2
algo::Smallstr50 dev::Targsyslib_syslib_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsyslib.uname.Print
// Print back to string
void dev::uname_Print(dev::Targsyslib& parent, algo::cstring &out) {
    Regx_Print(parent.uname, out);
}

// --- dev.Targsyslib.uname.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool dev::uname_ReadStrptrMaybe(dev::Targsyslib& parent, algo::strptr in) {
    Regx_ReadSql(parent.uname, in, true);
    bool retval = true;// !parent.uname.parseerror; -- TODO: uncomment
    return retval;
}

// --- dev.Targsyslib..Concat_target_syslib
tempstr dev::Targsyslib_Concat_target_syslib( const algo::strptr& target ,const algo::strptr& syslib ) {
    return tempstr() << target <<'.'<< syslib ;
}

// --- dev.Targsyslib..ReadFieldMaybe
bool dev::Targsyslib_ReadFieldMaybe(dev::Targsyslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsyslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsyslib, strval); break;
        case dev_FieldId_target: retval = false; break;
        case dev_FieldId_syslib: retval = false; break;
        case dev_FieldId_uname: retval = uname_ReadStrptrMaybe(parent, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsyslib..ReadStrptrMaybe
// Read fields of dev::Targsyslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsyslib_ReadStrptrMaybe(dev::Targsyslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsyslib") || algo::StripTypeTag(in_str, "dev.Targsyslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsyslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsyslib..Print
// print string representation of dev::Targsyslib to string LHS, no header -- cprint:dev.Targsyslib.String
void dev::Targsyslib_Print(dev::Targsyslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsyslib";

    algo::Smallstr50_Print(row.targsyslib, temp);
    PrintAttrSpaceReset(str,"targsyslib", temp);

    dev::uname_Print(row, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Tgtcov..ReadFieldMaybe
bool dev::Tgtcov_ReadFieldMaybe(dev::Tgtcov &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case dev_FieldId_cov_min: retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov_min, strval); break;
        case dev_FieldId_maxerr: retval = algo::U32Dec2_ReadStrptrMaybe(parent.maxerr, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Tgtcov..ReadStrptrMaybe
// Read fields of dev::Tgtcov from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Tgtcov_ReadStrptrMaybe(dev::Tgtcov &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tgtcov") || algo::StripTypeTag(in_str, "dev.Tgtcov");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tgtcov_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Tgtcov..Print
// print string representation of dev::Tgtcov to string LHS, no header -- cprint:dev.Tgtcov.String
void dev::Tgtcov_Print(dev::Tgtcov & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.tgtcov";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::U32Dec2_Print(row.cov_min, temp);
    PrintAttrSpaceReset(str,"cov_min", temp);

    algo::U32Dec2_Print(row.maxerr, temp);
    PrintAttrSpaceReset(str,"maxerr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Timefmt..ReadFieldMaybe
bool dev::Timefmt_ReadFieldMaybe(dev::Timefmt &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_timefmt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.timefmt, strval); break;
        case dev_FieldId_dirname: retval = bool_ReadStrptrMaybe(parent.dirname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Timefmt..ReadStrptrMaybe
// Read fields of dev::Timefmt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Timefmt_ReadStrptrMaybe(dev::Timefmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.timefmt") || algo::StripTypeTag(in_str, "dev.Timefmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Timefmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Timefmt..Print
// print string representation of dev::Timefmt to string LHS, no header -- cprint:dev.Timefmt.String
void dev::Timefmt_Print(dev::Timefmt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.timefmt";

    algo::Smallstr100_Print(row.timefmt, temp);
    PrintAttrSpaceReset(str,"timefmt", temp);

    bool_Print(row.dirname, temp);
    PrintAttrSpaceReset(str,"dirname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.ToolOpt.opt_type.Get
algo::Smallstr50 dev::opt_type_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt_type.Get2
algo::Smallstr50 dev::ToolOpt_opt_type_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get
algo::Smallstr100 dev::opt_Get(dev::ToolOpt& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.tool_opt, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get2
algo::Smallstr100 dev::ToolOpt_opt_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.target.Get
algo::Smallstr50 dev::target_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.target.Get2
algo::Smallstr50 dev::ToolOpt_target_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.uname.Get
algo::Smallstr50 dev::uname_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.uname.Get2
algo::Smallstr50 dev::ToolOpt_uname_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get
algo::Smallstr50 dev::sortfld_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, ".LL"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get2
algo::Smallstr50 dev::ToolOpt_sortfld_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get2
algo::Smallstr50 dev::ToolOpt_compiler_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get2
algo::Smallstr50 dev::ToolOpt_cfg_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.arch.Get
algo::Smallstr50 dev::arch_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt.arch.Get2
algo::Smallstr50 dev::ToolOpt_arch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt..Concat_uname_compiler_cfg_arch_target_opt_type_opt
tempstr dev::ToolOpt_Concat_uname_compiler_cfg_arch_target_opt_type_opt( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ,const algo::strptr& target ,const algo::strptr& opt_type ,const algo::strptr& opt ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch <<'/'<< target <<'-'<< opt_type <<':'<< opt ;
}

// --- dev.ToolOpt..ReadFieldMaybe
bool dev::ToolOpt_ReadFieldMaybe(dev::ToolOpt &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_tool_opt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.tool_opt, strval); break;
        case dev_FieldId_opt_type: retval = false; break;
        case dev_FieldId_opt: retval = false; break;
        case dev_FieldId_target: retval = false; break;
        case dev_FieldId_uname: retval = false; break;
        case dev_FieldId_sortfld: retval = false; break;
        case dev_FieldId_compiler: retval = false; break;
        case dev_FieldId_cfg: retval = false; break;
        case dev_FieldId_arch: retval = false; break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.ToolOpt..ReadStrptrMaybe
// Read fields of dev::ToolOpt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::ToolOpt_ReadStrptrMaybe(dev::ToolOpt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tool_opt") || algo::StripTypeTag(in_str, "dev.ToolOpt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ToolOpt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.ToolOpt..Print
// print string representation of dev::ToolOpt to string LHS, no header -- cprint:dev.ToolOpt.String
void dev::ToolOpt_Print(dev::ToolOpt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.tool_opt";

    algo::Smallstr100_Print(row.tool_opt, temp);
    PrintAttrSpaceReset(str,"tool_opt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Uname..ReadFieldMaybe
bool dev::Uname_ReadFieldMaybe(dev::Uname &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Uname..ReadStrptrMaybe
// Read fields of dev::Uname from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Uname_ReadStrptrMaybe(dev::Uname &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.uname") || algo::StripTypeTag(in_str, "dev.Uname");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Uname_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Uname..Print
// print string representation of dev::Uname to string LHS, no header -- cprint:dev.Uname.String
void dev::Uname_Print(dev::Uname & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.uname";

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Unstablefld..ReadFieldMaybe
bool dev::Unstablefld_ReadFieldMaybe(dev::Unstablefld &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Unstablefld..ReadStrptrMaybe
// Read fields of dev::Unstablefld from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Unstablefld_ReadStrptrMaybe(dev::Unstablefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.unstablefld") || algo::StripTypeTag(in_str, "dev.Unstablefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Unstablefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Unstablefld..Print
// print string representation of dev::Unstablefld to string LHS, no header -- cprint:dev.Unstablefld.String
void dev::Unstablefld_Print(dev::Unstablefld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.unstablefld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev...SizeCheck
inline static void dev::SizeCheck() {
}
