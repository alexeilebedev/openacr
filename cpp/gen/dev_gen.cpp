//
// cpp/gen/dev_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dev.Arch.arch
const char *dev_Arch_arch_         = "";
const char *dev_Arch_arch_amd64    = "amd64";
const char *dev_Arch_arch_i686     = "i686";
const char *dev_Arch_arch_i86pc    = "i86pc";
const char *dev_Arch_arch_x64      = "x64";
const char *dev_Arch_arch_x86_64   = "x86_64";

// compile-time string constants for dev.Builddir.builddir
const char *dev_Builddir_builddir_Darwin_clangPP_coverage_x86_64   = "Darwin-clang++.coverage-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_debug_x86_64      = "Darwin-clang++.debug-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_profile_x86_64    = "Darwin-clang++.profile-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_release_x86_64    = "Darwin-clang++.release-x86_64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_coverage_amd64   = "FreeBSD-clang++.coverage-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_debug_amd64      = "FreeBSD-clang++.debug-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_profile_amd64    = "FreeBSD-clang++.profile-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_release_amd64    = "FreeBSD-clang++.release-amd64";
const char *dev_Builddir_builddir_Linux_clangPP_coverage_x86_64    = "Linux-clang++.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_debug_x86_64       = "Linux-clang++.debug-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_profile_x86_64     = "Linux-clang++.profile-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_release_x86_64     = "Linux-clang++.release-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_coverage_x86_64        = "Linux-g++.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_debug_x86_64           = "Linux-g++.debug-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_profile_x86_64         = "Linux-g++.profile-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_release_x86_64         = "Linux-g++.release-x86_64";

// compile-time string constants for dev.Cfg.cfg
const char *dev_Cfg_cfg_   = "";

const char *dev_Cfg_cfg_coverage   = "coverage";
const char *dev_Cfg_cfg_debug      = "debug";

const char *dev_Cfg_cfg_profile   = "profile";
const char *dev_Cfg_cfg_release   = "release";

// compile-time string constants for dev.Compiler.compiler
const char *dev_Compiler_compiler_          = "";
const char *dev_Compiler_compiler_cl        = "cl";
const char *dev_Compiler_compiler_clangPP   = "clang++";
const char *dev_Compiler_compiler_gPP       = "g++";

// compile-time string constants for dev.License.license
const char *dev_License_license_      = "";
const char *dev_License_license_GPL   = "GPL";

// compile-time string constants for dev.Mdmark.mdmark
const char *dev_Mdmark_mdmark_MDSECTION   = "MDSECTION";
const char *dev_Mdmark_mdmark_CMD         = "CMD";
const char *dev_Mdmark_mdmark_TOC         = "TOC";

// compile-time string constants for dev.Mdmark.state
const char *dev_Mdmark_state_BEG        = "BEG";
const char *dev_Mdmark_state_END        = "END";
const char *dev_Mdmark_state_BEG_AUTO   = "BEG_AUTO";
const char *dev_Mdmark_state_END_AUTO   = "END_AUTO";

// compile-time string constants for dev.Sandbox.sandbox
const char *dev_Sandbox_sandbox_abt_md   = "abt_md";

const char *dev_Sandbox_sandbox_acr_ed       = "acr_ed";
const char *dev_Sandbox_sandbox_amc          = "amc";
const char *dev_Sandbox_sandbox_amc_gc       = "amc_gc";
const char *dev_Sandbox_sandbox_apm_base     = "apm-base";
const char *dev_Sandbox_sandbox_apm_theirs   = "apm-theirs";
const char *dev_Sandbox_sandbox_atf_ci       = "atf_ci";
const char *dev_Sandbox_sandbox_atf_ci_apm   = "atf_ci-apm";
const char *dev_Sandbox_sandbox_atf_fuzz     = "atf_fuzz";
const char *dev_Sandbox_sandbox_tut_make     = "tut_make";

namespace dev { // gen:ns_print_proto
    // func:dev...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- dev.Arch..ReadFieldMaybe
bool dev::Arch_ReadFieldMaybe(dev::Arch& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_arch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Arch..ReadStrptrMaybe
// Read fields of dev::Arch from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Arch_ReadStrptrMaybe(dev::Arch &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.arch") || algo::StripTypeTag(in_str, "dev.Arch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Arch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Arch..Print
// print string representation of ROW to string STR
// cfmt:dev.Arch.String  printfmt:Tuple
void dev::Arch_Print(dev::Arch& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.arch";

    algo::Smallstr50_Print(row.arch, temp);
    PrintAttrSpaceReset(str,"arch", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Badline..ReadFieldMaybe
bool dev::Badline_ReadFieldMaybe(dev::Badline& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_badline: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.badline, strval);
            break;
        }
        case dev_FieldId_expr: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dev_FieldId_targsrc_regx: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsrc_regx, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Badline..ReadStrptrMaybe
// Read fields of dev::Badline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Badline_ReadStrptrMaybe(dev::Badline &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.badline") || algo::StripTypeTag(in_str, "dev.Badline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Badline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Badline..Print
// print string representation of ROW to string STR
// cfmt:dev.Badline.String  printfmt:Tuple
void dev::Badline_Print(dev::Badline& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.badline";

    algo::Smallstr50_Print(row.badline, temp);
    PrintAttrSpaceReset(str,"badline", temp);

    algo::Smallstr200_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr50_Print(row.targsrc_regx, temp);
    PrintAttrSpaceReset(str,"targsrc_regx", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Builddir.uname.Get
algo::Smallstr50 dev::uname_Get(dev::Builddir& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.uname.Get2
algo::Smallstr50 dev::Builddir_uname_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::Builddir& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.compiler.Get2
algo::Smallstr50 dev::Builddir_compiler_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::Builddir& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.cfg.Get2
algo::Smallstr50 dev::Builddir_cfg_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.arch.Get
algo::Smallstr50 dev::arch_Get(dev::Builddir& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LR"));
    return ret;
}

// --- dev.Builddir.arch.Get2
algo::Smallstr50 dev::Builddir_arch_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LR"));
    return ret;
}

// --- dev.Builddir..Concat_uname_compiler_cfg_arch
tempstr dev::Builddir_Concat_uname_compiler_cfg_arch( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch ;
}

// --- dev.Builddir..ReadFieldMaybe
bool dev::Builddir_ReadFieldMaybe(dev::Builddir& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_builddir: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.builddir, strval);
            break;
        }
        case dev_FieldId_uname: {
            retval = false;
            break;
        }
        case dev_FieldId_compiler: {
            retval = false;
            break;
        }
        case dev_FieldId_cfg: {
            retval = false;
            break;
        }
        case dev_FieldId_arch: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Builddir..ReadStrptrMaybe
// Read fields of dev::Builddir from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Builddir_ReadStrptrMaybe(dev::Builddir &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.builddir") || algo::StripTypeTag(in_str, "dev.Builddir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Builddir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Builddir..Print
// print string representation of ROW to string STR
// cfmt:dev.Builddir.String  printfmt:Tuple
void dev::Builddir_Print(dev::Builddir& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.builddir";

    algo::Smallstr50_Print(row.builddir, temp);
    PrintAttrSpaceReset(str,"builddir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Cfg..ReadFieldMaybe
bool dev::Cfg_ReadFieldMaybe(dev::Cfg& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_cfg: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval);
            break;
        }
        case dev_FieldId_suffix: {
            retval = algo::Smallstr5_ReadStrptrMaybe(parent.suffix, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Cfg..ReadStrptrMaybe
// Read fields of dev::Cfg from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Cfg_ReadStrptrMaybe(dev::Cfg &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.cfg") || algo::StripTypeTag(in_str, "dev.Cfg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Cfg..Print
// print string representation of ROW to string STR
// cfmt:dev.Cfg.String  printfmt:Tuple
void dev::Cfg_Print(dev::Cfg& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.cfg";

    algo::Smallstr50_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr5_Print(row.suffix, temp);
    PrintAttrSpaceReset(str,"suffix", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Compiler..ReadFieldMaybe
bool dev::Compiler_ReadFieldMaybe(dev::Compiler& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_compiler: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval);
            break;
        }
        case dev_FieldId_ranlib: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ranlib, strval);
            break;
        }
        case dev_FieldId_ar: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ar, strval);
            break;
        }
        case dev_FieldId_link: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.link, strval);
            break;
        }
        case dev_FieldId_libext: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.libext, strval);
            break;
        }
        case dev_FieldId_exeext: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.exeext, strval);
            break;
        }
        case dev_FieldId_pchext: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.pchext, strval);
            break;
        }
        case dev_FieldId_objext: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.objext, strval);
            break;
        }
        case dev_FieldId_rc: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.rc, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Compiler..ReadStrptrMaybe
// Read fields of dev::Compiler from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Compiler_ReadStrptrMaybe(dev::Compiler &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.compiler") || algo::StripTypeTag(in_str, "dev.Compiler");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Compiler_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Compiler..Print
// print string representation of ROW to string STR
// cfmt:dev.Compiler.String  printfmt:Tuple
void dev::Compiler_Print(dev::Compiler& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.compiler";

    algo::Smallstr50_Print(row.compiler, temp);
    PrintAttrSpaceReset(str,"compiler", temp);

    algo::Smallstr50_Print(row.ranlib, temp);
    PrintAttrSpaceReset(str,"ranlib", temp);

    algo::Smallstr50_Print(row.ar, temp);
    PrintAttrSpaceReset(str,"ar", temp);

    algo::Smallstr50_Print(row.link, temp);
    PrintAttrSpaceReset(str,"link", temp);

    algo::Smallstr50_Print(row.libext, temp);
    PrintAttrSpaceReset(str,"libext", temp);

    algo::Smallstr20_Print(row.exeext, temp);
    PrintAttrSpaceReset(str,"exeext", temp);

    algo::Smallstr20_Print(row.pchext, temp);
    PrintAttrSpaceReset(str,"pchext", temp);

    algo::Smallstr20_Print(row.objext, temp);
    PrintAttrSpaceReset(str,"objext", temp);

    algo::Smallstr50_Print(row.rc, temp);
    PrintAttrSpaceReset(str,"rc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Copyright..ReadFieldMaybe
bool dev::Copyright_ReadFieldMaybe(dev::Copyright& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_copyright: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.copyright, strval);
            break;
        }
        case dev_FieldId_dflt: {
            retval = bool_ReadStrptrMaybe(parent.dflt, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Copyright..ReadStrptrMaybe
// Read fields of dev::Copyright from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Copyright_ReadStrptrMaybe(dev::Copyright &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.copyright") || algo::StripTypeTag(in_str, "dev.Copyright");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Copyright_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Copyright..Print
// print string representation of ROW to string STR
// cfmt:dev.Copyright.String  printfmt:Tuple
void dev::Copyright_Print(dev::Copyright& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.copyright";

    algo::Smallstr50_Print(row.copyright, temp);
    PrintAttrSpaceReset(str,"copyright", temp);

    bool_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Covfile..ReadFieldMaybe
bool dev::Covfile_ReadFieldMaybe(dev::Covfile& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_covfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.covfile, strval);
            break;
        }
        case dev_FieldId_total: {
            retval = u32_ReadStrptrMaybe(parent.total, strval);
            break;
        }
        case dev_FieldId_nonexe: {
            retval = u32_ReadStrptrMaybe(parent.nonexe, strval);
            break;
        }
        case dev_FieldId_exe: {
            retval = u32_ReadStrptrMaybe(parent.exe, strval);
            break;
        }
        case dev_FieldId_exer: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.exer, strval);
            break;
        }
        case dev_FieldId_hit: {
            retval = u32_ReadStrptrMaybe(parent.hit, strval);
            break;
        }
        case dev_FieldId_cov: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covfile..ReadStrptrMaybe
// Read fields of dev::Covfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covfile_ReadStrptrMaybe(dev::Covfile &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covfile") || algo::StripTypeTag(in_str, "dev.Covfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covfile..Print
// print string representation of ROW to string STR
// cfmt:dev.Covfile.String  printfmt:Tuple
void dev::Covfile_Print(dev::Covfile& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.covfile";

    algo::Smallstr200_Print(row.covfile, temp);
    PrintAttrSpaceReset(str,"covfile", temp);

    u32_Print(row.total, temp);
    PrintAttrSpaceReset(str,"total", temp);

    u32_Print(row.nonexe, temp);
    PrintAttrSpaceReset(str,"nonexe", temp);

    u32_Print(row.exe, temp);
    PrintAttrSpaceReset(str,"exe", temp);

    algo::U32Dec2_Print(row.exer, temp);
    PrintAttrSpaceReset(str,"exer", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::U32Dec2_Print(row.cov, temp);
    PrintAttrSpaceReset(str,"cov", temp);
}

// --- dev.Covline.src.Get
algo::Smallstr200 dev::src_Get(dev::Covline& parent) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(parent.covline, ":RL"));
    return ret;
}

// --- dev.Covline.src.Get2
algo::Smallstr200 dev::Covline_src_Get(algo::strptr arg) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":RL"));
    return ret;
}

// --- dev.Covline.line.Get
u32 dev::line_Get(dev::Covline& parent) throw() {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.covline, ":RR"));
    return ret;
}

// --- dev.Covline.line.Get2
u32 dev::Covline_line_Get(algo::strptr arg) throw() {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(arg, ":RR"));
    return ret;
}

// --- dev.Covline.flag.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::flag_ToCstr(const dev::Covline& parent) throw() {
    const char *ret = NULL;
    switch(flag_GetEnum(parent)) {
        case dev_Covline_flag_N            : ret = "N";  break;
        case dev_Covline_flag_E            : ret = "E";  break;
        case dev_Covline_flag_P            : ret = "P";  break;
    }
    return ret;
}

// --- dev.Covline.flag.Print
// Convert flag to a string. First, attempt conversion to a known string.
// If no string matches, print flag as a numeric value.
void dev::flag_Print(const dev::Covline& parent, algo::cstring &lhs) throw() {
    const char *strval = flag_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.flag;
    }
}

// --- dev.Covline.flag.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::flag_SetStrptrMaybe(dev::Covline& parent, algo::strptr rhs) throw() {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'E': {
                    flag_SetEnum(parent,dev_Covline_flag_E); ret = true; break;
                }
                case 'N': {
                    flag_SetEnum(parent,dev_Covline_flag_N); ret = true; break;
                }
                case 'P': {
                    flag_SetEnum(parent,dev_Covline_flag_P); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.Covline.flag.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::flag_SetStrptr(dev::Covline& parent, algo::strptr rhs, dev_Covline_flag_Enum dflt) throw() {
    if (!flag_SetStrptrMaybe(parent,rhs)) flag_SetEnum(parent,dflt);
}

// --- dev.Covline.flag.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::flag_ReadStrptrMaybe(dev::Covline& parent, algo::strptr rhs) throw() {
    bool retval = false;
    retval = flag_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = char_ReadStrptrMaybe(parent.flag,rhs);
    }
    return retval;
}

// --- dev.Covline..Concat_src_line
tempstr dev::Covline_Concat_src_line( const algo::strptr& src ,u32 line ) {
    return tempstr() << src <<':'<< line ;
}

// --- dev.Covline..ReadFieldMaybe
bool dev::Covline_ReadFieldMaybe(dev::Covline& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_covline: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.covline, strval);
            break;
        }
        case dev_FieldId_src: {
            retval = false;
            break;
        }
        case dev_FieldId_line: {
            retval = false;
            break;
        }
        case dev_FieldId_flag: {
            retval = flag_ReadStrptrMaybe(parent, strval);
            break;
        }
        case dev_FieldId_hit: {
            retval = u32_ReadStrptrMaybe(parent.hit, strval);
            break;
        }
        case dev_FieldId_text: {
            retval = algo::cstring_ReadStrptrMaybe(parent.text, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covline..ReadStrptrMaybe
// Read fields of dev::Covline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covline_ReadStrptrMaybe(dev::Covline &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covline") || algo::StripTypeTag(in_str, "dev.Covline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covline..Print
// print string representation of ROW to string STR
// cfmt:dev.Covline.String  printfmt:Tuple
void dev::Covline_Print(dev::Covline& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.covline";

    algo::Smallstr200_Print(row.covline, temp);
    PrintAttrSpaceReset(str,"covline", temp);

    dev::flag_Print(row, temp);
    PrintAttrSpaceReset(str,"flag", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::cstring_Print(row.text, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- dev.Covtarget..ReadFieldMaybe
bool dev::Covtarget_ReadFieldMaybe(dev::Covtarget& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_covtarget: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.covtarget, strval);
            break;
        }
        case dev_FieldId_total: {
            retval = u32_ReadStrptrMaybe(parent.total, strval);
            break;
        }
        case dev_FieldId_nonexe: {
            retval = u32_ReadStrptrMaybe(parent.nonexe, strval);
            break;
        }
        case dev_FieldId_exe: {
            retval = u32_ReadStrptrMaybe(parent.exe, strval);
            break;
        }
        case dev_FieldId_exer: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.exer, strval);
            break;
        }
        case dev_FieldId_hit: {
            retval = u32_ReadStrptrMaybe(parent.hit, strval);
            break;
        }
        case dev_FieldId_cov: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Covtarget..ReadStrptrMaybe
// Read fields of dev::Covtarget from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Covtarget_ReadStrptrMaybe(dev::Covtarget &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.covtarget") || algo::StripTypeTag(in_str, "dev.Covtarget");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Covtarget_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Covtarget..Print
// print string representation of ROW to string STR
// cfmt:dev.Covtarget.String  printfmt:Tuple
void dev::Covtarget_Print(dev::Covtarget& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.covtarget";

    algo::Smallstr16_Print(row.covtarget, temp);
    PrintAttrSpaceReset(str,"covtarget", temp);

    u32_Print(row.total, temp);
    PrintAttrSpaceReset(str,"total", temp);

    u32_Print(row.nonexe, temp);
    PrintAttrSpaceReset(str,"nonexe", temp);

    u32_Print(row.exe, temp);
    PrintAttrSpaceReset(str,"exe", temp);

    algo::U32Dec2_Print(row.exer, temp);
    PrintAttrSpaceReset(str,"exer", temp);

    u32_Print(row.hit, temp);
    PrintAttrSpaceReset(str,"hit", temp);

    algo::U32Dec2_Print(row.cov, temp);
    PrintAttrSpaceReset(str,"cov", temp);
}

// --- dev.Edaction.edacttype.Get
algo::Smallstr50 dev::edacttype_Get(dev::Edaction& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.edaction, "_LL"));
    return ret;
}

// --- dev.Edaction.edacttype.Get2
algo::Smallstr50 dev::Edaction_edacttype_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "_LL"));
    return ret;
}

// --- dev.Edaction.name.Get
algo::Smallstr50 dev::name_Get(dev::Edaction& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.edaction, "_LR"));
    return ret;
}

// --- dev.Edaction.name.Get2
algo::Smallstr50 dev::Edaction_name_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "_LR"));
    return ret;
}

// --- dev.Edaction..Concat_edacttype_name
tempstr dev::Edaction_Concat_edacttype_name( const algo::strptr& edacttype ,const algo::strptr& name ) {
    return tempstr() << edacttype <<'_'<< name ;
}

// --- dev.Edaction..ReadFieldMaybe
bool dev::Edaction_ReadFieldMaybe(dev::Edaction& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_edaction: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.edaction, strval);
            break;
        }
        case dev_FieldId_edacttype: {
            retval = false;
            break;
        }
        case dev_FieldId_name: {
            retval = false;
            break;
        }
        case dev_FieldId_needamc: {
            retval = bool_ReadStrptrMaybe(parent.needamc, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Edaction..ReadStrptrMaybe
// Read fields of dev::Edaction from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Edaction_ReadStrptrMaybe(dev::Edaction &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.edaction") || algo::StripTypeTag(in_str, "dev.Edaction");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Edaction_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Edaction..Print
// print string representation of ROW to string STR
// cfmt:dev.Edaction.String  printfmt:Tuple
void dev::Edaction_Print(dev::Edaction& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.edaction";

    algo::Smallstr50_Print(row.edaction, temp);
    PrintAttrSpaceReset(str,"edaction", temp);

    bool_Print(row.needamc, temp);
    PrintAttrSpaceReset(str,"needamc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Edacttype..ReadFieldMaybe
bool dev::Edacttype_ReadFieldMaybe(dev::Edacttype& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_edacttype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.edacttype, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Edacttype..ReadStrptrMaybe
// Read fields of dev::Edacttype from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Edacttype_ReadStrptrMaybe(dev::Edacttype &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.edacttype") || algo::StripTypeTag(in_str, "dev.Edacttype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Edacttype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Edacttype..Print
// print string representation of ROW to string STR
// cfmt:dev.Edacttype.String  printfmt:Tuple
void dev::Edacttype_Print(dev::Edacttype& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.edacttype";

    algo::Smallstr50_Print(row.edacttype, temp);
    PrintAttrSpaceReset(str,"edacttype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::value_ToCstr(const dev::FieldId& parent) throw() {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dev_FieldId_arch              : ret = "arch";  break;
        case dev_FieldId_comment           : ret = "comment";  break;
        case dev_FieldId_badline           : ret = "badline";  break;
        case dev_FieldId_expr              : ret = "expr";  break;
        case dev_FieldId_targsrc_regx      : ret = "targsrc_regx";  break;
        case dev_FieldId_builddir          : ret = "builddir";  break;
        case dev_FieldId_uname             : ret = "uname";  break;
        case dev_FieldId_compiler          : ret = "compiler";  break;
        case dev_FieldId_cfg               : ret = "cfg";  break;
        case dev_FieldId_suffix            : ret = "suffix";  break;
        case dev_FieldId_ranlib            : ret = "ranlib";  break;
        case dev_FieldId_ar                : ret = "ar";  break;
        case dev_FieldId_link              : ret = "link";  break;
        case dev_FieldId_libext            : ret = "libext";  break;
        case dev_FieldId_exeext            : ret = "exeext";  break;
        case dev_FieldId_pchext            : ret = "pchext";  break;
        case dev_FieldId_objext            : ret = "objext";  break;
        case dev_FieldId_rc                : ret = "rc";  break;
        case dev_FieldId_copyright         : ret = "copyright";  break;
        case dev_FieldId_dflt              : ret = "dflt";  break;
        case dev_FieldId_covfile           : ret = "covfile";  break;
        case dev_FieldId_total             : ret = "total";  break;
        case dev_FieldId_nonexe            : ret = "nonexe";  break;
        case dev_FieldId_exe               : ret = "exe";  break;
        case dev_FieldId_exer              : ret = "exer";  break;
        case dev_FieldId_hit               : ret = "hit";  break;
        case dev_FieldId_cov               : ret = "cov";  break;
        case dev_FieldId_covline           : ret = "covline";  break;
        case dev_FieldId_src               : ret = "src";  break;
        case dev_FieldId_line              : ret = "line";  break;
        case dev_FieldId_flag              : ret = "flag";  break;
        case dev_FieldId_text              : ret = "text";  break;
        case dev_FieldId_covtarget         : ret = "covtarget";  break;
        case dev_FieldId_edaction          : ret = "edaction";  break;
        case dev_FieldId_edacttype         : ret = "edacttype";  break;
        case dev_FieldId_name              : ret = "name";  break;
        case dev_FieldId_needamc           : ret = "needamc";  break;
        case dev_FieldId_gitfile           : ret = "gitfile";  break;
        case dev_FieldId_ext               : ret = "ext";  break;
        case dev_FieldId_gitinfo           : ret = "gitinfo";  break;
        case dev_FieldId_author            : ret = "author";  break;
        case dev_FieldId_compver           : ret = "compver";  break;
        case dev_FieldId_package           : ret = "package";  break;
        case dev_FieldId_hilite            : ret = "hilite";  break;
        case dev_FieldId_color             : ret = "color";  break;
        case dev_FieldId_htmlentity        : ret = "htmlentity";  break;
        case dev_FieldId_code              : ret = "code";  break;
        case dev_FieldId_include           : ret = "include";  break;
        case dev_FieldId_srcfile           : ret = "srcfile";  break;
        case dev_FieldId_filename          : ret = "filename";  break;
        case dev_FieldId_sys               : ret = "sys";  break;
        case dev_FieldId_license           : ret = "license";  break;
        case dev_FieldId_nlongline         : ret = "nlongline";  break;
        case dev_FieldId_longestline       : ret = "longestline";  break;
        case dev_FieldId_nbadws            : ret = "nbadws";  break;
        case dev_FieldId_maxws             : ret = "maxws";  break;
        case dev_FieldId_nlongfunc         : ret = "nlongfunc";  break;
        case dev_FieldId_longestfunc       : ret = "longestfunc";  break;
        case dev_FieldId_nmysteryfunc      : ret = "nmysteryfunc";  break;
        case dev_FieldId_badness           : ret = "badness";  break;
        case dev_FieldId_mdmark            : ret = "mdmark";  break;
        case dev_FieldId_state             : ret = "state";  break;
        case dev_FieldId_param             : ret = "param";  break;
        case dev_FieldId_mdsection         : ret = "mdsection";  break;
        case dev_FieldId_match             : ret = "match";  break;
        case dev_FieldId_path              : ret = "path";  break;
        case dev_FieldId_genlist           : ret = "genlist";  break;
        case dev_FieldId_strict            : ret = "strict";  break;
        case dev_FieldId_opt_type          : ret = "opt_type";  break;
        case dev_FieldId_sep               : ret = "sep";  break;
        case dev_FieldId_baseref           : ret = "baseref";  break;
        case dev_FieldId_origin            : ret = "origin";  break;
        case dev_FieldId_pkgdep            : ret = "pkgdep";  break;
        case dev_FieldId_parent            : ret = "parent";  break;
        case dev_FieldId_soft              : ret = "soft";  break;
        case dev_FieldId_pkgkey            : ret = "pkgkey";  break;
        case dev_FieldId_key               : ret = "key";  break;
        case dev_FieldId_inl               : ret = "inl";  break;
        case dev_FieldId_sandbox           : ret = "sandbox";  break;
        case dev_FieldId_filter            : ret = "filter";  break;
        case dev_FieldId_readmesort        : ret = "readmesort";  break;
        case dev_FieldId_sbpath            : ret = "sbpath";  break;
        case dev_FieldId_syscmd            : ret = "syscmd";  break;
        case dev_FieldId_execkey           : ret = "execkey";  break;
        case dev_FieldId_command           : ret = "command";  break;
        case dev_FieldId_pid               : ret = "pid";  break;
        case dev_FieldId_status            : ret = "status";  break;
        case dev_FieldId_nprereq           : ret = "nprereq";  break;
        case dev_FieldId_fail_prereq       : ret = "fail_prereq";  break;
        case dev_FieldId_completed         : ret = "completed";  break;
        case dev_FieldId_maxtime           : ret = "maxtime";  break;
        case dev_FieldId_syscmddep         : ret = "syscmddep";  break;
        case dev_FieldId_child             : ret = "child";  break;
        case dev_FieldId_syslib            : ret = "syslib";  break;
        case dev_FieldId_targdep           : ret = "targdep";  break;
        case dev_FieldId_target            : ret = "target";  break;
        case dev_FieldId_targsrc           : ret = "targsrc";  break;
        case dev_FieldId_targsyslib        : ret = "targsyslib";  break;
        case dev_FieldId_cov_min           : ret = "cov_min";  break;
        case dev_FieldId_maxerr            : ret = "maxerr";  break;
        case dev_FieldId_timefmt           : ret = "timefmt";  break;
        case dev_FieldId_dirname           : ret = "dirname";  break;
        case dev_FieldId_tool_opt          : ret = "tool_opt";  break;
        case dev_FieldId_opt               : ret = "opt";  break;
        case dev_FieldId_sortfld           : ret = "sortfld";  break;
        case dev_FieldId_field             : ret = "field";  break;
        case dev_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- dev.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dev::value_Print(const dev::FieldId& parent, algo::cstring &lhs) throw() {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dev.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) throw() {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('a','r'): {
                    value_SetEnum(parent,dev_FieldId_ar); ret = true; break;
                }
                case LE_STR2('r','c'): {
                    value_SetEnum(parent,dev_FieldId_rc); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,dev_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('c','o','v'): {
                    value_SetEnum(parent,dev_FieldId_cov); ret = true; break;
                }
                case LE_STR3('e','x','e'): {
                    value_SetEnum(parent,dev_FieldId_exe); ret = true; break;
                }
                case LE_STR3('e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_ext); ret = true; break;
                }
                case LE_STR3('h','i','t'): {
                    value_SetEnum(parent,dev_FieldId_hit); ret = true; break;
                }
                case LE_STR3('i','n','l'): {
                    value_SetEnum(parent,dev_FieldId_inl); ret = true; break;
                }
                case LE_STR3('k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_key); ret = true; break;
                }
                case LE_STR3('o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_opt); ret = true; break;
                }
                case LE_STR3('p','i','d'): {
                    value_SetEnum(parent,dev_FieldId_pid); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dev_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_src); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dev_FieldId_sys); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,dev_FieldId_arch); ret = true; break;
                }
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,dev_FieldId_code); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,dev_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('e','x','e','r'): {
                    value_SetEnum(parent,dev_FieldId_exer); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dev_FieldId_expr); ret = true; break;
                }
                case LE_STR4('f','l','a','g'): {
                    value_SetEnum(parent,dev_FieldId_flag); ret = true; break;
                }
                case LE_STR4('l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_line); ret = true; break;
                }
                case LE_STR4('l','i','n','k'): {
                    value_SetEnum(parent,dev_FieldId_link); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_name); ret = true; break;
                }
                case LE_STR4('p','a','t','h'): {
                    value_SetEnum(parent,dev_FieldId_path); ret = true; break;
                }
                case LE_STR4('s','o','f','t'): {
                    value_SetEnum(parent,dev_FieldId_soft); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_text); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('c','h','i','l','d'): {
                    value_SetEnum(parent,dev_FieldId_child); ret = true; break;
                }
                case LE_STR5('c','o','l','o','r'): {
                    value_SetEnum(parent,dev_FieldId_color); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,dev_FieldId_field); ret = true; break;
                }
                case LE_STR5('m','a','t','c','h'): {
                    value_SetEnum(parent,dev_FieldId_match); ret = true; break;
                }
                case LE_STR5('m','a','x','w','s'): {
                    value_SetEnum(parent,dev_FieldId_maxws); ret = true; break;
                }
                case LE_STR5('p','a','r','a','m'): {
                    value_SetEnum(parent,dev_FieldId_param); ret = true; break;
                }
                case LE_STR5('s','t','a','t','e'): {
                    value_SetEnum(parent,dev_FieldId_state); ret = true; break;
                }
                case LE_STR5('t','o','t','a','l'): {
                    value_SetEnum(parent,dev_FieldId_total); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dev_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','u','t','h','o','r'): {
                    value_SetEnum(parent,dev_FieldId_author); ret = true; break;
                }
                case LE_STR6('e','x','e','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_exeext); ret = true; break;
                }
                case LE_STR6('f','i','l','t','e','r'): {
                    value_SetEnum(parent,dev_FieldId_filter); ret = true; break;
                }
                case LE_STR6('h','i','l','i','t','e'): {
                    value_SetEnum(parent,dev_FieldId_hilite); ret = true; break;
                }
                case LE_STR6('l','i','b','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_libext); ret = true; break;
                }
                case LE_STR6('m','a','x','e','r','r'): {
                    value_SetEnum(parent,dev_FieldId_maxerr); ret = true; break;
                }
                case LE_STR6('m','d','m','a','r','k'): {
                    value_SetEnum(parent,dev_FieldId_mdmark); ret = true; break;
                }
                case LE_STR6('n','b','a','d','w','s'): {
                    value_SetEnum(parent,dev_FieldId_nbadws); ret = true; break;
                }
                case LE_STR6('n','o','n','e','x','e'): {
                    value_SetEnum(parent,dev_FieldId_nonexe); ret = true; break;
                }
                case LE_STR6('o','b','j','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_objext); ret = true; break;
                }
                case LE_STR6('o','r','i','g','i','n'): {
                    value_SetEnum(parent,dev_FieldId_origin); ret = true; break;
                }
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_parent); ret = true; break;
                }
                case LE_STR6('p','c','h','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_pchext); ret = true; break;
                }
                case LE_STR6('p','k','g','d','e','p'): {
                    value_SetEnum(parent,dev_FieldId_pkgdep); ret = true; break;
                }
                case LE_STR6('p','k','g','k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_pkgkey); ret = true; break;
                }
                case LE_STR6('r','a','n','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_ranlib); ret = true; break;
                }
                case LE_STR6('s','b','p','a','t','h'): {
                    value_SetEnum(parent,dev_FieldId_sbpath); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,dev_FieldId_status); ret = true; break;
                }
                case LE_STR6('s','t','r','i','c','t'): {
                    value_SetEnum(parent,dev_FieldId_strict); ret = true; break;
                }
                case LE_STR6('s','u','f','f','i','x'): {
                    value_SetEnum(parent,dev_FieldId_suffix); ret = true; break;
                }
                case LE_STR6('s','y','s','c','m','d'): {
                    value_SetEnum(parent,dev_FieldId_syscmd); ret = true; break;
                }
                case LE_STR6('s','y','s','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_syslib); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,dev_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_badline); ret = true; break;
                }
                case LE_STR7('b','a','d','n','e','s','s'): {
                    value_SetEnum(parent,dev_FieldId_badness); ret = true; break;
                }
                case LE_STR7('b','a','s','e','r','e','f'): {
                    value_SetEnum(parent,dev_FieldId_baseref); ret = true; break;
                }
                case LE_STR7('c','o','m','m','a','n','d'): {
                    value_SetEnum(parent,dev_FieldId_command); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','m','p','v','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compver); ret = true; break;
                }
                case LE_STR7('c','o','v','_','m','i','n'): {
                    value_SetEnum(parent,dev_FieldId_cov_min); ret = true; break;
                }
                case LE_STR7('c','o','v','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_covfile); ret = true; break;
                }
                case LE_STR7('c','o','v','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_covline); ret = true; break;
                }
                case LE_STR7('d','i','r','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_dirname); ret = true; break;
                }
                case LE_STR7('e','x','e','c','k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_execkey); ret = true; break;
                }
                case LE_STR7('g','e','n','l','i','s','t'): {
                    value_SetEnum(parent,dev_FieldId_genlist); ret = true; break;
                }
                case LE_STR7('g','i','t','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_gitfile); ret = true; break;
                }
                case LE_STR7('g','i','t','i','n','f','o'): {
                    value_SetEnum(parent,dev_FieldId_gitinfo); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,dev_FieldId_include); ret = true; break;
                }
                case LE_STR7('l','i','c','e','n','s','e'): {
                    value_SetEnum(parent,dev_FieldId_license); ret = true; break;
                }
                case LE_STR7('m','a','x','t','i','m','e'): {
                    value_SetEnum(parent,dev_FieldId_maxtime); ret = true; break;
                }
                case LE_STR7('n','e','e','d','a','m','c'): {
                    value_SetEnum(parent,dev_FieldId_needamc); ret = true; break;
                }
                case LE_STR7('n','p','r','e','r','e','q'): {
                    value_SetEnum(parent,dev_FieldId_nprereq); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,dev_FieldId_package); ret = true; break;
                }
                case LE_STR7('s','a','n','d','b','o','x'): {
                    value_SetEnum(parent,dev_FieldId_sandbox); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,dev_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('t','a','r','g','d','e','p'): {
                    value_SetEnum(parent,dev_FieldId_targdep); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_targsrc); ret = true; break;
                }
                case LE_STR7('t','i','m','e','f','m','t'): {
                    value_SetEnum(parent,dev_FieldId_timefmt); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('b','u','i','l','d','d','i','r'): {
                    value_SetEnum(parent,dev_FieldId_builddir); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('e','d','a','c','t','i','o','n'): {
                    value_SetEnum(parent,dev_FieldId_edaction); ret = true; break;
                }
                case LE_STR8('f','i','l','e','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_filename); ret = true; break;
                }
                case LE_STR8('o','p','t','_','t','y','p','e'): {
                    value_SetEnum(parent,dev_FieldId_opt_type); ret = true; break;
                }
                case LE_STR8('t','o','o','l','_','o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_tool_opt); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','m','p','l','e','t','e'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dev_FieldId_completed); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','p','y','r','i','g','h'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dev_FieldId_copyright); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','v','t','a','r','g','e'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dev_FieldId_covtarget); ret = true; break; }
                    break;
                }
                case LE_STR8('e','d','a','c','t','t','y','p'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_edacttype); ret = true; break; }
                    break;
                }
                case LE_STR8('m','d','s','e','c','t','i','o'): {
                    if (memcmp(rhs.elems+8,"n",1)==0) { value_SetEnum(parent,dev_FieldId_mdsection); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','f','u','n'): {
                    if (memcmp(rhs.elems+8,"c",1)==0) { value_SetEnum(parent,dev_FieldId_nlongfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','l','i','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_nlongline); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','s','c','m','d','d','e'): {
                    if (memcmp(rhs.elems+8,"p",1)==0) { value_SetEnum(parent,dev_FieldId_syscmddep); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('h','t','m','l','e','n','t','i'): {
                    if (memcmp(rhs.elems+8,"ty",2)==0) { value_SetEnum(parent,dev_FieldId_htmlentity); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','a','d','m','e','s','o'): {
                    if (memcmp(rhs.elems+8,"rt",2)==0) { value_SetEnum(parent,dev_FieldId_readmesort); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,dev_FieldId_targsyslib); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','a','i','l','_','p','r','e'): {
                    if (memcmp(rhs.elems+8,"req",3)==0) { value_SetEnum(parent,dev_FieldId_fail_prereq); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','f'): {
                    if (memcmp(rhs.elems+8,"unc",3)==0) { value_SetEnum(parent,dev_FieldId_longestfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dev_FieldId_longestline); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('n','m','y','s','t','e','r','y'): {
                    if (memcmp(rhs.elems+8,"func",4)==0) { value_SetEnum(parent,dev_FieldId_nmysteryfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','r','c','_'): {
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,dev_FieldId_targsrc_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::value_SetStrptr(dev::FieldId& parent, algo::strptr rhs, dev_FieldIdEnum dflt) throw() {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dev.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::value_ReadStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) throw() {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dev.FieldId..ReadStrptrMaybe
// Read fields of dev::FieldId from an ascii string.
// The format of the string is the format of the dev::FieldId's only field
bool dev::FieldId_ReadStrptrMaybe(dev::FieldId &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dev.FieldId..Print
// print string representation of ROW to string STR
// cfmt:dev.FieldId.String  printfmt:Raw
void dev::FieldId_Print(dev::FieldId& row, algo::cstring& str) throw() {
    dev::value_Print(row, str);
}

// --- dev.Gitfile.ext.Get
algo::Smallstr50 dev::ext_Get(dev::Gitfile& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gitfile, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile.ext.Get2
algo::Smallstr50 dev::Gitfile_ext_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile..ReadFieldMaybe
bool dev::Gitfile_ReadFieldMaybe(dev::Gitfile& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_ext: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitfile..ReadStrptrMaybe
// Read fields of dev::Gitfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitfile_ReadStrptrMaybe(dev::Gitfile &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitfile") || algo::StripTypeTag(in_str, "dev.Gitfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitfile..Print
// print string representation of ROW to string STR
// cfmt:dev.Gitfile.String  printfmt:Tuple
void dev::Gitfile_Print(dev::Gitfile& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.gitfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);
}

// --- dev.Gitinfo..ReadFieldMaybe
bool dev::Gitinfo_ReadFieldMaybe(dev::Gitinfo& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitinfo: {
            retval = algo::Smallstr40_ReadStrptrMaybe(parent.gitinfo, strval);
            break;
        }
        case dev_FieldId_author: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.author, strval);
            break;
        }
        case dev_FieldId_cfg: {
            retval = algo::Smallstr40_ReadStrptrMaybe(parent.cfg, strval);
            break;
        }
        case dev_FieldId_compver: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.compver, strval);
            break;
        }
        case dev_FieldId_package: {
            retval = algo::Smallstr40_ReadStrptrMaybe(parent.package, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitinfo..ReadStrptrMaybe
// Read fields of dev::Gitinfo from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitinfo_ReadStrptrMaybe(dev::Gitinfo &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitinfo") || algo::StripTypeTag(in_str, "dev.Gitinfo");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitinfo_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitinfo..Print
// print string representation of ROW to string STR
// cfmt:dev.Gitinfo.String  printfmt:Tuple
void dev::Gitinfo_Print(dev::Gitinfo& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.gitinfo";

    algo::Smallstr40_Print(row.gitinfo, temp);
    PrintAttrSpaceReset(str,"gitinfo", temp);

    algo::Smallstr50_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr40_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr20_Print(row.compver, temp);
    PrintAttrSpaceReset(str,"compver", temp);

    algo::Smallstr40_Print(row.package, temp);
    PrintAttrSpaceReset(str,"package", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Hilite..ReadFieldMaybe
bool dev::Hilite_ReadFieldMaybe(dev::Hilite& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_hilite: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.hilite, strval);
            break;
        }
        case dev_FieldId_color: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.color, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Hilite..ReadStrptrMaybe
// Read fields of dev::Hilite from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Hilite_ReadStrptrMaybe(dev::Hilite &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.hilite") || algo::StripTypeTag(in_str, "dev.Hilite");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hilite_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Hilite..Print
// print string representation of ROW to string STR
// cfmt:dev.Hilite.String  printfmt:Tuple
void dev::Hilite_Print(dev::Hilite& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.hilite";

    algo::Smallstr50_Print(row.hilite, temp);
    PrintAttrSpaceReset(str,"hilite", temp);

    algo::Smallstr50_Print(row.color, temp);
    PrintAttrSpaceReset(str,"color", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Htmlentity..ReadFieldMaybe
bool dev::Htmlentity_ReadFieldMaybe(dev::Htmlentity& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_htmlentity: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.htmlentity, strval);
            break;
        }
        case dev_FieldId_code: {
            retval = i32_ReadStrptrMaybe(parent.code, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Htmlentity..ReadStrptrMaybe
// Read fields of dev::Htmlentity from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Htmlentity_ReadStrptrMaybe(dev::Htmlentity &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.htmlentity") || algo::StripTypeTag(in_str, "dev.Htmlentity");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Htmlentity_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Htmlentity..Print
// print string representation of ROW to string STR
// cfmt:dev.Htmlentity.String  printfmt:Tuple
void dev::Htmlentity_Print(dev::Htmlentity& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.htmlentity";

    algo::Smallstr50_Print(row.htmlentity, temp);
    PrintAttrSpaceReset(str,"htmlentity", temp);

    i32_Print(row.code, temp);
    PrintAttrSpaceReset(str,"code", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Include.srcfile.Get
algo::Smallstr200 dev::srcfile_Get(dev::Include& parent) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LL"));
    return ret;
}

// --- dev.Include.srcfile.Get2
algo::Smallstr200 dev::Include_srcfile_Get(algo::strptr arg) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dev.Include.filename.Get
algo::Smallstr200 dev::filename_Get(dev::Include& parent) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LR"));
    return ret;
}

// --- dev.Include.filename.Get2
algo::Smallstr200 dev::Include_filename_Get(algo::strptr arg) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dev.Include..Concat_srcfile_filename
tempstr dev::Include_Concat_srcfile_filename( const algo::strptr& srcfile ,const algo::strptr& filename ) {
    return tempstr() << srcfile <<':'<< filename ;
}

// --- dev.Include..ReadFieldMaybe
bool dev::Include_ReadFieldMaybe(dev::Include& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_include: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.include, strval);
            break;
        }
        case dev_FieldId_srcfile: {
            retval = false;
            break;
        }
        case dev_FieldId_filename: {
            retval = false;
            break;
        }
        case dev_FieldId_sys: {
            retval = bool_ReadStrptrMaybe(parent.sys, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Include..ReadStrptrMaybe
// Read fields of dev::Include from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Include_ReadStrptrMaybe(dev::Include &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.include") || algo::StripTypeTag(in_str, "dev.Include");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Include_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Include..Print
// print string representation of ROW to string STR
// cfmt:dev.Include.String  printfmt:Tuple
void dev::Include_Print(dev::Include& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.include";

    algo::Smallstr200_Print(row.include, temp);
    PrintAttrSpaceReset(str,"include", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.License..ReadFieldMaybe
bool dev::License_ReadFieldMaybe(dev::License& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_license: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.License..ReadStrptrMaybe
// Read fields of dev::License from an ascii string.
// The format of the string is an ssim Tuple
bool dev::License_ReadStrptrMaybe(dev::License &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.license") || algo::StripTypeTag(in_str, "dev.License");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && License_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.License..Print
// print string representation of ROW to string STR
// cfmt:dev.License.String  printfmt:Tuple
void dev::License_Print(dev::License& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.license";

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Linelim..ReadFieldMaybe
bool dev::Linelim_ReadFieldMaybe(dev::Linelim& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_nlongline: {
            retval = u32_ReadStrptrMaybe(parent.nlongline, strval);
            break;
        }
        case dev_FieldId_longestline: {
            retval = u32_ReadStrptrMaybe(parent.longestline, strval);
            break;
        }
        case dev_FieldId_nbadws: {
            retval = u32_ReadStrptrMaybe(parent.nbadws, strval);
            break;
        }
        case dev_FieldId_maxws: {
            retval = u32_ReadStrptrMaybe(parent.maxws, strval);
            break;
        }
        case dev_FieldId_nlongfunc: {
            retval = u32_ReadStrptrMaybe(parent.nlongfunc, strval);
            break;
        }
        case dev_FieldId_longestfunc: {
            retval = u32_ReadStrptrMaybe(parent.longestfunc, strval);
            break;
        }
        case dev_FieldId_nmysteryfunc: {
            retval = u32_ReadStrptrMaybe(parent.nmysteryfunc, strval);
            break;
        }
        case dev_FieldId_badness: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.badness, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Linelim..ReadStrptrMaybe
// Read fields of dev::Linelim from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Linelim_ReadStrptrMaybe(dev::Linelim &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.linelim") || algo::StripTypeTag(in_str, "dev.Linelim");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Linelim_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Linelim..Print
// print string representation of ROW to string STR
// cfmt:dev.Linelim.String  printfmt:Tuple
void dev::Linelim_Print(dev::Linelim& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.linelim";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    u32_Print(row.nlongline, temp);
    PrintAttrSpaceReset(str,"nlongline", temp);

    u32_Print(row.longestline, temp);
    PrintAttrSpaceReset(str,"longestline", temp);

    u32_Print(row.nbadws, temp);
    PrintAttrSpaceReset(str,"nbadws", temp);

    u32_Print(row.maxws, temp);
    PrintAttrSpaceReset(str,"maxws", temp);

    u32_Print(row.nlongfunc, temp);
    PrintAttrSpaceReset(str,"nlongfunc", temp);

    u32_Print(row.longestfunc, temp);
    PrintAttrSpaceReset(str,"longestfunc", temp);

    u32_Print(row.nmysteryfunc, temp);
    PrintAttrSpaceReset(str,"nmysteryfunc", temp);

    algo::Smallstr50_Print(row.badness, temp);
    PrintAttrSpaceReset(str,"badness", temp);
}

// --- dev.Mdmark..ReadFieldMaybe
bool dev::Mdmark_ReadFieldMaybe(dev::Mdmark& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_mdmark: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.mdmark, strval);
            break;
        }
        case dev_FieldId_state: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.state, strval);
            break;
        }
        case dev_FieldId_param: {
            retval = algo::cstring_ReadStrptrMaybe(parent.param, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Mdmark..ReadStrptrMaybe
// Read fields of dev::Mdmark from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Mdmark_ReadStrptrMaybe(dev::Mdmark &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.mdmark") || algo::StripTypeTag(in_str, "dev.Mdmark");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mdmark_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Mdmark..Print
// print string representation of ROW to string STR
// cfmt:dev.Mdmark.String  printfmt:Tuple
void dev::Mdmark_Print(dev::Mdmark& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.mdmark";

    algo::Smallstr50_Print(row.mdmark, temp);
    PrintAttrSpaceReset(str,"mdmark", temp);

    algo::Smallstr50_Print(row.state, temp);
    PrintAttrSpaceReset(str,"state", temp);

    algo::cstring_Print(row.param, temp);
    PrintAttrSpaceReset(str,"param", temp);
}

// --- dev.MdmarkCase.mdmark.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::mdmark_ToCstr(const dev::MdmarkCase& parent) throw() {
    const char *ret = NULL;
    switch(mdmark_GetEnum(parent)) {
        case dev_MdmarkCase_MDSECTION      : ret = "MDSECTION";  break;
        case dev_MdmarkCase_CMD            : ret = "CMD";  break;
        case dev_MdmarkCase_TOC            : ret = "TOC";  break;
    }
    return ret;
}

// --- dev.MdmarkCase.mdmark.Print
// Convert mdmark to a string. First, attempt conversion to a known string.
// If no string matches, print mdmark as a numeric value.
void dev::mdmark_Print(const dev::MdmarkCase& parent, algo::cstring &lhs) throw() {
    const char *strval = mdmark_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.mdmark;
    }
}

// --- dev.MdmarkCase.mdmark.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::mdmark_SetStrptrMaybe(dev::MdmarkCase& parent, algo::strptr rhs) throw() {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('C','M','D'): {
                    mdmark_SetEnum(parent,dev_MdmarkCase_CMD); ret = true; break;
                }
                case LE_STR3('T','O','C'): {
                    mdmark_SetEnum(parent,dev_MdmarkCase_TOC); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('M','D','S','E','C','T','I','O'): {
                    if (memcmp(rhs.elems+8,"N",1)==0) { mdmark_SetEnum(parent,dev_MdmarkCase_MDSECTION); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.MdmarkCase.mdmark.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::mdmark_SetStrptr(dev::MdmarkCase& parent, algo::strptr rhs, dev_MdmarkCaseEnum dflt) throw() {
    if (!mdmark_SetStrptrMaybe(parent,rhs)) mdmark_SetEnum(parent,dflt);
}

// --- dev.Mdsection..ReadFieldMaybe
bool dev::Mdsection_ReadFieldMaybe(dev::Mdsection& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_mdsection: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.mdsection, strval);
            break;
        }
        case dev_FieldId_match: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.match, strval);
            break;
        }
        case dev_FieldId_path: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.path, strval);
            break;
        }
        case dev_FieldId_genlist: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.genlist, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Mdsection..ReadStrptrMaybe
// Read fields of dev::Mdsection from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Mdsection_ReadStrptrMaybe(dev::Mdsection &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.mdsection") || algo::StripTypeTag(in_str, "dev.Mdsection");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mdsection_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Mdsection..Print
// print string representation of ROW to string STR
// cfmt:dev.Mdsection.String  printfmt:Tuple
void dev::Mdsection_Print(dev::Mdsection& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.mdsection";

    algo::Smallstr50_Print(row.mdsection, temp);
    PrintAttrSpaceReset(str,"mdsection", temp);

    algo::Smallstr200_Print(row.match, temp);
    PrintAttrSpaceReset(str,"match", temp);

    algo::Smallstr100_Print(row.path, temp);
    PrintAttrSpaceReset(str,"path", temp);

    algo::Smallstr50_Print(row.genlist, temp);
    PrintAttrSpaceReset(str,"genlist", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Msgfile..ReadFieldMaybe
bool dev::Msgfile_ReadFieldMaybe(dev::Msgfile& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_strict: {
            retval = bool_ReadStrptrMaybe(parent.strict, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Msgfile..ReadStrptrMaybe
// Read fields of dev::Msgfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Msgfile_ReadStrptrMaybe(dev::Msgfile &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.msgfile") || algo::StripTypeTag(in_str, "dev.Msgfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Msgfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Msgfile..Print
// print string representation of ROW to string STR
// cfmt:dev.Msgfile.String  printfmt:Tuple
void dev::Msgfile_Print(dev::Msgfile& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.msgfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Noindent..ReadFieldMaybe
bool dev::Noindent_ReadFieldMaybe(dev::Noindent& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Noindent..ReadStrptrMaybe
// Read fields of dev::Noindent from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Noindent_ReadStrptrMaybe(dev::Noindent &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.noindent") || algo::StripTypeTag(in_str, "dev.Noindent");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Noindent_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Noindent..Print
// print string representation of ROW to string STR
// cfmt:dev.Noindent.String  printfmt:Tuple
void dev::Noindent_Print(dev::Noindent& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.noindent";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.OptType..ReadFieldMaybe
bool dev::OptType_ReadFieldMaybe(dev::OptType& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_opt_type: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.opt_type, strval);
            break;
        }
        case dev_FieldId_sep: {
            retval = algo::RspaceStr4_ReadStrptrMaybe(parent.sep, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.OptType..ReadStrptrMaybe
// Read fields of dev::OptType from an ascii string.
// The format of the string is an ssim Tuple
bool dev::OptType_ReadStrptrMaybe(dev::OptType &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.opt_type") || algo::StripTypeTag(in_str, "dev.OptType");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptType_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.OptType..Print
// print string representation of ROW to string STR
// cfmt:dev.OptType.String  printfmt:Tuple
void dev::OptType_Print(dev::OptType& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.opt_type";

    algo::Smallstr50_Print(row.opt_type, temp);
    PrintAttrSpaceReset(str,"opt_type", temp);

    algo::RspaceStr4_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Package..ReadFieldMaybe
bool dev::Package_ReadFieldMaybe(dev::Package& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_package: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.package, strval);
            break;
        }
        case dev_FieldId_baseref: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.baseref, strval);
            break;
        }
        case dev_FieldId_origin: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.origin, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Package..ReadStrptrMaybe
// Read fields of dev::Package from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Package_ReadStrptrMaybe(dev::Package &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.package") || algo::StripTypeTag(in_str, "dev.Package");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Package_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Package..Print
// print string representation of ROW to string STR
// cfmt:dev.Package.String  printfmt:Tuple
void dev::Package_Print(dev::Package& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.package";

    algo::Smallstr50_Print(row.package, temp);
    PrintAttrSpaceReset(str,"package", temp);

    algo::Smallstr50_Print(row.baseref, temp);
    PrintAttrSpaceReset(str,"baseref", temp);

    algo::Smallstr200_Print(row.origin, temp);
    PrintAttrSpaceReset(str,"origin", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Pkgdep.package.Get
algo::Smallstr50 dev::package_Get(dev::Pkgdep& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pkgdep, ".RL"));
    return ret;
}

// --- dev.Pkgdep.package.Get2
algo::Smallstr50 dev::Pkgdep_package_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Pkgdep.parent.Get
algo::Smallstr50 dev::parent_Get(dev::Pkgdep& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pkgdep, ".RR"));
    return ret;
}

// --- dev.Pkgdep.parent.Get2
algo::Smallstr50 dev::Pkgdep_parent_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Pkgdep..Concat_package_parent
tempstr dev::Pkgdep_Concat_package_parent( const algo::strptr& package ,const algo::strptr& parent ) {
    return tempstr() << package <<'.'<< parent ;
}

// --- dev.Pkgdep..ReadFieldMaybe
bool dev::Pkgdep_ReadFieldMaybe(dev::Pkgdep& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_pkgdep: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.pkgdep, strval);
            break;
        }
        case dev_FieldId_package: {
            retval = false;
            break;
        }
        case dev_FieldId_parent: {
            retval = false;
            break;
        }
        case dev_FieldId_soft: {
            retval = bool_ReadStrptrMaybe(parent.soft, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Pkgdep..ReadStrptrMaybe
// Read fields of dev::Pkgdep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Pkgdep_ReadStrptrMaybe(dev::Pkgdep &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.pkgdep") || algo::StripTypeTag(in_str, "dev.Pkgdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pkgdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Pkgdep..Print
// print string representation of ROW to string STR
// cfmt:dev.Pkgdep.String  printfmt:Tuple
void dev::Pkgdep_Print(dev::Pkgdep& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.pkgdep";

    algo::Smallstr100_Print(row.pkgdep, temp);
    PrintAttrSpaceReset(str,"pkgdep", temp);

    bool_Print(row.soft, temp);
    PrintAttrSpaceReset(str,"soft", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Pkgkey.package.Get
algo::Smallstr50 dev::package_Get(dev::Pkgkey& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pkgkey, "/LL"));
    return ret;
}

// --- dev.Pkgkey.package.Get2
algo::Smallstr50 dev::Pkgkey_package_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Pkgkey.key.Get
algo::Smallstr150 dev::key_Get(dev::Pkgkey& parent) throw() {
    algo::Smallstr150 ret(algo::Pathcomp(parent.pkgkey, "/LR"));
    return ret;
}

// --- dev.Pkgkey.key.Get2
algo::Smallstr150 dev::Pkgkey_key_Get(algo::strptr arg) throw() {
    algo::Smallstr150 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dev.Pkgkey..Concat_package_key
tempstr dev::Pkgkey_Concat_package_key( const algo::strptr& package ,const algo::strptr& key ) {
    return tempstr() << package <<'/'<< key ;
}

// --- dev.Pkgkey..ReadFieldMaybe
bool dev::Pkgkey_ReadFieldMaybe(dev::Pkgkey& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_pkgkey: {
            retval = algo::Smallstr150_ReadStrptrMaybe(parent.pkgkey, strval);
            break;
        }
        case dev_FieldId_package: {
            retval = false;
            break;
        }
        case dev_FieldId_key: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Pkgkey..ReadStrptrMaybe
// Read fields of dev::Pkgkey from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Pkgkey_ReadStrptrMaybe(dev::Pkgkey &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.pkgkey") || algo::StripTypeTag(in_str, "dev.Pkgkey");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pkgkey_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Pkgkey..Print
// print string representation of ROW to string STR
// cfmt:dev.Pkgkey.String  printfmt:Tuple
void dev::Pkgkey_Print(dev::Pkgkey& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.pkgkey";

    algo::Smallstr150_Print(row.pkgkey, temp);
    PrintAttrSpaceReset(str,"pkgkey", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Readme..ReadFieldMaybe
bool dev::Readme_ReadFieldMaybe(dev::Readme& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_inl: {
            retval = bool_ReadStrptrMaybe(parent.inl, strval);
            break;
        }
        case dev_FieldId_sandbox: {
            retval = bool_ReadStrptrMaybe(parent.sandbox, strval);
            break;
        }
        case dev_FieldId_filter: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.filter, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Readme..ReadStrptrMaybe
// Read fields of dev::Readme from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Readme_ReadStrptrMaybe(dev::Readme &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.readme") || algo::StripTypeTag(in_str, "dev.Readme");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Readme_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Readme..Print
// print string representation of ROW to string STR
// cfmt:dev.Readme.String  printfmt:Tuple
void dev::Readme_Print(dev::Readme& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.readme";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    bool_Print(row.inl, temp);
    PrintAttrSpaceReset(str,"inl", temp);

    bool_Print(row.sandbox, temp);
    PrintAttrSpaceReset(str,"sandbox", temp);

    algo::Smallstr100_Print(row.filter, temp);
    PrintAttrSpaceReset(str,"filter", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Readmesort..ReadFieldMaybe
bool dev::Readmesort_ReadFieldMaybe(dev::Readmesort& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_readmesort: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.readmesort, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Readmesort..ReadStrptrMaybe
// Read fields of dev::Readmesort from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Readmesort_ReadStrptrMaybe(dev::Readmesort &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.readmesort") || algo::StripTypeTag(in_str, "dev.Readmesort");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Readmesort_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Readmesort..Print
// print string representation of ROW to string STR
// cfmt:dev.Readmesort.String  printfmt:Tuple
void dev::Readmesort_Print(dev::Readmesort& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.readmesort";

    algo::Smallstr250_Print(row.readmesort, temp);
    PrintAttrSpaceReset(str,"readmesort", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Sandbox..ReadFieldMaybe
bool dev::Sandbox_ReadFieldMaybe(dev::Sandbox& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_sandbox: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.sandbox, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Sandbox..ReadStrptrMaybe
// Read fields of dev::Sandbox from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Sandbox_ReadStrptrMaybe(dev::Sandbox &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.sandbox") || algo::StripTypeTag(in_str, "dev.Sandbox");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sandbox_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Sandbox..Print
// print string representation of ROW to string STR
// cfmt:dev.Sandbox.String  printfmt:Tuple
void dev::Sandbox_Print(dev::Sandbox& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.sandbox";

    algo::Smallstr50_Print(row.sandbox, temp);
    PrintAttrSpaceReset(str,"sandbox", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Sbpath..ReadFieldMaybe
bool dev::Sbpath_ReadFieldMaybe(dev::Sbpath& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_sbpath: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.sbpath, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Sbpath..ReadStrptrMaybe
// Read fields of dev::Sbpath from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Sbpath_ReadStrptrMaybe(dev::Sbpath &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.sbpath") || algo::StripTypeTag(in_str, "dev.Sbpath");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sbpath_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Sbpath..Print
// print string representation of ROW to string STR
// cfmt:dev.Sbpath.String  printfmt:Tuple
void dev::Sbpath_Print(dev::Sbpath& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.sbpath";

    algo::Smallstr50_Print(row.sbpath, temp);
    PrintAttrSpaceReset(str,"sbpath", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Scriptfile.name.Get
algo::Smallstr50 dev::name_Get(dev::Scriptfile& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gitfile, "/RR"));
    return ret;
}

// --- dev.Scriptfile.name.Get2
algo::Smallstr50 dev::Scriptfile_name_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dev.Scriptfile..ReadFieldMaybe
bool dev::Scriptfile_ReadFieldMaybe(dev::Scriptfile& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_gitfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval);
            break;
        }
        case dev_FieldId_name: {
            retval = false;
            break;
        }
        case dev_FieldId_license: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Scriptfile..ReadStrptrMaybe
// Read fields of dev::Scriptfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Scriptfile_ReadStrptrMaybe(dev::Scriptfile &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.scriptfile") || algo::StripTypeTag(in_str, "dev.Scriptfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Scriptfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Scriptfile..Print
// print string representation of ROW to string STR
// cfmt:dev.Scriptfile.String  printfmt:Tuple
void dev::Scriptfile_Print(dev::Scriptfile& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.scriptfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Srcfile.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Srcfile& parent) throw() {
    algo::Smallstr10 ret(algo::Pathcomp(parent.srcfile, ".RR"));
    return ret;
}

// --- dev.Srcfile.ext.Get2
algo::Smallstr10 dev::Srcfile_ext_Get(algo::strptr arg) throw() {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Srcfile..ReadFieldMaybe
bool dev::Srcfile_ReadFieldMaybe(dev::Srcfile& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_srcfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.srcfile, strval);
            break;
        }
        case dev_FieldId_ext: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Srcfile..ReadStrptrMaybe
// Read fields of dev::Srcfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Srcfile_ReadStrptrMaybe(dev::Srcfile &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.srcfile") || algo::StripTypeTag(in_str, "dev.Srcfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Srcfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Srcfile..Print
// print string representation of ROW to string STR
// cfmt:dev.Srcfile.String  printfmt:Tuple
void dev::Srcfile_Print(dev::Srcfile& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.srcfile";

    algo::Smallstr200_Print(row.srcfile, temp);
    PrintAttrSpaceReset(str,"srcfile", temp);
}

// --- dev.Syscmd..ReadFieldMaybe
bool dev::Syscmd_ReadFieldMaybe(dev::Syscmd& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_syscmd: {
            retval = i64_ReadStrptrMaybe(parent.syscmd, strval);
            break;
        }
        case dev_FieldId_execkey: {
            retval = false;
            break;
        }
        case dev_FieldId_command: {
            retval = algo::cstring_ReadStrptrMaybe(parent.command, strval);
            break;
        }
        case dev_FieldId_pid: {
            retval = i32_ReadStrptrMaybe(parent.pid, strval);
            break;
        }
        case dev_FieldId_status: {
            retval = i32_ReadStrptrMaybe(parent.status, strval);
            break;
        }
        case dev_FieldId_nprereq: {
            retval = i32_ReadStrptrMaybe(parent.nprereq, strval);
            break;
        }
        case dev_FieldId_fail_prereq: {
            retval = bool_ReadStrptrMaybe(parent.fail_prereq, strval);
            break;
        }
        case dev_FieldId_completed: {
            retval = bool_ReadStrptrMaybe(parent.completed, strval);
            break;
        }
        case dev_FieldId_maxtime: {
            retval = i32_ReadStrptrMaybe(parent.maxtime, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmd..ReadStrptrMaybe
// Read fields of dev::Syscmd from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmd_ReadStrptrMaybe(dev::Syscmd &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syscmd") || algo::StripTypeTag(in_str, "dev.Syscmd");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmd_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmd..Print
// print string representation of ROW to string STR
// cfmt:dev.Syscmd.String  printfmt:Tuple
void dev::Syscmd_Print(dev::Syscmd& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.syscmd";

    i64_Print(row.syscmd, temp);
    PrintAttrSpaceReset(str,"syscmd", temp);

    algo::cstring_Print(row.command, temp);
    PrintAttrSpaceReset(str,"command", temp);

    i32_Print(row.pid, temp);
    PrintAttrSpaceReset(str,"pid", temp);

    i32_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    i32_Print(row.nprereq, temp);
    PrintAttrSpaceReset(str,"nprereq", temp);

    bool_Print(row.fail_prereq, temp);
    PrintAttrSpaceReset(str,"fail_prereq", temp);

    bool_Print(row.completed, temp);
    PrintAttrSpaceReset(str,"completed", temp);

    i32_Print(row.maxtime, temp);
    PrintAttrSpaceReset(str,"maxtime", temp);
}

// --- dev.Syscmddep..ReadFieldMaybe
bool dev::Syscmddep_ReadFieldMaybe(dev::Syscmddep& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_syscmddep: {
            retval = false;
            break;
        }
        case dev_FieldId_child: {
            retval = i64_ReadStrptrMaybe(parent.child, strval);
            break;
        }
        case dev_FieldId_parent: {
            retval = i64_ReadStrptrMaybe(parent.parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmddep..ReadStrptrMaybe
// Read fields of dev::Syscmddep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmddep_ReadStrptrMaybe(dev::Syscmddep &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syscmddep") || algo::StripTypeTag(in_str, "dev.Syscmddep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmddep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmddep..Print
// print string representation of ROW to string STR
// cfmt:dev.Syscmddep.String  printfmt:Tuple
void dev::Syscmddep_Print(dev::Syscmddep& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.syscmddep";

    i64_Print(row.child, temp);
    PrintAttrSpaceReset(str,"child", temp);

    i64_Print(row.parent, temp);
    PrintAttrSpaceReset(str,"parent", temp);
}

// --- dev.Syslib..ReadFieldMaybe
bool dev::Syslib_ReadFieldMaybe(dev::Syslib& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_syslib: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.syslib, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syslib..ReadStrptrMaybe
// Read fields of dev::Syslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syslib_ReadStrptrMaybe(dev::Syslib &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syslib") || algo::StripTypeTag(in_str, "dev.Syslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syslib..Print
// print string representation of ROW to string STR
// cfmt:dev.Syslib.String  printfmt:Tuple
void dev::Syslib_Print(dev::Syslib& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.syslib";

    algo::Smallstr50_Print(row.syslib, temp);
    PrintAttrSpaceReset(str,"syslib", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targdep.target.Get
algo::Smallstr16 dev::target_Get(dev::Targdep& parent) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RL"));
    return ret;
}

// --- dev.Targdep.target.Get2
algo::Smallstr16 dev::Targdep_target_Get(algo::strptr arg) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targdep.parent.Get
algo::Smallstr16 dev::parent_Get(dev::Targdep& parent) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RR"));
    return ret;
}

// --- dev.Targdep.parent.Get2
algo::Smallstr16 dev::Targdep_parent_Get(algo::strptr arg) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targdep..Concat_target_parent
tempstr dev::Targdep_Concat_target_parent( const algo::strptr& target ,const algo::strptr& parent ) {
    return tempstr() << target <<'.'<< parent ;
}

// --- dev.Targdep..ReadFieldMaybe
bool dev::Targdep_ReadFieldMaybe(dev::Targdep& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_targdep: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.targdep, strval);
            break;
        }
        case dev_FieldId_target: {
            retval = false;
            break;
        }
        case dev_FieldId_parent: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targdep..ReadStrptrMaybe
// Read fields of dev::Targdep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targdep_ReadStrptrMaybe(dev::Targdep &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targdep") || algo::StripTypeTag(in_str, "dev.Targdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targdep..Print
// print string representation of ROW to string STR
// cfmt:dev.Targdep.String  printfmt:Tuple
void dev::Targdep_Print(dev::Targdep& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.targdep";

    algo::Smallstr50_Print(row.targdep, temp);
    PrintAttrSpaceReset(str,"targdep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Target..ReadFieldMaybe
bool dev::Target_ReadFieldMaybe(dev::Target& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_target: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Target..ReadStrptrMaybe
// Read fields of dev::Target from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Target_ReadStrptrMaybe(dev::Target &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.target") || algo::StripTypeTag(in_str, "dev.Target");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Target_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Target..Print
// print string representation of ROW to string STR
// cfmt:dev.Target.String  printfmt:Tuple
void dev::Target_Print(dev::Target& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.target";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);
}

// --- dev.Targsrc.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsrc& parent) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsrc, "/LL"));
    return ret;
}

// --- dev.Targsrc.target.Get2
algo::Smallstr16 dev::Targsrc_target_Get(algo::strptr arg) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Targsrc.src.Get
algo::Smallstr200 dev::src_Get(dev::Targsrc& parent) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(parent.targsrc, "/LR"));
    return ret;
}

// --- dev.Targsrc.src.Get2
algo::Smallstr200 dev::Targsrc_src_Get(algo::strptr arg) throw() {
    algo::Smallstr200 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dev.Targsrc.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Targsrc& parent) throw() {
    algo::Smallstr10 ret(algo::Pathcomp(parent.targsrc, ".RR"));
    return ret;
}

// --- dev.Targsrc.ext.Get2
algo::Smallstr10 dev::Targsrc_ext_Get(algo::strptr arg) throw() {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsrc..Concat_target_src
tempstr dev::Targsrc_Concat_target_src( const algo::strptr& target ,const algo::strptr& src ) {
    return tempstr() << target <<'/'<< src ;
}

// --- dev.Targsrc..ReadFieldMaybe
bool dev::Targsrc_ReadFieldMaybe(dev::Targsrc& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_targsrc: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.targsrc, strval);
            break;
        }
        case dev_FieldId_target: {
            retval = false;
            break;
        }
        case dev_FieldId_src: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        case dev_FieldId_ext: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsrc..ReadStrptrMaybe
// Read fields of dev::Targsrc from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsrc_ReadStrptrMaybe(dev::Targsrc &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsrc") || algo::StripTypeTag(in_str, "dev.Targsrc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsrc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsrc..Print
// print string representation of ROW to string STR
// cfmt:dev.Targsrc.String  printfmt:Tuple
void dev::Targsrc_Print(dev::Targsrc& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.targsrc";

    algo::Smallstr100_Print(row.targsrc, temp);
    PrintAttrSpaceReset(str,"targsrc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targsyslib.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsyslib& parent) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsyslib, "/LR.LL"));
    return ret;
}

// --- dev.Targsyslib.target.Get2
algo::Smallstr16 dev::Targsyslib_target_Get(algo::strptr arg) throw() {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LR.LL"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get
algo::Smallstr50 dev::syslib_Get(dev::Targsyslib& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsyslib, "/LR.LR"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get2
algo::Smallstr50 dev::Targsyslib_syslib_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR.LR"));
    return ret;
}

// --- dev.Targsyslib.uname.Get
algo::Smallstr50 dev::uname_Get(dev::Targsyslib& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsyslib, "/LL"));
    return ret;
}

// --- dev.Targsyslib.uname.Get2
algo::Smallstr50 dev::Targsyslib_uname_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Targsyslib..Concat_uname_target_syslib
tempstr dev::Targsyslib_Concat_uname_target_syslib( const algo::strptr& uname ,const algo::strptr& target ,const algo::strptr& syslib ) {
    return tempstr() << uname <<'/'<< target <<'.'<< syslib ;
}

// --- dev.Targsyslib..ReadFieldMaybe
bool dev::Targsyslib_ReadFieldMaybe(dev::Targsyslib& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_targsyslib: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsyslib, strval);
            break;
        }
        case dev_FieldId_target: {
            retval = false;
            break;
        }
        case dev_FieldId_syslib: {
            retval = false;
            break;
        }
        case dev_FieldId_uname: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsyslib..ReadStrptrMaybe
// Read fields of dev::Targsyslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsyslib_ReadStrptrMaybe(dev::Targsyslib &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsyslib") || algo::StripTypeTag(in_str, "dev.Targsyslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsyslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsyslib..Print
// print string representation of ROW to string STR
// cfmt:dev.Targsyslib.String  printfmt:Tuple
void dev::Targsyslib_Print(dev::Targsyslib& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.targsyslib";

    algo::Smallstr50_Print(row.targsyslib, temp);
    PrintAttrSpaceReset(str,"targsyslib", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Tgtcov..ReadFieldMaybe
bool dev::Tgtcov_ReadFieldMaybe(dev::Tgtcov& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_target: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval);
            break;
        }
        case dev_FieldId_cov_min: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.cov_min, strval);
            break;
        }
        case dev_FieldId_maxerr: {
            retval = algo::U32Dec2_ReadStrptrMaybe(parent.maxerr, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Tgtcov..ReadStrptrMaybe
// Read fields of dev::Tgtcov from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Tgtcov_ReadStrptrMaybe(dev::Tgtcov &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tgtcov") || algo::StripTypeTag(in_str, "dev.Tgtcov");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tgtcov_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Tgtcov..Print
// print string representation of ROW to string STR
// cfmt:dev.Tgtcov.String  printfmt:Tuple
void dev::Tgtcov_Print(dev::Tgtcov& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.tgtcov";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::U32Dec2_Print(row.cov_min, temp);
    PrintAttrSpaceReset(str,"cov_min", temp);

    algo::U32Dec2_Print(row.maxerr, temp);
    PrintAttrSpaceReset(str,"maxerr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Timefmt..ReadFieldMaybe
bool dev::Timefmt_ReadFieldMaybe(dev::Timefmt& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_timefmt: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.timefmt, strval);
            break;
        }
        case dev_FieldId_dirname: {
            retval = bool_ReadStrptrMaybe(parent.dirname, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Timefmt..ReadStrptrMaybe
// Read fields of dev::Timefmt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Timefmt_ReadStrptrMaybe(dev::Timefmt &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.timefmt") || algo::StripTypeTag(in_str, "dev.Timefmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Timefmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Timefmt..Print
// print string representation of ROW to string STR
// cfmt:dev.Timefmt.String  printfmt:Tuple
void dev::Timefmt_Print(dev::Timefmt& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.timefmt";

    algo::Smallstr100_Print(row.timefmt, temp);
    PrintAttrSpaceReset(str,"timefmt", temp);

    bool_Print(row.dirname, temp);
    PrintAttrSpaceReset(str,"dirname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.ToolOpt.uname.Get
algo::Smallstr50 dev::uname_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.uname.Get2
algo::Smallstr50 dev::ToolOpt_uname_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get2
algo::Smallstr50 dev::ToolOpt_compiler_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get2
algo::Smallstr50 dev::ToolOpt_cfg_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.arch.Get
algo::Smallstr50 dev::arch_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt.arch.Get2
algo::Smallstr50 dev::ToolOpt_arch_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt.target.Get
algo::Smallstr50 dev::target_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.target.Get2
algo::Smallstr50 dev::ToolOpt_target_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.opt_type.Get
algo::Smallstr50 dev::opt_type_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt_type.Get2
algo::Smallstr50 dev::ToolOpt_opt_type_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get
algo::Smallstr100 dev::opt_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr100 ret(algo::Pathcomp(parent.tool_opt, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get2
algo::Smallstr100 dev::ToolOpt_opt_Get(algo::strptr arg) throw() {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get
algo::Smallstr50 dev::sortfld_Get(dev::ToolOpt& parent) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, ".LL"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get2
algo::Smallstr50 dev::ToolOpt_sortfld_Get(algo::strptr arg) throw() {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dev.ToolOpt..Concat_uname_compiler_cfg_arch_target_opt_type_opt
tempstr dev::ToolOpt_Concat_uname_compiler_cfg_arch_target_opt_type_opt( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ,const algo::strptr& target ,const algo::strptr& opt_type ,const algo::strptr& opt ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch <<'/'<< target <<'-'<< opt_type <<':'<< opt ;
}

// --- dev.ToolOpt..ReadFieldMaybe
bool dev::ToolOpt_ReadFieldMaybe(dev::ToolOpt& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_tool_opt: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.tool_opt, strval);
            break;
        }
        case dev_FieldId_uname: {
            retval = false;
            break;
        }
        case dev_FieldId_compiler: {
            retval = false;
            break;
        }
        case dev_FieldId_cfg: {
            retval = false;
            break;
        }
        case dev_FieldId_arch: {
            retval = false;
            break;
        }
        case dev_FieldId_target: {
            retval = false;
            break;
        }
        case dev_FieldId_opt_type: {
            retval = false;
            break;
        }
        case dev_FieldId_opt: {
            retval = false;
            break;
        }
        case dev_FieldId_sortfld: {
            retval = false;
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.ToolOpt..ReadStrptrMaybe
// Read fields of dev::ToolOpt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::ToolOpt_ReadStrptrMaybe(dev::ToolOpt &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tool_opt") || algo::StripTypeTag(in_str, "dev.ToolOpt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ToolOpt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.ToolOpt..Print
// print string representation of ROW to string STR
// cfmt:dev.ToolOpt.String  printfmt:Tuple
void dev::ToolOpt_Print(dev::ToolOpt& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.tool_opt";

    algo::Smallstr100_Print(row.tool_opt, temp);
    PrintAttrSpaceReset(str,"tool_opt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Uname..ReadFieldMaybe
bool dev::Uname_ReadFieldMaybe(dev::Uname& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_uname: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Uname..ReadStrptrMaybe
// Read fields of dev::Uname from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Uname_ReadStrptrMaybe(dev::Uname &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.uname") || algo::StripTypeTag(in_str, "dev.Uname");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Uname_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Uname..Print
// print string representation of ROW to string STR
// cfmt:dev.Uname.String  printfmt:Tuple
void dev::Uname_Print(dev::Uname& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.uname";

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Unstablefld..ReadFieldMaybe
bool dev::Unstablefld_ReadFieldMaybe(dev::Unstablefld& parent, algo::strptr field, algo::strptr strval) throw() {
    bool retval = true;
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dev_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dev_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Unstablefld..ReadStrptrMaybe
// Read fields of dev::Unstablefld from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Unstablefld_ReadStrptrMaybe(dev::Unstablefld &parent, algo::strptr in_str) throw() {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.unstablefld") || algo::StripTypeTag(in_str, "dev.Unstablefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Unstablefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Unstablefld..Print
// print string representation of ROW to string STR
// cfmt:dev.Unstablefld.String  printfmt:Tuple
void dev::Unstablefld_Print(dev::Unstablefld& row, algo::cstring& str) throw() {
    algo::tempstr temp;
    str << "dev.unstablefld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev...SizeCheck
inline static void dev::SizeCheck() {
}
