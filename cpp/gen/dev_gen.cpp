//
// cpp/gen/dev_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dev.Arch.arch
const char *dev_Arch_arch_         = "";
const char *dev_Arch_arch_i386     = "i386";
const char *dev_Arch_arch_i686     = "i686";
const char *dev_Arch_arch_i86pc    = "i86pc";
const char *dev_Arch_arch_x64      = "x64";
const char *dev_Arch_arch_x86_64   = "x86_64";

// compile-time string constants for dev.Builddir.builddir
const char *dev_Builddir_builddir_dflt_coverage_x86_64   = "dflt.coverage-x86_64";
const char *dev_Builddir_builddir_dflt_debug_x86_64      = "dflt.debug-x86_64";
const char *dev_Builddir_builddir_dflt_profile_x86_64    = "dflt.profile-x86_64";
const char *dev_Builddir_builddir_dflt_release_x86_64    = "dflt.release-x86_64";

// compile-time string constants for dev.Cfg.cfg
const char *dev_Cfg_cfg_   = "";

const char *dev_Cfg_cfg_coverage   = "coverage";
const char *dev_Cfg_cfg_debug      = "debug";

const char *dev_Cfg_cfg_profile   = "profile";
const char *dev_Cfg_cfg_release   = "release";

// compile-time string constants for dev.Compiler.compiler
const char *dev_Compiler_compiler_          = "";
const char *dev_Compiler_compiler_clangPP   = "clang++";
const char *dev_Compiler_compiler_gPP       = "g++";
const char *dev_Compiler_compiler_gPP_9     = "g++-9";

namespace dev {
    static void          SizeCheck();
} // end namespace dev

// --- dev.Arch..ReadFieldMaybe
bool dev::Arch_ReadFieldMaybe(dev::Arch &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_arch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Arch..ReadStrptrMaybe
// Read fields of dev::Arch from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Arch_ReadStrptrMaybe(dev::Arch &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.arch") || algo::StripTypeTag(in_str, "dev.Arch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Arch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Arch..Print
// print string representation of dev::Arch to string LHS, no header -- cprint:dev.Arch.String
void dev::Arch_Print(dev::Arch & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.arch";

    algo::Smallstr50_Print(row.arch, temp);
    PrintAttrSpaceReset(str,"arch", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Badline..ReadFieldMaybe
bool dev::Badline_ReadFieldMaybe(dev::Badline &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_badline: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badline, strval); break;
        case dev_FieldId_expr: retval = algo::Smallstr200_ReadStrptrMaybe(parent.expr, strval); break;
        case dev_FieldId_targsrc_regx: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsrc_regx, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Badline..ReadStrptrMaybe
// Read fields of dev::Badline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Badline_ReadStrptrMaybe(dev::Badline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.badline") || algo::StripTypeTag(in_str, "dev.Badline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Badline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Badline..Print
// print string representation of dev::Badline to string LHS, no header -- cprint:dev.Badline.String
void dev::Badline_Print(dev::Badline & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.badline";

    algo::Smallstr50_Print(row.badline, temp);
    PrintAttrSpaceReset(str,"badline", temp);

    algo::Smallstr200_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr50_Print(row.targsrc_regx, temp);
    PrintAttrSpaceReset(str,"targsrc_regx", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Builddir.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.cfg.Get2
algo::Smallstr50 dev::Builddir_cfg_Get(strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LL"));
    return ret;
}

// --- dev.Builddir..ReadFieldMaybe
bool dev::Builddir_ReadFieldMaybe(dev::Builddir &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_builddir: retval = algo::Smallstr50_ReadStrptrMaybe(parent.builddir, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Builddir..ReadStrptrMaybe
// Read fields of dev::Builddir from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Builddir_ReadStrptrMaybe(dev::Builddir &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.builddir") || algo::StripTypeTag(in_str, "dev.Builddir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Builddir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Builddir..Print
// print string representation of dev::Builddir to string LHS, no header -- cprint:dev.Builddir.String
void dev::Builddir_Print(dev::Builddir & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.builddir";

    algo::Smallstr50_Print(row.builddir, temp);
    PrintAttrSpaceReset(str,"builddir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Cfg..ReadFieldMaybe
bool dev::Cfg_ReadFieldMaybe(dev::Cfg &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Cfg..ReadStrptrMaybe
// Read fields of dev::Cfg from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Cfg_ReadStrptrMaybe(dev::Cfg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.cfg") || algo::StripTypeTag(in_str, "dev.Cfg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Cfg..Print
// print string representation of dev::Cfg to string LHS, no header -- cprint:dev.Cfg.String
void dev::Cfg_Print(dev::Cfg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.cfg";

    algo::Smallstr50_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Compiler..ReadFieldMaybe
bool dev::Compiler_ReadFieldMaybe(dev::Compiler &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_compiler: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval); break;
        case dev_FieldId_dflt: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dflt, strval); break;
        case dev_FieldId_ranlib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ranlib, strval); break;
        case dev_FieldId_ar: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ar, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Compiler..ReadStrptrMaybe
// Read fields of dev::Compiler from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Compiler_ReadStrptrMaybe(dev::Compiler &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.compiler") || algo::StripTypeTag(in_str, "dev.Compiler");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Compiler_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Compiler..Print
// print string representation of dev::Compiler to string LHS, no header -- cprint:dev.Compiler.String
void dev::Compiler_Print(dev::Compiler & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.compiler";

    algo::Smallstr50_Print(row.compiler, temp);
    PrintAttrSpaceReset(str,"compiler", temp);

    algo::Smallstr50_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Smallstr50_Print(row.ranlib, temp);
    PrintAttrSpaceReset(str,"ranlib", temp);

    algo::Smallstr50_Print(row.ar, temp);
    PrintAttrSpaceReset(str,"ar", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::value_ToCstr(const dev::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dev_FieldId_arch              : ret = "arch";  break;
        case dev_FieldId_comment           : ret = "comment";  break;
        case dev_FieldId_badline           : ret = "badline";  break;
        case dev_FieldId_expr              : ret = "expr";  break;
        case dev_FieldId_targsrc_regx      : ret = "targsrc_regx";  break;
        case dev_FieldId_builddir          : ret = "builddir";  break;
        case dev_FieldId_cfg               : ret = "cfg";  break;
        case dev_FieldId_compiler          : ret = "compiler";  break;
        case dev_FieldId_dflt              : ret = "dflt";  break;
        case dev_FieldId_ranlib            : ret = "ranlib";  break;
        case dev_FieldId_ar                : ret = "ar";  break;
        case dev_FieldId_gitfile           : ret = "gitfile";  break;
        case dev_FieldId_ext               : ret = "ext";  break;
        case dev_FieldId_gitinfo           : ret = "gitinfo";  break;
        case dev_FieldId_author            : ret = "author";  break;
        case dev_FieldId_compver           : ret = "compver";  break;
        case dev_FieldId_package           : ret = "package";  break;
        case dev_FieldId_include           : ret = "include";  break;
        case dev_FieldId_srcfile           : ret = "srcfile";  break;
        case dev_FieldId_filename          : ret = "filename";  break;
        case dev_FieldId_sys               : ret = "sys";  break;
        case dev_FieldId_nlongline         : ret = "nlongline";  break;
        case dev_FieldId_longestline       : ret = "longestline";  break;
        case dev_FieldId_nbadws            : ret = "nbadws";  break;
        case dev_FieldId_maxws             : ret = "maxws";  break;
        case dev_FieldId_nlongfunc         : ret = "nlongfunc";  break;
        case dev_FieldId_longestfunc       : ret = "longestfunc";  break;
        case dev_FieldId_nmysteryfunc      : ret = "nmysteryfunc";  break;
        case dev_FieldId_badness           : ret = "badness";  break;
        case dev_FieldId_opt_type          : ret = "opt_type";  break;
        case dev_FieldId_sep               : ret = "sep";  break;
        case dev_FieldId_args              : ret = "args";  break;
        case dev_FieldId_syscmd            : ret = "syscmd";  break;
        case dev_FieldId_execkey           : ret = "execkey";  break;
        case dev_FieldId_command           : ret = "command";  break;
        case dev_FieldId_pid               : ret = "pid";  break;
        case dev_FieldId_status            : ret = "status";  break;
        case dev_FieldId_nprereq           : ret = "nprereq";  break;
        case dev_FieldId_fail_prereq       : ret = "fail_prereq";  break;
        case dev_FieldId_completed         : ret = "completed";  break;
        case dev_FieldId_maxtime           : ret = "maxtime";  break;
        case dev_FieldId_syscmddep         : ret = "syscmddep";  break;
        case dev_FieldId_child             : ret = "child";  break;
        case dev_FieldId_parent            : ret = "parent";  break;
        case dev_FieldId_syslib            : ret = "syslib";  break;
        case dev_FieldId_targdep           : ret = "targdep";  break;
        case dev_FieldId_target            : ret = "target";  break;
        case dev_FieldId_targsrc           : ret = "targsrc";  break;
        case dev_FieldId_src               : ret = "src";  break;
        case dev_FieldId_targsyslib        : ret = "targsyslib";  break;
        case dev_FieldId_uname             : ret = "uname";  break;
        case dev_FieldId_tool_opt          : ret = "tool_opt";  break;
        case dev_FieldId_opt               : ret = "opt";  break;
        case dev_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- dev.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dev::value_Print(const dev::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dev.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(ReadLE16(rhs.elems))) {
                case LE_STR2('a','r'): {
                    value_SetEnum(parent,dev_FieldId_ar); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,dev_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_ext); ret = true; break;
                }
                case LE_STR3('o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_opt); ret = true; break;
                }
                case LE_STR3('p','i','d'): {
                    value_SetEnum(parent,dev_FieldId_pid); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dev_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_src); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dev_FieldId_sys); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(ReadLE32(rhs.elems))) {
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,dev_FieldId_arch); ret = true; break;
                }
                case LE_STR4('a','r','g','s'): {
                    value_SetEnum(parent,dev_FieldId_args); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,dev_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dev_FieldId_expr); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('c','h','i','l','d'): {
                    value_SetEnum(parent,dev_FieldId_child); ret = true; break;
                }
                case LE_STR5('m','a','x','w','s'): {
                    value_SetEnum(parent,dev_FieldId_maxws); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dev_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','u','t','h','o','r'): {
                    value_SetEnum(parent,dev_FieldId_author); ret = true; break;
                }
                case LE_STR6('n','b','a','d','w','s'): {
                    value_SetEnum(parent,dev_FieldId_nbadws); ret = true; break;
                }
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_parent); ret = true; break;
                }
                case LE_STR6('r','a','n','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_ranlib); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,dev_FieldId_status); ret = true; break;
                }
                case LE_STR6('s','y','s','c','m','d'): {
                    value_SetEnum(parent,dev_FieldId_syscmd); ret = true; break;
                }
                case LE_STR6('s','y','s','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_syslib); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,dev_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_badline); ret = true; break;
                }
                case LE_STR7('b','a','d','n','e','s','s'): {
                    value_SetEnum(parent,dev_FieldId_badness); ret = true; break;
                }
                case LE_STR7('c','o','m','m','a','n','d'): {
                    value_SetEnum(parent,dev_FieldId_command); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','m','p','v','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compver); ret = true; break;
                }
                case LE_STR7('e','x','e','c','k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_execkey); ret = true; break;
                }
                case LE_STR7('g','i','t','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_gitfile); ret = true; break;
                }
                case LE_STR7('g','i','t','i','n','f','o'): {
                    value_SetEnum(parent,dev_FieldId_gitinfo); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,dev_FieldId_include); ret = true; break;
                }
                case LE_STR7('m','a','x','t','i','m','e'): {
                    value_SetEnum(parent,dev_FieldId_maxtime); ret = true; break;
                }
                case LE_STR7('n','p','r','e','r','e','q'): {
                    value_SetEnum(parent,dev_FieldId_nprereq); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,dev_FieldId_package); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('t','a','r','g','d','e','p'): {
                    value_SetEnum(parent,dev_FieldId_targdep); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_targsrc); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('b','u','i','l','d','d','i','r'): {
                    value_SetEnum(parent,dev_FieldId_builddir); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('f','i','l','e','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_filename); ret = true; break;
                }
                case LE_STR8('o','p','t','_','t','y','p','e'): {
                    value_SetEnum(parent,dev_FieldId_opt_type); ret = true; break;
                }
                case LE_STR8('t','o','o','l','_','o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_tool_opt); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','m','p','l','e','t','e'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dev_FieldId_completed); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','f','u','n'): {
                    if (memcmp(rhs.elems+8,"c",1)==0) { value_SetEnum(parent,dev_FieldId_nlongfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','l','i','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_nlongline); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','s','c','m','d','d','e'): {
                    if (memcmp(rhs.elems+8,"p",1)==0) { value_SetEnum(parent,dev_FieldId_syscmddep); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('t','a','r','g','s','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,dev_FieldId_targsyslib); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('f','a','i','l','_','p','r','e'): {
                    if (memcmp(rhs.elems+8,"req",3)==0) { value_SetEnum(parent,dev_FieldId_fail_prereq); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','f'): {
                    if (memcmp(rhs.elems+8,"unc",3)==0) { value_SetEnum(parent,dev_FieldId_longestfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dev_FieldId_longestline); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('n','m','y','s','t','e','r','y'): {
                    if (memcmp(rhs.elems+8,"func",4)==0) { value_SetEnum(parent,dev_FieldId_nmysteryfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','r','c','_'): {
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,dev_FieldId_targsrc_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::value_SetStrptr(dev::FieldId& parent, algo::strptr rhs, dev_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dev.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::value_ReadStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dev.FieldId..ReadStrptrMaybe
// Read fields of dev::FieldId from an ascii string.
// The format of the string is the format of the dev::FieldId's only field
bool dev::FieldId_ReadStrptrMaybe(dev::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && dev::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dev.FieldId..Print
// print string representation of dev::FieldId to string LHS, no header -- cprint:dev.FieldId.String
void dev::FieldId_Print(dev::FieldId & row, algo::cstring &str) {
    dev::value_Print(row, str);
}

// --- dev.Gitfile.ext.Get
algo::Smallstr50 dev::ext_Get(dev::Gitfile& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gitfile, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile.ext.Get2
algo::Smallstr50 dev::Gitfile_ext_Get(strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile..ReadFieldMaybe
bool dev::Gitfile_ReadFieldMaybe(dev::Gitfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitfile..ReadStrptrMaybe
// Read fields of dev::Gitfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitfile_ReadStrptrMaybe(dev::Gitfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitfile") || algo::StripTypeTag(in_str, "dev.Gitfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitfile..Print
// print string representation of dev::Gitfile to string LHS, no header -- cprint:dev.Gitfile.String
void dev::Gitfile_Print(dev::Gitfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);
}

// --- dev.Gitinfo..ReadFieldMaybe
bool dev::Gitinfo_ReadFieldMaybe(dev::Gitinfo &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitinfo: retval = algo::Smallstr40_ReadStrptrMaybe(parent.gitinfo, strval); break;
        case dev_FieldId_author: retval = algo::Smallstr50_ReadStrptrMaybe(parent.author, strval); break;
        case dev_FieldId_cfg: retval = algo::Smallstr40_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_compver: retval = algo::Smallstr20_ReadStrptrMaybe(parent.compver, strval); break;
        case dev_FieldId_package: retval = algo::Smallstr40_ReadStrptrMaybe(parent.package, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitinfo..ReadStrptrMaybe
// Read fields of dev::Gitinfo from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitinfo_ReadStrptrMaybe(dev::Gitinfo &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitinfo") || algo::StripTypeTag(in_str, "dev.Gitinfo");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitinfo_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitinfo..Print
// print string representation of dev::Gitinfo to string LHS, no header -- cprint:dev.Gitinfo.String
void dev::Gitinfo_Print(dev::Gitinfo & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitinfo";

    algo::Smallstr40_Print(row.gitinfo, temp);
    PrintAttrSpaceReset(str,"gitinfo", temp);

    algo::Smallstr50_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr40_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr20_Print(row.compver, temp);
    PrintAttrSpaceReset(str,"compver", temp);

    algo::Smallstr40_Print(row.package, temp);
    PrintAttrSpaceReset(str,"package", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Include.srcfile.Get
algo::Smallstr200 dev::srcfile_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LL"));
    return ret;
}

// --- dev.Include.srcfile.Get2
algo::Smallstr200 dev::Include_srcfile_Get(strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dev.Include.filename.Get
algo::Smallstr200 dev::filename_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LR"));
    return ret;
}

// --- dev.Include.filename.Get2
algo::Smallstr200 dev::Include_filename_Get(strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dev.Include..Concat_srcfile_filename
tempstr dev::Include_Concat_srcfile_filename( const algo::strptr& srcfile ,const algo::strptr& filename ) {
    return tempstr() << srcfile <<':'<< filename ;
}

// --- dev.Include..ReadFieldMaybe
bool dev::Include_ReadFieldMaybe(dev::Include &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_include: retval = algo::Smallstr200_ReadStrptrMaybe(parent.include, strval); break;
        case dev_FieldId_sys: retval = bool_ReadStrptrMaybe(parent.sys, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Include..ReadStrptrMaybe
// Read fields of dev::Include from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Include_ReadStrptrMaybe(dev::Include &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Include");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Include_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Include..Print
// print string representation of dev::Include to string LHS, no header -- cprint:dev.Include.String
void dev::Include_Print(dev::Include & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Include";

    algo::Smallstr200_Print(row.include, temp);
    PrintAttrSpaceReset(str,"include", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Linelim..ReadFieldMaybe
bool dev::Linelim_ReadFieldMaybe(dev::Linelim &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_nlongline: retval = u32_ReadStrptrMaybe(parent.nlongline, strval); break;
        case dev_FieldId_longestline: retval = u32_ReadStrptrMaybe(parent.longestline, strval); break;
        case dev_FieldId_nbadws: retval = u32_ReadStrptrMaybe(parent.nbadws, strval); break;
        case dev_FieldId_maxws: retval = u32_ReadStrptrMaybe(parent.maxws, strval); break;
        case dev_FieldId_nlongfunc: retval = u32_ReadStrptrMaybe(parent.nlongfunc, strval); break;
        case dev_FieldId_longestfunc: retval = u32_ReadStrptrMaybe(parent.longestfunc, strval); break;
        case dev_FieldId_nmysteryfunc: retval = u32_ReadStrptrMaybe(parent.nmysteryfunc, strval); break;
        case dev_FieldId_badness: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badness, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Linelim..ReadStrptrMaybe
// Read fields of dev::Linelim from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Linelim_ReadStrptrMaybe(dev::Linelim &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.linelim") || algo::StripTypeTag(in_str, "dev.Linelim");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Linelim_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Linelim..Print
// print string representation of dev::Linelim to string LHS, no header -- cprint:dev.Linelim.String
void dev::Linelim_Print(dev::Linelim & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.linelim";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    u32_Print(row.nlongline, temp);
    PrintAttrSpaceReset(str,"nlongline", temp);

    u32_Print(row.longestline, temp);
    PrintAttrSpaceReset(str,"longestline", temp);

    u32_Print(row.nbadws, temp);
    PrintAttrSpaceReset(str,"nbadws", temp);

    u32_Print(row.maxws, temp);
    PrintAttrSpaceReset(str,"maxws", temp);

    u32_Print(row.nlongfunc, temp);
    PrintAttrSpaceReset(str,"nlongfunc", temp);

    u32_Print(row.longestfunc, temp);
    PrintAttrSpaceReset(str,"longestfunc", temp);

    u32_Print(row.nmysteryfunc, temp);
    PrintAttrSpaceReset(str,"nmysteryfunc", temp);

    algo::Smallstr50_Print(row.badness, temp);
    PrintAttrSpaceReset(str,"badness", temp);
}

// --- dev.OptType..ReadFieldMaybe
bool dev::OptType_ReadFieldMaybe(dev::OptType &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_opt_type: retval = algo::Smallstr50_ReadStrptrMaybe(parent.opt_type, strval); break;
        case dev_FieldId_sep: retval = algo::RspaceStr4_ReadStrptrMaybe(parent.sep, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.OptType..ReadStrptrMaybe
// Read fields of dev::OptType from an ascii string.
// The format of the string is an ssim Tuple
bool dev::OptType_ReadStrptrMaybe(dev::OptType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.opt_type") || algo::StripTypeTag(in_str, "dev.OptType");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptType_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.OptType..Print
// print string representation of dev::OptType to string LHS, no header -- cprint:dev.OptType.String
void dev::OptType_Print(dev::OptType & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.opt_type";

    algo::Smallstr50_Print(row.opt_type, temp);
    PrintAttrSpaceReset(str,"opt_type", temp);

    algo::RspaceStr4_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Readme..ReadFieldMaybe
bool dev::Readme_ReadFieldMaybe(dev::Readme &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Readme..ReadStrptrMaybe
// Read fields of dev::Readme from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Readme_ReadStrptrMaybe(dev::Readme &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.readme") || algo::StripTypeTag(in_str, "dev.Readme");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Readme_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Readme..Print
// print string representation of dev::Readme to string LHS, no header -- cprint:dev.Readme.String
void dev::Readme_Print(dev::Readme & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.readme";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Scriptfile..ReadFieldMaybe
bool dev::Scriptfile_ReadFieldMaybe(dev::Scriptfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_args: retval = algo::Smallstr100_ReadStrptrMaybe(parent.args, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Scriptfile..ReadStrptrMaybe
// Read fields of dev::Scriptfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Scriptfile_ReadStrptrMaybe(dev::Scriptfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.scriptfile") || algo::StripTypeTag(in_str, "dev.Scriptfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Scriptfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Scriptfile..Print
// print string representation of dev::Scriptfile to string LHS, no header -- cprint:dev.Scriptfile.String
void dev::Scriptfile_Print(dev::Scriptfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.scriptfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Smallstr100_Print(row.args, temp);
    PrintAttrSpaceReset(str,"args", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Srcfile.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Srcfile& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.srcfile, ".RR"));
    return ret;
}

// --- dev.Srcfile.ext.Get2
algo::Smallstr10 dev::Srcfile_ext_Get(strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Srcfile..ReadFieldMaybe
bool dev::Srcfile_ReadFieldMaybe(dev::Srcfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_srcfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.srcfile, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Srcfile..ReadStrptrMaybe
// Read fields of dev::Srcfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Srcfile_ReadStrptrMaybe(dev::Srcfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.srcfile") || algo::StripTypeTag(in_str, "dev.Srcfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Srcfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Srcfile..Print
// print string representation of dev::Srcfile to string LHS, no header -- cprint:dev.Srcfile.String
void dev::Srcfile_Print(dev::Srcfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.srcfile";

    algo::Smallstr200_Print(row.srcfile, temp);
    PrintAttrSpaceReset(str,"srcfile", temp);
}

// --- dev.Syscmd..ReadFieldMaybe
bool dev::Syscmd_ReadFieldMaybe(dev::Syscmd &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syscmd: retval = i64_ReadStrptrMaybe(parent.syscmd, strval); break;
        case dev_FieldId_command: retval = algo::cstring_ReadStrptrMaybe(parent.command, strval); break;
        case dev_FieldId_pid: retval = i32_ReadStrptrMaybe(parent.pid, strval); break;
        case dev_FieldId_status: retval = i32_ReadStrptrMaybe(parent.status, strval); break;
        case dev_FieldId_nprereq: retval = i32_ReadStrptrMaybe(parent.nprereq, strval); break;
        case dev_FieldId_fail_prereq: retval = bool_ReadStrptrMaybe(parent.fail_prereq, strval); break;
        case dev_FieldId_completed: retval = bool_ReadStrptrMaybe(parent.completed, strval); break;
        case dev_FieldId_maxtime: retval = i32_ReadStrptrMaybe(parent.maxtime, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmd..ReadStrptrMaybe
// Read fields of dev::Syscmd from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmd_ReadStrptrMaybe(dev::Syscmd &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmd");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmd_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmd..Print
// print string representation of dev::Syscmd to string LHS, no header -- cprint:dev.Syscmd.String
void dev::Syscmd_Print(dev::Syscmd & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmd";

    i64_Print(row.syscmd, temp);
    PrintAttrSpaceReset(str,"syscmd", temp);

    algo::cstring_Print(row.command, temp);
    PrintAttrSpaceReset(str,"command", temp);

    i32_Print(row.pid, temp);
    PrintAttrSpaceReset(str,"pid", temp);

    i32_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    i32_Print(row.nprereq, temp);
    PrintAttrSpaceReset(str,"nprereq", temp);

    bool_Print(row.fail_prereq, temp);
    PrintAttrSpaceReset(str,"fail_prereq", temp);

    bool_Print(row.completed, temp);
    PrintAttrSpaceReset(str,"completed", temp);

    i32_Print(row.maxtime, temp);
    PrintAttrSpaceReset(str,"maxtime", temp);
}

// --- dev.Syscmddep..ReadFieldMaybe
bool dev::Syscmddep_ReadFieldMaybe(dev::Syscmddep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_child: retval = i64_ReadStrptrMaybe(parent.child, strval); break;
        case dev_FieldId_parent: retval = i64_ReadStrptrMaybe(parent.parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmddep..ReadStrptrMaybe
// Read fields of dev::Syscmddep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmddep_ReadStrptrMaybe(dev::Syscmddep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmddep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmddep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmddep..Print
// print string representation of dev::Syscmddep to string LHS, no header -- cprint:dev.Syscmddep.String
void dev::Syscmddep_Print(dev::Syscmddep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmddep";

    i64_Print(row.child, temp);
    PrintAttrSpaceReset(str,"child", temp);

    i64_Print(row.parent, temp);
    PrintAttrSpaceReset(str,"parent", temp);
}

// --- dev.Syslib..ReadFieldMaybe
bool dev::Syslib_ReadFieldMaybe(dev::Syslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.syslib, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syslib..ReadStrptrMaybe
// Read fields of dev::Syslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syslib_ReadStrptrMaybe(dev::Syslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syslib") || algo::StripTypeTag(in_str, "dev.Syslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syslib..Print
// print string representation of dev::Syslib to string LHS, no header -- cprint:dev.Syslib.String
void dev::Syslib_Print(dev::Syslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.syslib";

    algo::Smallstr50_Print(row.syslib, temp);
    PrintAttrSpaceReset(str,"syslib", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targdep.target.Get
algo::Smallstr16 dev::target_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RL"));
    return ret;
}

// --- dev.Targdep.target.Get2
algo::Smallstr16 dev::Targdep_target_Get(strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targdep.parent.Get
algo::Smallstr16 dev::parent_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RR"));
    return ret;
}

// --- dev.Targdep.parent.Get2
algo::Smallstr16 dev::Targdep_parent_Get(strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targdep..Concat_target_parent
tempstr dev::Targdep_Concat_target_parent( const algo::strptr& target ,const algo::strptr& parent ) {
    return tempstr() << target <<'.'<< parent ;
}

// --- dev.Targdep..ReadFieldMaybe
bool dev::Targdep_ReadFieldMaybe(dev::Targdep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targdep: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targdep, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targdep..ReadStrptrMaybe
// Read fields of dev::Targdep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targdep_ReadStrptrMaybe(dev::Targdep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targdep") || algo::StripTypeTag(in_str, "dev.Targdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targdep..Print
// print string representation of dev::Targdep to string LHS, no header -- cprint:dev.Targdep.String
void dev::Targdep_Print(dev::Targdep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targdep";

    algo::Smallstr50_Print(row.targdep, temp);
    PrintAttrSpaceReset(str,"targdep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Target..ReadFieldMaybe
bool dev::Target_ReadFieldMaybe(dev::Target &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Target..ReadStrptrMaybe
// Read fields of dev::Target from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Target_ReadStrptrMaybe(dev::Target &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.target") || algo::StripTypeTag(in_str, "dev.Target");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Target_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Target..Print
// print string representation of dev::Target to string LHS, no header -- cprint:dev.Target.String
void dev::Target_Print(dev::Target & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.target";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);
}

// --- dev.Targinstall..ReadFieldMaybe
bool dev::Targinstall_ReadFieldMaybe(dev::Targinstall &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targinstall..ReadStrptrMaybe
// Read fields of dev::Targinstall from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targinstall_ReadStrptrMaybe(dev::Targinstall &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targinstall") || algo::StripTypeTag(in_str, "dev.Targinstall");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targinstall_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targinstall..Print
// print string representation of dev::Targinstall to string LHS, no header -- cprint:dev.Targinstall.String
void dev::Targinstall_Print(dev::Targinstall & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targinstall";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targsrc.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsrc& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsrc, "/LL"));
    return ret;
}

// --- dev.Targsrc.target.Get2
algo::Smallstr16 dev::Targsrc_target_Get(strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Targsrc.src.Get
algo::Smallstr200 dev::src_Get(dev::Targsrc& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.targsrc, "/LR"));
    return ret;
}

// --- dev.Targsrc.src.Get2
algo::Smallstr200 dev::Targsrc_src_Get(strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dev.Targsrc.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Targsrc& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.targsrc, ".RR"));
    return ret;
}

// --- dev.Targsrc.ext.Get2
algo::Smallstr10 dev::Targsrc_ext_Get(strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsrc..Concat_target_src
tempstr dev::Targsrc_Concat_target_src( const algo::strptr& target ,const algo::strptr& src ) {
    return tempstr() << target <<'/'<< src ;
}

// --- dev.Targsrc..ReadFieldMaybe
bool dev::Targsrc_ReadFieldMaybe(dev::Targsrc &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsrc: retval = algo::Smallstr100_ReadStrptrMaybe(parent.targsrc, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsrc..ReadStrptrMaybe
// Read fields of dev::Targsrc from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsrc_ReadStrptrMaybe(dev::Targsrc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsrc") || algo::StripTypeTag(in_str, "dev.Targsrc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsrc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsrc..Print
// print string representation of dev::Targsrc to string LHS, no header -- cprint:dev.Targsrc.String
void dev::Targsrc_Print(dev::Targsrc & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsrc";

    algo::Smallstr100_Print(row.targsrc, temp);
    PrintAttrSpaceReset(str,"targsrc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targsyslib.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsyslib& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsyslib, ".RL"));
    return ret;
}

// --- dev.Targsyslib.target.Get2
algo::Smallstr16 dev::Targsyslib_target_Get(strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get
algo::Smallstr50 dev::syslib_Get(dev::Targsyslib& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsyslib, ".RR"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get2
algo::Smallstr50 dev::Targsyslib_syslib_Get(strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsyslib..Concat_target_syslib
tempstr dev::Targsyslib_Concat_target_syslib( const algo::strptr& target ,const algo::strptr& syslib ) {
    return tempstr() << target <<'.'<< syslib ;
}

// --- dev.Targsyslib..ReadFieldMaybe
bool dev::Targsyslib_ReadFieldMaybe(dev::Targsyslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsyslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsyslib, strval); break;
        case dev_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsyslib..ReadStrptrMaybe
// Read fields of dev::Targsyslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsyslib_ReadStrptrMaybe(dev::Targsyslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsyslib") || algo::StripTypeTag(in_str, "dev.Targsyslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsyslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsyslib..Print
// print string representation of dev::Targsyslib to string LHS, no header -- cprint:dev.Targsyslib.String
void dev::Targsyslib_Print(dev::Targsyslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsyslib";

    algo::Smallstr50_Print(row.targsyslib, temp);
    PrintAttrSpaceReset(str,"targsyslib", temp);

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.ToolOpt..ReadFieldMaybe
bool dev::ToolOpt_ReadFieldMaybe(dev::ToolOpt &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_tool_opt: retval = algo::RspaceStr10_ReadStrptrMaybe(parent.tool_opt, strval); break;
        case dev_FieldId_opt_type: retval = algo::Smallstr50_ReadStrptrMaybe(parent.opt_type, strval); break;
        case dev_FieldId_opt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.opt, strval); break;
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case dev_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case dev_FieldId_compiler: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval); break;
        case dev_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_arch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.ToolOpt..ReadStrptrMaybe
// Read fields of dev::ToolOpt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::ToolOpt_ReadStrptrMaybe(dev::ToolOpt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tool_opt") || algo::StripTypeTag(in_str, "dev.ToolOpt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ToolOpt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.ToolOpt..Print
// print string representation of dev::ToolOpt to string LHS, no header -- cprint:dev.ToolOpt.String
void dev::ToolOpt_Print(dev::ToolOpt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.tool_opt";

    algo::RspaceStr10_Print(row.tool_opt, temp);
    PrintAttrSpaceReset(str,"tool_opt", temp);

    algo::Smallstr50_Print(row.opt_type, temp);
    PrintAttrSpaceReset(str,"opt_type", temp);

    algo::Smallstr100_Print(row.opt, temp);
    PrintAttrSpaceReset(str,"opt", temp);

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Smallstr50_Print(row.compiler, temp);
    PrintAttrSpaceReset(str,"compiler", temp);

    algo::Smallstr50_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr50_Print(row.arch, temp);
    PrintAttrSpaceReset(str,"arch", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Uname..ReadFieldMaybe
bool dev::Uname_ReadFieldMaybe(dev::Uname &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Uname..ReadStrptrMaybe
// Read fields of dev::Uname from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Uname_ReadStrptrMaybe(dev::Uname &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.uname") || algo::StripTypeTag(in_str, "dev.Uname");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Uname_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Uname..Print
// print string representation of dev::Uname to string LHS, no header -- cprint:dev.Uname.String
void dev::Uname_Print(dev::Uname & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.uname";

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev...SizeCheck
inline static void dev::SizeCheck() {
}
