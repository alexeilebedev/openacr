//
// cpp/gen/acr_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/acr_gen.h"
#include "include/gen/acr_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/amcdb_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
acr::FDb        acr::_db;         // dependency found via dev.targdep

namespace acr {
const char *acr_help =
"acr: Algo Cross-Reference - ssimfile database & update tool\n"
"Usage: acr [[-query:]<string>] [options]\n"
"    OPTION      TYPE    DFLT    COMMENT\n"
"    [query]     string  \"\"      Regx to match record\n"
"    -where...   string          Additional key:value pairs to match\n"
"    -select             Y       Select records matching query (default)\n"
"    -del                        Delete found item\n"
"    -insert                     Read stdin and insert tuples\n"
"    -replace                    Read stdin and replace tuples\n"
"    -update                     Read stdin and update attributes of existing tuples\n"
"    -merge                      Combination of -update and -insert\n"
"    -unused                     Only select records which are not referenced.\n"
"    -trunc                      (with insert or rename): truncate table on first write\n"
"    -check                      Run cross-reference check on selection\n"
"    -maxshow    int     100     Limit number of errors per table\n"
"    -write                      Write data back to disk.\n"
"    -rename     string  \"\"      Change value of found item\n"
"    -nup        int     0       Number of levels to go up\n"
"    -ndown      int     0       Number of levels to go down\n"
"    -xref                       Short for -nup 100 -ndown 100\n"
"    -fldfunc                    Evaluate fldfunc when printing tuple\n"
"    -maxgroup   int     25      Max. items per group\n"
"    -pretty             Y       Align output in blocks\n"
"    -tree                       Print as tree\n"
"    -loose                      Allow printing a record before its references (used with -e)\n"
"    -my                         Invoke acr_my -e (using acr_my directly is faster)\n"
"    -schema     string  \"data\"  Directory for initializing acr meta-data\n"
"    -e                          Open selection in editor, write back when done.\n"
"    -t                          Short for -tree -xref -loose\n"
"    -rowid                      Print/respect acr.rowid attribute\n"
"    -in         string  \"data\"  Input directory or filename, - for stdin\n"
"    -cmt                        Print comments for all columns referenced in output\n"
"    -report             Y       Show final report\n"
"    -print              Y       Print selected records\n"
"    -cmd        string  \"\"      Print script with command execution for each selected row\n"
"    -field...   string          Fields to select\n"
"    -regxof     string  \"\"      Single field: output regx of matching field values\n"
"    -meta                       Select meta-data for selected records\n"
"    -verbose    int             Verbosity level (0..255); alias -v; cumulative\n"
"    -debug      int             Debug level (0..255); alias -d; cumulative\n"
"    -help                       Print help an exit; alias -h\n"
"    -version                    Print version and exit\n"
"    -signature                  Show signatures and exit; alias -sig\n"
;


} // namespace acr
acr::_db_bh_pline_curs::~_db_bh_pline_curs() {
    algo_lib::malloc_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

acr::_db_bh_ctype_topo_curs::~_db_bh_ctype_topo_curs() {
    algo_lib::malloc_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

namespace acr { // gen:ns_print_proto
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    static bool          anonfld_InputMaybe(dmmeta::Anonfld &elem) __attribute__((nothrow));
    static bool          cdflt_InputMaybe(dmmeta::Cdflt &elem) __attribute__((nothrow));
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_pline_Downheap(acr::FPline& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_pline_Upheap(acr::FPline& row, int idx) __attribute__((nothrow));
    static bool          bh_pline_ElemLt(acr::FPline &a, acr::FPline &b) __attribute__((nothrow));
    static void          _db_bh_pline_curs_Add(_db_bh_pline_curs &curs, acr::FPline& row);
    static bool          substr_InputMaybe(dmmeta::Substr &elem) __attribute__((nothrow));
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    static bool          ssimsort_InputMaybe(dmmeta::Ssimsort &elem) __attribute__((nothrow));
    static bool          smallstr_InputMaybe(dmmeta::Smallstr &elem) __attribute__((nothrow));
    static bool          funique_InputMaybe(dmmeta::Funique &elem) __attribute__((nothrow));
    static bool          bltin_InputMaybe(amcdb::Bltin &elem) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_ctype_topo_Downheap(acr::FCtype& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_ctype_topo_Upheap(acr::FCtype& row, int idx) __attribute__((nothrow));
    static bool          bh_ctype_topo_ElemLt(acr::FCtype &a, acr::FCtype &b) __attribute__((nothrow));
    static void          _db_bh_ctype_topo_curs_Add(_db_bh_ctype_topo_curs &curs, acr::FCtype& row);
    static bool          cppfunc_InputMaybe(dmmeta::Cppfunc &elem) __attribute__((nothrow));
    static bool          ssimreq_InputMaybe(dmmeta::Ssimreq &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Swap values elem_a and elem_b
    static void          c_cmtrec_Swap(acr::FRec* &elem_a, acr::FRec* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_cmtrec_Rotleft(acr::FRec* &elem_a, acr::FRec* &elem_b, acr::FRec* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_cmtrec_Lt(acr::FRec &elem_a, acr::FRec &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_cmtrec_IntInsertionSort(acr::FRec* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_cmtrec_IntHeapSort(acr::FRec* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_cmtrec_IntQuickSort(acr::FRec* *elems, int n, int depth) __attribute__((nothrow));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- acr.AttrRegx.name.Print
// Print back to string
void acr::name_Print(acr::AttrRegx& where, algo::cstring &out) {
    Regx_Print(where.name, out);
}

// --- acr.AttrRegx.value.Print
// Print back to string
void acr::value_Print(acr::AttrRegx& where, algo::cstring &out) {
    Regx_Print(where.value, out);
}

// --- acr.AttrRegx..Print
// print string representation of acr::AttrRegx to string LHS, no header -- cprint:acr.AttrRegx.String
void acr::AttrRegx_Print(acr::AttrRegx & row, algo::cstring &str) {
    acr::name_Print(row, str);
    str << ':';
    acr::value_Print(row, str);
}

// --- acr.CtypeTopoKey..Print
// print string representation of acr::CtypeTopoKey to string LHS, no header -- cprint:acr.CtypeTopoKey.String
void acr::CtypeTopoKey_Print(acr::CtypeTopoKey & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.CtypeTopoKey";

    i32_Print(row.alldep, temp);
    PrintAttrSpaceReset(str,"alldep", temp);

    i32_Print(row.rowid, temp);
    PrintAttrSpaceReset(str,"rowid", temp);
}

// --- acr.Err..Print
// print string representation of acr::Err to string LHS, no header -- cprint:acr.Err.String
void acr::Err_Print(acr::Err & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.Err";

    u64_PrintHex(u64((const acr::FCtype*)row.ctype), temp, 8, true);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    algo::cstring_Print(row.text, temp);
    PrintAttrSpaceReset(str,"text", temp);

    u64_PrintHex(u64((const acr::FRec*)row.rec), temp, 8, true);
    PrintAttrSpaceReset(str,"rec", temp);

    u64_PrintHex(u64((const acr::FField*)row.fld), temp, 8, true);
    PrintAttrSpaceReset(str,"fld", temp);
}

// --- acr.FAnonfld.base.CopyOut
// Copy fields out of row
void acr::anonfld_CopyOut(acr::FAnonfld &row, dmmeta::Anonfld &out) {
    out.field = row.field;
    // comment: field stripped (see dmmeta.fbase:acr.FAnonfld.base)
}

// --- acr.FAnonfld.base.CopyIn
// Copy fields in to row
void acr::anonfld_CopyIn(acr::FAnonfld &row, dmmeta::Anonfld &in) {
    row.field = in.field;
    // comment: field stripped (see dmmeta.fbase:acr.FAnonfld.base)
}

// --- acr.FBltin.base.CopyOut
// Copy fields out of row
void acr::bltin_CopyOut(acr::FBltin &row, amcdb::Bltin &out) {
    out.ctype = row.ctype;
    out.likeu64 = row.likeu64;
    out.bigendok = row.bigendok;
    out.issigned = row.issigned;
    // comment: field stripped (see dmmeta.fbase:acr.FBltin.base)
}

// --- acr.FBltin.base.CopyIn
// Copy fields in to row
void acr::bltin_CopyIn(acr::FBltin &row, amcdb::Bltin &in) {
    row.ctype = in.ctype;
    row.likeu64 = in.likeu64;
    row.bigendok = in.bigendok;
    row.issigned = in.issigned;
    // comment: field stripped (see dmmeta.fbase:acr.FBltin.base)
}

// --- acr.FBltin..Uninit
void acr::FBltin_Uninit(acr::FBltin& bltin) {
    acr::FBltin &row = bltin; (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_bltin_Remove(*p_ctype, row);// remove bltin from index c_bltin
    }
}

// --- acr.FCdflt.base.CopyOut
// Copy fields out of row
void acr::cdflt_CopyOut(acr::FCdflt &row, dmmeta::Cdflt &out) {
    out.ctype = row.ctype;
    out.dflt = row.dflt;
    out.cppdflt = row.cppdflt;
    out.ssimdflt = row.ssimdflt;
    out.jsdflt = row.jsdflt;
    // comment: field stripped (see dmmeta.fbase:acr.FCdflt.base)
}

// --- acr.FCdflt.base.CopyIn
// Copy fields in to row
void acr::cdflt_CopyIn(acr::FCdflt &row, dmmeta::Cdflt &in) {
    row.ctype = in.ctype;
    row.dflt = in.dflt;
    row.cppdflt = in.cppdflt;
    row.ssimdflt = in.ssimdflt;
    row.jsdflt = in.jsdflt;
    // comment: field stripped (see dmmeta.fbase:acr.FCdflt.base)
}

// --- acr.FCdflt..Uninit
void acr::FCdflt_Uninit(acr::FCdflt& cdflt) {
    acr::FCdflt &row = cdflt; (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cdflt_Remove(*p_ctype, row);// remove cdflt from index c_cdflt
    }
}

// --- acr.FCheck.c_bad_rec.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_bad_rec_Insert(acr::FCheck& check, acr::FRec& row) {
    // reserve space
    c_bad_rec_Reserve(check, 1);
    u32 n  = check.c_bad_rec_n;
    u32 at = n;
    acr::FRec* *elems = check.c_bad_rec_elems;
    elems[at] = &row;
    check.c_bad_rec_n = n+1;

}

// --- acr.FCheck.c_bad_rec.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_bad_rec_ScanInsertMaybe(acr::FCheck& check, acr::FRec& row) {
    bool retval = true;
    u32 n  = check.c_bad_rec_n;
    for (u32 i = 0; i < n; i++) {
        if (check.c_bad_rec_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_bad_rec_Reserve(check, 1);
        check.c_bad_rec_elems[n] = &row;
        check.c_bad_rec_n = n+1;
    }
    return retval;
}

// --- acr.FCheck.c_bad_rec.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_bad_rec_Remove(acr::FCheck& check, acr::FRec& row) {
    int lim = check.c_bad_rec_n;
    acr::FRec* *elems = check.c_bad_rec_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FRec* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FRec*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            check.c_bad_rec_n = lim - 1;
            break;
        }
    }
}

// --- acr.FCheck.c_bad_rec.Reserve
// Reserve space in index for N more elements;
void acr::c_bad_rec_Reserve(acr::FCheck& check, u32 n) {
    u32 old_max = check.c_bad_rec_max;
    if (UNLIKELY(check.c_bad_rec_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FRec*);
        u32 new_size = new_max * sizeof(acr::FRec*);
        void *new_mem = algo_lib::malloc_ReallocMem(check.c_bad_rec_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FCheck.c_bad_rec");
        }
        check.c_bad_rec_elems = (acr::FRec**)new_mem;
        check.c_bad_rec_max = new_max;
    }
}

// --- acr.FCheck.ary_name.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& acr::ary_name_Alloc(acr::FCheck& check) {
    ary_name_Reserve(check, 1);
    int n  = check.ary_name_n;
    int at = n;
    algo::cstring *elems = check.ary_name_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    check.ary_name_n = n+1;
    return elems[at];
}

// --- acr.FCheck.ary_name.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& acr::ary_name_AllocAt(acr::FCheck& check, int at) {
    ary_name_Reserve(check, 1);
    int n  = check.ary_name_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("acr.bad_alloc_at  field:acr.FCheck.ary_name  comment:'index out of range'");
    }
    algo::cstring *elems = check.ary_name_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    check.ary_name_n = n+1;
    return elems[at];
}

// --- acr.FCheck.ary_name.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> acr::ary_name_AllocN(acr::FCheck& check, int n_elems) {
    ary_name_Reserve(check, n_elems);
    int old_n  = check.ary_name_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = check.ary_name_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    check.ary_name_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- acr.FCheck.ary_name.Remove
// Remove item by index. If index outside of range, do nothing.
void acr::ary_name_Remove(acr::FCheck& check, u32 i) {
    u32 lim = check.ary_name_n;
    algo::cstring *elems = check.ary_name_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        check.ary_name_n = lim - 1;
    }
}

// --- acr.FCheck.ary_name.RemoveAll
void acr::ary_name_RemoveAll(acr::FCheck& check) {
    u32 n = check.ary_name_n;
    while (n > 0) {
        n -= 1;
        check.ary_name_elems[n].~cstring();
        check.ary_name_n = n;
    }
}

// --- acr.FCheck.ary_name.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::ary_name_RemoveLast(acr::FCheck& check) {
    u64 n = check.ary_name_n;
    if (n > 0) {
        n -= 1;
        ary_name_qFind(check, u64(n)).~cstring();
        check.ary_name_n = n;
    }
}

// --- acr.FCheck.ary_name.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void acr::ary_name_AbsReserve(acr::FCheck& check, int n) {
    u32 old_max  = check.ary_name_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(check.ary_name_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.tary_nomem  field:acr.FCheck.ary_name  comment:'out of memory'");
        }
        check.ary_name_elems = (algo::cstring*)new_mem;
        check.ary_name_max = new_max;
    }
}

// --- acr.FCheck.ary_name.Setary
// Copy contents of RHS to PARENT.
void acr::ary_name_Setary(acr::FCheck& check, acr::FCheck &rhs) {
    ary_name_RemoveAll(check);
    int nnew = rhs.ary_name_n;
    ary_name_Reserve(check, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (check.ary_name_elems + i) algo::cstring(ary_name_qFind(rhs, i));
        check.ary_name_n = i + 1;
    }
}

// --- acr.FCheck.ary_name.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> acr::ary_name_AllocNVal(acr::FCheck& check, int n_elems, const algo::cstring& val) {
    ary_name_Reserve(check, n_elems);
    int old_n  = check.ary_name_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = check.ary_name_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    check.ary_name_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- acr.FCheck..Uninit
void acr::FCheck_Uninit(acr::FCheck& check) {
    acr::FCheck &row = check; (void)row;

    // acr.FCheck.ary_name.Uninit (Tary)  //
    // remove all elements from acr.FCheck.ary_name
    ary_name_RemoveAll(check);
    // free memory for Tary acr.FCheck.ary_name
    algo_lib::malloc_FreeMem(check.ary_name_elems, sizeof(algo::cstring)*check.ary_name_max); // (acr.FCheck.ary_name)

    // acr.FCheck.c_bad_rec.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(check.c_bad_rec_elems, sizeof(acr::FRec*)*check.c_bad_rec_max); // (acr.FCheck.c_bad_rec)
}

// --- acr.FCppfunc.base.CopyOut
// Copy fields out of row
void acr::cppfunc_CopyOut(acr::FCppfunc &row, dmmeta::Cppfunc &out) {
    out.field = row.field;
    out.expr = row.expr;
}

// --- acr.FCppfunc.base.CopyIn
// Copy fields in to row
void acr::cppfunc_CopyIn(acr::FCppfunc &row, dmmeta::Cppfunc &in) {
    row.field = in.field;
    row.expr = in.expr;
}

// --- acr.FCtype.base.CopyOut
// Copy fields out of row
void acr::ctype_CopyOut(acr::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- acr.FCtype.base.CopyIn
// Copy fields in to row
void acr::ctype_CopyIn(acr::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- acr.FCtype.ns.Get
algo::Smallstr16 acr::ns_Get(acr::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- acr.FCtype.name.Get
algo::Smallstr50 acr::name_Get(acr::FCtype& ctype) {
    algo::Smallstr50 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- acr.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_field_Insert(acr::FCtype& ctype, acr::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,true)) {
        // reserve space
        c_field_Reserve(ctype, 1);
        u32 n  = ctype.c_field_n;
        u32 at = n;
        acr::FField* *elems = ctype.c_field_elems;
        elems[at] = &row;
        ctype.c_field_n = n+1;

    }
}

// --- acr.FCtype.c_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool acr::c_field_InsertMaybe(acr::FCtype& ctype, acr::FField& row) {
    bool retval = !row.ctype_c_field_in_ary;
    c_field_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- acr.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_field_Remove(acr::FCtype& ctype, acr::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,false)) {
        int lim = ctype.c_field_n;
        acr::FField* *elems = ctype.c_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            acr::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(acr::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- acr.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void acr::c_field_Reserve(acr::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FField*);
        u32 new_size = new_max * sizeof(acr::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FCtype.c_field");
        }
        ctype.c_field_elems = (acr::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- acr.FCtype.zd_trec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_trec_Insert(acr::FCtype& ctype, acr::FRec& row) {
    if (!zd_trec_InLlistQ(row)) {
        acr::FRec* old_tail = ctype.zd_trec_tail;
        row.zd_trec_next = NULL;
        row.zd_trec_prev = old_tail;
        ctype.zd_trec_tail = &row;
        acr::FRec **new_row_a = &old_tail->zd_trec_next;
        acr::FRec **new_row_b = &ctype.zd_trec_head;
        acr::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FCtype.zd_trec.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_trec_Remove(acr::FCtype& ctype, acr::FRec& row) {
    if (zd_trec_InLlistQ(row)) {
        acr::FRec* old_head       = ctype.zd_trec_head;
        (void)old_head; // in case it's not used
        acr::FRec* prev = row.zd_trec_prev;
        acr::FRec* next = row.zd_trec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FRec **new_next_a = &prev->zd_trec_next;
        acr::FRec **new_next_b = &ctype.zd_trec_head;
        acr::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FRec **new_prev_a = &next->zd_trec_prev;
        acr::FRec **new_prev_b = &ctype.zd_trec_tail;
        acr::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_trec_next=(acr::FRec*)-1; // not-in-list
    }
}

// --- acr.FCtype.zd_trec.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_trec_RemoveAll(acr::FCtype& ctype) {
    acr::FRec* row = ctype.zd_trec_head;
    ctype.zd_trec_head = NULL;
    ctype.zd_trec_tail = NULL;
    while (row) {
        acr::FRec* row_next = row->zd_trec_next;
        row->zd_trec_next  = (acr::FRec*)-1;
        row->zd_trec_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FCtype.zd_trec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec* acr::zd_trec_RemoveFirst(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_trec_head;
    if (row) {
        acr::FRec *next = row->zd_trec_next;
        ctype.zd_trec_head = next;
        acr::FRec **new_end_a = &next->zd_trec_prev;
        acr::FRec **new_end_b = &ctype.zd_trec_tail;
        acr::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_trec_next = (acr::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FCtype.ind_rec.Find
// Find row by key. Return NULL if not found.
acr::FRec* acr::ind_rec_Find(acr::FCtype& ctype, const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (ctype.ind_rec_buckets_n - 1);
    acr::FRec* *e = &ctype.ind_rec_buckets_elems[index];
    acr::FRec* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).pkey == key;
        if (done) break;
        e         = &ret->ind_rec_next;
    } while (true);
    return ret;
}

// --- acr.FCtype.ind_rec.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_rec_InsertMaybe(acr::FCtype& ctype, acr::FRec& row) {
    ind_rec_Reserve(ctype, 1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_rec_next == (acr::FRec*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.pkey) & (ctype.ind_rec_buckets_n - 1);
        acr::FRec* *prev = &ctype.ind_rec_buckets_elems[index];
        do {
            acr::FRec* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).pkey == row.pkey) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_rec_next;
        } while (true);
        if (retval) {
            row.ind_rec_next = *prev;
            ctype.ind_rec_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FCtype.ind_rec.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_rec_Remove(acr::FCtype& ctype, acr::FRec& row) {
    if (LIKELY(row.ind_rec_next != (acr::FRec*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.pkey) & (ctype.ind_rec_buckets_n - 1);
        acr::FRec* *prev = &ctype.ind_rec_buckets_elems[index]; // addr of pointer to current element
        while (acr::FRec *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_rec_next; // unlink (singly linked list)
                ctype.ind_rec_n--;
                row.ind_rec_next = (acr::FRec*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_rec_next;
        }
    }
}

// --- acr.FCtype.ind_rec.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_rec_Reserve(acr::FCtype& ctype, int n) {
    u32 old_nbuckets = ctype.ind_rec_buckets_n;
    u32 new_nelems   = ctype.ind_rec_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FRec*);
        u32 new_size = new_nbuckets * sizeof(acr::FRec*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FRec* *new_buckets = (acr::FRec**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FCtype.ind_rec");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < ctype.ind_rec_buckets_n; i++) {
            acr::FRec* elem = ctype.ind_rec_buckets_elems[i];
            while (elem) {
                acr::FRec &row        = *elem;
                acr::FRec* next       = row.ind_rec_next;
                u32 index          = algo::cstring_Hash(0, row.pkey) & (new_nbuckets-1);
                row.ind_rec_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(ctype.ind_rec_buckets_elems, old_size);
        ctype.ind_rec_buckets_elems = new_buckets;
        ctype.ind_rec_buckets_n = new_nbuckets;
    }
}

// --- acr.FCtype.zd_selrec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_selrec_Insert(acr::FCtype& ctype, acr::FRec& row) {
    if (!zd_selrec_InLlistQ(row)) {
        acr::FRec* old_tail = ctype.zd_selrec_tail;
        row.zd_selrec_next = NULL;
        row.zd_selrec_prev = old_tail;
        ctype.zd_selrec_tail = &row;
        acr::FRec **new_row_a = &old_tail->zd_selrec_next;
        acr::FRec **new_row_b = &ctype.zd_selrec_head;
        acr::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FCtype.zd_selrec.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_selrec_Remove(acr::FCtype& ctype, acr::FRec& row) {
    if (zd_selrec_InLlistQ(row)) {
        acr::FRec* old_head       = ctype.zd_selrec_head;
        (void)old_head; // in case it's not used
        acr::FRec* prev = row.zd_selrec_prev;
        acr::FRec* next = row.zd_selrec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FRec **new_next_a = &prev->zd_selrec_next;
        acr::FRec **new_next_b = &ctype.zd_selrec_head;
        acr::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FRec **new_prev_a = &next->zd_selrec_prev;
        acr::FRec **new_prev_b = &ctype.zd_selrec_tail;
        acr::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_selrec_next=(acr::FRec*)-1; // not-in-list
    }
}

// --- acr.FCtype.zd_selrec.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_selrec_RemoveAll(acr::FCtype& ctype) {
    acr::FRec* row = ctype.zd_selrec_head;
    ctype.zd_selrec_head = NULL;
    ctype.zd_selrec_tail = NULL;
    while (row) {
        acr::FRec* row_next = row->zd_selrec_next;
        row->zd_selrec_next  = (acr::FRec*)-1;
        row->zd_selrec_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FCtype.zd_selrec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec* acr::zd_selrec_RemoveFirst(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_selrec_head;
    if (row) {
        acr::FRec *next = row->zd_selrec_next;
        ctype.zd_selrec_head = next;
        acr::FRec **new_end_a = &next->zd_selrec_prev;
        acr::FRec **new_end_b = &ctype.zd_selrec_tail;
        acr::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_selrec_next = (acr::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FCtype.c_child.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_child_Insert(acr::FCtype& ctype, acr::FCtype& row) {
    // reserve space
    c_child_Reserve(ctype, 1);
    u32 n  = ctype.c_child_n;
    u32 at = n;
    acr::FCtype* *elems = ctype.c_child_elems;
    elems[at] = &row;
    ctype.c_child_n = n+1;

}

// --- acr.FCtype.c_child.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_child_ScanInsertMaybe(acr::FCtype& ctype, acr::FCtype& row) {
    bool retval = true;
    u32 n  = ctype.c_child_n;
    for (u32 i = 0; i < n; i++) {
        if (ctype.c_child_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_child_Reserve(ctype, 1);
        ctype.c_child_elems[n] = &row;
        ctype.c_child_n = n+1;
    }
    return retval;
}

// --- acr.FCtype.c_child.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_child_Remove(acr::FCtype& ctype, acr::FCtype& row) {
    int lim = ctype.c_child_n;
    acr::FCtype* *elems = ctype.c_child_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FCtype* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FCtype*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ctype.c_child_n = lim - 1;
            break;
        }
    }
}

// --- acr.FCtype.c_child.Reserve
// Reserve space in index for N more elements;
void acr::c_child_Reserve(acr::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_child_max;
    if (UNLIKELY(ctype.c_child_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FCtype*);
        u32 new_size = new_max * sizeof(acr::FCtype*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_child_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FCtype.c_child");
        }
        ctype.c_child_elems = (acr::FCtype**)new_mem;
        ctype.c_child_max = new_max;
    }
}

// --- acr.FCtype.zd_arg.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_arg_Insert(acr::FCtype& ctype, acr::FField& row) {
    if (!zd_arg_InLlistQ(row)) {
        acr::FField* old_tail = ctype.zd_arg_tail;
        row.zd_arg_next = NULL;
        row.zd_arg_prev = old_tail;
        ctype.zd_arg_tail = &row;
        acr::FField **new_row_a = &old_tail->zd_arg_next;
        acr::FField **new_row_b = &ctype.zd_arg_head;
        acr::FField **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ctype.zd_arg_n++;
    }
}

// --- acr.FCtype.zd_arg.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_arg_Remove(acr::FCtype& ctype, acr::FField& row) {
    if (zd_arg_InLlistQ(row)) {
        acr::FField* old_head       = ctype.zd_arg_head;
        (void)old_head; // in case it's not used
        acr::FField* prev = row.zd_arg_prev;
        acr::FField* next = row.zd_arg_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FField **new_next_a = &prev->zd_arg_next;
        acr::FField **new_next_b = &ctype.zd_arg_head;
        acr::FField **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FField **new_prev_a = &next->zd_arg_prev;
        acr::FField **new_prev_b = &ctype.zd_arg_tail;
        acr::FField **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        ctype.zd_arg_n--;
        row.zd_arg_next=(acr::FField*)-1; // not-in-list
    }
}

// --- acr.FCtype.zd_arg.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_arg_RemoveAll(acr::FCtype& ctype) {
    acr::FField* row = ctype.zd_arg_head;
    ctype.zd_arg_head = NULL;
    ctype.zd_arg_tail = NULL;
    ctype.zd_arg_n = 0;
    while (row) {
        acr::FField* row_next = row->zd_arg_next;
        row->zd_arg_next  = (acr::FField*)-1;
        row->zd_arg_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FCtype.zd_arg.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FField* acr::zd_arg_RemoveFirst(acr::FCtype& ctype) {
    acr::FField *row = NULL;
    row = ctype.zd_arg_head;
    if (row) {
        acr::FField *next = row->zd_arg_next;
        ctype.zd_arg_head = next;
        acr::FField **new_end_a = &next->zd_arg_prev;
        acr::FField **new_end_b = &ctype.zd_arg_tail;
        acr::FField **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        ctype.zd_arg_n--;
        row->zd_arg_next = (acr::FField*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FCtype.ind_rec_curs.Reset
void acr::ctype_ind_rec_curs_Reset(ctype_ind_rec_curs &curs, acr::FCtype &parent) {
    curs.bucket = 0;
    curs.parent = &parent;
    curs.prow = &parent.ind_rec_buckets_elems[0]; // hash never has zero buckets
    while (!*curs.prow) {
        curs.bucket += 1;
        if (curs.bucket == parent.ind_rec_buckets_n) break;
        curs.prow = &parent.ind_rec_buckets_elems[curs.bucket];
    }
}

// --- acr.FCtype..Init
// Set all fields to initial values.
void acr::FCtype_Init(acr::FCtype& ctype) {
    ctype.c_field_elems = NULL; // (acr.FCtype.c_field)
    ctype.c_field_n = 0; // (acr.FCtype.c_field)
    ctype.c_field_max = 0; // (acr.FCtype.c_field)
    ctype.c_cdflt = NULL;
    ctype.c_ssimfile = NULL;
    ctype.zd_trec_head = NULL; // (acr.FCtype.zd_trec)
    ctype.zd_trec_tail = NULL; // (acr.FCtype.zd_trec)
    // initialize hash table for acr::FRec;
    ctype.ind_rec_n             	= 0; // (acr.FCtype.ind_rec)
    ctype.ind_rec_buckets_n     	= 4; // (acr.FCtype.ind_rec)
    ctype.ind_rec_buckets_elems 	= (acr::FRec**)algo_lib::malloc_AllocMem(sizeof(acr::FRec*)*ctype.ind_rec_buckets_n); // initial buckets (acr.FCtype.ind_rec)
    if (!ctype.ind_rec_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FCtype.ind_rec)
    }
    memset(ctype.ind_rec_buckets_elems, 0, sizeof(acr::FRec*)*ctype.ind_rec_buckets_n); // (acr.FCtype.ind_rec)
    ctype.zd_selrec_head = NULL; // (acr.FCtype.zd_selrec)
    ctype.zd_selrec_tail = NULL; // (acr.FCtype.zd_selrec)
    ctype.n_insert = i32(0);
    ctype.rank = i32(false);
    ctype.c_child_elems = NULL; // (acr.FCtype.c_child)
    ctype.c_child_n = 0; // (acr.FCtype.c_child)
    ctype.c_child_max = 0; // (acr.FCtype.c_child)
    ctype.show_rowid = bool(false);
    ctype.next_rowid = u64(0);
    ctype.numeric = bool(false);
    ctype.c_bltin = NULL;
    ctype.zd_arg_head = NULL; // (acr.FCtype.zd_arg)
    ctype.zd_arg_n = 0; // (acr.FCtype.zd_arg)
    ctype.zd_arg_tail = NULL; // (acr.FCtype.zd_arg)
    ctype.rowid = i32(0);
    ctype.visit = bool(false);
    ctype.cmt_printed = bool(false);
    ctype.mark_sel = bool(false);
    ctype.mark_cascupdate = bool(false);
    ctype.run_c_child_in_ary = bool(false);
    ctype.ind_ctype_next = (acr::FCtype*)-1; // (acr.FDb.ind_ctype) not-in-hash
    ctype.zd_sel_ctype_next = (acr::FCtype*)-1; // (acr.FDb.zd_sel_ctype) not-in-list
    ctype.zd_sel_ctype_prev = NULL; // (acr.FDb.zd_sel_ctype)
    ctype.bh_ctype_topo_idx = -1; // (acr.FDb.bh_ctype_topo) not-in-heap
}

// --- acr.FCtype..Uninit
void acr::FCtype_Uninit(acr::FCtype& ctype) {
    acr::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype
    zd_sel_ctype_Remove(row); // remove ctype from index zd_sel_ctype
    bh_ctype_topo_Remove(row); // remove ctype from index bh_ctype_topo

    // acr.FCtype.c_child.Uninit (Ptrary)  //all tables that reference this table
    algo_lib::malloc_FreeMem(ctype.c_child_elems, sizeof(acr::FCtype*)*ctype.c_child_max); // (acr.FCtype.c_child)

    // acr.FCtype.ind_rec.Uninit (Thash)  //Index of records by primary key
    algo_lib::malloc_FreeMem(ctype.ind_rec_buckets_elems, sizeof(acr::FRec*)*ctype.ind_rec_buckets_n); // (acr.FCtype.ind_rec)

    // acr.FCtype.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_field_elems, sizeof(acr::FField*)*ctype.c_field_max); // (acr.FCtype.c_field)
}

// --- acr.trace..Print
// print string representation of acr::trace to string LHS, no header -- cprint:acr.trace.String
void acr::trace_Print(acr::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- acr.FDb.pline.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPline& acr::pline_Alloc() {
    acr::FPline* row = pline_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.pline  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.pline.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FPline* acr::pline_AllocMaybe() {
    acr::FPline *row = (acr::FPline*)pline_AllocMem();
    if (row) {
        new (row) acr::FPline; // call constructor
    }
    return row;
}

// --- acr.FDb.pline.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::pline_Delete(acr::FPline &row) {
    row.~FPline();
    pline_FreeMem(row);
}

// --- acr.FDb.pline.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::pline_AllocMem() {
    acr::FPline *row = _db.pline_free;
    if (UNLIKELY(!row)) {
        pline_Reserve(1);
        row = _db.pline_free;
    }
    if (row) {
        _db.pline_free = row->pline_next;
    }
    return row;
}

// --- acr.FDb.pline.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::pline_FreeMem(acr::FPline &row) {
    if (UNLIKELY(row.pline_next != (acr::FPline*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.pline  comment:'double deletion caught'");
    }
    row.pline_next = _db.pline_free; // insert into free list
    _db.pline_free  = &row;
}

// --- acr.FDb.pline.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::pline_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.pline_blocksize; // underlying allocator is probably Lpool
        u64 reserved = pline_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.pline.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::pline_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FPline)) {
        acr::FPline *mem = (acr::FPline*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FPline) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].pline_next = _db.pline_free;
            _db.pline_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.pline.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::pline_XrefMaybe(acr::FPline &row) {
    bool retval = true;
    (void)row;
    // insert pline into index zd_pline
    if (true) { // user-defined insert condition
        zd_pline_Insert(row);
    }
    acr::FRec* p_p_rec = row.p_rec;
    if (UNLIKELY(!p_p_rec)) {
        algo_lib::ResetErrtext() << "acr.null_ref  xref:acr.FRec.c_pline";
        return false;
    }
    // insert pline into index c_pline
    if (true) { // user-defined insert condition
        bool success = c_pline_InsertMaybe(*p_p_rec, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FRec.c_pline"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.pdep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPdep& acr::pdep_Alloc() {
    acr::FPdep* row = pdep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.pdep  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.pdep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FPdep* acr::pdep_AllocMaybe() {
    acr::FPdep *row = (acr::FPdep*)pdep_AllocMem();
    if (row) {
        new (row) acr::FPdep; // call constructor
    }
    return row;
}

// --- acr.FDb.pdep.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::pdep_Delete(acr::FPdep &row) {
    row.~FPdep();
    pdep_FreeMem(row);
}

// --- acr.FDb.pdep.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::pdep_AllocMem() {
    acr::FPdep *row = _db.pdep_free;
    if (UNLIKELY(!row)) {
        pdep_Reserve(1);
        row = _db.pdep_free;
    }
    if (row) {
        _db.pdep_free = row->pdep_next;
    }
    return row;
}

// --- acr.FDb.pdep.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::pdep_FreeMem(acr::FPdep &row) {
    if (UNLIKELY(row.pdep_next != (acr::FPdep*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.pdep  comment:'double deletion caught'");
    }
    row.pdep_next = _db.pdep_free; // insert into free list
    _db.pdep_free  = &row;
}

// --- acr.FDb.pdep.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::pdep_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.pdep_blocksize; // underlying allocator is probably Lpool
        u64 reserved = pdep_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.pdep.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::pdep_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FPdep)) {
        acr::FPdep *mem = (acr::FPdep*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FPdep) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].pdep_next = _db.pdep_free;
            _db.pdep_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.pdep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::pdep_XrefMaybe(acr::FPdep &row) {
    bool retval = true;
    (void)row;
    // insert pdep into index zd_pdep
    if (true) { // user-defined insert condition
        zd_pdep_Insert(row);
    }
    acr::FPline* p_p_parent = row.p_parent;
    if (UNLIKELY(!p_p_parent)) {
        algo_lib::ResetErrtext() << "acr.null_ref  xref:acr.FPline.zd_child";
        return false;
    }
    // insert pdep into index zd_child
    if (true) { // user-defined insert condition
        zd_child_Insert(*p_p_parent, row);
    }
    return retval;
}

// --- acr.FDb.zd_pline.Cascdel
// Delete all elements in the linked list.
void acr::zd_pline_Cascdel() {
    while (acr::FPline *zd_pline_first = zd_pline_First()) {
        pline_Delete(*zd_pline_first);
    }
}

// --- acr.FDb.zd_pline.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_pline_Insert(acr::FPline& row) {
    if (!zd_pline_InLlistQ(row)) {
        acr::FPline* old_tail = _db.zd_pline_tail;
        row.zd_pline_next = NULL;
        row.zd_pline_prev = old_tail;
        _db.zd_pline_tail = &row;
        acr::FPline **new_row_a = &old_tail->zd_pline_next;
        acr::FPline **new_row_b = &_db.zd_pline_head;
        acr::FPline **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FDb.zd_pline.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_pline_Remove(acr::FPline& row) {
    if (zd_pline_InLlistQ(row)) {
        acr::FPline* old_head       = _db.zd_pline_head;
        (void)old_head; // in case it's not used
        acr::FPline* prev = row.zd_pline_prev;
        acr::FPline* next = row.zd_pline_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FPline **new_next_a = &prev->zd_pline_next;
        acr::FPline **new_next_b = &_db.zd_pline_head;
        acr::FPline **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FPline **new_prev_a = &next->zd_pline_prev;
        acr::FPline **new_prev_b = &_db.zd_pline_tail;
        acr::FPline **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_pline_next=(acr::FPline*)-1; // not-in-list
    }
}

// --- acr.FDb.zd_pline.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_pline_RemoveAll() {
    acr::FPline* row = _db.zd_pline_head;
    _db.zd_pline_head = NULL;
    _db.zd_pline_tail = NULL;
    while (row) {
        acr::FPline* row_next = row->zd_pline_next;
        row->zd_pline_next  = (acr::FPline*)-1;
        row->zd_pline_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FDb.zd_pline.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPline* acr::zd_pline_RemoveFirst() {
    acr::FPline *row = NULL;
    row = _db.zd_pline_head;
    if (row) {
        acr::FPline *next = row->zd_pline_next;
        _db.zd_pline_head = next;
        acr::FPline **new_end_a = &next->zd_pline_prev;
        acr::FPline **new_end_b = &_db.zd_pline_tail;
        acr::FPline **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_pline_next = (acr::FPline*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.zd_pdep.Cascdel
// Delete all elements in the linked list.
void acr::zd_pdep_Cascdel() {
    while (acr::FPdep *zd_pdep_first = zd_pdep_First()) {
        pdep_Delete(*zd_pdep_first);
    }
}

// --- acr.FDb.zd_pdep.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_pdep_Insert(acr::FPdep& row) {
    if (!zd_pdep_InLlistQ(row)) {
        acr::FPdep* old_tail = _db.zd_pdep_tail;
        row.zd_pdep_next = NULL;
        row.zd_pdep_prev = old_tail;
        _db.zd_pdep_tail = &row;
        acr::FPdep **new_row_a = &old_tail->zd_pdep_next;
        acr::FPdep **new_row_b = &_db.zd_pdep_head;
        acr::FPdep **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FDb.zd_pdep.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_pdep_Remove(acr::FPdep& row) {
    if (zd_pdep_InLlistQ(row)) {
        acr::FPdep* old_head       = _db.zd_pdep_head;
        (void)old_head; // in case it's not used
        acr::FPdep* prev = row.zd_pdep_prev;
        acr::FPdep* next = row.zd_pdep_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FPdep **new_next_a = &prev->zd_pdep_next;
        acr::FPdep **new_next_b = &_db.zd_pdep_head;
        acr::FPdep **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FPdep **new_prev_a = &next->zd_pdep_prev;
        acr::FPdep **new_prev_b = &_db.zd_pdep_tail;
        acr::FPdep **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_pdep_next=(acr::FPdep*)-1; // not-in-list
    }
}

// --- acr.FDb.zd_pdep.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_pdep_RemoveAll() {
    acr::FPdep* row = _db.zd_pdep_head;
    _db.zd_pdep_head = NULL;
    _db.zd_pdep_tail = NULL;
    while (row) {
        acr::FPdep* row_next = row->zd_pdep_next;
        row->zd_pdep_next  = (acr::FPdep*)-1;
        row->zd_pdep_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FDb.zd_pdep.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPdep* acr::zd_pdep_RemoveFirst() {
    acr::FPdep *row = NULL;
    row = _db.zd_pdep_head;
    if (row) {
        acr::FPdep *next = row->zd_pdep_next;
        _db.zd_pdep_head = next;
        acr::FPdep **new_end_a = &next->zd_pdep_prev;
        acr::FPdep **new_end_b = &_db.zd_pdep_tail;
        acr::FPdep **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_pdep_next = (acr::FPdep*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCtype& acr::ctype_Alloc() {
    acr::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FCtype* acr::ctype_AllocMaybe() {
    acr::FCtype *row = (acr::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) acr::FCtype; // call constructor
        row->rowid = i32(ctype_N() - 1);
    }
    return row;
}

// --- acr.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCtype* acr::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    acr::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(acr::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(i32(n)).~FCtype();
        _db.ctype_n = i32(n);
    }
}

// --- acr.FDb.ctype.InputMaybe
static bool acr::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::ctype_XrefMaybe(acr::FCtype &row) {
    bool retval = true;
    (void)row;
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    // insert ctype into index bh_ctype_topo
    if (true) { // user-defined insert condition
        bh_ctype_topo_Insert(row);
    }
    return retval;
}

// --- acr.FDb.err.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FErr& acr::err_Alloc() {
    acr::FErr* row = err_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.err  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.err.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FErr* acr::err_AllocMaybe() {
    acr::FErr *row = (acr::FErr*)err_AllocMem();
    if (row) {
        new (row) acr::FErr; // call constructor
    }
    return row;
}

// --- acr.FDb.err.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FErr* acr::err_InsertMaybe(const acr::Err &value) {
    acr::FErr *row = &err_Alloc(); // if out of memory, process dies. if input error, return NULL.
    err_CopyIn(*row,const_cast<acr::Err&>(value));
    bool ok = err_XrefMaybe(*row); // this may return false
    if (!ok) {
        err_Delete(*row); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.err.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::err_Delete(acr::FErr &row) {
    row.~FErr();
    err_FreeMem(row);
}

// --- acr.FDb.err.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::err_AllocMem() {
    acr::FErr *row = _db.err_free;
    if (UNLIKELY(!row)) {
        err_Reserve(1);
        row = _db.err_free;
    }
    if (row) {
        _db.err_free = row->err_next;
    }
    return row;
}

// --- acr.FDb.err.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::err_FreeMem(acr::FErr &row) {
    if (UNLIKELY(row.err_next != (acr::FErr*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.err  comment:'double deletion caught'");
    }
    row.err_next = _db.err_free; // insert into free list
    _db.err_free  = &row;
}

// --- acr.FDb.err.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::err_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.err_blocksize; // underlying allocator is probably Lpool
        u64 reserved = err_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.err.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::err_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FErr)) {
        acr::FErr *mem = (acr::FErr*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FErr) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].err_next = _db.err_free;
            _db.err_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.err.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::err_XrefMaybe(acr::FErr &row) {
    bool retval = true;
    (void)row;
    // insert err into index zd_all_err
    if (true) { // user-defined insert condition
        zd_all_err_Insert(row);
    }
    return retval;
}

// --- acr.FDb.anonfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FAnonfld& acr::anonfld_Alloc() {
    acr::FAnonfld* row = anonfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.anonfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.anonfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FAnonfld* acr::anonfld_AllocMaybe() {
    acr::FAnonfld *row = (acr::FAnonfld*)anonfld_AllocMem();
    if (row) {
        new (row) acr::FAnonfld; // call constructor
    }
    return row;
}

// --- acr.FDb.anonfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FAnonfld* acr::anonfld_InsertMaybe(const dmmeta::Anonfld &value) {
    acr::FAnonfld *row = &anonfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    anonfld_CopyIn(*row,const_cast<dmmeta::Anonfld&>(value));
    bool ok = anonfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        anonfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.anonfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::anonfld_AllocMem() {
    u64 new_nelems     = _db.anonfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FAnonfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.anonfld_lary[bsr];
        if (!lev) {
            lev=(acr::FAnonfld*)algo_lib::malloc_AllocMem(sizeof(acr::FAnonfld) * (u64(1)<<bsr));
            _db.anonfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.anonfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.anonfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::anonfld_RemoveLast() {
    u64 n = _db.anonfld_n;
    if (n > 0) {
        n -= 1;
        anonfld_qFind(u64(n)).~FAnonfld();
        _db.anonfld_n = i32(n);
    }
}

// --- acr.FDb.anonfld.InputMaybe
static bool acr::anonfld_InputMaybe(dmmeta::Anonfld &elem) {
    bool retval = true;
    retval = anonfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.anonfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::anonfld_XrefMaybe(acr::FAnonfld &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.cdflt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCdflt& acr::cdflt_Alloc() {
    acr::FCdflt* row = cdflt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.cdflt  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.cdflt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FCdflt* acr::cdflt_AllocMaybe() {
    acr::FCdflt *row = (acr::FCdflt*)cdflt_AllocMem();
    if (row) {
        new (row) acr::FCdflt; // call constructor
    }
    return row;
}

// --- acr.FDb.cdflt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCdflt* acr::cdflt_InsertMaybe(const dmmeta::Cdflt &value) {
    acr::FCdflt *row = &cdflt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cdflt_CopyIn(*row,const_cast<dmmeta::Cdflt&>(value));
    bool ok = cdflt_XrefMaybe(*row); // this may return false
    if (!ok) {
        cdflt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.cdflt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::cdflt_AllocMem() {
    u64 new_nelems     = _db.cdflt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FCdflt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cdflt_lary[bsr];
        if (!lev) {
            lev=(acr::FCdflt*)algo_lib::malloc_AllocMem(sizeof(acr::FCdflt) * (u64(1)<<bsr));
            _db.cdflt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cdflt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.cdflt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::cdflt_RemoveLast() {
    u64 n = _db.cdflt_n;
    if (n > 0) {
        n -= 1;
        cdflt_qFind(u64(n)).~FCdflt();
        _db.cdflt_n = i32(n);
    }
}

// --- acr.FDb.cdflt.InputMaybe
static bool acr::cdflt_InputMaybe(dmmeta::Cdflt &elem) {
    bool retval = true;
    retval = cdflt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.cdflt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::cdflt_XrefMaybe(acr::FCdflt &row) {
    bool retval = true;
    (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cdflt into index c_cdflt
    if (true) { // user-defined insert condition
        bool success = c_cdflt_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FCtype.c_cdflt"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.rec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FRec& acr::rec_Alloc() {
    acr::FRec* row = rec_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.rec  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.rec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FRec* acr::rec_AllocMaybe() {
    acr::FRec *row = (acr::FRec*)rec_AllocMem();
    if (row) {
        new (row) acr::FRec; // call constructor
    }
    return row;
}

// --- acr.FDb.rec.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::rec_Delete(acr::FRec &row) {
    row.~FRec();
    rec_FreeMem(row);
}

// --- acr.FDb.rec.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::rec_AllocMem() {
    acr::FRec *row = _db.rec_free;
    if (UNLIKELY(!row)) {
        rec_Reserve(1);
        row = _db.rec_free;
    }
    if (row) {
        _db.rec_free = row->rec_next;
    }
    return row;
}

// --- acr.FDb.rec.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::rec_FreeMem(acr::FRec &row) {
    if (UNLIKELY(row.rec_next != (acr::FRec*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.rec  comment:'double deletion caught'");
    }
    row.rec_next = _db.rec_free; // insert into free list
    _db.rec_free  = &row;
}

// --- acr.FDb.rec.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::rec_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.rec_blocksize; // underlying allocator is probably Lpool
        u64 reserved = rec_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.rec.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::rec_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FRec)) {
        acr::FRec *mem = (acr::FRec*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FRec) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].rec_next = _db.rec_free;
            _db.rec_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.rec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::rec_XrefMaybe(acr::FRec &row) {
    bool retval = true;
    (void)row;
    acr::FFile* p_p_outfile = row.p_outfile;
    if (UNLIKELY(!p_p_outfile)) {
        algo_lib::ResetErrtext() << "acr.null_ref  xref:acr.FFile.zd_frec";
        return false;
    }
    // insert rec into index zd_frec
    if (true) { // user-defined insert condition
        zd_frec_Insert(*p_p_outfile, row);
    }
    acr::FCtype* p_p_ctype = row.p_ctype;
    if (UNLIKELY(!p_p_ctype)) {
        algo_lib::ResetErrtext() << "acr.null_ref  xref:acr.FCtype.ind_rec";
        return false;
    }
    // insert rec into index ind_rec
    if (true) { // user-defined insert condition
        bool success = ind_rec_InsertMaybe(*p_p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FCtype.ind_rec"; // check for duplicate key
            return false;
        }
    }
    // insert rec into index zd_trec
    if (true) { // user-defined insert condition
        zd_trec_Insert(*p_p_ctype, row);
    }
    return retval;
}

// --- acr.FDb.uniqueattr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FUniqueattr& acr::uniqueattr_Alloc() {
    acr::FUniqueattr* row = uniqueattr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.uniqueattr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.uniqueattr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FUniqueattr* acr::uniqueattr_AllocMaybe() {
    acr::FUniqueattr *row = (acr::FUniqueattr*)uniqueattr_AllocMem();
    if (row) {
        new (row) acr::FUniqueattr; // call constructor
    }
    return row;
}

// --- acr.FDb.uniqueattr.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::uniqueattr_Delete(acr::FUniqueattr &row) {
    row.~FUniqueattr();
    uniqueattr_FreeMem(row);
}

// --- acr.FDb.uniqueattr.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::uniqueattr_AllocMem() {
    acr::FUniqueattr *row = _db.uniqueattr_free;
    if (UNLIKELY(!row)) {
        uniqueattr_Reserve(1);
        row = _db.uniqueattr_free;
    }
    if (row) {
        _db.uniqueattr_free = row->uniqueattr_next;
    }
    return row;
}

// --- acr.FDb.uniqueattr.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::uniqueattr_FreeMem(acr::FUniqueattr &row) {
    if (UNLIKELY(row.uniqueattr_next != (acr::FUniqueattr*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.uniqueattr  comment:'double deletion caught'");
    }
    row.uniqueattr_next = _db.uniqueattr_free; // insert into free list
    _db.uniqueattr_free  = &row;
}

// --- acr.FDb.uniqueattr.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::uniqueattr_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.uniqueattr_blocksize; // underlying allocator is probably Lpool
        u64 reserved = uniqueattr_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.uniqueattr.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::uniqueattr_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FUniqueattr)) {
        acr::FUniqueattr *mem = (acr::FUniqueattr*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FUniqueattr) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].uniqueattr_next = _db.uniqueattr_free;
            _db.uniqueattr_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.uniqueattr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::uniqueattr_XrefMaybe(acr::FUniqueattr &row) {
    bool retval = true;
    (void)row;
    // insert uniqueattr into index ind_uniqueattr
    if (true) { // user-defined insert condition
        bool success = ind_uniqueattr_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_uniqueattr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.query.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FQuery& acr::query_Alloc() {
    acr::FQuery* row = query_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.query  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.query.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FQuery* acr::query_AllocMaybe() {
    acr::FQuery *row = (acr::FQuery*)query_AllocMem();
    if (row) {
        new (row) acr::FQuery; // call constructor
    }
    return row;
}

// --- acr.FDb.query.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::query_Delete(acr::FQuery &row) {
    row.~FQuery();
    query_FreeMem(row);
}

// --- acr.FDb.query.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* acr::query_AllocMem() {
    acr::FQuery *row = _db.query_free;
    if (UNLIKELY(!row)) {
        query_Reserve(1);
        row = _db.query_free;
    }
    if (row) {
        _db.query_free = row->query_next;
    }
    return row;
}

// --- acr.FDb.query.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::query_FreeMem(acr::FQuery &row) {
    if (UNLIKELY(row.query_next != (acr::FQuery*)-1)) {
        FatalErrorExit("acr.tpool_double_delete  pool:acr.FDb.query  comment:'double deletion caught'");
    }
    row.query_next = _db.query_free; // insert into free list
    _db.query_free  = &row;
}

// --- acr.FDb.query.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 acr::query_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.query_blocksize; // underlying allocator is probably Lpool
        u64 reserved = query_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- acr.FDb.query.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 acr::query_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(acr::FQuery)) {
        acr::FQuery *mem = (acr::FQuery*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(acr::FQuery) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].query_next = _db.query_free;
            _db.query_free = mem+i;
        }
    }
    return ret;
}

// --- acr.FDb.query.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::query_XrefMaybe(acr::FQuery &row) {
    bool retval = true;
    (void)row;
    // insert query into index zs_query
    if (true) { // user-defined insert condition
        zs_query_Insert(row);
    }
    return retval;
}

// --- acr.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FField& acr::field_Alloc() {
    acr::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FField* acr::field_AllocMaybe() {
    acr::FField *row = (acr::FField*)field_AllocMem();
    if (row) {
        new (row) acr::FField; // call constructor
    }
    return row;
}

// --- acr.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FField* acr::field_InsertMaybe(const dmmeta::Field &value) {
    acr::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(acr::FField*)algo_lib::malloc_AllocMem(sizeof(acr::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u64(n)).~FField();
        _db.field_n = i32(n);
    }
}

// --- acr.FDb.field.InputMaybe
static bool acr::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::field_XrefMaybe(acr::FField &row) {
    bool retval = true;
    (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    acr::FCtype* p_arg = acr::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // insert field into index zd_arg
    if (true) { // user-defined insert condition
        zd_arg_Insert(*p_arg, row);
    }
    return retval;
}

// --- acr.FDb.file.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FFile& acr::file_Alloc() {
    acr::FFile* row = file_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.file  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.file.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FFile* acr::file_AllocMaybe() {
    acr::FFile *row = (acr::FFile*)file_AllocMem();
    if (row) {
        new (row) acr::FFile; // call constructor
    }
    return row;
}

// --- acr.FDb.file.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::file_AllocMem() {
    u64 new_nelems     = _db.file_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FFile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.file_lary[bsr];
        if (!lev) {
            lev=(acr::FFile*)algo_lib::malloc_AllocMem(sizeof(acr::FFile) * (u64(1)<<bsr));
            _db.file_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.file_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.file.RemoveAll
// Remove all elements from Lary
void acr::file_RemoveAll() {
    for (u64 n = _db.file_n; n>0; ) {
        n--;
        file_qFind(u64(n)).~FFile(); // destroy last element
        _db.file_n = i32(n);
    }
}

// --- acr.FDb.file.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::file_RemoveLast() {
    u64 n = _db.file_n;
    if (n > 0) {
        n -= 1;
        file_qFind(u64(n)).~FFile();
        _db.file_n = i32(n);
    }
}

// --- acr.FDb.file.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::file_XrefMaybe(acr::FFile &row) {
    bool retval = true;
    (void)row;
    // insert file into index ind_file
    if (true) { // user-defined insert condition
        bool success = ind_file_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_file"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     acr.FDb.cmdline
//     algo_lib.FDb.cmdline
void acr::ReadArgv() {
    command::acr &cmd = acr::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    int anonidx=0;
    algo::strptr nextanon = command::acr_GetAnon(cmd, anonidx);
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::acr_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"acr: unknown option "<<Keyval("value",arg)<<eol;
            } else {
                if (isanon) {
                    if (attrname == nextanon) { // treat named anon (positional) argument as unnamed
                        attrname = ""; // treat it as unnamed
                    } else if (nextanon != "") { // disallow out-of-order anon (positional) args
                        err<<"acr: error at "<<algo::strptr_ToSsim(arg)<<": must be preceded by [-"<<nextanon<<"]"<<eol;
                    }
                }
            }
        }
        // look up anon field name based on index
        // anon fields are only allowed in the leaf ns, never base
        if (ch_N(attrname) == 0) {
            attrname = nextanon;
            nextanon = command::acr_GetAnon(cmd, ++anonidx);
            command::FieldId_ReadStrptrMaybe(attrid,attrname);
            whichns=1;
        }
        if (ch_N(attrname) == 0) {
            err << "acr: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::acr_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"acr: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(acr_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    vrfy(acr::LoadTuplesMaybe(cmd.schema)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
}

// --- acr.FDb._db.MainLoop
// Main loop.
void acr::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        acr::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- acr.FDb._db.Step
// Main step
void acr::Step() {
}

// --- acr.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void acr::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("acr", acr::InsertStrptrMaybe, NULL, acr::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "acr.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(acr::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)acr::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'acr.Input'  signature:'5b35bb60c26576ddf66e70c5fcefab0c79b6cbb9'");
}

// --- acr.FDb._db.StaticCheck
void acr::StaticCheck() {
    algo_assert(_offset_of(acr::FieldId, value) + sizeof(((acr::FieldId*)0)->value) == sizeof(acr::FieldId));
}

// --- acr.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool acr::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    acr::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case acr_TableId_dmmeta_Ctype: { // finput:acr.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Anonfld: { // finput:acr.FDb.anonfld
            dmmeta::Anonfld elem;
            retval = dmmeta::Anonfld_ReadStrptrMaybe(elem, str);
            retval = retval && anonfld_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Cdflt: { // finput:acr.FDb.cdflt
            dmmeta::Cdflt elem;
            retval = dmmeta::Cdflt_ReadStrptrMaybe(elem, str);
            retval = retval && cdflt_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Field: { // finput:acr.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Substr: { // finput:acr.FDb.substr
            dmmeta::Substr elem;
            retval = dmmeta::Substr_ReadStrptrMaybe(elem, str);
            retval = retval && substr_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Ssimfile: { // finput:acr.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Ssimsort: { // finput:acr.FDb.ssimsort
            dmmeta::Ssimsort elem;
            retval = dmmeta::Ssimsort_ReadStrptrMaybe(elem, str);
            retval = retval && ssimsort_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Smallstr: { // finput:acr.FDb.smallstr
            dmmeta::Smallstr elem;
            retval = dmmeta::Smallstr_ReadStrptrMaybe(elem, str);
            retval = retval && smallstr_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Funique: { // finput:acr.FDb.funique
            dmmeta::Funique elem;
            retval = dmmeta::Funique_ReadStrptrMaybe(elem, str);
            retval = retval && funique_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_amcdb_Bltin: { // finput:acr.FDb.bltin
            amcdb::Bltin elem;
            retval = amcdb::Bltin_ReadStrptrMaybe(elem, str);
            retval = retval && bltin_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Cppfunc: { // finput:acr.FDb.cppfunc
            dmmeta::Cppfunc elem;
            retval = dmmeta::Cppfunc_ReadStrptrMaybe(elem, str);
            retval = retval && cppfunc_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case acr_TableId_dmmeta_Ssimreq: { // finput:acr.FDb.ssimreq
            dmmeta::Ssimreq elem;
            retval = dmmeta::Ssimreq_ReadStrptrMaybe(elem, str);
            retval = retval && ssimreq_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- acr.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool acr::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dmmeta.anonfld", "dmmeta.ctype", "amcdb.bltin", "dmmeta.cdflt"
        , "dmmeta.cppfunc", "dmmeta.field", "dmmeta.funique", "dmmeta.smallstr"
        , "dmmeta.ssimfile", "dmmeta.ssimreq", "dmmeta.ssimsort", "dmmeta.substr"

        , NULL};
        retval = algo_lib::DoLoadTuples(root, acr::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- acr.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool acr::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, acr::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- acr.FDb._db.Steps
// Calls Step function of dependencies
void acr::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- acr.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- acr.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
acr::FCtype* acr::ind_ctype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    acr::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    acr::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_ctype_InsertMaybe(acr::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (acr::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            acr::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_ctype_Remove(acr::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (acr::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (acr::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (acr::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- acr.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FCtype*);
        u32 new_size = new_nbuckets * sizeof(acr::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FCtype* *new_buckets = (acr::FCtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            acr::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                acr::FCtype &row        = *elem;
                acr::FCtype* next       = row.ind_ctype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
acr::FField* acr::ind_field_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    acr::FField* *e = &_db.ind_field_buckets_elems[index];
    acr::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_field_InsertMaybe(acr::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (acr::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            acr::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_field_Remove(acr::FField& row) {
    if (LIKELY(row.ind_field_next != (acr::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (acr::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (acr::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- acr.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FField*);
        u32 new_size = new_nbuckets * sizeof(acr::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FField* *new_buckets = (acr::FField**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            acr::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                acr::FField &row        = *elem;
                acr::FField* next       = row.ind_field_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.ind_file.Find
// Find row by key. Return NULL if not found.
acr::FFile* acr::ind_file_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_file_buckets_n - 1);
    acr::FFile* *e = &_db.ind_file_buckets_elems[index];
    acr::FFile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).file == key;
        if (done) break;
        e         = &ret->ind_file_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_file.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FFile& acr::ind_file_GetOrCreate(const algo::strptr& key) {
    acr::FFile* ret = ind_file_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &file_Alloc();
        (*ret).file = key;
        bool good = file_XrefMaybe(*ret);
        if (!good) {
            file_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr.create_error  table:ind_file  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr.FDb.ind_file.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_file_InsertMaybe(acr::FFile& row) {
    ind_file_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_file_next == (acr::FFile*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.file) & (_db.ind_file_buckets_n - 1);
        acr::FFile* *prev = &_db.ind_file_buckets_elems[index];
        do {
            acr::FFile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).file == row.file) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_file_next;
        } while (true);
        if (retval) {
            row.ind_file_next = *prev;
            _db.ind_file_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_file.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_file_Remove(acr::FFile& row) {
    if (LIKELY(row.ind_file_next != (acr::FFile*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.file) & (_db.ind_file_buckets_n - 1);
        acr::FFile* *prev = &_db.ind_file_buckets_elems[index]; // addr of pointer to current element
        while (acr::FFile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_file_next; // unlink (singly linked list)
                _db.ind_file_n--;
                row.ind_file_next = (acr::FFile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_file_next;
        }
    }
}

// --- acr.FDb.ind_file.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_file_Reserve(int n) {
    u32 old_nbuckets = _db.ind_file_buckets_n;
    u32 new_nelems   = _db.ind_file_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FFile*);
        u32 new_size = new_nbuckets * sizeof(acr::FFile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FFile* *new_buckets = (acr::FFile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_file");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_file_buckets_n; i++) {
            acr::FFile* elem = _db.ind_file_buckets_elems[i];
            while (elem) {
                acr::FFile &row        = *elem;
                acr::FFile* next       = row.ind_file_next;
                u32 index          = algo::cstring_Hash(0, row.file) & (new_nbuckets-1);
                row.ind_file_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_file_buckets_elems, old_size);
        _db.ind_file_buckets_elems = new_buckets;
        _db.ind_file_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.zd_all_selrec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_all_selrec_Insert(acr::FRec& row) {
    if (!zd_all_selrec_InLlistQ(row)) {
        acr::FRec* old_tail = _db.zd_all_selrec_tail;
        row.zd_all_selrec_next = NULL;
        row.zd_all_selrec_prev = old_tail;
        _db.zd_all_selrec_tail = &row;
        acr::FRec **new_row_a = &old_tail->zd_all_selrec_next;
        acr::FRec **new_row_b = &_db.zd_all_selrec_head;
        acr::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_all_selrec_n++;
    }
}

// --- acr.FDb.zd_all_selrec.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_all_selrec_Remove(acr::FRec& row) {
    if (zd_all_selrec_InLlistQ(row)) {
        acr::FRec* old_head       = _db.zd_all_selrec_head;
        (void)old_head; // in case it's not used
        acr::FRec* prev = row.zd_all_selrec_prev;
        acr::FRec* next = row.zd_all_selrec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FRec **new_next_a = &prev->zd_all_selrec_next;
        acr::FRec **new_next_b = &_db.zd_all_selrec_head;
        acr::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FRec **new_prev_a = &next->zd_all_selrec_prev;
        acr::FRec **new_prev_b = &_db.zd_all_selrec_tail;
        acr::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_all_selrec_n--;
        row.zd_all_selrec_next=(acr::FRec*)-1; // not-in-list
    }
}

// --- acr.FDb.zd_all_selrec.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_all_selrec_RemoveAll() {
    acr::FRec* row = _db.zd_all_selrec_head;
    _db.zd_all_selrec_head = NULL;
    _db.zd_all_selrec_tail = NULL;
    _db.zd_all_selrec_n = 0;
    while (row) {
        acr::FRec* row_next = row->zd_all_selrec_next;
        row->zd_all_selrec_next  = (acr::FRec*)-1;
        row->zd_all_selrec_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FDb.zd_all_selrec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec* acr::zd_all_selrec_RemoveFirst() {
    acr::FRec *row = NULL;
    row = _db.zd_all_selrec_head;
    if (row) {
        acr::FRec *next = row->zd_all_selrec_next;
        _db.zd_all_selrec_head = next;
        acr::FRec **new_end_a = &next->zd_all_selrec_prev;
        acr::FRec **new_end_b = &_db.zd_all_selrec_tail;
        acr::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_all_selrec_n--;
        row->zd_all_selrec_next = (acr::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.zd_all_err.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_all_err_Insert(acr::FErr& row) {
    if (!zd_all_err_InLlistQ(row)) {
        acr::FErr* old_tail = _db.zd_all_err_tail;
        row.zd_all_err_next = NULL;
        row.zd_all_err_prev = old_tail;
        _db.zd_all_err_tail = &row;
        acr::FErr **new_row_a = &old_tail->zd_all_err_next;
        acr::FErr **new_row_b = &_db.zd_all_err_head;
        acr::FErr **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_all_err_n++;
    }
}

// --- acr.FDb.zd_all_err.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_all_err_Remove(acr::FErr& row) {
    if (zd_all_err_InLlistQ(row)) {
        acr::FErr* old_head       = _db.zd_all_err_head;
        (void)old_head; // in case it's not used
        acr::FErr* prev = row.zd_all_err_prev;
        acr::FErr* next = row.zd_all_err_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FErr **new_next_a = &prev->zd_all_err_next;
        acr::FErr **new_next_b = &_db.zd_all_err_head;
        acr::FErr **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FErr **new_prev_a = &next->zd_all_err_prev;
        acr::FErr **new_prev_b = &_db.zd_all_err_tail;
        acr::FErr **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_all_err_n--;
        row.zd_all_err_next=(acr::FErr*)-1; // not-in-list
    }
}

// --- acr.FDb.zd_all_err.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_all_err_RemoveAll() {
    acr::FErr* row = _db.zd_all_err_head;
    _db.zd_all_err_head = NULL;
    _db.zd_all_err_tail = NULL;
    _db.zd_all_err_n = 0;
    while (row) {
        acr::FErr* row_next = row->zd_all_err_next;
        row->zd_all_err_next  = (acr::FErr*)-1;
        row->zd_all_err_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FDb.zd_all_err.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FErr* acr::zd_all_err_RemoveFirst() {
    acr::FErr *row = NULL;
    row = _db.zd_all_err_head;
    if (row) {
        acr::FErr *next = row->zd_all_err_next;
        _db.zd_all_err_head = next;
        acr::FErr **new_end_a = &next->zd_all_err_prev;
        acr::FErr **new_end_b = &_db.zd_all_err_tail;
        acr::FErr **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_all_err_n--;
        row->zd_all_err_next = (acr::FErr*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.zd_sel_ctype.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_sel_ctype_Insert(acr::FCtype& row) {
    if (!zd_sel_ctype_InLlistQ(row)) {
        acr::FCtype* old_tail = _db.zd_sel_ctype_tail;
        row.zd_sel_ctype_next = NULL;
        row.zd_sel_ctype_prev = old_tail;
        _db.zd_sel_ctype_tail = &row;
        acr::FCtype **new_row_a = &old_tail->zd_sel_ctype_next;
        acr::FCtype **new_row_b = &_db.zd_sel_ctype_head;
        acr::FCtype **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FDb.zd_sel_ctype.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_sel_ctype_Remove(acr::FCtype& row) {
    if (zd_sel_ctype_InLlistQ(row)) {
        acr::FCtype* old_head       = _db.zd_sel_ctype_head;
        (void)old_head; // in case it's not used
        acr::FCtype* prev = row.zd_sel_ctype_prev;
        acr::FCtype* next = row.zd_sel_ctype_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FCtype **new_next_a = &prev->zd_sel_ctype_next;
        acr::FCtype **new_next_b = &_db.zd_sel_ctype_head;
        acr::FCtype **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FCtype **new_prev_a = &next->zd_sel_ctype_prev;
        acr::FCtype **new_prev_b = &_db.zd_sel_ctype_tail;
        acr::FCtype **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_sel_ctype_next=(acr::FCtype*)-1; // not-in-list
    }
}

// --- acr.FDb.zd_sel_ctype.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_sel_ctype_RemoveAll() {
    acr::FCtype* row = _db.zd_sel_ctype_head;
    _db.zd_sel_ctype_head = NULL;
    _db.zd_sel_ctype_tail = NULL;
    while (row) {
        acr::FCtype* row_next = row->zd_sel_ctype_next;
        row->zd_sel_ctype_next  = (acr::FCtype*)-1;
        row->zd_sel_ctype_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FDb.zd_sel_ctype.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FCtype* acr::zd_sel_ctype_RemoveFirst() {
    acr::FCtype *row = NULL;
    row = _db.zd_sel_ctype_head;
    if (row) {
        acr::FCtype *next = row->zd_sel_ctype_next;
        _db.zd_sel_ctype_head = next;
        acr::FCtype **new_end_a = &next->zd_sel_ctype_prev;
        acr::FCtype **new_end_b = &_db.zd_sel_ctype_tail;
        acr::FCtype **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_sel_ctype_next = (acr::FCtype*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.bh_pline.Dealloc
// Remove all elements from heap and free memory used by the array.
void acr::bh_pline_Dealloc() {
    bh_pline_RemoveAll();
    algo_lib::malloc_FreeMem(_db.bh_pline_elems, sizeof(acr::FPline*)*_db.bh_pline_max);
    _db.bh_pline_max   = 0;
    _db.bh_pline_elems = NULL;
}

// --- acr.FDb.bh_pline.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int acr::bh_pline_Downheap(acr::FPline& row, int idx) {
    acr::FPline* *elems = _db.bh_pline_elems;
    int n = _db.bh_pline_n;
    int child = idx*2+1;
    while (child < n) {
        acr::FPline* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            acr::FPline* q = elems[rchild]; // right child
            if (bh_pline_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_pline_ElemLt(*p,row)) {
            break;
        }
        p->bh_pline_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- acr.FDb.bh_pline.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void acr::bh_pline_Insert(acr::FPline& row) {
    if (LIKELY(row.bh_pline_idx == -1)) {
        bh_pline_Reserve(1);
        int n = _db.bh_pline_n;
        _db.bh_pline_n = n + 1;
        int new_idx = bh_pline_Upheap(row, n);
        row.bh_pline_idx = new_idx;
        _db.bh_pline_elems[new_idx] = &row;
    }
}

// --- acr.FDb.bh_pline.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 acr::bh_pline_Reheap(acr::FPline& row) {
    int old_idx = row.bh_pline_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_pline_Reserve(1);
        old_idx = _db.bh_pline_n++;
    }
    int new_idx = bh_pline_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_pline_Downheap(row, old_idx);
    }
    row.bh_pline_idx = new_idx;
    _db.bh_pline_elems[new_idx] = &row;
    return new_idx;
}

// --- acr.FDb.bh_pline.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 acr::bh_pline_ReheapFirst() {
    acr::FPline &row = *_db.bh_pline_elems[0];
    i32 new_idx = bh_pline_Downheap(row, 0);
    row.bh_pline_idx = new_idx;
    _db.bh_pline_elems[new_idx] = &row;
    return new_idx;
}

// --- acr.FDb.bh_pline.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::bh_pline_Remove(acr::FPline& row) {
    if (bh_pline_InBheapQ(row)) {
        int old_idx = row.bh_pline_idx;
        if (_db.bh_pline_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_pline_idx = -1;           // mark not in heap
            i32 n = _db.bh_pline_n - 1; // index of last element in heap
            _db.bh_pline_n = n;         // decrease count
            if (old_idx != n) {
                acr::FPline *elem = _db.bh_pline_elems[n];
                int new_idx = bh_pline_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_pline_Downheap(*elem, old_idx);
                }
                elem->bh_pline_idx = new_idx;
                _db.bh_pline_elems[new_idx] = elem;
            }
        }
    }
}

// --- acr.FDb.bh_pline.RemoveAll
// Remove all elements from binary heap
void acr::bh_pline_RemoveAll() {
    int n = _db.bh_pline_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_pline_elems[i]->bh_pline_idx = -1; // mark not-in-heap
    }
    _db.bh_pline_n = 0;
}

// --- acr.FDb.bh_pline.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
acr::FPline* acr::bh_pline_RemoveFirst() {
    acr::FPline *row = NULL;
    if (_db.bh_pline_n > 0) {
        row = _db.bh_pline_elems[0];
        row->bh_pline_idx = -1;           // mark not in heap
        i32 n = _db.bh_pline_n - 1; // index of last element in heap
        _db.bh_pline_n = n;         // decrease count
        if (n) {
            acr::FPline &elem = *_db.bh_pline_elems[n];
            int new_idx = bh_pline_Downheap(elem, 0);
            elem.bh_pline_idx = new_idx;
            _db.bh_pline_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- acr.FDb.bh_pline.Reserve
// Reserve space in index for N more elements
void acr::bh_pline_Reserve(int n) {
    i32 old_max = _db.bh_pline_max;
    if (UNLIKELY(_db.bh_pline_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FPline*);
        u32 new_size = new_max * sizeof(acr::FPline*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.bh_pline_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.bh_pline");
        }
        _db.bh_pline_elems = (acr::FPline**)new_mem;
        _db.bh_pline_max = new_max;
    }
}

// --- acr.FDb.bh_pline.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int acr::bh_pline_Upheap(acr::FPline& row, int idx) {
    acr::FPline* *elems = _db.bh_pline_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        acr::FPline* p = elems[j];
        if (!bh_pline_ElemLt(row, *p)) {
            break;
        }
        p->bh_pline_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- acr.FDb.bh_pline.ElemLt
inline static bool acr::bh_pline_ElemLt(acr::FPline &a, acr::FPline &b) {
    (void)_db;
    return key_Lt(a, b);
}

// --- acr.FDb.substr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSubstr& acr::substr_Alloc() {
    acr::FSubstr* row = substr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.substr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.substr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FSubstr* acr::substr_AllocMaybe() {
    acr::FSubstr *row = (acr::FSubstr*)substr_AllocMem();
    if (row) {
        new (row) acr::FSubstr; // call constructor
    }
    return row;
}

// --- acr.FDb.substr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSubstr* acr::substr_InsertMaybe(const dmmeta::Substr &value) {
    acr::FSubstr *row = &substr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    substr_CopyIn(*row,const_cast<dmmeta::Substr&>(value));
    bool ok = substr_XrefMaybe(*row); // this may return false
    if (!ok) {
        substr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.substr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::substr_AllocMem() {
    u64 new_nelems     = _db.substr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FSubstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.substr_lary[bsr];
        if (!lev) {
            lev=(acr::FSubstr*)algo_lib::malloc_AllocMem(sizeof(acr::FSubstr) * (u64(1)<<bsr));
            _db.substr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.substr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.substr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::substr_RemoveLast() {
    u64 n = _db.substr_n;
    if (n > 0) {
        n -= 1;
        substr_qFind(u64(n)).~FSubstr();
        _db.substr_n = i32(n);
    }
}

// --- acr.FDb.substr.InputMaybe
static bool acr::substr_InputMaybe(dmmeta::Substr &elem) {
    bool retval = true;
    retval = substr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.substr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::substr_XrefMaybe(acr::FSubstr &row) {
    bool retval = true;
    (void)row;
    acr::FField* p_field = acr::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert substr into index c_substr
    if (true) { // user-defined insert condition
        bool success = c_substr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FField.c_substr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimfile& acr::ssimfile_Alloc() {
    acr::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimfile* acr::ssimfile_AllocMaybe() {
    acr::FSsimfile *row = (acr::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) acr::FSsimfile; // call constructor
    }
    return row;
}

// --- acr.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimfile* acr::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    acr::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(acr::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = i32(n);
    }
}

// --- acr.FDb.ssimfile.InputMaybe
static bool acr::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::ssimfile_XrefMaybe(acr::FSsimfile &row) {
    bool retval = true;
    (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        bool success = c_ssimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FCtype.c_ssimfile"; // check for duplicate key
            return false;
        }
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.tempkey.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FTempkey& acr::tempkey_Alloc() {
    acr::FTempkey* row = tempkey_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.tempkey  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.tempkey.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FTempkey* acr::tempkey_AllocMaybe() {
    acr::FTempkey *row = (acr::FTempkey*)tempkey_AllocMem();
    if (row) {
        new (row) acr::FTempkey; // call constructor
    }
    return row;
}

// --- acr.FDb.tempkey.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::tempkey_AllocMem() {
    u64 new_nelems     = _db.tempkey_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FTempkey*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tempkey_lary[bsr];
        if (!lev) {
            lev=(acr::FTempkey*)algo_lib::malloc_AllocMem(sizeof(acr::FTempkey) * (u64(1)<<bsr));
            _db.tempkey_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tempkey_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.tempkey.RemoveAll
// Remove all elements from Lary
void acr::tempkey_RemoveAll() {
    for (u64 n = _db.tempkey_n; n>0; ) {
        n--;
        tempkey_qFind(u64(n)).~FTempkey(); // destroy last element
        _db.tempkey_n = i32(n);
    }
}

// --- acr.FDb.tempkey.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::tempkey_RemoveLast() {
    u64 n = _db.tempkey_n;
    if (n > 0) {
        n -= 1;
        tempkey_qFind(u64(n)).~FTempkey();
        _db.tempkey_n = i32(n);
    }
}

// --- acr.FDb.tempkey.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::tempkey_XrefMaybe(acr::FTempkey &row) {
    bool retval = true;
    (void)row;
    // insert tempkey into index ind_tempkey
    if (true) { // user-defined insert condition
        bool success = ind_tempkey_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_tempkey"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.ind_tempkey.Find
// Find row by key. Return NULL if not found.
acr::FTempkey* acr::ind_tempkey_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_tempkey_buckets_n - 1);
    acr::FTempkey* *e = &_db.ind_tempkey_buckets_elems[index];
    acr::FTempkey* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).tempkey == key;
        if (done) break;
        e         = &ret->ind_tempkey_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_tempkey.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FTempkey& acr::ind_tempkey_GetOrCreate(const algo::strptr& key) {
    acr::FTempkey* ret = ind_tempkey_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &tempkey_Alloc();
        (*ret).tempkey = key;
        bool good = tempkey_XrefMaybe(*ret);
        if (!good) {
            tempkey_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr.create_error  table:ind_tempkey  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr.FDb.ind_tempkey.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_tempkey_InsertMaybe(acr::FTempkey& row) {
    ind_tempkey_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_tempkey_next == (acr::FTempkey*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.tempkey) & (_db.ind_tempkey_buckets_n - 1);
        acr::FTempkey* *prev = &_db.ind_tempkey_buckets_elems[index];
        do {
            acr::FTempkey* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).tempkey == row.tempkey) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_tempkey_next;
        } while (true);
        if (retval) {
            row.ind_tempkey_next = *prev;
            _db.ind_tempkey_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_tempkey.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_tempkey_Remove(acr::FTempkey& row) {
    if (LIKELY(row.ind_tempkey_next != (acr::FTempkey*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.tempkey) & (_db.ind_tempkey_buckets_n - 1);
        acr::FTempkey* *prev = &_db.ind_tempkey_buckets_elems[index]; // addr of pointer to current element
        while (acr::FTempkey *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_tempkey_next; // unlink (singly linked list)
                _db.ind_tempkey_n--;
                row.ind_tempkey_next = (acr::FTempkey*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_tempkey_next;
        }
    }
}

// --- acr.FDb.ind_tempkey.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_tempkey_Reserve(int n) {
    u32 old_nbuckets = _db.ind_tempkey_buckets_n;
    u32 new_nelems   = _db.ind_tempkey_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FTempkey*);
        u32 new_size = new_nbuckets * sizeof(acr::FTempkey*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FTempkey* *new_buckets = (acr::FTempkey**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_tempkey");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_tempkey_buckets_n; i++) {
            acr::FTempkey* elem = _db.ind_tempkey_buckets_elems[i];
            while (elem) {
                acr::FTempkey &row        = *elem;
                acr::FTempkey* next       = row.ind_tempkey_next;
                u32 index          = algo::cstring_Hash(0, row.tempkey) & (new_nbuckets-1);
                row.ind_tempkey_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_tempkey_buckets_elems, old_size);
        _db.ind_tempkey_buckets_elems = new_buckets;
        _db.ind_tempkey_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
acr::FSsimfile* acr::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    acr::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    acr::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_ssimfile_InsertMaybe(acr::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (acr::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            acr::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_ssimfile_Remove(acr::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (acr::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (acr::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (acr::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- acr.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(acr::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FSsimfile* *new_buckets = (acr::FSsimfile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            acr::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                acr::FSsimfile &row        = *elem;
                acr::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.print.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::print_XrefMaybe(acr::FPrint &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.printattr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPrintAttr& acr::printattr_Alloc() {
    acr::FPrintAttr* row = printattr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.printattr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.printattr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FPrintAttr* acr::printattr_AllocMaybe() {
    acr::FPrintAttr *row = (acr::FPrintAttr*)printattr_AllocMem(sizeof(acr::FPrintAttr));
    if (row) {
        new (row) acr::FPrintAttr; // call constructor
    }
    return row;
}

// --- acr.FDb.printattr.Delete
// Remove row from all global and cross indices, then deallocate row
void acr::printattr_Delete(acr::FPrintAttr &row) {
    int length = sizeof(acr::FPrintAttr);
    row.~FPrintAttr();
    printattr_FreeMem(&row, length);
}

// --- acr.FDb.printattr.AllocMem
// Allocate n bytes. If no memory available, return NULL.
void* acr::printattr_AllocMem(size_t n) {
    void* mem = malloc(n);
    ++algo_lib::_db.trace.alloc__db_malloc; // update global malloc counter
    return mem;
}

// --- acr.FDb.printattr.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void acr::printattr_FreeMem(void *mem, size_t n) {
    (void)n;
    if (mem) {
        ++algo_lib::_db.trace.del__db_malloc; // update global malloc counter
        free(mem);
    }
}

// --- acr.FDb.printattr.ReallocMem
// Reallocate n bytes. If the call fails, return value is NULL.
// In this case, original MEM pointer is untouched.
void* acr::printattr_ReallocMem(void *mem, size_t old_size, size_t new_size) {
    (void)old_size;
    algo_lib::_db.trace.alloc__db_malloc += old_size == 0; // update global malloc counter
    algo_lib::_db.trace.del__db_malloc += new_size == 0; // update global malloc counter
    void* new_mem = realloc(mem, new_size);
    return new_mem;
}

// --- acr.FDb.printattr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::printattr_XrefMaybe(acr::FPrintAttr &row) {
    bool retval = true;
    (void)row;
    acr::FPrint* p_p_print = row.p_print;
    if (UNLIKELY(!p_p_print)) {
        algo_lib::ResetErrtext() << "acr.null_ref  xref:acr.FPrint.ind_printattr";
        return false;
    }
    // insert printattr into index ind_printattr
    if (true) { // user-defined insert condition
        bool success = ind_printattr_InsertMaybe(*p_p_print, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FPrint.ind_printattr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.zs_query.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zs_query_Insert(acr::FQuery& row) {
    if (!zs_query_InLlistQ(row)) {
        acr::FQuery* old_tail       = _db.zs_query_tail;
        row.zs_query_next  = NULL;
        _db.zs_query_tail = &row;
        acr::FQuery **new_row_a = &old_tail->zs_query_next;
        acr::FQuery **new_row_b = &_db.zs_query_head;
        acr::FQuery **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FDb.zs_query.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void acr::zs_query_Remove(acr::FQuery& row) {
    if (zs_query_InLlistQ(row)) {
        acr::FQuery* old_head       = _db.zs_query_head;
        (void)old_head; // in case it's not used
        acr::FQuery* prev=NULL;
        acr::FQuery* cur     = _db.zs_query_head;
        while (cur) {  // search for element by pointer
            acr::FQuery* next = cur->zs_query_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_query_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_query_next = next;
                } else {
                    _db.zs_query_head = next;
                }
                row.zs_query_next = (acr::FQuery*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- acr.FDb.zs_query.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zs_query_RemoveAll() {
    acr::FQuery* row = _db.zs_query_head;
    _db.zs_query_head = NULL;
    _db.zs_query_tail = NULL;
    while (row) {
        acr::FQuery* row_next = row->zs_query_next;
        row->zs_query_next  = (acr::FQuery*)-1;
        row = row_next;
    }
}

// --- acr.FDb.zs_query.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FQuery* acr::zs_query_RemoveFirst() {
    acr::FQuery *row = NULL;
    row = _db.zs_query_head;
    if (row) {
        acr::FQuery *next = row->zs_query_next;
        _db.zs_query_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_query_tail = NULL;
        }
        row->zs_query_next = (acr::FQuery*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FDb.run.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::run_XrefMaybe(acr::FRun &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.check.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::check_XrefMaybe(acr::FCheck &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.ssimsort.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimsort& acr::ssimsort_Alloc() {
    acr::FSsimsort* row = ssimsort_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.ssimsort  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.ssimsort.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimsort* acr::ssimsort_AllocMaybe() {
    acr::FSsimsort *row = (acr::FSsimsort*)ssimsort_AllocMem();
    if (row) {
        new (row) acr::FSsimsort; // call constructor
    }
    return row;
}

// --- acr.FDb.ssimsort.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimsort* acr::ssimsort_InsertMaybe(const dmmeta::Ssimsort &value) {
    acr::FSsimsort *row = &ssimsort_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimsort_CopyIn(*row,const_cast<dmmeta::Ssimsort&>(value));
    bool ok = ssimsort_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimsort_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.ssimsort.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::ssimsort_AllocMem() {
    u64 new_nelems     = _db.ssimsort_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FSsimsort*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimsort_lary[bsr];
        if (!lev) {
            lev=(acr::FSsimsort*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimsort) * (u64(1)<<bsr));
            _db.ssimsort_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimsort_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.ssimsort.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::ssimsort_RemoveLast() {
    u64 n = _db.ssimsort_n;
    if (n > 0) {
        n -= 1;
        ssimsort_qFind(u64(n)).~FSsimsort();
        _db.ssimsort_n = i32(n);
    }
}

// --- acr.FDb.ssimsort.InputMaybe
static bool acr::ssimsort_InputMaybe(dmmeta::Ssimsort &elem) {
    bool retval = true;
    retval = ssimsort_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.ssimsort.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::ssimsort_XrefMaybe(acr::FSsimsort &row) {
    bool retval = true;
    (void)row;
    acr::FSsimfile* p_ssimfile = acr::ind_ssimfile_Find(row.ssimfile);
    if (UNLIKELY(!p_ssimfile)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ssimfile" << Keyval("key", row.ssimfile);
        return false;
    }
    // insert ssimsort into index c_ssimsort
    if (true) { // user-defined insert condition
        bool success = c_ssimsort_InsertMaybe(*p_ssimfile, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FSsimfile.c_ssimsort"; // check for duplicate key
            return false;
        }
    }
    // insert ssimsort into index ind_ssimsort
    if (true) { // user-defined insert condition
        bool success = ind_ssimsort_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FDb.ind_ssimsort"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.ind_ssimsort.Find
// Find row by key. Return NULL if not found.
acr::FSsimsort* acr::ind_ssimsort_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimsort_buckets_n - 1);
    acr::FSsimsort* *e = &_db.ind_ssimsort_buckets_elems[index];
    acr::FSsimsort* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimsort_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_ssimsort.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_ssimsort_InsertMaybe(acr::FSsimsort& row) {
    ind_ssimsort_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimsort_next == (acr::FSsimsort*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimsort_buckets_n - 1);
        acr::FSsimsort* *prev = &_db.ind_ssimsort_buckets_elems[index];
        do {
            acr::FSsimsort* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimsort_next;
        } while (true);
        if (retval) {
            row.ind_ssimsort_next = *prev;
            _db.ind_ssimsort_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_ssimsort.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_ssimsort_Remove(acr::FSsimsort& row) {
    if (LIKELY(row.ind_ssimsort_next != (acr::FSsimsort*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimsort_buckets_n - 1);
        acr::FSsimsort* *prev = &_db.ind_ssimsort_buckets_elems[index]; // addr of pointer to current element
        while (acr::FSsimsort *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimsort_next; // unlink (singly linked list)
                _db.ind_ssimsort_n--;
                row.ind_ssimsort_next = (acr::FSsimsort*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimsort_next;
        }
    }
}

// --- acr.FDb.ind_ssimsort.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_ssimsort_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimsort_buckets_n;
    u32 new_nelems   = _db.ind_ssimsort_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FSsimsort*);
        u32 new_size = new_nbuckets * sizeof(acr::FSsimsort*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FSsimsort* *new_buckets = (acr::FSsimsort**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_ssimsort");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimsort_buckets_n; i++) {
            acr::FSsimsort* elem = _db.ind_ssimsort_buckets_elems[i];
            while (elem) {
                acr::FSsimsort &row        = *elem;
                acr::FSsimsort* next       = row.ind_ssimsort_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimsort_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimsort_buckets_elems, old_size);
        _db.ind_ssimsort_buckets_elems = new_buckets;
        _db.ind_ssimsort_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.write.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::write_XrefMaybe(acr::FWrite &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.smallstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSmallstr& acr::smallstr_Alloc() {
    acr::FSmallstr* row = smallstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.smallstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.smallstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FSmallstr* acr::smallstr_AllocMaybe() {
    acr::FSmallstr *row = (acr::FSmallstr*)smallstr_AllocMem();
    if (row) {
        new (row) acr::FSmallstr; // call constructor
    }
    return row;
}

// --- acr.FDb.smallstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSmallstr* acr::smallstr_InsertMaybe(const dmmeta::Smallstr &value) {
    acr::FSmallstr *row = &smallstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    smallstr_CopyIn(*row,const_cast<dmmeta::Smallstr&>(value));
    bool ok = smallstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        smallstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.smallstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::smallstr_AllocMem() {
    u64 new_nelems     = _db.smallstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FSmallstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.smallstr_lary[bsr];
        if (!lev) {
            lev=(acr::FSmallstr*)algo_lib::malloc_AllocMem(sizeof(acr::FSmallstr) * (u64(1)<<bsr));
            _db.smallstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.smallstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.smallstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::smallstr_RemoveLast() {
    u64 n = _db.smallstr_n;
    if (n > 0) {
        n -= 1;
        smallstr_qFind(u64(n)).~FSmallstr();
        _db.smallstr_n = i32(n);
    }
}

// --- acr.FDb.smallstr.InputMaybe
static bool acr::smallstr_InputMaybe(dmmeta::Smallstr &elem) {
    bool retval = true;
    retval = smallstr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.smallstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::smallstr_XrefMaybe(acr::FSmallstr &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.funique.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FFunique& acr::funique_Alloc() {
    acr::FFunique* row = funique_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.funique  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.funique.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FFunique* acr::funique_AllocMaybe() {
    acr::FFunique *row = (acr::FFunique*)funique_AllocMem();
    if (row) {
        new (row) acr::FFunique; // call constructor
    }
    return row;
}

// --- acr.FDb.funique.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FFunique* acr::funique_InsertMaybe(const dmmeta::Funique &value) {
    acr::FFunique *row = &funique_Alloc(); // if out of memory, process dies. if input error, return NULL.
    funique_CopyIn(*row,const_cast<dmmeta::Funique&>(value));
    bool ok = funique_XrefMaybe(*row); // this may return false
    if (!ok) {
        funique_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.funique.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::funique_AllocMem() {
    u64 new_nelems     = _db.funique_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FFunique*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.funique_lary[bsr];
        if (!lev) {
            lev=(acr::FFunique*)algo_lib::malloc_AllocMem(sizeof(acr::FFunique) * (u64(1)<<bsr));
            _db.funique_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.funique_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.funique.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::funique_RemoveLast() {
    u64 n = _db.funique_n;
    if (n > 0) {
        n -= 1;
        funique_qFind(u64(n)).~FFunique();
        _db.funique_n = i32(n);
    }
}

// --- acr.FDb.funique.InputMaybe
static bool acr::funique_InputMaybe(dmmeta::Funique &elem) {
    bool retval = true;
    retval = funique_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.funique.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::funique_XrefMaybe(acr::FFunique &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.ind_uniqueattr.Find
// Find row by key. Return NULL if not found.
acr::FUniqueattr* acr::ind_uniqueattr_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_uniqueattr_buckets_n - 1);
    acr::FUniqueattr* *e = &_db.ind_uniqueattr_buckets_elems[index];
    acr::FUniqueattr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).uniqueattr == key;
        if (done) break;
        e         = &ret->ind_uniqueattr_next;
    } while (true);
    return ret;
}

// --- acr.FDb.ind_uniqueattr.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FUniqueattr& acr::ind_uniqueattr_GetOrCreate(const algo::strptr& key) {
    acr::FUniqueattr* ret = ind_uniqueattr_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &uniqueattr_Alloc();
        (*ret).uniqueattr = key;
        bool good = uniqueattr_XrefMaybe(*ret);
        if (!good) {
            uniqueattr_Delete(*ret); // delete offending row, any existin xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr.create_error  table:ind_uniqueattr  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr.FDb.ind_uniqueattr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_uniqueattr_InsertMaybe(acr::FUniqueattr& row) {
    ind_uniqueattr_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_uniqueattr_next == (acr::FUniqueattr*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.uniqueattr) & (_db.ind_uniqueattr_buckets_n - 1);
        acr::FUniqueattr* *prev = &_db.ind_uniqueattr_buckets_elems[index];
        do {
            acr::FUniqueattr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).uniqueattr == row.uniqueattr) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_uniqueattr_next;
        } while (true);
        if (retval) {
            row.ind_uniqueattr_next = *prev;
            _db.ind_uniqueattr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FDb.ind_uniqueattr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_uniqueattr_Remove(acr::FUniqueattr& row) {
    if (LIKELY(row.ind_uniqueattr_next != (acr::FUniqueattr*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.uniqueattr) & (_db.ind_uniqueattr_buckets_n - 1);
        acr::FUniqueattr* *prev = &_db.ind_uniqueattr_buckets_elems[index]; // addr of pointer to current element
        while (acr::FUniqueattr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_uniqueattr_next; // unlink (singly linked list)
                _db.ind_uniqueattr_n--;
                row.ind_uniqueattr_next = (acr::FUniqueattr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_uniqueattr_next;
        }
    }
}

// --- acr.FDb.ind_uniqueattr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_uniqueattr_Reserve(int n) {
    u32 old_nbuckets = _db.ind_uniqueattr_buckets_n;
    u32 new_nelems   = _db.ind_uniqueattr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FUniqueattr*);
        u32 new_size = new_nbuckets * sizeof(acr::FUniqueattr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FUniqueattr* *new_buckets = (acr::FUniqueattr**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.ind_uniqueattr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_uniqueattr_buckets_n; i++) {
            acr::FUniqueattr* elem = _db.ind_uniqueattr_buckets_elems[i];
            while (elem) {
                acr::FUniqueattr &row        = *elem;
                acr::FUniqueattr* next       = row.ind_uniqueattr_next;
                u32 index          = algo::cstring_Hash(0, row.uniqueattr) & (new_nbuckets-1);
                row.ind_uniqueattr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_uniqueattr_buckets_elems, old_size);
        _db.ind_uniqueattr_buckets_elems = new_buckets;
        _db.ind_uniqueattr_buckets_n = new_nbuckets;
    }
}

// --- acr.FDb.bltin.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FBltin& acr::bltin_Alloc() {
    acr::FBltin* row = bltin_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.bltin  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.bltin.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FBltin* acr::bltin_AllocMaybe() {
    acr::FBltin *row = (acr::FBltin*)bltin_AllocMem();
    if (row) {
        new (row) acr::FBltin; // call constructor
    }
    return row;
}

// --- acr.FDb.bltin.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FBltin* acr::bltin_InsertMaybe(const amcdb::Bltin &value) {
    acr::FBltin *row = &bltin_Alloc(); // if out of memory, process dies. if input error, return NULL.
    bltin_CopyIn(*row,const_cast<amcdb::Bltin&>(value));
    bool ok = bltin_XrefMaybe(*row); // this may return false
    if (!ok) {
        bltin_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.bltin.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::bltin_AllocMem() {
    u64 new_nelems     = _db.bltin_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FBltin*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.bltin_lary[bsr];
        if (!lev) {
            lev=(acr::FBltin*)algo_lib::malloc_AllocMem(sizeof(acr::FBltin) * (u64(1)<<bsr));
            _db.bltin_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.bltin_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.bltin.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::bltin_RemoveLast() {
    u64 n = _db.bltin_n;
    if (n > 0) {
        n -= 1;
        bltin_qFind(u64(n)).~FBltin();
        _db.bltin_n = i32(n);
    }
}

// --- acr.FDb.bltin.InputMaybe
static bool acr::bltin_InputMaybe(amcdb::Bltin &elem) {
    bool retval = true;
    retval = bltin_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.bltin.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::bltin_XrefMaybe(acr::FBltin &row) {
    bool retval = true;
    (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert bltin into index c_bltin
    if (true) { // user-defined insert condition
        bool success = c_bltin_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FCtype.c_bltin"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.bh_ctype_topo.Dealloc
// Remove all elements from heap and free memory used by the array.
void acr::bh_ctype_topo_Dealloc() {
    bh_ctype_topo_RemoveAll();
    algo_lib::malloc_FreeMem(_db.bh_ctype_topo_elems, sizeof(acr::FCtype*)*_db.bh_ctype_topo_max);
    _db.bh_ctype_topo_max   = 0;
    _db.bh_ctype_topo_elems = NULL;
}

// --- acr.FDb.bh_ctype_topo.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int acr::bh_ctype_topo_Downheap(acr::FCtype& row, int idx) {
    acr::FCtype* *elems = _db.bh_ctype_topo_elems;
    int n = _db.bh_ctype_topo_n;
    int child = idx*2+1;
    while (child < n) {
        acr::FCtype* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            acr::FCtype* q = elems[rchild]; // right child
            if (bh_ctype_topo_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_ctype_topo_ElemLt(*p,row)) {
            break;
        }
        p->bh_ctype_topo_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- acr.FDb.bh_ctype_topo.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void acr::bh_ctype_topo_Insert(acr::FCtype& row) {
    if (LIKELY(row.bh_ctype_topo_idx == -1)) {
        bh_ctype_topo_Reserve(1);
        int n = _db.bh_ctype_topo_n;
        _db.bh_ctype_topo_n = n + 1;
        int new_idx = bh_ctype_topo_Upheap(row, n);
        row.bh_ctype_topo_idx = new_idx;
        _db.bh_ctype_topo_elems[new_idx] = &row;
    }
}

// --- acr.FDb.bh_ctype_topo.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 acr::bh_ctype_topo_Reheap(acr::FCtype& row) {
    int old_idx = row.bh_ctype_topo_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_ctype_topo_Reserve(1);
        old_idx = _db.bh_ctype_topo_n++;
    }
    int new_idx = bh_ctype_topo_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_ctype_topo_Downheap(row, old_idx);
    }
    row.bh_ctype_topo_idx = new_idx;
    _db.bh_ctype_topo_elems[new_idx] = &row;
    return new_idx;
}

// --- acr.FDb.bh_ctype_topo.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 acr::bh_ctype_topo_ReheapFirst() {
    acr::FCtype &row = *_db.bh_ctype_topo_elems[0];
    i32 new_idx = bh_ctype_topo_Downheap(row, 0);
    row.bh_ctype_topo_idx = new_idx;
    _db.bh_ctype_topo_elems[new_idx] = &row;
    return new_idx;
}

// --- acr.FDb.bh_ctype_topo.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::bh_ctype_topo_Remove(acr::FCtype& row) {
    if (bh_ctype_topo_InBheapQ(row)) {
        int old_idx = row.bh_ctype_topo_idx;
        if (_db.bh_ctype_topo_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_ctype_topo_idx = -1;           // mark not in heap
            i32 n = _db.bh_ctype_topo_n - 1; // index of last element in heap
            _db.bh_ctype_topo_n = n;         // decrease count
            if (old_idx != n) {
                acr::FCtype *elem = _db.bh_ctype_topo_elems[n];
                int new_idx = bh_ctype_topo_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_ctype_topo_Downheap(*elem, old_idx);
                }
                elem->bh_ctype_topo_idx = new_idx;
                _db.bh_ctype_topo_elems[new_idx] = elem;
            }
        }
    }
}

// --- acr.FDb.bh_ctype_topo.RemoveAll
// Remove all elements from binary heap
void acr::bh_ctype_topo_RemoveAll() {
    int n = _db.bh_ctype_topo_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_ctype_topo_elems[i]->bh_ctype_topo_idx = -1; // mark not-in-heap
    }
    _db.bh_ctype_topo_n = 0;
}

// --- acr.FDb.bh_ctype_topo.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
acr::FCtype* acr::bh_ctype_topo_RemoveFirst() {
    acr::FCtype *row = NULL;
    if (_db.bh_ctype_topo_n > 0) {
        row = _db.bh_ctype_topo_elems[0];
        row->bh_ctype_topo_idx = -1;           // mark not in heap
        i32 n = _db.bh_ctype_topo_n - 1; // index of last element in heap
        _db.bh_ctype_topo_n = n;         // decrease count
        if (n) {
            acr::FCtype &elem = *_db.bh_ctype_topo_elems[n];
            int new_idx = bh_ctype_topo_Downheap(elem, 0);
            elem.bh_ctype_topo_idx = new_idx;
            _db.bh_ctype_topo_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- acr.FDb.bh_ctype_topo.Reserve
// Reserve space in index for N more elements
void acr::bh_ctype_topo_Reserve(int n) {
    i32 old_max = _db.bh_ctype_topo_max;
    if (UNLIKELY(_db.bh_ctype_topo_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FCtype*);
        u32 new_size = new_max * sizeof(acr::FCtype*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.bh_ctype_topo_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FDb.bh_ctype_topo");
        }
        _db.bh_ctype_topo_elems = (acr::FCtype**)new_mem;
        _db.bh_ctype_topo_max = new_max;
    }
}

// --- acr.FDb.bh_ctype_topo.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int acr::bh_ctype_topo_Upheap(acr::FCtype& row, int idx) {
    acr::FCtype* *elems = _db.bh_ctype_topo_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        acr::FCtype* p = elems[j];
        if (!bh_ctype_topo_ElemLt(row, *p)) {
            break;
        }
        p->bh_ctype_topo_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- acr.FDb.bh_ctype_topo.ElemLt
inline static bool acr::bh_ctype_topo_ElemLt(acr::FCtype &a, acr::FCtype &b) {
    (void)_db;
    return topokey_Lt(a, b);
}

// --- acr.FDb.cppfunc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCppfunc& acr::cppfunc_Alloc() {
    acr::FCppfunc* row = cppfunc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.cppfunc  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.cppfunc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FCppfunc* acr::cppfunc_AllocMaybe() {
    acr::FCppfunc *row = (acr::FCppfunc*)cppfunc_AllocMem();
    if (row) {
        new (row) acr::FCppfunc; // call constructor
    }
    return row;
}

// --- acr.FDb.cppfunc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCppfunc* acr::cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) {
    acr::FCppfunc *row = &cppfunc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cppfunc_CopyIn(*row,const_cast<dmmeta::Cppfunc&>(value));
    bool ok = cppfunc_XrefMaybe(*row); // this may return false
    if (!ok) {
        cppfunc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.cppfunc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::cppfunc_AllocMem() {
    u64 new_nelems     = _db.cppfunc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FCppfunc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cppfunc_lary[bsr];
        if (!lev) {
            lev=(acr::FCppfunc*)algo_lib::malloc_AllocMem(sizeof(acr::FCppfunc) * (u64(1)<<bsr));
            _db.cppfunc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cppfunc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.cppfunc.RemoveAll
// Remove all elements from Lary
void acr::cppfunc_RemoveAll() {
    for (u64 n = _db.cppfunc_n; n>0; ) {
        n--;
        cppfunc_qFind(u64(n)).~FCppfunc(); // destroy last element
        _db.cppfunc_n = i32(n);
    }
}

// --- acr.FDb.cppfunc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::cppfunc_RemoveLast() {
    u64 n = _db.cppfunc_n;
    if (n > 0) {
        n -= 1;
        cppfunc_qFind(u64(n)).~FCppfunc();
        _db.cppfunc_n = i32(n);
    }
}

// --- acr.FDb.cppfunc.InputMaybe
static bool acr::cppfunc_InputMaybe(dmmeta::Cppfunc &elem) {
    bool retval = true;
    retval = cppfunc_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.cppfunc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::cppfunc_XrefMaybe(acr::FCppfunc &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FDb.ssimreq.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimreq& acr::ssimreq_Alloc() {
    acr::FSsimreq* row = ssimreq_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr.out_of_mem  field:acr.FDb.ssimreq  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr.FDb.ssimreq.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimreq* acr::ssimreq_AllocMaybe() {
    acr::FSsimreq *row = (acr::FSsimreq*)ssimreq_AllocMem();
    if (row) {
        new (row) acr::FSsimreq; // call constructor
    }
    return row;
}

// --- acr.FDb.ssimreq.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimreq* acr::ssimreq_InsertMaybe(const dmmeta::Ssimreq &value) {
    acr::FSsimreq *row = &ssimreq_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimreq_CopyIn(*row,const_cast<dmmeta::Ssimreq&>(value));
    bool ok = ssimreq_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimreq_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr.FDb.ssimreq.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr::ssimreq_AllocMem() {
    u64 new_nelems     = _db.ssimreq_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr::FSsimreq*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimreq_lary[bsr];
        if (!lev) {
            lev=(acr::FSsimreq*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimreq) * (u64(1)<<bsr));
            _db.ssimreq_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimreq_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr.FDb.ssimreq.RemoveAll
// Remove all elements from Lary
void acr::ssimreq_RemoveAll() {
    for (u64 n = _db.ssimreq_n; n>0; ) {
        n--;
        ssimreq_qFind(u64(n)).~FSsimreq(); // destroy last element
        _db.ssimreq_n = i32(n);
    }
}

// --- acr.FDb.ssimreq.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::ssimreq_RemoveLast() {
    u64 n = _db.ssimreq_n;
    if (n > 0) {
        n -= 1;
        ssimreq_qFind(u64(n)).~FSsimreq();
        _db.ssimreq_n = i32(n);
    }
}

// --- acr.FDb.ssimreq.InputMaybe
static bool acr::ssimreq_InputMaybe(dmmeta::Ssimreq &elem) {
    bool retval = true;
    retval = ssimreq_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr.FDb.ssimreq.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::ssimreq_XrefMaybe(acr::FSsimreq &row) {
    bool retval = true;
    (void)row;
    acr::FSsimfile* p_ssimfile = acr::ind_ssimfile_Find(row.ssimfile);
    if (UNLIKELY(!p_ssimfile)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_ssimfile" << Keyval("key", row.ssimfile);
        return false;
    }
    // ssimreq: save pointer to ssimfile
    if (true) { // user-defined insert condition
        row.p_ssimfile = p_ssimfile;
    }
    acr::FField* p_field = acr::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "acr.bad_xref  index:acr.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // ssimreq: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert ssimreq into index c_ssimreq
    if (true) { // user-defined insert condition
        bool success = c_ssimreq_InsertMaybe(*p_ssimfile, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr.duplicate_key  xref:acr.FSsimfile.c_ssimreq"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr acr::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- acr.FDb.trace.N
// Function return 1
inline static i32 acr::trace_N() {
    return 1;
}

// --- acr.FDb.bh_pline_curs.Add
static void acr::_db_bh_pline_curs_Add(_db_bh_pline_curs &curs, acr::FPline& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    acr::FPline* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        acr::FPline* p = elems[j];
        if (!bh_pline_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- acr.FDb.bh_pline_curs.Reserve
void acr::_db_bh_pline_curs_Reserve(_db_bh_pline_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_pline_N();
        curs.temp_elems   = (acr::FPline**)algo_lib::malloc_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("acr.cursor_out_of_memory  func:acr.FDb.bh_pline_curs.Reserve");
        }
        curs.temp_max       = bh_pline_N();
    }
}

// --- acr.FDb.bh_pline_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void acr::_db_bh_pline_curs_Reset(_db_bh_pline_curs &curs, acr::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_pline_curs_Reserve(curs, bh_pline_N());
    curs.temp_n = 0;
    if (parent.bh_pline_n > 0) {
        acr::FPline &first = *parent.bh_pline_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- acr.FDb.bh_pline_curs.Next
// Advance cursor.
void acr::_db_bh_pline_curs_Next(_db_bh_pline_curs &curs) {
    acr::FPline* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        acr::FPline* dead = elems[0];
        int i       = 0;
        acr::FPline* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            acr::FPline* choose = last;
            int l         = i*2+1;
            if (l<n) {
                acr::FPline* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                acr::FPline* er = elems[r];
                if (bh_pline_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_pline_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_pline_idx;
        i = (index*2+1);
        if (i < bh_pline_N()) {
            acr::FPline &elem = *curs.parent->bh_pline_elems[i];
            _db_bh_pline_curs_Add(curs, elem);
        }
        if (i+1 < bh_pline_N()) {
            acr::FPline &elem = *curs.parent->bh_pline_elems[i + 1];
            _db_bh_pline_curs_Add(curs, elem);
        }
    }
}

// --- acr.FDb.bh_ctype_topo_curs.Add
static void acr::_db_bh_ctype_topo_curs_Add(_db_bh_ctype_topo_curs &curs, acr::FCtype& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    acr::FCtype* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        acr::FCtype* p = elems[j];
        if (!bh_ctype_topo_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- acr.FDb.bh_ctype_topo_curs.Reserve
void acr::_db_bh_ctype_topo_curs_Reserve(_db_bh_ctype_topo_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_ctype_topo_N();
        curs.temp_elems   = (acr::FCtype**)algo_lib::malloc_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("acr.cursor_out_of_memory  func:acr.FDb.bh_ctype_topo_curs.Reserve");
        }
        curs.temp_max       = bh_ctype_topo_N();
    }
}

// --- acr.FDb.bh_ctype_topo_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void acr::_db_bh_ctype_topo_curs_Reset(_db_bh_ctype_topo_curs &curs, acr::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_ctype_topo_curs_Reserve(curs, bh_ctype_topo_N());
    curs.temp_n = 0;
    if (parent.bh_ctype_topo_n > 0) {
        acr::FCtype &first = *parent.bh_ctype_topo_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- acr.FDb.bh_ctype_topo_curs.Next
// Advance cursor.
void acr::_db_bh_ctype_topo_curs_Next(_db_bh_ctype_topo_curs &curs) {
    acr::FCtype* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        acr::FCtype* dead = elems[0];
        int i       = 0;
        acr::FCtype* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            acr::FCtype* choose = last;
            int l         = i*2+1;
            if (l<n) {
                acr::FCtype* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                acr::FCtype* er = elems[r];
                if (bh_ctype_topo_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_ctype_topo_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_ctype_topo_idx;
        i = (index*2+1);
        if (i < bh_ctype_topo_N()) {
            acr::FCtype &elem = *curs.parent->bh_ctype_topo_elems[i];
            _db_bh_ctype_topo_curs_Add(curs, elem);
        }
        if (i+1 < bh_ctype_topo_N()) {
            acr::FCtype &elem = *curs.parent->bh_ctype_topo_elems[i + 1];
            _db_bh_ctype_topo_curs_Add(curs, elem);
        }
    }
}

// --- acr.FDb..Init
// Set all fields to initial values.
void acr::FDb_Init() {
    // pline: initialize Tpool
    _db.pline_free      = NULL;
    _db.pline_blocksize = algo::BumpToPow2(64 * sizeof(acr::FPline)); // allocate 64-127 elements at a time
    // pdep: initialize Tpool
    _db.pdep_free      = NULL;
    _db.pdep_blocksize = algo::BumpToPow2(64 * sizeof(acr::FPdep)); // allocate 64-127 elements at a time
    _db.zd_pline_head = NULL; // (acr.FDb.zd_pline)
    _db.zd_pline_tail = NULL; // (acr.FDb.zd_pline)
    _db.zd_pdep_head = NULL; // (acr.FDb.zd_pdep)
    _db.zd_pdep_tail = NULL; // (acr.FDb.zd_pdep)
    // initialize LAry ctype (acr.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    acr::FCtype* ctype_first = (acr::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // err: initialize Tpool
    _db.err_free      = NULL;
    _db.err_blocksize = algo::BumpToPow2(64 * sizeof(acr::FErr)); // allocate 64-127 elements at a time
    // initialize LAry anonfld (acr.FDb.anonfld)
    _db.anonfld_n = 0;
    memset(_db.anonfld_lary, 0, sizeof(_db.anonfld_lary)); // zero out all level pointers
    acr::FAnonfld* anonfld_first = (acr::FAnonfld*)algo_lib::malloc_AllocMem(sizeof(acr::FAnonfld) * (u64(1)<<4));
    if (!anonfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.anonfld_lary[i]  = anonfld_first;
        anonfld_first    += 1ULL<<i;
    }
    // initialize LAry cdflt (acr.FDb.cdflt)
    _db.cdflt_n = 0;
    memset(_db.cdflt_lary, 0, sizeof(_db.cdflt_lary)); // zero out all level pointers
    acr::FCdflt* cdflt_first = (acr::FCdflt*)algo_lib::malloc_AllocMem(sizeof(acr::FCdflt) * (u64(1)<<4));
    if (!cdflt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cdflt_lary[i]  = cdflt_first;
        cdflt_first    += 1ULL<<i;
    }
    // rec: initialize Tpool
    _db.rec_free      = NULL;
    _db.rec_blocksize = algo::BumpToPow2(64 * sizeof(acr::FRec)); // allocate 64-127 elements at a time
    // uniqueattr: initialize Tpool
    _db.uniqueattr_free      = NULL;
    _db.uniqueattr_blocksize = algo::BumpToPow2(64 * sizeof(acr::FUniqueattr)); // allocate 64-127 elements at a time
    // query: initialize Tpool
    _db.query_free      = NULL;
    _db.query_blocksize = algo::BumpToPow2(64 * sizeof(acr::FQuery)); // allocate 64-127 elements at a time
    // initialize LAry field (acr.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    acr::FField* field_first = (acr::FField*)algo_lib::malloc_AllocMem(sizeof(acr::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize LAry file (acr.FDb.file)
    _db.file_n = 0;
    memset(_db.file_lary, 0, sizeof(_db.file_lary)); // zero out all level pointers
    acr::FFile* file_first = (acr::FFile*)algo_lib::malloc_AllocMem(sizeof(acr::FFile) * (u64(1)<<4));
    if (!file_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.file_lary[i]  = file_first;
        file_first    += 1ULL<<i;
    }
    _db.err_seq = u32(0);
    _db.check_failed = bool(false);
    // initialize hash table for acr::FCtype;
    _db.ind_ctype_n             	= 0; // (acr.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (acr.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (acr::FCtype**)algo_lib::malloc_AllocMem(sizeof(acr::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (acr.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(acr::FCtype*)*_db.ind_ctype_buckets_n); // (acr.FDb.ind_ctype)
    // initialize hash table for acr::FField;
    _db.ind_field_n             	= 0; // (acr.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (acr.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (acr::FField**)algo_lib::malloc_AllocMem(sizeof(acr::FField*)*_db.ind_field_buckets_n); // initial buckets (acr.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(acr::FField*)*_db.ind_field_buckets_n); // (acr.FDb.ind_field)
    // initialize hash table for acr::FFile;
    _db.ind_file_n             	= 0; // (acr.FDb.ind_file)
    _db.ind_file_buckets_n     	= 4; // (acr.FDb.ind_file)
    _db.ind_file_buckets_elems 	= (acr::FFile**)algo_lib::malloc_AllocMem(sizeof(acr::FFile*)*_db.ind_file_buckets_n); // initial buckets (acr.FDb.ind_file)
    if (!_db.ind_file_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_file)
    }
    memset(_db.ind_file_buckets_elems, 0, sizeof(acr::FFile*)*_db.ind_file_buckets_n); // (acr.FDb.ind_file)
    _db.zd_all_selrec_head = NULL; // (acr.FDb.zd_all_selrec)
    _db.zd_all_selrec_n = 0; // (acr.FDb.zd_all_selrec)
    _db.zd_all_selrec_tail = NULL; // (acr.FDb.zd_all_selrec)
    _db.zd_all_err_head = NULL; // (acr.FDb.zd_all_err)
    _db.zd_all_err_n = 0; // (acr.FDb.zd_all_err)
    _db.zd_all_err_tail = NULL; // (acr.FDb.zd_all_err)
    _db.zd_sel_ctype_head = NULL; // (acr.FDb.zd_sel_ctype)
    _db.zd_sel_ctype_tail = NULL; // (acr.FDb.zd_sel_ctype)
    _db.bh_pline_max   	= 0; // (acr.FDb.bh_pline)
    _db.bh_pline_n     	= 0; // (acr.FDb.bh_pline)
    _db.bh_pline_elems 	= NULL; // (acr.FDb.bh_pline)
    // initialize LAry substr (acr.FDb.substr)
    _db.substr_n = 0;
    memset(_db.substr_lary, 0, sizeof(_db.substr_lary)); // zero out all level pointers
    acr::FSubstr* substr_first = (acr::FSubstr*)algo_lib::malloc_AllocMem(sizeof(acr::FSubstr) * (u64(1)<<4));
    if (!substr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.substr_lary[i]  = substr_first;
        substr_first    += 1ULL<<i;
    }
    // initialize LAry ssimfile (acr.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    acr::FSsimfile* ssimfile_first = (acr::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize LAry tempkey (acr.FDb.tempkey)
    _db.tempkey_n = 0;
    memset(_db.tempkey_lary, 0, sizeof(_db.tempkey_lary)); // zero out all level pointers
    acr::FTempkey* tempkey_first = (acr::FTempkey*)algo_lib::malloc_AllocMem(sizeof(acr::FTempkey) * (u64(1)<<4));
    if (!tempkey_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tempkey_lary[i]  = tempkey_first;
        tempkey_first    += 1ULL<<i;
    }
    // initialize hash table for acr::FTempkey;
    _db.ind_tempkey_n             	= 0; // (acr.FDb.ind_tempkey)
    _db.ind_tempkey_buckets_n     	= 4; // (acr.FDb.ind_tempkey)
    _db.ind_tempkey_buckets_elems 	= (acr::FTempkey**)algo_lib::malloc_AllocMem(sizeof(acr::FTempkey*)*_db.ind_tempkey_buckets_n); // initial buckets (acr.FDb.ind_tempkey)
    if (!_db.ind_tempkey_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_tempkey)
    }
    memset(_db.ind_tempkey_buckets_elems, 0, sizeof(acr::FTempkey*)*_db.ind_tempkey_buckets_n); // (acr.FDb.ind_tempkey)
    // initialize hash table for acr::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (acr.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (acr.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (acr::FSsimfile**)algo_lib::malloc_AllocMem(sizeof(acr::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (acr.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(acr::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (acr.FDb.ind_ssimfile)
    _db.zs_query_head = NULL; // (acr.FDb.zs_query)
    _db.zs_query_tail = NULL; // (acr.FDb.zs_query)
    // initialize LAry ssimsort (acr.FDb.ssimsort)
    _db.ssimsort_n = 0;
    memset(_db.ssimsort_lary, 0, sizeof(_db.ssimsort_lary)); // zero out all level pointers
    acr::FSsimsort* ssimsort_first = (acr::FSsimsort*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimsort) * (u64(1)<<4));
    if (!ssimsort_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimsort_lary[i]  = ssimsort_first;
        ssimsort_first    += 1ULL<<i;
    }
    // initialize hash table for acr::FSsimsort;
    _db.ind_ssimsort_n             	= 0; // (acr.FDb.ind_ssimsort)
    _db.ind_ssimsort_buckets_n     	= 4; // (acr.FDb.ind_ssimsort)
    _db.ind_ssimsort_buckets_elems 	= (acr::FSsimsort**)algo_lib::malloc_AllocMem(sizeof(acr::FSsimsort*)*_db.ind_ssimsort_buckets_n); // initial buckets (acr.FDb.ind_ssimsort)
    if (!_db.ind_ssimsort_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_ssimsort)
    }
    memset(_db.ind_ssimsort_buckets_elems, 0, sizeof(acr::FSsimsort*)*_db.ind_ssimsort_buckets_n); // (acr.FDb.ind_ssimsort)
    _db.n_file_written = u32(0);
    // initialize LAry smallstr (acr.FDb.smallstr)
    _db.smallstr_n = 0;
    memset(_db.smallstr_lary, 0, sizeof(_db.smallstr_lary)); // zero out all level pointers
    acr::FSmallstr* smallstr_first = (acr::FSmallstr*)algo_lib::malloc_AllocMem(sizeof(acr::FSmallstr) * (u64(1)<<4));
    if (!smallstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.smallstr_lary[i]  = smallstr_first;
        smallstr_first    += 1ULL<<i;
    }
    // initialize LAry funique (acr.FDb.funique)
    _db.funique_n = 0;
    memset(_db.funique_lary, 0, sizeof(_db.funique_lary)); // zero out all level pointers
    acr::FFunique* funique_first = (acr::FFunique*)algo_lib::malloc_AllocMem(sizeof(acr::FFunique) * (u64(1)<<4));
    if (!funique_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.funique_lary[i]  = funique_first;
        funique_first    += 1ULL<<i;
    }
    // initialize hash table for acr::FUniqueattr;
    _db.ind_uniqueattr_n             	= 0; // (acr.FDb.ind_uniqueattr)
    _db.ind_uniqueattr_buckets_n     	= 4; // (acr.FDb.ind_uniqueattr)
    _db.ind_uniqueattr_buckets_elems 	= (acr::FUniqueattr**)algo_lib::malloc_AllocMem(sizeof(acr::FUniqueattr*)*_db.ind_uniqueattr_buckets_n); // initial buckets (acr.FDb.ind_uniqueattr)
    if (!_db.ind_uniqueattr_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FDb.ind_uniqueattr)
    }
    memset(_db.ind_uniqueattr_buckets_elems, 0, sizeof(acr::FUniqueattr*)*_db.ind_uniqueattr_buckets_n); // (acr.FDb.ind_uniqueattr)
    // initialize LAry bltin (acr.FDb.bltin)
    _db.bltin_n = 0;
    memset(_db.bltin_lary, 0, sizeof(_db.bltin_lary)); // zero out all level pointers
    acr::FBltin* bltin_first = (acr::FBltin*)algo_lib::malloc_AllocMem(sizeof(acr::FBltin) * (u64(1)<<4));
    if (!bltin_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.bltin_lary[i]  = bltin_first;
        bltin_first    += 1ULL<<i;
    }
    _db.ctype_rank_computed = bool(false);
    _db.file_input = bool(false);
    _db.bh_ctype_topo_max   	= 0; // (acr.FDb.bh_ctype_topo)
    _db.bh_ctype_topo_n     	= 0; // (acr.FDb.bh_ctype_topo)
    _db.bh_ctype_topo_elems 	= NULL; // (acr.FDb.bh_ctype_topo)
    // initialize LAry cppfunc (acr.FDb.cppfunc)
    _db.cppfunc_n = 0;
    memset(_db.cppfunc_lary, 0, sizeof(_db.cppfunc_lary)); // zero out all level pointers
    acr::FCppfunc* cppfunc_first = (acr::FCppfunc*)algo_lib::malloc_AllocMem(sizeof(acr::FCppfunc) * (u64(1)<<4));
    if (!cppfunc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cppfunc_lary[i]  = cppfunc_first;
        cppfunc_first    += 1ULL<<i;
    }
    // initialize LAry ssimreq (acr.FDb.ssimreq)
    _db.ssimreq_n = 0;
    memset(_db.ssimreq_lary, 0, sizeof(_db.ssimreq_lary)); // zero out all level pointers
    acr::FSsimreq* ssimreq_first = (acr::FSsimreq*)algo_lib::malloc_AllocMem(sizeof(acr::FSsimreq) * (u64(1)<<4));
    if (!ssimreq_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimreq_lary[i]  = ssimreq_first;
        ssimreq_first    += 1ULL<<i;
    }

    acr::InitReflection();
}

// --- acr.FDb..Uninit
void acr::FDb_Uninit() {
    acr::FDb &row = _db; (void)row;
    zd_pdep_Cascdel(); // dmmeta.cascdel:acr.FDb.zd_pdep
    zd_pline_Cascdel(); // dmmeta.cascdel:acr.FDb.zd_pline

    // acr.FDb.ssimreq.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.cppfunc.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.bh_ctype_topo.Uninit (Bheap)  //
    // skip destruction in global scope

    // acr.FDb.bltin.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.ind_uniqueattr.Uninit (Thash)  //
    // skip destruction of ind_uniqueattr in global scope

    // acr.FDb.funique.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.smallstr.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.ind_ssimsort.Uninit (Thash)  //
    // skip destruction of ind_ssimsort in global scope

    // acr.FDb.ssimsort.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // acr.FDb.ind_tempkey.Uninit (Thash)  //
    // skip destruction of ind_tempkey in global scope

    // acr.FDb.tempkey.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.substr.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.bh_pline.Uninit (Bheap)  //List of records to print
    // skip destruction in global scope

    // acr.FDb.ind_file.Uninit (Thash)  //Index of files by primary key
    // skip destruction of ind_file in global scope

    // acr.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // acr.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // acr.FDb.file.Uninit (Lary)  //List of all loaded files
    // skip destruction in global scope

    // acr.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.cdflt.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.anonfld.Uninit (Lary)  //
    // skip destruction in global scope

    // acr.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- acr.FErr.base.CopyOut
// Copy fields out of row
void acr::err_CopyOut(acr::FErr &row, acr::Err &out) {
    // ctype: unknown field type (Ptr), skipped
    out.id = row.id;
    out.text = row.text;
    // rec: unknown field type (Ptr), skipped
    // fld: unknown field type (Ptr), skipped
}

// --- acr.FErr.base.CopyIn
// Copy fields in to row
void acr::err_CopyIn(acr::FErr &row, acr::Err &in) {
    // ctype: unknown field reftype (Ptr), skipped
    row.id = in.id;
    row.text = in.text;
    // rec: unknown field reftype (Ptr), skipped
    // fld: unknown field reftype (Ptr), skipped
}

// --- acr.FErr..Uninit
void acr::FErr_Uninit(acr::FErr& err) {
    acr::FErr &row = err; (void)row;
    zd_all_err_Remove(row); // remove err from index zd_all_err
}

// --- acr.FField.base.CopyOut
// Copy fields out of row
void acr::field_CopyOut(acr::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- acr.FField.base.CopyIn
// Copy fields in to row
void acr::field_CopyIn(acr::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- acr.FField.ctype.Get
algo::Smallstr50 acr::ctype_Get(acr::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- acr.FField.ns.Get
algo::Smallstr16 acr::ns_Get(acr::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- acr.FField.name.Get
algo::Smallstr50 acr::name_Get(acr::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- acr.FField..Init
// Set all fields to initial values.
void acr::FField_Init(acr::FField& field) {
    field.reftype = algo::strptr("Val");
    field.p_ctype = NULL;
    field.p_arg = NULL;
    field.c_substr = NULL;
    field.max_attr_len = u32(0);
    field.col_width = u32(0);
    field.isfldfunc = bool(false);
    field.anon = bool(false);
    field.unique = bool(false);
    field.ctype_c_field_in_ary = bool(false);
    field.zd_arg_next = (acr::FField*)-1; // (acr.FCtype.zd_arg) not-in-list
    field.zd_arg_prev = NULL; // (acr.FCtype.zd_arg)
    field.ind_field_next = (acr::FField*)-1; // (acr.FDb.ind_field) not-in-hash
}

// --- acr.FField..Uninit
void acr::FField_Uninit(acr::FField& field) {
    acr::FField &row = field; (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
    ind_field_Remove(row); // remove field from index ind_field
    acr::FCtype* p_arg = acr::ind_ctype_Find(row.arg);
    if (p_arg)  {
        zd_arg_Remove(*p_arg, row);// remove field from index zd_arg
    }
}

// --- acr.FFile.zd_frec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_frec_Insert(acr::FFile& file, acr::FRec& row) {
    if (!zd_frec_InLlistQ(row)) {
        acr::FRec* old_tail = file.zd_frec_tail;
        row.zd_frec_next = NULL;
        row.zd_frec_prev = old_tail;
        file.zd_frec_tail = &row;
        acr::FRec **new_row_a = &old_tail->zd_frec_next;
        acr::FRec **new_row_b = &file.zd_frec_head;
        acr::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FFile.zd_frec.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_frec_Remove(acr::FFile& file, acr::FRec& row) {
    if (zd_frec_InLlistQ(row)) {
        acr::FRec* old_head       = file.zd_frec_head;
        (void)old_head; // in case it's not used
        acr::FRec* prev = row.zd_frec_prev;
        acr::FRec* next = row.zd_frec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FRec **new_next_a = &prev->zd_frec_next;
        acr::FRec **new_next_b = &file.zd_frec_head;
        acr::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FRec **new_prev_a = &next->zd_frec_prev;
        acr::FRec **new_prev_b = &file.zd_frec_tail;
        acr::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_frec_next=(acr::FRec*)-1; // not-in-list
    }
}

// --- acr.FFile.zd_frec.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_frec_RemoveAll(acr::FFile& file) {
    acr::FRec* row = file.zd_frec_head;
    file.zd_frec_head = NULL;
    file.zd_frec_tail = NULL;
    while (row) {
        acr::FRec* row_next = row->zd_frec_next;
        row->zd_frec_next  = (acr::FRec*)-1;
        row->zd_frec_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FFile.zd_frec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec* acr::zd_frec_RemoveFirst(acr::FFile& file) {
    acr::FRec *row = NULL;
    row = file.zd_frec_head;
    if (row) {
        acr::FRec *next = row->zd_frec_next;
        file.zd_frec_head = next;
        acr::FRec **new_end_a = &next->zd_frec_prev;
        acr::FRec **new_end_b = &file.zd_frec_tail;
        acr::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_frec_next = (acr::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FFile..Uninit
void acr::FFile_Uninit(acr::FFile& file) {
    acr::FFile &row = file; (void)row;
    ind_file_Remove(row); // remove file from index ind_file
}

// --- acr.FFunique.base.CopyOut
// Copy fields out of row
void acr::funique_CopyOut(acr::FFunique &row, dmmeta::Funique &out) {
    out.field = row.field;
    // comment: field stripped (see dmmeta.fbase:acr.FFunique.base)
}

// --- acr.FFunique.base.CopyIn
// Copy fields in to row
void acr::funique_CopyIn(acr::FFunique &row, dmmeta::Funique &in) {
    row.field = in.field;
    // comment: field stripped (see dmmeta.fbase:acr.FFunique.base)
}

// --- acr.FPdep..Uninit
void acr::FPdep_Uninit(acr::FPdep& pdep) {
    acr::FPdep &row = pdep; (void)row;
    zd_pdep_Remove(row); // remove pdep from index zd_pdep
    acr::FPline* p_p_parent = row.p_parent;
    if (p_p_parent)  {
        zd_child_Remove(*p_p_parent, row);// remove pdep from index zd_child
    }
}

// --- acr.PlineKey..Cmp
i32 acr::PlineKey_Cmp(acr::PlineKey & lhs, acr::PlineKey & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.alldep, rhs.alldep);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.negdepth, rhs.negdepth);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.ctype_rank, rhs.ctype_rank);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.PlineKey..Eq
bool acr::PlineKey_Eq(const acr::PlineKey & lhs,const acr::PlineKey & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.alldep, rhs.alldep);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.negdepth, rhs.negdepth);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.ctype_rank, rhs.ctype_rank);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.PlineKey..Print
// print string representation of acr::PlineKey to string LHS, no header -- cprint:acr.PlineKey.String
void acr::PlineKey_Print(acr::PlineKey & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.PlineKey";

    i32_Print(row.alldep, temp);
    PrintAttrSpaceReset(str,"alldep", temp);

    i32_Print(row.negdepth, temp);
    PrintAttrSpaceReset(str,"negdepth", temp);

    i32_Print(row.ctype_rank, temp);
    PrintAttrSpaceReset(str,"ctype_rank", temp);

    i32_Print(row.rowid, temp);
    PrintAttrSpaceReset(str,"rowid", temp);
}

// --- acr.FPline.zd_child.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void acr::zd_child_Insert(acr::FPline& pline, acr::FPdep& row) {
    if (!zd_child_InLlistQ(row)) {
        acr::FPdep* old_tail = pline.zd_child_tail;
        row.zd_child_next = NULL;
        row.zd_child_prev = old_tail;
        pline.zd_child_tail = &row;
        acr::FPdep **new_row_a = &old_tail->zd_child_next;
        acr::FPdep **new_row_b = &pline.zd_child_head;
        acr::FPdep **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- acr.FPline.zd_child.Remove
// Remove element from index. If element is not in index, do nothing.
void acr::zd_child_Remove(acr::FPline& pline, acr::FPdep& row) {
    if (zd_child_InLlistQ(row)) {
        acr::FPdep* old_head       = pline.zd_child_head;
        (void)old_head; // in case it's not used
        acr::FPdep* prev = row.zd_child_prev;
        acr::FPdep* next = row.zd_child_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        acr::FPdep **new_next_a = &prev->zd_child_next;
        acr::FPdep **new_next_b = &pline.zd_child_head;
        acr::FPdep **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        acr::FPdep **new_prev_a = &next->zd_child_prev;
        acr::FPdep **new_prev_b = &pline.zd_child_tail;
        acr::FPdep **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_child_next=(acr::FPdep*)-1; // not-in-list
    }
}

// --- acr.FPline.zd_child.RemoveAll
// Empty the index. (The rows are not deleted)
void acr::zd_child_RemoveAll(acr::FPline& pline) {
    acr::FPdep* row = pline.zd_child_head;
    pline.zd_child_head = NULL;
    pline.zd_child_tail = NULL;
    while (row) {
        acr::FPdep* row_next = row->zd_child_next;
        row->zd_child_next  = (acr::FPdep*)-1;
        row->zd_child_prev  = NULL;
        row = row_next;
    }
}

// --- acr.FPline.zd_child.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPdep* acr::zd_child_RemoveFirst(acr::FPline& pline) {
    acr::FPdep *row = NULL;
    row = pline.zd_child_head;
    if (row) {
        acr::FPdep *next = row->zd_child_next;
        pline.zd_child_head = next;
        acr::FPdep **new_end_a = &next->zd_child_prev;
        acr::FPdep **new_end_b = &pline.zd_child_tail;
        acr::FPdep **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_child_next = (acr::FPdep*)-1; // mark as not-in-list
    }
    return row;
}

// --- acr.FPline..Uninit
void acr::FPline_Uninit(acr::FPline& pline) {
    acr::FPline &row = pline; (void)row;
    zd_pline_Remove(row); // remove pline from index zd_pline
    acr::FRec* p_p_rec = row.p_rec;
    if (p_p_rec)  {
        c_pline_Remove(*p_p_rec, row);// remove pline from index c_pline
    }
    bh_pline_Remove(row); // remove pline from index bh_pline
}

// --- acr.FPrint.ind_printattr.Cascdel
// Delete all rows reachable through the hash index
void acr::ind_printattr_Cascdel(acr::FPrint& print) {
    if (print.ind_printattr_n) {
        for (int i = 0; i < print.ind_printattr_buckets_n; i++) {
            acr::FPrintAttr *elem = print.ind_printattr_buckets_elems[i];
            while (elem) {
                acr::FPrintAttr *next = elem->ind_printattr_next;
                printattr_Delete(*elem);
                elem = next;
            }
        }
    }
}

// --- acr.FPrint.ind_printattr.Find
// Find row by key. Return NULL if not found.
acr::FPrintAttr* acr::ind_printattr_Find(acr::FPrint& print, const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (print.ind_printattr_buckets_n - 1);
    acr::FPrintAttr* *e = &print.ind_printattr_buckets_elems[index];
    acr::FPrintAttr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_printattr_next;
    } while (true);
    return ret;
}

// --- acr.FPrint.ind_printattr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr::ind_printattr_InsertMaybe(acr::FPrint& print, acr::FPrintAttr& row) {
    ind_printattr_Reserve(print, 1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_printattr_next == (acr::FPrintAttr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (print.ind_printattr_buckets_n - 1);
        acr::FPrintAttr* *prev = &print.ind_printattr_buckets_elems[index];
        do {
            acr::FPrintAttr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_printattr_next;
        } while (true);
        if (retval) {
            row.ind_printattr_next = *prev;
            print.ind_printattr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr.FPrint.ind_printattr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr::ind_printattr_Remove(acr::FPrint& print, acr::FPrintAttr& row) {
    if (LIKELY(row.ind_printattr_next != (acr::FPrintAttr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (print.ind_printattr_buckets_n - 1);
        acr::FPrintAttr* *prev = &print.ind_printattr_buckets_elems[index]; // addr of pointer to current element
        while (acr::FPrintAttr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_printattr_next; // unlink (singly linked list)
                print.ind_printattr_n--;
                row.ind_printattr_next = (acr::FPrintAttr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_printattr_next;
        }
    }
}

// --- acr.FPrint.ind_printattr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr::ind_printattr_Reserve(acr::FPrint& print, int n) {
    u32 old_nbuckets = print.ind_printattr_buckets_n;
    u32 new_nelems   = print.ind_printattr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr::FPrintAttr*);
        u32 new_size = new_nbuckets * sizeof(acr::FPrintAttr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr::FPrintAttr* *new_buckets = (acr::FPrintAttr**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FPrint.ind_printattr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < print.ind_printattr_buckets_n; i++) {
            acr::FPrintAttr* elem = print.ind_printattr_buckets_elems[i];
            while (elem) {
                acr::FPrintAttr &row        = *elem;
                acr::FPrintAttr* next       = row.ind_printattr_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_printattr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(print.ind_printattr_buckets_elems, old_size);
        print.ind_printattr_buckets_elems = new_buckets;
        print.ind_printattr_buckets_n = new_nbuckets;
    }
}

// --- acr.FPrint.c_pline.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_pline_Insert(acr::FPrint& print, acr::FPline& row) {
    // reserve space
    c_pline_Reserve(print, 1);
    u32 n  = print.c_pline_n;
    u32 at = n;
    acr::FPline* *elems = print.c_pline_elems;
    elems[at] = &row;
    print.c_pline_n = n+1;

}

// --- acr.FPrint.c_pline.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_pline_ScanInsertMaybe(acr::FPrint& print, acr::FPline& row) {
    bool retval = true;
    u32 n  = print.c_pline_n;
    for (u32 i = 0; i < n; i++) {
        if (print.c_pline_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_pline_Reserve(print, 1);
        print.c_pline_elems[n] = &row;
        print.c_pline_n = n+1;
    }
    return retval;
}

// --- acr.FPrint.c_pline.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_pline_Remove(acr::FPrint& print, acr::FPline& row) {
    int lim = print.c_pline_n;
    acr::FPline* *elems = print.c_pline_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FPline* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FPline*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            print.c_pline_n = lim - 1;
            break;
        }
    }
}

// --- acr.FPrint.c_pline.Reserve
// Reserve space in index for N more elements;
void acr::c_pline_Reserve(acr::FPrint& print, u32 n) {
    u32 old_max = print.c_pline_max;
    if (UNLIKELY(print.c_pline_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FPline*);
        u32 new_size = new_max * sizeof(acr::FPline*);
        void *new_mem = algo_lib::malloc_ReallocMem(print.c_pline_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FPrint.c_pline");
        }
        print.c_pline_elems = (acr::FPline**)new_mem;
        print.c_pline_max = new_max;
    }
}

// --- acr.FPrint..Init
// Set all fields to initial values.
void acr::FPrint_Init(acr::FPrint& print) {
    // initialize hash table for acr::FPrintAttr;
    print.ind_printattr_n             	= 0; // (acr.FPrint.ind_printattr)
    print.ind_printattr_buckets_n     	= 4; // (acr.FPrint.ind_printattr)
    print.ind_printattr_buckets_elems 	= (acr::FPrintAttr**)algo_lib::malloc_AllocMem(sizeof(acr::FPrintAttr*)*print.ind_printattr_buckets_n); // initial buckets (acr.FPrint.ind_printattr)
    if (!print.ind_printattr_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr.FPrint.ind_printattr)
    }
    memset(print.ind_printattr_buckets_elems, 0, sizeof(acr::FPrintAttr*)*print.ind_printattr_buckets_n); // (acr.FPrint.ind_printattr)
    print.c_pline_elems = NULL; // (acr.FPrint.c_pline)
    print.c_pline_n = 0; // (acr.FPrint.c_pline)
    print.c_pline_max = 0; // (acr.FPrint.c_pline)
    print.pretty = bool(false);
    print.tree = bool(false);
    print.fldfunc = bool(false);
    print.maxgroup = i32(25);
    print.cmt = bool(false);
    print.rowid = bool(true);
    print.fstdout = bool(true);
    print.loose = bool(false);
    print.showstatus = bool(false);
    print.skip_line = i32(0);
    print.this_depth = i32(0);
    print.prev_depth = i32(0);
}

// --- acr.FPrint..Uninit
void acr::FPrint_Uninit(acr::FPrint& print) {
    acr::FPrint &row = print; (void)row;
    ind_printattr_Cascdel(print); // dmmeta.cascdel:acr.FPrint.ind_printattr

    // acr.FPrint.c_pline.Uninit (Ptrary)  //Current print group
    algo_lib::malloc_FreeMem(print.c_pline_elems, sizeof(acr::FPline*)*print.c_pline_max); // (acr.FPrint.c_pline)

    // acr.FPrint.ind_printattr.Uninit (Thash)  //Index of printed attributes (to get width)
    algo_lib::malloc_FreeMem(print.ind_printattr_buckets_elems, sizeof(acr::FPrintAttr*)*print.ind_printattr_buckets_n); // (acr.FPrint.ind_printattr)
}

// --- acr.FPrintAttr..Uninit
void acr::FPrintAttr_Uninit(acr::FPrintAttr& printattr) {
    acr::FPrintAttr &row = printattr; (void)row;
    acr::FPrint* p_p_print = row.p_print;
    if (p_p_print)  {
        ind_printattr_Remove(*p_p_print, row);// remove printattr from index ind_printattr
    }
}

// --- acr.Queryop.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr::value_ToCstr(const acr::Queryop& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_Queryop_value_none        : ret = "none";  break;
        case acr_Queryop_value_select      : ret = "select";  break;
        case acr_Queryop_value_set_attr    : ret = "set_attr";  break;
        case acr_Queryop_value_rename_attr : ret = "rename_attr";  break;
        case acr_Queryop_value_del_attr    : ret = "del_attr";  break;
        case acr_Queryop_value_finish_rename_field: ret = "finish_rename_field";  break;
    }
    return ret;
}

// --- acr.Queryop.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr::value_Print(const acr::Queryop& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr.Queryop.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr::value_SetStrptrMaybe(acr::Queryop& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('n','o','n','e'): {
                    value_SetEnum(parent,acr_Queryop_value_none); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('s','e','l','e','c','t'): {
                    value_SetEnum(parent,acr_Queryop_value_select); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','l','_','a','t','t','r'): {
                    value_SetEnum(parent,acr_Queryop_value_del_attr); ret = true; break;
                }
                case LE_STR8('s','e','t','_','a','t','t','r'): {
                    value_SetEnum(parent,acr_Queryop_value_set_attr); ret = true; break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('r','e','n','a','m','e','_','a'): {
                    if (memcmp(rhs.elems+8,"ttr",3)==0) { value_SetEnum(parent,acr_Queryop_value_rename_attr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','i','n','i','s','h','_','r'): {
                    if (memcmp(rhs.elems+8,"ename_field",11)==0) { value_SetEnum(parent,acr_Queryop_value_finish_rename_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr.Queryop.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr::value_SetStrptr(acr::Queryop& parent, algo::strptr rhs, acr_Queryop_value_Enum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr.Queryop..Print
// print string representation of acr::Queryop to string LHS, no header -- cprint:acr.Queryop.String
void acr::Queryop_Print(acr::Queryop & row, algo::cstring &str) {
    acr::value_Print(row, str);
}

// --- acr.FQuery.where.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
acr::AttrRegx& acr::where_Alloc(acr::FQuery& query) {
    where_Reserve(query, 1);
    int n  = query.where_n;
    int at = n;
    acr::AttrRegx *elems = query.where_elems;
    new (elems + at) acr::AttrRegx(); // construct new element, default initializer
    query.where_n = n+1;
    return elems[at];
}

// --- acr.FQuery.where.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
acr::AttrRegx& acr::where_AllocAt(acr::FQuery& query, int at) {
    where_Reserve(query, 1);
    int n  = query.where_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("acr.bad_alloc_at  field:acr.FQuery.where  comment:'index out of range'");
    }
    acr::AttrRegx *elems = query.where_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(acr::AttrRegx));
    new (elems + at) acr::AttrRegx(); // construct element, default initializer
    query.where_n = n+1;
    return elems[at];
}

// --- acr.FQuery.where.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<acr::AttrRegx> acr::where_AllocN(acr::FQuery& query, int n_elems) {
    where_Reserve(query, n_elems);
    int old_n  = query.where_n;
    int new_n = old_n + n_elems;
    acr::AttrRegx *elems = query.where_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) acr::AttrRegx(); // construct new element, default initialize
    }
    query.where_n = new_n;
    return algo::aryptr<acr::AttrRegx>(elems + old_n, n_elems);
}

// --- acr.FQuery.where.Remove
// Remove item by index. If index outside of range, do nothing.
void acr::where_Remove(acr::FQuery& query, u32 i) {
    u32 lim = query.where_n;
    acr::AttrRegx *elems = query.where_elems;
    if (i < lim) {
        elems[i].~AttrRegx(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(acr::AttrRegx) * (lim - (i + 1)));
        query.where_n = lim - 1;
    }
}

// --- acr.FQuery.where.RemoveAll
void acr::where_RemoveAll(acr::FQuery& query) {
    u32 n = query.where_n;
    while (n > 0) {
        n -= 1;
        query.where_elems[n].~AttrRegx();
        query.where_n = n;
    }
}

// --- acr.FQuery.where.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr::where_RemoveLast(acr::FQuery& query) {
    u64 n = query.where_n;
    if (n > 0) {
        n -= 1;
        where_qFind(query, u64(n)).~AttrRegx();
        query.where_n = n;
    }
}

// --- acr.FQuery.where.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void acr::where_AbsReserve(acr::FQuery& query, int n) {
    u32 old_max  = query.where_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(query.where_elems, old_max * sizeof(acr::AttrRegx), new_max * sizeof(acr::AttrRegx));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.tary_nomem  field:acr.FQuery.where  comment:'out of memory'");
        }
        query.where_elems = (acr::AttrRegx*)new_mem;
        query.where_max = new_max;
    }
}

// --- acr.FQuery.where.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr::where_XrefMaybe(acr::AttrRegx &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr.FQuery.ssimfile.Print
// Print back to string
void acr::ssimfile_Print(acr::FQuery& query, algo::cstring &out) {
    Regx_Print(query.ssimfile, out);
}

// --- acr.FQuery..Init
// Set all fields to initial values.
void acr::FQuery_Init(acr::FQuery& query) {
    query.where_elems 	= 0; // (acr.FQuery.where)
    query.where_n     	= 0; // (acr.FQuery.where)
    query.where_max   	= 0; // (acr.FQuery.where)
    query.new_val = algo::strptr("");
    Regx_ReadAcr(query.ssimfile, "", true);
    query.nup = i32(0);
    query.ndown = i32(0);
    query.unused = bool(false);
    query.selmeta = bool(false);
    query.delrec = bool(false);
    query.comment = algo::strptr("");
    query.query_next = (acr::FQuery*)-1; // (acr.FDb.query) not-in-tpool's freelist
    query.zs_query_next = (acr::FQuery*)-1; // (acr.FDb.zs_query) not-in-list
}

// --- acr.FQuery..Uninit
void acr::FQuery_Uninit(acr::FQuery& query) {
    acr::FQuery &row = query; (void)row;
    zs_query_Remove(row); // remove query from index zs_query

    // acr.FQuery.where.Uninit (Tary)  //Additional key/value args
    // remove all elements from acr.FQuery.where
    where_RemoveAll(query);
    // free memory for Tary acr.FQuery.where
    algo_lib::malloc_FreeMem(query.where_elems, sizeof(acr::AttrRegx)*query.where_max); // (acr.FQuery.where)
}

// --- acr.FQuery..Print
// print string representation of acr::FQuery to string LHS, no header -- cprint:acr.FQuery.String
void acr::FQuery_Print(acr::FQuery & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.FQuery";

    acr::Queryop_Print(row.queryop, temp);
    PrintAttrSpaceReset(str,"queryop", temp);

    acr::AttrRegx_Print(row.query, temp);
    PrintAttrSpaceReset(str,"query", temp);

    algo::cstring_Print(row.new_val, temp);
    PrintAttrSpaceReset(str,"new_val", temp);

    acr::ssimfile_Print(row, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    i32_Print(row.nup, temp);
    PrintAttrSpaceReset(str,"nup", temp);

    i32_Print(row.ndown, temp);
    PrintAttrSpaceReset(str,"ndown", temp);

    bool_Print(row.unused, temp);
    PrintAttrSpaceReset(str,"unused", temp);

    bool_Print(row.selmeta, temp);
    PrintAttrSpaceReset(str,"selmeta", temp);

    bool_Print(row.delrec, temp);
    PrintAttrSpaceReset(str,"delrec", temp);

    algo::cstring_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- acr.RecSortkey..Print
// print string representation of acr::RecSortkey to string LHS, no header -- cprint:acr.RecSortkey.String
void acr::RecSortkey_Print(acr::RecSortkey & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.RecSortkey";

    double_Print(row.num, temp);
    PrintAttrSpaceReset(str,"num", temp);

    algo::cstring_Print(row.str, temp);
    PrintAttrSpaceReset(str,"str", temp);

    float_Print(row.rowid, temp);
    PrintAttrSpaceReset(str,"rowid", temp);
}

// --- acr.FRec..Init
// Set all fields to initial values.
void acr::FRec_Init(acr::FRec& rec) {
    rec.del = bool(false);
    rec.mod = bool(false);
    rec.metasel = bool(false);
    rec.isnew = bool(false);
    rec.seldist = i32(0);
    rec.c_pline = NULL;
    rec.p_outfile = NULL;
    rec.p_infile = NULL;
    rec.p_ctype = NULL;
    rec.lineno = i32(0);
    rec.zd_trec_next = (acr::FRec*)-1; // (acr.FCtype.zd_trec) not-in-list
    rec.zd_trec_prev = NULL; // (acr.FCtype.zd_trec)
    rec.ind_rec_next = (acr::FRec*)-1; // (acr.FCtype.ind_rec) not-in-hash
    rec.zd_selrec_next = (acr::FRec*)-1; // (acr.FCtype.zd_selrec) not-in-list
    rec.zd_selrec_prev = NULL; // (acr.FCtype.zd_selrec)
    rec.rec_next = (acr::FRec*)-1; // (acr.FDb.rec) not-in-tpool's freelist
    rec.zd_all_selrec_next = (acr::FRec*)-1; // (acr.FDb.zd_all_selrec) not-in-list
    rec.zd_all_selrec_prev = NULL; // (acr.FDb.zd_all_selrec)
    rec.zd_frec_next = (acr::FRec*)-1; // (acr.FFile.zd_frec) not-in-list
    rec.zd_frec_prev = NULL; // (acr.FFile.zd_frec)
}

// --- acr.FRec..Uninit
void acr::FRec_Uninit(acr::FRec& rec) {
    acr::FRec &row = rec; (void)row;
    zd_all_selrec_Remove(row); // remove rec from index zd_all_selrec
    acr::FFile* p_p_outfile = row.p_outfile;
    if (p_p_outfile)  {
        zd_frec_Remove(*p_p_outfile, row);// remove rec from index zd_frec
    }
    acr::FCtype* p_p_ctype = row.p_ctype;
    if (p_p_ctype)  {
        ind_rec_Remove(*p_p_ctype, row);// remove rec from index ind_rec
    }
    if (p_p_ctype)  {
        zd_selrec_Remove(*p_p_ctype, row);// remove rec from index zd_selrec
    }
    if (p_p_ctype)  {
        zd_trec_Remove(*p_p_ctype, row);// remove rec from index zd_trec
    }
}

// --- acr.FRun.c_ctype.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_ctype_Insert(acr::FRun& run, acr::FCtype& row) {
    // reserve space
    c_ctype_Reserve(run, 1);
    u32 n  = run.c_ctype_n;
    u32 at = n;
    acr::FCtype* *elems = run.c_ctype_elems;
    elems[at] = &row;
    run.c_ctype_n = n+1;

}

// --- acr.FRun.c_ctype.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_ctype_ScanInsertMaybe(acr::FRun& run, acr::FCtype& row) {
    bool retval = true;
    u32 n  = run.c_ctype_n;
    for (u32 i = 0; i < n; i++) {
        if (run.c_ctype_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ctype_Reserve(run, 1);
        run.c_ctype_elems[n] = &row;
        run.c_ctype_n = n+1;
    }
    return retval;
}

// --- acr.FRun.c_ctype.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_ctype_Remove(acr::FRun& run, acr::FCtype& row) {
    int lim = run.c_ctype_n;
    acr::FCtype* *elems = run.c_ctype_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FCtype* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FCtype*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            run.c_ctype_n = lim - 1;
            break;
        }
    }
}

// --- acr.FRun.c_ctype.Reserve
// Reserve space in index for N more elements;
void acr::c_ctype_Reserve(acr::FRun& run, u32 n) {
    u32 old_max = run.c_ctype_max;
    if (UNLIKELY(run.c_ctype_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FCtype*);
        u32 new_size = new_max * sizeof(acr::FCtype*);
        void *new_mem = algo_lib::malloc_ReallocMem(run.c_ctype_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FRun.c_ctype");
        }
        run.c_ctype_elems = (acr::FCtype**)new_mem;
        run.c_ctype_max = new_max;
    }
}

// --- acr.FRun.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_field_Insert(acr::FRun& run, acr::FField& row) {
    // reserve space
    c_field_Reserve(run, 1);
    u32 n  = run.c_field_n;
    u32 at = n;
    acr::FField* *elems = run.c_field_elems;
    elems[at] = &row;
    run.c_field_n = n+1;

}

// --- acr.FRun.c_field.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_field_ScanInsertMaybe(acr::FRun& run, acr::FField& row) {
    bool retval = true;
    u32 n  = run.c_field_n;
    for (u32 i = 0; i < n; i++) {
        if (run.c_field_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_field_Reserve(run, 1);
        run.c_field_elems[n] = &row;
        run.c_field_n = n+1;
    }
    return retval;
}

// --- acr.FRun.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_field_Remove(acr::FRun& run, acr::FField& row) {
    int lim = run.c_field_n;
    acr::FField* *elems = run.c_field_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FField* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FField*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            run.c_field_n = lim - 1;
            break;
        }
    }
}

// --- acr.FRun.c_field.Reserve
// Reserve space in index for N more elements;
void acr::c_field_Reserve(acr::FRun& run, u32 n) {
    u32 old_max = run.c_field_max;
    if (UNLIKELY(run.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FField*);
        u32 new_size = new_max * sizeof(acr::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(run.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FRun.c_field");
        }
        run.c_field_elems = (acr::FField**)new_mem;
        run.c_field_max = new_max;
    }
}

// --- acr.FRun.c_rec.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_rec_Insert(acr::FRun& run, acr::FRec& row) {
    // reserve space
    c_rec_Reserve(run, 1);
    u32 n  = run.c_rec_n;
    u32 at = n;
    acr::FRec* *elems = run.c_rec_elems;
    elems[at] = &row;
    run.c_rec_n = n+1;

}

// --- acr.FRun.c_rec.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_rec_ScanInsertMaybe(acr::FRun& run, acr::FRec& row) {
    bool retval = true;
    u32 n  = run.c_rec_n;
    for (u32 i = 0; i < n; i++) {
        if (run.c_rec_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_rec_Reserve(run, 1);
        run.c_rec_elems[n] = &row;
        run.c_rec_n = n+1;
    }
    return retval;
}

// --- acr.FRun.c_rec.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_rec_Remove(acr::FRun& run, acr::FRec& row) {
    int lim = run.c_rec_n;
    acr::FRec* *elems = run.c_rec_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FRec* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FRec*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            run.c_rec_n = lim - 1;
            break;
        }
    }
}

// --- acr.FRun.c_rec.Reserve
// Reserve space in index for N more elements;
void acr::c_rec_Reserve(acr::FRun& run, u32 n) {
    u32 old_max = run.c_rec_max;
    if (UNLIKELY(run.c_rec_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FRec*);
        u32 new_size = new_max * sizeof(acr::FRec*);
        void *new_mem = algo_lib::malloc_ReallocMem(run.c_rec_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FRun.c_rec");
        }
        run.c_rec_elems = (acr::FRec**)new_mem;
        run.c_rec_max = new_max;
    }
}

// --- acr.FRun.c_child.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_child_Insert(acr::FRun& run, acr::FCtype& row) {
    if (bool_Update(row.run_c_child_in_ary,true)) {
        // reserve space
        c_child_Reserve(run, 1);
        u32 n  = run.c_child_n;
        u32 at = n;
        acr::FCtype* *elems = run.c_child_elems;
        elems[at] = &row;
        run.c_child_n = n+1;

    }
}

// --- acr.FRun.c_child.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool acr::c_child_InsertMaybe(acr::FRun& run, acr::FCtype& row) {
    bool retval = !row.run_c_child_in_ary;
    c_child_Insert(run,row); // check is performed in _Insert again
    return retval;
}

// --- acr.FRun.c_child.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_child_Remove(acr::FRun& run, acr::FCtype& row) {
    if (bool_Update(row.run_c_child_in_ary,false)) {
        int lim = run.c_child_n;
        acr::FCtype* *elems = run.c_child_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            acr::FCtype* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(acr::FCtype*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                run.c_child_n = lim - 1;
                break;
            }
        }
    }
}

// --- acr.FRun.c_child.Reserve
// Reserve space in index for N more elements;
void acr::c_child_Reserve(acr::FRun& run, u32 n) {
    u32 old_max = run.c_child_max;
    if (UNLIKELY(run.c_child_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FCtype*);
        u32 new_size = new_max * sizeof(acr::FCtype*);
        void *new_mem = algo_lib::malloc_ReallocMem(run.c_child_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FRun.c_child");
        }
        run.c_child_elems = (acr::FCtype**)new_mem;
        run.c_child_max = new_max;
    }
}

// --- acr.FRun..Uninit
void acr::FRun_Uninit(acr::FRun& run) {
    acr::FRun &row = run; (void)row;

    // acr.FRun.c_child.Uninit (Ptrary)  //Down front (for -ndown)
    algo_lib::malloc_FreeMem(run.c_child_elems, sizeof(acr::FCtype*)*run.c_child_max); // (acr.FRun.c_child)

    // acr.FRun.c_rec.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(run.c_rec_elems, sizeof(acr::FRec*)*run.c_rec_max); // (acr.FRun.c_rec)

    // acr.FRun.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(run.c_field_elems, sizeof(acr::FField*)*run.c_field_max); // (acr.FRun.c_field)

    // acr.FRun.c_ctype.Uninit (Ptrary)  //Array of ctypes to check
    algo_lib::malloc_FreeMem(run.c_ctype_elems, sizeof(acr::FCtype*)*run.c_ctype_max); // (acr.FRun.c_ctype)
}

// --- acr.FRun..Print
// print string representation of acr::FRun to string LHS, no header -- cprint:acr.FRun.String
void acr::FRun_Print(acr::FRun & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr.FRun";

    i32_Print(row.n_regx_match, temp);
    PrintAttrSpaceReset(str,"n_regx_match", temp);

    i32_Print(row.n_visit_field, temp);
    PrintAttrSpaceReset(str,"n_visit_field", temp);

    i32_Print(row.n_visit_ctype, temp);
    PrintAttrSpaceReset(str,"n_visit_ctype", temp);

    i32_Print(row.n_mod_rec, temp);
    PrintAttrSpaceReset(str,"n_mod_rec", temp);
}

// --- acr.FSmallstr.base.CopyOut
// Copy fields out of row
void acr::smallstr_CopyOut(acr::FSmallstr &row, dmmeta::Smallstr &out) {
    out.field = row.field;
    out.length = row.length;
    out.strtype = row.strtype;
    out.pad = row.pad;
    out.strict = row.strict;
}

// --- acr.FSmallstr.base.CopyIn
// Copy fields in to row
void acr::smallstr_CopyIn(acr::FSmallstr &row, dmmeta::Smallstr &in) {
    row.field = in.field;
    row.length = in.length;
    row.strtype = in.strtype;
    row.pad = in.pad;
    row.strict = in.strict;
}

// --- acr.FSmallstr.ctype.Get
algo::Smallstr50 acr::ctype_Get(acr::FSmallstr& smallstr) {
    algo::Smallstr50 ret(algo::Pathcomp(smallstr.field, ".RL"));
    return ret;
}

// --- acr.FSsimfile.base.CopyOut
// Copy fields out of row
void acr::ssimfile_CopyOut(acr::FSsimfile &row, dmmeta::Ssimfile &out) {
    out.ssimfile = row.ssimfile;
    out.ctype = row.ctype;
}

// --- acr.FSsimfile.base.CopyIn
// Copy fields in to row
void acr::ssimfile_CopyIn(acr::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- acr.FSsimfile.ssimns.Get
algo::Smallstr16 acr::ssimns_Get(acr::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr.FSsimfile.ns.Get
algo::Smallstr16 acr::ns_Get(acr::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr.FSsimfile.name.Get
algo::Smallstr50 acr::name_Get(acr::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- acr.FSsimfile..Uninit
void acr::FSsimfile_Uninit(acr::FSsimfile& ssimfile) {
    acr::FSsimfile &row = ssimfile; (void)row;
    acr::FCtype* p_ctype = acr::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ssimfile_Remove(*p_ctype, row);// remove ssimfile from index c_ssimfile
    }
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
}

// --- acr.FSsimreq.base.CopyOut
// Copy fields out of row
void acr::ssimreq_CopyOut(acr::FSsimreq &row, dmmeta::Ssimreq &out) {
    out.ssimfile = row.ssimfile;
    out.field = row.field;
    out.value = row.value;
    out.bidir = row.bidir;
    out.comment = row.comment;
}

// --- acr.FSsimreq.base.CopyIn
// Copy fields in to row
void acr::ssimreq_CopyIn(acr::FSsimreq &row, dmmeta::Ssimreq &in) {
    row.ssimfile = in.ssimfile;
    row.field = in.field;
    row.value = in.value;
    row.bidir = in.bidir;
    row.comment = in.comment;
}

// --- acr.FSsimreq..Uninit
void acr::FSsimreq_Uninit(acr::FSsimreq& ssimreq) {
    acr::FSsimreq &row = ssimreq; (void)row;
    acr::FSsimfile* p_ssimfile = acr::ind_ssimfile_Find(row.ssimfile);
    if (p_ssimfile)  {
        c_ssimreq_Remove(*p_ssimfile, row);// remove ssimreq from index c_ssimreq
    }
}

// --- acr.FSsimsort.base.CopyOut
// Copy fields out of row
void acr::ssimsort_CopyOut(acr::FSsimsort &row, dmmeta::Ssimsort &out) {
    out.ssimfile = row.ssimfile;
    out.sortfld = row.sortfld;
    // comment: field stripped (see dmmeta.fbase:acr.FSsimsort.base)
}

// --- acr.FSsimsort.base.CopyIn
// Copy fields in to row
void acr::ssimsort_CopyIn(acr::FSsimsort &row, dmmeta::Ssimsort &in) {
    row.ssimfile = in.ssimfile;
    row.sortfld = in.sortfld;
    // comment: field stripped (see dmmeta.fbase:acr.FSsimsort.base)
}

// --- acr.FSsimsort..Uninit
void acr::FSsimsort_Uninit(acr::FSsimsort& ssimsort) {
    acr::FSsimsort &row = ssimsort; (void)row;
    acr::FSsimfile* p_ssimfile = acr::ind_ssimfile_Find(row.ssimfile);
    if (p_ssimfile)  {
        c_ssimsort_Remove(*p_ssimfile, row);// remove ssimsort from index c_ssimsort
    }
    ind_ssimsort_Remove(row); // remove ssimsort from index ind_ssimsort
}

// --- acr.FSubstr.base.CopyOut
// Copy fields out of row
void acr::substr_CopyOut(acr::FSubstr &row, dmmeta::Substr &out) {
    out.field = row.field;
    out.expr = row.expr;
    out.srcfield = row.srcfield;
}

// --- acr.FSubstr.base.CopyIn
// Copy fields in to row
void acr::substr_CopyIn(acr::FSubstr &row, dmmeta::Substr &in) {
    row.field = in.field;
    row.expr = in.expr;
    row.srcfield = in.srcfield;
}

// --- acr.FSubstr..Uninit
void acr::FSubstr_Uninit(acr::FSubstr& substr) {
    acr::FSubstr &row = substr; (void)row;
    acr::FField* p_field = acr::ind_field_Find(row.field);
    if (p_field)  {
        c_substr_Remove(*p_field, row);// remove substr from index c_substr
    }
}

// --- acr.FTempkey..Uninit
void acr::FTempkey_Uninit(acr::FTempkey& tempkey) {
    acr::FTempkey &row = tempkey; (void)row;
    ind_tempkey_Remove(row); // remove tempkey from index ind_tempkey
}

// --- acr.FUniqueattr..Uninit
void acr::FUniqueattr_Uninit(acr::FUniqueattr& uniqueattr) {
    acr::FUniqueattr &row = uniqueattr; (void)row;
    ind_uniqueattr_Remove(row); // remove uniqueattr from index ind_uniqueattr
}

// --- acr.FWrite.c_cmtrec.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr::c_cmtrec_Insert(acr::FWrite& write, acr::FRec& row) {
    // reserve space
    c_cmtrec_Reserve(write, 1);
    u32 n  = write.c_cmtrec_n;
    u32 at = n;
    acr::FRec* *elems = write.c_cmtrec_elems;
    elems[at] = &row;
    write.c_cmtrec_n = n+1;

}

// --- acr.FWrite.c_cmtrec.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr::c_cmtrec_ScanInsertMaybe(acr::FWrite& write, acr::FRec& row) {
    bool retval = true;
    u32 n  = write.c_cmtrec_n;
    for (u32 i = 0; i < n; i++) {
        if (write.c_cmtrec_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_cmtrec_Reserve(write, 1);
        write.c_cmtrec_elems[n] = &row;
        write.c_cmtrec_n = n+1;
    }
    return retval;
}

// --- acr.FWrite.c_cmtrec.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr::c_cmtrec_Remove(acr::FWrite& write, acr::FRec& row) {
    int lim = write.c_cmtrec_n;
    acr::FRec* *elems = write.c_cmtrec_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr::FRec* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr::FRec*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            write.c_cmtrec_n = lim - 1;
            break;
        }
    }
}

// --- acr.FWrite.c_cmtrec.Reserve
// Reserve space in index for N more elements;
void acr::c_cmtrec_Reserve(acr::FWrite& write, u32 n) {
    u32 old_max = write.c_cmtrec_max;
    if (UNLIKELY(write.c_cmtrec_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr::FRec*);
        u32 new_size = new_max * sizeof(acr::FRec*);
        void *new_mem = algo_lib::malloc_ReallocMem(write.c_cmtrec_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr.out_of_memory  field:acr.FWrite.c_cmtrec");
        }
        write.c_cmtrec_elems = (acr::FRec**)new_mem;
        write.c_cmtrec_max = new_max;
    }
}

// --- acr.FWrite.c_cmtrec.Swap
// Swap values elem_a and elem_b
inline static void acr::c_cmtrec_Swap(acr::FRec* &elem_a, acr::FRec* &elem_b) {
    acr::FRec *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- acr.FWrite.c_cmtrec.Rotleft
// Left circular shift of three-tuple
inline static void acr::c_cmtrec_Rotleft(acr::FRec* &elem_a, acr::FRec* &elem_b, acr::FRec* &elem_c) {
    acr::FRec *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- acr.FWrite.c_cmtrec.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool acr::c_cmtrec_Lt(acr::FRec &elem_a, acr::FRec &elem_b) {
    bool ret;
    ret = elem_a.sortkey < elem_b.sortkey;
    return ret;
}

// --- acr.FWrite.c_cmtrec.SortedQ
// Verify whether array is sorted
bool acr::c_cmtrec_SortedQ(acr::FWrite& write) {
    acr::FRec* *elems = c_cmtrec_Getary(write).elems;
    int n = c_cmtrec_N(write);
    for (int i = 1; i < n; i++) {
        if (c_cmtrec_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- acr.FWrite.c_cmtrec.IntInsertionSort
// Internal insertion sort
static void acr::c_cmtrec_IntInsertionSort(acr::FRec* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        acr::FRec *tmp = elems[i];
        // shift elements up by one
        if (c_cmtrec_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_cmtrec_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- acr.FWrite.c_cmtrec.IntHeapSort
// Internal heap sort
static void acr::c_cmtrec_IntHeapSort(acr::FRec* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_cmtrec_Lt(*elems[j], *elems[k])) {
            c_cmtrec_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_cmtrec_Lt(*elems[l], *elems[l+1]);
            if (c_cmtrec_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_cmtrec_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_cmtrec_Swap(elems[i],elems[k]);
        }
    }
}

// --- acr.FWrite.c_cmtrec.IntQuickSort
// Quick sort engine
static void acr::c_cmtrec_IntQuickSort(acr::FRec* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_cmtrec_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_cmtrec_Lt(*elems[pp], *elems[pi])) {
            c_cmtrec_Swap(elems[pi], elems[pp]);
        }
        if (c_cmtrec_Lt(*elems[pj], *elems[pp])) {
            if (c_cmtrec_Lt(*elems[pj], *elems[pi])) {
                c_cmtrec_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_cmtrec_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_cmtrec_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        acr::FRec *pivot = elems[pj];
        for(;;){
            while (c_cmtrec_Lt(*elems[++pi], *pivot)) {
            }
            while (c_cmtrec_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_cmtrec_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_cmtrec_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_cmtrec_IntInsertionSort(elems,n);
}

// --- acr.FWrite.c_cmtrec.InsertionSort
// Insertion sort
void acr::c_cmtrec_InsertionSort(acr::FWrite& write) {
    acr::FRec* *elems = c_cmtrec_Getary(write).elems;
    int n = c_cmtrec_N(write);
    c_cmtrec_IntInsertionSort(elems, n);
}

// --- acr.FWrite.c_cmtrec.HeapSort
// Heap sort
void acr::c_cmtrec_HeapSort(acr::FWrite& write) {
    acr::FRec* *elems = c_cmtrec_Getary(write).elems;
    int n = c_cmtrec_N(write);
    c_cmtrec_IntHeapSort(elems, n);
}

// --- acr.FWrite.c_cmtrec.QuickSort
// Quick sort
void acr::c_cmtrec_QuickSort(acr::FWrite& write) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_cmtrec_N(write) + 1)) + 3;
    acr::FRec* *elems = c_cmtrec_Getary(write).elems;
    int n = c_cmtrec_N(write);
    c_cmtrec_IntQuickSort(elems, n, max_depth);
}

// --- acr.FWrite..Uninit
void acr::FWrite_Uninit(acr::FWrite& write) {
    acr::FWrite &row = write; (void)row;

    // acr.FWrite.c_cmtrec.Uninit (Ptrary)  //Temporary array for write
    algo_lib::malloc_FreeMem(write.c_cmtrec_elems, sizeof(acr::FRec*)*write.c_cmtrec_max); // (acr.FWrite.c_cmtrec)
}

// --- acr.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr::value_ToCstr(const acr::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- acr.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr::value_Print(const acr::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr::value_SetStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,acr_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr::value_SetStrptr(acr::FieldId& parent, algo::strptr rhs, acr_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr::value_ReadStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr.FieldId..ReadStrptrMaybe
// Read fields of acr::FieldId from an ascii string.
// The format of the string is the format of the acr::FieldId's only field
bool acr::FieldId_ReadStrptrMaybe(acr::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr.FieldId..Print
// print string representation of acr::FieldId to string LHS, no header -- cprint:acr.FieldId.String
void acr::FieldId_Print(acr::FieldId & row, algo::cstring &str) {
    acr::value_Print(row, str);
}

// --- acr.ReadMode.read_mode.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr::read_mode_ToCstr(const acr::ReadMode& parent) {
    const char *ret = NULL;
    switch(read_mode_GetEnum(parent)) {
        case acr_ReadMode_insert           : ret = "insert";  break;
        case acr_ReadMode_replace          : ret = "replace";  break;
        case acr_ReadMode_update           : ret = "update";  break;
        case acr_ReadMode_merge            : ret = "merge";  break;
        case acr_ReadMode_delete           : ret = "delete";  break;
    }
    return ret;
}

// --- acr.ReadMode.read_mode.Print
// Convert read_mode to a string. First, attempt conversion to a known string.
// If no string matches, print read_mode as a numeric value.
void acr::read_mode_Print(const acr::ReadMode& parent, algo::cstring &lhs) {
    const char *strval = read_mode_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.read_mode;
    }
}

// --- acr.ReadMode.read_mode.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr::read_mode_SetStrptrMaybe(acr::ReadMode& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('m','e','r','g','e'): {
                    read_mode_SetEnum(parent,acr_ReadMode_merge); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('d','e','l','e','t','e'): {
                    read_mode_SetEnum(parent,acr_ReadMode_delete); ret = true; break;
                }
                case LE_STR6('i','n','s','e','r','t'): {
                    read_mode_SetEnum(parent,acr_ReadMode_insert); ret = true; break;
                }
                case LE_STR6('u','p','d','a','t','e'): {
                    read_mode_SetEnum(parent,acr_ReadMode_update); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('r','e','p','l','a','c','e'): {
                    read_mode_SetEnum(parent,acr_ReadMode_replace); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr.ReadMode.read_mode.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr::read_mode_SetStrptr(acr::ReadMode& parent, algo::strptr rhs, acr_ReadModeEnum dflt) {
    if (!read_mode_SetStrptrMaybe(parent,rhs)) read_mode_SetEnum(parent,dflt);
}

// --- acr.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr::value_ToCstr(const acr::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_TableId_dmmeta_Anonfld    : ret = "dmmeta.Anonfld";  break;
        case acr_TableId_amcdb_Bltin       : ret = "amcdb.Bltin";  break;
        case acr_TableId_dmmeta_Cdflt      : ret = "dmmeta.Cdflt";  break;
        case acr_TableId_dmmeta_Cppfunc    : ret = "dmmeta.Cppfunc";  break;
        case acr_TableId_dmmeta_Ctype      : ret = "dmmeta.Ctype";  break;
        case acr_TableId_dmmeta_Field      : ret = "dmmeta.Field";  break;
        case acr_TableId_dmmeta_Funique    : ret = "dmmeta.Funique";  break;
        case acr_TableId_dmmeta_Smallstr   : ret = "dmmeta.Smallstr";  break;
        case acr_TableId_dmmeta_Ssimfile   : ret = "dmmeta.Ssimfile";  break;
        case acr_TableId_dmmeta_Ssimreq    : ret = "dmmeta.Ssimreq";  break;
        case acr_TableId_dmmeta_Ssimsort   : ret = "dmmeta.Ssimsort";  break;
        case acr_TableId_dmmeta_Substr     : ret = "dmmeta.Substr";  break;
    }
    return ret;
}

// --- acr.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr::value_Print(const acr::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr::value_SetStrptrMaybe(acr::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','c','d','b','.','B','l'): {
                    if (memcmp(rhs.elems+8,"tin",3)==0) { value_SetEnum(parent,acr_TableId_amcdb_Bltin); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','c','d','b','.','b','l'): {
                    if (memcmp(rhs.elems+8,"tin",3)==0) { value_SetEnum(parent,acr_TableId_amcdb_bltin); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"dflt",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Cdflt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Field); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"dflt",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_cdflt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_TableId_dmmeta_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Substr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,acr_TableId_dmmeta_substr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','A'): {
                    if (memcmp(rhs.elems+8,"nonfld",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Anonfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"ppfunc",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Cppfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"unique",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Funique); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simreq",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Ssimreq); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','a'): {
                    if (memcmp(rhs.elems+8,"nonfld",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_anonfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"ppfunc",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_cppfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"unique",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_funique); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simreq",6)==0) { value_SetEnum(parent,acr_TableId_dmmeta_ssimreq); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"mallstr",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Smallstr); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Ssimfile); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simsort",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_Ssimsort); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"mallstr",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_smallstr); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_ssimfile); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simsort",7)==0) { value_SetEnum(parent,acr_TableId_dmmeta_ssimsort); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr::value_SetStrptr(acr::TableId& parent, algo::strptr rhs, acr_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr::value_ReadStrptrMaybe(acr::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr.TableId..ReadStrptrMaybe
// Read fields of acr::TableId from an ascii string.
// The format of the string is the format of the acr::TableId's only field
bool acr::TableId_ReadStrptrMaybe(acr::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr.TableId..Print
// print string representation of acr::TableId to string LHS, no header -- cprint:acr.TableId.String
void acr::TableId_Print(acr::TableId & row, algo::cstring &str) {
    acr::value_Print(row, str);
}

// --- acr...SizeCheck
inline static void acr::SizeCheck() {
}

// --- acr...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        acr::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        acr::ReadArgv(); // dmmeta.main:acr
        acr::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("acr.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        acr::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- acr...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
