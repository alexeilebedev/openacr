//
// cpp/gen/_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include

// --- i16..ReadStrptrMaybe
// Read fields of i16 from an ascii string.
// Attempt to parse i16 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool i16_ReadStrptrMaybe(i16 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u32 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+6-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0x7fff) {
            num = 0x7fff;
        }
    }
    if (neg) {
        num = -num;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "i16_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- i32..ReadStrptrMaybe
// Read fields of i32 from an ascii string.
// Attempt to parse i32 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool i32_ReadStrptrMaybe(i32 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u64 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+12-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0x7fffffff) {
            num = 0x7fffffff;
        }
    }
    if (neg) {
        num = -num;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "i32_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- i64..ReadStrptrMaybe
// Read fields of i64 from an ascii string.
// Attempt to parse i64 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool i64_ReadStrptrMaybe(i64 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u64 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+14-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        // 2nd batch of digits
        if (index < in_str.n_elems) {
            lim = u32_Min(index+14, in_str.n_elems);
            u64 num2 = 0;
            u64 div = 1;
            for (; index < lim; index++) {
                c = in_str.elems[index];
                if (!algo_lib::DigitCharQ(c)) {
                    break;
                }
                num2 = num2*10 + (c-'0');
                div = div*10;
            }
            if (num > 0x7fffffffffffffffULL/div) {
                num = 0x7fffffffffffffffULL;
            } else {
                num = num*div + num2;
            }
        }
    }
    if (neg) {
        num = -num;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "i64_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- i8..ReadStrptrMaybe
// Read fields of i8 from an ascii string.
// Attempt to parse i8 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool i8_ReadStrptrMaybe(i8 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u32 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+4-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0x7f) {
            num = 0x7f;
        }
    }
    if (neg) {
        num = -num;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "i8_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- u8..ReadStrptrMaybe
// Read fields of u8 from an ascii string.
// Attempt to parse u8 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool u8_ReadStrptrMaybe(u8 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u32 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+4-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0xff) {
            num = 0xff;
        }
    }
    if (neg) {
        num = 0;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "u8_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- u128..ReadStrptrMaybe
// Read fields of u128 from an ascii string.
// Attempt to parse u128 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool u128_ReadStrptrMaybe(u128 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u128 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+25-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        // 2nd batch of digits
        if (index < in_str.n_elems) {
            lim = u32_Min(index+25, in_str.n_elems);
            u128 num2 = 0;
            u128 div = 1;
            for (; index < lim; index++) {
                c = in_str.elems[index];
                if (!algo_lib::DigitCharQ(c)) {
                    break;
                }
                num2 = num2*10 + (c-'0');
                div = div*10;
            }
            if (num > ((u128(0xffffffffffffffffULL) << 64) | 0xffffffffffffffffULL)/div) {
                num = ((u128(0xffffffffffffffffULL) << 64) | 0xffffffffffffffffULL);
            } else {
                num = num*div + num2;
            }
        }
    }
    if (neg) {
        num = 0;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "u128_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- u16..ReadStrptrMaybe
// Read fields of u16 from an ascii string.
// Attempt to parse u16 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool u16_ReadStrptrMaybe(u16 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u32 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+6-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0xffff) {
            num = 0xffff;
        }
    }
    if (neg) {
        num = 0;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "u16_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- u32..ReadStrptrMaybe
// Read fields of u32 from an ascii string.
// Attempt to parse u32 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool u32_ReadStrptrMaybe(u32 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u64 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+12-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        if (num > 0xffffffff) {
            num = 0xffffffff;
        }
    }
    if (neg) {
        num = 0;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "u32_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}

// --- u64..ReadStrptrMaybe
// Read fields of u64 from an ascii string.
// Attempt to parse u64 from in_str
// Leading whitespace is silently skipped
// Return success value; If false, PARENT is unchanged
// String must be non-empty
// Number may prefixed with + or - (with no space after)
// If the value is outside of valid range for the type, it is clipped to the valid range
// Supported bases: 10, 16 (if string starts with 0x or 0X
// For hex numbers, there is no overflow (just take last N digits that fit the type)
bool u64_ReadStrptrMaybe(u64 &parent, algo::strptr in_str) {
    bool retval = true;
    int index = 0;
    bool neg=false;
    bool hex=false;
    u64 num=0;
    char c;
    while (index < in_str.n_elems && algo_lib::WhiteCharQ(in_str.elems[index])) {
        index++;
    }
    if (index < in_str.n_elems) {
        c = in_str.elems[index];
        index++;
        if (c=='+') {
        } else if (c=='-') {
            neg=true;
        } else if (algo_lib::DigitCharQ(c)) {
            num = c-'0';
            if (num==0 && index < in_str.n_elems) {
                c = in_str.elems[index];
                if (c == 'x' || c == 'X') {
                    hex=true;
                    index++;
                }
            }
        } else {
            retval=false;
        }
    } else {
        retval= index == 0;
    }
    if (hex) {
        if (index == in_str.n_elems) {
            retval=false;
        }
        for (; index < in_str.n_elems; index++) {
            c = in_str.elems[index];
            u8 val;
            if (!algo::ParseHex1(c, val)) {
                break;
            }
            num = num*16 + val;
        }
    } else {
        int lim = u32_Min(index+14-1, in_str.n_elems); // 1 digit already in num
        for (; index < lim; index++) {
            c = in_str.elems[index];
            if (!algo_lib::DigitCharQ(c)) {
                break;
            }
            num = num*10 + (c-'0');
        }
        // 2nd batch of digits
        if (index < in_str.n_elems) {
            lim = u32_Min(index+14, in_str.n_elems);
            u64 num2 = 0;
            u64 div = 1;
            for (; index < lim; index++) {
                c = in_str.elems[index];
                if (!algo_lib::DigitCharQ(c)) {
                    break;
                }
                num2 = num2*10 + (c-'0');
                div = div*10;
            }
            if (num > 0xffffffffffffffffULL/div) {
                num = 0xffffffffffffffffULL;
            } else {
                num = num*div + num2;
            }
        }
    }
    if (neg) {
        num = 0;
    }
    if (retval) {
        parent = num;
    } else {
        algo_lib::SaveBadTag("comment", "u64_ReadStrptrMaybe: bad number");
        algo_lib::SaveBadTag("value",in_str);
    }
    return retval;
}
