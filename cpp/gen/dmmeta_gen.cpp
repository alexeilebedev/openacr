//
// cpp/gen/dmmeta_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dmmeta.Buftype.pnewtype
const char *dmmeta_Buftype_pnewtype_Memptr      = "Memptr";
const char *dmmeta_Buftype_pnewtype_AmsStream   = "AmsStream";
const char *dmmeta_Buftype_pnewtype_Fixed       = "Fixed";
const char *dmmeta_Buftype_pnewtype_Dynamic     = "Dynamic";
const char *dmmeta_Buftype_pnewtype_ByteAry     = "ByteAry";

// compile-time string constants for dmmeta.Fbufdir.fbufdir
const char *dmmeta_Fbufdir_fbufdir_in    = "in";
const char *dmmeta_Fbufdir_fbufdir_out   = "out";

// compile-time string constants for dmmeta.Fbuftype.fbuftype
const char *dmmeta_Fbuftype_fbuftype_Bytebuf   = "Bytebuf";
const char *dmmeta_Fbuftype_fbuftype_Linebuf   = "Linebuf";
const char *dmmeta_Fbuftype_fbuftype_Msgbuf    = "Msgbuf";

// compile-time string constants for dmmeta.Hashtype.hashtype
const char *dmmeta_Hashtype_hashtype_Extern   = "Extern";
const char *dmmeta_Hashtype_hashtype_CRC32    = "CRC32";

// compile-time string constants for dmmeta.Ns.ns
const char *dmmeta_Ns_ns_            = "";
const char *dmmeta_Ns_ns_abt         = "abt";
const char *dmmeta_Ns_ns_abt_md      = "abt_md";
const char *dmmeta_Ns_ns_acr         = "acr";
const char *dmmeta_Ns_ns_acr_compl   = "acr_compl";
const char *dmmeta_Ns_ns_acr_dm      = "acr_dm";
const char *dmmeta_Ns_ns_acr_ed      = "acr_ed";
const char *dmmeta_Ns_ns_acr_in      = "acr_in";
const char *dmmeta_Ns_ns_acr_my      = "acr_my";
const char *dmmeta_Ns_ns_algo        = "algo";
const char *dmmeta_Ns_ns_algo_lib    = "algo_lib";
const char *dmmeta_Ns_ns_algo_pch    = "algo_pch";
const char *dmmeta_Ns_ns_amc         = "amc";
const char *dmmeta_Ns_ns_amc_gc      = "amc_gc";
const char *dmmeta_Ns_ns_amc_vis     = "amc_vis";
const char *dmmeta_Ns_ns_amcdb       = "amcdb";

const char *dmmeta_Ns_ns_ams            = "ams";
const char *dmmeta_Ns_ns_ams_cat        = "ams_cat";
const char *dmmeta_Ns_ns_ams_sendtest   = "ams_sendtest";
const char *dmmeta_Ns_ns_amsdb          = "amsdb";
const char *dmmeta_Ns_ns_atf            = "atf";
const char *dmmeta_Ns_ns_atf_amc        = "atf_amc";
const char *dmmeta_Ns_ns_atf_ci         = "atf_ci";
const char *dmmeta_Ns_ns_atf_cmdline    = "atf_cmdline";
const char *dmmeta_Ns_ns_atf_comp       = "atf_comp";
const char *dmmeta_Ns_ns_atf_cov        = "atf_cov";
const char *dmmeta_Ns_ns_atf_fuzz       = "atf_fuzz";
const char *dmmeta_Ns_ns_atf_gcli       = "atf_gcli";
const char *dmmeta_Ns_ns_atf_nrun       = "atf_nrun";
const char *dmmeta_Ns_ns_atf_unit       = "atf_unit";
const char *dmmeta_Ns_ns_atfdb          = "atfdb";
const char *dmmeta_Ns_ns_bash2html      = "bash2html";
const char *dmmeta_Ns_ns_command        = "command";
const char *dmmeta_Ns_ns_dev            = "dev";
const char *dmmeta_Ns_ns_dmmeta         = "dmmeta";
const char *dmmeta_Ns_ns_fm             = "fm";
const char *dmmeta_Ns_ns_fmdb           = "fmdb";
const char *dmmeta_Ns_ns_gcache         = "gcache";
const char *dmmeta_Ns_ns_gcli           = "gcli";
const char *dmmeta_Ns_ns_gclidb         = "gclidb";

const char *dmmeta_Ns_ns_ietf         = "ietf";
const char *dmmeta_Ns_ns_lib_amcdb    = "lib_amcdb";
const char *dmmeta_Ns_ns_lib_ams      = "lib_ams";
const char *dmmeta_Ns_ns_lib_ctype    = "lib_ctype";
const char *dmmeta_Ns_ns_lib_exec     = "lib_exec";
const char *dmmeta_Ns_ns_lib_fm       = "lib_fm";
const char *dmmeta_Ns_ns_lib_git      = "lib_git";
const char *dmmeta_Ns_ns_lib_iconv    = "lib_iconv";
const char *dmmeta_Ns_ns_lib_json     = "lib_json";
const char *dmmeta_Ns_ns_lib_mysql    = "lib_mysql";
const char *dmmeta_Ns_ns_lib_prot     = "lib_prot";
const char *dmmeta_Ns_ns_lib_sql      = "lib_sql";
const char *dmmeta_Ns_ns_mdbg         = "mdbg";
const char *dmmeta_Ns_ns_mysql2ssim   = "mysql2ssim";
const char *dmmeta_Ns_ns_orgfile      = "orgfile";
const char *dmmeta_Ns_ns_report       = "report";
const char *dmmeta_Ns_ns_samp_regx    = "samp_regx";
const char *dmmeta_Ns_ns_sandbox      = "sandbox";
const char *dmmeta_Ns_ns_src_func     = "src_func";
const char *dmmeta_Ns_ns_src_hdr      = "src_hdr";
const char *dmmeta_Ns_ns_src_lim      = "src_lim";

const char *dmmeta_Ns_ns_ssim2csv     = "ssim2csv";
const char *dmmeta_Ns_ns_ssim2mysql   = "ssim2mysql";
const char *dmmeta_Ns_ns_ssimfilt     = "ssimfilt";

const char *dmmeta_Ns_ns_strconv   = "strconv";
const char *dmmeta_Ns_ns_sv2ssim   = "sv2ssim";

// compile-time string constants for dmmeta.Nstype.nstype
const char *dmmeta_Nstype_nstype_exe   = "exe";
const char *dmmeta_Nstype_nstype_lib   = "lib";

const char *dmmeta_Nstype_nstype_none      = "none";
const char *dmmeta_Nstype_nstype_objlist   = "objlist";

const char *dmmeta_Nstype_nstype_pch        = "pch";
const char *dmmeta_Nstype_nstype_protocol   = "protocol";
const char *dmmeta_Nstype_nstype_ssimdb     = "ssimdb";

// compile-time string constants for dmmeta.Printfmt.printfmt
const char *dmmeta_Printfmt_printfmt_Auto         = "Auto";
const char *dmmeta_Printfmt_printfmt_Bitset       = "Bitset";
const char *dmmeta_Printfmt_printfmt_CompactSep   = "CompactSep";
const char *dmmeta_Printfmt_printfmt_Extern       = "Extern";
const char *dmmeta_Printfmt_printfmt_Raw          = "Raw";
const char *dmmeta_Printfmt_printfmt_Sep          = "Sep";
const char *dmmeta_Printfmt_printfmt_Tuple        = "Tuple";

// compile-time string constants for dmmeta.Reftype.reftype
const char *dmmeta_Reftype_reftype_Alias      = "Alias";
const char *dmmeta_Reftype_reftype_Atree      = "Atree";
const char *dmmeta_Reftype_reftype_Base       = "Base";
const char *dmmeta_Reftype_reftype_Bheap      = "Bheap";
const char *dmmeta_Reftype_reftype_Bitfld     = "Bitfld";
const char *dmmeta_Reftype_reftype_Blkpool    = "Blkpool";
const char *dmmeta_Reftype_reftype_Charset    = "Charset";
const char *dmmeta_Reftype_reftype_Count      = "Count";
const char *dmmeta_Reftype_reftype_Cppstack   = "Cppstack";
const char *dmmeta_Reftype_reftype_Delptr     = "Delptr";
const char *dmmeta_Reftype_reftype_Exec       = "Exec";
const char *dmmeta_Reftype_reftype_Fbuf       = "Fbuf";
const char *dmmeta_Reftype_reftype_Global     = "Global";
const char *dmmeta_Reftype_reftype_Hook       = "Hook";
const char *dmmeta_Reftype_reftype_Inlary     = "Inlary";
const char *dmmeta_Reftype_reftype_Lary       = "Lary";
const char *dmmeta_Reftype_reftype_Llist      = "Llist";
const char *dmmeta_Reftype_reftype_Lpool      = "Lpool";
const char *dmmeta_Reftype_reftype_Malloc     = "Malloc";
const char *dmmeta_Reftype_reftype_Opt        = "Opt";
const char *dmmeta_Reftype_reftype_Pkey       = "Pkey";
const char *dmmeta_Reftype_reftype_Protocol   = "Protocol";
const char *dmmeta_Reftype_reftype_Ptr        = "Ptr";
const char *dmmeta_Reftype_reftype_Ptrary     = "Ptrary";

const char *dmmeta_Reftype_reftype_Regx      = "Regx";
const char *dmmeta_Reftype_reftype_RegxSql   = "RegxSql";
const char *dmmeta_Reftype_reftype_Sbrk      = "Sbrk";

const char *dmmeta_Reftype_reftype_Smallstr   = "Smallstr";
const char *dmmeta_Reftype_reftype_Tary       = "Tary";
const char *dmmeta_Reftype_reftype_Thash      = "Thash";
const char *dmmeta_Reftype_reftype_Tpool      = "Tpool";
const char *dmmeta_Reftype_reftype_Upptr      = "Upptr";
const char *dmmeta_Reftype_reftype_Val        = "Val";
const char *dmmeta_Reftype_reftype_Varlen     = "Varlen";
const char *dmmeta_Reftype_reftype_ZSListMT   = "ZSListMT";

// compile-time string constants for dmmeta.Sorttype.sorttype
const char *dmmeta_Sorttype_sorttype_QuickSort       = "QuickSort";
const char *dmmeta_Sorttype_sorttype_InsertionSort   = "InsertionSort";
const char *dmmeta_Sorttype_sorttype_HeapSort        = "HeapSort";

// compile-time string constants for dmmeta.Ssimfile.ssimfile
const char *dmmeta_Ssimfile_ssimfile_amcdb_bltin      = "amcdb.bltin";
const char *dmmeta_Ssimfile_ssimfile_amcdb_curstype   = "amcdb.curstype";
const char *dmmeta_Ssimfile_ssimfile_amcdb_gen        = "amcdb.gen";
const char *dmmeta_Ssimfile_ssimfile_amcdb_regxtype   = "amcdb.regxtype";

const char *dmmeta_Ssimfile_ssimfile_amcdb_tclass       = "amcdb.tclass";
const char *dmmeta_Ssimfile_ssimfile_amcdb_tcurs        = "amcdb.tcurs";
const char *dmmeta_Ssimfile_ssimfile_amcdb_tfunc        = "amcdb.tfunc";
const char *dmmeta_Ssimfile_ssimfile_amsdb_proctype     = "amsdb.proctype";
const char *dmmeta_Ssimfile_ssimfile_amsdb_streamtype   = "amsdb.streamtype";
const char *dmmeta_Ssimfile_ssimfile_atfdb_amctest      = "atfdb.amctest";
const char *dmmeta_Ssimfile_ssimfile_atfdb_cijob        = "atfdb.cijob";

const char *dmmeta_Ssimfile_ssimfile_atfdb_citest     = "atfdb.citest";
const char *dmmeta_Ssimfile_ssimfile_atfdb_comptest   = "atfdb.comptest";

const char *dmmeta_Ssimfile_ssimfile_atfdb_fuzzstrat             = "atfdb.fuzzstrat";
const char *dmmeta_Ssimfile_ssimfile_atfdb_msgdir                = "atfdb.msgdir";
const char *dmmeta_Ssimfile_ssimfile_atfdb_targs                 = "atfdb.targs";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_char     = "atfdb.test_gsymbol_char";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_pkey     = "atfdb.test_gsymbol_pkey";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_strptr   = "atfdb.test_gsymbol_strptr";
const char *dmmeta_Ssimfile_ssimfile_atfdb_tfilt                 = "atfdb.tfilt";
const char *dmmeta_Ssimfile_ssimfile_atfdb_tmsg                  = "atfdb.tmsg";
const char *dmmeta_Ssimfile_ssimfile_atfdb_unittest              = "atfdb.unittest";
const char *dmmeta_Ssimfile_ssimfile_dev_arch                    = "dev.arch";
const char *dmmeta_Ssimfile_ssimfile_dev_badline                 = "dev.badline";
const char *dmmeta_Ssimfile_ssimfile_dev_builddir                = "dev.builddir";
const char *dmmeta_Ssimfile_ssimfile_dev_cfg                     = "dev.cfg";
const char *dmmeta_Ssimfile_ssimfile_dev_compiler                = "dev.compiler";
const char *dmmeta_Ssimfile_ssimfile_dev_covfile                 = "dev.covfile";
const char *dmmeta_Ssimfile_ssimfile_dev_covline                 = "dev.covline";
const char *dmmeta_Ssimfile_ssimfile_dev_covtarget               = "dev.covtarget";
const char *dmmeta_Ssimfile_ssimfile_dev_edaction                = "dev.edaction";
const char *dmmeta_Ssimfile_ssimfile_dev_edacttype               = "dev.edacttype";
const char *dmmeta_Ssimfile_ssimfile_dev_gitfile                 = "dev.gitfile";
const char *dmmeta_Ssimfile_ssimfile_dev_gitinfo                 = "dev.gitinfo";
const char *dmmeta_Ssimfile_ssimfile_dev_hilite                  = "dev.hilite";
const char *dmmeta_Ssimfile_ssimfile_dev_htmlentity              = "dev.htmlentity";
const char *dmmeta_Ssimfile_ssimfile_dev_include                 = "dev.include";
const char *dmmeta_Ssimfile_ssimfile_dev_license                 = "dev.license";
const char *dmmeta_Ssimfile_ssimfile_dev_linelim                 = "dev.linelim";
const char *dmmeta_Ssimfile_ssimfile_dev_mdsection               = "dev.mdsection";
const char *dmmeta_Ssimfile_ssimfile_dev_msgfile                 = "dev.msgfile";
const char *dmmeta_Ssimfile_ssimfile_dev_noindent                = "dev.noindent";
const char *dmmeta_Ssimfile_ssimfile_dev_opt_type                = "dev.opt_type";
const char *dmmeta_Ssimfile_ssimfile_dev_readme                  = "dev.readme";
const char *dmmeta_Ssimfile_ssimfile_dev_readmens                = "dev.readmens";
const char *dmmeta_Ssimfile_ssimfile_dev_sandbox                 = "dev.sandbox";

const char *dmmeta_Ssimfile_ssimfile_dev_sbpath            = "dev.sbpath";
const char *dmmeta_Ssimfile_ssimfile_dev_scriptfile        = "dev.scriptfile";
const char *dmmeta_Ssimfile_ssimfile_dev_srcfile           = "dev.srcfile";
const char *dmmeta_Ssimfile_ssimfile_dev_ssimfs            = "dev.ssimfs";
const char *dmmeta_Ssimfile_ssimfile_dev_syscmd            = "dev.syscmd";
const char *dmmeta_Ssimfile_ssimfile_dev_syscmddep         = "dev.syscmddep";
const char *dmmeta_Ssimfile_ssimfile_dev_syslib            = "dev.syslib";
const char *dmmeta_Ssimfile_ssimfile_dev_targdep           = "dev.targdep";
const char *dmmeta_Ssimfile_ssimfile_dev_target            = "dev.target";
const char *dmmeta_Ssimfile_ssimfile_dev_targsrc           = "dev.targsrc";
const char *dmmeta_Ssimfile_ssimfile_dev_targsyslib        = "dev.targsyslib";
const char *dmmeta_Ssimfile_ssimfile_dev_tgtcov            = "dev.tgtcov";
const char *dmmeta_Ssimfile_ssimfile_dev_timefmt           = "dev.timefmt";
const char *dmmeta_Ssimfile_ssimfile_dev_tool_opt          = "dev.tool_opt";
const char *dmmeta_Ssimfile_ssimfile_dev_uname             = "dev.uname";
const char *dmmeta_Ssimfile_ssimfile_dev_unstablefld       = "dev.unstablefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_anonfld        = "dmmeta.anonfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_argvtype       = "dmmeta.argvtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_basepool       = "dmmeta.basepool";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_bitfld         = "dmmeta.bitfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cafter         = "dmmeta.cafter";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cascdel        = "dmmeta.cascdel";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ccmp           = "dmmeta.ccmp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cdflt          = "dmmeta.cdflt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cextern        = "dmmeta.cextern";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cfmt           = "dmmeta.cfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cget           = "dmmeta.cget";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_charset        = "dmmeta.charset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_chash          = "dmmeta.chash";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cppfunc        = "dmmeta.cppfunc";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cppkeyword     = "dmmeta.cppkeyword";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cpptype        = "dmmeta.cpptype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_csize          = "dmmeta.csize";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cstr           = "dmmeta.cstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ctype          = "dmmeta.ctype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ctypelen       = "dmmeta.ctypelen";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispatch       = "dmmeta.dispatch";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispatch_msg   = "dmmeta.dispatch_msg";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispctx        = "dmmeta.dispctx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispfilter     = "dmmeta.dispfilter";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispsig        = "dmmeta.dispsig";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispsigcheck   = "dmmeta.dispsigcheck";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_disptrace      = "dmmeta.disptrace";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_falias         = "dmmeta.falias";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbase          = "dmmeta.fbase";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbigend        = "dmmeta.fbigend";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbitset        = "dmmeta.fbitset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbuf           = "dmmeta.fbuf";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbufdir        = "dmmeta.fbufdir";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbuftype   = "dmmeta.fbuftype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcast      = "dmmeta.fcast";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcleanup   = "dmmeta.fcleanup";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmap      = "dmmeta.fcmap";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmdline   = "dmmeta.fcmdline";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmp          = "dmmeta.fcmp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcompact      = "dmmeta.fcompact";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fconst        = "dmmeta.fconst";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcurs         = "dmmeta.fcurs";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fdec          = "dmmeta.fdec";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fdelay        = "dmmeta.fdelay";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fflag         = "dmmeta.fflag";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_field         = "dmmeta.field";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_findrem       = "dmmeta.findrem";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_finput        = "dmmeta.finput";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fldoffset     = "dmmeta.fldoffset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_floadtuples   = "dmmeta.floadtuples";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fnoremove     = "dmmeta.fnoremove";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_foutput       = "dmmeta.foutput";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fprefix       = "dmmeta.fprefix";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fregx         = "dmmeta.fregx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fsort         = "dmmeta.fsort";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fstep         = "dmmeta.fstep";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ftrace        = "dmmeta.ftrace";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ftuple        = "dmmeta.ftuple";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_func          = "dmmeta.func";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_funique       = "dmmeta.funique";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fuserinit     = "dmmeta.fuserinit";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fwddecl       = "dmmeta.fwddecl";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gconst        = "dmmeta.gconst";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gstatic       = "dmmeta.gstatic";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gsymbol       = "dmmeta.gsymbol";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_hashtype      = "dmmeta.hashtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_hook          = "dmmeta.hook";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_inlary        = "dmmeta.inlary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_lenfld        = "dmmeta.lenfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_listtype      = "dmmeta.listtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_llist         = "dmmeta.llist";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_logcat        = "dmmeta.logcat";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_main          = "dmmeta.main";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_msgtype       = "dmmeta.msgtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nocascdel     = "dmmeta.nocascdel";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nossimfile    = "dmmeta.nossimfile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_noxref        = "dmmeta.noxref";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ns            = "dmmeta.ns";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nscpp         = "dmmeta.nscpp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsdb          = "dmmeta.nsdb";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsinclude     = "dmmeta.nsinclude";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsproto   = "dmmeta.nsproto";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nstype   = "dmmeta.nstype";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsversion   = "dmmeta.nsversion";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsx         = "dmmeta.nsx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_numstr      = "dmmeta.numstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pack        = "dmmeta.pack";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld    = "dmmeta.pmaskfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pnew        = "dmmeta.pnew";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pnewtype    = "dmmeta.pnewtype";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_printfmt       = "dmmeta.printfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ptrary         = "dmmeta.ptrary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_reftype        = "dmmeta.reftype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_rowid          = "dmmeta.rowid";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_smallstr       = "dmmeta.smallstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sortfld        = "dmmeta.sortfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sorttype       = "dmmeta.sorttype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sqltype        = "dmmeta.sqltype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimfile       = "dmmeta.ssimfile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimreq        = "dmmeta.ssimreq";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimsort       = "dmmeta.ssimsort";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimvolatile   = "dmmeta.ssimvolatile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_steptype       = "dmmeta.steptype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_strfmt         = "dmmeta.strfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_strtype        = "dmmeta.strtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_substr         = "dmmeta.substr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_svtype         = "dmmeta.svtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tary           = "dmmeta.tary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_thash          = "dmmeta.thash";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tracefld       = "dmmeta.tracefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tracerec       = "dmmeta.tracerec";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_typefld        = "dmmeta.typefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_usertracefld   = "dmmeta.usertracefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_xref           = "dmmeta.xref";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alarm            = "fmdb.alarm";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_code         = "fmdb.alm_code";

const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_objtype    = "fmdb.alm_objtype";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_source     = "fmdb.alm_source";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gact         = "gclidb.gact";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gatv         = "gclidb.gatv";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmd      = "gclidb.gclicmd";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmdf2j   = "gclidb.gclicmdf2j";

const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmdt        = "gclidb.gclicmdt";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclienv         = "gclidb.gclienv";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclienvsub      = "gclidb.gclienvsub";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclisub         = "gclidb.gclisub";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gfld            = "gclidb.gfld";
const char *dmmeta_Ssimfile_ssimfile_gclidb_githost         = "gclidb.githost";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gmethod         = "gclidb.gmethod";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepo           = "gclidb.grepo";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepogitport    = "gclidb.grepogitport";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepossh        = "gclidb.grepossh";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gstate          = "gclidb.gstate";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gstatet         = "gclidb.gstatet";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtbl            = "gclidb.gtbl";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblact         = "gclidb.gtblact";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblactfld      = "gclidb.gtblactfld";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblacttst      = "gclidb.gtblacttst";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblacttstout   = "gclidb.gtblacttstout";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtype           = "gclidb.gtype";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtypeh          = "gclidb.gtypeh";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtypeprefix     = "gclidb.gtypeprefix";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issue           = "gclidb.issue";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issuenote       = "gclidb.issuenote";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issuepipeline   = "gclidb.issuepipeline";
const char *dmmeta_Ssimfile_ssimfile_gclidb_label           = "gclidb.label";
const char *dmmeta_Ssimfile_ssimfile_gclidb_milestone       = "gclidb.milestone";
const char *dmmeta_Ssimfile_ssimfile_gclidb_mr              = "gclidb.mr";
const char *dmmeta_Ssimfile_ssimfile_gclidb_mrjob           = "gclidb.mrjob";

const char *dmmeta_Ssimfile_ssimfile_gclidb_mrnote    = "gclidb.mrnote";
const char *dmmeta_Ssimfile_ssimfile_gclidb_project   = "gclidb.project";
const char *dmmeta_Ssimfile_ssimfile_gclidb_user      = "gclidb.user";

// compile-time string constants for dmmeta.Steptype.steptype
const char *dmmeta_Steptype_steptype_Callback        = "Callback";
const char *dmmeta_Steptype_steptype_Extern          = "Extern";
const char *dmmeta_Steptype_steptype_Inline          = "Inline";
const char *dmmeta_Steptype_steptype_InlineOnce      = "InlineOnce";
const char *dmmeta_Steptype_steptype_InlineRecur     = "InlineRecur";
const char *dmmeta_Steptype_steptype_TimeHookRecur   = "TimeHookRecur";

// compile-time string constants for dmmeta.Strfmt.strfmt
const char *dmmeta_Strfmt_strfmt_Argv      = "Argv";
const char *dmmeta_Strfmt_strfmt_ArgvGnu   = "ArgvGnu";
const char *dmmeta_Strfmt_strfmt_Json      = "Json";
const char *dmmeta_Strfmt_strfmt_String    = "String";
const char *dmmeta_Strfmt_strfmt_Tuple     = "Tuple";

// compile-time string constants for dmmeta.Strtype.strtype
const char *dmmeta_Strtype_strtype_rpascal    = "rpascal";
const char *dmmeta_Strtype_strtype_rightpad   = "rightpad";
const char *dmmeta_Strtype_strtype_leftpad    = "leftpad";

namespace dmmeta { // gen:ns_print_proto
    static void          SizeCheck();
} // gen:ns_print_proto

// --- dmmeta.Anonfld..ReadFieldMaybe
bool dmmeta::Anonfld_ReadFieldMaybe(dmmeta::Anonfld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Anonfld..ReadStrptrMaybe
// Read fields of dmmeta::Anonfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Anonfld_ReadStrptrMaybe(dmmeta::Anonfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.anonfld") || algo::StripTypeTag(in_str, "dmmeta.Anonfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Anonfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Anonfld..Print
// print string representation of dmmeta::Anonfld to string LHS, no header -- cprint:dmmeta.Anonfld.String
void dmmeta::Anonfld_Print(dmmeta::Anonfld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.anonfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Argvtype..ReadFieldMaybe
bool dmmeta::Argvtype_ReadFieldMaybe(dmmeta::Argvtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_argvtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.argvtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Argvtype..ReadStrptrMaybe
// Read fields of dmmeta::Argvtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Argvtype_ReadStrptrMaybe(dmmeta::Argvtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.argvtype") || algo::StripTypeTag(in_str, "dmmeta.Argvtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Argvtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Argvtype..Print
// print string representation of dmmeta::Argvtype to string LHS, no header -- cprint:dmmeta.Argvtype.String
void dmmeta::Argvtype_Print(dmmeta::Argvtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.argvtype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr50_Print(row.argvtype, temp);
    PrintAttrSpaceReset(str,"argvtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Basepool..ReadFieldMaybe
bool dmmeta::Basepool_ReadFieldMaybe(dmmeta::Basepool &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_base: retval = algo::Smallstr100_ReadStrptrMaybe(parent.base, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Basepool..ReadStrptrMaybe
// Read fields of dmmeta::Basepool from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Basepool_ReadStrptrMaybe(dmmeta::Basepool &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.basepool") || algo::StripTypeTag(in_str, "dmmeta.Basepool");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Basepool_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Basepool..Print
// print string representation of dmmeta::Basepool to string LHS, no header -- cprint:dmmeta.Basepool.String
void dmmeta::Basepool_Print(dmmeta::Basepool & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.basepool";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.base, temp);
    PrintAttrSpaceReset(str,"base", temp);
}

// --- dmmeta.Bitfld.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Bitfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Bitfld.name.Get2
algo::Smallstr50 dmmeta::Bitfld_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Bitfld..ReadFieldMaybe
bool dmmeta::Bitfld_ReadFieldMaybe(dmmeta::Bitfld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_offset: retval = i32_ReadStrptrMaybe(parent.offset, strval); break;
        case dmmeta_FieldId_width: retval = i32_ReadStrptrMaybe(parent.width, strval); break;
        case dmmeta_FieldId_srcfield: retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Bitfld..ReadStrptrMaybe
// Read fields of dmmeta::Bitfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Bitfld_ReadStrptrMaybe(dmmeta::Bitfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.bitfld") || algo::StripTypeTag(in_str, "dmmeta.Bitfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Bitfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Bitfld..Print
// print string representation of dmmeta::Bitfld to string LHS, no header -- cprint:dmmeta.Bitfld.String
void dmmeta::Bitfld_Print(dmmeta::Bitfld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.bitfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.offset, temp);
    PrintAttrSpaceReset(str,"offset", temp);

    i32_Print(row.width, temp);
    PrintAttrSpaceReset(str,"width", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Buftype..ReadFieldMaybe
bool dmmeta::Buftype_ReadFieldMaybe(dmmeta::Buftype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_pnewtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.pnewtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Buftype..ReadStrptrMaybe
// Read fields of dmmeta::Buftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Buftype_ReadStrptrMaybe(dmmeta::Buftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pnewtype") || algo::StripTypeTag(in_str, "dmmeta.Buftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Buftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Buftype..Print
// print string representation of dmmeta::Buftype to string LHS, no header -- cprint:dmmeta.Buftype.String
void dmmeta::Buftype_Print(dmmeta::Buftype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.pnewtype";

    algo::Smallstr50_Print(row.pnewtype, temp);
    PrintAttrSpaceReset(str,"pnewtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cafter.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Cafter& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.cafter, "/RL"));
    return ret;
}

// --- dmmeta.Cafter.ctype.Get2
algo::Smallstr50 dmmeta::Cafter_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Cafter.after.Get
algo::Smallstr50 dmmeta::after_Get(dmmeta::Cafter& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.cafter, "/RR"));
    return ret;
}

// --- dmmeta.Cafter.after.Get2
algo::Smallstr50 dmmeta::Cafter_after_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Cafter..Concat_ctype_after
tempstr dmmeta::Cafter_Concat_ctype_after( const algo::strptr& ctype ,const algo::strptr& after ) {
    return tempstr() << ctype <<'/'<< after ;
}

// --- dmmeta.Cafter..ReadFieldMaybe
bool dmmeta::Cafter_ReadFieldMaybe(dmmeta::Cafter &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_cafter: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cafter, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_after: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cafter..ReadStrptrMaybe
// Read fields of dmmeta::Cafter from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cafter_ReadStrptrMaybe(dmmeta::Cafter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cafter") || algo::StripTypeTag(in_str, "dmmeta.Cafter");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cafter_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cafter..Print
// print string representation of dmmeta::Cafter to string LHS, no header -- cprint:dmmeta.Cafter.String
void dmmeta::Cafter_Print(dmmeta::Cafter & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cafter";

    algo::Smallstr50_Print(row.cafter, temp);
    PrintAttrSpaceReset(str,"cafter", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cascdel..ReadFieldMaybe
bool dmmeta::Cascdel_ReadFieldMaybe(dmmeta::Cascdel &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cascdel..ReadStrptrMaybe
// Read fields of dmmeta::Cascdel from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cascdel_ReadStrptrMaybe(dmmeta::Cascdel &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cascdel") || algo::StripTypeTag(in_str, "dmmeta.Cascdel");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cascdel_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cascdel..Print
// print string representation of dmmeta::Cascdel to string LHS, no header -- cprint:dmmeta.Cascdel.String
void dmmeta::Cascdel_Print(dmmeta::Cascdel & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cascdel";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ccmp..ReadFieldMaybe
bool dmmeta::Ccmp_ReadFieldMaybe(dmmeta::Ccmp &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_extrn: retval = bool_ReadStrptrMaybe(parent.extrn, strval); break;
        case dmmeta_FieldId_genop: retval = bool_ReadStrptrMaybe(parent.genop, strval); break;
        case dmmeta_FieldId_order: retval = bool_ReadStrptrMaybe(parent.order, strval); break;
        case dmmeta_FieldId_minmax: retval = bool_ReadStrptrMaybe(parent.minmax, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ccmp..ReadStrptrMaybe
// Read fields of dmmeta::Ccmp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ccmp_ReadStrptrMaybe(dmmeta::Ccmp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ccmp") || algo::StripTypeTag(in_str, "dmmeta.Ccmp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ccmp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ccmp..Print
// print string representation of dmmeta::Ccmp to string LHS, no header -- cprint:dmmeta.Ccmp.String
void dmmeta::Ccmp_Print(dmmeta::Ccmp & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ccmp";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.genop, temp);
    PrintAttrSpaceReset(str,"genop", temp);

    bool_Print(row.order, temp);
    PrintAttrSpaceReset(str,"order", temp);

    bool_Print(row.minmax, temp);
    PrintAttrSpaceReset(str,"minmax", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cdflt..ReadFieldMaybe
bool dmmeta::Cdflt_ReadFieldMaybe(dmmeta::Cdflt &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_dflt: retval = algo::CppExpr_ReadStrptrMaybe(parent.dflt, strval); break;
        case dmmeta_FieldId_cppdflt: retval = algo::CppExpr_ReadStrptrMaybe(parent.cppdflt, strval); break;
        case dmmeta_FieldId_ssimdflt: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimdflt, strval); break;
        case dmmeta_FieldId_jsdflt: retval = algo::Smallstr50_ReadStrptrMaybe(parent.jsdflt, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cdflt..ReadStrptrMaybe
// Read fields of dmmeta::Cdflt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cdflt_ReadStrptrMaybe(dmmeta::Cdflt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cdflt") || algo::StripTypeTag(in_str, "dmmeta.Cdflt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cdflt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cdflt..Print
// print string representation of dmmeta::Cdflt to string LHS, no header -- cprint:dmmeta.Cdflt.String
void dmmeta::Cdflt_Print(dmmeta::Cdflt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cdflt";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::CppExpr_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::CppExpr_Print(row.cppdflt, temp);
    PrintAttrSpaceReset(str,"cppdflt", temp);

    algo::Smallstr50_Print(row.ssimdflt, temp);
    PrintAttrSpaceReset(str,"ssimdflt", temp);

    algo::Smallstr50_Print(row.jsdflt, temp);
    PrintAttrSpaceReset(str,"jsdflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cextern..ReadFieldMaybe
bool dmmeta::Cextern_ReadFieldMaybe(dmmeta::Cextern &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_initmemset: retval = bool_ReadStrptrMaybe(parent.initmemset, strval); break;
        case dmmeta_FieldId_isstruct: retval = bool_ReadStrptrMaybe(parent.isstruct, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cextern..ReadStrptrMaybe
// Read fields of dmmeta::Cextern from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cextern_ReadStrptrMaybe(dmmeta::Cextern &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cextern") || algo::StripTypeTag(in_str, "dmmeta.Cextern");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cextern_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cextern..Print
// print string representation of dmmeta::Cextern to string LHS, no header -- cprint:dmmeta.Cextern.String
void dmmeta::Cextern_Print(dmmeta::Cextern & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cextern";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.initmemset, temp);
    PrintAttrSpaceReset(str,"initmemset", temp);

    bool_Print(row.isstruct, temp);
    PrintAttrSpaceReset(str,"isstruct", temp);
}

// --- dmmeta.Cfmt.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Cfmt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.cfmt, ".RL"));
    return ret;
}

// --- dmmeta.Cfmt.ctype.Get2
algo::Smallstr50 dmmeta::Cfmt_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Cfmt.strfmt.Get
algo::Smallstr50 dmmeta::strfmt_Get(dmmeta::Cfmt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.cfmt, ".RR"));
    return ret;
}

// --- dmmeta.Cfmt.strfmt.Get2
algo::Smallstr50 dmmeta::Cfmt_strfmt_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Cfmt..Concat_ctype_strfmt
tempstr dmmeta::Cfmt_Concat_ctype_strfmt( const algo::strptr& ctype ,const algo::strptr& strfmt ) {
    return tempstr() << ctype <<'.'<< strfmt ;
}

// --- dmmeta.Cfmt..ReadFieldMaybe
bool dmmeta::Cfmt_ReadFieldMaybe(dmmeta::Cfmt &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_cfmt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.cfmt, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_strfmt: retval = false; break;
        case dmmeta_FieldId_printfmt: retval = algo::Smallstr50_ReadStrptrMaybe(parent.printfmt, strval); break;
        case dmmeta_FieldId_read: retval = bool_ReadStrptrMaybe(parent.read, strval); break;
        case dmmeta_FieldId_print: retval = bool_ReadStrptrMaybe(parent.print, strval); break;
        case dmmeta_FieldId_sep: retval = algo::Smallstr20_ReadStrptrMaybe(parent.sep, strval); break;
        case dmmeta_FieldId_genop: retval = bool_ReadStrptrMaybe(parent.genop, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cfmt..ReadStrptrMaybe
// Read fields of dmmeta::Cfmt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cfmt_ReadStrptrMaybe(dmmeta::Cfmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cfmt") || algo::StripTypeTag(in_str, "dmmeta.Cfmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cfmt..Print
// print string representation of dmmeta::Cfmt to string LHS, no header -- cprint:dmmeta.Cfmt.String
void dmmeta::Cfmt_Print(dmmeta::Cfmt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cfmt";

    algo::Smallstr100_Print(row.cfmt, temp);
    PrintAttrSpaceReset(str,"cfmt", temp);

    algo::Smallstr50_Print(row.printfmt, temp);
    PrintAttrSpaceReset(str,"printfmt", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    bool_Print(row.print, temp);
    PrintAttrSpaceReset(str,"print", temp);

    algo::Smallstr20_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    bool_Print(row.genop, temp);
    PrintAttrSpaceReset(str,"genop", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cget..ReadFieldMaybe
bool dmmeta::Cget_ReadFieldMaybe(dmmeta::Cget &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cget..ReadStrptrMaybe
// Read fields of dmmeta::Cget from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cget_ReadStrptrMaybe(dmmeta::Cget &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cget") || algo::StripTypeTag(in_str, "dmmeta.Cget");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cget_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cget..Print
// print string representation of dmmeta::Cget to string LHS, no header -- cprint:dmmeta.Cget.String
void dmmeta::Cget_Print(dmmeta::Cget & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cget";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Charset..ReadFieldMaybe
bool dmmeta::Charset_ReadFieldMaybe(dmmeta::Charset &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_expr: retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval); break;
        case dmmeta_FieldId_charrange: retval = bool_ReadStrptrMaybe(parent.charrange, strval); break;
        case dmmeta_FieldId_calc: retval = bool_ReadStrptrMaybe(parent.calc, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Charset..ReadStrptrMaybe
// Read fields of dmmeta::Charset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Charset_ReadStrptrMaybe(dmmeta::Charset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.charset") || algo::StripTypeTag(in_str, "dmmeta.Charset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Charset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Charset..Print
// print string representation of dmmeta::Charset to string LHS, no header -- cprint:dmmeta.Charset.String
void dmmeta::Charset_Print(dmmeta::Charset & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.charset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    bool_Print(row.charrange, temp);
    PrintAttrSpaceReset(str,"charrange", temp);

    bool_Print(row.calc, temp);
    PrintAttrSpaceReset(str,"calc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Chash..ReadFieldMaybe
bool dmmeta::Chash_ReadFieldMaybe(dmmeta::Chash &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_hashtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.hashtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Chash..ReadStrptrMaybe
// Read fields of dmmeta::Chash from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Chash_ReadStrptrMaybe(dmmeta::Chash &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.chash") || algo::StripTypeTag(in_str, "dmmeta.Chash");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Chash_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Chash..Print
// print string representation of dmmeta::Chash to string LHS, no header -- cprint:dmmeta.Chash.String
void dmmeta::Chash_Print(dmmeta::Chash & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.chash";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr50_Print(row.hashtype, temp);
    PrintAttrSpaceReset(str,"hashtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cppfunc..ReadFieldMaybe
bool dmmeta::Cppfunc_ReadFieldMaybe(dmmeta::Cppfunc &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_expr: retval = algo::CppExpr_ReadStrptrMaybe(parent.expr, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cppfunc..ReadStrptrMaybe
// Read fields of dmmeta::Cppfunc from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cppfunc_ReadStrptrMaybe(dmmeta::Cppfunc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cppfunc") || algo::StripTypeTag(in_str, "dmmeta.Cppfunc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cppfunc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cppfunc..Print
// print string representation of dmmeta::Cppfunc to string LHS, no header -- cprint:dmmeta.Cppfunc.String
void dmmeta::Cppfunc_Print(dmmeta::Cppfunc & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cppfunc";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);
}

// --- dmmeta.Cppkeyword..ReadFieldMaybe
bool dmmeta::Cppkeyword_ReadFieldMaybe(dmmeta::Cppkeyword &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_cppkeyword: retval = algo::Smallstr20_ReadStrptrMaybe(parent.cppkeyword, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cppkeyword..ReadStrptrMaybe
// Read fields of dmmeta::Cppkeyword from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cppkeyword_ReadStrptrMaybe(dmmeta::Cppkeyword &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cppkeyword") || algo::StripTypeTag(in_str, "dmmeta.Cppkeyword");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cppkeyword_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cppkeyword..Print
// print string representation of dmmeta::Cppkeyword to string LHS, no header -- cprint:dmmeta.Cppkeyword.String
void dmmeta::Cppkeyword_Print(dmmeta::Cppkeyword & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cppkeyword";

    algo::Smallstr20_Print(row.cppkeyword, temp);
    PrintAttrSpaceReset(str,"cppkeyword", temp);
}

// --- dmmeta.Cpptype..ReadFieldMaybe
bool dmmeta::Cpptype_ReadFieldMaybe(dmmeta::Cpptype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_ctor: retval = bool_ReadStrptrMaybe(parent.ctor, strval); break;
        case dmmeta_FieldId_dtor: retval = bool_ReadStrptrMaybe(parent.dtor, strval); break;
        case dmmeta_FieldId_cheap_copy: retval = bool_ReadStrptrMaybe(parent.cheap_copy, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cpptype..ReadStrptrMaybe
// Read fields of dmmeta::Cpptype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cpptype_ReadStrptrMaybe(dmmeta::Cpptype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cpptype") || algo::StripTypeTag(in_str, "dmmeta.Cpptype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cpptype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cpptype..Print
// print string representation of dmmeta::Cpptype to string LHS, no header -- cprint:dmmeta.Cpptype.String
void dmmeta::Cpptype_Print(dmmeta::Cpptype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cpptype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.ctor, temp);
    PrintAttrSpaceReset(str,"ctor", temp);

    bool_Print(row.dtor, temp);
    PrintAttrSpaceReset(str,"dtor", temp);

    bool_Print(row.cheap_copy, temp);
    PrintAttrSpaceReset(str,"cheap_copy", temp);
}

// --- dmmeta.Csize..ReadFieldMaybe
bool dmmeta::Csize_ReadFieldMaybe(dmmeta::Csize &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_size: retval = u32_ReadStrptrMaybe(parent.size, strval); break;
        case dmmeta_FieldId_alignment: retval = u32_ReadStrptrMaybe(parent.alignment, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Csize..ReadStrptrMaybe
// Read fields of dmmeta::Csize from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Csize_ReadStrptrMaybe(dmmeta::Csize &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.csize") || algo::StripTypeTag(in_str, "dmmeta.Csize");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Csize_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Csize..Print
// print string representation of dmmeta::Csize to string LHS, no header -- cprint:dmmeta.Csize.String
void dmmeta::Csize_Print(dmmeta::Csize & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.csize";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.size, temp);
    PrintAttrSpaceReset(str,"size", temp);

    u32_Print(row.alignment, temp);
    PrintAttrSpaceReset(str,"alignment", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cstr..ReadFieldMaybe
bool dmmeta::Cstr_ReadFieldMaybe(dmmeta::Cstr &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_strequiv: retval = bool_ReadStrptrMaybe(parent.strequiv, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cstr..ReadStrptrMaybe
// Read fields of dmmeta::Cstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cstr_ReadStrptrMaybe(dmmeta::Cstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cstr") || algo::StripTypeTag(in_str, "dmmeta.Cstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cstr..Print
// print string representation of dmmeta::Cstr to string LHS, no header -- cprint:dmmeta.Cstr.String
void dmmeta::Cstr_Print(dmmeta::Cstr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.cstr";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.strequiv, temp);
    PrintAttrSpaceReset(str,"strequiv", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ctype.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Ctype& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ctype, ".RL"));
    return ret;
}

// --- dmmeta.Ctype.ns.Get2
algo::Smallstr16 dmmeta::Ctype_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Ctype.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Ctype& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ctype, ".RR"));
    return ret;
}

// --- dmmeta.Ctype.name.Get2
algo::Smallstr50 dmmeta::Ctype_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Ctype..Concat_ns_name
tempstr dmmeta::Ctype_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Ctype..ReadFieldMaybe
bool dmmeta::Ctype_ReadFieldMaybe(dmmeta::Ctype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ctype..ReadStrptrMaybe
// Read fields of dmmeta::Ctype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ctype_ReadStrptrMaybe(dmmeta::Ctype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ctype") || algo::StripTypeTag(in_str, "dmmeta.Ctype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ctype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ctype..Print
// print string representation of dmmeta::Ctype to string LHS, no header -- cprint:dmmeta.Ctype.String
void dmmeta::Ctype_Print(dmmeta::Ctype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ctype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ctypelen..ReadFieldMaybe
bool dmmeta::Ctypelen_ReadFieldMaybe(dmmeta::Ctypelen &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_len: retval = u32_ReadStrptrMaybe(parent.len, strval); break;
        case dmmeta_FieldId_alignment: retval = i32_ReadStrptrMaybe(parent.alignment, strval); break;
        case dmmeta_FieldId_padbytes: retval = i32_ReadStrptrMaybe(parent.padbytes, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ctypelen..ReadStrptrMaybe
// Read fields of dmmeta::Ctypelen from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ctypelen_ReadStrptrMaybe(dmmeta::Ctypelen &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ctypelen") || algo::StripTypeTag(in_str, "dmmeta.Ctypelen");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ctypelen_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ctypelen..Print
// print string representation of dmmeta::Ctypelen to string LHS, no header -- cprint:dmmeta.Ctypelen.String
void dmmeta::Ctypelen_Print(dmmeta::Ctypelen & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ctypelen";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.len, temp);
    PrintAttrSpaceReset(str,"len", temp);

    i32_Print(row.alignment, temp);
    PrintAttrSpaceReset(str,"alignment", temp);

    i32_Print(row.padbytes, temp);
    PrintAttrSpaceReset(str,"padbytes", temp);
}

// --- dmmeta.Dispatch.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Dispatch& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.dispatch, ".RL"));
    return ret;
}

// --- dmmeta.Dispatch.ns.Get2
algo::Smallstr16 dmmeta::Dispatch_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Dispatch.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Dispatch& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispatch, ".RR"));
    return ret;
}

// --- dmmeta.Dispatch.name.Get2
algo::Smallstr50 dmmeta::Dispatch_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Dispatch..Concat_ns_name
tempstr dmmeta::Dispatch_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Dispatch..ReadFieldMaybe
bool dmmeta::Dispatch_ReadFieldMaybe(dmmeta::Dispatch &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispatch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_unk: retval = bool_ReadStrptrMaybe(parent.unk, strval); break;
        case dmmeta_FieldId_read: retval = bool_ReadStrptrMaybe(parent.read, strval); break;
        case dmmeta_FieldId_print: retval = bool_ReadStrptrMaybe(parent.print, strval); break;
        case dmmeta_FieldId_haslen: retval = bool_ReadStrptrMaybe(parent.haslen, strval); break;
        case dmmeta_FieldId_call: retval = bool_ReadStrptrMaybe(parent.call, strval); break;
        case dmmeta_FieldId_strict: retval = bool_ReadStrptrMaybe(parent.strict, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispatch..ReadStrptrMaybe
// Read fields of dmmeta::Dispatch from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispatch_ReadStrptrMaybe(dmmeta::Dispatch &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispatch") || algo::StripTypeTag(in_str, "dmmeta.Dispatch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispatch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispatch..Init
// Set all fields to initial values.
void dmmeta::Dispatch_Init(dmmeta::Dispatch& parent) {
    parent.unk = bool(false);
    parent.read = bool(false);
    parent.print = bool(false);
    parent.haslen = bool(false);
    parent.call = bool(false);
    parent.strict = bool(false);
}

// --- dmmeta.Dispatch..Print
// print string representation of dmmeta::Dispatch to string LHS, no header -- cprint:dmmeta.Dispatch.String
void dmmeta::Dispatch_Print(dmmeta::Dispatch & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispatch";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.unk, temp);
    PrintAttrSpaceReset(str,"unk", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    bool_Print(row.print, temp);
    PrintAttrSpaceReset(str,"print", temp);

    bool_Print(row.haslen, temp);
    PrintAttrSpaceReset(str,"haslen", temp);

    bool_Print(row.call, temp);
    PrintAttrSpaceReset(str,"call", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.DispatchMsg.dispatch.Get
algo::Smallstr50 dmmeta::dispatch_Get(dmmeta::DispatchMsg& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispatch_msg, "/RL"));
    return ret;
}

// --- dmmeta.DispatchMsg.dispatch.Get2
algo::Smallstr50 dmmeta::DispatchMsg_dispatch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.DispatchMsg.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::DispatchMsg& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispatch_msg, "/RR"));
    return ret;
}

// --- dmmeta.DispatchMsg.ctype.Get2
algo::Smallstr50 dmmeta::DispatchMsg_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.DispatchMsg..Concat_dispatch_ctype
tempstr dmmeta::DispatchMsg_Concat_dispatch_ctype( const algo::strptr& dispatch ,const algo::strptr& ctype ) {
    return tempstr() << dispatch <<'/'<< ctype ;
}

// --- dmmeta.DispatchMsg..ReadFieldMaybe
bool dmmeta::DispatchMsg_ReadFieldMaybe(dmmeta::DispatchMsg &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispatch_msg: retval = algo::Smallstr100_ReadStrptrMaybe(parent.dispatch_msg, strval); break;
        case dmmeta_FieldId_dispatch: retval = false; break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.DispatchMsg..ReadStrptrMaybe
// Read fields of dmmeta::DispatchMsg from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::DispatchMsg_ReadStrptrMaybe(dmmeta::DispatchMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispatch_msg") || algo::StripTypeTag(in_str, "dmmeta.DispatchMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DispatchMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.DispatchMsg..Print
// print string representation of dmmeta::DispatchMsg to string LHS, no header -- cprint:dmmeta.DispatchMsg.String
void dmmeta::DispatchMsg_Print(dmmeta::DispatchMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispatch_msg";

    algo::Smallstr100_Print(row.dispatch_msg, temp);
    PrintAttrSpaceReset(str,"dispatch_msg", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispctx..ReadFieldMaybe
bool dmmeta::Dispctx_ReadFieldMaybe(dmmeta::Dispctx &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispatch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval); break;
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispctx..ReadStrptrMaybe
// Read fields of dmmeta::Dispctx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispctx_ReadStrptrMaybe(dmmeta::Dispctx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispctx") || algo::StripTypeTag(in_str, "dmmeta.Dispctx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispctx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispctx..Print
// print string representation of dmmeta::Dispctx to string LHS, no header -- cprint:dmmeta.Dispctx.String
void dmmeta::Dispctx_Print(dmmeta::Dispctx & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispctx";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispfilter..ReadFieldMaybe
bool dmmeta::Dispfilter_ReadFieldMaybe(dmmeta::Dispfilter &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispatch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval); break;
        case dmmeta_FieldId_match_all: retval = bool_ReadStrptrMaybe(parent.match_all, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispfilter..ReadStrptrMaybe
// Read fields of dmmeta::Dispfilter from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispfilter_ReadStrptrMaybe(dmmeta::Dispfilter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispfilter") || algo::StripTypeTag(in_str, "dmmeta.Dispfilter");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispfilter_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispfilter..Print
// print string representation of dmmeta::Dispfilter to string LHS, no header -- cprint:dmmeta.Dispfilter.String
void dmmeta::Dispfilter_Print(dmmeta::Dispfilter & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispfilter";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.match_all, temp);
    PrintAttrSpaceReset(str,"match_all", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispsig.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Dispsig& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.dispsig, ".RL"));
    return ret;
}

// --- dmmeta.Dispsig.ns.Get2
algo::Smallstr16 dmmeta::Dispsig_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Dispsig.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Dispsig& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispsig, ".RR"));
    return ret;
}

// --- dmmeta.Dispsig.name.Get2
algo::Smallstr50 dmmeta::Dispsig_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Dispsig..Concat_ns_name
tempstr dmmeta::Dispsig_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Dispsig..ReadFieldMaybe
bool dmmeta::Dispsig_ReadFieldMaybe(dmmeta::Dispsig &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispsig: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispsig, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_signature: retval = algo::Sha1sig_ReadStrptrMaybe(parent.signature, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispsig..ReadStrptrMaybe
// Read fields of dmmeta::Dispsig from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispsig_ReadStrptrMaybe(dmmeta::Dispsig &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispsig") || algo::StripTypeTag(in_str, "dmmeta.Dispsig");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispsig_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispsig..Print
// print string representation of dmmeta::Dispsig to string LHS, no header -- cprint:dmmeta.Dispsig.String
void dmmeta::Dispsig_Print(dmmeta::Dispsig & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispsig";

    algo::Smallstr50_Print(row.dispsig, temp);
    PrintAttrSpaceReset(str,"dispsig", temp);

    algo::Sha1sig_Print(row.signature, temp);
    PrintAttrSpaceReset(str,"signature", temp);
}

// --- dmmeta.Dispsigcheck..ReadFieldMaybe
bool dmmeta::Dispsigcheck_ReadFieldMaybe(dmmeta::Dispsigcheck &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispsig: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispsig, strval); break;
        case dmmeta_FieldId_signature: retval = algo::Sha1sig_ReadStrptrMaybe(parent.signature, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispsigcheck..ReadStrptrMaybe
// Read fields of dmmeta::Dispsigcheck from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispsigcheck_ReadStrptrMaybe(dmmeta::Dispsigcheck &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispsigcheck") || algo::StripTypeTag(in_str, "dmmeta.Dispsigcheck");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispsigcheck_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispsigcheck..Print
// print string representation of dmmeta::Dispsigcheck to string LHS, no header -- cprint:dmmeta.Dispsigcheck.String
void dmmeta::Dispsigcheck_Print(dmmeta::Dispsigcheck & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.dispsigcheck";

    algo::Smallstr50_Print(row.dispsig, temp);
    PrintAttrSpaceReset(str,"dispsig", temp);

    algo::Sha1sig_Print(row.signature, temp);
    PrintAttrSpaceReset(str,"signature", temp);
}

// --- dmmeta.Disptrace..ReadFieldMaybe
bool dmmeta::Disptrace_ReadFieldMaybe(dmmeta::Disptrace &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_dispatch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval); break;
        case dmmeta_FieldId_cycle: retval = bool_ReadStrptrMaybe(parent.cycle, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Disptrace..ReadStrptrMaybe
// Read fields of dmmeta::Disptrace from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Disptrace_ReadStrptrMaybe(dmmeta::Disptrace &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.disptrace") || algo::StripTypeTag(in_str, "dmmeta.Disptrace");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Disptrace_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Disptrace..Print
// print string representation of dmmeta::Disptrace to string LHS, no header -- cprint:dmmeta.Disptrace.String
void dmmeta::Disptrace_Print(dmmeta::Disptrace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.disptrace";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.cycle, temp);
    PrintAttrSpaceReset(str,"cycle", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Falias..ReadFieldMaybe
bool dmmeta::Falias_ReadFieldMaybe(dmmeta::Falias &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_srcfield: retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Falias..ReadStrptrMaybe
// Read fields of dmmeta::Falias from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Falias_ReadStrptrMaybe(dmmeta::Falias &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.falias") || algo::StripTypeTag(in_str, "dmmeta.Falias");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Falias_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Falias..Print
// print string representation of dmmeta::Falias to string LHS, no header -- cprint:dmmeta.Falias.String
void dmmeta::Falias_Print(dmmeta::Falias & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.falias";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbase..ReadFieldMaybe
bool dmmeta::Fbase_ReadFieldMaybe(dmmeta::Fbase &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_stripcomment: retval = bool_ReadStrptrMaybe(parent.stripcomment, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbase..ReadStrptrMaybe
// Read fields of dmmeta::Fbase from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbase_ReadStrptrMaybe(dmmeta::Fbase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbase") || algo::StripTypeTag(in_str, "dmmeta.Fbase");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbase_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbase..Print
// print string representation of dmmeta::Fbase to string LHS, no header -- cprint:dmmeta.Fbase.String
void dmmeta::Fbase_Print(dmmeta::Fbase & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbase";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.stripcomment, temp);
    PrintAttrSpaceReset(str,"stripcomment", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbigend..ReadFieldMaybe
bool dmmeta::Fbigend_ReadFieldMaybe(dmmeta::Fbigend &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbigend..ReadStrptrMaybe
// Read fields of dmmeta::Fbigend from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbigend_ReadStrptrMaybe(dmmeta::Fbigend &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbigend") || algo::StripTypeTag(in_str, "dmmeta.Fbigend");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbigend_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbigend..Print
// print string representation of dmmeta::Fbigend to string LHS, no header -- cprint:dmmeta.Fbigend.String
void dmmeta::Fbigend_Print(dmmeta::Fbigend & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbigend";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbitset..ReadFieldMaybe
bool dmmeta::Fbitset_ReadFieldMaybe(dmmeta::Fbitset &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbitset..ReadStrptrMaybe
// Read fields of dmmeta::Fbitset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbitset_ReadStrptrMaybe(dmmeta::Fbitset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbitset") || algo::StripTypeTag(in_str, "dmmeta.Fbitset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbitset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbitset..Print
// print string representation of dmmeta::Fbitset to string LHS, no header -- cprint:dmmeta.Fbitset.String
void dmmeta::Fbitset_Print(dmmeta::Fbitset & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbitset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbuf.fbufdir.Get
algo::Smallstr50 dmmeta::fbufdir_Get(dmmeta::Fbuf& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR_LL"));
    return ret;
}

// --- dmmeta.Fbuf.fbufdir.Get2
algo::Smallstr50 dmmeta::Fbuf_fbufdir_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR_LL"));
    return ret;
}

// --- dmmeta.Fbuf..ReadFieldMaybe
bool dmmeta::Fbuf_ReadFieldMaybe(dmmeta::Fbuf &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_fbufdir: retval = false; break;
        case dmmeta_FieldId_max: retval = u32_ReadStrptrMaybe(parent.max, strval); break;
        case dmmeta_FieldId_fbuftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbuftype, strval); break;
        case dmmeta_FieldId_insready: retval = algo::Smallstr100_ReadStrptrMaybe(parent.insready, strval); break;
        case dmmeta_FieldId_inseof: retval = algo::Smallstr100_ReadStrptrMaybe(parent.inseof, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbuf..ReadStrptrMaybe
// Read fields of dmmeta::Fbuf from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbuf_ReadStrptrMaybe(dmmeta::Fbuf &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbuf") || algo::StripTypeTag(in_str, "dmmeta.Fbuf");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbuf_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbuf..Print
// print string representation of dmmeta::Fbuf to string LHS, no header -- cprint:dmmeta.Fbuf.String
void dmmeta::Fbuf_Print(dmmeta::Fbuf & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbuf";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    u32_Print(row.max, temp);
    PrintAttrSpaceReset(str,"max", temp);

    algo::Smallstr50_Print(row.fbuftype, temp);
    PrintAttrSpaceReset(str,"fbuftype", temp);

    algo::Smallstr100_Print(row.insready, temp);
    PrintAttrSpaceReset(str,"insready", temp);

    algo::Smallstr100_Print(row.inseof, temp);
    PrintAttrSpaceReset(str,"inseof", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbufdir..ReadFieldMaybe
bool dmmeta::Fbufdir_ReadFieldMaybe(dmmeta::Fbufdir &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fbufdir: retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbufdir, strval); break;
        case dmmeta_FieldId_read: retval = bool_ReadStrptrMaybe(parent.read, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbufdir..ReadStrptrMaybe
// Read fields of dmmeta::Fbufdir from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbufdir_ReadStrptrMaybe(dmmeta::Fbufdir &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbufdir") || algo::StripTypeTag(in_str, "dmmeta.Fbufdir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbufdir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbufdir..Print
// print string representation of dmmeta::Fbufdir to string LHS, no header -- cprint:dmmeta.Fbufdir.String
void dmmeta::Fbufdir_Print(dmmeta::Fbufdir & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbufdir";

    algo::Smallstr50_Print(row.fbufdir, temp);
    PrintAttrSpaceReset(str,"fbufdir", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbuftype..ReadFieldMaybe
bool dmmeta::Fbuftype_ReadFieldMaybe(dmmeta::Fbuftype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fbuftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbuftype, strval); break;
        case dmmeta_FieldId_getmsg: retval = bool_ReadStrptrMaybe(parent.getmsg, strval); break;
        case dmmeta_FieldId_skipbytes: retval = bool_ReadStrptrMaybe(parent.skipbytes, strval); break;
        case dmmeta_FieldId_read: retval = bool_ReadStrptrMaybe(parent.read, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbuftype..ReadStrptrMaybe
// Read fields of dmmeta::Fbuftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbuftype_ReadStrptrMaybe(dmmeta::Fbuftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbuftype") || algo::StripTypeTag(in_str, "dmmeta.Fbuftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbuftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbuftype..Print
// print string representation of dmmeta::Fbuftype to string LHS, no header -- cprint:dmmeta.Fbuftype.String
void dmmeta::Fbuftype_Print(dmmeta::Fbuftype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fbuftype";

    algo::Smallstr50_Print(row.fbuftype, temp);
    PrintAttrSpaceReset(str,"fbuftype", temp);

    bool_Print(row.getmsg, temp);
    PrintAttrSpaceReset(str,"getmsg", temp);

    bool_Print(row.skipbytes, temp);
    PrintAttrSpaceReset(str,"skipbytes", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcast..ReadFieldMaybe
bool dmmeta::Fcast_ReadFieldMaybe(dmmeta::Fcast &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_expr: retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcast..ReadStrptrMaybe
// Read fields of dmmeta::Fcast from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcast_ReadStrptrMaybe(dmmeta::Fcast &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcast") || algo::StripTypeTag(in_str, "dmmeta.Fcast");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcast_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcast..Print
// print string representation of dmmeta::Fcast to string LHS, no header -- cprint:dmmeta.Fcast.String
void dmmeta::Fcast_Print(dmmeta::Fcast & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcast";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcleanup..ReadFieldMaybe
bool dmmeta::Fcleanup_ReadFieldMaybe(dmmeta::Fcleanup &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcleanup..ReadStrptrMaybe
// Read fields of dmmeta::Fcleanup from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcleanup_ReadStrptrMaybe(dmmeta::Fcleanup &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcleanup") || algo::StripTypeTag(in_str, "dmmeta.Fcleanup");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcleanup_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcleanup..Print
// print string representation of dmmeta::Fcleanup to string LHS, no header -- cprint:dmmeta.Fcleanup.String
void dmmeta::Fcleanup_Print(dmmeta::Fcleanup & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcleanup";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmap.leftField.Get
algo::Smallstr100 dmmeta::leftField_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcmap, "=LL/LL"));
    return ret;
}

// --- dmmeta.Fcmap.leftField.Get2
algo::Smallstr100 dmmeta::Fcmap_leftField_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "=LL/LL"));
    return ret;
}

// --- dmmeta.Fcmap.leftVal.Get
algo::Smallstr40 dmmeta::leftVal_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr40 ret(algo::Pathcomp(parent.fcmap, "=LL/LR"));
    return ret;
}

// --- dmmeta.Fcmap.leftVal.Get2
algo::Smallstr40 dmmeta::Fcmap_leftVal_Get(algo::strptr arg) {
    algo::Smallstr40 ret(algo::Pathcomp(arg, "=LL/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightVal.Get
algo::Smallstr40 dmmeta::rightVal_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr40 ret(algo::Pathcomp(parent.fcmap, "=LR/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightVal.Get2
algo::Smallstr40 dmmeta::Fcmap_rightVal_Get(algo::strptr arg) {
    algo::Smallstr40 ret(algo::Pathcomp(arg, "=LR/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightField.Get
algo::Smallstr100 dmmeta::rightField_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcmap, "=LR/LL"));
    return ret;
}

// --- dmmeta.Fcmap.rightField.Get2
algo::Smallstr100 dmmeta::Fcmap_rightField_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "=LR/LL"));
    return ret;
}

// --- dmmeta.Fcmap..Concat_leftField_leftVal_rightField_rightVal
tempstr dmmeta::Fcmap_Concat_leftField_leftVal_rightField_rightVal( const algo::strptr& leftField ,const algo::strptr& leftVal ,const algo::strptr& rightField ,const algo::strptr& rightVal ) {
    return tempstr() << leftField <<'/'<< leftVal <<'='<< rightField <<'/'<< rightVal ;
}

// --- dmmeta.Fcmap..ReadFieldMaybe
bool dmmeta::Fcmap_ReadFieldMaybe(dmmeta::Fcmap &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fcmap: retval = algo::Smallstr250_ReadStrptrMaybe(parent.fcmap, strval); break;
        case dmmeta_FieldId_leftField: retval = false; break;
        case dmmeta_FieldId_leftVal: retval = false; break;
        case dmmeta_FieldId_rightVal: retval = false; break;
        case dmmeta_FieldId_rightField: retval = false; break;
        case dmmeta_FieldId_bidir: retval = bool_ReadStrptrMaybe(parent.bidir, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmap..ReadStrptrMaybe
// Read fields of dmmeta::Fcmap from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmap_ReadStrptrMaybe(dmmeta::Fcmap &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmap") || algo::StripTypeTag(in_str, "dmmeta.Fcmap");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmap_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmap..Print
// print string representation of dmmeta::Fcmap to string LHS, no header -- cprint:dmmeta.Fcmap.String
void dmmeta::Fcmap_Print(dmmeta::Fcmap & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcmap";

    algo::Smallstr250_Print(row.fcmap, temp);
    PrintAttrSpaceReset(str,"fcmap", temp);

    bool_Print(row.bidir, temp);
    PrintAttrSpaceReset(str,"bidir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmdline.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fcmdline& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".RL.RL"));
    return ret;
}

// --- dmmeta.Fcmdline.ns.Get2
algo::Smallstr16 dmmeta::Fcmdline_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Fcmdline..ReadFieldMaybe
bool dmmeta::Fcmdline_ReadFieldMaybe(dmmeta::Fcmdline &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_read: retval = bool_ReadStrptrMaybe(parent.read, strval); break;
        case dmmeta_FieldId_basecmdline: retval = algo::Smallstr100_ReadStrptrMaybe(parent.basecmdline, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmdline..ReadStrptrMaybe
// Read fields of dmmeta::Fcmdline from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmdline_ReadStrptrMaybe(dmmeta::Fcmdline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmdline") || algo::StripTypeTag(in_str, "dmmeta.Fcmdline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmdline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmdline..Print
// print string representation of dmmeta::Fcmdline to string LHS, no header -- cprint:dmmeta.Fcmdline.String
void dmmeta::Fcmdline_Print(dmmeta::Fcmdline & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcmdline";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Smallstr100_Print(row.basecmdline, temp);
    PrintAttrSpaceReset(str,"basecmdline", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmp..ReadFieldMaybe
bool dmmeta::Fcmp_ReadFieldMaybe(dmmeta::Fcmp &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_versionsort: retval = bool_ReadStrptrMaybe(parent.versionsort, strval); break;
        case dmmeta_FieldId_casesens: retval = bool_ReadStrptrMaybe(parent.casesens, strval); break;
        case dmmeta_FieldId_extrn: retval = bool_ReadStrptrMaybe(parent.extrn, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmp..ReadStrptrMaybe
// Read fields of dmmeta::Fcmp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmp_ReadStrptrMaybe(dmmeta::Fcmp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmp") || algo::StripTypeTag(in_str, "dmmeta.Fcmp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmp..Print
// print string representation of dmmeta::Fcmp to string LHS, no header -- cprint:dmmeta.Fcmp.String
void dmmeta::Fcmp_Print(dmmeta::Fcmp & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcmp";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.versionsort, temp);
    PrintAttrSpaceReset(str,"versionsort", temp);

    bool_Print(row.casesens, temp);
    PrintAttrSpaceReset(str,"casesens", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcompact..ReadFieldMaybe
bool dmmeta::Fcompact_ReadFieldMaybe(dmmeta::Fcompact &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcompact..ReadStrptrMaybe
// Read fields of dmmeta::Fcompact from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcompact_ReadStrptrMaybe(dmmeta::Fcompact &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcompact") || algo::StripTypeTag(in_str, "dmmeta.Fcompact");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcompact_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcompact..Print
// print string representation of dmmeta::Fcompact to string LHS, no header -- cprint:dmmeta.Fcompact.String
void dmmeta::Fcompact_Print(dmmeta::Fcompact & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcompact";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fconst.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fconst& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fconst, "/LL"));
    return ret;
}

// --- dmmeta.Fconst.field.Get2
algo::Smallstr100 dmmeta::Fconst_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Fconst.name.Get
algo::Smallstr100 dmmeta::name_Get(dmmeta::Fconst& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fconst, "/LR"));
    return ret;
}

// --- dmmeta.Fconst.name.Get2
algo::Smallstr100 dmmeta::Fconst_name_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dmmeta.Fconst..Concat_field_name
tempstr dmmeta::Fconst_Concat_field_name( const algo::strptr& field ,const algo::strptr& name ) {
    return tempstr() << field <<'/'<< name ;
}

// --- dmmeta.Fconst..ReadFieldMaybe
bool dmmeta::Fconst_ReadFieldMaybe(dmmeta::Fconst &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fconst: retval = algo::Smallstr100_ReadStrptrMaybe(parent.fconst, strval); break;
        case dmmeta_FieldId_field: retval = false; break;
        case dmmeta_FieldId_value: retval = algo::CppExpr_ReadStrptrMaybe(parent.value, strval); break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fconst..ReadStrptrMaybe
// Read fields of dmmeta::Fconst from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fconst_ReadStrptrMaybe(dmmeta::Fconst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fconst") || algo::StripTypeTag(in_str, "dmmeta.Fconst");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fconst_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fconst..Print
// print string representation of dmmeta::Fconst to string LHS, no header -- cprint:dmmeta.Fconst.String
void dmmeta::Fconst_Print(dmmeta::Fconst & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fconst";

    algo::Smallstr100_Print(row.fconst, temp);
    PrintAttrSpaceReset(str,"fconst", temp);

    algo::CppExpr_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcurs.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcurs, "/RL"));
    return ret;
}

// --- dmmeta.Fcurs.field.Get2
algo::Smallstr100 dmmeta::Fcurs_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Fcurs.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fcurs, "/RL.RL"));
    return ret;
}

// --- dmmeta.Fcurs.ctype.Get2
algo::Smallstr50 dmmeta::Fcurs_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RL.RL"));
    return ret;
}

// --- dmmeta.Fcurs.curstype.Get
algo::Smallstr50 dmmeta::curstype_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fcurs, "/RR"));
    return ret;
}

// --- dmmeta.Fcurs.curstype.Get2
algo::Smallstr50 dmmeta::Fcurs_curstype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Fcurs..Concat_field_curstype
tempstr dmmeta::Fcurs_Concat_field_curstype( const algo::strptr& field ,const algo::strptr& curstype ) {
    return tempstr() << field <<'/'<< curstype ;
}

// --- dmmeta.Fcurs..ReadFieldMaybe
bool dmmeta::Fcurs_ReadFieldMaybe(dmmeta::Fcurs &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fcurs: retval = algo::Smallstr50_ReadStrptrMaybe(parent.fcurs, strval); break;
        case dmmeta_FieldId_field: retval = false; break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_curstype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcurs..ReadStrptrMaybe
// Read fields of dmmeta::Fcurs from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcurs_ReadStrptrMaybe(dmmeta::Fcurs &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcurs") || algo::StripTypeTag(in_str, "dmmeta.Fcurs");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcurs_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcurs..Print
// print string representation of dmmeta::Fcurs to string LHS, no header -- cprint:dmmeta.Fcurs.String
void dmmeta::Fcurs_Print(dmmeta::Fcurs & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fcurs";

    algo::Smallstr50_Print(row.fcurs, temp);
    PrintAttrSpaceReset(str,"fcurs", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fdec..ReadFieldMaybe
bool dmmeta::Fdec_ReadFieldMaybe(dmmeta::Fdec &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_nplace: retval = i32_ReadStrptrMaybe(parent.nplace, strval); break;
        case dmmeta_FieldId_fixedfmt: retval = bool_ReadStrptrMaybe(parent.fixedfmt, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fdec..ReadStrptrMaybe
// Read fields of dmmeta::Fdec from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fdec_ReadStrptrMaybe(dmmeta::Fdec &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fdec") || algo::StripTypeTag(in_str, "dmmeta.Fdec");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fdec_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fdec..Print
// print string representation of dmmeta::Fdec to string LHS, no header -- cprint:dmmeta.Fdec.String
void dmmeta::Fdec_Print(dmmeta::Fdec & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fdec";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.nplace, temp);
    PrintAttrSpaceReset(str,"nplace", temp);

    bool_Print(row.fixedfmt, temp);
    PrintAttrSpaceReset(str,"fixedfmt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fdelay..ReadFieldMaybe
bool dmmeta::Fdelay_ReadFieldMaybe(dmmeta::Fdelay &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fstep: retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval); break;
        case dmmeta_FieldId_delay: retval = algo::I64Dec9_ReadStrptrMaybe(parent.delay, strval); break;
        case dmmeta_FieldId_scale: retval = bool_ReadStrptrMaybe(parent.scale, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fdelay..ReadStrptrMaybe
// Read fields of dmmeta::Fdelay from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fdelay_ReadStrptrMaybe(dmmeta::Fdelay &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fdelay") || algo::StripTypeTag(in_str, "dmmeta.Fdelay");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fdelay_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fdelay..Print
// print string representation of dmmeta::Fdelay to string LHS, no header -- cprint:dmmeta.Fdelay.String
void dmmeta::Fdelay_Print(dmmeta::Fdelay & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fdelay";

    algo::Smallstr100_Print(row.fstep, temp);
    PrintAttrSpaceReset(str,"fstep", temp);

    algo::I64Dec9_Print(row.delay, temp);
    PrintAttrSpaceReset(str,"delay", temp);

    bool_Print(row.scale, temp);
    PrintAttrSpaceReset(str,"scale", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fflag..ReadFieldMaybe
bool dmmeta::Fflag_ReadFieldMaybe(dmmeta::Fflag &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_cumulative: retval = bool_ReadStrptrMaybe(parent.cumulative, strval); break;
        case dmmeta_FieldId_emptyval: retval = algo::cstring_ReadStrptrMaybe(parent.emptyval, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fflag..ReadStrptrMaybe
// Read fields of dmmeta::Fflag from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fflag_ReadStrptrMaybe(dmmeta::Fflag &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fflag") || algo::StripTypeTag(in_str, "dmmeta.Fflag");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fflag_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fflag..Print
// print string representation of dmmeta::Fflag to string LHS, no header -- cprint:dmmeta.Fflag.String
void dmmeta::Fflag_Print(dmmeta::Fflag & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fflag";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.cumulative, temp);
    PrintAttrSpaceReset(str,"cumulative", temp);

    algo::cstring_Print(row.emptyval, temp);
    PrintAttrSpaceReset(str,"emptyval", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Field.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Field& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Field.ctype.Get2
algo::Smallstr50 dmmeta::Field_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Field.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Field& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".RL.RL"));
    return ret;
}

// --- dmmeta.Field.ns.Get2
algo::Smallstr16 dmmeta::Field_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Field.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Field& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Field.name.Get2
algo::Smallstr50 dmmeta::Field_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Field..Concat_ctype_name
tempstr dmmeta::Field_Concat_ctype_name( const algo::strptr& ctype ,const algo::strptr& name ) {
    return tempstr() << ctype <<'.'<< name ;
}

// --- dmmeta.Field..ReadFieldMaybe
bool dmmeta::Field_ReadFieldMaybe(dmmeta::Field &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_arg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arg, strval); break;
        case dmmeta_FieldId_reftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval); break;
        case dmmeta_FieldId_dflt: retval = algo::CppExpr_ReadStrptrMaybe(parent.dflt, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Field..ReadStrptrMaybe
// Read fields of dmmeta::Field from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Field_ReadStrptrMaybe(dmmeta::Field &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.field") || algo::StripTypeTag(in_str, "dmmeta.Field");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Field_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Field..Print
// print string representation of dmmeta::Field to string LHS, no header -- cprint:dmmeta.Field.String
void dmmeta::Field_Print(dmmeta::Field & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.field";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr50_Print(row.arg, temp);
    PrintAttrSpaceReset(str,"arg", temp);

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    algo::CppExpr_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::value_ToCstr(const dmmeta::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dmmeta_FieldId_field          : ret = "field";  break;
        case dmmeta_FieldId_comment        : ret = "comment";  break;
        case dmmeta_FieldId_ctype          : ret = "ctype";  break;
        case dmmeta_FieldId_argvtype       : ret = "argvtype";  break;
        case dmmeta_FieldId_base           : ret = "base";  break;
        case dmmeta_FieldId_name           : ret = "name";  break;
        case dmmeta_FieldId_offset         : ret = "offset";  break;
        case dmmeta_FieldId_width          : ret = "width";  break;
        case dmmeta_FieldId_srcfield       : ret = "srcfield";  break;
        case dmmeta_FieldId_pnewtype       : ret = "pnewtype";  break;
        case dmmeta_FieldId_cafter         : ret = "cafter";  break;
        case dmmeta_FieldId_after          : ret = "after";  break;
        case dmmeta_FieldId_extrn          : ret = "extrn";  break;
        case dmmeta_FieldId_genop          : ret = "genop";  break;
        case dmmeta_FieldId_order          : ret = "order";  break;
        case dmmeta_FieldId_minmax         : ret = "minmax";  break;
        case dmmeta_FieldId_dflt           : ret = "dflt";  break;
        case dmmeta_FieldId_cppdflt        : ret = "cppdflt";  break;
        case dmmeta_FieldId_ssimdflt       : ret = "ssimdflt";  break;
        case dmmeta_FieldId_jsdflt         : ret = "jsdflt";  break;
        case dmmeta_FieldId_initmemset     : ret = "initmemset";  break;
        case dmmeta_FieldId_isstruct       : ret = "isstruct";  break;
        case dmmeta_FieldId_cfmt           : ret = "cfmt";  break;
        case dmmeta_FieldId_strfmt         : ret = "strfmt";  break;
        case dmmeta_FieldId_printfmt       : ret = "printfmt";  break;
        case dmmeta_FieldId_read           : ret = "read";  break;
        case dmmeta_FieldId_print          : ret = "print";  break;
        case dmmeta_FieldId_sep            : ret = "sep";  break;
        case dmmeta_FieldId_expr           : ret = "expr";  break;
        case dmmeta_FieldId_charrange      : ret = "charrange";  break;
        case dmmeta_FieldId_calc           : ret = "calc";  break;
        case dmmeta_FieldId_hashtype       : ret = "hashtype";  break;
        case dmmeta_FieldId_cppkeyword     : ret = "cppkeyword";  break;
        case dmmeta_FieldId_ctor           : ret = "ctor";  break;
        case dmmeta_FieldId_dtor           : ret = "dtor";  break;
        case dmmeta_FieldId_cheap_copy     : ret = "cheap_copy";  break;
        case dmmeta_FieldId_size           : ret = "size";  break;
        case dmmeta_FieldId_alignment      : ret = "alignment";  break;
        case dmmeta_FieldId_strequiv       : ret = "strequiv";  break;
        case dmmeta_FieldId_ns             : ret = "ns";  break;
        case dmmeta_FieldId_len            : ret = "len";  break;
        case dmmeta_FieldId_padbytes       : ret = "padbytes";  break;
        case dmmeta_FieldId_dispatch       : ret = "dispatch";  break;
        case dmmeta_FieldId_unk            : ret = "unk";  break;
        case dmmeta_FieldId_haslen         : ret = "haslen";  break;
        case dmmeta_FieldId_call           : ret = "call";  break;
        case dmmeta_FieldId_strict         : ret = "strict";  break;
        case dmmeta_FieldId_dispatch_msg   : ret = "dispatch_msg";  break;
        case dmmeta_FieldId_match_all      : ret = "match_all";  break;
        case dmmeta_FieldId_dispsig        : ret = "dispsig";  break;
        case dmmeta_FieldId_signature      : ret = "signature";  break;
        case dmmeta_FieldId_cycle          : ret = "cycle";  break;
        case dmmeta_FieldId_stripcomment   : ret = "stripcomment";  break;
        case dmmeta_FieldId_fbufdir        : ret = "fbufdir";  break;
        case dmmeta_FieldId_max            : ret = "max";  break;
        case dmmeta_FieldId_fbuftype       : ret = "fbuftype";  break;
        case dmmeta_FieldId_insready       : ret = "insready";  break;
        case dmmeta_FieldId_inseof         : ret = "inseof";  break;
        case dmmeta_FieldId_getmsg         : ret = "getmsg";  break;
        case dmmeta_FieldId_skipbytes      : ret = "skipbytes";  break;
        case dmmeta_FieldId_fcmap          : ret = "fcmap";  break;
        case dmmeta_FieldId_leftField      : ret = "leftField";  break;
        case dmmeta_FieldId_leftVal        : ret = "leftVal";  break;
        case dmmeta_FieldId_rightVal       : ret = "rightVal";  break;
        case dmmeta_FieldId_rightField     : ret = "rightField";  break;
        case dmmeta_FieldId_bidir          : ret = "bidir";  break;
        case dmmeta_FieldId_basecmdline    : ret = "basecmdline";  break;
        case dmmeta_FieldId_versionsort    : ret = "versionsort";  break;
        case dmmeta_FieldId_casesens       : ret = "casesens";  break;
        case dmmeta_FieldId_fconst         : ret = "fconst";  break;
        case dmmeta_FieldId_value          : ret = "value";  break;
        case dmmeta_FieldId_fcurs          : ret = "fcurs";  break;
        case dmmeta_FieldId_curstype       : ret = "curstype";  break;
        case dmmeta_FieldId_nplace         : ret = "nplace";  break;
        case dmmeta_FieldId_fixedfmt       : ret = "fixedfmt";  break;
        case dmmeta_FieldId_fstep          : ret = "fstep";  break;
        case dmmeta_FieldId_delay          : ret = "delay";  break;
        case dmmeta_FieldId_scale          : ret = "scale";  break;
        case dmmeta_FieldId_cumulative     : ret = "cumulative";  break;
        case dmmeta_FieldId_emptyval       : ret = "emptyval";  break;
        case dmmeta_FieldId_arg            : ret = "arg";  break;
        case dmmeta_FieldId_reftype        : ret = "reftype";  break;
        case dmmeta_FieldId_update         : ret = "update";  break;
        case dmmeta_FieldId_fprefix        : ret = "fprefix";  break;
        case dmmeta_FieldId_partial        : ret = "partial";  break;
        case dmmeta_FieldId_regxtype       : ret = "regxtype";  break;
        case dmmeta_FieldId_sorttype       : ret = "sorttype";  break;
        case dmmeta_FieldId_sortfld        : ret = "sortfld";  break;
        case dmmeta_FieldId_steptype       : ret = "steptype";  break;
        case dmmeta_FieldId_func           : ret = "func";  break;
        case dmmeta_FieldId_inl            : ret = "inl";  break;
        case dmmeta_FieldId_proto          : ret = "proto";  break;
        case dmmeta_FieldId_body           : ret = "body";  break;
        case dmmeta_FieldId_deprecate      : ret = "deprecate";  break;
        case dmmeta_FieldId_ismacro        : ret = "ismacro";  break;
        case dmmeta_FieldId_glob           : ret = "glob";  break;
        case dmmeta_FieldId_priv           : ret = "priv";  break;
        case dmmeta_FieldId_ret            : ret = "ret";  break;
        case dmmeta_FieldId_fwddecl        : ret = "fwddecl";  break;
        case dmmeta_FieldId_namefld        : ret = "namefld";  break;
        case dmmeta_FieldId_idfld          : ret = "idfld";  break;
        case dmmeta_FieldId_wantenum       : ret = "wantenum";  break;
        case dmmeta_FieldId_namefldctyp    : ret = "namefldctyp";  break;
        case dmmeta_FieldId_gsymbol        : ret = "gsymbol";  break;
        case dmmeta_FieldId_ssimfile       : ret = "ssimfile";  break;
        case dmmeta_FieldId_inc            : ret = "inc";  break;
        case dmmeta_FieldId_symboltype     : ret = "symboltype";  break;
        case dmmeta_FieldId_min            : ret = "min";  break;
        case dmmeta_FieldId_extra          : ret = "extra";  break;
        case dmmeta_FieldId_listtype       : ret = "listtype";  break;
        case dmmeta_FieldId_circular       : ret = "circular";  break;
        case dmmeta_FieldId_haveprev       : ret = "haveprev";  break;
        case dmmeta_FieldId_instail        : ret = "instail";  break;
        case dmmeta_FieldId_havetail       : ret = "havetail";  break;
        case dmmeta_FieldId_havecount      : ret = "havecount";  break;
        case dmmeta_FieldId_logcat         : ret = "logcat";  break;
        case dmmeta_FieldId_enabled        : ret = "enabled";  break;
        case dmmeta_FieldId_builtin        : ret = "builtin";  break;
        case dmmeta_FieldId_ismodule       : ret = "ismodule";  break;
        case dmmeta_FieldId_type           : ret = "type";  break;
        case dmmeta_FieldId_xref           : ret = "xref";  break;
        case dmmeta_FieldId_nstype         : ret = "nstype";  break;
        case dmmeta_FieldId_license        : ret = "license";  break;
        case dmmeta_FieldId_nsinclude      : ret = "nsinclude";  break;
        case dmmeta_FieldId_sys            : ret = "sys";  break;
        case dmmeta_FieldId_version        : ret = "version";  break;
        case dmmeta_FieldId_genthrow       : ret = "genthrow";  break;
        case dmmeta_FieldId_correct_getorcreate: ret = "correct_getorcreate";  break;
        case dmmeta_FieldId_pool           : ret = "pool";  break;
        case dmmeta_FieldId_sortxref       : ret = "sortxref";  break;
        case dmmeta_FieldId_pack           : ret = "pack";  break;
        case dmmeta_FieldId_numtype        : ret = "numtype";  break;
        case dmmeta_FieldId_min_len        : ret = "min_len";  break;
        case dmmeta_FieldId_pnew           : ret = "pnew";  break;
        case dmmeta_FieldId_buftype        : ret = "buftype";  break;
        case dmmeta_FieldId_unique         : ret = "unique";  break;
        case dmmeta_FieldId_isval          : ret = "isval";  break;
        case dmmeta_FieldId_cascins        : ret = "cascins";  break;
        case dmmeta_FieldId_usebasepool    : ret = "usebasepool";  break;
        case dmmeta_FieldId_cancopy        : ret = "cancopy";  break;
        case dmmeta_FieldId_isxref         : ret = "isxref";  break;
        case dmmeta_FieldId_del            : ret = "del";  break;
        case dmmeta_FieldId_up             : ret = "up";  break;
        case dmmeta_FieldId_isnew          : ret = "isnew";  break;
        case dmmeta_FieldId_hasalloc       : ret = "hasalloc";  break;
        case dmmeta_FieldId_inst           : ret = "inst";  break;
        case dmmeta_FieldId_varlen         : ret = "varlen";  break;
        case dmmeta_FieldId_length         : ret = "length";  break;
        case dmmeta_FieldId_strtype        : ret = "strtype";  break;
        case dmmeta_FieldId_pad            : ret = "pad";  break;
        case dmmeta_FieldId_ssimns         : ret = "ssimns";  break;
        case dmmeta_FieldId_maxwid         : ret = "maxwid";  break;
        case dmmeta_FieldId_fixedwid1      : ret = "fixedwid1";  break;
        case dmmeta_FieldId_fixedwid2      : ret = "fixedwid2";  break;
        case dmmeta_FieldId_aliased        : ret = "aliased";  break;
        case dmmeta_FieldId_hashfld        : ret = "hashfld";  break;
        case dmmeta_FieldId_tracefld       : ret = "tracefld";  break;
        case dmmeta_FieldId_tracerec       : ret = "tracerec";  break;
        case dmmeta_FieldId_inscond        : ret = "inscond";  break;
        case dmmeta_FieldId_via            : ret = "via";  break;
        case dmmeta_FieldId_viafld         : ret = "viafld";  break;
        case dmmeta_FieldId_keyfld         : ret = "keyfld";  break;
    }
    return ret;
}

// --- dmmeta.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dmmeta::value_Print(const dmmeta::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dmmeta.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::value_SetStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_ns); ret = true; break;
                }
                case LE_STR2('u','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_up); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','r','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_arg); ret = true; break;
                }
                case LE_STR3('d','e','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_del); ret = true; break;
                }
                case LE_STR3('i','n','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_inc); ret = true; break;
                }
                case LE_STR3('i','n','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_inl); ret = true; break;
                }
                case LE_STR3('l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_len); ret = true; break;
                }
                case LE_STR3('m','a','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_max); ret = true; break;
                }
                case LE_STR3('m','i','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_min); ret = true; break;
                }
                case LE_STR3('p','a','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_pad); ret = true; break;
                }
                case LE_STR3('r','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_ret); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_sys); ret = true; break;
                }
                case LE_STR3('u','n','k'): {
                    value_SetEnum(parent,dmmeta_FieldId_unk); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,dmmeta_FieldId_via); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_base); ret = true; break;
                }
                case LE_STR4('b','o','d','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_body); ret = true; break;
                }
                case LE_STR4('c','a','l','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_calc); ret = true; break;
                }
                case LE_STR4('c','a','l','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_call); ret = true; break;
                }
                case LE_STR4('c','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_cfmt); ret = true; break;
                }
                case LE_STR4('c','t','o','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_ctor); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('d','t','o','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_dtor); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_expr); ret = true; break;
                }
                case LE_STR4('f','u','n','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_func); ret = true; break;
                }
                case LE_STR4('g','l','o','b'): {
                    value_SetEnum(parent,dmmeta_FieldId_glob); ret = true; break;
                }
                case LE_STR4('i','n','s','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_inst); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_name); ret = true; break;
                }
                case LE_STR4('p','a','c','k'): {
                    value_SetEnum(parent,dmmeta_FieldId_pack); ret = true; break;
                }
                case LE_STR4('p','n','e','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_pnew); ret = true; break;
                }
                case LE_STR4('p','o','o','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_pool); ret = true; break;
                }
                case LE_STR4('p','r','i','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_priv); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_read); ret = true; break;
                }
                case LE_STR4('s','i','z','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_size); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_type); ret = true; break;
                }
                case LE_STR4('x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_xref); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','f','t','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_after); ret = true; break;
                }
                case LE_STR5('b','i','d','i','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_bidir); ret = true; break;
                }
                case LE_STR5('c','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ctype); ret = true; break;
                }
                case LE_STR5('c','y','c','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_cycle); ret = true; break;
                }
                case LE_STR5('d','e','l','a','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_delay); ret = true; break;
                }
                case LE_STR5('e','x','t','r','a'): {
                    value_SetEnum(parent,dmmeta_FieldId_extra); ret = true; break;
                }
                case LE_STR5('e','x','t','r','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_extrn); ret = true; break;
                }
                case LE_STR5('f','c','m','a','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_fcmap); ret = true; break;
                }
                case LE_STR5('f','c','u','r','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_fcurs); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_field); ret = true; break;
                }
                case LE_STR5('f','s','t','e','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_fstep); ret = true; break;
                }
                case LE_STR5('g','e','n','o','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_genop); ret = true; break;
                }
                case LE_STR5('i','d','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_idfld); ret = true; break;
                }
                case LE_STR5('i','s','n','e','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_isnew); ret = true; break;
                }
                case LE_STR5('i','s','v','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_isval); ret = true; break;
                }
                case LE_STR5('o','r','d','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_order); ret = true; break;
                }
                case LE_STR5('p','r','i','n','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_print); ret = true; break;
                }
                case LE_STR5('p','r','o','t','o'): {
                    value_SetEnum(parent,dmmeta_FieldId_proto); ret = true; break;
                }
                case LE_STR5('s','c','a','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_scale); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','i','d','t','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_width); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('c','a','f','t','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_cafter); ret = true; break;
                }
                case LE_STR6('f','c','o','n','s','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_fconst); ret = true; break;
                }
                case LE_STR6('g','e','t','m','s','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_getmsg); ret = true; break;
                }
                case LE_STR6('h','a','s','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_haslen); ret = true; break;
                }
                case LE_STR6('i','n','s','e','o','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_inseof); ret = true; break;
                }
                case LE_STR6('i','s','x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_isxref); ret = true; break;
                }
                case LE_STR6('j','s','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_jsdflt); ret = true; break;
                }
                case LE_STR6('k','e','y','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_keyfld); ret = true; break;
                }
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_length); ret = true; break;
                }
                case LE_STR6('l','o','g','c','a','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_logcat); ret = true; break;
                }
                case LE_STR6('m','a','x','w','i','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_maxwid); ret = true; break;
                }
                case LE_STR6('m','i','n','m','a','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_minmax); ret = true; break;
                }
                case LE_STR6('n','p','l','a','c','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_nplace); ret = true; break;
                }
                case LE_STR6('n','s','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_nstype); ret = true; break;
                }
                case LE_STR6('o','f','f','s','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_offset); ret = true; break;
                }
                case LE_STR6('s','s','i','m','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimns); ret = true; break;
                }
                case LE_STR6('s','t','r','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_strfmt); ret = true; break;
                }
                case LE_STR6('s','t','r','i','c','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_strict); ret = true; break;
                }
                case LE_STR6('u','n','i','q','u','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_unique); ret = true; break;
                }
                case LE_STR6('u','p','d','a','t','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_update); ret = true; break;
                }
                case LE_STR6('v','a','r','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_varlen); ret = true; break;
                }
                case LE_STR6('v','i','a','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_viafld); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','l','i','a','s','e','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_aliased); ret = true; break;
                }
                case LE_STR7('b','u','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_buftype); ret = true; break;
                }
                case LE_STR7('b','u','i','l','t','i','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_builtin); ret = true; break;
                }
                case LE_STR7('c','a','n','c','o','p','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_cancopy); ret = true; break;
                }
                case LE_STR7('c','a','s','c','i','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_cascins); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','p','p','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_cppdflt); ret = true; break;
                }
                case LE_STR7('d','i','s','p','s','i','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_dispsig); ret = true; break;
                }
                case LE_STR7('e','n','a','b','l','e','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_enabled); ret = true; break;
                }
                case LE_STR7('f','b','u','f','d','i','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_fbufdir); ret = true; break;
                }
                case LE_STR7('f','p','r','e','f','i','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_fprefix); ret = true; break;
                }
                case LE_STR7('f','w','d','d','e','c','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_fwddecl); ret = true; break;
                }
                case LE_STR7('g','s','y','m','b','o','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_gsymbol); ret = true; break;
                }
                case LE_STR7('h','a','s','h','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_hashfld); ret = true; break;
                }
                case LE_STR7('i','n','s','c','o','n','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_inscond); ret = true; break;
                }
                case LE_STR7('i','n','s','t','a','i','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_instail); ret = true; break;
                }
                case LE_STR7('i','s','m','a','c','r','o'): {
                    value_SetEnum(parent,dmmeta_FieldId_ismacro); ret = true; break;
                }
                case LE_STR7('l','e','f','t','V','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_leftVal); ret = true; break;
                }
                case LE_STR7('l','i','c','e','n','s','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_license); ret = true; break;
                }
                case LE_STR7('m','i','n','_','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_min_len); ret = true; break;
                }
                case LE_STR7('n','a','m','e','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_namefld); ret = true; break;
                }
                case LE_STR7('n','u','m','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_numtype); ret = true; break;
                }
                case LE_STR7('p','a','r','t','i','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_partial); ret = true; break;
                }
                case LE_STR7('r','e','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_reftype); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','t','r','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_strtype); ret = true; break;
                }
                case LE_STR7('v','e','r','s','i','o','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_version); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','r','g','v','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_argvtype); ret = true; break;
                }
                case LE_STR8('c','a','s','e','s','e','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_casesens); ret = true; break;
                }
                case LE_STR8('c','i','r','c','u','l','a','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_circular); ret = true; break;
                }
                case LE_STR8('c','u','r','s','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_curstype); ret = true; break;
                }
                case LE_STR8('d','i','s','p','a','t','c','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_dispatch); ret = true; break;
                }
                case LE_STR8('e','m','p','t','y','v','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_emptyval); ret = true; break;
                }
                case LE_STR8('f','b','u','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_fbuftype); ret = true; break;
                }
                case LE_STR8('f','i','x','e','d','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_fixedfmt); ret = true; break;
                }
                case LE_STR8('g','e','n','t','h','r','o','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_genthrow); ret = true; break;
                }
                case LE_STR8('h','a','s','a','l','l','o','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_hasalloc); ret = true; break;
                }
                case LE_STR8('h','a','s','h','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_hashtype); ret = true; break;
                }
                case LE_STR8('h','a','v','e','p','r','e','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_haveprev); ret = true; break;
                }
                case LE_STR8('h','a','v','e','t','a','i','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_havetail); ret = true; break;
                }
                case LE_STR8('i','n','s','r','e','a','d','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_insready); ret = true; break;
                }
                case LE_STR8('i','s','m','o','d','u','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ismodule); ret = true; break;
                }
                case LE_STR8('i','s','s','t','r','u','c','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_isstruct); ret = true; break;
                }
                case LE_STR8('l','i','s','t','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_listtype); ret = true; break;
                }
                case LE_STR8('p','a','d','b','y','t','e','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_padbytes); ret = true; break;
                }
                case LE_STR8('p','n','e','w','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_pnewtype); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_printfmt); ret = true; break;
                }
                case LE_STR8('r','e','g','x','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_regxtype); ret = true; break;
                }
                case LE_STR8('r','i','g','h','t','V','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_rightVal); ret = true; break;
                }
                case LE_STR8('s','o','r','t','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_sorttype); ret = true; break;
                }
                case LE_STR8('s','o','r','t','x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_sortxref); ret = true; break;
                }
                case LE_STR8('s','r','c','f','i','e','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_srcfield); ret = true; break;
                }
                case LE_STR8('s','s','i','m','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimdflt); ret = true; break;
                }
                case LE_STR8('s','s','i','m','f','i','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimfile); ret = true; break;
                }
                case LE_STR8('s','t','e','p','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_steptype); ret = true; break;
                }
                case LE_STR8('s','t','r','e','q','u','i','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_strequiv); ret = true; break;
                }
                case LE_STR8('t','r','a','c','e','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_tracefld); ret = true; break;
                }
                case LE_STR8('t','r','a','c','e','r','e','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_tracerec); ret = true; break;
                }
                case LE_STR8('w','a','n','t','e','n','u','m'): {
                    value_SetEnum(parent,dmmeta_FieldId_wantenum); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','l','i','g','n','m','e','n'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dmmeta_FieldId_alignment); ret = true; break; }
                    break;
                }
                case LE_STR8('c','h','a','r','r','a','n','g'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_charrange); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','p','r','e','c','a','t'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_deprecate); ret = true; break; }
                    break;
                }
                case LE_STR8('f','i','x','e','d','w','i','d'): {
                    if (memcmp(rhs.elems+8,"1",1)==0) { value_SetEnum(parent,dmmeta_FieldId_fixedwid1); ret = true; break; }
                    if (memcmp(rhs.elems+8,"2",1)==0) { value_SetEnum(parent,dmmeta_FieldId_fixedwid2); ret = true; break; }
                    break;
                }
                case LE_STR8('h','a','v','e','c','o','u','n'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dmmeta_FieldId_havecount); ret = true; break; }
                    break;
                }
                case LE_STR8('l','e','f','t','F','i','e','l'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dmmeta_FieldId_leftField); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','t','c','h','_','a','l'): {
                    if (memcmp(rhs.elems+8,"l",1)==0) { value_SetEnum(parent,dmmeta_FieldId_match_all); ret = true; break; }
                    break;
                }
                case LE_STR8('n','s','i','n','c','l','u','d'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_nsinclude); ret = true; break; }
                    break;
                }
                case LE_STR8('s','i','g','n','a','t','u','r'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_signature); ret = true; break; }
                    break;
                }
                case LE_STR8('s','k','i','p','b','y','t','e'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,dmmeta_FieldId_skipbytes); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','e','a','p','_','c','o'): {
                    if (memcmp(rhs.elems+8,"py",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cheap_copy); ret = true; break; }
                    break;
                }
                case LE_STR8('c','p','p','k','e','y','w','o'): {
                    if (memcmp(rhs.elems+8,"rd",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cppkeyword); ret = true; break; }
                    break;
                }
                case LE_STR8('c','u','m','u','l','a','t','i'): {
                    if (memcmp(rhs.elems+8,"ve",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cumulative); ret = true; break; }
                    break;
                }
                case LE_STR8('i','n','i','t','m','e','m','s'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,dmmeta_FieldId_initmemset); ret = true; break; }
                    break;
                }
                case LE_STR8('r','i','g','h','t','F','i','e'): {
                    if (memcmp(rhs.elems+8,"ld",2)==0) { value_SetEnum(parent,dmmeta_FieldId_rightField); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','m','b','o','l','t','y'): {
                    if (memcmp(rhs.elems+8,"pe",2)==0) { value_SetEnum(parent,dmmeta_FieldId_symboltype); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('b','a','s','e','c','m','d','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dmmeta_FieldId_basecmdline); ret = true; break; }
                    break;
                }
                case LE_STR8('n','a','m','e','f','l','d','c'): {
                    if (memcmp(rhs.elems+8,"typ",3)==0) { value_SetEnum(parent,dmmeta_FieldId_namefldctyp); ret = true; break; }
                    break;
                }
                case LE_STR8('u','s','e','b','a','s','e','p'): {
                    if (memcmp(rhs.elems+8,"ool",3)==0) { value_SetEnum(parent,dmmeta_FieldId_usebasepool); ret = true; break; }
                    break;
                }
                case LE_STR8('v','e','r','s','i','o','n','s'): {
                    if (memcmp(rhs.elems+8,"ort",3)==0) { value_SetEnum(parent,dmmeta_FieldId_versionsort); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','i','s','p','a','t','c','h'): {
                    if (memcmp(rhs.elems+8,"_msg",4)==0) { value_SetEnum(parent,dmmeta_FieldId_dispatch_msg); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','i','p','c','o','m'): {
                    if (memcmp(rhs.elems+8,"ment",4)==0) { value_SetEnum(parent,dmmeta_FieldId_stripcomment); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','r','r','e','c','t','_'): {
                    if (memcmp(rhs.elems+8,"getorcreate",11)==0) { value_SetEnum(parent,dmmeta_FieldId_correct_getorcreate); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::value_SetStrptr(dmmeta::FieldId& parent, algo::strptr rhs, dmmeta_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dmmeta.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dmmeta::value_ReadStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dmmeta.FieldId..ReadStrptrMaybe
// Read fields of dmmeta::FieldId from an ascii string.
// The format of the string is the format of the dmmeta::FieldId's only field
bool dmmeta::FieldId_ReadStrptrMaybe(dmmeta::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dmmeta.FieldId..Print
// print string representation of dmmeta::FieldId to string LHS, no header -- cprint:dmmeta.FieldId.String
void dmmeta::FieldId_Print(dmmeta::FieldId & row, algo::cstring &str) {
    dmmeta::value_Print(row, str);
}

// --- dmmeta.Findrem..ReadFieldMaybe
bool dmmeta::Findrem_ReadFieldMaybe(dmmeta::Findrem &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Findrem..ReadStrptrMaybe
// Read fields of dmmeta::Findrem from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Findrem_ReadStrptrMaybe(dmmeta::Findrem &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.findrem") || algo::StripTypeTag(in_str, "dmmeta.Findrem");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Findrem_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Findrem..Print
// print string representation of dmmeta::Findrem to string LHS, no header -- cprint:dmmeta.Findrem.String
void dmmeta::Findrem_Print(dmmeta::Findrem & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.findrem";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Finput.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Finput& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Finput.ns.Get2
algo::Smallstr16 dmmeta::Finput_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Finput..ReadFieldMaybe
bool dmmeta::Finput_ReadFieldMaybe(dmmeta::Finput &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_extrn: retval = bool_ReadStrptrMaybe(parent.extrn, strval); break;
        case dmmeta_FieldId_update: retval = bool_ReadStrptrMaybe(parent.update, strval); break;
        case dmmeta_FieldId_strict: retval = bool_ReadStrptrMaybe(parent.strict, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Finput..ReadStrptrMaybe
// Read fields of dmmeta::Finput from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Finput_ReadStrptrMaybe(dmmeta::Finput &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.finput") || algo::StripTypeTag(in_str, "dmmeta.Finput");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Finput_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Finput..Print
// print string representation of dmmeta::Finput to string LHS, no header -- cprint:dmmeta.Finput.String
void dmmeta::Finput_Print(dmmeta::Finput & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.finput";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.update, temp);
    PrintAttrSpaceReset(str,"update", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fldoffset..ReadFieldMaybe
bool dmmeta::Fldoffset_ReadFieldMaybe(dmmeta::Fldoffset &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_offset: retval = i32_ReadStrptrMaybe(parent.offset, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fldoffset..ReadStrptrMaybe
// Read fields of dmmeta::Fldoffset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fldoffset_ReadStrptrMaybe(dmmeta::Fldoffset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fldoffset") || algo::StripTypeTag(in_str, "dmmeta.Fldoffset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fldoffset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fldoffset..Print
// print string representation of dmmeta::Fldoffset to string LHS, no header -- cprint:dmmeta.Fldoffset.String
void dmmeta::Fldoffset_Print(dmmeta::Fldoffset & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fldoffset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.offset, temp);
    PrintAttrSpaceReset(str,"offset", temp);
}

// --- dmmeta.Floadtuples.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Floadtuples& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Floadtuples.ctype.Get2
algo::Smallstr50 dmmeta::Floadtuples_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Floadtuples..ReadFieldMaybe
bool dmmeta::Floadtuples_ReadFieldMaybe(dmmeta::Floadtuples &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Floadtuples..ReadStrptrMaybe
// Read fields of dmmeta::Floadtuples from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Floadtuples_ReadStrptrMaybe(dmmeta::Floadtuples &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.floadtuples") || algo::StripTypeTag(in_str, "dmmeta.Floadtuples");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Floadtuples_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Floadtuples..Print
// print string representation of dmmeta::Floadtuples to string LHS, no header -- cprint:dmmeta.Floadtuples.String
void dmmeta::Floadtuples_Print(dmmeta::Floadtuples & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.floadtuples";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fnoremove..ReadFieldMaybe
bool dmmeta::Fnoremove_ReadFieldMaybe(dmmeta::Fnoremove &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fnoremove..ReadStrptrMaybe
// Read fields of dmmeta::Fnoremove from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fnoremove_ReadStrptrMaybe(dmmeta::Fnoremove &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fnoremove") || algo::StripTypeTag(in_str, "dmmeta.Fnoremove");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fnoremove_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fnoremove..Print
// print string representation of dmmeta::Fnoremove to string LHS, no header -- cprint:dmmeta.Fnoremove.String
void dmmeta::Fnoremove_Print(dmmeta::Fnoremove & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fnoremove";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Foutput.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Foutput& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Foutput.ns.Get2
algo::Smallstr16 dmmeta::Foutput_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Foutput..ReadFieldMaybe
bool dmmeta::Foutput_ReadFieldMaybe(dmmeta::Foutput &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Foutput..ReadStrptrMaybe
// Read fields of dmmeta::Foutput from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Foutput_ReadStrptrMaybe(dmmeta::Foutput &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.foutput") || algo::StripTypeTag(in_str, "dmmeta.Foutput");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Foutput_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Foutput..Print
// print string representation of dmmeta::Foutput to string LHS, no header -- cprint:dmmeta.Foutput.String
void dmmeta::Foutput_Print(dmmeta::Foutput & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.foutput";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fprefix..ReadFieldMaybe
bool dmmeta::Fprefix_ReadFieldMaybe(dmmeta::Fprefix &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fprefix: retval = algo::Smallstr5_ReadStrptrMaybe(parent.fprefix, strval); break;
        case dmmeta_FieldId_reftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fprefix..ReadStrptrMaybe
// Read fields of dmmeta::Fprefix from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fprefix_ReadStrptrMaybe(dmmeta::Fprefix &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fprefix") || algo::StripTypeTag(in_str, "dmmeta.Fprefix");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fprefix_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fprefix..Print
// print string representation of dmmeta::Fprefix to string LHS, no header -- cprint:dmmeta.Fprefix.String
void dmmeta::Fprefix_Print(dmmeta::Fprefix & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fprefix";

    algo::Smallstr5_Print(row.fprefix, temp);
    PrintAttrSpaceReset(str,"fprefix", temp);

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fregx..ReadFieldMaybe
bool dmmeta::Fregx_ReadFieldMaybe(dmmeta::Fregx &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_partial: retval = bool_ReadStrptrMaybe(parent.partial, strval); break;
        case dmmeta_FieldId_regxtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.regxtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fregx..ReadStrptrMaybe
// Read fields of dmmeta::Fregx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fregx_ReadStrptrMaybe(dmmeta::Fregx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fregx") || algo::StripTypeTag(in_str, "dmmeta.Fregx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fregx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fregx..Print
// print string representation of dmmeta::Fregx to string LHS, no header -- cprint:dmmeta.Fregx.String
void dmmeta::Fregx_Print(dmmeta::Fregx & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fregx";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.partial, temp);
    PrintAttrSpaceReset(str,"partial", temp);

    algo::Smallstr50_Print(row.regxtype, temp);
    PrintAttrSpaceReset(str,"regxtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fsort..ReadFieldMaybe
bool dmmeta::Fsort_ReadFieldMaybe(dmmeta::Fsort &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_sorttype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.sorttype, strval); break;
        case dmmeta_FieldId_sortfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fsort..ReadStrptrMaybe
// Read fields of dmmeta::Fsort from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fsort_ReadStrptrMaybe(dmmeta::Fsort &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fsort") || algo::StripTypeTag(in_str, "dmmeta.Fsort");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fsort_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fsort..Print
// print string representation of dmmeta::Fsort to string LHS, no header -- cprint:dmmeta.Fsort.String
void dmmeta::Fsort_Print(dmmeta::Fsort & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fsort";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr50_Print(row.sorttype, temp);
    PrintAttrSpaceReset(str,"sorttype", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fstep.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fstep& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fstep, ""));
    return ret;
}

// --- dmmeta.Fstep.field.Get2
algo::Smallstr100 dmmeta::Fstep_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ""));
    return ret;
}

// --- dmmeta.Fstep.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fstep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.fstep, ".LL"));
    return ret;
}

// --- dmmeta.Fstep.ns.Get2
algo::Smallstr16 dmmeta::Fstep_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Fstep.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Fstep& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fstep, ".RR"));
    return ret;
}

// --- dmmeta.Fstep.name.Get2
algo::Smallstr50 dmmeta::Fstep_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Fstep..Concat_field
tempstr dmmeta::Fstep_Concat_field( const algo::strptr& field ) {
    return tempstr() << field ;
}

// --- dmmeta.Fstep..ReadFieldMaybe
bool dmmeta::Fstep_ReadFieldMaybe(dmmeta::Fstep &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fstep: retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval); break;
        case dmmeta_FieldId_field: retval = false; break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_steptype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.steptype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fstep..ReadStrptrMaybe
// Read fields of dmmeta::Fstep from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fstep_ReadStrptrMaybe(dmmeta::Fstep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fstep") || algo::StripTypeTag(in_str, "dmmeta.Fstep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fstep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fstep..Print
// print string representation of dmmeta::Fstep to string LHS, no header -- cprint:dmmeta.Fstep.String
void dmmeta::Fstep_Print(dmmeta::Fstep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fstep";

    algo::Smallstr100_Print(row.fstep, temp);
    PrintAttrSpaceReset(str,"fstep", temp);

    algo::Smallstr50_Print(row.steptype, temp);
    PrintAttrSpaceReset(str,"steptype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ftrace..ReadFieldMaybe
bool dmmeta::Ftrace_ReadFieldMaybe(dmmeta::Ftrace &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ftrace..ReadStrptrMaybe
// Read fields of dmmeta::Ftrace from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ftrace_ReadStrptrMaybe(dmmeta::Ftrace &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ftrace") || algo::StripTypeTag(in_str, "dmmeta.Ftrace");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ftrace_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ftrace..Print
// print string representation of dmmeta::Ftrace to string LHS, no header -- cprint:dmmeta.Ftrace.String
void dmmeta::Ftrace_Print(dmmeta::Ftrace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ftrace";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ftuple..ReadFieldMaybe
bool dmmeta::Ftuple_ReadFieldMaybe(dmmeta::Ftuple &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ftuple..ReadStrptrMaybe
// Read fields of dmmeta::Ftuple from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ftuple_ReadStrptrMaybe(dmmeta::Ftuple &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ftuple") || algo::StripTypeTag(in_str, "dmmeta.Ftuple");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ftuple_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ftuple..Print
// print string representation of dmmeta::Ftuple to string LHS, no header -- cprint:dmmeta.Ftuple.String
void dmmeta::Ftuple_Print(dmmeta::Ftuple & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ftuple";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Func.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Func& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.func, ".RL"));
    return ret;
}

// --- dmmeta.Func.field.Get2
algo::Smallstr100 dmmeta::Func_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Func.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Func& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.func, ".RR"));
    return ret;
}

// --- dmmeta.Func.name.Get2
algo::Smallstr50 dmmeta::Func_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Func.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Func& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.func, ".RL.RL"));
    return ret;
}

// --- dmmeta.Func.ctype.Get2
algo::Smallstr50 dmmeta::Func_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Func.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Func& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.func, ".RL.RL.RL"));
    return ret;
}

// --- dmmeta.Func.ns.Get2
algo::Smallstr16 dmmeta::Func_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL.RL"));
    return ret;
}

// --- dmmeta.Func..Concat_field_name
tempstr dmmeta::Func_Concat_field_name( const algo::strptr& field ,const algo::strptr& name ) {
    return tempstr() << field <<'.'<< name ;
}

// --- dmmeta.Func..ReadFieldMaybe
bool dmmeta::Func_ReadFieldMaybe(dmmeta::Func &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_func: retval = algo::Smallstr100_ReadStrptrMaybe(parent.func, strval); break;
        case dmmeta_FieldId_inl: retval = bool_ReadStrptrMaybe(parent.inl, strval); break;
        case dmmeta_FieldId_field: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_proto: retval = algo::cstring_ReadStrptrMaybe(parent.proto, strval); break;
        case dmmeta_FieldId_body: retval = algo::cstring_ReadStrptrMaybe(parent.body, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_deprecate: retval = bool_ReadStrptrMaybe(parent.deprecate, strval); break;
        case dmmeta_FieldId_ismacro: retval = bool_ReadStrptrMaybe(parent.ismacro, strval); break;
        case dmmeta_FieldId_extrn: retval = bool_ReadStrptrMaybe(parent.extrn, strval); break;
        case dmmeta_FieldId_glob: retval = bool_ReadStrptrMaybe(parent.glob, strval); break;
        case dmmeta_FieldId_priv: retval = bool_ReadStrptrMaybe(parent.priv, strval); break;
        case dmmeta_FieldId_ret: retval = algo::cstring_ReadStrptrMaybe(parent.ret, strval); break;
        case dmmeta_FieldId_comment: retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Func..ReadStrptrMaybe
// Read fields of dmmeta::Func from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Func_ReadStrptrMaybe(dmmeta::Func &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.func") || algo::StripTypeTag(in_str, "dmmeta.Func");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Func_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Func..Init
// Set all fields to initial values.
void dmmeta::Func_Init(dmmeta::Func& parent) {
    parent.inl = bool(false);
    parent.deprecate = bool(false);
    parent.ismacro = bool(false);
    parent.extrn = bool(false);
    parent.glob = bool(false);
    parent.priv = bool(false);
}

// --- dmmeta.Func..Print
// print string representation of dmmeta::Func to string LHS, no header -- cprint:dmmeta.Func.String
void dmmeta::Func_Print(dmmeta::Func & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.func";

    algo::Smallstr100_Print(row.func, temp);
    PrintAttrSpaceReset(str,"func", temp);

    bool_Print(row.inl, temp);
    PrintAttrSpaceReset(str,"inl", temp);

    algo::cstring_Print(row.proto, temp);
    PrintAttrSpaceReset(str,"proto", temp);

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);

    bool_Print(row.deprecate, temp);
    PrintAttrSpaceReset(str,"deprecate", temp);

    bool_Print(row.ismacro, temp);
    PrintAttrSpaceReset(str,"ismacro", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.glob, temp);
    PrintAttrSpaceReset(str,"glob", temp);

    bool_Print(row.priv, temp);
    PrintAttrSpaceReset(str,"priv", temp);

    algo::cstring_Print(row.ret, temp);
    PrintAttrSpaceReset(str,"ret", temp);

    algo::cstring_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Funique..ReadFieldMaybe
bool dmmeta::Funique_ReadFieldMaybe(dmmeta::Funique &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Funique..ReadStrptrMaybe
// Read fields of dmmeta::Funique from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Funique_ReadStrptrMaybe(dmmeta::Funique &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.funique") || algo::StripTypeTag(in_str, "dmmeta.Funique");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Funique_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Funique..Print
// print string representation of dmmeta::Funique to string LHS, no header -- cprint:dmmeta.Funique.String
void dmmeta::Funique_Print(dmmeta::Funique & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.funique";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fuserinit..ReadFieldMaybe
bool dmmeta::Fuserinit_ReadFieldMaybe(dmmeta::Fuserinit &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fuserinit..ReadStrptrMaybe
// Read fields of dmmeta::Fuserinit from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fuserinit_ReadStrptrMaybe(dmmeta::Fuserinit &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fuserinit") || algo::StripTypeTag(in_str, "dmmeta.Fuserinit");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fuserinit_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fuserinit..Print
// print string representation of dmmeta::Fuserinit to string LHS, no header -- cprint:dmmeta.Fuserinit.String
void dmmeta::Fuserinit_Print(dmmeta::Fuserinit & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fuserinit";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fwddecl.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fwddecl& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.fwddecl, ".LL"));
    return ret;
}

// --- dmmeta.Fwddecl.ns.Get2
algo::Smallstr16 dmmeta::Fwddecl_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Fwddecl.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Fwddecl& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fwddecl, ".LR"));
    return ret;
}

// --- dmmeta.Fwddecl.ctype.Get2
algo::Smallstr50 dmmeta::Fwddecl_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- dmmeta.Fwddecl..Concat_ns_ctype
tempstr dmmeta::Fwddecl_Concat_ns_ctype( const algo::strptr& ns ,const algo::strptr& ctype ) {
    return tempstr() << ns <<'.'<< ctype ;
}

// --- dmmeta.Fwddecl..ReadFieldMaybe
bool dmmeta::Fwddecl_ReadFieldMaybe(dmmeta::Fwddecl &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_fwddecl: retval = algo::Smallstr100_ReadStrptrMaybe(parent.fwddecl, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fwddecl..ReadStrptrMaybe
// Read fields of dmmeta::Fwddecl from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fwddecl_ReadStrptrMaybe(dmmeta::Fwddecl &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fwddecl") || algo::StripTypeTag(in_str, "dmmeta.Fwddecl");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fwddecl_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fwddecl..Print
// print string representation of dmmeta::Fwddecl to string LHS, no header -- cprint:dmmeta.Fwddecl.String
void dmmeta::Fwddecl_Print(dmmeta::Fwddecl & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.fwddecl";

    algo::Smallstr100_Print(row.fwddecl, temp);
    PrintAttrSpaceReset(str,"fwddecl", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Gconst.namefldctyp.Get
algo::Smallstr50 dmmeta::namefldctyp_Get(dmmeta::Gconst& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.namefld, ".RL"));
    return ret;
}

// --- dmmeta.Gconst.namefldctyp.Get2
algo::Smallstr50 dmmeta::Gconst_namefldctyp_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Gconst..ReadFieldMaybe
bool dmmeta::Gconst_ReadFieldMaybe(dmmeta::Gconst &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_namefld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.namefld, strval); break;
        case dmmeta_FieldId_idfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.idfld, strval); break;
        case dmmeta_FieldId_wantenum: retval = bool_ReadStrptrMaybe(parent.wantenum, strval); break;
        case dmmeta_FieldId_namefldctyp: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gconst..ReadStrptrMaybe
// Read fields of dmmeta::Gconst from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gconst_ReadStrptrMaybe(dmmeta::Gconst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gconst") || algo::StripTypeTag(in_str, "dmmeta.Gconst");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gconst_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gconst..Print
// print string representation of dmmeta::Gconst to string LHS, no header -- cprint:dmmeta.Gconst.String
void dmmeta::Gconst_Print(dmmeta::Gconst & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.gconst";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.namefld, temp);
    PrintAttrSpaceReset(str,"namefld", temp);

    algo::Smallstr100_Print(row.idfld, temp);
    PrintAttrSpaceReset(str,"idfld", temp);

    bool_Print(row.wantenum, temp);
    PrintAttrSpaceReset(str,"wantenum", temp);
}

// --- dmmeta.Gstatic.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Gstatic& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Gstatic.ns.Get2
algo::Smallstr16 dmmeta::Gstatic_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Gstatic..ReadFieldMaybe
bool dmmeta::Gstatic_ReadFieldMaybe(dmmeta::Gstatic &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gstatic..ReadStrptrMaybe
// Read fields of dmmeta::Gstatic from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gstatic_ReadStrptrMaybe(dmmeta::Gstatic &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gstatic") || algo::StripTypeTag(in_str, "dmmeta.Gstatic");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gstatic_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gstatic..Print
// print string representation of dmmeta::Gstatic to string LHS, no header -- cprint:dmmeta.Gstatic.String
void dmmeta::Gstatic_Print(dmmeta::Gstatic & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.gstatic";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Gsymbol.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Gsymbol& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.gsymbol, "/RL"));
    return ret;
}

// --- dmmeta.Gsymbol.ns.Get2
algo::Smallstr16 dmmeta::Gsymbol_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Gsymbol.ssimfile.Get
algo::Smallstr50 dmmeta::ssimfile_Get(dmmeta::Gsymbol& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gsymbol, "/RR"));
    return ret;
}

// --- dmmeta.Gsymbol.ssimfile.Get2
algo::Smallstr50 dmmeta::Gsymbol_ssimfile_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Gsymbol..Concat_ns_ssimfile
tempstr dmmeta::Gsymbol_Concat_ns_ssimfile( const algo::strptr& ns ,const algo::strptr& ssimfile ) {
    return tempstr() << ns <<'/'<< ssimfile ;
}

// --- dmmeta.Gsymbol..ReadFieldMaybe
bool dmmeta::Gsymbol_ReadFieldMaybe(dmmeta::Gsymbol &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_gsymbol: retval = algo::Smallstr50_ReadStrptrMaybe(parent.gsymbol, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_ssimfile: retval = false; break;
        case dmmeta_FieldId_inc: retval = algo::Smallstr100_ReadStrptrMaybe(parent.inc, strval); break;
        case dmmeta_FieldId_symboltype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.symboltype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gsymbol..ReadStrptrMaybe
// Read fields of dmmeta::Gsymbol from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gsymbol_ReadStrptrMaybe(dmmeta::Gsymbol &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gsymbol") || algo::StripTypeTag(in_str, "dmmeta.Gsymbol");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gsymbol_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gsymbol..Print
// print string representation of dmmeta::Gsymbol to string LHS, no header -- cprint:dmmeta.Gsymbol.String
void dmmeta::Gsymbol_Print(dmmeta::Gsymbol & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.gsymbol";

    algo::Smallstr50_Print(row.gsymbol, temp);
    PrintAttrSpaceReset(str,"gsymbol", temp);

    algo::Smallstr100_Print(row.inc, temp);
    PrintAttrSpaceReset(str,"inc", temp);

    algo::Smallstr50_Print(row.symboltype, temp);
    PrintAttrSpaceReset(str,"symboltype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Hashtype..ReadFieldMaybe
bool dmmeta::Hashtype_ReadFieldMaybe(dmmeta::Hashtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_hashtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.hashtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Hashtype..ReadStrptrMaybe
// Read fields of dmmeta::Hashtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Hashtype_ReadStrptrMaybe(dmmeta::Hashtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.hashtype") || algo::StripTypeTag(in_str, "dmmeta.Hashtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hashtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Hashtype..Print
// print string representation of dmmeta::Hashtype to string LHS, no header -- cprint:dmmeta.Hashtype.String
void dmmeta::Hashtype_Print(dmmeta::Hashtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.hashtype";

    algo::Smallstr50_Print(row.hashtype, temp);
    PrintAttrSpaceReset(str,"hashtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Hook..ReadFieldMaybe
bool dmmeta::Hook_ReadFieldMaybe(dmmeta::Hook &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Hook..ReadStrptrMaybe
// Read fields of dmmeta::Hook from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Hook_ReadStrptrMaybe(dmmeta::Hook &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.hook") || algo::StripTypeTag(in_str, "dmmeta.Hook");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hook_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Hook..Print
// print string representation of dmmeta::Hook to string LHS, no header -- cprint:dmmeta.Hook.String
void dmmeta::Hook_Print(dmmeta::Hook & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.hook";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Inlary..ReadFieldMaybe
bool dmmeta::Inlary_ReadFieldMaybe(dmmeta::Inlary &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_min: retval = i32_ReadStrptrMaybe(parent.min, strval); break;
        case dmmeta_FieldId_max: retval = i32_ReadStrptrMaybe(parent.max, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Inlary..ReadStrptrMaybe
// Read fields of dmmeta::Inlary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Inlary_ReadStrptrMaybe(dmmeta::Inlary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.inlary") || algo::StripTypeTag(in_str, "dmmeta.Inlary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Inlary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Inlary..Print
// print string representation of dmmeta::Inlary to string LHS, no header -- cprint:dmmeta.Inlary.String
void dmmeta::Inlary_Print(dmmeta::Inlary & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.inlary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.min, temp);
    PrintAttrSpaceReset(str,"min", temp);

    i32_Print(row.max, temp);
    PrintAttrSpaceReset(str,"max", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Lenfld.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Lenfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Lenfld.ctype.Get2
algo::Smallstr50 dmmeta::Lenfld_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Lenfld..ReadFieldMaybe
bool dmmeta::Lenfld_ReadFieldMaybe(dmmeta::Lenfld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_extra: retval = i32_ReadStrptrMaybe(parent.extra, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Lenfld..ReadStrptrMaybe
// Read fields of dmmeta::Lenfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Lenfld_ReadStrptrMaybe(dmmeta::Lenfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.lenfld") || algo::StripTypeTag(in_str, "dmmeta.Lenfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Lenfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Lenfld..Print
// print string representation of dmmeta::Lenfld to string LHS, no header -- cprint:dmmeta.Lenfld.String
void dmmeta::Lenfld_Print(dmmeta::Lenfld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.lenfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.extra, temp);
    PrintAttrSpaceReset(str,"extra", temp);
}

// --- dmmeta.Listtype..ReadFieldMaybe
bool dmmeta::Listtype_ReadFieldMaybe(dmmeta::Listtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_listtype: retval = algo::Smallstr5_ReadStrptrMaybe(parent.listtype, strval); break;
        case dmmeta_FieldId_circular: retval = bool_ReadStrptrMaybe(parent.circular, strval); break;
        case dmmeta_FieldId_haveprev: retval = bool_ReadStrptrMaybe(parent.haveprev, strval); break;
        case dmmeta_FieldId_instail: retval = bool_ReadStrptrMaybe(parent.instail, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Listtype..ReadStrptrMaybe
// Read fields of dmmeta::Listtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Listtype_ReadStrptrMaybe(dmmeta::Listtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.listtype") || algo::StripTypeTag(in_str, "dmmeta.Listtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Listtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Listtype..Print
// print string representation of dmmeta::Listtype to string LHS, no header -- cprint:dmmeta.Listtype.String
void dmmeta::Listtype_Print(dmmeta::Listtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.listtype";

    algo::Smallstr5_Print(row.listtype, temp);
    PrintAttrSpaceReset(str,"listtype", temp);

    bool_Print(row.circular, temp);
    PrintAttrSpaceReset(str,"circular", temp);

    bool_Print(row.haveprev, temp);
    PrintAttrSpaceReset(str,"haveprev", temp);

    bool_Print(row.instail, temp);
    PrintAttrSpaceReset(str,"instail", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Llist.listtype.Get
algo::Smallstr5 dmmeta::listtype_Get(dmmeta::Llist& parent) {
    algo::Smallstr5 ret(algo::Pathcomp(parent.field, ".RR_LL"));
    return ret;
}

// --- dmmeta.Llist.listtype.Get2
algo::Smallstr5 dmmeta::Llist_listtype_Get(algo::strptr arg) {
    algo::Smallstr5 ret(algo::Pathcomp(arg, ".RR_LL"));
    return ret;
}

// --- dmmeta.Llist..ReadFieldMaybe
bool dmmeta::Llist_ReadFieldMaybe(dmmeta::Llist &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_havetail: retval = bool_ReadStrptrMaybe(parent.havetail, strval); break;
        case dmmeta_FieldId_havecount: retval = bool_ReadStrptrMaybe(parent.havecount, strval); break;
        case dmmeta_FieldId_listtype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Llist..ReadStrptrMaybe
// Read fields of dmmeta::Llist from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Llist_ReadStrptrMaybe(dmmeta::Llist &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.llist") || algo::StripTypeTag(in_str, "dmmeta.Llist");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Llist_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Llist..Print
// print string representation of dmmeta::Llist to string LHS, no header -- cprint:dmmeta.Llist.String
void dmmeta::Llist_Print(dmmeta::Llist & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.llist";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.havetail, temp);
    PrintAttrSpaceReset(str,"havetail", temp);

    bool_Print(row.havecount, temp);
    PrintAttrSpaceReset(str,"havecount", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Logcat..ReadFieldMaybe
bool dmmeta::Logcat_ReadFieldMaybe(dmmeta::Logcat &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_logcat: retval = algo::Smallstr50_ReadStrptrMaybe(parent.logcat, strval); break;
        case dmmeta_FieldId_enabled: retval = bool_ReadStrptrMaybe(parent.enabled, strval); break;
        case dmmeta_FieldId_builtin: retval = bool_ReadStrptrMaybe(parent.builtin, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Logcat..ReadStrptrMaybe
// Read fields of dmmeta::Logcat from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Logcat_ReadStrptrMaybe(dmmeta::Logcat &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.logcat") || algo::StripTypeTag(in_str, "dmmeta.Logcat");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Logcat_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Logcat..Print
// print string representation of dmmeta::Logcat to string LHS, no header -- cprint:dmmeta.Logcat.String
void dmmeta::Logcat_Print(dmmeta::Logcat & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.logcat";

    algo::Smallstr50_Print(row.logcat, temp);
    PrintAttrSpaceReset(str,"logcat", temp);

    bool_Print(row.enabled, temp);
    PrintAttrSpaceReset(str,"enabled", temp);

    bool_Print(row.builtin, temp);
    PrintAttrSpaceReset(str,"builtin", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Main..ReadFieldMaybe
bool dmmeta::Main_ReadFieldMaybe(dmmeta::Main &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_ismodule: retval = bool_ReadStrptrMaybe(parent.ismodule, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Main..ReadStrptrMaybe
// Read fields of dmmeta::Main from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Main_ReadStrptrMaybe(dmmeta::Main &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.main") || algo::StripTypeTag(in_str, "dmmeta.Main");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Main_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Main..Print
// print string representation of dmmeta::Main to string LHS, no header -- cprint:dmmeta.Main.String
void dmmeta::Main_Print(dmmeta::Main & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.main";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    bool_Print(row.ismodule, temp);
    PrintAttrSpaceReset(str,"ismodule", temp);
}

// --- dmmeta.Msgtype..ReadFieldMaybe
bool dmmeta::Msgtype_ReadFieldMaybe(dmmeta::Msgtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_type: retval = algo::CppExpr_ReadStrptrMaybe(parent.type, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Msgtype..ReadStrptrMaybe
// Read fields of dmmeta::Msgtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Msgtype_ReadStrptrMaybe(dmmeta::Msgtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.msgtype") || algo::StripTypeTag(in_str, "dmmeta.Msgtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Msgtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Msgtype..Print
// print string representation of dmmeta::Msgtype to string LHS, no header -- cprint:dmmeta.Msgtype.String
void dmmeta::Msgtype_Print(dmmeta::Msgtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.msgtype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::CppExpr_Print(row.type, temp);
    PrintAttrSpaceReset(str,"type", temp);
}

// --- dmmeta.Nocascdel..ReadFieldMaybe
bool dmmeta::Nocascdel_ReadFieldMaybe(dmmeta::Nocascdel &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_xref: retval = algo::Smallstr100_ReadStrptrMaybe(parent.xref, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nocascdel..ReadStrptrMaybe
// Read fields of dmmeta::Nocascdel from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nocascdel_ReadStrptrMaybe(dmmeta::Nocascdel &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nocascdel") || algo::StripTypeTag(in_str, "dmmeta.Nocascdel");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nocascdel_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nocascdel..Print
// print string representation of dmmeta::Nocascdel to string LHS, no header -- cprint:dmmeta.Nocascdel.String
void dmmeta::Nocascdel_Print(dmmeta::Nocascdel & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nocascdel";

    algo::Smallstr100_Print(row.xref, temp);
    PrintAttrSpaceReset(str,"xref", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nossimfile..ReadFieldMaybe
bool dmmeta::Nossimfile_ReadFieldMaybe(dmmeta::Nossimfile &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nossimfile..ReadStrptrMaybe
// Read fields of dmmeta::Nossimfile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nossimfile_ReadStrptrMaybe(dmmeta::Nossimfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nossimfile") || algo::StripTypeTag(in_str, "dmmeta.Nossimfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nossimfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nossimfile..Print
// print string representation of dmmeta::Nossimfile to string LHS, no header -- cprint:dmmeta.Nossimfile.String
void dmmeta::Nossimfile_Print(dmmeta::Nossimfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nossimfile";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Noxref..ReadFieldMaybe
bool dmmeta::Noxref_ReadFieldMaybe(dmmeta::Noxref &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Noxref..ReadStrptrMaybe
// Read fields of dmmeta::Noxref from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Noxref_ReadStrptrMaybe(dmmeta::Noxref &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.noxref") || algo::StripTypeTag(in_str, "dmmeta.Noxref");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Noxref_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Noxref..Print
// print string representation of dmmeta::Noxref to string LHS, no header -- cprint:dmmeta.Noxref.String
void dmmeta::Noxref_Print(dmmeta::Noxref & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.noxref";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ns..ReadFieldMaybe
bool dmmeta::Ns_ReadFieldMaybe(dmmeta::Ns &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_nstype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval); break;
        case dmmeta_FieldId_license: retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ns..ReadStrptrMaybe
// Read fields of dmmeta::Ns from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ns_ReadStrptrMaybe(dmmeta::Ns &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ns") || algo::StripTypeTag(in_str, "dmmeta.Ns");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ns_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ns..Print
// print string representation of dmmeta::Ns to string LHS, no header -- cprint:dmmeta.Ns.String
void dmmeta::Ns_Print(dmmeta::Ns & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ns";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Smallstr50_Print(row.nstype, temp);
    PrintAttrSpaceReset(str,"nstype", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nscpp..ReadFieldMaybe
bool dmmeta::Nscpp_ReadFieldMaybe(dmmeta::Nscpp &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nscpp..ReadStrptrMaybe
// Read fields of dmmeta::Nscpp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nscpp_ReadStrptrMaybe(dmmeta::Nscpp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nscpp") || algo::StripTypeTag(in_str, "dmmeta.Nscpp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nscpp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nscpp..Print
// print string representation of dmmeta::Nscpp to string LHS, no header -- cprint:dmmeta.Nscpp.String
void dmmeta::Nscpp_Print(dmmeta::Nscpp & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nscpp";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsdb..ReadFieldMaybe
bool dmmeta::Nsdb_ReadFieldMaybe(dmmeta::Nsdb &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsdb..ReadStrptrMaybe
// Read fields of dmmeta::Nsdb from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsdb_ReadStrptrMaybe(dmmeta::Nsdb &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsdb") || algo::StripTypeTag(in_str, "dmmeta.Nsdb");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsdb_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsdb..Print
// print string representation of dmmeta::Nsdb to string LHS, no header -- cprint:dmmeta.Nsdb.String
void dmmeta::Nsdb_Print(dmmeta::Nsdb & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nsdb";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsinclude.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Nsinclude& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.nsinclude, "/LL"));
    return ret;
}

// --- dmmeta.Nsinclude.ns.Get2
algo::Smallstr16 dmmeta::Nsinclude_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Nsinclude.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Nsinclude& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.nsinclude, "/LR"));
    return ret;
}

// --- dmmeta.Nsinclude.name.Get2
algo::Smallstr50 dmmeta::Nsinclude_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dmmeta.Nsinclude..Concat_ns_name
tempstr dmmeta::Nsinclude_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'/'<< name ;
}

// --- dmmeta.Nsinclude..ReadFieldMaybe
bool dmmeta::Nsinclude_ReadFieldMaybe(dmmeta::Nsinclude &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_nsinclude: retval = algo::Smallstr50_ReadStrptrMaybe(parent.nsinclude, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_sys: retval = bool_ReadStrptrMaybe(parent.sys, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsinclude..ReadStrptrMaybe
// Read fields of dmmeta::Nsinclude from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsinclude_ReadStrptrMaybe(dmmeta::Nsinclude &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsinclude") || algo::StripTypeTag(in_str, "dmmeta.Nsinclude");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsinclude_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsinclude..Print
// print string representation of dmmeta::Nsinclude to string LHS, no header -- cprint:dmmeta.Nsinclude.String
void dmmeta::Nsinclude_Print(dmmeta::Nsinclude & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nsinclude";

    algo::Smallstr50_Print(row.nsinclude, temp);
    PrintAttrSpaceReset(str,"nsinclude", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsproto..ReadFieldMaybe
bool dmmeta::Nsproto_ReadFieldMaybe(dmmeta::Nsproto &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsproto..ReadStrptrMaybe
// Read fields of dmmeta::Nsproto from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsproto_ReadStrptrMaybe(dmmeta::Nsproto &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsproto") || algo::StripTypeTag(in_str, "dmmeta.Nsproto");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsproto_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsproto..Print
// print string representation of dmmeta::Nsproto to string LHS, no header -- cprint:dmmeta.Nsproto.String
void dmmeta::Nsproto_Print(dmmeta::Nsproto & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nsproto";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nstype..ReadFieldMaybe
bool dmmeta::Nstype_ReadFieldMaybe(dmmeta::Nstype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_nstype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nstype..ReadStrptrMaybe
// Read fields of dmmeta::Nstype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nstype_ReadStrptrMaybe(dmmeta::Nstype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nstype") || algo::StripTypeTag(in_str, "dmmeta.Nstype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nstype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nstype..Print
// print string representation of dmmeta::Nstype to string LHS, no header -- cprint:dmmeta.Nstype.String
void dmmeta::Nstype_Print(dmmeta::Nstype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nstype";

    algo::Smallstr50_Print(row.nstype, temp);
    PrintAttrSpaceReset(str,"nstype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsversion..ReadFieldMaybe
bool dmmeta::Nsversion_ReadFieldMaybe(dmmeta::Nsversion &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_version: retval = algo::Smallstr10_ReadStrptrMaybe(parent.version, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsversion..ReadStrptrMaybe
// Read fields of dmmeta::Nsversion from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsversion_ReadStrptrMaybe(dmmeta::Nsversion &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsversion") || algo::StripTypeTag(in_str, "dmmeta.Nsversion");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsversion_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsversion..Print
// print string representation of dmmeta::Nsversion to string LHS, no header -- cprint:dmmeta.Nsversion.String
void dmmeta::Nsversion_Print(dmmeta::Nsversion & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nsversion";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Smallstr10_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsx..ReadFieldMaybe
bool dmmeta::Nsx_ReadFieldMaybe(dmmeta::Nsx &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ns: retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval); break;
        case dmmeta_FieldId_genthrow: retval = bool_ReadStrptrMaybe(parent.genthrow, strval); break;
        case dmmeta_FieldId_correct_getorcreate: retval = bool_ReadStrptrMaybe(parent.correct_getorcreate, strval); break;
        case dmmeta_FieldId_pool: retval = algo::Smallstr100_ReadStrptrMaybe(parent.pool, strval); break;
        case dmmeta_FieldId_sortxref: retval = bool_ReadStrptrMaybe(parent.sortxref, strval); break;
        case dmmeta_FieldId_pack: retval = bool_ReadStrptrMaybe(parent.pack, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsx..ReadStrptrMaybe
// Read fields of dmmeta::Nsx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsx_ReadStrptrMaybe(dmmeta::Nsx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsx") || algo::StripTypeTag(in_str, "dmmeta.Nsx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsx..Print
// print string representation of dmmeta::Nsx to string LHS, no header -- cprint:dmmeta.Nsx.String
void dmmeta::Nsx_Print(dmmeta::Nsx & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.nsx";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    bool_Print(row.genthrow, temp);
    PrintAttrSpaceReset(str,"genthrow", temp);

    bool_Print(row.correct_getorcreate, temp);
    PrintAttrSpaceReset(str,"correct_getorcreate", temp);

    algo::Smallstr100_Print(row.pool, temp);
    PrintAttrSpaceReset(str,"pool", temp);

    bool_Print(row.sortxref, temp);
    PrintAttrSpaceReset(str,"sortxref", temp);

    bool_Print(row.pack, temp);
    PrintAttrSpaceReset(str,"pack", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Numstr..ReadFieldMaybe
bool dmmeta::Numstr_ReadFieldMaybe(dmmeta::Numstr &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_numtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.numtype, strval); break;
        case dmmeta_FieldId_base: retval = i32_ReadStrptrMaybe(parent.base, strval); break;
        case dmmeta_FieldId_min_len: retval = i32_ReadStrptrMaybe(parent.min_len, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Numstr..ReadStrptrMaybe
// Read fields of dmmeta::Numstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Numstr_ReadStrptrMaybe(dmmeta::Numstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.numstr") || algo::StripTypeTag(in_str, "dmmeta.Numstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Numstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Numstr..Print
// print string representation of dmmeta::Numstr to string LHS, no header -- cprint:dmmeta.Numstr.String
void dmmeta::Numstr_Print(dmmeta::Numstr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.numstr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr50_Print(row.numtype, temp);
    PrintAttrSpaceReset(str,"numtype", temp);

    i32_Print(row.base, temp);
    PrintAttrSpaceReset(str,"base", temp);

    i32_Print(row.min_len, temp);
    PrintAttrSpaceReset(str,"min_len", temp);
}

// --- dmmeta.Pack..ReadFieldMaybe
bool dmmeta::Pack_ReadFieldMaybe(dmmeta::Pack &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pack..ReadStrptrMaybe
// Read fields of dmmeta::Pack from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pack_ReadStrptrMaybe(dmmeta::Pack &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pack") || algo::StripTypeTag(in_str, "dmmeta.Pack");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pack_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pack..Print
// print string representation of dmmeta::Pack to string LHS, no header -- cprint:dmmeta.Pack.String
void dmmeta::Pack_Print(dmmeta::Pack & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.pack";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Pmaskfld.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Pmaskfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Pmaskfld.ctype.Get2
algo::Smallstr50 dmmeta::Pmaskfld_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Pmaskfld..ReadFieldMaybe
bool dmmeta::Pmaskfld_ReadFieldMaybe(dmmeta::Pmaskfld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pmaskfld..ReadStrptrMaybe
// Read fields of dmmeta::Pmaskfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pmaskfld_ReadStrptrMaybe(dmmeta::Pmaskfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pmaskfld") || algo::StripTypeTag(in_str, "dmmeta.Pmaskfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pmaskfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pmaskfld..Print
// print string representation of dmmeta::Pmaskfld to string LHS, no header -- cprint:dmmeta.Pmaskfld.String
void dmmeta::Pmaskfld_Print(dmmeta::Pmaskfld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.pmaskfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Pnew.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Pnew& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.pnew, "/LL"));
    return ret;
}

// --- dmmeta.Pnew.ns.Get2
algo::Smallstr16 dmmeta::Pnew_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Pnew.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Pnew& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pnew, "/LR.RL"));
    return ret;
}

// --- dmmeta.Pnew.ctype.Get2
algo::Smallstr50 dmmeta::Pnew_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR.RL"));
    return ret;
}

// --- dmmeta.Pnew.buftype.Get
algo::Smallstr50 dmmeta::buftype_Get(dmmeta::Pnew& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pnew, "/LR.RR"));
    return ret;
}

// --- dmmeta.Pnew.buftype.Get2
algo::Smallstr50 dmmeta::Pnew_buftype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR.RR"));
    return ret;
}

// --- dmmeta.Pnew..Concat_ns_ctype_buftype
tempstr dmmeta::Pnew_Concat_ns_ctype_buftype( const algo::strptr& ns ,const algo::strptr& ctype ,const algo::strptr& buftype ) {
    return tempstr() << ns <<'/'<< ctype <<'.'<< buftype ;
}

// --- dmmeta.Pnew..ReadFieldMaybe
bool dmmeta::Pnew_ReadFieldMaybe(dmmeta::Pnew &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_pnew: retval = algo::Smallstr100_ReadStrptrMaybe(parent.pnew, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_buftype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pnew..ReadStrptrMaybe
// Read fields of dmmeta::Pnew from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pnew_ReadStrptrMaybe(dmmeta::Pnew &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pnew") || algo::StripTypeTag(in_str, "dmmeta.Pnew");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pnew_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pnew..Print
// print string representation of dmmeta::Pnew to string LHS, no header -- cprint:dmmeta.Pnew.String
void dmmeta::Pnew_Print(dmmeta::Pnew & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.pnew";

    algo::Smallstr100_Print(row.pnew, temp);
    PrintAttrSpaceReset(str,"pnew", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Printfmt..ReadFieldMaybe
bool dmmeta::Printfmt_ReadFieldMaybe(dmmeta::Printfmt &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_printfmt: retval = algo::Smallstr50_ReadStrptrMaybe(parent.printfmt, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Printfmt..ReadStrptrMaybe
// Read fields of dmmeta::Printfmt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Printfmt_ReadStrptrMaybe(dmmeta::Printfmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.printfmt") || algo::StripTypeTag(in_str, "dmmeta.Printfmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Printfmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Printfmt..Print
// print string representation of dmmeta::Printfmt to string LHS, no header -- cprint:dmmeta.Printfmt.String
void dmmeta::Printfmt_Print(dmmeta::Printfmt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.printfmt";

    algo::Smallstr50_Print(row.printfmt, temp);
    PrintAttrSpaceReset(str,"printfmt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ptrary..ReadFieldMaybe
bool dmmeta::Ptrary_ReadFieldMaybe(dmmeta::Ptrary &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_unique: retval = bool_ReadStrptrMaybe(parent.unique, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ptrary..ReadStrptrMaybe
// Read fields of dmmeta::Ptrary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ptrary_ReadStrptrMaybe(dmmeta::Ptrary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ptrary") || algo::StripTypeTag(in_str, "dmmeta.Ptrary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ptrary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ptrary..Print
// print string representation of dmmeta::Ptrary to string LHS, no header -- cprint:dmmeta.Ptrary.String
void dmmeta::Ptrary_Print(dmmeta::Ptrary & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ptrary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.unique, temp);
    PrintAttrSpaceReset(str,"unique", temp);
}

// --- dmmeta.Reftype..ReadFieldMaybe
bool dmmeta::Reftype_ReadFieldMaybe(dmmeta::Reftype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_reftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval); break;
        case dmmeta_FieldId_isval: retval = bool_ReadStrptrMaybe(parent.isval, strval); break;
        case dmmeta_FieldId_cascins: retval = bool_ReadStrptrMaybe(parent.cascins, strval); break;
        case dmmeta_FieldId_usebasepool: retval = bool_ReadStrptrMaybe(parent.usebasepool, strval); break;
        case dmmeta_FieldId_cancopy: retval = bool_ReadStrptrMaybe(parent.cancopy, strval); break;
        case dmmeta_FieldId_isxref: retval = bool_ReadStrptrMaybe(parent.isxref, strval); break;
        case dmmeta_FieldId_del: retval = bool_ReadStrptrMaybe(parent.del, strval); break;
        case dmmeta_FieldId_up: retval = bool_ReadStrptrMaybe(parent.up, strval); break;
        case dmmeta_FieldId_isnew: retval = bool_ReadStrptrMaybe(parent.isnew, strval); break;
        case dmmeta_FieldId_hasalloc: retval = bool_ReadStrptrMaybe(parent.hasalloc, strval); break;
        case dmmeta_FieldId_inst: retval = bool_ReadStrptrMaybe(parent.inst, strval); break;
        case dmmeta_FieldId_varlen: retval = bool_ReadStrptrMaybe(parent.varlen, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Reftype..ReadStrptrMaybe
// Read fields of dmmeta::Reftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Reftype_ReadStrptrMaybe(dmmeta::Reftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.reftype") || algo::StripTypeTag(in_str, "dmmeta.Reftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Reftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Reftype..Init
// Set all fields to initial values.
void dmmeta::Reftype_Init(dmmeta::Reftype& parent) {
    parent.reftype = algo::strptr("Val");
    parent.isval = bool(false);
    parent.cascins = bool(false);
    parent.usebasepool = bool(false);
    parent.cancopy = bool(false);
    parent.isxref = bool(false);
    parent.del = bool(false);
    parent.up = bool(false);
    parent.isnew = bool(false);
    parent.hasalloc = bool(false);
    parent.inst = bool(false);
    parent.varlen = bool(false);
}

// --- dmmeta.Reftype..Print
// print string representation of dmmeta::Reftype to string LHS, no header -- cprint:dmmeta.Reftype.String
void dmmeta::Reftype_Print(dmmeta::Reftype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.reftype";

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    bool_Print(row.isval, temp);
    PrintAttrSpaceReset(str,"isval", temp);

    bool_Print(row.cascins, temp);
    PrintAttrSpaceReset(str,"cascins", temp);

    bool_Print(row.usebasepool, temp);
    PrintAttrSpaceReset(str,"usebasepool", temp);

    bool_Print(row.cancopy, temp);
    PrintAttrSpaceReset(str,"cancopy", temp);

    bool_Print(row.isxref, temp);
    PrintAttrSpaceReset(str,"isxref", temp);

    bool_Print(row.del, temp);
    PrintAttrSpaceReset(str,"del", temp);

    bool_Print(row.up, temp);
    PrintAttrSpaceReset(str,"up", temp);

    bool_Print(row.isnew, temp);
    PrintAttrSpaceReset(str,"isnew", temp);

    bool_Print(row.hasalloc, temp);
    PrintAttrSpaceReset(str,"hasalloc", temp);

    bool_Print(row.inst, temp);
    PrintAttrSpaceReset(str,"inst", temp);

    bool_Print(row.varlen, temp);
    PrintAttrSpaceReset(str,"varlen", temp);
}

// --- dmmeta.ReftypeCase.reftype.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::reftype_ToCstr(const dmmeta::ReftypeCase& parent) {
    const char *ret = NULL;
    switch(reftype_GetEnum(parent)) {
        case dmmeta_ReftypeCase_Alias      : ret = "Alias";  break;
        case dmmeta_ReftypeCase_Atree      : ret = "Atree";  break;
        case dmmeta_ReftypeCase_Base       : ret = "Base";  break;
        case dmmeta_ReftypeCase_Bheap      : ret = "Bheap";  break;
        case dmmeta_ReftypeCase_Bitfld     : ret = "Bitfld";  break;
        case dmmeta_ReftypeCase_Blkpool    : ret = "Blkpool";  break;
        case dmmeta_ReftypeCase_Charset    : ret = "Charset";  break;
        case dmmeta_ReftypeCase_Count      : ret = "Count";  break;
        case dmmeta_ReftypeCase_Cppstack   : ret = "Cppstack";  break;
        case dmmeta_ReftypeCase_Delptr     : ret = "Delptr";  break;
        case dmmeta_ReftypeCase_Exec       : ret = "Exec";  break;
        case dmmeta_ReftypeCase_Fbuf       : ret = "Fbuf";  break;
        case dmmeta_ReftypeCase_Global     : ret = "Global";  break;
        case dmmeta_ReftypeCase_Hook       : ret = "Hook";  break;
        case dmmeta_ReftypeCase_Inlary     : ret = "Inlary";  break;
        case dmmeta_ReftypeCase_Lary       : ret = "Lary";  break;
        case dmmeta_ReftypeCase_Llist      : ret = "Llist";  break;
        case dmmeta_ReftypeCase_Lpool      : ret = "Lpool";  break;
        case dmmeta_ReftypeCase_Malloc     : ret = "Malloc";  break;
        case dmmeta_ReftypeCase_Opt        : ret = "Opt";  break;
        case dmmeta_ReftypeCase_Pkey       : ret = "Pkey";  break;
        case dmmeta_ReftypeCase_Protocol   : ret = "Protocol";  break;
        case dmmeta_ReftypeCase_Ptr        : ret = "Ptr";  break;
        case dmmeta_ReftypeCase_Ptrary     : ret = "Ptrary";  break;
        case dmmeta_ReftypeCase_Regx       : ret = "Regx";  break;
        case dmmeta_ReftypeCase_RegxSql    : ret = "RegxSql";  break;
        case dmmeta_ReftypeCase_Sbrk       : ret = "Sbrk";  break;
        case dmmeta_ReftypeCase_Smallstr   : ret = "Smallstr";  break;
        case dmmeta_ReftypeCase_Tary       : ret = "Tary";  break;
        case dmmeta_ReftypeCase_Thash      : ret = "Thash";  break;
        case dmmeta_ReftypeCase_Tpool      : ret = "Tpool";  break;
        case dmmeta_ReftypeCase_Upptr      : ret = "Upptr";  break;
        case dmmeta_ReftypeCase_Val        : ret = "Val";  break;
        case dmmeta_ReftypeCase_Varlen     : ret = "Varlen";  break;
        case dmmeta_ReftypeCase_ZSListMT   : ret = "ZSListMT";  break;
    }
    return ret;
}

// --- dmmeta.ReftypeCase.reftype.Print
// Convert reftype to a string. First, attempt conversion to a known string.
// If no string matches, print reftype as a numeric value.
void dmmeta::reftype_Print(const dmmeta::ReftypeCase& parent, algo::cstring &lhs) {
    const char *strval = reftype_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.reftype;
    }
}

// --- dmmeta.ReftypeCase.reftype.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::reftype_SetStrptrMaybe(dmmeta::ReftypeCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('O','p','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Opt); ret = true; break;
                }
                case LE_STR3('P','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Ptr); ret = true; break;
                }
                case LE_STR3('V','a','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Val); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('B','a','s','e'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Base); ret = true; break;
                }
                case LE_STR4('E','x','e','c'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Exec); ret = true; break;
                }
                case LE_STR4('F','b','u','f'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Fbuf); ret = true; break;
                }
                case LE_STR4('H','o','o','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Hook); ret = true; break;
                }
                case LE_STR4('L','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Lary); ret = true; break;
                }
                case LE_STR4('P','k','e','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Pkey); ret = true; break;
                }
                case LE_STR4('R','e','g','x'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Regx); ret = true; break;
                }
                case LE_STR4('S','b','r','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Sbrk); ret = true; break;
                }
                case LE_STR4('T','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Tary); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('A','l','i','a','s'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Alias); ret = true; break;
                }
                case LE_STR5('A','t','r','e','e'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Atree); ret = true; break;
                }
                case LE_STR5('B','h','e','a','p'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Bheap); ret = true; break;
                }
                case LE_STR5('C','o','u','n','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Count); ret = true; break;
                }
                case LE_STR5('L','l','i','s','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Llist); ret = true; break;
                }
                case LE_STR5('L','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Lpool); ret = true; break;
                }
                case LE_STR5('T','h','a','s','h'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Thash); ret = true; break;
                }
                case LE_STR5('T','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Tpool); ret = true; break;
                }
                case LE_STR5('U','p','p','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Upptr); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('B','i','t','f','l','d'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Bitfld); ret = true; break;
                }
                case LE_STR6('D','e','l','p','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Delptr); ret = true; break;
                }
                case LE_STR6('G','l','o','b','a','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Global); ret = true; break;
                }
                case LE_STR6('I','n','l','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Inlary); ret = true; break;
                }
                case LE_STR6('M','a','l','l','o','c'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Malloc); ret = true; break;
                }
                case LE_STR6('P','t','r','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Ptrary); ret = true; break;
                }
                case LE_STR6('V','a','r','l','e','n'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Varlen); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('B','l','k','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Blkpool); ret = true; break;
                }
                case LE_STR7('C','h','a','r','s','e','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Charset); ret = true; break;
                }
                case LE_STR7('R','e','g','x','S','q','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_RegxSql); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('C','p','p','s','t','a','c','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Cppstack); ret = true; break;
                }
                case LE_STR8('P','r','o','t','o','c','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Protocol); ret = true; break;
                }
                case LE_STR8('S','m','a','l','l','s','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Smallstr); ret = true; break;
                }
                case LE_STR8('Z','S','L','i','s','t','M','T'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_ZSListMT); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.ReftypeCase.reftype.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::reftype_SetStrptr(dmmeta::ReftypeCase& parent, algo::strptr rhs, dmmeta_ReftypeCaseEnum dflt) {
    if (!reftype_SetStrptrMaybe(parent,rhs)) reftype_SetEnum(parent,dflt);
}

// --- dmmeta.Rowid..ReadFieldMaybe
bool dmmeta::Rowid_ReadFieldMaybe(dmmeta::Rowid &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Rowid..ReadStrptrMaybe
// Read fields of dmmeta::Rowid from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Rowid_ReadStrptrMaybe(dmmeta::Rowid &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.rowid") || algo::StripTypeTag(in_str, "dmmeta.Rowid");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Rowid_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Rowid..Print
// print string representation of dmmeta::Rowid to string LHS, no header -- cprint:dmmeta.Rowid.String
void dmmeta::Rowid_Print(dmmeta::Rowid & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.rowid";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Smallstr.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Smallstr& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Smallstr.ctype.Get2
algo::Smallstr50 dmmeta::Smallstr_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Smallstr..ReadFieldMaybe
bool dmmeta::Smallstr_ReadFieldMaybe(dmmeta::Smallstr &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_length: retval = i32_ReadStrptrMaybe(parent.length, strval); break;
        case dmmeta_FieldId_strtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.strtype, strval); break;
        case dmmeta_FieldId_pad: retval = algo::CppExpr_ReadStrptrMaybe(parent.pad, strval); break;
        case dmmeta_FieldId_strict: retval = bool_ReadStrptrMaybe(parent.strict, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Smallstr..ReadStrptrMaybe
// Read fields of dmmeta::Smallstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Smallstr_ReadStrptrMaybe(dmmeta::Smallstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.smallstr") || algo::StripTypeTag(in_str, "dmmeta.Smallstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Smallstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Smallstr..Print
// print string representation of dmmeta::Smallstr to string LHS, no header -- cprint:dmmeta.Smallstr.String
void dmmeta::Smallstr_Print(dmmeta::Smallstr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.smallstr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.length, temp);
    PrintAttrSpaceReset(str,"length", temp);

    algo::Smallstr50_Print(row.strtype, temp);
    PrintAttrSpaceReset(str,"strtype", temp);

    algo::CppExpr_Print(row.pad, temp);
    PrintAttrSpaceReset(str,"pad", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);
}

// --- dmmeta.Sortfld..ReadFieldMaybe
bool dmmeta::Sortfld_ReadFieldMaybe(dmmeta::Sortfld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_sortfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sortfld..ReadStrptrMaybe
// Read fields of dmmeta::Sortfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sortfld_ReadStrptrMaybe(dmmeta::Sortfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sortfld") || algo::StripTypeTag(in_str, "dmmeta.Sortfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sortfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sortfld..Print
// print string representation of dmmeta::Sortfld to string LHS, no header -- cprint:dmmeta.Sortfld.String
void dmmeta::Sortfld_Print(dmmeta::Sortfld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.sortfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);
}

// --- dmmeta.Sorttype..ReadFieldMaybe
bool dmmeta::Sorttype_ReadFieldMaybe(dmmeta::Sorttype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_sorttype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.sorttype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sorttype..ReadStrptrMaybe
// Read fields of dmmeta::Sorttype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sorttype_ReadStrptrMaybe(dmmeta::Sorttype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sorttype") || algo::StripTypeTag(in_str, "dmmeta.Sorttype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sorttype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sorttype..Print
// print string representation of dmmeta::Sorttype to string LHS, no header -- cprint:dmmeta.Sorttype.String
void dmmeta::Sorttype_Print(dmmeta::Sorttype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.sorttype";

    algo::Smallstr50_Print(row.sorttype, temp);
    PrintAttrSpaceReset(str,"sorttype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Sqltype..ReadFieldMaybe
bool dmmeta::Sqltype_ReadFieldMaybe(dmmeta::Sqltype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_expr: retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sqltype..ReadStrptrMaybe
// Read fields of dmmeta::Sqltype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sqltype_ReadStrptrMaybe(dmmeta::Sqltype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sqltype") || algo::StripTypeTag(in_str, "dmmeta.Sqltype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sqltype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sqltype..Print
// print string representation of dmmeta::Sqltype to string LHS, no header -- cprint:dmmeta.Sqltype.String
void dmmeta::Sqltype_Print(dmmeta::Sqltype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.sqltype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimfile.ssimns.Get
algo::Smallstr16 dmmeta::ssimns_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ssimfile, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ssimns.Get2
algo::Smallstr16 dmmeta::Ssimfile_ssimns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ssimfile, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ns.Get2
algo::Smallstr16 dmmeta::Ssimfile_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ssimfile, ".RR"));
    return ret;
}

// --- dmmeta.Ssimfile.name.Get2
algo::Smallstr50 dmmeta::Ssimfile_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Ssimfile..ReadFieldMaybe
bool dmmeta::Ssimfile_ReadFieldMaybe(dmmeta::Ssimfile &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval); break;
        case dmmeta_FieldId_ssimns: retval = false; break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimfile..ReadStrptrMaybe
// Read fields of dmmeta::Ssimfile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimfile_ReadStrptrMaybe(dmmeta::Ssimfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimfile") || algo::StripTypeTag(in_str, "dmmeta.Ssimfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimfile..Print
// print string representation of dmmeta::Ssimfile to string LHS, no header -- cprint:dmmeta.Ssimfile.String
void dmmeta::Ssimfile_Print(dmmeta::Ssimfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ssimfile";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);
}

// --- dmmeta.Ssimreq..ReadFieldMaybe
bool dmmeta::Ssimreq_ReadFieldMaybe(dmmeta::Ssimreq &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval); break;
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_value: retval = algo::Smallstr100_ReadStrptrMaybe(parent.value, strval); break;
        case dmmeta_FieldId_bidir: retval = bool_ReadStrptrMaybe(parent.bidir, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimreq..ReadStrptrMaybe
// Read fields of dmmeta::Ssimreq from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimreq_ReadStrptrMaybe(dmmeta::Ssimreq &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimreq") || algo::StripTypeTag(in_str, "dmmeta.Ssimreq");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimreq_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimreq..Print
// print string representation of dmmeta::Ssimreq to string LHS, no header -- cprint:dmmeta.Ssimreq.String
void dmmeta::Ssimreq_Print(dmmeta::Ssimreq & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ssimreq";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    bool_Print(row.bidir, temp);
    PrintAttrSpaceReset(str,"bidir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimsort..ReadFieldMaybe
bool dmmeta::Ssimsort_ReadFieldMaybe(dmmeta::Ssimsort &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval); break;
        case dmmeta_FieldId_sortfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimsort..ReadStrptrMaybe
// Read fields of dmmeta::Ssimsort from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimsort_ReadStrptrMaybe(dmmeta::Ssimsort &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimsort") || algo::StripTypeTag(in_str, "dmmeta.Ssimsort");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimsort_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimsort..Print
// print string representation of dmmeta::Ssimsort to string LHS, no header -- cprint:dmmeta.Ssimsort.String
void dmmeta::Ssimsort_Print(dmmeta::Ssimsort & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ssimsort";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimvolatile..ReadFieldMaybe
bool dmmeta::Ssimvolatile_ReadFieldMaybe(dmmeta::Ssimvolatile &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimvolatile..ReadStrptrMaybe
// Read fields of dmmeta::Ssimvolatile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimvolatile_ReadStrptrMaybe(dmmeta::Ssimvolatile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimvolatile") || algo::StripTypeTag(in_str, "dmmeta.Ssimvolatile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimvolatile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimvolatile..Print
// print string representation of dmmeta::Ssimvolatile to string LHS, no header -- cprint:dmmeta.Ssimvolatile.String
void dmmeta::Ssimvolatile_Print(dmmeta::Ssimvolatile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.ssimvolatile";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Steptype..ReadFieldMaybe
bool dmmeta::Steptype_ReadFieldMaybe(dmmeta::Steptype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_steptype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.steptype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Steptype..ReadStrptrMaybe
// Read fields of dmmeta::Steptype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Steptype_ReadStrptrMaybe(dmmeta::Steptype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.steptype") || algo::StripTypeTag(in_str, "dmmeta.Steptype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Steptype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Steptype..Print
// print string representation of dmmeta::Steptype to string LHS, no header -- cprint:dmmeta.Steptype.String
void dmmeta::Steptype_Print(dmmeta::Steptype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.steptype";

    algo::Smallstr50_Print(row.steptype, temp);
    PrintAttrSpaceReset(str,"steptype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Strtype..ReadFieldMaybe
bool dmmeta::Strtype_ReadFieldMaybe(dmmeta::Strtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_strtype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.strtype, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Strtype..ReadStrptrMaybe
// Read fields of dmmeta::Strtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Strtype_ReadStrptrMaybe(dmmeta::Strtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.strtype") || algo::StripTypeTag(in_str, "dmmeta.Strtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Strtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Strtype..Print
// print string representation of dmmeta::Strtype to string LHS, no header -- cprint:dmmeta.Strtype.String
void dmmeta::Strtype_Print(dmmeta::Strtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.strtype";

    algo::Smallstr50_Print(row.strtype, temp);
    PrintAttrSpaceReset(str,"strtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Substr..ReadFieldMaybe
bool dmmeta::Substr_ReadFieldMaybe(dmmeta::Substr &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_expr: retval = algo::CppExpr_ReadStrptrMaybe(parent.expr, strval); break;
        case dmmeta_FieldId_srcfield: retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Substr..ReadStrptrMaybe
// Read fields of dmmeta::Substr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Substr_ReadStrptrMaybe(dmmeta::Substr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.substr") || algo::StripTypeTag(in_str, "dmmeta.Substr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Substr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Substr..Print
// print string representation of dmmeta::Substr to string LHS, no header -- cprint:dmmeta.Substr.String
void dmmeta::Substr_Print(dmmeta::Substr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.substr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);
}

// --- dmmeta.Svtype..ReadFieldMaybe
bool dmmeta::Svtype_ReadFieldMaybe(dmmeta::Svtype &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case dmmeta_FieldId_maxwid: retval = i32_ReadStrptrMaybe(parent.maxwid, strval); break;
        case dmmeta_FieldId_fixedwid1: retval = i32_ReadStrptrMaybe(parent.fixedwid1, strval); break;
        case dmmeta_FieldId_fixedwid2: retval = i32_ReadStrptrMaybe(parent.fixedwid2, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Svtype..ReadStrptrMaybe
// Read fields of dmmeta::Svtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Svtype_ReadStrptrMaybe(dmmeta::Svtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.svtype") || algo::StripTypeTag(in_str, "dmmeta.Svtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Svtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Svtype..Print
// print string representation of dmmeta::Svtype to string LHS, no header -- cprint:dmmeta.Svtype.String
void dmmeta::Svtype_Print(dmmeta::Svtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.svtype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    i32_Print(row.maxwid, temp);
    PrintAttrSpaceReset(str,"maxwid", temp);

    i32_Print(row.fixedwid1, temp);
    PrintAttrSpaceReset(str,"fixedwid1", temp);

    i32_Print(row.fixedwid2, temp);
    PrintAttrSpaceReset(str,"fixedwid2", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tary..ReadFieldMaybe
bool dmmeta::Tary_ReadFieldMaybe(dmmeta::Tary &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_aliased: retval = bool_ReadStrptrMaybe(parent.aliased, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tary..ReadStrptrMaybe
// Read fields of dmmeta::Tary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tary_ReadStrptrMaybe(dmmeta::Tary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tary") || algo::StripTypeTag(in_str, "dmmeta.Tary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tary..Print
// print string representation of dmmeta::Tary to string LHS, no header -- cprint:dmmeta.Tary.String
void dmmeta::Tary_Print(dmmeta::Tary & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.tary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.aliased, temp);
    PrintAttrSpaceReset(str,"aliased", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Thash..ReadFieldMaybe
bool dmmeta::Thash_ReadFieldMaybe(dmmeta::Thash &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_hashfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.hashfld, strval); break;
        case dmmeta_FieldId_unique: retval = bool_ReadStrptrMaybe(parent.unique, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Thash..ReadStrptrMaybe
// Read fields of dmmeta::Thash from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Thash_ReadStrptrMaybe(dmmeta::Thash &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.thash") || algo::StripTypeTag(in_str, "dmmeta.Thash");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Thash_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Thash..Print
// print string representation of dmmeta::Thash to string LHS, no header -- cprint:dmmeta.Thash.String
void dmmeta::Thash_Print(dmmeta::Thash & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.thash";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.hashfld, temp);
    PrintAttrSpaceReset(str,"hashfld", temp);

    bool_Print(row.unique, temp);
    PrintAttrSpaceReset(str,"unique", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tracefld.tracerec.Get
algo::Smallstr50 dmmeta::tracerec_Get(dmmeta::Tracefld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracefld, ".RL"));
    return ret;
}

// --- dmmeta.Tracefld.tracerec.Get2
algo::Smallstr50 dmmeta::Tracefld_tracerec_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Tracefld.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Tracefld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracefld, ".RR"));
    return ret;
}

// --- dmmeta.Tracefld.name.Get2
algo::Smallstr50 dmmeta::Tracefld_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Tracefld..Concat_tracerec_name
tempstr dmmeta::Tracefld_Concat_tracerec_name( const algo::strptr& tracerec ,const algo::strptr& name ) {
    return tempstr() << tracerec <<'.'<< name ;
}

// --- dmmeta.Tracefld..ReadFieldMaybe
bool dmmeta::Tracefld_ReadFieldMaybe(dmmeta::Tracefld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_tracefld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.tracefld, strval); break;
        case dmmeta_FieldId_tracerec: retval = false; break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tracefld..ReadStrptrMaybe
// Read fields of dmmeta::Tracefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tracefld_ReadStrptrMaybe(dmmeta::Tracefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tracefld") || algo::StripTypeTag(in_str, "dmmeta.Tracefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tracefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tracefld..Print
// print string representation of dmmeta::Tracefld to string LHS, no header -- cprint:dmmeta.Tracefld.String
void dmmeta::Tracefld_Print(dmmeta::Tracefld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.tracefld";

    algo::Smallstr100_Print(row.tracefld, temp);
    PrintAttrSpaceReset(str,"tracefld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tracerec.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Tracerec& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracerec, ".LL"));
    return ret;
}

// --- dmmeta.Tracerec.name.Get2
algo::Smallstr50 dmmeta::Tracerec_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Tracerec..ReadFieldMaybe
bool dmmeta::Tracerec_ReadFieldMaybe(dmmeta::Tracerec &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_tracerec: retval = algo::Smallstr50_ReadStrptrMaybe(parent.tracerec, strval); break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tracerec..ReadStrptrMaybe
// Read fields of dmmeta::Tracerec from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tracerec_ReadStrptrMaybe(dmmeta::Tracerec &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tracerec") || algo::StripTypeTag(in_str, "dmmeta.Tracerec");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tracerec_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tracerec..Print
// print string representation of dmmeta::Tracerec to string LHS, no header -- cprint:dmmeta.Tracerec.String
void dmmeta::Tracerec_Print(dmmeta::Tracerec & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.tracerec";

    algo::Smallstr50_Print(row.tracerec, temp);
    PrintAttrSpaceReset(str,"tracerec", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Typefld.ctype.Get
algo::Smallstr50 dmmeta::ctype_Get(dmmeta::Typefld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Typefld.ctype.Get2
algo::Smallstr50 dmmeta::Typefld_ctype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Typefld..ReadFieldMaybe
bool dmmeta::Typefld_ReadFieldMaybe(dmmeta::Typefld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_ctype: retval = false; break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Typefld..ReadStrptrMaybe
// Read fields of dmmeta::Typefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Typefld_ReadStrptrMaybe(dmmeta::Typefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.typefld") || algo::StripTypeTag(in_str, "dmmeta.Typefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Typefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Typefld..Print
// print string representation of dmmeta::Typefld to string LHS, no header -- cprint:dmmeta.Typefld.String
void dmmeta::Typefld_Print(dmmeta::Typefld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.typefld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Usertracefld..ReadFieldMaybe
bool dmmeta::Usertracefld_ReadFieldMaybe(dmmeta::Usertracefld &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_tracefld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.tracefld, strval); break;
        case dmmeta_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Usertracefld..ReadStrptrMaybe
// Read fields of dmmeta::Usertracefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Usertracefld_ReadStrptrMaybe(dmmeta::Usertracefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.usertracefld") || algo::StripTypeTag(in_str, "dmmeta.Usertracefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Usertracefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Usertracefld..Print
// print string representation of dmmeta::Usertracefld to string LHS, no header -- cprint:dmmeta.Usertracefld.String
void dmmeta::Usertracefld_Print(dmmeta::Usertracefld & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.usertracefld";

    algo::Smallstr100_Print(row.tracefld, temp);
    PrintAttrSpaceReset(str,"tracefld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Xref.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Xref& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Xref.name.Get2
algo::Smallstr50 dmmeta::Xref_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Xref.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Xref& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Xref.ns.Get2
algo::Smallstr16 dmmeta::Xref_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Xref.viafld.Get
algo::Smallstr100 dmmeta::viafld_Get(dmmeta::Xref& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.via, "/LL"));
    return ret;
}

// --- dmmeta.Xref.viafld.Get2
algo::Smallstr100 dmmeta::Xref_viafld_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Xref.keyfld.Get
algo::Smallstr100 dmmeta::keyfld_Get(dmmeta::Xref& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.via, "/RR"));
    return ret;
}

// --- dmmeta.Xref.keyfld.Get2
algo::Smallstr100 dmmeta::Xref_keyfld_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Xref..ReadFieldMaybe
bool dmmeta::Xref_ReadFieldMaybe(dmmeta::Xref &parent, algo::strptr field, algo::strptr strval) {
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dmmeta_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case dmmeta_FieldId_name: retval = false; break;
        case dmmeta_FieldId_inscond: retval = algo::CppExpr_ReadStrptrMaybe(parent.inscond, strval); break;
        case dmmeta_FieldId_ns: retval = false; break;
        case dmmeta_FieldId_via: retval = algo::Smallstr200_ReadStrptrMaybe(parent.via, strval); break;
        case dmmeta_FieldId_viafld: retval = false; break;
        case dmmeta_FieldId_keyfld: retval = false; break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Xref..ReadStrptrMaybe
// Read fields of dmmeta::Xref from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Xref_ReadStrptrMaybe(dmmeta::Xref &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.xref") || algo::StripTypeTag(in_str, "dmmeta.Xref");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Xref_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Xref..Print
// print string representation of dmmeta::Xref to string LHS, no header -- cprint:dmmeta.Xref.String
void dmmeta::Xref_Print(dmmeta::Xref & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dmmeta.xref";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.inscond, temp);
    PrintAttrSpaceReset(str,"inscond", temp);

    algo::Smallstr200_Print(row.via, temp);
    PrintAttrSpaceReset(str,"via", temp);
}

// --- dmmeta...SizeCheck
inline static void dmmeta::SizeCheck() {
}
