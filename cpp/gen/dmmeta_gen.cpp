//
// cpp/gen/dmmeta_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dmmeta.Buftype.pnewtype
const char *dmmeta_Buftype_pnewtype_Memptr      = "Memptr";
const char *dmmeta_Buftype_pnewtype_AmsStream   = "AmsStream";
const char *dmmeta_Buftype_pnewtype_Fixed       = "Fixed";
const char *dmmeta_Buftype_pnewtype_Dynamic     = "Dynamic";
const char *dmmeta_Buftype_pnewtype_ByteAry     = "ByteAry";
const char *dmmeta_Buftype_pnewtype_Append      = "Append";

// compile-time string constants for dmmeta.Fastenc.fastenc
const char *dmmeta_Fastenc_fastenc_byteVector   = "byteVector";
const char *dmmeta_Fastenc_fastenc_group        = "group";
const char *dmmeta_Fastenc_fastenc_scaled       = "scaled";
const char *dmmeta_Fastenc_fastenc_sequence     = "sequence";
const char *dmmeta_Fastenc_fastenc_signed       = "signed";
const char *dmmeta_Fastenc_fastenc_string       = "string";
const char *dmmeta_Fastenc_fastenc_template     = "template";
const char *dmmeta_Fastenc_fastenc_type         = "type";
const char *dmmeta_Fastenc_fastenc_unsigned     = "unsigned";

// compile-time string constants for dmmeta.Fastinstr.fastinstr
const char *dmmeta_Fastinstr_fastinstr_field    = "field";
const char *dmmeta_Fastinstr_fastinstr_length   = "length";

const char *dmmeta_Fastinstr_fastinstr_mantissa   = "mantissa";

// compile-time string constants for dmmeta.Fastop.fastop
const char *dmmeta_Fastop_fastop_constant    = "constant";
const char *dmmeta_Fastop_fastop_copy        = "copy";
const char *dmmeta_Fastop_fastop_default     = "default";
const char *dmmeta_Fastop_fastop_delta       = "delta";
const char *dmmeta_Fastop_fastop_increment   = "increment";
const char *dmmeta_Fastop_fastop_none        = "none";
const char *dmmeta_Fastop_fastop_tail        = "tail";

// compile-time string constants for dmmeta.Fbufdir.fbufdir
const char *dmmeta_Fbufdir_fbufdir_in    = "in";
const char *dmmeta_Fbufdir_fbufdir_out   = "out";

// compile-time string constants for dmmeta.Fbuftype.fbuftype
const char *dmmeta_Fbuftype_fbuftype_Bytebuf   = "Bytebuf";
const char *dmmeta_Fbuftype_fbuftype_Linebuf   = "Linebuf";
const char *dmmeta_Fbuftype_fbuftype_Msgbuf    = "Msgbuf";

// compile-time string constants for dmmeta.Hashtype.hashtype
const char *dmmeta_Hashtype_hashtype_Extern   = "Extern";
const char *dmmeta_Hashtype_hashtype_CRC32    = "CRC32";

// compile-time string constants for dmmeta.Ns.ns
const char *dmmeta_Ns_ns_            = "";
const char *dmmeta_Ns_ns_abt         = "abt";
const char *dmmeta_Ns_ns_abt_md      = "abt_md";
const char *dmmeta_Ns_ns_acr         = "acr";
const char *dmmeta_Ns_ns_acr_compl   = "acr_compl";
const char *dmmeta_Ns_ns_acr_dm      = "acr_dm";
const char *dmmeta_Ns_ns_acr_ed      = "acr_ed";
const char *dmmeta_Ns_ns_acr_in      = "acr_in";
const char *dmmeta_Ns_ns_acr_my      = "acr_my";
const char *dmmeta_Ns_ns_algo        = "algo";
const char *dmmeta_Ns_ns_algo_lib    = "algo_lib";
const char *dmmeta_Ns_ns_amc         = "amc";
const char *dmmeta_Ns_ns_amc_gc      = "amc_gc";
const char *dmmeta_Ns_ns_amc_vis     = "amc_vis";
const char *dmmeta_Ns_ns_amcdb       = "amcdb";

const char *dmmeta_Ns_ns_ams            = "ams";
const char *dmmeta_Ns_ns_ams_cat        = "ams_cat";
const char *dmmeta_Ns_ns_ams_sendtest   = "ams_sendtest";
const char *dmmeta_Ns_ns_amsdb          = "amsdb";
const char *dmmeta_Ns_ns_apm            = "apm";
const char *dmmeta_Ns_ns_aqlite         = "aqlite";
const char *dmmeta_Ns_ns_atf            = "atf";
const char *dmmeta_Ns_ns_atf_amc        = "atf_amc";
const char *dmmeta_Ns_ns_atf_ci         = "atf_ci";
const char *dmmeta_Ns_ns_atf_cmdline    = "atf_cmdline";
const char *dmmeta_Ns_ns_atf_comp       = "atf_comp";
const char *dmmeta_Ns_ns_atf_cov        = "atf_cov";
const char *dmmeta_Ns_ns_atf_fuzz       = "atf_fuzz";
const char *dmmeta_Ns_ns_atf_gcli       = "atf_gcli";
const char *dmmeta_Ns_ns_atf_nrun       = "atf_nrun";
const char *dmmeta_Ns_ns_atf_unit       = "atf_unit";
const char *dmmeta_Ns_ns_atfdb          = "atfdb";
const char *dmmeta_Ns_ns_bash2html      = "bash2html";
const char *dmmeta_Ns_ns_command        = "command";
const char *dmmeta_Ns_ns_dev            = "dev";
const char *dmmeta_Ns_ns_dmmeta         = "dmmeta";
const char *dmmeta_Ns_ns_fm             = "fm";
const char *dmmeta_Ns_ns_fmdb           = "fmdb";
const char *dmmeta_Ns_ns_gcache         = "gcache";
const char *dmmeta_Ns_ns_gcli           = "gcli";
const char *dmmeta_Ns_ns_gclidb         = "gclidb";

const char *dmmeta_Ns_ns_ietf         = "ietf";
const char *dmmeta_Ns_ns_lib_amcdb    = "lib_amcdb";
const char *dmmeta_Ns_ns_lib_ams      = "lib_ams";
const char *dmmeta_Ns_ns_lib_ctype    = "lib_ctype";
const char *dmmeta_Ns_ns_lib_exec     = "lib_exec";
const char *dmmeta_Ns_ns_lib_fm       = "lib_fm";
const char *dmmeta_Ns_ns_lib_git      = "lib_git";
const char *dmmeta_Ns_ns_lib_iconv    = "lib_iconv";
const char *dmmeta_Ns_ns_lib_json     = "lib_json";
const char *dmmeta_Ns_ns_lib_mysql    = "lib_mysql";
const char *dmmeta_Ns_ns_lib_prot     = "lib_prot";
const char *dmmeta_Ns_ns_lib_sql      = "lib_sql";
const char *dmmeta_Ns_ns_lib_sqlite   = "lib_sqlite";
const char *dmmeta_Ns_ns_mdbg         = "mdbg";
const char *dmmeta_Ns_ns_mysql2ssim   = "mysql2ssim";
const char *dmmeta_Ns_ns_orgfile      = "orgfile";
const char *dmmeta_Ns_ns_report       = "report";
const char *dmmeta_Ns_ns_samp_regx    = "samp_regx";
const char *dmmeta_Ns_ns_sandbox      = "sandbox";
const char *dmmeta_Ns_ns_src_func     = "src_func";
const char *dmmeta_Ns_ns_src_hdr      = "src_hdr";
const char *dmmeta_Ns_ns_src_lim      = "src_lim";

const char *dmmeta_Ns_ns_ssim2csv     = "ssim2csv";
const char *dmmeta_Ns_ns_ssim2mysql   = "ssim2mysql";
const char *dmmeta_Ns_ns_ssimfilt     = "ssimfilt";

const char *dmmeta_Ns_ns_strconv   = "strconv";
const char *dmmeta_Ns_ns_sv2ssim   = "sv2ssim";

// compile-time string constants for dmmeta.Nstype.nstype
const char *dmmeta_Nstype_nstype_exe   = "exe";
const char *dmmeta_Nstype_nstype_lib   = "lib";

const char *dmmeta_Nstype_nstype_none      = "none";
const char *dmmeta_Nstype_nstype_objlist   = "objlist";

const char *dmmeta_Nstype_nstype_protocol   = "protocol";
const char *dmmeta_Nstype_nstype_ssimdb     = "ssimdb";

// compile-time string constants for dmmeta.Printfmt.printfmt
const char *dmmeta_Printfmt_printfmt_Auto         = "Auto";
const char *dmmeta_Printfmt_printfmt_Bitset       = "Bitset";
const char *dmmeta_Printfmt_printfmt_CompactSep   = "CompactSep";
const char *dmmeta_Printfmt_printfmt_Extern       = "Extern";
const char *dmmeta_Printfmt_printfmt_Raw          = "Raw";
const char *dmmeta_Printfmt_printfmt_Sep          = "Sep";
const char *dmmeta_Printfmt_printfmt_Tuple        = "Tuple";

// compile-time string constants for dmmeta.Reftype.reftype
const char *dmmeta_Reftype_reftype_Alias      = "Alias";
const char *dmmeta_Reftype_reftype_Atree      = "Atree";
const char *dmmeta_Reftype_reftype_Base       = "Base";
const char *dmmeta_Reftype_reftype_Bheap      = "Bheap";
const char *dmmeta_Reftype_reftype_Bitfld     = "Bitfld";
const char *dmmeta_Reftype_reftype_Blkpool    = "Blkpool";
const char *dmmeta_Reftype_reftype_Charset    = "Charset";
const char *dmmeta_Reftype_reftype_Count      = "Count";
const char *dmmeta_Reftype_reftype_Cppstack   = "Cppstack";
const char *dmmeta_Reftype_reftype_Delptr     = "Delptr";
const char *dmmeta_Reftype_reftype_Exec       = "Exec";
const char *dmmeta_Reftype_reftype_Fbuf       = "Fbuf";
const char *dmmeta_Reftype_reftype_Global     = "Global";
const char *dmmeta_Reftype_reftype_Hook       = "Hook";
const char *dmmeta_Reftype_reftype_Inlary     = "Inlary";
const char *dmmeta_Reftype_reftype_Lary       = "Lary";
const char *dmmeta_Reftype_reftype_Llist      = "Llist";
const char *dmmeta_Reftype_reftype_Lpool      = "Lpool";
const char *dmmeta_Reftype_reftype_Malloc     = "Malloc";
const char *dmmeta_Reftype_reftype_Opt        = "Opt";
const char *dmmeta_Reftype_reftype_Pkey       = "Pkey";
const char *dmmeta_Reftype_reftype_Protocol   = "Protocol";
const char *dmmeta_Reftype_reftype_Ptr        = "Ptr";
const char *dmmeta_Reftype_reftype_Ptrary     = "Ptrary";

const char *dmmeta_Reftype_reftype_Regx      = "Regx";
const char *dmmeta_Reftype_reftype_RegxSql   = "RegxSql";
const char *dmmeta_Reftype_reftype_Sbrk      = "Sbrk";

const char *dmmeta_Reftype_reftype_Smallstr   = "Smallstr";
const char *dmmeta_Reftype_reftype_Tary       = "Tary";
const char *dmmeta_Reftype_reftype_Thash      = "Thash";
const char *dmmeta_Reftype_reftype_Tpool      = "Tpool";
const char *dmmeta_Reftype_reftype_Upptr      = "Upptr";
const char *dmmeta_Reftype_reftype_Val        = "Val";
const char *dmmeta_Reftype_reftype_Varlen     = "Varlen";
const char *dmmeta_Reftype_reftype_ZSListMT   = "ZSListMT";

// compile-time string constants for dmmeta.Sorttype.sorttype
const char *dmmeta_Sorttype_sorttype_QuickSort       = "QuickSort";
const char *dmmeta_Sorttype_sorttype_InsertionSort   = "InsertionSort";
const char *dmmeta_Sorttype_sorttype_HeapSort        = "HeapSort";

// compile-time string constants for dmmeta.Ssimfile.ssimfile
const char *dmmeta_Ssimfile_ssimfile_amcdb_bltin      = "amcdb.bltin";
const char *dmmeta_Ssimfile_ssimfile_amcdb_curstype   = "amcdb.curstype";
const char *dmmeta_Ssimfile_ssimfile_amcdb_gen        = "amcdb.gen";
const char *dmmeta_Ssimfile_ssimfile_amcdb_regxtype   = "amcdb.regxtype";

const char *dmmeta_Ssimfile_ssimfile_amcdb_tclass       = "amcdb.tclass";
const char *dmmeta_Ssimfile_ssimfile_amcdb_tcurs        = "amcdb.tcurs";
const char *dmmeta_Ssimfile_ssimfile_amcdb_tfunc        = "amcdb.tfunc";
const char *dmmeta_Ssimfile_ssimfile_amsdb_proctype     = "amsdb.proctype";
const char *dmmeta_Ssimfile_ssimfile_amsdb_streamtype   = "amsdb.streamtype";
const char *dmmeta_Ssimfile_ssimfile_atfdb_amctest      = "atfdb.amctest";
const char *dmmeta_Ssimfile_ssimfile_atfdb_cijob        = "atfdb.cijob";

const char *dmmeta_Ssimfile_ssimfile_atfdb_cipackage   = "atfdb.cipackage";
const char *dmmeta_Ssimfile_ssimfile_atfdb_citest      = "atfdb.citest";
const char *dmmeta_Ssimfile_ssimfile_atfdb_comptest    = "atfdb.comptest";

const char *dmmeta_Ssimfile_ssimfile_atfdb_fuzzstrat             = "atfdb.fuzzstrat";
const char *dmmeta_Ssimfile_ssimfile_atfdb_msgdir                = "atfdb.msgdir";
const char *dmmeta_Ssimfile_ssimfile_atfdb_targs                 = "atfdb.targs";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_char     = "atfdb.test_gsymbol_char";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_pkey     = "atfdb.test_gsymbol_pkey";
const char *dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_strptr   = "atfdb.test_gsymbol_strptr";
const char *dmmeta_Ssimfile_ssimfile_atfdb_tfilt                 = "atfdb.tfilt";
const char *dmmeta_Ssimfile_ssimfile_atfdb_tmsg                  = "atfdb.tmsg";
const char *dmmeta_Ssimfile_ssimfile_atfdb_unittest              = "atfdb.unittest";
const char *dmmeta_Ssimfile_ssimfile_dev_arch                    = "dev.arch";
const char *dmmeta_Ssimfile_ssimfile_dev_badline                 = "dev.badline";
const char *dmmeta_Ssimfile_ssimfile_dev_builddir                = "dev.builddir";
const char *dmmeta_Ssimfile_ssimfile_dev_cfg                     = "dev.cfg";
const char *dmmeta_Ssimfile_ssimfile_dev_compiler                = "dev.compiler";
const char *dmmeta_Ssimfile_ssimfile_dev_copyright               = "dev.copyright";
const char *dmmeta_Ssimfile_ssimfile_dev_covfile                 = "dev.covfile";
const char *dmmeta_Ssimfile_ssimfile_dev_covline                 = "dev.covline";
const char *dmmeta_Ssimfile_ssimfile_dev_covtarget               = "dev.covtarget";
const char *dmmeta_Ssimfile_ssimfile_dev_edaction                = "dev.edaction";
const char *dmmeta_Ssimfile_ssimfile_dev_edacttype               = "dev.edacttype";
const char *dmmeta_Ssimfile_ssimfile_dev_gitfile                 = "dev.gitfile";
const char *dmmeta_Ssimfile_ssimfile_dev_gitinfo                 = "dev.gitinfo";
const char *dmmeta_Ssimfile_ssimfile_dev_hilite                  = "dev.hilite";
const char *dmmeta_Ssimfile_ssimfile_dev_htmlentity              = "dev.htmlentity";
const char *dmmeta_Ssimfile_ssimfile_dev_include                 = "dev.include";
const char *dmmeta_Ssimfile_ssimfile_dev_license                 = "dev.license";
const char *dmmeta_Ssimfile_ssimfile_dev_linelim                 = "dev.linelim";
const char *dmmeta_Ssimfile_ssimfile_dev_mdsection               = "dev.mdsection";
const char *dmmeta_Ssimfile_ssimfile_dev_msgfile                 = "dev.msgfile";
const char *dmmeta_Ssimfile_ssimfile_dev_noindent                = "dev.noindent";
const char *dmmeta_Ssimfile_ssimfile_dev_opt_type                = "dev.opt_type";
const char *dmmeta_Ssimfile_ssimfile_dev_package                 = "dev.package";
const char *dmmeta_Ssimfile_ssimfile_dev_pkgdep                  = "dev.pkgdep";
const char *dmmeta_Ssimfile_ssimfile_dev_pkgkey                  = "dev.pkgkey";
const char *dmmeta_Ssimfile_ssimfile_dev_readme                  = "dev.readme";
const char *dmmeta_Ssimfile_ssimfile_dev_sandbox                 = "dev.sandbox";

const char *dmmeta_Ssimfile_ssimfile_dev_sbpath            = "dev.sbpath";
const char *dmmeta_Ssimfile_ssimfile_dev_scriptfile        = "dev.scriptfile";
const char *dmmeta_Ssimfile_ssimfile_dev_srcfile           = "dev.srcfile";
const char *dmmeta_Ssimfile_ssimfile_dev_syscmd            = "dev.syscmd";
const char *dmmeta_Ssimfile_ssimfile_dev_syscmddep         = "dev.syscmddep";
const char *dmmeta_Ssimfile_ssimfile_dev_syslib            = "dev.syslib";
const char *dmmeta_Ssimfile_ssimfile_dev_targdep           = "dev.targdep";
const char *dmmeta_Ssimfile_ssimfile_dev_target            = "dev.target";
const char *dmmeta_Ssimfile_ssimfile_dev_targsrc           = "dev.targsrc";
const char *dmmeta_Ssimfile_ssimfile_dev_targsyslib        = "dev.targsyslib";
const char *dmmeta_Ssimfile_ssimfile_dev_tgtcov            = "dev.tgtcov";
const char *dmmeta_Ssimfile_ssimfile_dev_timefmt           = "dev.timefmt";
const char *dmmeta_Ssimfile_ssimfile_dev_tool_opt          = "dev.tool_opt";
const char *dmmeta_Ssimfile_ssimfile_dev_uname             = "dev.uname";
const char *dmmeta_Ssimfile_ssimfile_dev_unstablefld       = "dev.unstablefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_anonfld        = "dmmeta.anonfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_argvtype       = "dmmeta.argvtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_basepool       = "dmmeta.basepool";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_bitfld         = "dmmeta.bitfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cafter         = "dmmeta.cafter";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cascdel        = "dmmeta.cascdel";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ccmp           = "dmmeta.ccmp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cdflt          = "dmmeta.cdflt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cextern        = "dmmeta.cextern";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cfast          = "dmmeta.cfast";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cfmt           = "dmmeta.cfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cget           = "dmmeta.cget";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_charset        = "dmmeta.charset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_chash          = "dmmeta.chash";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cppfunc        = "dmmeta.cppfunc";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cppkeyword     = "dmmeta.cppkeyword";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cpptype        = "dmmeta.cpptype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_csize          = "dmmeta.csize";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_cstr           = "dmmeta.cstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ctype          = "dmmeta.ctype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ctypelen       = "dmmeta.ctypelen";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispatch       = "dmmeta.dispatch";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispatch_msg   = "dmmeta.dispatch_msg";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispctx        = "dmmeta.dispctx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispfilter     = "dmmeta.dispfilter";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispsig        = "dmmeta.dispsig";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_dispsigcheck   = "dmmeta.dispsigcheck";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_disptrace      = "dmmeta.disptrace";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_falias         = "dmmeta.falias";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fastenc        = "dmmeta.fastenc";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fastinstr   = "dmmeta.fastinstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fastop      = "dmmeta.fastop";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbase       = "dmmeta.fbase";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbigend     = "dmmeta.fbigend";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbitset     = "dmmeta.fbitset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbuf        = "dmmeta.fbuf";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbufdir     = "dmmeta.fbufdir";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fbuftype   = "dmmeta.fbuftype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcast      = "dmmeta.fcast";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcleanup   = "dmmeta.fcleanup";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmap      = "dmmeta.fcmap";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmdline   = "dmmeta.fcmdline";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcmp       = "dmmeta.fcmp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcompact   = "dmmeta.fcompact";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fconst     = "dmmeta.fconst";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fcurs      = "dmmeta.fcurs";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fdec       = "dmmeta.fdec";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fdelay     = "dmmeta.fdelay";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ffast      = "dmmeta.ffast";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_fflag         = "dmmeta.fflag";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_field         = "dmmeta.field";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_findrem       = "dmmeta.findrem";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_finput        = "dmmeta.finput";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fldoffset     = "dmmeta.fldoffset";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_floadtuples   = "dmmeta.floadtuples";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fnoremove     = "dmmeta.fnoremove";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_foutput       = "dmmeta.foutput";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fprefix       = "dmmeta.fprefix";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fregx         = "dmmeta.fregx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fsort         = "dmmeta.fsort";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fstep         = "dmmeta.fstep";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ftrace        = "dmmeta.ftrace";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ftuple        = "dmmeta.ftuple";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_func          = "dmmeta.func";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_funique       = "dmmeta.funique";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fuserinit     = "dmmeta.fuserinit";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_fwddecl       = "dmmeta.fwddecl";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gconst        = "dmmeta.gconst";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gstatic       = "dmmeta.gstatic";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_gsymbol       = "dmmeta.gsymbol";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_hashtype      = "dmmeta.hashtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_hook          = "dmmeta.hook";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_inlary        = "dmmeta.inlary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_lenfld        = "dmmeta.lenfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_listtype      = "dmmeta.listtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_llist         = "dmmeta.llist";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_logcat        = "dmmeta.logcat";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_main          = "dmmeta.main";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_msgtype       = "dmmeta.msgtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nocascdel     = "dmmeta.nocascdel";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nossimfile    = "dmmeta.nossimfile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_noxref        = "dmmeta.noxref";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ns            = "dmmeta.ns";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nscpp         = "dmmeta.nscpp";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsdb          = "dmmeta.nsdb";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsfast        = "dmmeta.nsfast";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsinclude     = "dmmeta.nsinclude";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsproto   = "dmmeta.nsproto";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nstype   = "dmmeta.nstype";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsversion         = "dmmeta.nsversion";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_nsx               = "dmmeta.nsx";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_numstr            = "dmmeta.numstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pack              = "dmmeta.pack";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld          = "dmmeta.pmaskfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld_member   = "dmmeta.pmaskfld_member";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pnew              = "dmmeta.pnew";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_pnewtype          = "dmmeta.pnewtype";

const char *dmmeta_Ssimfile_ssimfile_dmmeta_printfmt       = "dmmeta.printfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ptrary         = "dmmeta.ptrary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_reftype        = "dmmeta.reftype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_rowid          = "dmmeta.rowid";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_smallstr       = "dmmeta.smallstr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sortfld        = "dmmeta.sortfld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sorttype       = "dmmeta.sorttype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_sqltype        = "dmmeta.sqltype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimfile       = "dmmeta.ssimfile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimreq        = "dmmeta.ssimreq";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimsort       = "dmmeta.ssimsort";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_ssimvolatile   = "dmmeta.ssimvolatile";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_steptype       = "dmmeta.steptype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_strfmt         = "dmmeta.strfmt";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_strtype        = "dmmeta.strtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_substr         = "dmmeta.substr";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_svtype         = "dmmeta.svtype";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tary           = "dmmeta.tary";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_thash          = "dmmeta.thash";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tracefld       = "dmmeta.tracefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_tracerec       = "dmmeta.tracerec";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_typefld        = "dmmeta.typefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_usertracefld   = "dmmeta.usertracefld";
const char *dmmeta_Ssimfile_ssimfile_dmmeta_xref           = "dmmeta.xref";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alarm            = "fmdb.alarm";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_code         = "fmdb.alm_code";

const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_objtype    = "fmdb.alm_objtype";
const char *dmmeta_Ssimfile_ssimfile_fmdb_alm_source     = "fmdb.alm_source";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gact         = "gclidb.gact";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gatv         = "gclidb.gatv";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmd      = "gclidb.gclicmd";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmdf2j   = "gclidb.gclicmdf2j";

const char *dmmeta_Ssimfile_ssimfile_gclidb_gclicmdt        = "gclidb.gclicmdt";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclienv         = "gclidb.gclienv";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclienvsub      = "gclidb.gclienvsub";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gclisub         = "gclidb.gclisub";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gfld            = "gclidb.gfld";
const char *dmmeta_Ssimfile_ssimfile_gclidb_githost         = "gclidb.githost";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gmethod         = "gclidb.gmethod";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepo           = "gclidb.grepo";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepogitport    = "gclidb.grepogitport";
const char *dmmeta_Ssimfile_ssimfile_gclidb_grepossh        = "gclidb.grepossh";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gstate          = "gclidb.gstate";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gstatet         = "gclidb.gstatet";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtbl            = "gclidb.gtbl";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblact         = "gclidb.gtblact";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblactfld      = "gclidb.gtblactfld";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblacttst      = "gclidb.gtblacttst";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtblacttstout   = "gclidb.gtblacttstout";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtype           = "gclidb.gtype";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtypeh          = "gclidb.gtypeh";
const char *dmmeta_Ssimfile_ssimfile_gclidb_gtypeprefix     = "gclidb.gtypeprefix";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issue           = "gclidb.issue";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issuenote       = "gclidb.issuenote";
const char *dmmeta_Ssimfile_ssimfile_gclidb_issuepipeline   = "gclidb.issuepipeline";
const char *dmmeta_Ssimfile_ssimfile_gclidb_label           = "gclidb.label";
const char *dmmeta_Ssimfile_ssimfile_gclidb_milestone       = "gclidb.milestone";
const char *dmmeta_Ssimfile_ssimfile_gclidb_mr              = "gclidb.mr";
const char *dmmeta_Ssimfile_ssimfile_gclidb_mrjob           = "gclidb.mrjob";

const char *dmmeta_Ssimfile_ssimfile_gclidb_mrnote    = "gclidb.mrnote";
const char *dmmeta_Ssimfile_ssimfile_gclidb_project   = "gclidb.project";
const char *dmmeta_Ssimfile_ssimfile_gclidb_user      = "gclidb.user";

// compile-time string constants for dmmeta.Steptype.steptype
const char *dmmeta_Steptype_steptype_Callback        = "Callback";
const char *dmmeta_Steptype_steptype_Extern          = "Extern";
const char *dmmeta_Steptype_steptype_Inline          = "Inline";
const char *dmmeta_Steptype_steptype_InlineOnce      = "InlineOnce";
const char *dmmeta_Steptype_steptype_InlineRecur     = "InlineRecur";
const char *dmmeta_Steptype_steptype_TimeHookRecur   = "TimeHookRecur";

// compile-time string constants for dmmeta.Strfmt.strfmt
const char *dmmeta_Strfmt_strfmt_Argv      = "Argv";
const char *dmmeta_Strfmt_strfmt_ArgvGnu   = "ArgvGnu";
const char *dmmeta_Strfmt_strfmt_Json      = "Json";
const char *dmmeta_Strfmt_strfmt_String    = "String";
const char *dmmeta_Strfmt_strfmt_Tuple     = "Tuple";

// compile-time string constants for dmmeta.Strtype.strtype
const char *dmmeta_Strtype_strtype_rpascal    = "rpascal";
const char *dmmeta_Strtype_strtype_rightpad   = "rightpad";
const char *dmmeta_Strtype_strtype_leftpad    = "leftpad";

namespace dmmeta { // gen:ns_print_proto
    // func:dmmeta...SizeCheck
    static void          SizeCheck();
} // gen:ns_print_proto

// --- dmmeta.Anonfld..ReadFieldMaybe
bool dmmeta::Anonfld_ReadFieldMaybe(dmmeta::Anonfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Anonfld..ReadStrptrMaybe
// Read fields of dmmeta::Anonfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Anonfld_ReadStrptrMaybe(dmmeta::Anonfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.anonfld") || algo::StripTypeTag(in_str, "dmmeta.Anonfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Anonfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Anonfld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Anonfld.String  printfmt:Tuple
void dmmeta::Anonfld_Print(dmmeta::Anonfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.anonfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Argvtype..ReadFieldMaybe
bool dmmeta::Argvtype_ReadFieldMaybe(dmmeta::Argvtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_argvtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.argvtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Argvtype..ReadStrptrMaybe
// Read fields of dmmeta::Argvtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Argvtype_ReadStrptrMaybe(dmmeta::Argvtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.argvtype") || algo::StripTypeTag(in_str, "dmmeta.Argvtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Argvtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Argvtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Argvtype.String  printfmt:Tuple
void dmmeta::Argvtype_Print(dmmeta::Argvtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.argvtype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr50_Print(row.argvtype, temp);
    PrintAttrSpaceReset(str,"argvtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Basepool..ReadFieldMaybe
bool dmmeta::Basepool_ReadFieldMaybe(dmmeta::Basepool& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_base: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.base, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Basepool..ReadStrptrMaybe
// Read fields of dmmeta::Basepool from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Basepool_ReadStrptrMaybe(dmmeta::Basepool &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.basepool") || algo::StripTypeTag(in_str, "dmmeta.Basepool");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Basepool_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Basepool..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Basepool.String  printfmt:Tuple
void dmmeta::Basepool_Print(dmmeta::Basepool& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.basepool";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.base, temp);
    PrintAttrSpaceReset(str,"base", temp);
}

// --- dmmeta.Bitfld.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Bitfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Bitfld.name.Get2
algo::Smallstr50 dmmeta::Bitfld_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Bitfld..ReadFieldMaybe
bool dmmeta::Bitfld_ReadFieldMaybe(dmmeta::Bitfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_offset: {
            retval = i32_ReadStrptrMaybe(parent.offset, strval);
            break;
        }
        case dmmeta_FieldId_width: {
            retval = i32_ReadStrptrMaybe(parent.width, strval);
            break;
        }
        case dmmeta_FieldId_srcfield: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Bitfld..ReadStrptrMaybe
// Read fields of dmmeta::Bitfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Bitfld_ReadStrptrMaybe(dmmeta::Bitfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.bitfld") || algo::StripTypeTag(in_str, "dmmeta.Bitfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Bitfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Bitfld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Bitfld.String  printfmt:Tuple
void dmmeta::Bitfld_Print(dmmeta::Bitfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.bitfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.offset, temp);
    PrintAttrSpaceReset(str,"offset", temp);

    i32_Print(row.width, temp);
    PrintAttrSpaceReset(str,"width", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Buftype..ReadFieldMaybe
bool dmmeta::Buftype_ReadFieldMaybe(dmmeta::Buftype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_pnewtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.pnewtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Buftype..ReadStrptrMaybe
// Read fields of dmmeta::Buftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Buftype_ReadStrptrMaybe(dmmeta::Buftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pnewtype") || algo::StripTypeTag(in_str, "dmmeta.Buftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Buftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Buftype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Buftype.String  printfmt:Tuple
void dmmeta::Buftype_Print(dmmeta::Buftype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.pnewtype";

    algo::Smallstr50_Print(row.pnewtype, temp);
    PrintAttrSpaceReset(str,"pnewtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cafter.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Cafter& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.cafter, "/RL"));
    return ret;
}

// --- dmmeta.Cafter.ctype.Get2
algo::Smallstr100 dmmeta::Cafter_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Cafter.after.Get
algo::Smallstr100 dmmeta::after_Get(dmmeta::Cafter& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.cafter, "/RR"));
    return ret;
}

// --- dmmeta.Cafter.after.Get2
algo::Smallstr100 dmmeta::Cafter_after_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Cafter..Concat_ctype_after
tempstr dmmeta::Cafter_Concat_ctype_after( const algo::strptr& ctype ,const algo::strptr& after ) {
    return tempstr() << ctype <<'/'<< after ;
}

// --- dmmeta.Cafter..ReadFieldMaybe
bool dmmeta::Cafter_ReadFieldMaybe(dmmeta::Cafter& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_cafter: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.cafter, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_after: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cafter..ReadStrptrMaybe
// Read fields of dmmeta::Cafter from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cafter_ReadStrptrMaybe(dmmeta::Cafter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cafter") || algo::StripTypeTag(in_str, "dmmeta.Cafter");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cafter_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cafter..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cafter.String  printfmt:Tuple
void dmmeta::Cafter_Print(dmmeta::Cafter& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cafter";

    algo::Smallstr50_Print(row.cafter, temp);
    PrintAttrSpaceReset(str,"cafter", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cascdel..ReadFieldMaybe
bool dmmeta::Cascdel_ReadFieldMaybe(dmmeta::Cascdel& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cascdel..ReadStrptrMaybe
// Read fields of dmmeta::Cascdel from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cascdel_ReadStrptrMaybe(dmmeta::Cascdel &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cascdel") || algo::StripTypeTag(in_str, "dmmeta.Cascdel");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cascdel_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cascdel..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cascdel.String  printfmt:Tuple
void dmmeta::Cascdel_Print(dmmeta::Cascdel& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cascdel";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ccmp..ReadFieldMaybe
bool dmmeta::Ccmp_ReadFieldMaybe(dmmeta::Ccmp& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_extrn: {
            retval = bool_ReadStrptrMaybe(parent.extrn, strval);
            break;
        }
        case dmmeta_FieldId_genop: {
            retval = bool_ReadStrptrMaybe(parent.genop, strval);
            break;
        }
        case dmmeta_FieldId_order: {
            retval = bool_ReadStrptrMaybe(parent.order, strval);
            break;
        }
        case dmmeta_FieldId_minmax: {
            retval = bool_ReadStrptrMaybe(parent.minmax, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ccmp..ReadStrptrMaybe
// Read fields of dmmeta::Ccmp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ccmp_ReadStrptrMaybe(dmmeta::Ccmp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ccmp") || algo::StripTypeTag(in_str, "dmmeta.Ccmp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ccmp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ccmp..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ccmp.String  printfmt:Tuple
void dmmeta::Ccmp_Print(dmmeta::Ccmp& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ccmp";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.genop, temp);
    PrintAttrSpaceReset(str,"genop", temp);

    bool_Print(row.order, temp);
    PrintAttrSpaceReset(str,"order", temp);

    bool_Print(row.minmax, temp);
    PrintAttrSpaceReset(str,"minmax", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cdflt..ReadFieldMaybe
bool dmmeta::Cdflt_ReadFieldMaybe(dmmeta::Cdflt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_dflt: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.dflt, strval);
            break;
        }
        case dmmeta_FieldId_cppdflt: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.cppdflt, strval);
            break;
        }
        case dmmeta_FieldId_ssimdflt: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimdflt, strval);
            break;
        }
        case dmmeta_FieldId_jsdflt: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.jsdflt, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cdflt..ReadStrptrMaybe
// Read fields of dmmeta::Cdflt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cdflt_ReadStrptrMaybe(dmmeta::Cdflt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cdflt") || algo::StripTypeTag(in_str, "dmmeta.Cdflt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cdflt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cdflt..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cdflt.String  printfmt:Tuple
void dmmeta::Cdflt_Print(dmmeta::Cdflt& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cdflt";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::CppExpr_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::CppExpr_Print(row.cppdflt, temp);
    PrintAttrSpaceReset(str,"cppdflt", temp);

    algo::Smallstr50_Print(row.ssimdflt, temp);
    PrintAttrSpaceReset(str,"ssimdflt", temp);

    algo::Smallstr50_Print(row.jsdflt, temp);
    PrintAttrSpaceReset(str,"jsdflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cextern..ReadFieldMaybe
bool dmmeta::Cextern_ReadFieldMaybe(dmmeta::Cextern& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_initmemset: {
            retval = bool_ReadStrptrMaybe(parent.initmemset, strval);
            break;
        }
        case dmmeta_FieldId_isstruct: {
            retval = bool_ReadStrptrMaybe(parent.isstruct, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cextern..ReadStrptrMaybe
// Read fields of dmmeta::Cextern from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cextern_ReadStrptrMaybe(dmmeta::Cextern &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cextern") || algo::StripTypeTag(in_str, "dmmeta.Cextern");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cextern_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cextern..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cextern.String  printfmt:Tuple
void dmmeta::Cextern_Print(dmmeta::Cextern& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cextern";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.initmemset, temp);
    PrintAttrSpaceReset(str,"initmemset", temp);

    bool_Print(row.isstruct, temp);
    PrintAttrSpaceReset(str,"isstruct", temp);
}

// --- dmmeta.Cfast..ReadFieldMaybe
bool dmmeta::Cfast_ReadFieldMaybe(dmmeta::Cfast& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_id: {
            retval = u32_ReadStrptrMaybe(parent.id, strval);
            break;
        }
        case dmmeta_FieldId_encoding: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.encoding, strval);
            break;
        }
        case dmmeta_FieldId_reset: {
            retval = bool_ReadStrptrMaybe(parent.reset, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cfast..ReadStrptrMaybe
// Read fields of dmmeta::Cfast from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cfast_ReadStrptrMaybe(dmmeta::Cfast &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cfast") || algo::StripTypeTag(in_str, "dmmeta.Cfast");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfast_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cfast..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cfast.String  printfmt:Tuple
void dmmeta::Cfast_Print(dmmeta::Cfast& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cfast";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    algo::Smallstr50_Print(row.encoding, temp);
    PrintAttrSpaceReset(str,"encoding", temp);

    bool_Print(row.reset, temp);
    PrintAttrSpaceReset(str,"reset", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cfmt.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Cfmt& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.cfmt, ".RL"));
    return ret;
}

// --- dmmeta.Cfmt.ctype.Get2
algo::Smallstr100 dmmeta::Cfmt_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Cfmt.strfmt.Get
algo::Smallstr50 dmmeta::strfmt_Get(dmmeta::Cfmt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.cfmt, ".RR"));
    return ret;
}

// --- dmmeta.Cfmt.strfmt.Get2
algo::Smallstr50 dmmeta::Cfmt_strfmt_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Cfmt..Concat_ctype_strfmt
tempstr dmmeta::Cfmt_Concat_ctype_strfmt( const algo::strptr& ctype ,const algo::strptr& strfmt ) {
    return tempstr() << ctype <<'.'<< strfmt ;
}

// --- dmmeta.Cfmt..ReadFieldMaybe
bool dmmeta::Cfmt_ReadFieldMaybe(dmmeta::Cfmt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_cfmt: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.cfmt, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_strfmt: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_printfmt: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.printfmt, strval);
            break;
        }
        case dmmeta_FieldId_read: {
            retval = bool_ReadStrptrMaybe(parent.read, strval);
            break;
        }
        case dmmeta_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case dmmeta_FieldId_sep: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.sep, strval);
            break;
        }
        case dmmeta_FieldId_genop: {
            retval = bool_ReadStrptrMaybe(parent.genop, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cfmt..ReadStrptrMaybe
// Read fields of dmmeta::Cfmt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cfmt_ReadStrptrMaybe(dmmeta::Cfmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cfmt") || algo::StripTypeTag(in_str, "dmmeta.Cfmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cfmt..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cfmt.String  printfmt:Tuple
void dmmeta::Cfmt_Print(dmmeta::Cfmt& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cfmt";

    algo::Smallstr100_Print(row.cfmt, temp);
    PrintAttrSpaceReset(str,"cfmt", temp);

    algo::Smallstr50_Print(row.printfmt, temp);
    PrintAttrSpaceReset(str,"printfmt", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    bool_Print(row.print, temp);
    PrintAttrSpaceReset(str,"print", temp);

    algo::Smallstr20_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    bool_Print(row.genop, temp);
    PrintAttrSpaceReset(str,"genop", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cget..ReadFieldMaybe
bool dmmeta::Cget_ReadFieldMaybe(dmmeta::Cget& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cget..ReadStrptrMaybe
// Read fields of dmmeta::Cget from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cget_ReadStrptrMaybe(dmmeta::Cget &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cget") || algo::StripTypeTag(in_str, "dmmeta.Cget");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cget_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cget..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cget.String  printfmt:Tuple
void dmmeta::Cget_Print(dmmeta::Cget& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cget";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Charset..ReadFieldMaybe
bool dmmeta::Charset_ReadFieldMaybe(dmmeta::Charset& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_expr: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dmmeta_FieldId_charrange: {
            retval = bool_ReadStrptrMaybe(parent.charrange, strval);
            break;
        }
        case dmmeta_FieldId_calc: {
            retval = bool_ReadStrptrMaybe(parent.calc, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Charset..ReadStrptrMaybe
// Read fields of dmmeta::Charset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Charset_ReadStrptrMaybe(dmmeta::Charset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.charset") || algo::StripTypeTag(in_str, "dmmeta.Charset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Charset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Charset..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Charset.String  printfmt:Tuple
void dmmeta::Charset_Print(dmmeta::Charset& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.charset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    bool_Print(row.charrange, temp);
    PrintAttrSpaceReset(str,"charrange", temp);

    bool_Print(row.calc, temp);
    PrintAttrSpaceReset(str,"calc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Chash..ReadFieldMaybe
bool dmmeta::Chash_ReadFieldMaybe(dmmeta::Chash& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_hashtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.hashtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Chash..ReadStrptrMaybe
// Read fields of dmmeta::Chash from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Chash_ReadStrptrMaybe(dmmeta::Chash &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.chash") || algo::StripTypeTag(in_str, "dmmeta.Chash");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Chash_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Chash..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Chash.String  printfmt:Tuple
void dmmeta::Chash_Print(dmmeta::Chash& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.chash";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr50_Print(row.hashtype, temp);
    PrintAttrSpaceReset(str,"hashtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cppfunc..ReadFieldMaybe
bool dmmeta::Cppfunc_ReadFieldMaybe(dmmeta::Cppfunc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_expr: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dmmeta_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case dmmeta_FieldId_set: {
            retval = bool_ReadStrptrMaybe(parent.set, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cppfunc..ReadStrptrMaybe
// Read fields of dmmeta::Cppfunc from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cppfunc_ReadStrptrMaybe(dmmeta::Cppfunc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cppfunc") || algo::StripTypeTag(in_str, "dmmeta.Cppfunc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cppfunc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cppfunc..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cppfunc.String  printfmt:Tuple
void dmmeta::Cppfunc_Print(dmmeta::Cppfunc& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cppfunc";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    bool_Print(row.print, temp);
    PrintAttrSpaceReset(str,"print", temp);

    bool_Print(row.set, temp);
    PrintAttrSpaceReset(str,"set", temp);
}

// --- dmmeta.Cppkeyword..ReadFieldMaybe
bool dmmeta::Cppkeyword_ReadFieldMaybe(dmmeta::Cppkeyword& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_cppkeyword: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.cppkeyword, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cppkeyword..ReadStrptrMaybe
// Read fields of dmmeta::Cppkeyword from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cppkeyword_ReadStrptrMaybe(dmmeta::Cppkeyword &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cppkeyword") || algo::StripTypeTag(in_str, "dmmeta.Cppkeyword");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cppkeyword_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cppkeyword..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cppkeyword.String  printfmt:Tuple
void dmmeta::Cppkeyword_Print(dmmeta::Cppkeyword& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cppkeyword";

    algo::Smallstr20_Print(row.cppkeyword, temp);
    PrintAttrSpaceReset(str,"cppkeyword", temp);
}

// --- dmmeta.Cpptype..ReadFieldMaybe
bool dmmeta::Cpptype_ReadFieldMaybe(dmmeta::Cpptype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_ctor: {
            retval = bool_ReadStrptrMaybe(parent.ctor, strval);
            break;
        }
        case dmmeta_FieldId_dtor: {
            retval = bool_ReadStrptrMaybe(parent.dtor, strval);
            break;
        }
        case dmmeta_FieldId_cheap_copy: {
            retval = bool_ReadStrptrMaybe(parent.cheap_copy, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cpptype..ReadStrptrMaybe
// Read fields of dmmeta::Cpptype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cpptype_ReadStrptrMaybe(dmmeta::Cpptype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cpptype") || algo::StripTypeTag(in_str, "dmmeta.Cpptype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cpptype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cpptype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cpptype.String  printfmt:Tuple
void dmmeta::Cpptype_Print(dmmeta::Cpptype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cpptype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.ctor, temp);
    PrintAttrSpaceReset(str,"ctor", temp);

    bool_Print(row.dtor, temp);
    PrintAttrSpaceReset(str,"dtor", temp);

    bool_Print(row.cheap_copy, temp);
    PrintAttrSpaceReset(str,"cheap_copy", temp);
}

// --- dmmeta.Csize..ReadFieldMaybe
bool dmmeta::Csize_ReadFieldMaybe(dmmeta::Csize& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_size: {
            retval = u32_ReadStrptrMaybe(parent.size, strval);
            break;
        }
        case dmmeta_FieldId_alignment: {
            retval = u32_ReadStrptrMaybe(parent.alignment, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Csize..ReadStrptrMaybe
// Read fields of dmmeta::Csize from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Csize_ReadStrptrMaybe(dmmeta::Csize &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.csize") || algo::StripTypeTag(in_str, "dmmeta.Csize");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Csize_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Csize..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Csize.String  printfmt:Tuple
void dmmeta::Csize_Print(dmmeta::Csize& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.csize";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.size, temp);
    PrintAttrSpaceReset(str,"size", temp);

    u32_Print(row.alignment, temp);
    PrintAttrSpaceReset(str,"alignment", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Cstr..ReadFieldMaybe
bool dmmeta::Cstr_ReadFieldMaybe(dmmeta::Cstr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_strequiv: {
            retval = bool_ReadStrptrMaybe(parent.strequiv, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Cstr..ReadStrptrMaybe
// Read fields of dmmeta::Cstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Cstr_ReadStrptrMaybe(dmmeta::Cstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.cstr") || algo::StripTypeTag(in_str, "dmmeta.Cstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Cstr..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Cstr.String  printfmt:Tuple
void dmmeta::Cstr_Print(dmmeta::Cstr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.cstr";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.strequiv, temp);
    PrintAttrSpaceReset(str,"strequiv", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ctype.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Ctype& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ctype, ".RL"));
    return ret;
}

// --- dmmeta.Ctype.ns.Get2
algo::Smallstr16 dmmeta::Ctype_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Ctype.name.Get
algo::Smallstr100 dmmeta::name_Get(dmmeta::Ctype& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.ctype, ".RR"));
    return ret;
}

// --- dmmeta.Ctype.name.Get2
algo::Smallstr100 dmmeta::Ctype_name_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Ctype..Concat_ns_name
tempstr dmmeta::Ctype_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Ctype..ReadFieldMaybe
bool dmmeta::Ctype_ReadFieldMaybe(dmmeta::Ctype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ctype..ReadStrptrMaybe
// Read fields of dmmeta::Ctype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ctype_ReadStrptrMaybe(dmmeta::Ctype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ctype") || algo::StripTypeTag(in_str, "dmmeta.Ctype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ctype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ctype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ctype.String  printfmt:Tuple
void dmmeta::Ctype_Print(dmmeta::Ctype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ctype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ctypelen..ReadFieldMaybe
bool dmmeta::Ctypelen_ReadFieldMaybe(dmmeta::Ctypelen& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_len: {
            retval = u32_ReadStrptrMaybe(parent.len, strval);
            break;
        }
        case dmmeta_FieldId_alignment: {
            retval = i32_ReadStrptrMaybe(parent.alignment, strval);
            break;
        }
        case dmmeta_FieldId_padbytes: {
            retval = i32_ReadStrptrMaybe(parent.padbytes, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ctypelen..ReadStrptrMaybe
// Read fields of dmmeta::Ctypelen from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ctypelen_ReadStrptrMaybe(dmmeta::Ctypelen &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ctypelen") || algo::StripTypeTag(in_str, "dmmeta.Ctypelen");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ctypelen_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ctypelen..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ctypelen.String  printfmt:Tuple
void dmmeta::Ctypelen_Print(dmmeta::Ctypelen& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ctypelen";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    u32_Print(row.len, temp);
    PrintAttrSpaceReset(str,"len", temp);

    i32_Print(row.alignment, temp);
    PrintAttrSpaceReset(str,"alignment", temp);

    i32_Print(row.padbytes, temp);
    PrintAttrSpaceReset(str,"padbytes", temp);
}

// --- dmmeta.Dispatch.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Dispatch& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.dispatch, ".RL"));
    return ret;
}

// --- dmmeta.Dispatch.ns.Get2
algo::Smallstr16 dmmeta::Dispatch_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Dispatch.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Dispatch& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispatch, ".RR"));
    return ret;
}

// --- dmmeta.Dispatch.name.Get2
algo::Smallstr50 dmmeta::Dispatch_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Dispatch..Concat_ns_name
tempstr dmmeta::Dispatch_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Dispatch..ReadFieldMaybe
bool dmmeta::Dispatch_ReadFieldMaybe(dmmeta::Dispatch& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispatch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_unk: {
            retval = bool_ReadStrptrMaybe(parent.unk, strval);
            break;
        }
        case dmmeta_FieldId_read: {
            retval = bool_ReadStrptrMaybe(parent.read, strval);
            break;
        }
        case dmmeta_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case dmmeta_FieldId_haslen: {
            retval = bool_ReadStrptrMaybe(parent.haslen, strval);
            break;
        }
        case dmmeta_FieldId_call: {
            retval = bool_ReadStrptrMaybe(parent.call, strval);
            break;
        }
        case dmmeta_FieldId_strict: {
            retval = bool_ReadStrptrMaybe(parent.strict, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispatch..ReadStrptrMaybe
// Read fields of dmmeta::Dispatch from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispatch_ReadStrptrMaybe(dmmeta::Dispatch &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispatch") || algo::StripTypeTag(in_str, "dmmeta.Dispatch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispatch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispatch..Init
// Set all fields to initial values.
void dmmeta::Dispatch_Init(dmmeta::Dispatch& parent) {
    parent.unk = bool(false);
    parent.read = bool(false);
    parent.print = bool(false);
    parent.haslen = bool(false);
    parent.call = bool(false);
    parent.strict = bool(false);
}

// --- dmmeta.Dispatch..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispatch.String  printfmt:Tuple
void dmmeta::Dispatch_Print(dmmeta::Dispatch& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispatch";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.unk, temp);
    PrintAttrSpaceReset(str,"unk", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    bool_Print(row.print, temp);
    PrintAttrSpaceReset(str,"print", temp);

    bool_Print(row.haslen, temp);
    PrintAttrSpaceReset(str,"haslen", temp);

    bool_Print(row.call, temp);
    PrintAttrSpaceReset(str,"call", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.DispatchMsg.dispatch.Get
algo::Smallstr50 dmmeta::dispatch_Get(dmmeta::DispatchMsg& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispatch_msg, "/RL"));
    return ret;
}

// --- dmmeta.DispatchMsg.dispatch.Get2
algo::Smallstr50 dmmeta::DispatchMsg_dispatch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.DispatchMsg.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::DispatchMsg& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.dispatch_msg, "/RR"));
    return ret;
}

// --- dmmeta.DispatchMsg.ctype.Get2
algo::Smallstr100 dmmeta::DispatchMsg_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.DispatchMsg..Concat_dispatch_ctype
tempstr dmmeta::DispatchMsg_Concat_dispatch_ctype( const algo::strptr& dispatch ,const algo::strptr& ctype ) {
    return tempstr() << dispatch <<'/'<< ctype ;
}

// --- dmmeta.DispatchMsg..ReadFieldMaybe
bool dmmeta::DispatchMsg_ReadFieldMaybe(dmmeta::DispatchMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispatch_msg: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.dispatch_msg, strval);
            break;
        }
        case dmmeta_FieldId_dispatch: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.DispatchMsg..ReadStrptrMaybe
// Read fields of dmmeta::DispatchMsg from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::DispatchMsg_ReadStrptrMaybe(dmmeta::DispatchMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispatch_msg") || algo::StripTypeTag(in_str, "dmmeta.DispatchMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DispatchMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.DispatchMsg..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.DispatchMsg.String  printfmt:Tuple
void dmmeta::DispatchMsg_Print(dmmeta::DispatchMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispatch_msg";

    algo::Smallstr100_Print(row.dispatch_msg, temp);
    PrintAttrSpaceReset(str,"dispatch_msg", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispctx..ReadFieldMaybe
bool dmmeta::Dispctx_ReadFieldMaybe(dmmeta::Dispctx& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispatch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispctx..ReadStrptrMaybe
// Read fields of dmmeta::Dispctx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispctx_ReadStrptrMaybe(dmmeta::Dispctx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispctx") || algo::StripTypeTag(in_str, "dmmeta.Dispctx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispctx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispctx..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispctx.String  printfmt:Tuple
void dmmeta::Dispctx_Print(dmmeta::Dispctx& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispctx";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispfilter..ReadFieldMaybe
bool dmmeta::Dispfilter_ReadFieldMaybe(dmmeta::Dispfilter& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispatch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval);
            break;
        }
        case dmmeta_FieldId_match_all: {
            retval = bool_ReadStrptrMaybe(parent.match_all, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispfilter..ReadStrptrMaybe
// Read fields of dmmeta::Dispfilter from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispfilter_ReadStrptrMaybe(dmmeta::Dispfilter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispfilter") || algo::StripTypeTag(in_str, "dmmeta.Dispfilter");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispfilter_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispfilter..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispfilter.String  printfmt:Tuple
void dmmeta::Dispfilter_Print(dmmeta::Dispfilter& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispfilter";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.match_all, temp);
    PrintAttrSpaceReset(str,"match_all", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Dispsig.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Dispsig& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.dispsig, ".RL"));
    return ret;
}

// --- dmmeta.Dispsig.ns.Get2
algo::Smallstr16 dmmeta::Dispsig_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Dispsig.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Dispsig& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.dispsig, ".RR"));
    return ret;
}

// --- dmmeta.Dispsig.name.Get2
algo::Smallstr50 dmmeta::Dispsig_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Dispsig..Concat_ns_name
tempstr dmmeta::Dispsig_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Dispsig..ReadFieldMaybe
bool dmmeta::Dispsig_ReadFieldMaybe(dmmeta::Dispsig& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispsig: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispsig, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_signature: {
            retval = algo::Sha1sig_ReadStrptrMaybe(parent.signature, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispsig..ReadStrptrMaybe
// Read fields of dmmeta::Dispsig from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispsig_ReadStrptrMaybe(dmmeta::Dispsig &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispsig") || algo::StripTypeTag(in_str, "dmmeta.Dispsig");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispsig_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispsig..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispsig.String  printfmt:Tuple
void dmmeta::Dispsig_Print(dmmeta::Dispsig& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispsig";

    algo::Smallstr50_Print(row.dispsig, temp);
    PrintAttrSpaceReset(str,"dispsig", temp);

    algo::Sha1sig_Print(row.signature, temp);
    PrintAttrSpaceReset(str,"signature", temp);
}

// --- dmmeta.Dispsigcheck..ReadFieldMaybe
bool dmmeta::Dispsigcheck_ReadFieldMaybe(dmmeta::Dispsigcheck& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispsig: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispsig, strval);
            break;
        }
        case dmmeta_FieldId_signature: {
            retval = algo::Sha1sig_ReadStrptrMaybe(parent.signature, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Dispsigcheck..ReadStrptrMaybe
// Read fields of dmmeta::Dispsigcheck from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Dispsigcheck_ReadStrptrMaybe(dmmeta::Dispsigcheck &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.dispsigcheck") || algo::StripTypeTag(in_str, "dmmeta.Dispsigcheck");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Dispsigcheck_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Dispsigcheck..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispsigcheck.String  printfmt:Tuple
void dmmeta::Dispsigcheck_Print(dmmeta::Dispsigcheck& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.dispsigcheck";

    algo::Smallstr50_Print(row.dispsig, temp);
    PrintAttrSpaceReset(str,"dispsig", temp);

    algo::Sha1sig_Print(row.signature, temp);
    PrintAttrSpaceReset(str,"signature", temp);
}

// --- dmmeta.Disptrace..ReadFieldMaybe
bool dmmeta::Disptrace_ReadFieldMaybe(dmmeta::Disptrace& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_dispatch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.dispatch, strval);
            break;
        }
        case dmmeta_FieldId_cycle: {
            retval = bool_ReadStrptrMaybe(parent.cycle, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Disptrace..ReadStrptrMaybe
// Read fields of dmmeta::Disptrace from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Disptrace_ReadStrptrMaybe(dmmeta::Disptrace &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.disptrace") || algo::StripTypeTag(in_str, "dmmeta.Disptrace");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Disptrace_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Disptrace..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Disptrace.String  printfmt:Tuple
void dmmeta::Disptrace_Print(dmmeta::Disptrace& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.disptrace";

    algo::Smallstr50_Print(row.dispatch, temp);
    PrintAttrSpaceReset(str,"dispatch", temp);

    bool_Print(row.cycle, temp);
    PrintAttrSpaceReset(str,"cycle", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Falias..ReadFieldMaybe
bool dmmeta::Falias_ReadFieldMaybe(dmmeta::Falias& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_srcfield: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Falias..ReadStrptrMaybe
// Read fields of dmmeta::Falias from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Falias_ReadStrptrMaybe(dmmeta::Falias &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.falias") || algo::StripTypeTag(in_str, "dmmeta.Falias");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Falias_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Falias..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Falias.String  printfmt:Tuple
void dmmeta::Falias_Print(dmmeta::Falias& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.falias";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fastenc..ReadFieldMaybe
bool dmmeta::Fastenc_ReadFieldMaybe(dmmeta::Fastenc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fastenc: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fastenc, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fastenc..ReadStrptrMaybe
// Read fields of dmmeta::Fastenc from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fastenc_ReadStrptrMaybe(dmmeta::Fastenc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fastenc") || algo::StripTypeTag(in_str, "dmmeta.Fastenc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fastenc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fastenc..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastenc.String  printfmt:Tuple
void dmmeta::Fastenc_Print(dmmeta::Fastenc& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fastenc";

    algo::Smallstr50_Print(row.fastenc, temp);
    PrintAttrSpaceReset(str,"fastenc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.FastencCase.fastenc.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::fastenc_ToCstr(const dmmeta::FastencCase& parent) {
    const char *ret = NULL;
    switch(fastenc_GetEnum(parent)) {
        case dmmeta_FastencCase_byteVector : ret = "byteVector";  break;
        case dmmeta_FastencCase_group      : ret = "group";  break;
        case dmmeta_FastencCase_scaled     : ret = "scaled";  break;
        case dmmeta_FastencCase_sequence   : ret = "sequence";  break;
        case dmmeta_FastencCase_signed     : ret = "signed";  break;
        case dmmeta_FastencCase_string     : ret = "string";  break;
        case dmmeta_FastencCase_template   : ret = "template";  break;
        case dmmeta_FastencCase_type       : ret = "type";  break;
        case dmmeta_FastencCase_unsigned   : ret = "unsigned";  break;
    }
    return ret;
}

// --- dmmeta.FastencCase.fastenc.Print
// Convert fastenc to a string. First, attempt conversion to a known string.
// If no string matches, print fastenc as a numeric value.
void dmmeta::fastenc_Print(const dmmeta::FastencCase& parent, algo::cstring &lhs) {
    const char *strval = fastenc_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.fastenc;
    }
}

// --- dmmeta.FastencCase.fastenc.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::fastenc_SetStrptrMaybe(dmmeta::FastencCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','y','p','e'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_type); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('g','r','o','u','p'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_group); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('s','c','a','l','e','d'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_scaled); ret = true; break;
                }
                case LE_STR6('s','i','g','n','e','d'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_signed); ret = true; break;
                }
                case LE_STR6('s','t','r','i','n','g'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_string); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','q','u','e','n','c','e'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_sequence); ret = true; break;
                }
                case LE_STR8('t','e','m','p','l','a','t','e'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_template); ret = true; break;
                }
                case LE_STR8('u','n','s','i','g','n','e','d'): {
                    fastenc_SetEnum(parent,dmmeta_FastencCase_unsigned); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('b','y','t','e','V','e','c','t'): {
                    if (memcmp(rhs.elems+8,"or",2)==0) { fastenc_SetEnum(parent,dmmeta_FastencCase_byteVector); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.FastencCase.fastenc.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::fastenc_SetStrptr(dmmeta::FastencCase& parent, algo::strptr rhs, dmmeta_FastencCaseEnum dflt) {
    if (!fastenc_SetStrptrMaybe(parent,rhs)) fastenc_SetEnum(parent,dflt);
}

// --- dmmeta.Fastinstr..ReadFieldMaybe
bool dmmeta::Fastinstr_ReadFieldMaybe(dmmeta::Fastinstr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fastinstr: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fastinstr, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fastinstr..ReadStrptrMaybe
// Read fields of dmmeta::Fastinstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fastinstr_ReadStrptrMaybe(dmmeta::Fastinstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fastinstr") || algo::StripTypeTag(in_str, "dmmeta.Fastinstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fastinstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fastinstr..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastinstr.String  printfmt:Tuple
void dmmeta::Fastinstr_Print(dmmeta::Fastinstr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fastinstr";

    algo::Smallstr50_Print(row.fastinstr, temp);
    PrintAttrSpaceReset(str,"fastinstr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.FastinstrCase.fastinstr.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::fastinstr_ToCstr(const dmmeta::FastinstrCase& parent) {
    const char *ret = NULL;
    switch(fastinstr_GetEnum(parent)) {
        case dmmeta_FastinstrCase_field    : ret = "field";  break;
        case dmmeta_FastinstrCase_length   : ret = "length";  break;
        case dmmeta_FastinstrCase_mantissa : ret = "mantissa";  break;
    }
    return ret;
}

// --- dmmeta.FastinstrCase.fastinstr.Print
// Convert fastinstr to a string. First, attempt conversion to a known string.
// If no string matches, print fastinstr as a numeric value.
void dmmeta::fastinstr_Print(const dmmeta::FastinstrCase& parent, algo::cstring &lhs) {
    const char *strval = fastinstr_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.fastinstr;
    }
}

// --- dmmeta.FastinstrCase.fastinstr.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::fastinstr_SetStrptrMaybe(dmmeta::FastinstrCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','i','e','l','d'): {
                    fastinstr_SetEnum(parent,dmmeta_FastinstrCase_field); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('l','e','n','g','t','h'): {
                    fastinstr_SetEnum(parent,dmmeta_FastinstrCase_length); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('m','a','n','t','i','s','s','a'): {
                    fastinstr_SetEnum(parent,dmmeta_FastinstrCase_mantissa); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.FastinstrCase.fastinstr.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::fastinstr_SetStrptr(dmmeta::FastinstrCase& parent, algo::strptr rhs, dmmeta_FastinstrCaseEnum dflt) {
    if (!fastinstr_SetStrptrMaybe(parent,rhs)) fastinstr_SetEnum(parent,dflt);
}

// --- dmmeta.Fastop..ReadFieldMaybe
bool dmmeta::Fastop_ReadFieldMaybe(dmmeta::Fastop& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fastop: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fastop, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fastop..ReadStrptrMaybe
// Read fields of dmmeta::Fastop from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fastop_ReadStrptrMaybe(dmmeta::Fastop &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fastop") || algo::StripTypeTag(in_str, "dmmeta.Fastop");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fastop_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fastop..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastop.String  printfmt:Tuple
void dmmeta::Fastop_Print(dmmeta::Fastop& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fastop";

    algo::Smallstr50_Print(row.fastop, temp);
    PrintAttrSpaceReset(str,"fastop", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.FastopCase.fastop.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::fastop_ToCstr(const dmmeta::FastopCase& parent) {
    const char *ret = NULL;
    switch(fastop_GetEnum(parent)) {
        case dmmeta_FastopCase_constant    : ret = "constant";  break;
        case dmmeta_FastopCase_copy        : ret = "copy";  break;
        case dmmeta_FastopCase_default     : ret = "default";  break;
        case dmmeta_FastopCase_delta       : ret = "delta";  break;
        case dmmeta_FastopCase_increment   : ret = "increment";  break;
        case dmmeta_FastopCase_none        : ret = "none";  break;
        case dmmeta_FastopCase_tail        : ret = "tail";  break;
    }
    return ret;
}

// --- dmmeta.FastopCase.fastop.Print
// Convert fastop to a string. First, attempt conversion to a known string.
// If no string matches, print fastop as a numeric value.
void dmmeta::fastop_Print(const dmmeta::FastopCase& parent, algo::cstring &lhs) {
    const char *strval = fastop_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.fastop;
    }
}

// --- dmmeta.FastopCase.fastop.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::fastop_SetStrptrMaybe(dmmeta::FastopCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('c','o','p','y'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_copy); ret = true; break;
                }
                case LE_STR4('n','o','n','e'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_none); ret = true; break;
                }
                case LE_STR4('t','a','i','l'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_tail); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('d','e','l','t','a'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_delta); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('d','e','f','a','u','l','t'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_default); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','s','t','a','n','t'): {
                    fastop_SetEnum(parent,dmmeta_FastopCase_constant); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','n','c','r','e','m','e','n'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { fastop_SetEnum(parent,dmmeta_FastopCase_increment); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.FastopCase.fastop.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::fastop_SetStrptr(dmmeta::FastopCase& parent, algo::strptr rhs, dmmeta_FastopCaseEnum dflt) {
    if (!fastop_SetStrptrMaybe(parent,rhs)) fastop_SetEnum(parent,dflt);
}

// --- dmmeta.Fbase..ReadFieldMaybe
bool dmmeta::Fbase_ReadFieldMaybe(dmmeta::Fbase& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_stripcomment: {
            retval = bool_ReadStrptrMaybe(parent.stripcomment, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbase..ReadStrptrMaybe
// Read fields of dmmeta::Fbase from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbase_ReadStrptrMaybe(dmmeta::Fbase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbase") || algo::StripTypeTag(in_str, "dmmeta.Fbase");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbase_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbase..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbase.String  printfmt:Tuple
void dmmeta::Fbase_Print(dmmeta::Fbase& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbase";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.stripcomment, temp);
    PrintAttrSpaceReset(str,"stripcomment", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbigend..ReadFieldMaybe
bool dmmeta::Fbigend_ReadFieldMaybe(dmmeta::Fbigend& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbigend..ReadStrptrMaybe
// Read fields of dmmeta::Fbigend from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbigend_ReadStrptrMaybe(dmmeta::Fbigend &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbigend") || algo::StripTypeTag(in_str, "dmmeta.Fbigend");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbigend_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbigend..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbigend.String  printfmt:Tuple
void dmmeta::Fbigend_Print(dmmeta::Fbigend& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbigend";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbitset..ReadFieldMaybe
bool dmmeta::Fbitset_ReadFieldMaybe(dmmeta::Fbitset& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbitset..ReadStrptrMaybe
// Read fields of dmmeta::Fbitset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbitset_ReadStrptrMaybe(dmmeta::Fbitset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbitset") || algo::StripTypeTag(in_str, "dmmeta.Fbitset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbitset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbitset..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbitset.String  printfmt:Tuple
void dmmeta::Fbitset_Print(dmmeta::Fbitset& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbitset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbuf.fbufdir.Get
algo::Smallstr50 dmmeta::fbufdir_Get(dmmeta::Fbuf& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR_LL"));
    return ret;
}

// --- dmmeta.Fbuf.fbufdir.Get2
algo::Smallstr50 dmmeta::Fbuf_fbufdir_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR_LL"));
    return ret;
}

// --- dmmeta.Fbuf..ReadFieldMaybe
bool dmmeta::Fbuf_ReadFieldMaybe(dmmeta::Fbuf& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_fbufdir: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_max: {
            retval = u32_ReadStrptrMaybe(parent.max, strval);
            break;
        }
        case dmmeta_FieldId_fbuftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbuftype, strval);
            break;
        }
        case dmmeta_FieldId_insready: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.insready, strval);
            break;
        }
        case dmmeta_FieldId_inseof: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.inseof, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbuf..ReadStrptrMaybe
// Read fields of dmmeta::Fbuf from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbuf_ReadStrptrMaybe(dmmeta::Fbuf &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbuf") || algo::StripTypeTag(in_str, "dmmeta.Fbuf");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbuf_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbuf..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbuf.String  printfmt:Tuple
void dmmeta::Fbuf_Print(dmmeta::Fbuf& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbuf";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    u32_Print(row.max, temp);
    PrintAttrSpaceReset(str,"max", temp);

    algo::Smallstr50_Print(row.fbuftype, temp);
    PrintAttrSpaceReset(str,"fbuftype", temp);

    algo::Smallstr100_Print(row.insready, temp);
    PrintAttrSpaceReset(str,"insready", temp);

    algo::Smallstr100_Print(row.inseof, temp);
    PrintAttrSpaceReset(str,"inseof", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbufdir..ReadFieldMaybe
bool dmmeta::Fbufdir_ReadFieldMaybe(dmmeta::Fbufdir& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fbufdir: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbufdir, strval);
            break;
        }
        case dmmeta_FieldId_read: {
            retval = bool_ReadStrptrMaybe(parent.read, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbufdir..ReadStrptrMaybe
// Read fields of dmmeta::Fbufdir from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbufdir_ReadStrptrMaybe(dmmeta::Fbufdir &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbufdir") || algo::StripTypeTag(in_str, "dmmeta.Fbufdir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbufdir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbufdir..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbufdir.String  printfmt:Tuple
void dmmeta::Fbufdir_Print(dmmeta::Fbufdir& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbufdir";

    algo::Smallstr50_Print(row.fbufdir, temp);
    PrintAttrSpaceReset(str,"fbufdir", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fbuftype..ReadFieldMaybe
bool dmmeta::Fbuftype_ReadFieldMaybe(dmmeta::Fbuftype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fbuftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fbuftype, strval);
            break;
        }
        case dmmeta_FieldId_getmsg: {
            retval = bool_ReadStrptrMaybe(parent.getmsg, strval);
            break;
        }
        case dmmeta_FieldId_skipbytes: {
            retval = bool_ReadStrptrMaybe(parent.skipbytes, strval);
            break;
        }
        case dmmeta_FieldId_read: {
            retval = bool_ReadStrptrMaybe(parent.read, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fbuftype..ReadStrptrMaybe
// Read fields of dmmeta::Fbuftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fbuftype_ReadStrptrMaybe(dmmeta::Fbuftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fbuftype") || algo::StripTypeTag(in_str, "dmmeta.Fbuftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fbuftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fbuftype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbuftype.String  printfmt:Tuple
void dmmeta::Fbuftype_Print(dmmeta::Fbuftype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fbuftype";

    algo::Smallstr50_Print(row.fbuftype, temp);
    PrintAttrSpaceReset(str,"fbuftype", temp);

    bool_Print(row.getmsg, temp);
    PrintAttrSpaceReset(str,"getmsg", temp);

    bool_Print(row.skipbytes, temp);
    PrintAttrSpaceReset(str,"skipbytes", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcast..ReadFieldMaybe
bool dmmeta::Fcast_ReadFieldMaybe(dmmeta::Fcast& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_expr: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcast..ReadStrptrMaybe
// Read fields of dmmeta::Fcast from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcast_ReadStrptrMaybe(dmmeta::Fcast &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcast") || algo::StripTypeTag(in_str, "dmmeta.Fcast");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcast_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcast..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcast.String  printfmt:Tuple
void dmmeta::Fcast_Print(dmmeta::Fcast& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcast";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcleanup..ReadFieldMaybe
bool dmmeta::Fcleanup_ReadFieldMaybe(dmmeta::Fcleanup& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcleanup..ReadStrptrMaybe
// Read fields of dmmeta::Fcleanup from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcleanup_ReadStrptrMaybe(dmmeta::Fcleanup &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcleanup") || algo::StripTypeTag(in_str, "dmmeta.Fcleanup");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcleanup_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcleanup..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcleanup.String  printfmt:Tuple
void dmmeta::Fcleanup_Print(dmmeta::Fcleanup& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcleanup";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmap.leftField.Get
algo::Smallstr100 dmmeta::leftField_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcmap, "=LL/LL"));
    return ret;
}

// --- dmmeta.Fcmap.leftField.Get2
algo::Smallstr100 dmmeta::Fcmap_leftField_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "=LL/LL"));
    return ret;
}

// --- dmmeta.Fcmap.leftVal.Get
algo::Smallstr40 dmmeta::leftVal_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr40 ret(algo::Pathcomp(parent.fcmap, "=LL/LR"));
    return ret;
}

// --- dmmeta.Fcmap.leftVal.Get2
algo::Smallstr40 dmmeta::Fcmap_leftVal_Get(algo::strptr arg) {
    algo::Smallstr40 ret(algo::Pathcomp(arg, "=LL/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightVal.Get
algo::Smallstr40 dmmeta::rightVal_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr40 ret(algo::Pathcomp(parent.fcmap, "=LR/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightVal.Get2
algo::Smallstr40 dmmeta::Fcmap_rightVal_Get(algo::strptr arg) {
    algo::Smallstr40 ret(algo::Pathcomp(arg, "=LR/LR"));
    return ret;
}

// --- dmmeta.Fcmap.rightField.Get
algo::Smallstr100 dmmeta::rightField_Get(dmmeta::Fcmap& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcmap, "=LR/LL"));
    return ret;
}

// --- dmmeta.Fcmap.rightField.Get2
algo::Smallstr100 dmmeta::Fcmap_rightField_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "=LR/LL"));
    return ret;
}

// --- dmmeta.Fcmap..Concat_leftField_leftVal_rightField_rightVal
tempstr dmmeta::Fcmap_Concat_leftField_leftVal_rightField_rightVal( const algo::strptr& leftField ,const algo::strptr& leftVal ,const algo::strptr& rightField ,const algo::strptr& rightVal ) {
    return tempstr() << leftField <<'/'<< leftVal <<'='<< rightField <<'/'<< rightVal ;
}

// --- dmmeta.Fcmap..ReadFieldMaybe
bool dmmeta::Fcmap_ReadFieldMaybe(dmmeta::Fcmap& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fcmap: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.fcmap, strval);
            break;
        }
        case dmmeta_FieldId_leftField: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_leftVal: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_rightVal: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_rightField: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_bidir: {
            retval = bool_ReadStrptrMaybe(parent.bidir, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmap..ReadStrptrMaybe
// Read fields of dmmeta::Fcmap from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmap_ReadStrptrMaybe(dmmeta::Fcmap &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmap") || algo::StripTypeTag(in_str, "dmmeta.Fcmap");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmap_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmap..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmap.String  printfmt:Tuple
void dmmeta::Fcmap_Print(dmmeta::Fcmap& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcmap";

    algo::Smallstr250_Print(row.fcmap, temp);
    PrintAttrSpaceReset(str,"fcmap", temp);

    bool_Print(row.bidir, temp);
    PrintAttrSpaceReset(str,"bidir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmdline.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fcmdline& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".RL.RL"));
    return ret;
}

// --- dmmeta.Fcmdline.ns.Get2
algo::Smallstr16 dmmeta::Fcmdline_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Fcmdline..ReadFieldMaybe
bool dmmeta::Fcmdline_ReadFieldMaybe(dmmeta::Fcmdline& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_read: {
            retval = bool_ReadStrptrMaybe(parent.read, strval);
            break;
        }
        case dmmeta_FieldId_basecmdline: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.basecmdline, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmdline..ReadStrptrMaybe
// Read fields of dmmeta::Fcmdline from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmdline_ReadStrptrMaybe(dmmeta::Fcmdline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmdline") || algo::StripTypeTag(in_str, "dmmeta.Fcmdline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmdline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmdline..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmdline.String  printfmt:Tuple
void dmmeta::Fcmdline_Print(dmmeta::Fcmdline& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcmdline";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.read, temp);
    PrintAttrSpaceReset(str,"read", temp);

    algo::Smallstr100_Print(row.basecmdline, temp);
    PrintAttrSpaceReset(str,"basecmdline", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcmp..ReadFieldMaybe
bool dmmeta::Fcmp_ReadFieldMaybe(dmmeta::Fcmp& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_versionsort: {
            retval = bool_ReadStrptrMaybe(parent.versionsort, strval);
            break;
        }
        case dmmeta_FieldId_casesens: {
            retval = bool_ReadStrptrMaybe(parent.casesens, strval);
            break;
        }
        case dmmeta_FieldId_extrn: {
            retval = bool_ReadStrptrMaybe(parent.extrn, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcmp..ReadStrptrMaybe
// Read fields of dmmeta::Fcmp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcmp_ReadStrptrMaybe(dmmeta::Fcmp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcmp") || algo::StripTypeTag(in_str, "dmmeta.Fcmp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcmp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcmp..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmp.String  printfmt:Tuple
void dmmeta::Fcmp_Print(dmmeta::Fcmp& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcmp";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.versionsort, temp);
    PrintAttrSpaceReset(str,"versionsort", temp);

    bool_Print(row.casesens, temp);
    PrintAttrSpaceReset(str,"casesens", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcompact..ReadFieldMaybe
bool dmmeta::Fcompact_ReadFieldMaybe(dmmeta::Fcompact& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcompact..ReadStrptrMaybe
// Read fields of dmmeta::Fcompact from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcompact_ReadStrptrMaybe(dmmeta::Fcompact &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcompact") || algo::StripTypeTag(in_str, "dmmeta.Fcompact");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcompact_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcompact..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcompact.String  printfmt:Tuple
void dmmeta::Fcompact_Print(dmmeta::Fcompact& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcompact";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fconst.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fconst& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fconst, "/LL"));
    return ret;
}

// --- dmmeta.Fconst.field.Get2
algo::Smallstr100 dmmeta::Fconst_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Fconst.name.Get
algo::Smallstr100 dmmeta::name_Get(dmmeta::Fconst& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fconst, "/LR"));
    return ret;
}

// --- dmmeta.Fconst.name.Get2
algo::Smallstr100 dmmeta::Fconst_name_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dmmeta.Fconst..Concat_field_name
tempstr dmmeta::Fconst_Concat_field_name( const algo::strptr& field ,const algo::strptr& name ) {
    return tempstr() << field <<'/'<< name ;
}

// --- dmmeta.Fconst..ReadFieldMaybe
bool dmmeta::Fconst_ReadFieldMaybe(dmmeta::Fconst& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fconst: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.fconst, strval);
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_value: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fconst..ReadStrptrMaybe
// Read fields of dmmeta::Fconst from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fconst_ReadStrptrMaybe(dmmeta::Fconst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fconst") || algo::StripTypeTag(in_str, "dmmeta.Fconst");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fconst_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fconst..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fconst.String  printfmt:Tuple
void dmmeta::Fconst_Print(dmmeta::Fconst& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fconst";

    algo::Smallstr100_Print(row.fconst, temp);
    PrintAttrSpaceReset(str,"fconst", temp);

    algo::CppExpr_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fcurs.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcurs, "/RL"));
    return ret;
}

// --- dmmeta.Fcurs.field.Get2
algo::Smallstr100 dmmeta::Fcurs_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Fcurs.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fcurs, "/RL.RL"));
    return ret;
}

// --- dmmeta.Fcurs.ctype.Get2
algo::Smallstr100 dmmeta::Fcurs_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RL.RL"));
    return ret;
}

// --- dmmeta.Fcurs.curstype.Get
algo::Smallstr50 dmmeta::curstype_Get(dmmeta::Fcurs& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fcurs, "/RR"));
    return ret;
}

// --- dmmeta.Fcurs.curstype.Get2
algo::Smallstr50 dmmeta::Fcurs_curstype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Fcurs..Concat_field_curstype
tempstr dmmeta::Fcurs_Concat_field_curstype( const algo::strptr& field ,const algo::strptr& curstype ) {
    return tempstr() << field <<'/'<< curstype ;
}

// --- dmmeta.Fcurs..ReadFieldMaybe
bool dmmeta::Fcurs_ReadFieldMaybe(dmmeta::Fcurs& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fcurs: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.fcurs, strval);
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_curstype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fcurs..ReadStrptrMaybe
// Read fields of dmmeta::Fcurs from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fcurs_ReadStrptrMaybe(dmmeta::Fcurs &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fcurs") || algo::StripTypeTag(in_str, "dmmeta.Fcurs");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fcurs_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fcurs..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcurs.String  printfmt:Tuple
void dmmeta::Fcurs_Print(dmmeta::Fcurs& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fcurs";

    algo::Smallstr50_Print(row.fcurs, temp);
    PrintAttrSpaceReset(str,"fcurs", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fdec..ReadFieldMaybe
bool dmmeta::Fdec_ReadFieldMaybe(dmmeta::Fdec& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_nplace: {
            retval = i32_ReadStrptrMaybe(parent.nplace, strval);
            break;
        }
        case dmmeta_FieldId_fixedfmt: {
            retval = bool_ReadStrptrMaybe(parent.fixedfmt, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fdec..ReadStrptrMaybe
// Read fields of dmmeta::Fdec from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fdec_ReadStrptrMaybe(dmmeta::Fdec &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fdec") || algo::StripTypeTag(in_str, "dmmeta.Fdec");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fdec_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fdec..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fdec.String  printfmt:Tuple
void dmmeta::Fdec_Print(dmmeta::Fdec& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fdec";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.nplace, temp);
    PrintAttrSpaceReset(str,"nplace", temp);

    bool_Print(row.fixedfmt, temp);
    PrintAttrSpaceReset(str,"fixedfmt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fdelay..ReadFieldMaybe
bool dmmeta::Fdelay_ReadFieldMaybe(dmmeta::Fdelay& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fstep: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval);
            break;
        }
        case dmmeta_FieldId_delay: {
            retval = algo::I64Dec9_ReadStrptrMaybe(parent.delay, strval);
            break;
        }
        case dmmeta_FieldId_scale: {
            retval = bool_ReadStrptrMaybe(parent.scale, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fdelay..ReadStrptrMaybe
// Read fields of dmmeta::Fdelay from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fdelay_ReadStrptrMaybe(dmmeta::Fdelay &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fdelay") || algo::StripTypeTag(in_str, "dmmeta.Fdelay");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fdelay_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fdelay..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fdelay.String  printfmt:Tuple
void dmmeta::Fdelay_Print(dmmeta::Fdelay& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fdelay";

    algo::Smallstr100_Print(row.fstep, temp);
    PrintAttrSpaceReset(str,"fstep", temp);

    algo::I64Dec9_Print(row.delay, temp);
    PrintAttrSpaceReset(str,"delay", temp);

    bool_Print(row.scale, temp);
    PrintAttrSpaceReset(str,"scale", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ffast.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Ffast& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.ffast, ".RL"));
    return ret;
}

// --- dmmeta.Ffast.field.Get2
algo::Smallstr100 dmmeta::Ffast_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Ffast.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Ffast& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.ffast, ".RL.RL"));
    return ret;
}

// --- dmmeta.Ffast.ctype.Get2
algo::Smallstr100 dmmeta::Ffast_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Ffast.fastinstr.Get
algo::Smallstr50 dmmeta::fastinstr_Get(dmmeta::Ffast& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ffast, ".RR"));
    return ret;
}

// --- dmmeta.Ffast.fastinstr.Get2
algo::Smallstr50 dmmeta::Ffast_fastinstr_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Ffast..Concat_field_fastinstr
tempstr dmmeta::Ffast_Concat_field_fastinstr( const algo::strptr& field ,const algo::strptr& fastinstr ) {
    return tempstr() << field <<'.'<< fastinstr ;
}

// --- dmmeta.Ffast..ReadFieldMaybe
bool dmmeta::Ffast_ReadFieldMaybe(dmmeta::Ffast& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ffast: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ffast, strval);
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_fastinstr: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.name, strval);
            break;
        }
        case dmmeta_FieldId_id: {
            retval = u32_ReadStrptrMaybe(parent.id, strval);
            break;
        }
        case dmmeta_FieldId_pos: {
            retval = u32_ReadStrptrMaybe(parent.pos, strval);
            break;
        }
        case dmmeta_FieldId_optional: {
            retval = bool_ReadStrptrMaybe(parent.optional, strval);
            break;
        }
        case dmmeta_FieldId_encoding: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.encoding, strval);
            break;
        }
        case dmmeta_FieldId_op: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.op, strval);
            break;
        }
        case dmmeta_FieldId_value: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ffast..ReadStrptrMaybe
// Read fields of dmmeta::Ffast from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ffast_ReadStrptrMaybe(dmmeta::Ffast &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ffast") || algo::StripTypeTag(in_str, "dmmeta.Ffast");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ffast_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ffast..Init
// Set all fields to initial values.
void dmmeta::Ffast_Init(dmmeta::Ffast& parent) {
    parent.id = u32(0);
    parent.pos = u32(0);
    parent.optional = bool(false);
}

// --- dmmeta.Ffast..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ffast.String  printfmt:Tuple
void dmmeta::Ffast_Print(dmmeta::Ffast& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ffast";

    algo::Smallstr100_Print(row.ffast, temp);
    PrintAttrSpaceReset(str,"ffast", temp);

    algo::Smallstr50_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);

    u32_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    u32_Print(row.pos, temp);
    PrintAttrSpaceReset(str,"pos", temp);

    bool_Print(row.optional, temp);
    PrintAttrSpaceReset(str,"optional", temp);

    algo::Smallstr50_Print(row.encoding, temp);
    PrintAttrSpaceReset(str,"encoding", temp);

    algo::Smallstr50_Print(row.op, temp);
    PrintAttrSpaceReset(str,"op", temp);

    algo::CppExpr_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fflag..ReadFieldMaybe
bool dmmeta::Fflag_ReadFieldMaybe(dmmeta::Fflag& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_cumulative: {
            retval = bool_ReadStrptrMaybe(parent.cumulative, strval);
            break;
        }
        case dmmeta_FieldId_emptyval: {
            retval = algo::cstring_ReadStrptrMaybe(parent.emptyval, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fflag..ReadStrptrMaybe
// Read fields of dmmeta::Fflag from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fflag_ReadStrptrMaybe(dmmeta::Fflag &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fflag") || algo::StripTypeTag(in_str, "dmmeta.Fflag");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fflag_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fflag..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fflag.String  printfmt:Tuple
void dmmeta::Fflag_Print(dmmeta::Fflag& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fflag";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.cumulative, temp);
    PrintAttrSpaceReset(str,"cumulative", temp);

    algo::cstring_Print(row.emptyval, temp);
    PrintAttrSpaceReset(str,"emptyval", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Field.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Field& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Field.ctype.Get2
algo::Smallstr100 dmmeta::Field_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Field.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Field& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".RL.RL"));
    return ret;
}

// --- dmmeta.Field.ns.Get2
algo::Smallstr16 dmmeta::Field_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Field.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Field& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Field.name.Get2
algo::Smallstr50 dmmeta::Field_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Field..Concat_ctype_name
tempstr dmmeta::Field_Concat_ctype_name( const algo::strptr& ctype ,const algo::strptr& name ) {
    return tempstr() << ctype <<'.'<< name ;
}

// --- dmmeta.Field..ReadFieldMaybe
bool dmmeta::Field_ReadFieldMaybe(dmmeta::Field& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_arg: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.arg, strval);
            break;
        }
        case dmmeta_FieldId_reftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval);
            break;
        }
        case dmmeta_FieldId_dflt: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.dflt, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Field..ReadStrptrMaybe
// Read fields of dmmeta::Field from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Field_ReadStrptrMaybe(dmmeta::Field &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.field") || algo::StripTypeTag(in_str, "dmmeta.Field");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Field_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Field..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Field.String  printfmt:Tuple
void dmmeta::Field_Print(dmmeta::Field& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.field";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.arg, temp);
    PrintAttrSpaceReset(str,"arg", temp);

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    algo::CppExpr_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::value_ToCstr(const dmmeta::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dmmeta_FieldId_field          : ret = "field";  break;
        case dmmeta_FieldId_comment        : ret = "comment";  break;
        case dmmeta_FieldId_ctype          : ret = "ctype";  break;
        case dmmeta_FieldId_argvtype       : ret = "argvtype";  break;
        case dmmeta_FieldId_base           : ret = "base";  break;
        case dmmeta_FieldId_name           : ret = "name";  break;
        case dmmeta_FieldId_offset         : ret = "offset";  break;
        case dmmeta_FieldId_width          : ret = "width";  break;
        case dmmeta_FieldId_srcfield       : ret = "srcfield";  break;
        case dmmeta_FieldId_pnewtype       : ret = "pnewtype";  break;
        case dmmeta_FieldId_cafter         : ret = "cafter";  break;
        case dmmeta_FieldId_after          : ret = "after";  break;
        case dmmeta_FieldId_extrn          : ret = "extrn";  break;
        case dmmeta_FieldId_genop          : ret = "genop";  break;
        case dmmeta_FieldId_order          : ret = "order";  break;
        case dmmeta_FieldId_minmax         : ret = "minmax";  break;
        case dmmeta_FieldId_dflt           : ret = "dflt";  break;
        case dmmeta_FieldId_cppdflt        : ret = "cppdflt";  break;
        case dmmeta_FieldId_ssimdflt       : ret = "ssimdflt";  break;
        case dmmeta_FieldId_jsdflt         : ret = "jsdflt";  break;
        case dmmeta_FieldId_initmemset     : ret = "initmemset";  break;
        case dmmeta_FieldId_isstruct       : ret = "isstruct";  break;
        case dmmeta_FieldId_id             : ret = "id";  break;
        case dmmeta_FieldId_encoding       : ret = "encoding";  break;
        case dmmeta_FieldId_reset          : ret = "reset";  break;
        case dmmeta_FieldId_cfmt           : ret = "cfmt";  break;
        case dmmeta_FieldId_strfmt         : ret = "strfmt";  break;
        case dmmeta_FieldId_printfmt       : ret = "printfmt";  break;
        case dmmeta_FieldId_read           : ret = "read";  break;
        case dmmeta_FieldId_print          : ret = "print";  break;
        case dmmeta_FieldId_sep            : ret = "sep";  break;
        case dmmeta_FieldId_expr           : ret = "expr";  break;
        case dmmeta_FieldId_charrange      : ret = "charrange";  break;
        case dmmeta_FieldId_calc           : ret = "calc";  break;
        case dmmeta_FieldId_hashtype       : ret = "hashtype";  break;
        case dmmeta_FieldId_set            : ret = "set";  break;
        case dmmeta_FieldId_cppkeyword     : ret = "cppkeyword";  break;
        case dmmeta_FieldId_ctor           : ret = "ctor";  break;
        case dmmeta_FieldId_dtor           : ret = "dtor";  break;
        case dmmeta_FieldId_cheap_copy     : ret = "cheap_copy";  break;
        case dmmeta_FieldId_size           : ret = "size";  break;
        case dmmeta_FieldId_alignment      : ret = "alignment";  break;
        case dmmeta_FieldId_strequiv       : ret = "strequiv";  break;
        case dmmeta_FieldId_ns             : ret = "ns";  break;
        case dmmeta_FieldId_len            : ret = "len";  break;
        case dmmeta_FieldId_padbytes       : ret = "padbytes";  break;
        case dmmeta_FieldId_dispatch       : ret = "dispatch";  break;
        case dmmeta_FieldId_unk            : ret = "unk";  break;
        case dmmeta_FieldId_haslen         : ret = "haslen";  break;
        case dmmeta_FieldId_call           : ret = "call";  break;
        case dmmeta_FieldId_strict         : ret = "strict";  break;
        case dmmeta_FieldId_dispatch_msg   : ret = "dispatch_msg";  break;
        case dmmeta_FieldId_match_all      : ret = "match_all";  break;
        case dmmeta_FieldId_dispsig        : ret = "dispsig";  break;
        case dmmeta_FieldId_signature      : ret = "signature";  break;
        case dmmeta_FieldId_cycle          : ret = "cycle";  break;
        case dmmeta_FieldId_fastenc        : ret = "fastenc";  break;
        case dmmeta_FieldId_fastinstr      : ret = "fastinstr";  break;
        case dmmeta_FieldId_fastop         : ret = "fastop";  break;
        case dmmeta_FieldId_stripcomment   : ret = "stripcomment";  break;
        case dmmeta_FieldId_fbufdir        : ret = "fbufdir";  break;
        case dmmeta_FieldId_max            : ret = "max";  break;
        case dmmeta_FieldId_fbuftype       : ret = "fbuftype";  break;
        case dmmeta_FieldId_insready       : ret = "insready";  break;
        case dmmeta_FieldId_inseof         : ret = "inseof";  break;
        case dmmeta_FieldId_getmsg         : ret = "getmsg";  break;
        case dmmeta_FieldId_skipbytes      : ret = "skipbytes";  break;
        case dmmeta_FieldId_fcmap          : ret = "fcmap";  break;
        case dmmeta_FieldId_leftField      : ret = "leftField";  break;
        case dmmeta_FieldId_leftVal        : ret = "leftVal";  break;
        case dmmeta_FieldId_rightVal       : ret = "rightVal";  break;
        case dmmeta_FieldId_rightField     : ret = "rightField";  break;
        case dmmeta_FieldId_bidir          : ret = "bidir";  break;
        case dmmeta_FieldId_basecmdline    : ret = "basecmdline";  break;
        case dmmeta_FieldId_versionsort    : ret = "versionsort";  break;
        case dmmeta_FieldId_casesens       : ret = "casesens";  break;
        case dmmeta_FieldId_fconst         : ret = "fconst";  break;
        case dmmeta_FieldId_value          : ret = "value";  break;
        case dmmeta_FieldId_fcurs          : ret = "fcurs";  break;
        case dmmeta_FieldId_curstype       : ret = "curstype";  break;
        case dmmeta_FieldId_nplace         : ret = "nplace";  break;
        case dmmeta_FieldId_fixedfmt       : ret = "fixedfmt";  break;
        case dmmeta_FieldId_fstep          : ret = "fstep";  break;
        case dmmeta_FieldId_delay          : ret = "delay";  break;
        case dmmeta_FieldId_scale          : ret = "scale";  break;
        case dmmeta_FieldId_ffast          : ret = "ffast";  break;
        case dmmeta_FieldId_pos            : ret = "pos";  break;
        case dmmeta_FieldId_optional       : ret = "optional";  break;
        case dmmeta_FieldId_op             : ret = "op";  break;
        case dmmeta_FieldId_cumulative     : ret = "cumulative";  break;
        case dmmeta_FieldId_emptyval       : ret = "emptyval";  break;
        case dmmeta_FieldId_arg            : ret = "arg";  break;
        case dmmeta_FieldId_reftype        : ret = "reftype";  break;
        case dmmeta_FieldId_update         : ret = "update";  break;
        case dmmeta_FieldId_fprefix        : ret = "fprefix";  break;
        case dmmeta_FieldId_partial        : ret = "partial";  break;
        case dmmeta_FieldId_regxtype       : ret = "regxtype";  break;
        case dmmeta_FieldId_sorttype       : ret = "sorttype";  break;
        case dmmeta_FieldId_sortfld        : ret = "sortfld";  break;
        case dmmeta_FieldId_steptype       : ret = "steptype";  break;
        case dmmeta_FieldId_func           : ret = "func";  break;
        case dmmeta_FieldId_inl            : ret = "inl";  break;
        case dmmeta_FieldId_proto          : ret = "proto";  break;
        case dmmeta_FieldId_body           : ret = "body";  break;
        case dmmeta_FieldId_deprecate      : ret = "deprecate";  break;
        case dmmeta_FieldId_ismacro        : ret = "ismacro";  break;
        case dmmeta_FieldId_glob           : ret = "glob";  break;
        case dmmeta_FieldId_priv           : ret = "priv";  break;
        case dmmeta_FieldId_ret            : ret = "ret";  break;
        case dmmeta_FieldId_fwddecl        : ret = "fwddecl";  break;
        case dmmeta_FieldId_namefld        : ret = "namefld";  break;
        case dmmeta_FieldId_idfld          : ret = "idfld";  break;
        case dmmeta_FieldId_wantenum       : ret = "wantenum";  break;
        case dmmeta_FieldId_namefldctyp    : ret = "namefldctyp";  break;
        case dmmeta_FieldId_gsymbol        : ret = "gsymbol";  break;
        case dmmeta_FieldId_ssimfile       : ret = "ssimfile";  break;
        case dmmeta_FieldId_inc            : ret = "inc";  break;
        case dmmeta_FieldId_symboltype     : ret = "symboltype";  break;
        case dmmeta_FieldId_min            : ret = "min";  break;
        case dmmeta_FieldId_extra          : ret = "extra";  break;
        case dmmeta_FieldId_listtype       : ret = "listtype";  break;
        case dmmeta_FieldId_circular       : ret = "circular";  break;
        case dmmeta_FieldId_haveprev       : ret = "haveprev";  break;
        case dmmeta_FieldId_instail        : ret = "instail";  break;
        case dmmeta_FieldId_havetail       : ret = "havetail";  break;
        case dmmeta_FieldId_havecount      : ret = "havecount";  break;
        case dmmeta_FieldId_logcat         : ret = "logcat";  break;
        case dmmeta_FieldId_enabled        : ret = "enabled";  break;
        case dmmeta_FieldId_builtin        : ret = "builtin";  break;
        case dmmeta_FieldId_ismodule       : ret = "ismodule";  break;
        case dmmeta_FieldId_type           : ret = "type";  break;
        case dmmeta_FieldId_xref           : ret = "xref";  break;
        case dmmeta_FieldId_nstype         : ret = "nstype";  break;
        case dmmeta_FieldId_license        : ret = "license";  break;
        case dmmeta_FieldId_nsinclude      : ret = "nsinclude";  break;
        case dmmeta_FieldId_sys            : ret = "sys";  break;
        case dmmeta_FieldId_version        : ret = "version";  break;
        case dmmeta_FieldId_genthrow       : ret = "genthrow";  break;
        case dmmeta_FieldId_correct_getorcreate: ret = "correct_getorcreate";  break;
        case dmmeta_FieldId_pool           : ret = "pool";  break;
        case dmmeta_FieldId_sortxref       : ret = "sortxref";  break;
        case dmmeta_FieldId_pack           : ret = "pack";  break;
        case dmmeta_FieldId_numtype        : ret = "numtype";  break;
        case dmmeta_FieldId_min_len        : ret = "min_len";  break;
        case dmmeta_FieldId_filter_print   : ret = "filter_print";  break;
        case dmmeta_FieldId_pmaskfld_member: ret = "pmaskfld_member";  break;
        case dmmeta_FieldId_pmaskfld       : ret = "pmaskfld";  break;
        case dmmeta_FieldId_pnew           : ret = "pnew";  break;
        case dmmeta_FieldId_buftype        : ret = "buftype";  break;
        case dmmeta_FieldId_unique         : ret = "unique";  break;
        case dmmeta_FieldId_isval          : ret = "isval";  break;
        case dmmeta_FieldId_cascins        : ret = "cascins";  break;
        case dmmeta_FieldId_usebasepool    : ret = "usebasepool";  break;
        case dmmeta_FieldId_cancopy        : ret = "cancopy";  break;
        case dmmeta_FieldId_isxref         : ret = "isxref";  break;
        case dmmeta_FieldId_del            : ret = "del";  break;
        case dmmeta_FieldId_up             : ret = "up";  break;
        case dmmeta_FieldId_isnew          : ret = "isnew";  break;
        case dmmeta_FieldId_hasalloc       : ret = "hasalloc";  break;
        case dmmeta_FieldId_inst           : ret = "inst";  break;
        case dmmeta_FieldId_varlen         : ret = "varlen";  break;
        case dmmeta_FieldId_length         : ret = "length";  break;
        case dmmeta_FieldId_strtype        : ret = "strtype";  break;
        case dmmeta_FieldId_pad            : ret = "pad";  break;
        case dmmeta_FieldId_ssimns         : ret = "ssimns";  break;
        case dmmeta_FieldId_ssimreq        : ret = "ssimreq";  break;
        case dmmeta_FieldId_parent         : ret = "parent";  break;
        case dmmeta_FieldId_parent_field   : ret = "parent_field";  break;
        case dmmeta_FieldId_parent_ctype   : ret = "parent_ctype";  break;
        case dmmeta_FieldId_child_ssimfile : ret = "child_ssimfile";  break;
        case dmmeta_FieldId_child_key      : ret = "child_key";  break;
        case dmmeta_FieldId_reqchild       : ret = "reqchild";  break;
        case dmmeta_FieldId_maxwid         : ret = "maxwid";  break;
        case dmmeta_FieldId_fixedwid1      : ret = "fixedwid1";  break;
        case dmmeta_FieldId_fixedwid2      : ret = "fixedwid2";  break;
        case dmmeta_FieldId_aliased        : ret = "aliased";  break;
        case dmmeta_FieldId_hashfld        : ret = "hashfld";  break;
        case dmmeta_FieldId_tracefld       : ret = "tracefld";  break;
        case dmmeta_FieldId_tracerec       : ret = "tracerec";  break;
        case dmmeta_FieldId_inscond        : ret = "inscond";  break;
        case dmmeta_FieldId_via            : ret = "via";  break;
        case dmmeta_FieldId_viafld         : ret = "viafld";  break;
        case dmmeta_FieldId_keyfld         : ret = "keyfld";  break;
    }
    return ret;
}

// --- dmmeta.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dmmeta::value_Print(const dmmeta::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dmmeta.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::value_SetStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('i','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_id); ret = true; break;
                }
                case LE_STR2('n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_ns); ret = true; break;
                }
                case LE_STR2('o','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_op); ret = true; break;
                }
                case LE_STR2('u','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_up); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','r','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_arg); ret = true; break;
                }
                case LE_STR3('d','e','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_del); ret = true; break;
                }
                case LE_STR3('i','n','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_inc); ret = true; break;
                }
                case LE_STR3('i','n','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_inl); ret = true; break;
                }
                case LE_STR3('l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_len); ret = true; break;
                }
                case LE_STR3('m','a','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_max); ret = true; break;
                }
                case LE_STR3('m','i','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_min); ret = true; break;
                }
                case LE_STR3('p','a','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_pad); ret = true; break;
                }
                case LE_STR3('p','o','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_pos); ret = true; break;
                }
                case LE_STR3('r','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_ret); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_set); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_sys); ret = true; break;
                }
                case LE_STR3('u','n','k'): {
                    value_SetEnum(parent,dmmeta_FieldId_unk); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,dmmeta_FieldId_via); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_base); ret = true; break;
                }
                case LE_STR4('b','o','d','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_body); ret = true; break;
                }
                case LE_STR4('c','a','l','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_calc); ret = true; break;
                }
                case LE_STR4('c','a','l','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_call); ret = true; break;
                }
                case LE_STR4('c','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_cfmt); ret = true; break;
                }
                case LE_STR4('c','t','o','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_ctor); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('d','t','o','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_dtor); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_expr); ret = true; break;
                }
                case LE_STR4('f','u','n','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_func); ret = true; break;
                }
                case LE_STR4('g','l','o','b'): {
                    value_SetEnum(parent,dmmeta_FieldId_glob); ret = true; break;
                }
                case LE_STR4('i','n','s','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_inst); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_name); ret = true; break;
                }
                case LE_STR4('p','a','c','k'): {
                    value_SetEnum(parent,dmmeta_FieldId_pack); ret = true; break;
                }
                case LE_STR4('p','n','e','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_pnew); ret = true; break;
                }
                case LE_STR4('p','o','o','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_pool); ret = true; break;
                }
                case LE_STR4('p','r','i','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_priv); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_read); ret = true; break;
                }
                case LE_STR4('s','i','z','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_size); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_type); ret = true; break;
                }
                case LE_STR4('x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_xref); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','f','t','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_after); ret = true; break;
                }
                case LE_STR5('b','i','d','i','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_bidir); ret = true; break;
                }
                case LE_STR5('c','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ctype); ret = true; break;
                }
                case LE_STR5('c','y','c','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_cycle); ret = true; break;
                }
                case LE_STR5('d','e','l','a','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_delay); ret = true; break;
                }
                case LE_STR5('e','x','t','r','a'): {
                    value_SetEnum(parent,dmmeta_FieldId_extra); ret = true; break;
                }
                case LE_STR5('e','x','t','r','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_extrn); ret = true; break;
                }
                case LE_STR5('f','c','m','a','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_fcmap); ret = true; break;
                }
                case LE_STR5('f','c','u','r','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_fcurs); ret = true; break;
                }
                case LE_STR5('f','f','a','s','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_ffast); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_field); ret = true; break;
                }
                case LE_STR5('f','s','t','e','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_fstep); ret = true; break;
                }
                case LE_STR5('g','e','n','o','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_genop); ret = true; break;
                }
                case LE_STR5('i','d','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_idfld); ret = true; break;
                }
                case LE_STR5('i','s','n','e','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_isnew); ret = true; break;
                }
                case LE_STR5('i','s','v','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_isval); ret = true; break;
                }
                case LE_STR5('o','r','d','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_order); ret = true; break;
                }
                case LE_STR5('p','r','i','n','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_print); ret = true; break;
                }
                case LE_STR5('p','r','o','t','o'): {
                    value_SetEnum(parent,dmmeta_FieldId_proto); ret = true; break;
                }
                case LE_STR5('r','e','s','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_reset); ret = true; break;
                }
                case LE_STR5('s','c','a','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_scale); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','i','d','t','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_width); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('c','a','f','t','e','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_cafter); ret = true; break;
                }
                case LE_STR6('f','a','s','t','o','p'): {
                    value_SetEnum(parent,dmmeta_FieldId_fastop); ret = true; break;
                }
                case LE_STR6('f','c','o','n','s','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_fconst); ret = true; break;
                }
                case LE_STR6('g','e','t','m','s','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_getmsg); ret = true; break;
                }
                case LE_STR6('h','a','s','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_haslen); ret = true; break;
                }
                case LE_STR6('i','n','s','e','o','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_inseof); ret = true; break;
                }
                case LE_STR6('i','s','x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_isxref); ret = true; break;
                }
                case LE_STR6('j','s','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_jsdflt); ret = true; break;
                }
                case LE_STR6('k','e','y','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_keyfld); ret = true; break;
                }
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_length); ret = true; break;
                }
                case LE_STR6('l','o','g','c','a','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_logcat); ret = true; break;
                }
                case LE_STR6('m','a','x','w','i','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_maxwid); ret = true; break;
                }
                case LE_STR6('m','i','n','m','a','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_minmax); ret = true; break;
                }
                case LE_STR6('n','p','l','a','c','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_nplace); ret = true; break;
                }
                case LE_STR6('n','s','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_nstype); ret = true; break;
                }
                case LE_STR6('o','f','f','s','e','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_offset); ret = true; break;
                }
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_parent); ret = true; break;
                }
                case LE_STR6('s','s','i','m','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimns); ret = true; break;
                }
                case LE_STR6('s','t','r','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_strfmt); ret = true; break;
                }
                case LE_STR6('s','t','r','i','c','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_strict); ret = true; break;
                }
                case LE_STR6('u','n','i','q','u','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_unique); ret = true; break;
                }
                case LE_STR6('u','p','d','a','t','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_update); ret = true; break;
                }
                case LE_STR6('v','a','r','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_varlen); ret = true; break;
                }
                case LE_STR6('v','i','a','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_viafld); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','l','i','a','s','e','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_aliased); ret = true; break;
                }
                case LE_STR7('b','u','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_buftype); ret = true; break;
                }
                case LE_STR7('b','u','i','l','t','i','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_builtin); ret = true; break;
                }
                case LE_STR7('c','a','n','c','o','p','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_cancopy); ret = true; break;
                }
                case LE_STR7('c','a','s','c','i','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_cascins); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','p','p','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_cppdflt); ret = true; break;
                }
                case LE_STR7('d','i','s','p','s','i','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_dispsig); ret = true; break;
                }
                case LE_STR7('e','n','a','b','l','e','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_enabled); ret = true; break;
                }
                case LE_STR7('f','a','s','t','e','n','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_fastenc); ret = true; break;
                }
                case LE_STR7('f','b','u','f','d','i','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_fbufdir); ret = true; break;
                }
                case LE_STR7('f','p','r','e','f','i','x'): {
                    value_SetEnum(parent,dmmeta_FieldId_fprefix); ret = true; break;
                }
                case LE_STR7('f','w','d','d','e','c','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_fwddecl); ret = true; break;
                }
                case LE_STR7('g','s','y','m','b','o','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_gsymbol); ret = true; break;
                }
                case LE_STR7('h','a','s','h','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_hashfld); ret = true; break;
                }
                case LE_STR7('i','n','s','c','o','n','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_inscond); ret = true; break;
                }
                case LE_STR7('i','n','s','t','a','i','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_instail); ret = true; break;
                }
                case LE_STR7('i','s','m','a','c','r','o'): {
                    value_SetEnum(parent,dmmeta_FieldId_ismacro); ret = true; break;
                }
                case LE_STR7('l','e','f','t','V','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_leftVal); ret = true; break;
                }
                case LE_STR7('l','i','c','e','n','s','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_license); ret = true; break;
                }
                case LE_STR7('m','i','n','_','l','e','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_min_len); ret = true; break;
                }
                case LE_STR7('n','a','m','e','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_namefld); ret = true; break;
                }
                case LE_STR7('n','u','m','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_numtype); ret = true; break;
                }
                case LE_STR7('p','a','r','t','i','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_partial); ret = true; break;
                }
                case LE_STR7('r','e','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_reftype); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','s','i','m','r','e','q'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimreq); ret = true; break;
                }
                case LE_STR7('s','t','r','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_strtype); ret = true; break;
                }
                case LE_STR7('v','e','r','s','i','o','n'): {
                    value_SetEnum(parent,dmmeta_FieldId_version); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','r','g','v','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_argvtype); ret = true; break;
                }
                case LE_STR8('c','a','s','e','s','e','n','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_casesens); ret = true; break;
                }
                case LE_STR8('c','i','r','c','u','l','a','r'): {
                    value_SetEnum(parent,dmmeta_FieldId_circular); ret = true; break;
                }
                case LE_STR8('c','u','r','s','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_curstype); ret = true; break;
                }
                case LE_STR8('d','i','s','p','a','t','c','h'): {
                    value_SetEnum(parent,dmmeta_FieldId_dispatch); ret = true; break;
                }
                case LE_STR8('e','m','p','t','y','v','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_emptyval); ret = true; break;
                }
                case LE_STR8('e','n','c','o','d','i','n','g'): {
                    value_SetEnum(parent,dmmeta_FieldId_encoding); ret = true; break;
                }
                case LE_STR8('f','b','u','f','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_fbuftype); ret = true; break;
                }
                case LE_STR8('f','i','x','e','d','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_fixedfmt); ret = true; break;
                }
                case LE_STR8('g','e','n','t','h','r','o','w'): {
                    value_SetEnum(parent,dmmeta_FieldId_genthrow); ret = true; break;
                }
                case LE_STR8('h','a','s','a','l','l','o','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_hasalloc); ret = true; break;
                }
                case LE_STR8('h','a','s','h','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_hashtype); ret = true; break;
                }
                case LE_STR8('h','a','v','e','p','r','e','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_haveprev); ret = true; break;
                }
                case LE_STR8('h','a','v','e','t','a','i','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_havetail); ret = true; break;
                }
                case LE_STR8('i','n','s','r','e','a','d','y'): {
                    value_SetEnum(parent,dmmeta_FieldId_insready); ret = true; break;
                }
                case LE_STR8('i','s','m','o','d','u','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ismodule); ret = true; break;
                }
                case LE_STR8('i','s','s','t','r','u','c','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_isstruct); ret = true; break;
                }
                case LE_STR8('l','i','s','t','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_listtype); ret = true; break;
                }
                case LE_STR8('o','p','t','i','o','n','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_optional); ret = true; break;
                }
                case LE_STR8('p','a','d','b','y','t','e','s'): {
                    value_SetEnum(parent,dmmeta_FieldId_padbytes); ret = true; break;
                }
                case LE_STR8('p','m','a','s','k','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_pmaskfld); ret = true; break;
                }
                case LE_STR8('p','n','e','w','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_pnewtype); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','f','m','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_printfmt); ret = true; break;
                }
                case LE_STR8('r','e','g','x','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_regxtype); ret = true; break;
                }
                case LE_STR8('r','e','q','c','h','i','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_reqchild); ret = true; break;
                }
                case LE_STR8('r','i','g','h','t','V','a','l'): {
                    value_SetEnum(parent,dmmeta_FieldId_rightVal); ret = true; break;
                }
                case LE_STR8('s','o','r','t','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_sorttype); ret = true; break;
                }
                case LE_STR8('s','o','r','t','x','r','e','f'): {
                    value_SetEnum(parent,dmmeta_FieldId_sortxref); ret = true; break;
                }
                case LE_STR8('s','r','c','f','i','e','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_srcfield); ret = true; break;
                }
                case LE_STR8('s','s','i','m','d','f','l','t'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimdflt); ret = true; break;
                }
                case LE_STR8('s','s','i','m','f','i','l','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_ssimfile); ret = true; break;
                }
                case LE_STR8('s','t','e','p','t','y','p','e'): {
                    value_SetEnum(parent,dmmeta_FieldId_steptype); ret = true; break;
                }
                case LE_STR8('s','t','r','e','q','u','i','v'): {
                    value_SetEnum(parent,dmmeta_FieldId_strequiv); ret = true; break;
                }
                case LE_STR8('t','r','a','c','e','f','l','d'): {
                    value_SetEnum(parent,dmmeta_FieldId_tracefld); ret = true; break;
                }
                case LE_STR8('t','r','a','c','e','r','e','c'): {
                    value_SetEnum(parent,dmmeta_FieldId_tracerec); ret = true; break;
                }
                case LE_STR8('w','a','n','t','e','n','u','m'): {
                    value_SetEnum(parent,dmmeta_FieldId_wantenum); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','l','i','g','n','m','e','n'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dmmeta_FieldId_alignment); ret = true; break; }
                    break;
                }
                case LE_STR8('c','h','a','r','r','a','n','g'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_charrange); ret = true; break; }
                    break;
                }
                case LE_STR8('c','h','i','l','d','_','k','e'): {
                    if (memcmp(rhs.elems+8,"y",1)==0) { value_SetEnum(parent,dmmeta_FieldId_child_key); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','p','r','e','c','a','t'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_deprecate); ret = true; break; }
                    break;
                }
                case LE_STR8('f','a','s','t','i','n','s','t'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,dmmeta_FieldId_fastinstr); ret = true; break; }
                    break;
                }
                case LE_STR8('f','i','x','e','d','w','i','d'): {
                    if (memcmp(rhs.elems+8,"1",1)==0) { value_SetEnum(parent,dmmeta_FieldId_fixedwid1); ret = true; break; }
                    if (memcmp(rhs.elems+8,"2",1)==0) { value_SetEnum(parent,dmmeta_FieldId_fixedwid2); ret = true; break; }
                    break;
                }
                case LE_STR8('h','a','v','e','c','o','u','n'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,dmmeta_FieldId_havecount); ret = true; break; }
                    break;
                }
                case LE_STR8('l','e','f','t','F','i','e','l'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dmmeta_FieldId_leftField); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','t','c','h','_','a','l'): {
                    if (memcmp(rhs.elems+8,"l",1)==0) { value_SetEnum(parent,dmmeta_FieldId_match_all); ret = true; break; }
                    break;
                }
                case LE_STR8('n','s','i','n','c','l','u','d'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_nsinclude); ret = true; break; }
                    break;
                }
                case LE_STR8('s','i','g','n','a','t','u','r'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dmmeta_FieldId_signature); ret = true; break; }
                    break;
                }
                case LE_STR8('s','k','i','p','b','y','t','e'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,dmmeta_FieldId_skipbytes); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','e','a','p','_','c','o'): {
                    if (memcmp(rhs.elems+8,"py",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cheap_copy); ret = true; break; }
                    break;
                }
                case LE_STR8('c','p','p','k','e','y','w','o'): {
                    if (memcmp(rhs.elems+8,"rd",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cppkeyword); ret = true; break; }
                    break;
                }
                case LE_STR8('c','u','m','u','l','a','t','i'): {
                    if (memcmp(rhs.elems+8,"ve",2)==0) { value_SetEnum(parent,dmmeta_FieldId_cumulative); ret = true; break; }
                    break;
                }
                case LE_STR8('i','n','i','t','m','e','m','s'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,dmmeta_FieldId_initmemset); ret = true; break; }
                    break;
                }
                case LE_STR8('r','i','g','h','t','F','i','e'): {
                    if (memcmp(rhs.elems+8,"ld",2)==0) { value_SetEnum(parent,dmmeta_FieldId_rightField); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','m','b','o','l','t','y'): {
                    if (memcmp(rhs.elems+8,"pe",2)==0) { value_SetEnum(parent,dmmeta_FieldId_symboltype); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('b','a','s','e','c','m','d','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dmmeta_FieldId_basecmdline); ret = true; break; }
                    break;
                }
                case LE_STR8('n','a','m','e','f','l','d','c'): {
                    if (memcmp(rhs.elems+8,"typ",3)==0) { value_SetEnum(parent,dmmeta_FieldId_namefldctyp); ret = true; break; }
                    break;
                }
                case LE_STR8('u','s','e','b','a','s','e','p'): {
                    if (memcmp(rhs.elems+8,"ool",3)==0) { value_SetEnum(parent,dmmeta_FieldId_usebasepool); ret = true; break; }
                    break;
                }
                case LE_STR8('v','e','r','s','i','o','n','s'): {
                    if (memcmp(rhs.elems+8,"ort",3)==0) { value_SetEnum(parent,dmmeta_FieldId_versionsort); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','i','s','p','a','t','c','h'): {
                    if (memcmp(rhs.elems+8,"_msg",4)==0) { value_SetEnum(parent,dmmeta_FieldId_dispatch_msg); ret = true; break; }
                    break;
                }
                case LE_STR8('f','i','l','t','e','r','_','p'): {
                    if (memcmp(rhs.elems+8,"rint",4)==0) { value_SetEnum(parent,dmmeta_FieldId_filter_print); ret = true; break; }
                    break;
                }
                case LE_STR8('p','a','r','e','n','t','_','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,dmmeta_FieldId_parent_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('p','a','r','e','n','t','_','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,dmmeta_FieldId_parent_field); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','i','p','c','o','m'): {
                    if (memcmp(rhs.elems+8,"ment",4)==0) { value_SetEnum(parent,dmmeta_FieldId_stripcomment); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','i','l','d','_','s','s'): {
                    if (memcmp(rhs.elems+8,"imfile",6)==0) { value_SetEnum(parent,dmmeta_FieldId_child_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','m','a','s','k','f','l','d'): {
                    if (memcmp(rhs.elems+8,"_member",7)==0) { value_SetEnum(parent,dmmeta_FieldId_pmaskfld_member); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','r','r','e','c','t','_'): {
                    if (memcmp(rhs.elems+8,"getorcreate",11)==0) { value_SetEnum(parent,dmmeta_FieldId_correct_getorcreate); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::value_SetStrptr(dmmeta::FieldId& parent, algo::strptr rhs, dmmeta_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dmmeta.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dmmeta::value_ReadStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dmmeta.FieldId..ReadStrptrMaybe
// Read fields of dmmeta::FieldId from an ascii string.
// The format of the string is the format of the dmmeta::FieldId's only field
bool dmmeta::FieldId_ReadStrptrMaybe(dmmeta::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dmmeta.FieldId..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.FieldId.String  printfmt:Raw
void dmmeta::FieldId_Print(dmmeta::FieldId& row, algo::cstring& str) {
    dmmeta::value_Print(row, str);
}

// --- dmmeta.Findrem..ReadFieldMaybe
bool dmmeta::Findrem_ReadFieldMaybe(dmmeta::Findrem& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Findrem..ReadStrptrMaybe
// Read fields of dmmeta::Findrem from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Findrem_ReadStrptrMaybe(dmmeta::Findrem &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.findrem") || algo::StripTypeTag(in_str, "dmmeta.Findrem");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Findrem_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Findrem..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Findrem.String  printfmt:Tuple
void dmmeta::Findrem_Print(dmmeta::Findrem& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.findrem";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Finput.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Finput& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Finput.ns.Get2
algo::Smallstr16 dmmeta::Finput_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Finput..ReadFieldMaybe
bool dmmeta::Finput_ReadFieldMaybe(dmmeta::Finput& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_extrn: {
            retval = bool_ReadStrptrMaybe(parent.extrn, strval);
            break;
        }
        case dmmeta_FieldId_update: {
            retval = bool_ReadStrptrMaybe(parent.update, strval);
            break;
        }
        case dmmeta_FieldId_strict: {
            retval = bool_ReadStrptrMaybe(parent.strict, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Finput..ReadStrptrMaybe
// Read fields of dmmeta::Finput from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Finput_ReadStrptrMaybe(dmmeta::Finput &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.finput") || algo::StripTypeTag(in_str, "dmmeta.Finput");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Finput_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Finput..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Finput.String  printfmt:Tuple
void dmmeta::Finput_Print(dmmeta::Finput& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.finput";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.update, temp);
    PrintAttrSpaceReset(str,"update", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fldoffset..ReadFieldMaybe
bool dmmeta::Fldoffset_ReadFieldMaybe(dmmeta::Fldoffset& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_offset: {
            retval = i32_ReadStrptrMaybe(parent.offset, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fldoffset..ReadStrptrMaybe
// Read fields of dmmeta::Fldoffset from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fldoffset_ReadStrptrMaybe(dmmeta::Fldoffset &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fldoffset") || algo::StripTypeTag(in_str, "dmmeta.Fldoffset");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fldoffset_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fldoffset..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fldoffset.String  printfmt:Tuple
void dmmeta::Fldoffset_Print(dmmeta::Fldoffset& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fldoffset";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.offset, temp);
    PrintAttrSpaceReset(str,"offset", temp);
}

// --- dmmeta.Floadtuples.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Floadtuples& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Floadtuples.ctype.Get2
algo::Smallstr100 dmmeta::Floadtuples_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Floadtuples..ReadFieldMaybe
bool dmmeta::Floadtuples_ReadFieldMaybe(dmmeta::Floadtuples& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Floadtuples..ReadStrptrMaybe
// Read fields of dmmeta::Floadtuples from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Floadtuples_ReadStrptrMaybe(dmmeta::Floadtuples &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.floadtuples") || algo::StripTypeTag(in_str, "dmmeta.Floadtuples");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Floadtuples_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Floadtuples..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Floadtuples.String  printfmt:Tuple
void dmmeta::Floadtuples_Print(dmmeta::Floadtuples& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.floadtuples";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fnoremove..ReadFieldMaybe
bool dmmeta::Fnoremove_ReadFieldMaybe(dmmeta::Fnoremove& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fnoremove..ReadStrptrMaybe
// Read fields of dmmeta::Fnoremove from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fnoremove_ReadStrptrMaybe(dmmeta::Fnoremove &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fnoremove") || algo::StripTypeTag(in_str, "dmmeta.Fnoremove");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fnoremove_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fnoremove..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fnoremove.String  printfmt:Tuple
void dmmeta::Fnoremove_Print(dmmeta::Fnoremove& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fnoremove";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Foutput.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Foutput& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Foutput.ns.Get2
algo::Smallstr16 dmmeta::Foutput_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Foutput..ReadFieldMaybe
bool dmmeta::Foutput_ReadFieldMaybe(dmmeta::Foutput& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Foutput..ReadStrptrMaybe
// Read fields of dmmeta::Foutput from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Foutput_ReadStrptrMaybe(dmmeta::Foutput &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.foutput") || algo::StripTypeTag(in_str, "dmmeta.Foutput");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Foutput_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Foutput..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Foutput.String  printfmt:Tuple
void dmmeta::Foutput_Print(dmmeta::Foutput& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.foutput";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fprefix..ReadFieldMaybe
bool dmmeta::Fprefix_ReadFieldMaybe(dmmeta::Fprefix& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fprefix: {
            retval = algo::Smallstr5_ReadStrptrMaybe(parent.fprefix, strval);
            break;
        }
        case dmmeta_FieldId_reftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fprefix..ReadStrptrMaybe
// Read fields of dmmeta::Fprefix from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fprefix_ReadStrptrMaybe(dmmeta::Fprefix &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fprefix") || algo::StripTypeTag(in_str, "dmmeta.Fprefix");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fprefix_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fprefix..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fprefix.String  printfmt:Tuple
void dmmeta::Fprefix_Print(dmmeta::Fprefix& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fprefix";

    algo::Smallstr5_Print(row.fprefix, temp);
    PrintAttrSpaceReset(str,"fprefix", temp);

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fregx..ReadFieldMaybe
bool dmmeta::Fregx_ReadFieldMaybe(dmmeta::Fregx& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_partial: {
            retval = bool_ReadStrptrMaybe(parent.partial, strval);
            break;
        }
        case dmmeta_FieldId_regxtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.regxtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fregx..ReadStrptrMaybe
// Read fields of dmmeta::Fregx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fregx_ReadStrptrMaybe(dmmeta::Fregx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fregx") || algo::StripTypeTag(in_str, "dmmeta.Fregx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fregx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fregx..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fregx.String  printfmt:Tuple
void dmmeta::Fregx_Print(dmmeta::Fregx& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fregx";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.partial, temp);
    PrintAttrSpaceReset(str,"partial", temp);

    algo::Smallstr50_Print(row.regxtype, temp);
    PrintAttrSpaceReset(str,"regxtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fsort..ReadFieldMaybe
bool dmmeta::Fsort_ReadFieldMaybe(dmmeta::Fsort& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_sorttype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.sorttype, strval);
            break;
        }
        case dmmeta_FieldId_sortfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fsort..ReadStrptrMaybe
// Read fields of dmmeta::Fsort from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fsort_ReadStrptrMaybe(dmmeta::Fsort &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fsort") || algo::StripTypeTag(in_str, "dmmeta.Fsort");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fsort_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fsort..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fsort.String  printfmt:Tuple
void dmmeta::Fsort_Print(dmmeta::Fsort& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fsort";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr50_Print(row.sorttype, temp);
    PrintAttrSpaceReset(str,"sorttype", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fstep.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Fstep& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fstep, ""));
    return ret;
}

// --- dmmeta.Fstep.field.Get2
algo::Smallstr100 dmmeta::Fstep_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ""));
    return ret;
}

// --- dmmeta.Fstep.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fstep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.fstep, ".LL"));
    return ret;
}

// --- dmmeta.Fstep.ns.Get2
algo::Smallstr16 dmmeta::Fstep_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Fstep.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Fstep& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.fstep, ".RR"));
    return ret;
}

// --- dmmeta.Fstep.name.Get2
algo::Smallstr50 dmmeta::Fstep_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Fstep..Concat_field
tempstr dmmeta::Fstep_Concat_field( const algo::strptr& field ) {
    return tempstr() << field ;
}

// --- dmmeta.Fstep..ReadFieldMaybe
bool dmmeta::Fstep_ReadFieldMaybe(dmmeta::Fstep& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fstep: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval);
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_steptype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.steptype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fstep..ReadStrptrMaybe
// Read fields of dmmeta::Fstep from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fstep_ReadStrptrMaybe(dmmeta::Fstep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fstep") || algo::StripTypeTag(in_str, "dmmeta.Fstep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fstep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fstep..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fstep.String  printfmt:Tuple
void dmmeta::Fstep_Print(dmmeta::Fstep& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fstep";

    algo::Smallstr100_Print(row.fstep, temp);
    PrintAttrSpaceReset(str,"fstep", temp);

    algo::Smallstr50_Print(row.steptype, temp);
    PrintAttrSpaceReset(str,"steptype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ftrace..ReadFieldMaybe
bool dmmeta::Ftrace_ReadFieldMaybe(dmmeta::Ftrace& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ftrace..ReadStrptrMaybe
// Read fields of dmmeta::Ftrace from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ftrace_ReadStrptrMaybe(dmmeta::Ftrace &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ftrace") || algo::StripTypeTag(in_str, "dmmeta.Ftrace");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ftrace_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ftrace..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ftrace.String  printfmt:Tuple
void dmmeta::Ftrace_Print(dmmeta::Ftrace& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ftrace";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ftuple..ReadFieldMaybe
bool dmmeta::Ftuple_ReadFieldMaybe(dmmeta::Ftuple& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ftuple..ReadStrptrMaybe
// Read fields of dmmeta::Ftuple from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ftuple_ReadStrptrMaybe(dmmeta::Ftuple &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ftuple") || algo::StripTypeTag(in_str, "dmmeta.Ftuple");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ftuple_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ftuple..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ftuple.String  printfmt:Tuple
void dmmeta::Ftuple_Print(dmmeta::Ftuple& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ftuple";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Func.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::Func& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.func, ".RL"));
    return ret;
}

// --- dmmeta.Func.field.Get2
algo::Smallstr100 dmmeta::Func_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Func.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Func& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.func, ".RR"));
    return ret;
}

// --- dmmeta.Func.name.Get2
algo::Smallstr50 dmmeta::Func_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Func.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Func& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.func, ".RL.RL"));
    return ret;
}

// --- dmmeta.Func.ctype.Get2
algo::Smallstr100 dmmeta::Func_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL.RL"));
    return ret;
}

// --- dmmeta.Func.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Func& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.func, ".RL.RL.RL"));
    return ret;
}

// --- dmmeta.Func.ns.Get2
algo::Smallstr16 dmmeta::Func_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL.RL.RL"));
    return ret;
}

// --- dmmeta.Func..Concat_field_name
tempstr dmmeta::Func_Concat_field_name( const algo::strptr& field ,const algo::strptr& name ) {
    return tempstr() << field <<'.'<< name ;
}

// --- dmmeta.Func..ReadFieldMaybe
bool dmmeta::Func_ReadFieldMaybe(dmmeta::Func& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_func: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.func, strval);
            break;
        }
        case dmmeta_FieldId_inl: {
            retval = bool_ReadStrptrMaybe(parent.inl, strval);
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_proto: {
            retval = algo::cstring_ReadStrptrMaybe(parent.proto, strval);
            break;
        }
        case dmmeta_FieldId_body: {
            retval = algo::cstring_ReadStrptrMaybe(parent.body, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_deprecate: {
            retval = bool_ReadStrptrMaybe(parent.deprecate, strval);
            break;
        }
        case dmmeta_FieldId_ismacro: {
            retval = bool_ReadStrptrMaybe(parent.ismacro, strval);
            break;
        }
        case dmmeta_FieldId_extrn: {
            retval = bool_ReadStrptrMaybe(parent.extrn, strval);
            break;
        }
        case dmmeta_FieldId_glob: {
            retval = bool_ReadStrptrMaybe(parent.glob, strval);
            break;
        }
        case dmmeta_FieldId_priv: {
            retval = bool_ReadStrptrMaybe(parent.priv, strval);
            break;
        }
        case dmmeta_FieldId_ret: {
            retval = algo::cstring_ReadStrptrMaybe(parent.ret, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Func..ReadStrptrMaybe
// Read fields of dmmeta::Func from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Func_ReadStrptrMaybe(dmmeta::Func &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.func") || algo::StripTypeTag(in_str, "dmmeta.Func");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Func_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Func..Init
// Set all fields to initial values.
void dmmeta::Func_Init(dmmeta::Func& parent) {
    parent.inl = bool(false);
    parent.deprecate = bool(false);
    parent.ismacro = bool(false);
    parent.extrn = bool(false);
    parent.glob = bool(false);
    parent.priv = bool(false);
}

// --- dmmeta.Func..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Func.String  printfmt:Tuple
void dmmeta::Func_Print(dmmeta::Func& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.func";

    algo::Smallstr100_Print(row.func, temp);
    PrintAttrSpaceReset(str,"func", temp);

    bool_Print(row.inl, temp);
    PrintAttrSpaceReset(str,"inl", temp);

    algo::cstring_Print(row.proto, temp);
    PrintAttrSpaceReset(str,"proto", temp);

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);

    bool_Print(row.deprecate, temp);
    PrintAttrSpaceReset(str,"deprecate", temp);

    bool_Print(row.ismacro, temp);
    PrintAttrSpaceReset(str,"ismacro", temp);

    bool_Print(row.extrn, temp);
    PrintAttrSpaceReset(str,"extrn", temp);

    bool_Print(row.glob, temp);
    PrintAttrSpaceReset(str,"glob", temp);

    bool_Print(row.priv, temp);
    PrintAttrSpaceReset(str,"priv", temp);

    algo::cstring_Print(row.ret, temp);
    PrintAttrSpaceReset(str,"ret", temp);

    algo::cstring_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Funique..ReadFieldMaybe
bool dmmeta::Funique_ReadFieldMaybe(dmmeta::Funique& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Funique..ReadStrptrMaybe
// Read fields of dmmeta::Funique from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Funique_ReadStrptrMaybe(dmmeta::Funique &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.funique") || algo::StripTypeTag(in_str, "dmmeta.Funique");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Funique_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Funique..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Funique.String  printfmt:Tuple
void dmmeta::Funique_Print(dmmeta::Funique& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.funique";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fuserinit..ReadFieldMaybe
bool dmmeta::Fuserinit_ReadFieldMaybe(dmmeta::Fuserinit& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fuserinit..ReadStrptrMaybe
// Read fields of dmmeta::Fuserinit from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fuserinit_ReadStrptrMaybe(dmmeta::Fuserinit &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fuserinit") || algo::StripTypeTag(in_str, "dmmeta.Fuserinit");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fuserinit_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fuserinit..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fuserinit.String  printfmt:Tuple
void dmmeta::Fuserinit_Print(dmmeta::Fuserinit& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fuserinit";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Fwddecl.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Fwddecl& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.fwddecl, ".LL"));
    return ret;
}

// --- dmmeta.Fwddecl.ns.Get2
algo::Smallstr16 dmmeta::Fwddecl_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Fwddecl.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Fwddecl& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.fwddecl, ".LR"));
    return ret;
}

// --- dmmeta.Fwddecl.ctype.Get2
algo::Smallstr100 dmmeta::Fwddecl_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- dmmeta.Fwddecl..Concat_ns_ctype
tempstr dmmeta::Fwddecl_Concat_ns_ctype( const algo::strptr& ns ,const algo::strptr& ctype ) {
    return tempstr() << ns <<'.'<< ctype ;
}

// --- dmmeta.Fwddecl..ReadFieldMaybe
bool dmmeta::Fwddecl_ReadFieldMaybe(dmmeta::Fwddecl& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_fwddecl: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.fwddecl, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Fwddecl..ReadStrptrMaybe
// Read fields of dmmeta::Fwddecl from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Fwddecl_ReadStrptrMaybe(dmmeta::Fwddecl &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.fwddecl") || algo::StripTypeTag(in_str, "dmmeta.Fwddecl");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Fwddecl_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Fwddecl..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Fwddecl.String  printfmt:Tuple
void dmmeta::Fwddecl_Print(dmmeta::Fwddecl& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.fwddecl";

    algo::Smallstr100_Print(row.fwddecl, temp);
    PrintAttrSpaceReset(str,"fwddecl", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Gconst.namefldctyp.Get
algo::Smallstr100 dmmeta::namefldctyp_Get(dmmeta::Gconst& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.namefld, ".RL"));
    return ret;
}

// --- dmmeta.Gconst.namefldctyp.Get2
algo::Smallstr100 dmmeta::Gconst_namefldctyp_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Gconst..ReadFieldMaybe
bool dmmeta::Gconst_ReadFieldMaybe(dmmeta::Gconst& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_namefld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.namefld, strval);
            break;
        }
        case dmmeta_FieldId_idfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.idfld, strval);
            break;
        }
        case dmmeta_FieldId_wantenum: {
            retval = bool_ReadStrptrMaybe(parent.wantenum, strval);
            break;
        }
        case dmmeta_FieldId_namefldctyp: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gconst..ReadStrptrMaybe
// Read fields of dmmeta::Gconst from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gconst_ReadStrptrMaybe(dmmeta::Gconst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gconst") || algo::StripTypeTag(in_str, "dmmeta.Gconst");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gconst_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gconst..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Gconst.String  printfmt:Tuple
void dmmeta::Gconst_Print(dmmeta::Gconst& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.gconst";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.namefld, temp);
    PrintAttrSpaceReset(str,"namefld", temp);

    algo::Smallstr100_Print(row.idfld, temp);
    PrintAttrSpaceReset(str,"idfld", temp);

    bool_Print(row.wantenum, temp);
    PrintAttrSpaceReset(str,"wantenum", temp);
}

// --- dmmeta.Gstatic.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Gstatic& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Gstatic.ns.Get2
algo::Smallstr16 dmmeta::Gstatic_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Gstatic..ReadFieldMaybe
bool dmmeta::Gstatic_ReadFieldMaybe(dmmeta::Gstatic& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gstatic..ReadStrptrMaybe
// Read fields of dmmeta::Gstatic from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gstatic_ReadStrptrMaybe(dmmeta::Gstatic &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gstatic") || algo::StripTypeTag(in_str, "dmmeta.Gstatic");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gstatic_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gstatic..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Gstatic.String  printfmt:Tuple
void dmmeta::Gstatic_Print(dmmeta::Gstatic& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.gstatic";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Gsymbol.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Gsymbol& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.gsymbol, "/RL"));
    return ret;
}

// --- dmmeta.Gsymbol.ns.Get2
algo::Smallstr16 dmmeta::Gsymbol_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.Gsymbol.ssimfile.Get
algo::Smallstr50 dmmeta::ssimfile_Get(dmmeta::Gsymbol& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gsymbol, "/RR"));
    return ret;
}

// --- dmmeta.Gsymbol.ssimfile.Get2
algo::Smallstr50 dmmeta::Gsymbol_ssimfile_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Gsymbol..Concat_ns_ssimfile
tempstr dmmeta::Gsymbol_Concat_ns_ssimfile( const algo::strptr& ns ,const algo::strptr& ssimfile ) {
    return tempstr() << ns <<'/'<< ssimfile ;
}

// --- dmmeta.Gsymbol..ReadFieldMaybe
bool dmmeta::Gsymbol_ReadFieldMaybe(dmmeta::Gsymbol& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_gsymbol: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gsymbol, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ssimfile: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_inc: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.inc, strval);
            break;
        }
        case dmmeta_FieldId_symboltype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.symboltype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Gsymbol..ReadStrptrMaybe
// Read fields of dmmeta::Gsymbol from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Gsymbol_ReadStrptrMaybe(dmmeta::Gsymbol &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.gsymbol") || algo::StripTypeTag(in_str, "dmmeta.Gsymbol");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gsymbol_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Gsymbol..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Gsymbol.String  printfmt:Tuple
void dmmeta::Gsymbol_Print(dmmeta::Gsymbol& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.gsymbol";

    algo::Smallstr50_Print(row.gsymbol, temp);
    PrintAttrSpaceReset(str,"gsymbol", temp);

    algo::Smallstr100_Print(row.inc, temp);
    PrintAttrSpaceReset(str,"inc", temp);

    algo::Smallstr100_Print(row.symboltype, temp);
    PrintAttrSpaceReset(str,"symboltype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Hashtype..ReadFieldMaybe
bool dmmeta::Hashtype_ReadFieldMaybe(dmmeta::Hashtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_hashtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.hashtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Hashtype..ReadStrptrMaybe
// Read fields of dmmeta::Hashtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Hashtype_ReadStrptrMaybe(dmmeta::Hashtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.hashtype") || algo::StripTypeTag(in_str, "dmmeta.Hashtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hashtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Hashtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Hashtype.String  printfmt:Tuple
void dmmeta::Hashtype_Print(dmmeta::Hashtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.hashtype";

    algo::Smallstr50_Print(row.hashtype, temp);
    PrintAttrSpaceReset(str,"hashtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Hook..ReadFieldMaybe
bool dmmeta::Hook_ReadFieldMaybe(dmmeta::Hook& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Hook..ReadStrptrMaybe
// Read fields of dmmeta::Hook from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Hook_ReadStrptrMaybe(dmmeta::Hook &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.hook") || algo::StripTypeTag(in_str, "dmmeta.Hook");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Hook_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Hook..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Hook.String  printfmt:Tuple
void dmmeta::Hook_Print(dmmeta::Hook& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.hook";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Inlary..ReadFieldMaybe
bool dmmeta::Inlary_ReadFieldMaybe(dmmeta::Inlary& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_min: {
            retval = i32_ReadStrptrMaybe(parent.min, strval);
            break;
        }
        case dmmeta_FieldId_max: {
            retval = i32_ReadStrptrMaybe(parent.max, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Inlary..ReadStrptrMaybe
// Read fields of dmmeta::Inlary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Inlary_ReadStrptrMaybe(dmmeta::Inlary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.inlary") || algo::StripTypeTag(in_str, "dmmeta.Inlary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Inlary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Inlary..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Inlary.String  printfmt:Tuple
void dmmeta::Inlary_Print(dmmeta::Inlary& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.inlary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.min, temp);
    PrintAttrSpaceReset(str,"min", temp);

    i32_Print(row.max, temp);
    PrintAttrSpaceReset(str,"max", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Lenfld.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Lenfld& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Lenfld.ctype.Get2
algo::Smallstr100 dmmeta::Lenfld_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Lenfld..ReadFieldMaybe
bool dmmeta::Lenfld_ReadFieldMaybe(dmmeta::Lenfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_extra: {
            retval = i32_ReadStrptrMaybe(parent.extra, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Lenfld..ReadStrptrMaybe
// Read fields of dmmeta::Lenfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Lenfld_ReadStrptrMaybe(dmmeta::Lenfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.lenfld") || algo::StripTypeTag(in_str, "dmmeta.Lenfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Lenfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Lenfld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Lenfld.String  printfmt:Tuple
void dmmeta::Lenfld_Print(dmmeta::Lenfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.lenfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.extra, temp);
    PrintAttrSpaceReset(str,"extra", temp);
}

// --- dmmeta.Listtype..ReadFieldMaybe
bool dmmeta::Listtype_ReadFieldMaybe(dmmeta::Listtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_listtype: {
            retval = algo::Smallstr5_ReadStrptrMaybe(parent.listtype, strval);
            break;
        }
        case dmmeta_FieldId_circular: {
            retval = bool_ReadStrptrMaybe(parent.circular, strval);
            break;
        }
        case dmmeta_FieldId_haveprev: {
            retval = bool_ReadStrptrMaybe(parent.haveprev, strval);
            break;
        }
        case dmmeta_FieldId_instail: {
            retval = bool_ReadStrptrMaybe(parent.instail, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Listtype..ReadStrptrMaybe
// Read fields of dmmeta::Listtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Listtype_ReadStrptrMaybe(dmmeta::Listtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.listtype") || algo::StripTypeTag(in_str, "dmmeta.Listtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Listtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Listtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Listtype.String  printfmt:Tuple
void dmmeta::Listtype_Print(dmmeta::Listtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.listtype";

    algo::Smallstr5_Print(row.listtype, temp);
    PrintAttrSpaceReset(str,"listtype", temp);

    bool_Print(row.circular, temp);
    PrintAttrSpaceReset(str,"circular", temp);

    bool_Print(row.haveprev, temp);
    PrintAttrSpaceReset(str,"haveprev", temp);

    bool_Print(row.instail, temp);
    PrintAttrSpaceReset(str,"instail", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Llist.listtype.Get
algo::Smallstr5 dmmeta::listtype_Get(dmmeta::Llist& parent) {
    algo::Smallstr5 ret(algo::Pathcomp(parent.field, ".RR_LL"));
    return ret;
}

// --- dmmeta.Llist.listtype.Get2
algo::Smallstr5 dmmeta::Llist_listtype_Get(algo::strptr arg) {
    algo::Smallstr5 ret(algo::Pathcomp(arg, ".RR_LL"));
    return ret;
}

// --- dmmeta.Llist..ReadFieldMaybe
bool dmmeta::Llist_ReadFieldMaybe(dmmeta::Llist& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_havetail: {
            retval = bool_ReadStrptrMaybe(parent.havetail, strval);
            break;
        }
        case dmmeta_FieldId_havecount: {
            retval = bool_ReadStrptrMaybe(parent.havecount, strval);
            break;
        }
        case dmmeta_FieldId_listtype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Llist..ReadStrptrMaybe
// Read fields of dmmeta::Llist from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Llist_ReadStrptrMaybe(dmmeta::Llist &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.llist") || algo::StripTypeTag(in_str, "dmmeta.Llist");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Llist_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Llist..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Llist.String  printfmt:Tuple
void dmmeta::Llist_Print(dmmeta::Llist& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.llist";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.havetail, temp);
    PrintAttrSpaceReset(str,"havetail", temp);

    bool_Print(row.havecount, temp);
    PrintAttrSpaceReset(str,"havecount", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Logcat..ReadFieldMaybe
bool dmmeta::Logcat_ReadFieldMaybe(dmmeta::Logcat& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_logcat: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.logcat, strval);
            break;
        }
        case dmmeta_FieldId_enabled: {
            retval = bool_ReadStrptrMaybe(parent.enabled, strval);
            break;
        }
        case dmmeta_FieldId_builtin: {
            retval = bool_ReadStrptrMaybe(parent.builtin, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Logcat..ReadStrptrMaybe
// Read fields of dmmeta::Logcat from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Logcat_ReadStrptrMaybe(dmmeta::Logcat &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.logcat") || algo::StripTypeTag(in_str, "dmmeta.Logcat");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Logcat_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Logcat..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Logcat.String  printfmt:Tuple
void dmmeta::Logcat_Print(dmmeta::Logcat& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.logcat";

    algo::Smallstr50_Print(row.logcat, temp);
    PrintAttrSpaceReset(str,"logcat", temp);

    bool_Print(row.enabled, temp);
    PrintAttrSpaceReset(str,"enabled", temp);

    bool_Print(row.builtin, temp);
    PrintAttrSpaceReset(str,"builtin", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Main..ReadFieldMaybe
bool dmmeta::Main_ReadFieldMaybe(dmmeta::Main& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_ismodule: {
            retval = bool_ReadStrptrMaybe(parent.ismodule, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Main..ReadStrptrMaybe
// Read fields of dmmeta::Main from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Main_ReadStrptrMaybe(dmmeta::Main &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.main") || algo::StripTypeTag(in_str, "dmmeta.Main");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Main_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Main..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Main.String  printfmt:Tuple
void dmmeta::Main_Print(dmmeta::Main& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.main";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    bool_Print(row.ismodule, temp);
    PrintAttrSpaceReset(str,"ismodule", temp);
}

// --- dmmeta.Msgtype..ReadFieldMaybe
bool dmmeta::Msgtype_ReadFieldMaybe(dmmeta::Msgtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_type: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.type, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Msgtype..ReadStrptrMaybe
// Read fields of dmmeta::Msgtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Msgtype_ReadStrptrMaybe(dmmeta::Msgtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.msgtype") || algo::StripTypeTag(in_str, "dmmeta.Msgtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Msgtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Msgtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Msgtype.String  printfmt:Tuple
void dmmeta::Msgtype_Print(dmmeta::Msgtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.msgtype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::CppExpr_Print(row.type, temp);
    PrintAttrSpaceReset(str,"type", temp);
}

// --- dmmeta.Nocascdel..ReadFieldMaybe
bool dmmeta::Nocascdel_ReadFieldMaybe(dmmeta::Nocascdel& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_xref: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.xref, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nocascdel..ReadStrptrMaybe
// Read fields of dmmeta::Nocascdel from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nocascdel_ReadStrptrMaybe(dmmeta::Nocascdel &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nocascdel") || algo::StripTypeTag(in_str, "dmmeta.Nocascdel");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nocascdel_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nocascdel..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nocascdel.String  printfmt:Tuple
void dmmeta::Nocascdel_Print(dmmeta::Nocascdel& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nocascdel";

    algo::Smallstr100_Print(row.xref, temp);
    PrintAttrSpaceReset(str,"xref", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nossimfile..ReadFieldMaybe
bool dmmeta::Nossimfile_ReadFieldMaybe(dmmeta::Nossimfile& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nossimfile..ReadStrptrMaybe
// Read fields of dmmeta::Nossimfile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nossimfile_ReadStrptrMaybe(dmmeta::Nossimfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nossimfile") || algo::StripTypeTag(in_str, "dmmeta.Nossimfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nossimfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nossimfile..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nossimfile.String  printfmt:Tuple
void dmmeta::Nossimfile_Print(dmmeta::Nossimfile& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nossimfile";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Noxref..ReadFieldMaybe
bool dmmeta::Noxref_ReadFieldMaybe(dmmeta::Noxref& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Noxref..ReadStrptrMaybe
// Read fields of dmmeta::Noxref from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Noxref_ReadStrptrMaybe(dmmeta::Noxref &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.noxref") || algo::StripTypeTag(in_str, "dmmeta.Noxref");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Noxref_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Noxref..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Noxref.String  printfmt:Tuple
void dmmeta::Noxref_Print(dmmeta::Noxref& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.noxref";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ns..ReadFieldMaybe
bool dmmeta::Ns_ReadFieldMaybe(dmmeta::Ns& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_nstype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval);
            break;
        }
        case dmmeta_FieldId_license: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ns..ReadStrptrMaybe
// Read fields of dmmeta::Ns from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ns_ReadStrptrMaybe(dmmeta::Ns &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ns") || algo::StripTypeTag(in_str, "dmmeta.Ns");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ns_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ns..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ns.String  printfmt:Tuple
void dmmeta::Ns_Print(dmmeta::Ns& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ns";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Smallstr50_Print(row.nstype, temp);
    PrintAttrSpaceReset(str,"nstype", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nscpp..ReadFieldMaybe
bool dmmeta::Nscpp_ReadFieldMaybe(dmmeta::Nscpp& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nscpp..ReadStrptrMaybe
// Read fields of dmmeta::Nscpp from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nscpp_ReadStrptrMaybe(dmmeta::Nscpp &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nscpp") || algo::StripTypeTag(in_str, "dmmeta.Nscpp");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nscpp_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nscpp..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nscpp.String  printfmt:Tuple
void dmmeta::Nscpp_Print(dmmeta::Nscpp& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nscpp";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsdb..ReadFieldMaybe
bool dmmeta::Nsdb_ReadFieldMaybe(dmmeta::Nsdb& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsdb..ReadStrptrMaybe
// Read fields of dmmeta::Nsdb from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsdb_ReadStrptrMaybe(dmmeta::Nsdb &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsdb") || algo::StripTypeTag(in_str, "dmmeta.Nsdb");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsdb_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsdb..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsdb.String  printfmt:Tuple
void dmmeta::Nsdb_Print(dmmeta::Nsdb& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsdb";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsfast..ReadFieldMaybe
bool dmmeta::Nsfast_ReadFieldMaybe(dmmeta::Nsfast& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsfast..ReadStrptrMaybe
// Read fields of dmmeta::Nsfast from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsfast_ReadStrptrMaybe(dmmeta::Nsfast &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsfast") || algo::StripTypeTag(in_str, "dmmeta.Nsfast");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsfast_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsfast..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsfast.String  printfmt:Tuple
void dmmeta::Nsfast_Print(dmmeta::Nsfast& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsfast";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsinclude.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Nsinclude& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.nsinclude, "/LL"));
    return ret;
}

// --- dmmeta.Nsinclude.ns.Get2
algo::Smallstr16 dmmeta::Nsinclude_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Nsinclude.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Nsinclude& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.nsinclude, "/LR"));
    return ret;
}

// --- dmmeta.Nsinclude.name.Get2
algo::Smallstr50 dmmeta::Nsinclude_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dmmeta.Nsinclude..Concat_ns_name
tempstr dmmeta::Nsinclude_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'/'<< name ;
}

// --- dmmeta.Nsinclude..ReadFieldMaybe
bool dmmeta::Nsinclude_ReadFieldMaybe(dmmeta::Nsinclude& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_nsinclude: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.nsinclude, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_sys: {
            retval = bool_ReadStrptrMaybe(parent.sys, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsinclude..ReadStrptrMaybe
// Read fields of dmmeta::Nsinclude from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsinclude_ReadStrptrMaybe(dmmeta::Nsinclude &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsinclude") || algo::StripTypeTag(in_str, "dmmeta.Nsinclude");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsinclude_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsinclude..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsinclude.String  printfmt:Tuple
void dmmeta::Nsinclude_Print(dmmeta::Nsinclude& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsinclude";

    algo::Smallstr50_Print(row.nsinclude, temp);
    PrintAttrSpaceReset(str,"nsinclude", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsproto..ReadFieldMaybe
bool dmmeta::Nsproto_ReadFieldMaybe(dmmeta::Nsproto& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsproto..ReadStrptrMaybe
// Read fields of dmmeta::Nsproto from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsproto_ReadStrptrMaybe(dmmeta::Nsproto &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsproto") || algo::StripTypeTag(in_str, "dmmeta.Nsproto");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsproto_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsproto..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsproto.String  printfmt:Tuple
void dmmeta::Nsproto_Print(dmmeta::Nsproto& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsproto";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nstype..ReadFieldMaybe
bool dmmeta::Nstype_ReadFieldMaybe(dmmeta::Nstype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_nstype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nstype..ReadStrptrMaybe
// Read fields of dmmeta::Nstype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nstype_ReadStrptrMaybe(dmmeta::Nstype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nstype") || algo::StripTypeTag(in_str, "dmmeta.Nstype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nstype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nstype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nstype.String  printfmt:Tuple
void dmmeta::Nstype_Print(dmmeta::Nstype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nstype";

    algo::Smallstr50_Print(row.nstype, temp);
    PrintAttrSpaceReset(str,"nstype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsversion..ReadFieldMaybe
bool dmmeta::Nsversion_ReadFieldMaybe(dmmeta::Nsversion& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_version: {
            retval = algo::Smallstr10_ReadStrptrMaybe(parent.version, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsversion..ReadStrptrMaybe
// Read fields of dmmeta::Nsversion from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsversion_ReadStrptrMaybe(dmmeta::Nsversion &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsversion") || algo::StripTypeTag(in_str, "dmmeta.Nsversion");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsversion_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsversion..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsversion.String  printfmt:Tuple
void dmmeta::Nsversion_Print(dmmeta::Nsversion& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsversion";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Smallstr10_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Nsx..ReadFieldMaybe
bool dmmeta::Nsx_ReadFieldMaybe(dmmeta::Nsx& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ns: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.ns, strval);
            break;
        }
        case dmmeta_FieldId_genthrow: {
            retval = bool_ReadStrptrMaybe(parent.genthrow, strval);
            break;
        }
        case dmmeta_FieldId_correct_getorcreate: {
            retval = bool_ReadStrptrMaybe(parent.correct_getorcreate, strval);
            break;
        }
        case dmmeta_FieldId_pool: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.pool, strval);
            break;
        }
        case dmmeta_FieldId_sortxref: {
            retval = bool_ReadStrptrMaybe(parent.sortxref, strval);
            break;
        }
        case dmmeta_FieldId_pack: {
            retval = bool_ReadStrptrMaybe(parent.pack, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Nsx..ReadStrptrMaybe
// Read fields of dmmeta::Nsx from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Nsx_ReadStrptrMaybe(dmmeta::Nsx &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.nsx") || algo::StripTypeTag(in_str, "dmmeta.Nsx");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Nsx_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Nsx..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsx.String  printfmt:Tuple
void dmmeta::Nsx_Print(dmmeta::Nsx& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.nsx";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    bool_Print(row.genthrow, temp);
    PrintAttrSpaceReset(str,"genthrow", temp);

    bool_Print(row.correct_getorcreate, temp);
    PrintAttrSpaceReset(str,"correct_getorcreate", temp);

    algo::Smallstr100_Print(row.pool, temp);
    PrintAttrSpaceReset(str,"pool", temp);

    bool_Print(row.sortxref, temp);
    PrintAttrSpaceReset(str,"sortxref", temp);

    bool_Print(row.pack, temp);
    PrintAttrSpaceReset(str,"pack", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Numstr..ReadFieldMaybe
bool dmmeta::Numstr_ReadFieldMaybe(dmmeta::Numstr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_numtype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.numtype, strval);
            break;
        }
        case dmmeta_FieldId_base: {
            retval = i32_ReadStrptrMaybe(parent.base, strval);
            break;
        }
        case dmmeta_FieldId_min_len: {
            retval = i32_ReadStrptrMaybe(parent.min_len, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Numstr..ReadStrptrMaybe
// Read fields of dmmeta::Numstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Numstr_ReadStrptrMaybe(dmmeta::Numstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.numstr") || algo::StripTypeTag(in_str, "dmmeta.Numstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Numstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Numstr..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Numstr.String  printfmt:Tuple
void dmmeta::Numstr_Print(dmmeta::Numstr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.numstr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.numtype, temp);
    PrintAttrSpaceReset(str,"numtype", temp);

    i32_Print(row.base, temp);
    PrintAttrSpaceReset(str,"base", temp);

    i32_Print(row.min_len, temp);
    PrintAttrSpaceReset(str,"min_len", temp);
}

// --- dmmeta.Pack..ReadFieldMaybe
bool dmmeta::Pack_ReadFieldMaybe(dmmeta::Pack& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pack..ReadStrptrMaybe
// Read fields of dmmeta::Pack from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pack_ReadStrptrMaybe(dmmeta::Pack &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pack") || algo::StripTypeTag(in_str, "dmmeta.Pack");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pack_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pack..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Pack.String  printfmt:Tuple
void dmmeta::Pack_Print(dmmeta::Pack& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.pack";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Pmaskfld.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Pmaskfld& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Pmaskfld.ctype.Get2
algo::Smallstr100 dmmeta::Pmaskfld_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Pmaskfld..ReadFieldMaybe
bool dmmeta::Pmaskfld_ReadFieldMaybe(dmmeta::Pmaskfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_filter_print: {
            retval = bool_ReadStrptrMaybe(parent.filter_print, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pmaskfld..ReadStrptrMaybe
// Read fields of dmmeta::Pmaskfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pmaskfld_ReadStrptrMaybe(dmmeta::Pmaskfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pmaskfld") || algo::StripTypeTag(in_str, "dmmeta.Pmaskfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pmaskfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pmaskfld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Pmaskfld.String  printfmt:Tuple
void dmmeta::Pmaskfld_Print(dmmeta::Pmaskfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.pmaskfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.filter_print, temp);
    PrintAttrSpaceReset(str,"filter_print", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.PmaskfldMember.pmaskfld.Get
algo::Smallstr100 dmmeta::pmaskfld_Get(dmmeta::PmaskfldMember& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.pmaskfld_member, "/RL"));
    return ret;
}

// --- dmmeta.PmaskfldMember.pmaskfld.Get2
algo::Smallstr100 dmmeta::PmaskfldMember_pmaskfld_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- dmmeta.PmaskfldMember.field.Get
algo::Smallstr100 dmmeta::field_Get(dmmeta::PmaskfldMember& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.pmaskfld_member, "/RR"));
    return ret;
}

// --- dmmeta.PmaskfldMember.field.Get2
algo::Smallstr100 dmmeta::PmaskfldMember_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.PmaskfldMember..Concat_pmaskfld_field
tempstr dmmeta::PmaskfldMember_Concat_pmaskfld_field( const algo::strptr& pmaskfld ,const algo::strptr& field ) {
    return tempstr() << pmaskfld <<'/'<< field ;
}

// --- dmmeta.PmaskfldMember..ReadFieldMaybe
bool dmmeta::PmaskfldMember_ReadFieldMaybe(dmmeta::PmaskfldMember& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_pmaskfld_member: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.pmaskfld_member, strval);
            break;
        }
        case dmmeta_FieldId_pmaskfld: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.PmaskfldMember..ReadStrptrMaybe
// Read fields of dmmeta::PmaskfldMember from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::PmaskfldMember_ReadStrptrMaybe(dmmeta::PmaskfldMember &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pmaskfld_member") || algo::StripTypeTag(in_str, "dmmeta.PmaskfldMember");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PmaskfldMember_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.PmaskfldMember..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.PmaskfldMember.String  printfmt:Tuple
void dmmeta::PmaskfldMember_Print(dmmeta::PmaskfldMember& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.pmaskfld_member";

    algo::Smallstr100_Print(row.pmaskfld_member, temp);
    PrintAttrSpaceReset(str,"pmaskfld_member", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Pnew.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Pnew& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.pnew, "/LL"));
    return ret;
}

// --- dmmeta.Pnew.ns.Get2
algo::Smallstr16 dmmeta::Pnew_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Pnew.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Pnew& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.pnew, "/LR.RL"));
    return ret;
}

// --- dmmeta.Pnew.ctype.Get2
algo::Smallstr100 dmmeta::Pnew_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR.RL"));
    return ret;
}

// --- dmmeta.Pnew.buftype.Get
algo::Smallstr50 dmmeta::buftype_Get(dmmeta::Pnew& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.pnew, "/LR.RR"));
    return ret;
}

// --- dmmeta.Pnew.buftype.Get2
algo::Smallstr50 dmmeta::Pnew_buftype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR.RR"));
    return ret;
}

// --- dmmeta.Pnew..Concat_ns_ctype_buftype
tempstr dmmeta::Pnew_Concat_ns_ctype_buftype( const algo::strptr& ns ,const algo::strptr& ctype ,const algo::strptr& buftype ) {
    return tempstr() << ns <<'/'<< ctype <<'.'<< buftype ;
}

// --- dmmeta.Pnew..ReadFieldMaybe
bool dmmeta::Pnew_ReadFieldMaybe(dmmeta::Pnew& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_pnew: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.pnew, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_buftype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Pnew..ReadStrptrMaybe
// Read fields of dmmeta::Pnew from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Pnew_ReadStrptrMaybe(dmmeta::Pnew &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.pnew") || algo::StripTypeTag(in_str, "dmmeta.Pnew");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Pnew_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Pnew..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Pnew.String  printfmt:Tuple
void dmmeta::Pnew_Print(dmmeta::Pnew& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.pnew";

    algo::Smallstr100_Print(row.pnew, temp);
    PrintAttrSpaceReset(str,"pnew", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Printfmt..ReadFieldMaybe
bool dmmeta::Printfmt_ReadFieldMaybe(dmmeta::Printfmt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_printfmt: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.printfmt, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Printfmt..ReadStrptrMaybe
// Read fields of dmmeta::Printfmt from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Printfmt_ReadStrptrMaybe(dmmeta::Printfmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.printfmt") || algo::StripTypeTag(in_str, "dmmeta.Printfmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Printfmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Printfmt..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Printfmt.String  printfmt:Tuple
void dmmeta::Printfmt_Print(dmmeta::Printfmt& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.printfmt";

    algo::Smallstr50_Print(row.printfmt, temp);
    PrintAttrSpaceReset(str,"printfmt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ptrary..ReadFieldMaybe
bool dmmeta::Ptrary_ReadFieldMaybe(dmmeta::Ptrary& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_unique: {
            retval = bool_ReadStrptrMaybe(parent.unique, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ptrary..ReadStrptrMaybe
// Read fields of dmmeta::Ptrary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ptrary_ReadStrptrMaybe(dmmeta::Ptrary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ptrary") || algo::StripTypeTag(in_str, "dmmeta.Ptrary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ptrary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ptrary..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ptrary.String  printfmt:Tuple
void dmmeta::Ptrary_Print(dmmeta::Ptrary& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ptrary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.unique, temp);
    PrintAttrSpaceReset(str,"unique", temp);
}

// --- dmmeta.Reftype..ReadFieldMaybe
bool dmmeta::Reftype_ReadFieldMaybe(dmmeta::Reftype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_reftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval);
            break;
        }
        case dmmeta_FieldId_isval: {
            retval = bool_ReadStrptrMaybe(parent.isval, strval);
            break;
        }
        case dmmeta_FieldId_cascins: {
            retval = bool_ReadStrptrMaybe(parent.cascins, strval);
            break;
        }
        case dmmeta_FieldId_usebasepool: {
            retval = bool_ReadStrptrMaybe(parent.usebasepool, strval);
            break;
        }
        case dmmeta_FieldId_cancopy: {
            retval = bool_ReadStrptrMaybe(parent.cancopy, strval);
            break;
        }
        case dmmeta_FieldId_isxref: {
            retval = bool_ReadStrptrMaybe(parent.isxref, strval);
            break;
        }
        case dmmeta_FieldId_del: {
            retval = bool_ReadStrptrMaybe(parent.del, strval);
            break;
        }
        case dmmeta_FieldId_up: {
            retval = bool_ReadStrptrMaybe(parent.up, strval);
            break;
        }
        case dmmeta_FieldId_isnew: {
            retval = bool_ReadStrptrMaybe(parent.isnew, strval);
            break;
        }
        case dmmeta_FieldId_hasalloc: {
            retval = bool_ReadStrptrMaybe(parent.hasalloc, strval);
            break;
        }
        case dmmeta_FieldId_inst: {
            retval = bool_ReadStrptrMaybe(parent.inst, strval);
            break;
        }
        case dmmeta_FieldId_varlen: {
            retval = bool_ReadStrptrMaybe(parent.varlen, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Reftype..ReadStrptrMaybe
// Read fields of dmmeta::Reftype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Reftype_ReadStrptrMaybe(dmmeta::Reftype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.reftype") || algo::StripTypeTag(in_str, "dmmeta.Reftype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Reftype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Reftype..Init
// Set all fields to initial values.
void dmmeta::Reftype_Init(dmmeta::Reftype& parent) {
    parent.reftype = algo::strptr("Val");
    parent.isval = bool(false);
    parent.cascins = bool(false);
    parent.usebasepool = bool(false);
    parent.cancopy = bool(false);
    parent.isxref = bool(false);
    parent.del = bool(false);
    parent.up = bool(false);
    parent.isnew = bool(false);
    parent.hasalloc = bool(false);
    parent.inst = bool(false);
    parent.varlen = bool(false);
}

// --- dmmeta.Reftype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Reftype.String  printfmt:Tuple
void dmmeta::Reftype_Print(dmmeta::Reftype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.reftype";

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    bool_Print(row.isval, temp);
    PrintAttrSpaceReset(str,"isval", temp);

    bool_Print(row.cascins, temp);
    PrintAttrSpaceReset(str,"cascins", temp);

    bool_Print(row.usebasepool, temp);
    PrintAttrSpaceReset(str,"usebasepool", temp);

    bool_Print(row.cancopy, temp);
    PrintAttrSpaceReset(str,"cancopy", temp);

    bool_Print(row.isxref, temp);
    PrintAttrSpaceReset(str,"isxref", temp);

    bool_Print(row.del, temp);
    PrintAttrSpaceReset(str,"del", temp);

    bool_Print(row.up, temp);
    PrintAttrSpaceReset(str,"up", temp);

    bool_Print(row.isnew, temp);
    PrintAttrSpaceReset(str,"isnew", temp);

    bool_Print(row.hasalloc, temp);
    PrintAttrSpaceReset(str,"hasalloc", temp);

    bool_Print(row.inst, temp);
    PrintAttrSpaceReset(str,"inst", temp);

    bool_Print(row.varlen, temp);
    PrintAttrSpaceReset(str,"varlen", temp);
}

// --- dmmeta.ReftypeCase.reftype.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dmmeta::reftype_ToCstr(const dmmeta::ReftypeCase& parent) {
    const char *ret = NULL;
    switch(reftype_GetEnum(parent)) {
        case dmmeta_ReftypeCase_Alias      : ret = "Alias";  break;
        case dmmeta_ReftypeCase_Atree      : ret = "Atree";  break;
        case dmmeta_ReftypeCase_Base       : ret = "Base";  break;
        case dmmeta_ReftypeCase_Bheap      : ret = "Bheap";  break;
        case dmmeta_ReftypeCase_Bitfld     : ret = "Bitfld";  break;
        case dmmeta_ReftypeCase_Blkpool    : ret = "Blkpool";  break;
        case dmmeta_ReftypeCase_Charset    : ret = "Charset";  break;
        case dmmeta_ReftypeCase_Count      : ret = "Count";  break;
        case dmmeta_ReftypeCase_Cppstack   : ret = "Cppstack";  break;
        case dmmeta_ReftypeCase_Delptr     : ret = "Delptr";  break;
        case dmmeta_ReftypeCase_Exec       : ret = "Exec";  break;
        case dmmeta_ReftypeCase_Fbuf       : ret = "Fbuf";  break;
        case dmmeta_ReftypeCase_Global     : ret = "Global";  break;
        case dmmeta_ReftypeCase_Hook       : ret = "Hook";  break;
        case dmmeta_ReftypeCase_Inlary     : ret = "Inlary";  break;
        case dmmeta_ReftypeCase_Lary       : ret = "Lary";  break;
        case dmmeta_ReftypeCase_Llist      : ret = "Llist";  break;
        case dmmeta_ReftypeCase_Lpool      : ret = "Lpool";  break;
        case dmmeta_ReftypeCase_Malloc     : ret = "Malloc";  break;
        case dmmeta_ReftypeCase_Opt        : ret = "Opt";  break;
        case dmmeta_ReftypeCase_Pkey       : ret = "Pkey";  break;
        case dmmeta_ReftypeCase_Protocol   : ret = "Protocol";  break;
        case dmmeta_ReftypeCase_Ptr        : ret = "Ptr";  break;
        case dmmeta_ReftypeCase_Ptrary     : ret = "Ptrary";  break;
        case dmmeta_ReftypeCase_Regx       : ret = "Regx";  break;
        case dmmeta_ReftypeCase_RegxSql    : ret = "RegxSql";  break;
        case dmmeta_ReftypeCase_Sbrk       : ret = "Sbrk";  break;
        case dmmeta_ReftypeCase_Smallstr   : ret = "Smallstr";  break;
        case dmmeta_ReftypeCase_Tary       : ret = "Tary";  break;
        case dmmeta_ReftypeCase_Thash      : ret = "Thash";  break;
        case dmmeta_ReftypeCase_Tpool      : ret = "Tpool";  break;
        case dmmeta_ReftypeCase_Upptr      : ret = "Upptr";  break;
        case dmmeta_ReftypeCase_Val        : ret = "Val";  break;
        case dmmeta_ReftypeCase_Varlen     : ret = "Varlen";  break;
        case dmmeta_ReftypeCase_ZSListMT   : ret = "ZSListMT";  break;
    }
    return ret;
}

// --- dmmeta.ReftypeCase.reftype.Print
// Convert reftype to a string. First, attempt conversion to a known string.
// If no string matches, print reftype as a numeric value.
void dmmeta::reftype_Print(const dmmeta::ReftypeCase& parent, algo::cstring &lhs) {
    const char *strval = reftype_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.reftype;
    }
}

// --- dmmeta.ReftypeCase.reftype.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dmmeta::reftype_SetStrptrMaybe(dmmeta::ReftypeCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('O','p','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Opt); ret = true; break;
                }
                case LE_STR3('P','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Ptr); ret = true; break;
                }
                case LE_STR3('V','a','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Val); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('B','a','s','e'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Base); ret = true; break;
                }
                case LE_STR4('E','x','e','c'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Exec); ret = true; break;
                }
                case LE_STR4('F','b','u','f'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Fbuf); ret = true; break;
                }
                case LE_STR4('H','o','o','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Hook); ret = true; break;
                }
                case LE_STR4('L','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Lary); ret = true; break;
                }
                case LE_STR4('P','k','e','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Pkey); ret = true; break;
                }
                case LE_STR4('R','e','g','x'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Regx); ret = true; break;
                }
                case LE_STR4('S','b','r','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Sbrk); ret = true; break;
                }
                case LE_STR4('T','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Tary); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('A','l','i','a','s'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Alias); ret = true; break;
                }
                case LE_STR5('A','t','r','e','e'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Atree); ret = true; break;
                }
                case LE_STR5('B','h','e','a','p'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Bheap); ret = true; break;
                }
                case LE_STR5('C','o','u','n','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Count); ret = true; break;
                }
                case LE_STR5('L','l','i','s','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Llist); ret = true; break;
                }
                case LE_STR5('L','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Lpool); ret = true; break;
                }
                case LE_STR5('T','h','a','s','h'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Thash); ret = true; break;
                }
                case LE_STR5('T','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Tpool); ret = true; break;
                }
                case LE_STR5('U','p','p','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Upptr); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('B','i','t','f','l','d'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Bitfld); ret = true; break;
                }
                case LE_STR6('D','e','l','p','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Delptr); ret = true; break;
                }
                case LE_STR6('G','l','o','b','a','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Global); ret = true; break;
                }
                case LE_STR6('I','n','l','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Inlary); ret = true; break;
                }
                case LE_STR6('M','a','l','l','o','c'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Malloc); ret = true; break;
                }
                case LE_STR6('P','t','r','a','r','y'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Ptrary); ret = true; break;
                }
                case LE_STR6('V','a','r','l','e','n'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Varlen); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('B','l','k','p','o','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Blkpool); ret = true; break;
                }
                case LE_STR7('C','h','a','r','s','e','t'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Charset); ret = true; break;
                }
                case LE_STR7('R','e','g','x','S','q','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_RegxSql); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('C','p','p','s','t','a','c','k'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Cppstack); ret = true; break;
                }
                case LE_STR8('P','r','o','t','o','c','o','l'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Protocol); ret = true; break;
                }
                case LE_STR8('S','m','a','l','l','s','t','r'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_Smallstr); ret = true; break;
                }
                case LE_STR8('Z','S','L','i','s','t','M','T'): {
                    reftype_SetEnum(parent,dmmeta_ReftypeCase_ZSListMT); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dmmeta.ReftypeCase.reftype.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dmmeta::reftype_SetStrptr(dmmeta::ReftypeCase& parent, algo::strptr rhs, dmmeta_ReftypeCaseEnum dflt) {
    if (!reftype_SetStrptrMaybe(parent,rhs)) reftype_SetEnum(parent,dflt);
}

// --- dmmeta.Rowid..ReadFieldMaybe
bool dmmeta::Rowid_ReadFieldMaybe(dmmeta::Rowid& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Rowid..ReadStrptrMaybe
// Read fields of dmmeta::Rowid from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Rowid_ReadStrptrMaybe(dmmeta::Rowid &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.rowid") || algo::StripTypeTag(in_str, "dmmeta.Rowid");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Rowid_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Rowid..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Rowid.String  printfmt:Tuple
void dmmeta::Rowid_Print(dmmeta::Rowid& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.rowid";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Smallstr.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Smallstr& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Smallstr.ctype.Get2
algo::Smallstr100 dmmeta::Smallstr_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Smallstr..ReadFieldMaybe
bool dmmeta::Smallstr_ReadFieldMaybe(dmmeta::Smallstr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_length: {
            retval = i32_ReadStrptrMaybe(parent.length, strval);
            break;
        }
        case dmmeta_FieldId_strtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.strtype, strval);
            break;
        }
        case dmmeta_FieldId_pad: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.pad, strval);
            break;
        }
        case dmmeta_FieldId_strict: {
            retval = bool_ReadStrptrMaybe(parent.strict, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Smallstr..ReadStrptrMaybe
// Read fields of dmmeta::Smallstr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Smallstr_ReadStrptrMaybe(dmmeta::Smallstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.smallstr") || algo::StripTypeTag(in_str, "dmmeta.Smallstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Smallstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Smallstr..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Smallstr.String  printfmt:Tuple
void dmmeta::Smallstr_Print(dmmeta::Smallstr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.smallstr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    i32_Print(row.length, temp);
    PrintAttrSpaceReset(str,"length", temp);

    algo::Smallstr50_Print(row.strtype, temp);
    PrintAttrSpaceReset(str,"strtype", temp);

    algo::CppExpr_Print(row.pad, temp);
    PrintAttrSpaceReset(str,"pad", temp);

    bool_Print(row.strict, temp);
    PrintAttrSpaceReset(str,"strict", temp);
}

// --- dmmeta.Sortfld..ReadFieldMaybe
bool dmmeta::Sortfld_ReadFieldMaybe(dmmeta::Sortfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_sortfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sortfld..ReadStrptrMaybe
// Read fields of dmmeta::Sortfld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sortfld_ReadStrptrMaybe(dmmeta::Sortfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sortfld") || algo::StripTypeTag(in_str, "dmmeta.Sortfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sortfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sortfld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Sortfld.String  printfmt:Tuple
void dmmeta::Sortfld_Print(dmmeta::Sortfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.sortfld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);
}

// --- dmmeta.Sorttype..ReadFieldMaybe
bool dmmeta::Sorttype_ReadFieldMaybe(dmmeta::Sorttype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_sorttype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.sorttype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sorttype..ReadStrptrMaybe
// Read fields of dmmeta::Sorttype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sorttype_ReadStrptrMaybe(dmmeta::Sorttype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sorttype") || algo::StripTypeTag(in_str, "dmmeta.Sorttype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sorttype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sorttype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Sorttype.String  printfmt:Tuple
void dmmeta::Sorttype_Print(dmmeta::Sorttype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.sorttype";

    algo::Smallstr50_Print(row.sorttype, temp);
    PrintAttrSpaceReset(str,"sorttype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Sqltype..ReadFieldMaybe
bool dmmeta::Sqltype_ReadFieldMaybe(dmmeta::Sqltype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_expr: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Sqltype..ReadStrptrMaybe
// Read fields of dmmeta::Sqltype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Sqltype_ReadStrptrMaybe(dmmeta::Sqltype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.sqltype") || algo::StripTypeTag(in_str, "dmmeta.Sqltype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sqltype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Sqltype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Sqltype.String  printfmt:Tuple
void dmmeta::Sqltype_Print(dmmeta::Sqltype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.sqltype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimfile.ssimns.Get
algo::Smallstr16 dmmeta::ssimns_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ssimfile, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ssimns.Get2
algo::Smallstr16 dmmeta::Ssimfile_ssimns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.ssimfile, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.ns.Get2
algo::Smallstr16 dmmeta::Ssimfile_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Ssimfile.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Ssimfile& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ssimfile, ".RR"));
    return ret;
}

// --- dmmeta.Ssimfile.name.Get2
algo::Smallstr50 dmmeta::Ssimfile_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Ssimfile..ReadFieldMaybe
bool dmmeta::Ssimfile_ReadFieldMaybe(dmmeta::Ssimfile& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval);
            break;
        }
        case dmmeta_FieldId_ssimns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimfile..ReadStrptrMaybe
// Read fields of dmmeta::Ssimfile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimfile_ReadStrptrMaybe(dmmeta::Ssimfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimfile") || algo::StripTypeTag(in_str, "dmmeta.Ssimfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimfile..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimfile.String  printfmt:Tuple
void dmmeta::Ssimfile_Print(dmmeta::Ssimfile& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ssimfile";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);
}

// --- dmmeta.Ssimreq.parent_field.Get
algo::Smallstr100 dmmeta::parent_field_Get(dmmeta::Ssimreq& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.parent, ":LL"));
    return ret;
}

// --- dmmeta.Ssimreq.parent_field.Get2
algo::Smallstr100 dmmeta::Ssimreq_parent_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dmmeta.Ssimreq.parent_ctype.Get
algo::Smallstr100 dmmeta::parent_ctype_Get(dmmeta::Ssimreq& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.parent, ":LL.RL"));
    return ret;
}

// --- dmmeta.Ssimreq.parent_ctype.Get2
algo::Smallstr100 dmmeta::Ssimreq_parent_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ":LL.RL"));
    return ret;
}

// --- dmmeta.Ssimreq.value.Get
algo::Smallstr100 dmmeta::value_Get(dmmeta::Ssimreq& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.parent, ":LR"));
    return ret;
}

// --- dmmeta.Ssimreq.value.Get2
algo::Smallstr100 dmmeta::Ssimreq_value_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dmmeta.Ssimreq.child_ssimfile.Get
algo::Smallstr50 dmmeta::child_ssimfile_Get(dmmeta::Ssimreq& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.ssimreq, ":LL"));
    return ret;
}

// --- dmmeta.Ssimreq.child_ssimfile.Get2
algo::Smallstr50 dmmeta::Ssimreq_child_ssimfile_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dmmeta.Ssimreq.child_key.Get
algo::Smallstr100 dmmeta::child_key_Get(dmmeta::Ssimreq& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.ssimreq, ":RR"));
    return ret;
}

// --- dmmeta.Ssimreq.child_key.Get2
algo::Smallstr100 dmmeta::Ssimreq_child_key_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ":RR"));
    return ret;
}

// --- dmmeta.Ssimreq..Concat_parent_field_value
tempstr dmmeta::Ssimreq_Concat_parent_field_value( const algo::strptr& parent_field ,const algo::strptr& value ) {
    return tempstr() << parent_field <<':'<< value ;
}

// --- dmmeta.Ssimreq..ReadFieldMaybe
bool dmmeta::Ssimreq_ReadFieldMaybe(dmmeta::Ssimreq& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ssimreq: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ssimreq, strval);
            break;
        }
        case dmmeta_FieldId_parent: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.parent, strval);
            break;
        }
        case dmmeta_FieldId_parent_field: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_parent_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_value: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_child_ssimfile: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_child_key: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_reqchild: {
            retval = bool_ReadStrptrMaybe(parent.reqchild, strval);
            break;
        }
        case dmmeta_FieldId_bidir: {
            retval = bool_ReadStrptrMaybe(parent.bidir, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimreq..ReadStrptrMaybe
// Read fields of dmmeta::Ssimreq from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimreq_ReadStrptrMaybe(dmmeta::Ssimreq &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimreq") || algo::StripTypeTag(in_str, "dmmeta.Ssimreq");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimreq_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimreq..Init
// Set all fields to initial values.
void dmmeta::Ssimreq_Init(dmmeta::Ssimreq& parent) {
    parent.reqchild = bool(false);
    parent.bidir = bool(false);
}

// --- dmmeta.Ssimreq..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimreq.String  printfmt:Tuple
void dmmeta::Ssimreq_Print(dmmeta::Ssimreq& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ssimreq";

    algo::Smallstr100_Print(row.ssimreq, temp);
    PrintAttrSpaceReset(str,"ssimreq", temp);

    algo::Smallstr100_Print(row.parent, temp);
    PrintAttrSpaceReset(str,"parent", temp);

    bool_Print(row.reqchild, temp);
    PrintAttrSpaceReset(str,"reqchild", temp);

    bool_Print(row.bidir, temp);
    PrintAttrSpaceReset(str,"bidir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimsort..ReadFieldMaybe
bool dmmeta::Ssimsort_ReadFieldMaybe(dmmeta::Ssimsort& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval);
            break;
        }
        case dmmeta_FieldId_sortfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimsort..ReadStrptrMaybe
// Read fields of dmmeta::Ssimsort from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimsort_ReadStrptrMaybe(dmmeta::Ssimsort &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimsort") || algo::StripTypeTag(in_str, "dmmeta.Ssimsort");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimsort_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimsort..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimsort.String  printfmt:Tuple
void dmmeta::Ssimsort_Print(dmmeta::Ssimsort& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ssimsort";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr100_Print(row.sortfld, temp);
    PrintAttrSpaceReset(str,"sortfld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Ssimvolatile..ReadFieldMaybe
bool dmmeta::Ssimvolatile_ReadFieldMaybe(dmmeta::Ssimvolatile& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ssimfile: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Ssimvolatile..ReadStrptrMaybe
// Read fields of dmmeta::Ssimvolatile from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Ssimvolatile_ReadStrptrMaybe(dmmeta::Ssimvolatile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.ssimvolatile") || algo::StripTypeTag(in_str, "dmmeta.Ssimvolatile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ssimvolatile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Ssimvolatile..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimvolatile.String  printfmt:Tuple
void dmmeta::Ssimvolatile_Print(dmmeta::Ssimvolatile& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.ssimvolatile";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Steptype..ReadFieldMaybe
bool dmmeta::Steptype_ReadFieldMaybe(dmmeta::Steptype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_steptype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.steptype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Steptype..ReadStrptrMaybe
// Read fields of dmmeta::Steptype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Steptype_ReadStrptrMaybe(dmmeta::Steptype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.steptype") || algo::StripTypeTag(in_str, "dmmeta.Steptype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Steptype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Steptype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Steptype.String  printfmt:Tuple
void dmmeta::Steptype_Print(dmmeta::Steptype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.steptype";

    algo::Smallstr50_Print(row.steptype, temp);
    PrintAttrSpaceReset(str,"steptype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Strtype..ReadFieldMaybe
bool dmmeta::Strtype_ReadFieldMaybe(dmmeta::Strtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_strtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.strtype, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Strtype..ReadStrptrMaybe
// Read fields of dmmeta::Strtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Strtype_ReadStrptrMaybe(dmmeta::Strtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.strtype") || algo::StripTypeTag(in_str, "dmmeta.Strtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Strtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Strtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Strtype.String  printfmt:Tuple
void dmmeta::Strtype_Print(dmmeta::Strtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.strtype";

    algo::Smallstr50_Print(row.strtype, temp);
    PrintAttrSpaceReset(str,"strtype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Substr..ReadFieldMaybe
bool dmmeta::Substr_ReadFieldMaybe(dmmeta::Substr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_expr: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case dmmeta_FieldId_srcfield: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Substr..ReadStrptrMaybe
// Read fields of dmmeta::Substr from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Substr_ReadStrptrMaybe(dmmeta::Substr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.substr") || algo::StripTypeTag(in_str, "dmmeta.Substr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Substr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Substr..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Substr.String  printfmt:Tuple
void dmmeta::Substr_Print(dmmeta::Substr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.substr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);
}

// --- dmmeta.Svtype..ReadFieldMaybe
bool dmmeta::Svtype_ReadFieldMaybe(dmmeta::Svtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case dmmeta_FieldId_maxwid: {
            retval = i32_ReadStrptrMaybe(parent.maxwid, strval);
            break;
        }
        case dmmeta_FieldId_fixedwid1: {
            retval = i32_ReadStrptrMaybe(parent.fixedwid1, strval);
            break;
        }
        case dmmeta_FieldId_fixedwid2: {
            retval = i32_ReadStrptrMaybe(parent.fixedwid2, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Svtype..ReadStrptrMaybe
// Read fields of dmmeta::Svtype from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Svtype_ReadStrptrMaybe(dmmeta::Svtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.svtype") || algo::StripTypeTag(in_str, "dmmeta.Svtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Svtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Svtype..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Svtype.String  printfmt:Tuple
void dmmeta::Svtype_Print(dmmeta::Svtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.svtype";

    algo::Smallstr100_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    i32_Print(row.maxwid, temp);
    PrintAttrSpaceReset(str,"maxwid", temp);

    i32_Print(row.fixedwid1, temp);
    PrintAttrSpaceReset(str,"fixedwid1", temp);

    i32_Print(row.fixedwid2, temp);
    PrintAttrSpaceReset(str,"fixedwid2", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tary..ReadFieldMaybe
bool dmmeta::Tary_ReadFieldMaybe(dmmeta::Tary& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_aliased: {
            retval = bool_ReadStrptrMaybe(parent.aliased, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tary..ReadStrptrMaybe
// Read fields of dmmeta::Tary from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tary_ReadStrptrMaybe(dmmeta::Tary &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tary") || algo::StripTypeTag(in_str, "dmmeta.Tary");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tary_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tary..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Tary.String  printfmt:Tuple
void dmmeta::Tary_Print(dmmeta::Tary& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.tary";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    bool_Print(row.aliased, temp);
    PrintAttrSpaceReset(str,"aliased", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Thash..ReadFieldMaybe
bool dmmeta::Thash_ReadFieldMaybe(dmmeta::Thash& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_hashfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.hashfld, strval);
            break;
        }
        case dmmeta_FieldId_unique: {
            retval = bool_ReadStrptrMaybe(parent.unique, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Thash..ReadStrptrMaybe
// Read fields of dmmeta::Thash from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Thash_ReadStrptrMaybe(dmmeta::Thash &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.thash") || algo::StripTypeTag(in_str, "dmmeta.Thash");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Thash_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Thash..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Thash.String  printfmt:Tuple
void dmmeta::Thash_Print(dmmeta::Thash& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.thash";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr100_Print(row.hashfld, temp);
    PrintAttrSpaceReset(str,"hashfld", temp);

    bool_Print(row.unique, temp);
    PrintAttrSpaceReset(str,"unique", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tracefld.tracerec.Get
algo::Smallstr50 dmmeta::tracerec_Get(dmmeta::Tracefld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracefld, ".RL"));
    return ret;
}

// --- dmmeta.Tracefld.tracerec.Get2
algo::Smallstr50 dmmeta::Tracefld_tracerec_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Tracefld.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Tracefld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracefld, ".RR"));
    return ret;
}

// --- dmmeta.Tracefld.name.Get2
algo::Smallstr50 dmmeta::Tracefld_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Tracefld..Concat_tracerec_name
tempstr dmmeta::Tracefld_Concat_tracerec_name( const algo::strptr& tracerec ,const algo::strptr& name ) {
    return tempstr() << tracerec <<'.'<< name ;
}

// --- dmmeta.Tracefld..ReadFieldMaybe
bool dmmeta::Tracefld_ReadFieldMaybe(dmmeta::Tracefld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_tracefld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.tracefld, strval);
            break;
        }
        case dmmeta_FieldId_tracerec: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tracefld..ReadStrptrMaybe
// Read fields of dmmeta::Tracefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tracefld_ReadStrptrMaybe(dmmeta::Tracefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tracefld") || algo::StripTypeTag(in_str, "dmmeta.Tracefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tracefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tracefld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Tracefld.String  printfmt:Tuple
void dmmeta::Tracefld_Print(dmmeta::Tracefld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.tracefld";

    algo::Smallstr100_Print(row.tracefld, temp);
    PrintAttrSpaceReset(str,"tracefld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Tracerec.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Tracerec& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tracerec, ".LR"));
    return ret;
}

// --- dmmeta.Tracerec.name.Get2
algo::Smallstr50 dmmeta::Tracerec_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- dmmeta.Tracerec.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Tracerec& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.tracerec, ".LL"));
    return ret;
}

// --- dmmeta.Tracerec.ns.Get2
algo::Smallstr16 dmmeta::Tracerec_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Tracerec..Concat_ns_name
tempstr dmmeta::Tracerec_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name ) {
    return tempstr() << ns <<'.'<< name ;
}

// --- dmmeta.Tracerec..ReadFieldMaybe
bool dmmeta::Tracerec_ReadFieldMaybe(dmmeta::Tracerec& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_tracerec: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.tracerec, strval);
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Tracerec..ReadStrptrMaybe
// Read fields of dmmeta::Tracerec from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Tracerec_ReadStrptrMaybe(dmmeta::Tracerec &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.tracerec") || algo::StripTypeTag(in_str, "dmmeta.Tracerec");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Tracerec_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Tracerec..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Tracerec.String  printfmt:Tuple
void dmmeta::Tracerec_Print(dmmeta::Tracerec& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.tracerec";

    algo::Smallstr50_Print(row.tracerec, temp);
    PrintAttrSpaceReset(str,"tracerec", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Typefld.ctype.Get
algo::Smallstr100 dmmeta::ctype_Get(dmmeta::Typefld& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.field, ".RL"));
    return ret;
}

// --- dmmeta.Typefld.ctype.Get2
algo::Smallstr100 dmmeta::Typefld_ctype_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dmmeta.Typefld..ReadFieldMaybe
bool dmmeta::Typefld_ReadFieldMaybe(dmmeta::Typefld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_ctype: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Typefld..ReadStrptrMaybe
// Read fields of dmmeta::Typefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Typefld_ReadStrptrMaybe(dmmeta::Typefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.typefld") || algo::StripTypeTag(in_str, "dmmeta.Typefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Typefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Typefld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Typefld.String  printfmt:Tuple
void dmmeta::Typefld_Print(dmmeta::Typefld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.typefld";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Usertracefld..ReadFieldMaybe
bool dmmeta::Usertracefld_ReadFieldMaybe(dmmeta::Usertracefld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_tracefld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.tracefld, strval);
            break;
        }
        case dmmeta_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Usertracefld..ReadStrptrMaybe
// Read fields of dmmeta::Usertracefld from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Usertracefld_ReadStrptrMaybe(dmmeta::Usertracefld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.usertracefld") || algo::StripTypeTag(in_str, "dmmeta.Usertracefld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Usertracefld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Usertracefld..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Usertracefld.String  printfmt:Tuple
void dmmeta::Usertracefld_Print(dmmeta::Usertracefld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.usertracefld";

    algo::Smallstr100_Print(row.tracefld, temp);
    PrintAttrSpaceReset(str,"tracefld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dmmeta.Xref.name.Get
algo::Smallstr50 dmmeta::name_Get(dmmeta::Xref& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.field, ".RR"));
    return ret;
}

// --- dmmeta.Xref.name.Get2
algo::Smallstr50 dmmeta::Xref_name_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dmmeta.Xref.ns.Get
algo::Smallstr16 dmmeta::ns_Get(dmmeta::Xref& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.field, ".LL"));
    return ret;
}

// --- dmmeta.Xref.ns.Get2
algo::Smallstr16 dmmeta::Xref_ns_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dmmeta.Xref.viafld.Get
algo::Smallstr100 dmmeta::viafld_Get(dmmeta::Xref& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.via, "/LL"));
    return ret;
}

// --- dmmeta.Xref.viafld.Get2
algo::Smallstr100 dmmeta::Xref_viafld_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dmmeta.Xref.keyfld.Get
algo::Smallstr100 dmmeta::keyfld_Get(dmmeta::Xref& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.via, "/RR"));
    return ret;
}

// --- dmmeta.Xref.keyfld.Get2
algo::Smallstr100 dmmeta::Xref_keyfld_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- dmmeta.Xref..ReadFieldMaybe
bool dmmeta::Xref_ReadFieldMaybe(dmmeta::Xref& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    dmmeta::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case dmmeta_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case dmmeta_FieldId_name: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_inscond: {
            retval = algo::CppExpr_ReadStrptrMaybe(parent.inscond, strval);
            break;
        }
        case dmmeta_FieldId_ns: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_via: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.via, strval);
            break;
        }
        case dmmeta_FieldId_viafld: {
            retval = false;
            break;
        }
        case dmmeta_FieldId_keyfld: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dmmeta.Xref..ReadStrptrMaybe
// Read fields of dmmeta::Xref from an ascii string.
// The format of the string is an ssim Tuple
bool dmmeta::Xref_ReadStrptrMaybe(dmmeta::Xref &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dmmeta.xref") || algo::StripTypeTag(in_str, "dmmeta.Xref");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Xref_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dmmeta.Xref..Print
// print string representation of ROW to string STR
// cfmt:dmmeta.Xref.String  printfmt:Tuple
void dmmeta::Xref_Print(dmmeta::Xref& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "dmmeta.xref";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::CppExpr_Print(row.inscond, temp);
    PrintAttrSpaceReset(str,"inscond", temp);

    algo::Smallstr200_Print(row.via, temp);
    PrintAttrSpaceReset(str,"via", temp);
}

// --- dmmeta...SizeCheck
inline static void dmmeta::SizeCheck() {
}
