//
// cpp/gen/httpdb_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/httpdb_gen.h"
#include "include/gen/httpdb_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace httpdb { // gen:ns_print_proto
    // func:httpdb...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- httpdb.Content..ReadFieldMaybe
bool httpdb::Content_ReadFieldMaybe(httpdb::Content& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    httpdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case httpdb_FieldId_content: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.content, strval);
        } break;
        case httpdb_FieldId_description: {
            retval = algo::cstring_ReadStrptrMaybe(parent.description, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- httpdb.Content..ReadStrptrMaybe
// Read fields of httpdb::Content from an ascii string.
// The format of the string is an ssim Tuple
bool httpdb::Content_ReadStrptrMaybe(httpdb::Content &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "httpdb.content") || algo::StripTypeTag(in_str, "httpdb.Content");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Content_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- httpdb.Content..Print
// print string representation of ROW to string STR
// cfmt:httpdb.Content.String  printfmt:Tuple
void httpdb::Content_Print(httpdb::Content& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "httpdb.content";

    algo::Smallstr250_Print(row.content, temp);
    PrintAttrSpaceReset(str,"content", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);
}

// --- httpdb.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* httpdb::value_ToCstr(const httpdb::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case httpdb_FieldId_content        : ret = "content";  break;
        case httpdb_FieldId_description    : ret = "description";  break;
        case httpdb_FieldId_header         : ret = "header";  break;
        case httpdb_FieldId_comment        : ret = "comment";  break;
        case httpdb_FieldId_method         : ret = "method";  break;
        case httpdb_FieldId_id             : ret = "id";  break;
        case httpdb_FieldId_status         : ret = "status";  break;
        case httpdb_FieldId_code           : ret = "code";  break;
        case httpdb_FieldId_reason         : ret = "reason";  break;
        case httpdb_FieldId_version        : ret = "version";  break;
        case httpdb_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- httpdb.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void httpdb::value_Print(const httpdb::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- httpdb.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool httpdb::value_SetStrptrMaybe(httpdb::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('i','d'): {
                    value_SetEnum(parent,httpdb_FieldId_id); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,httpdb_FieldId_code); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,httpdb_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('h','e','a','d','e','r'): {
                    value_SetEnum(parent,httpdb_FieldId_header); ret = true; break;
                }
                case LE_STR6('m','e','t','h','o','d'): {
                    value_SetEnum(parent,httpdb_FieldId_method); ret = true; break;
                }
                case LE_STR6('r','e','a','s','o','n'): {
                    value_SetEnum(parent,httpdb_FieldId_reason); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,httpdb_FieldId_status); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,httpdb_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','n','t','e','n','t'): {
                    value_SetEnum(parent,httpdb_FieldId_content); ret = true; break;
                }
                case LE_STR7('v','e','r','s','i','o','n'): {
                    value_SetEnum(parent,httpdb_FieldId_version); ret = true; break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','s','c','r','i','p','t'): {
                    if (memcmp(rhs.elems+8,"ion",3)==0) { value_SetEnum(parent,httpdb_FieldId_description); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- httpdb.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void httpdb::value_SetStrptr(httpdb::FieldId& parent, algo::strptr rhs, httpdb_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- httpdb.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool httpdb::value_ReadStrptrMaybe(httpdb::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- httpdb.FieldId..ReadStrptrMaybe
// Read fields of httpdb::FieldId from an ascii string.
// The format of the string is the format of the httpdb::FieldId's only field
bool httpdb::FieldId_ReadStrptrMaybe(httpdb::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- httpdb.FieldId..Print
// print string representation of ROW to string STR
// cfmt:httpdb.FieldId.String  printfmt:Raw
void httpdb::FieldId_Print(httpdb::FieldId& row, algo::cstring& str) {
    httpdb::value_Print(row, str);
}

// --- httpdb.Header..ReadFieldMaybe
bool httpdb::Header_ReadFieldMaybe(httpdb::Header& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    httpdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case httpdb_FieldId_header: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.header, strval);
        } break;
        case httpdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- httpdb.Header..ReadStrptrMaybe
// Read fields of httpdb::Header from an ascii string.
// The format of the string is an ssim Tuple
bool httpdb::Header_ReadStrptrMaybe(httpdb::Header &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "httpdb.header") || algo::StripTypeTag(in_str, "httpdb.Header");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Header_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- httpdb.Header..Print
// print string representation of ROW to string STR
// cfmt:httpdb.Header.String  printfmt:Tuple
void httpdb::Header_Print(httpdb::Header& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "httpdb.header";

    algo::Smallstr50_Print(row.header, temp);
    PrintAttrSpaceReset(str,"header", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- httpdb.Method..ReadFieldMaybe
bool httpdb::Method_ReadFieldMaybe(httpdb::Method& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    httpdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case httpdb_FieldId_method: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.method, strval);
        } break;
        case httpdb_FieldId_id: {
            retval = u8_ReadStrptrMaybe(parent.id, strval);
        } break;
        case httpdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- httpdb.Method..ReadStrptrMaybe
// Read fields of httpdb::Method from an ascii string.
// The format of the string is an ssim Tuple
bool httpdb::Method_ReadStrptrMaybe(httpdb::Method &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "httpdb.method") || algo::StripTypeTag(in_str, "httpdb.Method");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Method_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- httpdb.Method..Print
// print string representation of ROW to string STR
// cfmt:httpdb.Method.String  printfmt:Tuple
void httpdb::Method_Print(httpdb::Method& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "httpdb.method";

    algo::Smallstr50_Print(row.method, temp);
    PrintAttrSpaceReset(str,"method", temp);

    u8_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- httpdb.Status.code.Get
u16 httpdb::code_Get(httpdb::Status& parent) {
    u16 ret;
    ret = 0; // default value
    (void)u16_ReadStrptrMaybe(ret, algo::Pathcomp(parent.status, " LL"));
    return ret;
}

// --- httpdb.Status.code.Get2
u16 httpdb::Status_code_Get(algo::strptr arg) {
    u16 ret;
    ret = 0; // default value
    (void)u16_ReadStrptrMaybe(ret, algo::Pathcomp(arg, " LL"));
    return ret;
}

// --- httpdb.Status.reason.Get
algo::Smallstr50 httpdb::reason_Get(httpdb::Status& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.status, " LR"));
    return ret;
}

// --- httpdb.Status.reason.Get2
algo::Smallstr50 httpdb::Status_reason_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, " LR"));
    return ret;
}

// --- httpdb.Status..Concat_code_reason
tempstr httpdb::Status_Concat_code_reason( u16 code ,const algo::strptr& reason ) {
    return tempstr() << code <<' '<< reason ;
}

// --- httpdb.Status..ReadFieldMaybe
bool httpdb::Status_ReadFieldMaybe(httpdb::Status& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    httpdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case httpdb_FieldId_status: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.status, strval);
        } break;
        case httpdb_FieldId_code: {
            retval = false;
        } break;
        case httpdb_FieldId_reason: {
            retval = false;
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- httpdb.Status..ReadStrptrMaybe
// Read fields of httpdb::Status from an ascii string.
// The format of the string is an ssim Tuple
bool httpdb::Status_ReadStrptrMaybe(httpdb::Status &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "httpdb.status") || algo::StripTypeTag(in_str, "httpdb.Status");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Status_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- httpdb.Status..Print
// print string representation of ROW to string STR
// cfmt:httpdb.Status.String  printfmt:Tuple
void httpdb::Status_Print(httpdb::Status& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "httpdb.status";

    algo::Smallstr50_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);
}

// --- httpdb.Version..ReadFieldMaybe
bool httpdb::Version_ReadFieldMaybe(httpdb::Version& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    httpdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case httpdb_FieldId_version: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.version, strval);
        } break;
        case httpdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- httpdb.Version..ReadStrptrMaybe
// Read fields of httpdb::Version from an ascii string.
// The format of the string is an ssim Tuple
bool httpdb::Version_ReadStrptrMaybe(httpdb::Version &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "httpdb.version") || algo::StripTypeTag(in_str, "httpdb.Version");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Version_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- httpdb.Version..Print
// print string representation of ROW to string STR
// cfmt:httpdb.Version.String  printfmt:Tuple
void httpdb::Version_Print(httpdb::Version& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "httpdb.version";

    algo::Smallstr50_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- httpdb...SizeCheck
inline static void httpdb::SizeCheck() {
}
