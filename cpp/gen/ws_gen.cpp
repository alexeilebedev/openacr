//
// cpp/gen/ws_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/ws_gen.h"
#include "include/gen/ws_gen.inl.h"
#include "include/gen/ams_gen.h"
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace ws { // gen:ns_print_proto
    // func:ws.Frame.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame16.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.Frame64.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked16.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.fin.ReadStrptrMaybe
    inline static bool   fin_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.rsv1.ReadStrptrMaybe
    inline static bool   rsv1_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.rsv2.ReadStrptrMaybe
    inline static bool   rsv2_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.rsv3.ReadStrptrMaybe
    inline static bool   rsv3_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.opcode.ReadStrptrMaybe
    inline static bool   opcode_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.mask.ReadStrptrMaybe
    inline static bool   mask_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws.FrameMasked64.payload_len.ReadStrptrMaybe
    inline static bool   payload_len_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ws...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- ws.Side.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::Side& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_Side_server                : ret = "server";  break;
        case ws_Side_client                : ret = "client";  break;
    }
    return ret;
}

// --- ws.Side.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::Side& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.Side.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::Side& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('c','l','i','e','n','t'): {
                    value_SetEnum(parent,ws_Side_client); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,ws_Side_server); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.Side.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::Side& parent, algo::strptr rhs, ws_SideEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.Side.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::Side& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = char_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.Side..ReadStrptrMaybe
// Read fields of ws::Side from an ascii string.
// The format of the string is the format of the ws::Side's only field
bool ws::Side_ReadStrptrMaybe(ws::Side &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.Side..Print
// print string representation of ROW to string STR
// cfmt:ws.Side.String  printfmt:Raw
void ws::Side_Print(ws::Side row, algo::cstring& str) {
    ws::value_Print(row, str);
}

// --- ws.StatusCode.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::StatusCode& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_StatusCode_Normal_closure  : ret = "Normal closure";  break;
        case ws_StatusCode_Going_away      : ret = "Going away";  break;
        case ws_StatusCode_Protocol_error  : ret = "Protocol error";  break;
        case ws_StatusCode_Unsupported_message_data_type: ret = "Unsupported message data type";  break;
        case ws_StatusCode_No_status_code  : ret = "No status code";  break;
        case ws_StatusCode_Abnormal_closure: ret = "Abnormal closure";  break;
        case ws_StatusCode_Invalid_message_data: ret = "Invalid message data";  break;
        case ws_StatusCode_Policy_violation: ret = "Policy violation";  break;
        case ws_StatusCode_Message_too_big : ret = "Message too big";  break;
        case ws_StatusCode_Missing_extension: ret = "Missing extension";  break;
        case ws_StatusCode_Internal_error  : ret = "Internal error";  break;
        case ws_StatusCode_TLS_Handshake   : ret = "TLS Handshake";  break;
    }
    return ret;
}

// --- ws.StatusCode.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::StatusCode& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.StatusCode.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::StatusCode& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('G','o','i','n','g',' ','a','w'): {
                    if (memcmp(rhs.elems+8,"ay",2)==0) { value_SetEnum(parent,ws_StatusCode_Going_away); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('T','L','S',' ','H','a','n','d'): {
                    if (memcmp(rhs.elems+8,"shake",5)==0) { value_SetEnum(parent,ws_StatusCode_TLS_Handshake); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('I','n','t','e','r','n','a','l'): {
                    if (memcmp(rhs.elems+8," error",6)==0) { value_SetEnum(parent,ws_StatusCode_Internal_error); ret = true; break; }
                    break;
                }
                case LE_STR8('N','o',' ','s','t','a','t','u'): {
                    if (memcmp(rhs.elems+8,"s code",6)==0) { value_SetEnum(parent,ws_StatusCode_No_status_code); ret = true; break; }
                    break;
                }
                case LE_STR8('N','o','r','m','a','l',' ','c'): {
                    if (memcmp(rhs.elems+8,"losure",6)==0) { value_SetEnum(parent,ws_StatusCode_Normal_closure); ret = true; break; }
                    break;
                }
                case LE_STR8('P','r','o','t','o','c','o','l'): {
                    if (memcmp(rhs.elems+8," error",6)==0) { value_SetEnum(parent,ws_StatusCode_Protocol_error); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('M','e','s','s','a','g','e',' '): {
                    if (memcmp(rhs.elems+8,"too big",7)==0) { value_SetEnum(parent,ws_StatusCode_Message_too_big); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('A','b','n','o','r','m','a','l'): {
                    if (memcmp(rhs.elems+8," closure",8)==0) { value_SetEnum(parent,ws_StatusCode_Abnormal_closure); ret = true; break; }
                    break;
                }
                case LE_STR8('P','o','l','i','c','y',' ','v'): {
                    if (memcmp(rhs.elems+8,"iolation",8)==0) { value_SetEnum(parent,ws_StatusCode_Policy_violation); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('M','i','s','s','i','n','g',' '): {
                    if (memcmp(rhs.elems+8,"extension",9)==0) { value_SetEnum(parent,ws_StatusCode_Missing_extension); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 20: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('I','n','v','a','l','i','d',' '): {
                    if (memcmp(rhs.elems+8,"message data",12)==0) { value_SetEnum(parent,ws_StatusCode_Invalid_message_data); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 29: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('U','n','s','u','p','p','o','r'): {
                    if (memcmp(rhs.elems+8,"ted message data type",21)==0) { value_SetEnum(parent,ws_StatusCode_Unsupported_message_data_type); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.StatusCode.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::StatusCode& parent, algo::strptr rhs, ws_StatusCodeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.StatusCode.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::StatusCode& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u16_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.StatusCode..ReadStrptrMaybe
// Read fields of ws::StatusCode from an ascii string.
// The format of the string is the format of the ws::StatusCode's only field
bool ws::StatusCode_ReadStrptrMaybe(ws::StatusCode &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.StatusCode..Print
// print string representation of ROW to string STR
// cfmt:ws.StatusCode.String  printfmt:Raw
void ws::StatusCode_Print(ws::StatusCode row, algo::cstring& str) {
    ws::value_Print(row, str);
}

// --- ws.CloseMsg.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::CloseMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ws.CloseMsg.reason.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::reason_Getary(ws::CloseMsg& parent) {
    return algo::aryptr<char>(reason_Addr(parent), reason_N(parent));
}

// --- ws.CloseMsg.reason.Addr
char* ws::reason_Addr(ws::CloseMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ws::CloseMsg)); // address of varlen portion
}

// --- ws.CloseMsg.reason.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::reason_ReadStrptrMaybe(ws::CloseMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.CloseMsg.reason.Print
// Convert reason to a string.
// Array is printed as a regular string.
void ws::reason_Print(ws::CloseMsg& parent, algo::cstring &rhs) {
    rhs << reason_Getary(parent);
}

// --- ws.CloseMsg..ReadFieldMaybe
bool ws::CloseMsg_ReadFieldMaybe(ws::CloseMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_type: {
            retval = false;
        } break;
        case ws_FieldId_length: {
            retval = false;
        } break;
        case ws_FieldId_conn: {
            retval = algo::RspaceStr50_ReadStrptrMaybe(parent.conn, strval);
        } break;
        case ws_FieldId_side: {
            retval = ws::Side_ReadStrptrMaybe(parent.side, strval);
        } break;
        case ws_FieldId_code: {
            retval = ws::StatusCode_ReadStrptrMaybe(parent.code, strval);
        } break;
        case ws_FieldId_reason: {
            retval = reason_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.CloseMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::CloseMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ws::CloseMsg_ReadStrptrMaybe(ws::CloseMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.CloseMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && CloseMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.CloseMsg..Print
// print string representation of ROW to string STR
// cfmt:ws.CloseMsg.String  printfmt:Tuple
void ws::CloseMsg_Print(ws::CloseMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.CloseMsg";

    algo::RspaceStr50_Print(row.conn, temp);
    PrintAttrSpaceReset(str,"conn", temp);

    ws::Side_Print(row.side, temp);
    PrintAttrSpaceReset(str,"side", temp);

    ws::StatusCode_Print(row.code, temp);
    PrintAttrSpaceReset(str,"code", temp);

    ws::reason_Print(row, temp);
    PrintAttrSpaceReset(str,"reason", temp);
}

// --- ws.ConnectMsg.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::ConnectMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ws.ConnectMsg..ReadFieldMaybe
bool ws::ConnectMsg_ReadFieldMaybe(ws::ConnectMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_type: {
            retval = false;
        } break;
        case ws_FieldId_length: {
            retval = false;
        } break;
        case ws_FieldId_conn: {
            retval = algo::RspaceStr50_ReadStrptrMaybe(parent.conn, strval);
        } break;
        case ws_FieldId_side: {
            retval = ws::Side_ReadStrptrMaybe(parent.side, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.ConnectMsg..ReadStrptrMaybe
// Read fields of ws::ConnectMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ws::ConnectMsg_ReadStrptrMaybe(ws::ConnectMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.ConnectMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ConnectMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.ConnectMsg..Print
// print string representation of ROW to string STR
// cfmt:ws.ConnectMsg.String  printfmt:Tuple
void ws::ConnectMsg_Print(ws::ConnectMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.ConnectMsg";

    algo::RspaceStr50_Print(row.conn, temp);
    PrintAttrSpaceReset(str,"conn", temp);

    ws::Side_Print(row.side, temp);
    PrintAttrSpaceReset(str,"side", temp);
}

// --- ws.Opcode.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::Opcode& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_Opcode_cont                : ret = "cont";  break;
        case ws_Opcode_text                : ret = "text";  break;
        case ws_Opcode_binary              : ret = "binary";  break;
        case ws_Opcode_close               : ret = "close";  break;
        case ws_Opcode_ping                : ret = "ping";  break;
        case ws_Opcode_pong                : ret = "pong";  break;
    }
    return ret;
}

// --- ws.Opcode.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::Opcode& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.Opcode.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::Opcode& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('c','o','n','t'): {
                    value_SetEnum(parent,ws_Opcode_cont); ret = true; break;
                }
                case LE_STR4('p','i','n','g'): {
                    value_SetEnum(parent,ws_Opcode_ping); ret = true; break;
                }
                case LE_STR4('p','o','n','g'): {
                    value_SetEnum(parent,ws_Opcode_pong); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,ws_Opcode_text); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('c','l','o','s','e'): {
                    value_SetEnum(parent,ws_Opcode_close); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('b','i','n','a','r','y'): {
                    value_SetEnum(parent,ws_Opcode_binary); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.Opcode.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::Opcode& parent, algo::strptr rhs, ws_OpcodeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.Opcode.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::Opcode& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.Opcode..ReadStrptrMaybe
// Read fields of ws::Opcode from an ascii string.
// The format of the string is the format of the ws::Opcode's only field
bool ws::Opcode_ReadStrptrMaybe(ws::Opcode &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.Opcode..Print
// print string representation of ROW to string STR
// cfmt:ws.Opcode.String  printfmt:Raw
void ws::Opcode_Print(ws::Opcode row, algo::cstring& str) {
    ws::value_Print(row, str);
}

// --- ws.DataMsg.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::DataMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ws.DataMsg.data.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::data_Getary(ws::DataMsg& parent) {
    return algo::aryptr<char>(data_Addr(parent), data_N(parent));
}

// --- ws.DataMsg.data.Addr
char* ws::data_Addr(ws::DataMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ws::DataMsg)); // address of varlen portion
}

// --- ws.DataMsg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::data_ReadStrptrMaybe(ws::DataMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.DataMsg.data.Print
// Convert data to a string.
// Array is printed as a regular string.
void ws::data_Print(ws::DataMsg& parent, algo::cstring &rhs) {
    rhs << data_Getary(parent);
}

// --- ws.DataMsg..ReadFieldMaybe
bool ws::DataMsg_ReadFieldMaybe(ws::DataMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_type: {
            retval = false;
        } break;
        case ws_FieldId_length: {
            retval = false;
        } break;
        case ws_FieldId_conn: {
            retval = algo::RspaceStr50_ReadStrptrMaybe(parent.conn, strval);
        } break;
        case ws_FieldId_side: {
            retval = ws::Side_ReadStrptrMaybe(parent.side, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = ws::Opcode_ReadStrptrMaybe(parent.opcode, strval);
        } break;
        case ws_FieldId_data: {
            retval = data_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.DataMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::DataMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ws::DataMsg_ReadStrptrMaybe(ws::DataMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.DataMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DataMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.DataMsg..Print
// print string representation of ROW to string STR
// cfmt:ws.DataMsg.String  printfmt:Tuple
void ws::DataMsg_Print(ws::DataMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.DataMsg";

    algo::RspaceStr50_Print(row.conn, temp);
    PrintAttrSpaceReset(str,"conn", temp);

    ws::Side_Print(row.side, temp);
    PrintAttrSpaceReset(str,"side", temp);

    ws::Opcode_Print(row.opcode, temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    ws::data_Print(row, temp);
    PrintAttrSpaceReset(str,"data", temp);
}

// --- ws.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_FieldId_base               : ret = "base";  break;
        case ws_FieldId_type               : ret = "type";  break;
        case ws_FieldId_length             : ret = "length";  break;
        case ws_FieldId_conn               : ret = "conn";  break;
        case ws_FieldId_side               : ret = "side";  break;
        case ws_FieldId_code               : ret = "code";  break;
        case ws_FieldId_reason             : ret = "reason";  break;
        case ws_FieldId_opcode             : ret = "opcode";  break;
        case ws_FieldId_data               : ret = "data";  break;
        case ws_FieldId_byte0              : ret = "byte0";  break;
        case ws_FieldId_byte1              : ret = "byte1";  break;
        case ws_FieldId_fin                : ret = "fin";  break;
        case ws_FieldId_rsv1               : ret = "rsv1";  break;
        case ws_FieldId_rsv2               : ret = "rsv2";  break;
        case ws_FieldId_rsv3               : ret = "rsv3";  break;
        case ws_FieldId_mask               : ret = "mask";  break;
        case ws_FieldId_payload_len        : ret = "payload_len";  break;
        case ws_FieldId_payload            : ret = "payload";  break;
        case ws_FieldId_ext_payload_len    : ret = "ext_payload_len";  break;
        case ws_FieldId_masking_key        : ret = "masking_key";  break;
        case ws_FieldId_value              : ret = "value";  break;
        case ws_FieldId_server             : ret = "server";  break;
    }
    return ret;
}

// --- ws.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('f','i','n'): {
                    value_SetEnum(parent,ws_FieldId_fin); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,ws_FieldId_base); ret = true; break;
                }
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,ws_FieldId_code); ret = true; break;
                }
                case LE_STR4('c','o','n','n'): {
                    value_SetEnum(parent,ws_FieldId_conn); ret = true; break;
                }
                case LE_STR4('d','a','t','a'): {
                    value_SetEnum(parent,ws_FieldId_data); ret = true; break;
                }
                case LE_STR4('m','a','s','k'): {
                    value_SetEnum(parent,ws_FieldId_mask); ret = true; break;
                }
                case LE_STR4('r','s','v','1'): {
                    value_SetEnum(parent,ws_FieldId_rsv1); ret = true; break;
                }
                case LE_STR4('r','s','v','2'): {
                    value_SetEnum(parent,ws_FieldId_rsv2); ret = true; break;
                }
                case LE_STR4('r','s','v','3'): {
                    value_SetEnum(parent,ws_FieldId_rsv3); ret = true; break;
                }
                case LE_STR4('s','i','d','e'): {
                    value_SetEnum(parent,ws_FieldId_side); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,ws_FieldId_type); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('b','y','t','e','0'): {
                    value_SetEnum(parent,ws_FieldId_byte0); ret = true; break;
                }
                case LE_STR5('b','y','t','e','1'): {
                    value_SetEnum(parent,ws_FieldId_byte1); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,ws_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,ws_FieldId_length); ret = true; break;
                }
                case LE_STR6('o','p','c','o','d','e'): {
                    value_SetEnum(parent,ws_FieldId_opcode); ret = true; break;
                }
                case LE_STR6('r','e','a','s','o','n'): {
                    value_SetEnum(parent,ws_FieldId_reason); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,ws_FieldId_server); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('p','a','y','l','o','a','d'): {
                    value_SetEnum(parent,ws_FieldId_payload); ret = true; break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('m','a','s','k','i','n','g','_'): {
                    if (memcmp(rhs.elems+8,"key",3)==0) { value_SetEnum(parent,ws_FieldId_masking_key); ret = true; break; }
                    break;
                }
                case LE_STR8('p','a','y','l','o','a','d','_'): {
                    if (memcmp(rhs.elems+8,"len",3)==0) { value_SetEnum(parent,ws_FieldId_payload_len); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('e','x','t','_','p','a','y','l'): {
                    if (memcmp(rhs.elems+8,"oad_len",7)==0) { value_SetEnum(parent,ws_FieldId_ext_payload_len); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::FieldId& parent, algo::strptr rhs, ws_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.FieldId..ReadStrptrMaybe
// Read fields of ws::FieldId from an ascii string.
// The format of the string is the format of the ws::FieldId's only field
bool ws::FieldId_ReadStrptrMaybe(ws::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.FieldId..Print
// print string representation of ROW to string STR
// cfmt:ws.FieldId.String  printfmt:Raw
void ws::FieldId_Print(ws::FieldId& row, algo::cstring& str) {
    ws::value_Print(row, str);
}

// --- ws.Frame.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::Frame &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.Frame.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.Frame.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.Frame.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.Frame.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.Frame.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.Frame.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.Frame.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.Frame.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::Frame& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.Frame.payload.Addr
char* ws::payload_Addr(ws::Frame& parent) {
    return (char*)((u8*)&parent + sizeof(ws::Frame)); // address of varlen portion
}

// --- ws.Frame.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::Frame& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.Frame.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::Frame& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.Frame..ReadFieldMaybe
bool ws::Frame_ReadFieldMaybe(ws::Frame& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.Frame..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::Frame from an ascii string.
// The format of the string is an ssim Tuple
bool ws::Frame_ReadStrptrMaybe(ws::Frame &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.Frame");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Frame_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.Frame..Init
// Set all fields to initial values.
void ws::Frame_Init(ws::Frame& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(0);
}

// --- ws.Frame..Print
// print string representation of ROW to string STR
// cfmt:ws.Frame.String  printfmt:Tuple
void ws::Frame_Print(ws::Frame& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.Frame";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.Frame16.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::Frame16 &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.Frame16.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.Frame16.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.Frame16.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.Frame16.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.Frame16.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.Frame16.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.Frame16.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.Frame16.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::Frame16& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.Frame16.payload.Addr
char* ws::payload_Addr(ws::Frame16& parent) {
    return (char*)((u8*)&parent + sizeof(ws::Frame16)); // address of varlen portion
}

// --- ws.Frame16.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::Frame16& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.Frame16.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::Frame16& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.Frame16..ReadFieldMaybe
bool ws::Frame16_ReadFieldMaybe(ws::Frame16& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_ext_payload_len: {
            retval = false;
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.Frame16..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::Frame16 from an ascii string.
// The format of the string is an ssim Tuple
bool ws::Frame16_ReadStrptrMaybe(ws::Frame16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.Frame16");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Frame16_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.Frame16..Init
// Set all fields to initial values.
void ws::Frame16_Init(ws::Frame16& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(126);
    parent.ext_payload_len_be = htobe16(ssizeof(parent) + (-4)); // write big-endian value to memory
}

// --- ws.Frame16..Print
// print string representation of ROW to string STR
// cfmt:ws.Frame16.String  printfmt:Tuple
void ws::Frame16_Print(ws::Frame16& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.Frame16";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.Frame64.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::Frame64 &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.Frame64.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.Frame64.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.Frame64.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.Frame64.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.Frame64.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.Frame64.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.Frame64.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.Frame64.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::Frame64& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.Frame64.payload.Addr
char* ws::payload_Addr(ws::Frame64& parent) {
    return (char*)((u8*)&parent + sizeof(ws::Frame64)); // address of varlen portion
}

// --- ws.Frame64.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::Frame64& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.Frame64.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::Frame64& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.Frame64..ReadFieldMaybe
bool ws::Frame64_ReadFieldMaybe(ws::Frame64& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_ext_payload_len: {
            retval = false;
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.Frame64..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::Frame64 from an ascii string.
// The format of the string is an ssim Tuple
bool ws::Frame64_ReadStrptrMaybe(ws::Frame64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.Frame64");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Frame64_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.Frame64..Init
// Set all fields to initial values.
void ws::Frame64_Init(ws::Frame64& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(127);
    parent.ext_payload_len_be = htobe64(ssizeof(parent) + (-10)); // write big-endian value to memory
}

// --- ws.Frame64..Print
// print string representation of ROW to string STR
// cfmt:ws.Frame64.String  printfmt:Tuple
void ws::Frame64_Print(ws::Frame64& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.Frame64";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.FrameHeaderMsgsCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::FrameHeaderMsgsCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_FrameHeaderMsgsCase_ws_Frame16: ret = "ws.Frame16";  break;
        case ws_FrameHeaderMsgsCase_ws_Frame64: ret = "ws.Frame64";  break;
        case ws_FrameHeaderMsgsCase_ws_FrameMasked16: ret = "ws.FrameMasked16";  break;
        case ws_FrameHeaderMsgsCase_ws_FrameMasked64: ret = "ws.FrameMasked64";  break;
    }
    return ret;
}

// --- ws.FrameHeaderMsgsCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::FrameHeaderMsgsCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.FrameHeaderMsgsCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::FrameHeaderMsgsCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('w','s','.','F','r','a','m','e'): {
                    if (memcmp(rhs.elems+8,"16",2)==0) { value_SetEnum(parent,ws_FrameHeaderMsgsCase_ws_Frame16); ret = true; break; }
                    if (memcmp(rhs.elems+8,"64",2)==0) { value_SetEnum(parent,ws_FrameHeaderMsgsCase_ws_Frame64); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('w','s','.','F','r','a','m','e'): {
                    if (memcmp(rhs.elems+8,"Masked16",8)==0) { value_SetEnum(parent,ws_FrameHeaderMsgsCase_ws_FrameMasked16); ret = true; break; }
                    if (memcmp(rhs.elems+8,"Masked64",8)==0) { value_SetEnum(parent,ws_FrameHeaderMsgsCase_ws_FrameMasked64); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.FrameHeaderMsgsCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::FrameHeaderMsgsCase& parent, algo::strptr rhs, ws_FrameHeaderMsgsCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.FrameHeaderMsgsCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::FrameHeaderMsgsCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.FrameHeaderMsgsCase..ReadStrptrMaybe
// Read fields of ws::FrameHeaderMsgsCase from an ascii string.
// The format of the string is the format of the ws::FrameHeaderMsgsCase's only field
bool ws::FrameHeaderMsgsCase_ReadStrptrMaybe(ws::FrameHeaderMsgsCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.FrameMasked.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::FrameMasked &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.FrameMasked.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.FrameMasked.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::FrameMasked& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.FrameMasked.payload.Addr
char* ws::payload_Addr(ws::FrameMasked& parent) {
    return (char*)((u8*)&parent + sizeof(ws::FrameMasked)); // address of varlen portion
}

// --- ws.FrameMasked.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::FrameMasked& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.FrameMasked.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::FrameMasked& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.FrameMasked..ReadFieldMaybe
bool ws::FrameMasked_ReadFieldMaybe(ws::FrameMasked& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_masking_key: {
            retval = u32_ReadStrptrMaybe(parent.masking_key, strval);
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.FrameMasked..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::FrameMasked from an ascii string.
// The format of the string is an ssim Tuple
bool ws::FrameMasked_ReadStrptrMaybe(ws::FrameMasked &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.FrameMasked");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && FrameMasked_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.FrameMasked..Init
// Set all fields to initial values.
void ws::FrameMasked_Init(ws::FrameMasked& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(0);
    parent.masking_key = u32(0);
}

// --- ws.FrameMasked..Print
// print string representation of ROW to string STR
// cfmt:ws.FrameMasked.String  printfmt:Tuple
void ws::FrameMasked_Print(ws::FrameMasked& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.FrameMasked";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    u32_Print(row.masking_key, temp);
    PrintAttrSpaceReset(str,"masking_key", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.FrameMasked16.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::FrameMasked16 &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.FrameMasked16.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.FrameMasked16.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::FrameMasked16& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.FrameMasked16.payload.Addr
char* ws::payload_Addr(ws::FrameMasked16& parent) {
    return (char*)((u8*)&parent + sizeof(ws::FrameMasked16)); // address of varlen portion
}

// --- ws.FrameMasked16.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::FrameMasked16& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.FrameMasked16.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::FrameMasked16& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.FrameMasked16..ReadFieldMaybe
bool ws::FrameMasked16_ReadFieldMaybe(ws::FrameMasked16& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_ext_payload_len: {
            retval = false;
        } break;
        case ws_FieldId_masking_key: {
            retval = u32_ReadStrptrMaybe(parent.masking_key, strval);
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.FrameMasked16..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::FrameMasked16 from an ascii string.
// The format of the string is an ssim Tuple
bool ws::FrameMasked16_ReadStrptrMaybe(ws::FrameMasked16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.FrameMasked16");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && FrameMasked16_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.FrameMasked16..Init
// Set all fields to initial values.
void ws::FrameMasked16_Init(ws::FrameMasked16& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(254);
    parent.ext_payload_len_be = htobe16(ssizeof(parent) + (-8)); // write big-endian value to memory
    parent.masking_key = u32(0);
}

// --- ws.FrameMasked16..Print
// print string representation of ROW to string STR
// cfmt:ws.FrameMasked16.String  printfmt:Tuple
void ws::FrameMasked16_Print(ws::FrameMasked16& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.FrameMasked16";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    u32_Print(row.masking_key, temp);
    PrintAttrSpaceReset(str,"masking_key", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.FrameMasked64.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::FrameMasked64 &row, ws::FrameHeader &out) {
    out.byte0 = row.byte0;
    // byte1: field value is computed
    // fin: unknown field type (Bitfld), skipped
    // rsv1: unknown field type (Bitfld), skipped
    // rsv2: unknown field type (Bitfld), skipped
    // rsv3: unknown field type (Bitfld), skipped
    // opcode: unknown field type (Bitfld), skipped
    // mask: unknown field type (Bitfld), skipped
    // payload_len: unknown field type (Bitfld), skipped
}

// --- ws.FrameMasked64.fin.ReadStrptrMaybe
inline static bool ws::fin_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool fin_tmp;
    retval = bool_ReadStrptrMaybe(fin_tmp, in_str);
    if (retval) {
        fin_Set(parent, fin_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.rsv1.ReadStrptrMaybe
inline static bool ws::rsv1_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv1_tmp;
    retval = bool_ReadStrptrMaybe(rsv1_tmp, in_str);
    if (retval) {
        rsv1_Set(parent, rsv1_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.rsv2.ReadStrptrMaybe
inline static bool ws::rsv2_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv2_tmp;
    retval = bool_ReadStrptrMaybe(rsv2_tmp, in_str);
    if (retval) {
        rsv2_Set(parent, rsv2_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.rsv3.ReadStrptrMaybe
inline static bool ws::rsv3_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool rsv3_tmp;
    retval = bool_ReadStrptrMaybe(rsv3_tmp, in_str);
    if (retval) {
        rsv3_Set(parent, rsv3_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.opcode.ReadStrptrMaybe
inline static bool ws::opcode_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    ws::Opcode opcode_tmp;
    retval = ws::Opcode_ReadStrptrMaybe(opcode_tmp, in_str);
    if (retval) {
        opcode_Set(parent, opcode_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.mask.ReadStrptrMaybe
inline static bool ws::mask_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    bool mask_tmp;
    retval = bool_ReadStrptrMaybe(mask_tmp, in_str);
    if (retval) {
        mask_Set(parent, mask_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.payload_len.ReadStrptrMaybe
inline static bool ws::payload_len_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    u8 payload_len_tmp;
    retval = u8_ReadStrptrMaybe(payload_len_tmp, in_str);
    if (retval) {
        payload_len_Set(parent, payload_len_tmp);
    }
    return retval;
}

// --- ws.FrameMasked64.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ws::payload_Getary(ws::FrameMasked64& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ws.FrameMasked64.payload.Addr
char* ws::payload_Addr(ws::FrameMasked64& parent) {
    return (char*)((u8*)&parent + sizeof(ws::FrameMasked64)); // address of varlen portion
}

// --- ws.FrameMasked64.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::payload_ReadStrptrMaybe(ws::FrameMasked64& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ws.FrameMasked64.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ws::payload_Print(ws::FrameMasked64& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ws.FrameMasked64..ReadFieldMaybe
bool ws::FrameMasked64_ReadFieldMaybe(ws::FrameMasked64& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_byte0: {
            retval = u8_ReadStrptrMaybe(parent.byte0, strval);
        } break;
        case ws_FieldId_byte1: {
            retval = false;
        } break;
        case ws_FieldId_fin: {
            retval = fin_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv1: {
            retval = rsv1_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv2: {
            retval = rsv2_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_rsv3: {
            retval = rsv3_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_opcode: {
            retval = opcode_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_mask: {
            retval = mask_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_payload_len: {
            retval = payload_len_ReadStrptrMaybe(parent, strval);
        } break;
        case ws_FieldId_ext_payload_len: {
            retval = false;
        } break;
        case ws_FieldId_masking_key: {
            retval = u32_ReadStrptrMaybe(parent.masking_key, strval);
        } break;
        case ws_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.FrameMasked64..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ws::FrameMasked64 from an ascii string.
// The format of the string is an ssim Tuple
bool ws::FrameMasked64_ReadStrptrMaybe(ws::FrameMasked64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.FrameMasked64");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && FrameMasked64_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.FrameMasked64..Init
// Set all fields to initial values.
void ws::FrameMasked64_Init(ws::FrameMasked64& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(255);
    parent.ext_payload_len_be = htobe64(ssizeof(parent) + (-14)); // write big-endian value to memory
    parent.masking_key = u32(0);
}

// --- ws.FrameMasked64..Print
// print string representation of ROW to string STR
// cfmt:ws.FrameMasked64.String  printfmt:Tuple
void ws::FrameMasked64_Print(ws::FrameMasked64& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.FrameMasked64";

    bool_Print(fin_Get(row), temp);
    PrintAttrSpaceReset(str,"fin", temp);

    bool_Print(rsv1_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv1", temp);

    bool_Print(rsv2_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv2", temp);

    bool_Print(rsv3_Get(row), temp);
    PrintAttrSpaceReset(str,"rsv3", temp);

    ws::Opcode_Print(opcode_Get(row), temp);
    PrintAttrSpaceReset(str,"opcode", temp);

    bool_Print(mask_Get(row), temp);
    PrintAttrSpaceReset(str,"mask", temp);

    u8_Print(payload_len_Get(row), temp);
    PrintAttrSpaceReset(str,"payload_len", temp);

    u32_Print(row.masking_key, temp);
    PrintAttrSpaceReset(str,"masking_key", temp);

    ws::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ws.HttpState.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ws::value_ToCstr(const ws::HttpState& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ws_HttpState_INIT             : ret = "INIT";  break;
        case ws_HttpState_REQLINE          : ret = "REQLINE";  break;
        case ws_HttpState_HEADER           : ret = "HEADER";  break;
        case ws_HttpState_BODY             : ret = "BODY";  break;
        case ws_HttpState_FIN              : ret = "FIN";  break;
    }
    return ret;
}

// --- ws.HttpState.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ws::value_Print(const ws::HttpState& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ws.HttpState.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ws::value_SetStrptrMaybe(ws::HttpState& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('F','I','N'): {
                    value_SetEnum(parent,ws_HttpState_FIN); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('B','O','D','Y'): {
                    value_SetEnum(parent,ws_HttpState_BODY); ret = true; break;
                }
                case LE_STR4('I','N','I','T'): {
                    value_SetEnum(parent,ws_HttpState_INIT); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('H','E','A','D','E','R'): {
                    value_SetEnum(parent,ws_HttpState_HEADER); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('R','E','Q','L','I','N','E'): {
                    value_SetEnum(parent,ws_HttpState_REQLINE); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ws.HttpState.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ws::value_SetStrptr(ws::HttpState& parent, algo::strptr rhs, ws_HttpStateEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ws.HttpState.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ws::value_ReadStrptrMaybe(ws::HttpState& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ws.HttpState..ReadStrptrMaybe
// Read fields of ws::HttpState from an ascii string.
// The format of the string is the format of the ws::HttpState's only field
bool ws::HttpState_ReadStrptrMaybe(ws::HttpState &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ws.HttpState..Print
// print string representation of ROW to string STR
// cfmt:ws.HttpState.String  printfmt:Raw
void ws::HttpState_Print(ws::HttpState row, algo::cstring& str) {
    ws::value_Print(row, str);
}

// --- ws.ServerStartMsg.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::ServerStartMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ws.ServerStartMsg..ReadFieldMaybe
bool ws::ServerStartMsg_ReadFieldMaybe(ws::ServerStartMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_type: {
            retval = false;
        } break;
        case ws_FieldId_length: {
            retval = false;
        } break;
        case ws_FieldId_server: {
            retval = algo::RspaceStr25_ReadStrptrMaybe(parent.server, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.ServerStartMsg..ReadStrptrMaybe
// Read fields of ws::ServerStartMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ws::ServerStartMsg_ReadStrptrMaybe(ws::ServerStartMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.ServerStartMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ServerStartMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.ServerStartMsg..Print
// print string representation of ROW to string STR
// cfmt:ws.ServerStartMsg.String  printfmt:Tuple
void ws::ServerStartMsg_Print(ws::ServerStartMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.ServerStartMsg";

    algo::RspaceStr25_Print(row.server, temp);
    PrintAttrSpaceReset(str,"server", temp);
}

// --- ws.ServerStopMsg.base.CopyOut
// Copy fields out of row
void ws::parent_CopyOut(ws::ServerStopMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ws.ServerStopMsg..ReadFieldMaybe
bool ws::ServerStopMsg_ReadFieldMaybe(ws::ServerStopMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ws::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ws_FieldId_base: {
            retval = false;
        } break;
        case ws_FieldId_type: {
            retval = false;
        } break;
        case ws_FieldId_length: {
            retval = false;
        } break;
        case ws_FieldId_server: {
            retval = algo::RspaceStr25_ReadStrptrMaybe(parent.server, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ws.ServerStopMsg..ReadStrptrMaybe
// Read fields of ws::ServerStopMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ws::ServerStopMsg_ReadStrptrMaybe(ws::ServerStopMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ws.ServerStopMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ServerStopMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ws.ServerStopMsg..Print
// print string representation of ROW to string STR
// cfmt:ws.ServerStopMsg.String  printfmt:Tuple
void ws::ServerStopMsg_Print(ws::ServerStopMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ws.ServerStopMsg";

    algo::RspaceStr25_Print(row.server, temp);
    PrintAttrSpaceReset(str,"server", temp);
}

// --- ws...SizeCheck
inline static void ws::SizeCheck() {
    algo_assert(_offset_of(ws::Side,value) == 0);
    algo_assert(sizeof(ws::Side) == 1);
    algo_assert(_offset_of(ws::StatusCode,value) == 0);
    algo_assert(sizeof(ws::StatusCode) == 2);
    algo_assert(_offset_of(ws::CloseMsg,type) == 0);
    algo_assert(_offset_of(ws::CloseMsg,length) == 4);
    algo_assert(_offset_of(ws::CloseMsg,conn) == 8);
    algo_assert(_offset_of(ws::CloseMsg,side) == 58);
    algo_assert(_offset_of(ws::CloseMsg,code) == 59);
    algo_assert(sizeof(ws::CloseMsg) == 61);
    algo_assert(_offset_of(ws::ConnectMsg,type) == 0);
    algo_assert(_offset_of(ws::ConnectMsg,length) == 4);
    algo_assert(_offset_of(ws::ConnectMsg,conn) == 8);
    algo_assert(_offset_of(ws::ConnectMsg,side) == 58);
    algo_assert(sizeof(ws::ConnectMsg) == 59);
    algo_assert(_offset_of(ws::Opcode,value) == 0);
    algo_assert(sizeof(ws::Opcode) == 1);
    algo_assert(_offset_of(ws::DataMsg,type) == 0);
    algo_assert(_offset_of(ws::DataMsg,length) == 4);
    algo_assert(_offset_of(ws::DataMsg,conn) == 8);
    algo_assert(_offset_of(ws::DataMsg,side) == 58);
    algo_assert(_offset_of(ws::DataMsg,opcode) == 59);
    algo_assert(sizeof(ws::DataMsg) == 60);
    algo_assert(_offset_of(ws::Frame,byte0) == 0);
    algo_assert(_offset_of(ws::Frame,byte1) == 1);
    algo_assert(sizeof(ws::Frame) == 2);
    algo_assert(_offset_of(ws::Frame16,byte0) == 0);
    algo_assert(_offset_of(ws::Frame16,byte1) == 1);
    algo_assert(_offset_of(ws::Frame16,ext_payload_len_be) == 2);
    algo_assert(sizeof(ws::Frame16) == 4);
    algo_assert(_offset_of(ws::Frame64,byte0) == 0);
    algo_assert(_offset_of(ws::Frame64,byte1) == 1);
    algo_assert(_offset_of(ws::Frame64,ext_payload_len_be) == 2);
    algo_assert(sizeof(ws::Frame64) == 10);
    algo_assert(_offset_of(ws::FrameHeader,byte0) == 0);
    algo_assert(_offset_of(ws::FrameHeader,byte1) == 1);
    algo_assert(sizeof(ws::FrameHeader) == 2);
    algo_assert(_offset_of(ws::FrameMasked,byte0) == 0);
    algo_assert(_offset_of(ws::FrameMasked,byte1) == 1);
    algo_assert(_offset_of(ws::FrameMasked,masking_key) == 2);
    algo_assert(sizeof(ws::FrameMasked) == 6);
    algo_assert(_offset_of(ws::FrameMasked16,byte0) == 0);
    algo_assert(_offset_of(ws::FrameMasked16,byte1) == 1);
    algo_assert(_offset_of(ws::FrameMasked16,ext_payload_len_be) == 2);
    algo_assert(_offset_of(ws::FrameMasked16,masking_key) == 4);
    algo_assert(sizeof(ws::FrameMasked16) == 8);
    algo_assert(_offset_of(ws::FrameMasked64,byte0) == 0);
    algo_assert(_offset_of(ws::FrameMasked64,byte1) == 1);
    algo_assert(_offset_of(ws::FrameMasked64,ext_payload_len_be) == 2);
    algo_assert(_offset_of(ws::FrameMasked64,masking_key) == 10);
    algo_assert(sizeof(ws::FrameMasked64) == 14);
    algo_assert(_offset_of(ws::HttpState,value) == 0);
    algo_assert(sizeof(ws::HttpState) == 1);
    algo_assert(_offset_of(ws::ServerStartMsg,type) == 0);
    algo_assert(_offset_of(ws::ServerStartMsg,length) == 4);
    algo_assert(_offset_of(ws::ServerStartMsg,server) == 8);
    algo_assert(sizeof(ws::ServerStartMsg) == 33);
    algo_assert(_offset_of(ws::ServerStopMsg,type) == 0);
    algo_assert(_offset_of(ws::ServerStopMsg,length) == 4);
    algo_assert(_offset_of(ws::ServerStopMsg,server) == 8);
    algo_assert(sizeof(ws::ServerStopMsg) == 33);
}

// --- ws...StaticCheck
void ws::StaticCheck() {
    algo_assert(_offset_of(ws::Side, value) + sizeof(((ws::Side*)0)->value) == sizeof(ws::Side));
    algo_assert(_offset_of(ws::StatusCode, value) + sizeof(((ws::StatusCode*)0)->value) == sizeof(ws::StatusCode));
    algo_assert(_offset_of(ws::ConnectMsg, side) + sizeof(((ws::ConnectMsg*)0)->side) == sizeof(ws::ConnectMsg));
    algo_assert(_offset_of(ws::Opcode, value) + sizeof(((ws::Opcode*)0)->value) == sizeof(ws::Opcode));
    algo_assert(_offset_of(ws::FieldId, value) + sizeof(((ws::FieldId*)0)->value) == sizeof(ws::FieldId));
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame*)0)->byte1)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame16*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame16*)0)->byte1)*8 >= 8);
    algo_assert(_offset_of(ws::Frame16_curs, msglen) + sizeof(((ws::Frame16_curs*)0)->msglen) == sizeof(ws::Frame16_curs));
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame64*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::Frame64*)0)->byte1)*8 >= 8);
    algo_assert(_offset_of(ws::Frame64_curs, msglen) + sizeof(((ws::Frame64_curs*)0)->msglen) == sizeof(ws::Frame64_curs));
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameHeader*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameHeader*)0)->byte1)*8 >= 8);
    algo_assert(_offset_of(ws::FrameHeader, byte1) + sizeof(((ws::FrameHeader*)0)->byte1) == sizeof(ws::FrameHeader));
    algo_assert(_offset_of(ws::FrameHeaderMsgsCase, value) + sizeof(((ws::FrameHeaderMsgsCase*)0)->value) == sizeof(ws::FrameHeaderMsgsCase));
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked*)0)->byte1)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked16*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked16*)0)->byte1)*8 >= 8);
    algo_assert(_offset_of(ws::FrameMasked16_curs, msglen) + sizeof(((ws::FrameMasked16_curs*)0)->msglen) == sizeof(ws::FrameMasked16_curs));
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked64*)0)->byte0)*8 >= 8);
    // check that bitfield fits width
    algo_assert(sizeof(((ws::FrameMasked64*)0)->byte1)*8 >= 8);
    algo_assert(_offset_of(ws::FrameMasked64_curs, msglen) + sizeof(((ws::FrameMasked64_curs*)0)->msglen) == sizeof(ws::FrameMasked64_curs));
    algo_assert(_offset_of(ws::HttpState, value) + sizeof(((ws::HttpState*)0)->value) == sizeof(ws::HttpState));
    algo_assert(_offset_of(ws::ServerStartMsg, server) + sizeof(((ws::ServerStartMsg*)0)->server) == sizeof(ws::ServerStartMsg));
    algo_assert(_offset_of(ws::ServerStopMsg, server) + sizeof(((ws::ServerStopMsg*)0)->server) == sizeof(ws::ServerStopMsg));
}

// --- ws.FrameHeaderMsgs..Print
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool ws::FrameHeaderMsgs_Print(algo::cstring &str, ws::FrameHeader &msg, u32 msg_len) {
    switch(msg.byte1) {
        case 126: {
            if (sizeof(ws::Frame16) > msg_len) { return false; }
            Frame16_Print((ws::Frame16&)(msg), str);
            return true;
        }
        case 127: {
            if (sizeof(ws::Frame64) > msg_len) { return false; }
            Frame64_Print((ws::Frame64&)(msg), str);
            return true;
        }
        case 254: {
            if (sizeof(ws::FrameMasked16) > msg_len) { return false; }
            FrameMasked16_Print((ws::FrameMasked16&)(msg), str);
            return true;
        }
        case 255: {
            if (sizeof(ws::FrameMasked64) > msg_len) { return false; }
            FrameMasked64_Print((ws::FrameMasked64&)(msg), str);
            return true;
        }
        default:

        return false;
    }
}

// --- ws.FrameHeaderMsgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
ws::FrameHeaderMsgsCase ws::FrameHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    ws::FrameHeaderMsgsCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case ws_FrameHeaderMsgsCase_ws_Frame16: {
            int len = sizeof(ws::Frame16);
            ws::Frame16 *ctype = new(ary_AllocN(buf, len).elems) ws::Frame16; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Frame16_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ext_payload_len_Set(*ctype, u16(len-4));
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::Frame16 case

        case ws_FrameHeaderMsgsCase_ws_Frame64: {
            int len = sizeof(ws::Frame64);
            ws::Frame64 *ctype = new(ary_AllocN(buf, len).elems) ws::Frame64; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Frame64_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ext_payload_len_Set(*ctype, u64(len-10));
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::Frame64 case

        case ws_FrameHeaderMsgsCase_ws_FrameMasked16: {
            int len = sizeof(ws::FrameMasked16);
            ws::FrameMasked16 *ctype = new(ary_AllocN(buf, len).elems) ws::FrameMasked16; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = FrameMasked16_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ext_payload_len_Set(*ctype, u16(len-8));
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::FrameMasked16 case

        case ws_FrameHeaderMsgsCase_ws_FrameMasked64: {
            int len = sizeof(ws::FrameMasked64);
            ws::FrameMasked64 *ctype = new(ary_AllocN(buf, len).elems) ws::FrameMasked64; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = FrameMasked64_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ext_payload_len_Set(*ctype, u64(len-14));
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::FrameMasked64 case

        default: break;
    }
    return ok ? msgtype : ws::FrameHeaderMsgsCase();
}

// --- ws.FrameHeaderMsgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool ws::FrameHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    ws::FrameHeaderMsgsCase msgtype = FrameHeaderMsgs_ReadStrptr(str,buf);
    return !(msgtype == ws::FrameHeaderMsgsCase());
}
