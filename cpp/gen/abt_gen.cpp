//
// cpp/gen/abt_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/abt_gen.h"
#include "include/gen/abt_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
abt::FDb        abt::_db;         // dependency found via dev.targdep

namespace abt {
const char *abt_help =
"abt: Algo Build Tool - build & link C++ targets\n"
"Usage: abt [[-target:]<regx>] [options]\n"
"    OPTION      TYPE    DFLT    COMMENT\n"
"    [target]    regx    \"\"      Regx of target name\n"
"    -in         string  \"data\"  Root of input ssim dir\n"
"    -cfg        regx    \"\"      Set config\n"
"    -compiler   string  \"\"      Set compiler.\n"
"    -uname      string  \"\"      Set uname (default: guess)\n"
"    -arch       string  \"\"      Set architecture (default: guess)\n"
"    -ood                        List out-of-date source files\n"
"    -list                       List target files\n"
"    -listincl                   List includes\n"
"    -build                      If set, build specified target (all necessary steps)\n"
"    -preproc                    Preprocess file, produce .i file\n"
"    -srcfile    regx    \"%\"     Build/disassemble/preprocess specific file\n"
"    -clean                      Delete all output files\n"
"    -dry_run                    Print actions, do not perform\n"
"    -maxjobs    int     0       Maximum number of child build processes. 0=pick good default\n"
"    -printcmd                   Print commands. Do not execute\n"
"    -force                      Assume all files are out-of-date\n"
"    -install                    Update soft-link under bin/\n"
"    -coverity                   Run abt in coverity mode\n"
"    -package    string  \"\"      Package tag\n"
"    -maxerr     int     100     Max failing commands before rest of pipeline is forced to fail\n"
"    -disas      regx    \"\"      Regex of function to disassemble\n"
"    -report             Y       Print final report\n"
"    -jcdb       string  \"\"      Create JSON compilation database in specified file\n"
"    -cache      enum    auto    Cache mode (auto|none|gcache|gcache-force|ccache)\n"
"                                    auto  Select cache automatically among enabled\n"
"                                    none  No cache\n"
"                                    gcache  Select gcache if enabled (no cache if disabled)\n"
"                                    gcache-force  Pass --force to gcache (no cache if disabled)\n"
"                                    ccache  Select ccache if enabled (no cache if disabled)\n"
"    -shortlink                  Try to shorten sort link if possible\n"
"    -verbose    flag            Verbosity level (0..255); alias -v; cumulative\n"
"    -debug      flag            Debug level (0..255); alias -d; cumulative\n"
"    -help                       Print help and exit; alias -h\n"
"    -version                    Print version and exit\n"
"    -signature                  Show signatures and exit; alias -sig\n"
;


} // namespace abt
abt::_db_bh_syscmd_curs::~_db_bh_syscmd_curs() {
    abt::lpool_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

namespace abt { // gen:ns_gsymbol
    const char* dev_opt_type_AR("AR");
    const char* dev_opt_type_C("C");
    const char* dev_opt_type_CC("CC");
    const char* dev_opt_type_CPP("CPP");
    const char* dev_opt_type_HPP("HPP");
    const char* dev_opt_type_IGNOREME("IGNOREME");
    const char* dev_opt_type_LINK("LINK");
    const char* dev_opt_type_RC("RC");
} // gen:ns_gsymbol
namespace abt { // gen:ns_print_proto
    // func:abt.FDb.targdep.InputMaybe
    static bool          targdep_InputMaybe(dev::Targdep &elem) __attribute__((nothrow));
    // func:abt.FDb.tool_opt.InputMaybe
    static bool          tool_opt_InputMaybe(dev::ToolOpt &elem) __attribute__((nothrow));
    // func:abt.FDb.target.InputMaybe
    static bool          target_InputMaybe(dev::Target &elem) __attribute__((nothrow));
    // func:abt.FDb.targsrc.InputMaybe
    static bool          targsrc_InputMaybe(dev::Targsrc &elem) __attribute__((nothrow));
    // func:abt.FDb.syscmddep.InputMaybe
    static bool          syscmddep_InputMaybe(dev::Syscmddep &elem) __attribute__((nothrow));
    // func:abt.FDb.syscmd.InputMaybe
    static bool          syscmd_InputMaybe(dev::Syscmd &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    // func:abt.FDb._db.InitReflection
    static void          InitReflection();
    // func:abt.FDb.cfg.InputMaybe
    static bool          cfg_InputMaybe(dev::Cfg &elem) __attribute__((nothrow));
    // func:abt.FDb.uname.InputMaybe
    static bool          uname_InputMaybe(dev::Uname &elem) __attribute__((nothrow));
    // func:abt.FDb.compiler.InputMaybe
    static bool          compiler_InputMaybe(dev::Compiler &elem) __attribute__((nothrow));
    // func:abt.FDb.arch.InputMaybe
    static bool          arch_InputMaybe(dev::Arch &elem) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    // func:abt.FDb.bh_syscmd.Downheap
    static int           bh_syscmd_Downheap(abt::FSyscmd& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    // func:abt.FDb.bh_syscmd.Upheap
    static int           bh_syscmd_Upheap(abt::FSyscmd& row, int idx) __attribute__((nothrow));
    // func:abt.FDb.bh_syscmd.ElemLt
    inline static bool   bh_syscmd_ElemLt(abt::FSyscmd &a, abt::FSyscmd &b) __attribute__((nothrow));
    // func:abt.FDb.bh_syscmd_curs.Add
    static void          _db_bh_syscmd_curs_Add(_db_bh_syscmd_curs &curs, abt::FSyscmd& row);
    // func:abt.FDb.targsyslib.InputMaybe
    static bool          targsyslib_InputMaybe(dev::Targsyslib &elem) __attribute__((nothrow));
    // func:abt.FDb.syslib.InputMaybe
    static bool          syslib_InputMaybe(dev::Syslib &elem) __attribute__((nothrow));
    // func:abt.FDb.include.InputMaybe
    static bool          include_InputMaybe(dev::Include &elem) __attribute__((nothrow));
    // func:abt.FDb.ns.InputMaybe
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    // func:abt.FDb.builddir.InputMaybe
    static bool          builddir_InputMaybe(dev::Builddir &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    // func:abt.FDb.trace.RowidFind
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    // func:abt.FDb.trace.N
    inline static i32    trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // func:abt...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- abt.FArch.msghdr.CopyOut
// Copy fields out of row
void abt::arch_CopyOut(abt::FArch &row, dev::Arch &out) {
    out.arch = row.arch;
    out.comment = row.comment;
}

// --- abt.FArch.msghdr.CopyIn
// Copy fields in to row
void abt::arch_CopyIn(abt::FArch &row, dev::Arch &in) {
    row.arch = in.arch;
    row.comment = in.comment;
}

// --- abt.FArch..Uninit
void abt::FArch_Uninit(abt::FArch& arch) {
    abt::FArch &row = arch; (void)row;
    ind_arch_Remove(row); // remove arch from index ind_arch
}

// --- abt.FBuilddir.base.CopyOut
// Copy fields out of row
void abt::builddir_CopyOut(abt::FBuilddir &row, dev::Builddir &out) {
    out.builddir = row.builddir;
    out.comment = row.comment;
}

// --- abt.FBuilddir.base.CopyIn
// Copy fields in to row
void abt::builddir_CopyIn(abt::FBuilddir &row, dev::Builddir &in) {
    row.builddir = in.builddir;
    row.comment = in.comment;
}

// --- abt.FBuilddir.uname.Get
algo::Smallstr50 abt::uname_Get(abt::FBuilddir& builddir) {
    algo::Smallstr50 ret(algo::Pathcomp(builddir.builddir, ".LL-LL"));
    return ret;
}

// --- abt.FBuilddir.compiler.Get
algo::Smallstr50 abt::compiler_Get(abt::FBuilddir& builddir) {
    algo::Smallstr50 ret(algo::Pathcomp(builddir.builddir, ".LL-LR"));
    return ret;
}

// --- abt.FBuilddir.cfg.Get
algo::Smallstr50 abt::cfg_Get(abt::FBuilddir& builddir) {
    algo::Smallstr50 ret(algo::Pathcomp(builddir.builddir, ".LR-LL"));
    return ret;
}

// --- abt.FBuilddir.arch.Get
algo::Smallstr50 abt::arch_Get(abt::FBuilddir& builddir) {
    algo::Smallstr50 ret(algo::Pathcomp(builddir.builddir, ".LR-LR"));
    return ret;
}

// --- abt.FBuilddir..Init
// Set all fields to initial values.
void abt::FBuilddir_Init(abt::FBuilddir& builddir) {
    builddir.select = bool(false);
    builddir.p_compiler = NULL;
    builddir.ind_builddir_next = (abt::FBuilddir*)-1; // (abt.FDb.ind_builddir) not-in-hash
    builddir.ind_builddir_hashval = 0; // stored hash value
}

// --- abt.FBuilddir..Uninit
void abt::FBuilddir_Uninit(abt::FBuilddir& builddir) {
    abt::FBuilddir &row = builddir; (void)row;
    ind_builddir_Remove(row); // remove builddir from index ind_builddir
}

// --- abt.FCfg.msghdr.CopyOut
// Copy fields out of row
void abt::cfg_CopyOut(abt::FCfg &row, dev::Cfg &out) {
    out.cfg = row.cfg;
    out.suffix = row.suffix;
    out.comment = row.comment;
}

// --- abt.FCfg.msghdr.CopyIn
// Copy fields in to row
void abt::cfg_CopyIn(abt::FCfg &row, dev::Cfg &in) {
    row.cfg = in.cfg;
    row.suffix = in.suffix;
    row.comment = in.comment;
}

// --- abt.FCfg..Uninit
void abt::FCfg_Uninit(abt::FCfg& cfg) {
    abt::FCfg &row = cfg; (void)row;
    ind_cfg_Remove(row); // remove cfg from index ind_cfg
}

// --- abt.FCompiler.msghdr.CopyOut
// Copy fields out of row
void abt::compiler_CopyOut(abt::FCompiler &row, dev::Compiler &out) {
    out.compiler = row.compiler;
    out.ranlib = row.ranlib;
    out.ar = row.ar;
    out.link = row.link;
    out.libext = row.libext;
    out.exeext = row.exeext;
    out.pchext = row.pchext;
    out.objext = row.objext;
    out.rc = row.rc;
    out.comment = row.comment;
}

// --- abt.FCompiler.msghdr.CopyIn
// Copy fields in to row
void abt::compiler_CopyIn(abt::FCompiler &row, dev::Compiler &in) {
    row.compiler = in.compiler;
    row.ranlib = in.ranlib;
    row.ar = in.ar;
    row.link = in.link;
    row.libext = in.libext;
    row.exeext = in.exeext;
    row.pchext = in.pchext;
    row.objext = in.objext;
    row.rc = in.rc;
    row.comment = in.comment;
}

// --- abt.FCompiler..Uninit
void abt::FCompiler_Uninit(abt::FCompiler& compiler) {
    abt::FCompiler &row = compiler; (void)row;
    ind_compiler_Remove(row); // remove compiler from index ind_compiler
}

// --- abt.trace..Print
// print string representation of ROW to string STR
// cfmt:abt.trace.String  printfmt:Tuple
void abt::trace_Print(abt::trace& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "abt.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- abt.FDb.lpool.FreeMem
// Free block of memory previously returned by Lpool.
void abt::lpool_FreeMem(void* mem, u64 size) {
    size = u64_Max(size,1ULL<<4);
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (mem && cell < 36) {
        lpool_Lpblock *temp = (lpool_Lpblock*)mem; // push  singly linked list
        temp->next = _db.lpool_free[cell];
        _db.lpool_free[cell] = temp;
    }
}

// --- abt.FDb.lpool.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
void* abt::lpool_AllocMem(u64 size) {
    void *retval = NULL;
    size     = u64_Max(size,1<<4); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (cell < 36) {
        u64 i    = cell;
        // try to find a block that's at least as large as required.
        // if found, remove from free list
        for (; i < 36; i++) {
            lpool_Lpblock *blk = _db.lpool_free[i];
            if (blk) {
                _db.lpool_free[i] = blk->next;
                retval = blk;
                break;
            }
        }
        // if suitable size block is not found, create a new one
        // by requesting a block from the base allocator.
        if (UNLIKELY(!retval)) {
            i = u64_Max(cell, 21-4); // 2MB min -- allow huge page to be used
            retval = algo_lib::sbrk_AllocMem(1ULL<<(i+4));
        }
        if (LIKELY(retval)) {
            // if block is more than 2x as large as needed, return the upper half to the free
            // list (repeatedly). meanwhile, retval doesn't change.
            while (i > cell) {
                i--;
                int half = 1ULL<<(i+4);
                lpool_Lpblock *blk = (lpool_Lpblock*)((u8*)retval + half);
                blk->next = _db.lpool_free[i];
                _db.lpool_free[i] = blk;
            }
        }
    }
    return retval;
}

// --- abt.FDb.lpool.ReserveBuffers
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::sbrk)
bool abt::lpool_ReserveBuffers(u64 nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 1<<4);
    u64 cell = algo::u64_BitScanReverse(bufsize-1) + 1 - 4;
    if (cell < 36) {
        for (u64 i = 0; i < nbuf; i++) {
            u64 size = 1ULL<<(cell+4);
            lpool_Lpblock *temp = (lpool_Lpblock*)algo_lib::sbrk_AllocMem(size);
            if (temp == NULL) {
                retval = false;
                break;// why continue?
            } else {
                temp->next = _db.lpool_free[cell];
                _db.lpool_free[cell] = temp;
            }
        }
    }
    return retval;
}

// --- abt.FDb.lpool.ReallocMem
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
void* abt::lpool_ReallocMem(void* oldmem, u64 old_size, u64 new_size) {
    void *ret = oldmem;
    if (new_size != old_size) {
        ret = lpool_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            lpool_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- abt.FDb.lpool.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
u8& abt::lpool_Alloc() {
    u8* row = lpool_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.lpool  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.lpool.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
u8* abt::lpool_AllocMaybe() {
    u8 *row = (u8*)lpool_AllocMem(sizeof(u8));
    if (row) {
        new (row) u8; // call constructor
    }
    return row;
}

// --- abt.FDb.lpool.Delete
// Remove row from all global and cross indices, then deallocate row
void abt::lpool_Delete(u8 &row) {
    int length = sizeof(u8);
    lpool_FreeMem(&row, length);
}

// --- abt.FDb.srcfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FSrcfile& abt::srcfile_Alloc() {
    abt::FSrcfile* row = srcfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.srcfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.srcfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FSrcfile* abt::srcfile_AllocMaybe() {
    abt::FSrcfile *row = (abt::FSrcfile*)srcfile_AllocMem();
    if (row) {
        new (row) abt::FSrcfile; // call constructor
    }
    return row;
}

// --- abt.FDb.srcfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FSrcfile* abt::srcfile_InsertMaybe(const dev::Srcfile &value) {
    abt::FSrcfile *row = &srcfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    srcfile_CopyIn(*row,const_cast<dev::Srcfile&>(value));
    bool ok = srcfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        srcfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.srcfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::srcfile_AllocMem() {
    u64 new_nelems     = _db.srcfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FSrcfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.srcfile_lary[bsr];
        if (!lev) {
            lev=(abt::FSrcfile*)abt::lpool_AllocMem(sizeof(abt::FSrcfile) * (u64(1)<<bsr));
            _db.srcfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.srcfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.srcfile.RemoveAll
// Remove all elements from Lary
void abt::srcfile_RemoveAll() {
    for (u64 n = _db.srcfile_n; n>0; ) {
        n--;
        srcfile_qFind(u64(n)).~FSrcfile(); // destroy last element
        _db.srcfile_n = i32(n);
    }
}

// --- abt.FDb.srcfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::srcfile_RemoveLast() {
    u64 n = _db.srcfile_n;
    if (n > 0) {
        n -= 1;
        srcfile_qFind(u64(n)).~FSrcfile();
        _db.srcfile_n = i32(n);
    }
}

// --- abt.FDb.srcfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::srcfile_XrefMaybe(abt::FSrcfile &row) {
    bool retval = true;
    (void)row;
    // insert srcfile into index ind_srcfile
    if (true) { // user-defined insert condition
        bool success = ind_srcfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_srcfile"; // check for duplicate key
            return false;
        }
    }
    // insert srcfile into index zs_srcfile_read
    if (true) { // user-defined insert condition
        zs_srcfile_read_Insert(row);
    }
    return retval;
}

// --- abt.FDb.targdep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FTargdep& abt::targdep_Alloc() {
    abt::FTargdep* row = targdep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.targdep  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.targdep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FTargdep* abt::targdep_AllocMaybe() {
    abt::FTargdep *row = (abt::FTargdep*)targdep_AllocMem();
    if (row) {
        new (row) abt::FTargdep; // call constructor
    }
    return row;
}

// --- abt.FDb.targdep.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FTargdep* abt::targdep_InsertMaybe(const dev::Targdep &value) {
    abt::FTargdep *row = &targdep_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targdep_CopyIn(*row,const_cast<dev::Targdep&>(value));
    bool ok = targdep_XrefMaybe(*row); // this may return false
    if (!ok) {
        targdep_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.targdep.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::targdep_AllocMem() {
    u64 new_nelems     = _db.targdep_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FTargdep*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targdep_lary[bsr];
        if (!lev) {
            lev=(abt::FTargdep*)abt::lpool_AllocMem(sizeof(abt::FTargdep) * (u64(1)<<bsr));
            _db.targdep_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targdep_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.targdep.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::targdep_RemoveLast() {
    u64 n = _db.targdep_n;
    if (n > 0) {
        n -= 1;
        targdep_qFind(u64(n)).~FTargdep();
        _db.targdep_n = i32(n);
    }
}

// --- abt.FDb.targdep.InputMaybe
static bool abt::targdep_InputMaybe(dev::Targdep &elem) {
    bool retval = true;
    retval = targdep_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.targdep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::targdep_XrefMaybe(abt::FTargdep &row) {
    bool retval = true;
    (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // insert targdep into index c_targdep
    if (true) { // user-defined insert condition
        c_targdep_Insert(*p_target, row);
    }
    abt::FTarget* p_parent = abt::ind_target_Find(parent_Get(row));
    if (UNLIKELY(!p_parent)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_target" << Keyval("key", parent_Get(row));
        return false;
    }
    // targdep: save pointer to parent
    if (true) { // user-defined insert condition
        row.p_parent = p_parent;
    }
    return retval;
}

// --- abt.FDb.tool_opt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FToolOpt& abt::tool_opt_Alloc() {
    abt::FToolOpt* row = tool_opt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.tool_opt  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.tool_opt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FToolOpt* abt::tool_opt_AllocMaybe() {
    abt::FToolOpt *row = (abt::FToolOpt*)tool_opt_AllocMem();
    if (row) {
        new (row) abt::FToolOpt; // call constructor
    }
    return row;
}

// --- abt.FDb.tool_opt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FToolOpt* abt::tool_opt_InsertMaybe(const dev::ToolOpt &value) {
    abt::FToolOpt *row = &tool_opt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tool_opt_CopyIn(*row,const_cast<dev::ToolOpt&>(value));
    bool ok = tool_opt_XrefMaybe(*row); // this may return false
    if (!ok) {
        tool_opt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.tool_opt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::tool_opt_AllocMem() {
    u64 new_nelems     = _db.tool_opt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FToolOpt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tool_opt_lary[bsr];
        if (!lev) {
            lev=(abt::FToolOpt*)abt::lpool_AllocMem(sizeof(abt::FToolOpt) * (u64(1)<<bsr));
            _db.tool_opt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tool_opt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.tool_opt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::tool_opt_RemoveLast() {
    u64 n = _db.tool_opt_n;
    if (n > 0) {
        n -= 1;
        tool_opt_qFind(u64(n)).~FToolOpt();
        _db.tool_opt_n = i32(n);
    }
}

// --- abt.FDb.tool_opt.InputMaybe
static bool abt::tool_opt_InputMaybe(dev::ToolOpt &elem) {
    bool retval = true;
    retval = tool_opt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.tool_opt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::tool_opt_XrefMaybe(abt::FToolOpt &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- abt.FDb.ind_target.Find
// Find row by key. Return NULL if not found.
abt::FTarget* abt::ind_target_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_target_buckets_n - 1);
    abt::FTarget *ret = _db.ind_target_buckets_elems[index];
    for (; ret && !((*ret).target == key); ret = ret->ind_target_next) {
    }
    return ret;
}

// --- abt.FDb.ind_target.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FTarget& abt::ind_target_GetOrCreate(const algo::strptr& key) {
    abt::FTarget* ret = ind_target_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &target_Alloc();
        (*ret).target = key;
        bool good = target_XrefMaybe(*ret);
        if (!good) {
            target_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_target  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_target.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_target_InsertMaybe(abt::FTarget& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_target_next == (abt::FTarget*)-1)) {// check if in hash already
        row.ind_target_hashval = algo::Smallstr16_Hash(0, row.target);
        ind_target_Reserve(1);
        u32 index = row.ind_target_hashval & (_db.ind_target_buckets_n - 1);
        abt::FTarget* *prev = &_db.ind_target_buckets_elems[index];
        do {
            abt::FTarget* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).target == row.target) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_target_next;
        } while (true);
        if (retval) {
            row.ind_target_next = *prev;
            _db.ind_target_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_target.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_target_Remove(abt::FTarget& row) {
    if (LIKELY(row.ind_target_next != (abt::FTarget*)-1)) {// check if in hash already
        u32 index = row.ind_target_hashval & (_db.ind_target_buckets_n - 1);
        abt::FTarget* *prev = &_db.ind_target_buckets_elems[index]; // addr of pointer to current element
        while (abt::FTarget *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_target_next; // unlink (singly linked list)
                _db.ind_target_n--;
                row.ind_target_next = (abt::FTarget*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_target_next;
        }
    }
}

// --- abt.FDb.ind_target.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_target_Reserve(int n) {
    ind_target_AbsReserve(_db.ind_target_n + n);
}

// --- abt.FDb.ind_target.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_target_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_target_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FTarget*);
        u32 new_size = new_nbuckets * sizeof(abt::FTarget*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FTarget* *new_buckets = (abt::FTarget**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_target");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_target_buckets_n; i++) {
            abt::FTarget* elem = _db.ind_target_buckets_elems[i];
            while (elem) {
                abt::FTarget &row        = *elem;
                abt::FTarget* next       = row.ind_target_next;
                u32 index          = row.ind_target_hashval & (new_nbuckets-1);
                row.ind_target_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_target_buckets_elems, old_size);
        _db.ind_target_buckets_elems = new_buckets;
        _db.ind_target_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.target.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FTarget& abt::target_Alloc() {
    abt::FTarget* row = target_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.target  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.target.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FTarget* abt::target_AllocMaybe() {
    abt::FTarget *row = (abt::FTarget*)target_AllocMem();
    if (row) {
        new (row) abt::FTarget; // call constructor
    }
    return row;
}

// --- abt.FDb.target.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FTarget* abt::target_InsertMaybe(const dev::Target &value) {
    abt::FTarget *row = &target_Alloc(); // if out of memory, process dies. if input error, return NULL.
    target_CopyIn(*row,const_cast<dev::Target&>(value));
    bool ok = target_XrefMaybe(*row); // this may return false
    if (!ok) {
        target_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.target.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::target_AllocMem() {
    u64 new_nelems     = _db.target_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FTarget*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.target_lary[bsr];
        if (!lev) {
            lev=(abt::FTarget*)abt::lpool_AllocMem(sizeof(abt::FTarget) * (u64(1)<<bsr));
            _db.target_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.target_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.target.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::target_RemoveLast() {
    u64 n = _db.target_n;
    if (n > 0) {
        n -= 1;
        target_qFind(u64(n)).~FTarget();
        _db.target_n = i32(n);
    }
}

// --- abt.FDb.target.InputMaybe
static bool abt::target_InputMaybe(dev::Target &elem) {
    bool retval = true;
    retval = target_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.target.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::target_XrefMaybe(abt::FTarget &row) {
    bool retval = true;
    (void)row;
    // insert target into index ind_target
    if (true) { // user-defined insert condition
        bool success = ind_target_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_target"; // check for duplicate key
            return false;
        }
    }
    abt::FNs* p_target = abt::ind_ns_Find(row.target);
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_ns" << Keyval("key", row.target);
        return false;
    }
    // target: save pointer to target
    if (true) { // user-defined insert condition
        row.p_ns = p_target;
    }
    return retval;
}

// --- abt.FDb.ind_targsrc.Find
// Find row by key. Return NULL if not found.
abt::FTargsrc* abt::ind_targsrc_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_targsrc_buckets_n - 1);
    abt::FTargsrc *ret = _db.ind_targsrc_buckets_elems[index];
    for (; ret && !((*ret).targsrc == key); ret = ret->ind_targsrc_next) {
    }
    return ret;
}

// --- abt.FDb.ind_targsrc.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FTargsrc& abt::ind_targsrc_GetOrCreate(const algo::strptr& key) {
    abt::FTargsrc* ret = ind_targsrc_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &targsrc_Alloc();
        (*ret).targsrc = key;
        bool good = targsrc_XrefMaybe(*ret);
        if (!good) {
            targsrc_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_targsrc  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_targsrc.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_targsrc_InsertMaybe(abt::FTargsrc& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_targsrc_next == (abt::FTargsrc*)-1)) {// check if in hash already
        row.ind_targsrc_hashval = algo::Smallstr100_Hash(0, row.targsrc);
        ind_targsrc_Reserve(1);
        u32 index = row.ind_targsrc_hashval & (_db.ind_targsrc_buckets_n - 1);
        abt::FTargsrc* *prev = &_db.ind_targsrc_buckets_elems[index];
        do {
            abt::FTargsrc* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).targsrc == row.targsrc) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_targsrc_next;
        } while (true);
        if (retval) {
            row.ind_targsrc_next = *prev;
            _db.ind_targsrc_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_targsrc.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_targsrc_Remove(abt::FTargsrc& row) {
    if (LIKELY(row.ind_targsrc_next != (abt::FTargsrc*)-1)) {// check if in hash already
        u32 index = row.ind_targsrc_hashval & (_db.ind_targsrc_buckets_n - 1);
        abt::FTargsrc* *prev = &_db.ind_targsrc_buckets_elems[index]; // addr of pointer to current element
        while (abt::FTargsrc *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_targsrc_next; // unlink (singly linked list)
                _db.ind_targsrc_n--;
                row.ind_targsrc_next = (abt::FTargsrc*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_targsrc_next;
        }
    }
}

// --- abt.FDb.ind_targsrc.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_targsrc_Reserve(int n) {
    ind_targsrc_AbsReserve(_db.ind_targsrc_n + n);
}

// --- abt.FDb.ind_targsrc.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_targsrc_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_targsrc_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FTargsrc*);
        u32 new_size = new_nbuckets * sizeof(abt::FTargsrc*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FTargsrc* *new_buckets = (abt::FTargsrc**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_targsrc");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_targsrc_buckets_n; i++) {
            abt::FTargsrc* elem = _db.ind_targsrc_buckets_elems[i];
            while (elem) {
                abt::FTargsrc &row        = *elem;
                abt::FTargsrc* next       = row.ind_targsrc_next;
                u32 index          = row.ind_targsrc_hashval & (new_nbuckets-1);
                row.ind_targsrc_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_targsrc_buckets_elems, old_size);
        _db.ind_targsrc_buckets_elems = new_buckets;
        _db.ind_targsrc_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.targsrc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FTargsrc& abt::targsrc_Alloc() {
    abt::FTargsrc* row = targsrc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.targsrc  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.targsrc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FTargsrc* abt::targsrc_AllocMaybe() {
    abt::FTargsrc *row = (abt::FTargsrc*)targsrc_AllocMem();
    if (row) {
        new (row) abt::FTargsrc; // call constructor
    }
    return row;
}

// --- abt.FDb.targsrc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FTargsrc* abt::targsrc_InsertMaybe(const dev::Targsrc &value) {
    abt::FTargsrc *row = &targsrc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targsrc_CopyIn(*row,const_cast<dev::Targsrc&>(value));
    bool ok = targsrc_XrefMaybe(*row); // this may return false
    if (!ok) {
        targsrc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.targsrc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::targsrc_AllocMem() {
    u64 new_nelems     = _db.targsrc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FTargsrc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targsrc_lary[bsr];
        if (!lev) {
            lev=(abt::FTargsrc*)abt::lpool_AllocMem(sizeof(abt::FTargsrc) * (u64(1)<<bsr));
            _db.targsrc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targsrc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.targsrc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::targsrc_RemoveLast() {
    u64 n = _db.targsrc_n;
    if (n > 0) {
        n -= 1;
        targsrc_qFind(u64(n)).~FTargsrc();
        _db.targsrc_n = i32(n);
    }
}

// --- abt.FDb.targsrc.InputMaybe
static bool abt::targsrc_InputMaybe(dev::Targsrc &elem) {
    bool retval = true;
    retval = targsrc_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.targsrc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::targsrc_XrefMaybe(abt::FTargsrc &row) {
    bool retval = true;
    (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // insert targsrc into index c_targsrc
    if (true) { // user-defined insert condition
        c_targsrc_Insert(*p_target, row);
    }
    // insert targsrc into index ind_targsrc
    if (true) { // user-defined insert condition
        bool success = ind_targsrc_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_targsrc"; // check for duplicate key
            return false;
        }
    }
    // targsrc: save pointer to target
    if (true) { // user-defined insert condition
        row.p_target = p_target;
    }
    return retval;
}

// --- abt.FDb.syscmddep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FSyscmddep& abt::syscmddep_Alloc() {
    abt::FSyscmddep* row = syscmddep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.syscmddep  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.syscmddep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FSyscmddep* abt::syscmddep_AllocMaybe() {
    abt::FSyscmddep *row = (abt::FSyscmddep*)syscmddep_AllocMem();
    if (row) {
        new (row) abt::FSyscmddep; // call constructor
    }
    return row;
}

// --- abt.FDb.syscmddep.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FSyscmddep* abt::syscmddep_InsertMaybe(const dev::Syscmddep &value) {
    abt::FSyscmddep *row = &syscmddep_Alloc(); // if out of memory, process dies. if input error, return NULL.
    syscmddep_CopyIn(*row,const_cast<dev::Syscmddep&>(value));
    bool ok = syscmddep_XrefMaybe(*row); // this may return false
    if (!ok) {
        syscmddep_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.syscmddep.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::syscmddep_AllocMem() {
    u64 new_nelems     = _db.syscmddep_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FSyscmddep*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.syscmddep_lary[bsr];
        if (!lev) {
            lev=(abt::FSyscmddep*)abt::lpool_AllocMem(sizeof(abt::FSyscmddep) * (u64(1)<<bsr));
            _db.syscmddep_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.syscmddep_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.syscmddep.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::syscmddep_RemoveLast() {
    u64 n = _db.syscmddep_n;
    if (n > 0) {
        n -= 1;
        syscmddep_qFind(u64(n)).~FSyscmddep();
        _db.syscmddep_n = i32(n);
    }
}

// --- abt.FDb.syscmddep.InputMaybe
static bool abt::syscmddep_InputMaybe(dev::Syscmddep &elem) {
    bool retval = true;
    retval = syscmddep_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.syscmddep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::syscmddep_XrefMaybe(abt::FSyscmddep &row) {
    bool retval = true;
    (void)row;
    abt::FSyscmd* p_child = abt::ind_syscmd_Find(row.child);
    if (UNLIKELY(!p_child)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_syscmd" << Keyval("key", row.child);
        return false;
    }
    // insert syscmddep into index c_prior
    if (true) { // user-defined insert condition
        c_prior_Insert(*p_child, row);
    }
    abt::FSyscmd* p_parent = abt::ind_syscmd_Find(row.parent);
    if (UNLIKELY(!p_parent)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_syscmd" << Keyval("key", row.parent);
        return false;
    }
    // insert syscmddep into index c_next
    if (true) { // user-defined insert condition
        c_next_Insert(*p_parent, row);
    }
    // syscmddep: save pointer to child
    if (true) { // user-defined insert condition
        row.p_child = p_child;
    }
    // syscmddep: save pointer to parent
    if (true) { // user-defined insert condition
        row.p_parent = p_parent;
    }
    return retval;
}

// --- abt.FDb.syscmd.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FSyscmd& abt::syscmd_Alloc() {
    abt::FSyscmd* row = syscmd_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.syscmd  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.syscmd.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FSyscmd* abt::syscmd_AllocMaybe() {
    abt::FSyscmd *row = (abt::FSyscmd*)syscmd_AllocMem();
    if (row) {
        new (row) abt::FSyscmd; // call constructor
        row->rowid = i32(syscmd_N() - 1);
    }
    return row;
}

// --- abt.FDb.syscmd.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FSyscmd* abt::syscmd_InsertMaybe(const dev::Syscmd &value) {
    abt::FSyscmd *row = &syscmd_Alloc(); // if out of memory, process dies. if input error, return NULL.
    syscmd_CopyIn(*row,const_cast<dev::Syscmd&>(value));
    bool ok = syscmd_XrefMaybe(*row); // this may return false
    if (!ok) {
        syscmd_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.syscmd.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::syscmd_AllocMem() {
    u64 new_nelems     = _db.syscmd_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FSyscmd*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.syscmd_lary[bsr];
        if (!lev) {
            lev=(abt::FSyscmd*)abt::lpool_AllocMem(sizeof(abt::FSyscmd) * (u64(1)<<bsr));
            _db.syscmd_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.syscmd_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.syscmd.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::syscmd_RemoveLast() {
    u64 n = _db.syscmd_n;
    if (n > 0) {
        n -= 1;
        syscmd_qFind(i32(n)).~FSyscmd();
        _db.syscmd_n = i32(n);
    }
}

// --- abt.FDb.syscmd.InputMaybe
static bool abt::syscmd_InputMaybe(dev::Syscmd &elem) {
    bool retval = true;
    retval = syscmd_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.syscmd.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::syscmd_XrefMaybe(abt::FSyscmd &row) {
    bool retval = true;
    (void)row;
    // insert syscmd into index ind_syscmd
    if (true) { // user-defined insert condition
        bool success = ind_syscmd_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_syscmd"; // check for duplicate key
            return false;
        }
    }
    // insert syscmd into index ind_running
    if (row.pid != 0) { // user-defined insert condition
        bool success = ind_running_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_running"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     abt.FDb.cmdline
//     algo_lib.FDb.cmdline
void abt::ReadArgv() {
    command::abt &cmd = abt::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    int anonidx=0;
    algo::strptr nextanon = command::abt_GetAnon(cmd, anonidx);
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::abt_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"abt: unknown option "<<Keyval("value",arg)<<eol;
            } else {
                if (isanon) {
                    if (attrname == nextanon) { // treat named anon (positional) argument as unnamed
                        attrname = ""; // treat it as unnamed
                    } else if (nextanon != "") { // disallow out-of-order anon (positional) args
                        err<<"abt: error at "<<algo::strptr_ToSsim(arg)<<": must be preceded by [-"<<nextanon<<"]"<<eol;
                    }
                }
            }
        }
        // look up anon field name based on index
        // anon fields are only allowed in the leaf ns, never base
        if (ch_N(attrname) == 0) {
            attrname = nextanon;
            nextanon = command::abt_GetAnon(cmd, ++anonidx);
            command::FieldId_ReadStrptrMaybe(attrid,attrname);
            whichns=1;
        }
        if (ch_N(attrname) == 0) {
            err << "abt: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        } else if (haveval) {
            // read value into currently selected arg
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::abt_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"abt: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    algo_lib_logcat_debug.enabled = algo_lib::_db.cmdline.debug;
    algo_lib_logcat_verbose.enabled = algo_lib::_db.cmdline.verbose > 0;
    algo_lib_logcat_verbose2.enabled = algo_lib::_db.cmdline.verbose > 1;
    if (!dohelp) {
    }
    // dmmeta.floadtuples:abt.FDb.cmdline
    if (!dohelp && err=="") {
        algo_lib::ResetErrtext();
        if (!abt::LoadTuplesMaybe(cmd.in,true)) {
            err << "abt.load_input  "<<algo_lib::DetachBadTags()<<eol;
        }
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr_(err); // already has eol
        doexit=true;
    }
    if (dohelp) {
        prlog(abt_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
}

// --- abt.FDb._db.MainLoop
// Main loop.
void abt::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        abt::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- abt.FDb._db.Step
// Main step
void abt::Step() {
}

// --- abt.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void abt::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("abt", abt::InsertStrptrMaybe, NULL, abt::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "abt.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(abt::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)abt::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'abt.Input'  signature:'a3467e9a802a9e293d88ca8cb2cead5a09c85dcf'");
}

// --- abt.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool abt::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    abt::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case abt_TableId_dev_Targdep: { // finput:abt.FDb.targdep
            dev::Targdep elem;
            retval = dev::Targdep_ReadStrptrMaybe(elem, str);
            retval = retval && targdep_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_ToolOpt: { // finput:abt.FDb.tool_opt
            dev::ToolOpt elem;
            retval = dev::ToolOpt_ReadStrptrMaybe(elem, str);
            retval = retval && tool_opt_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Target: { // finput:abt.FDb.target
            dev::Target elem;
            retval = dev::Target_ReadStrptrMaybe(elem, str);
            retval = retval && target_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Targsrc: { // finput:abt.FDb.targsrc
            dev::Targsrc elem;
            retval = dev::Targsrc_ReadStrptrMaybe(elem, str);
            retval = retval && targsrc_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Syscmddep: { // finput:abt.FDb.syscmddep
            dev::Syscmddep elem;
            retval = dev::Syscmddep_ReadStrptrMaybe(elem, str);
            retval = retval && syscmddep_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Syscmd: { // finput:abt.FDb.syscmd
            dev::Syscmd elem;
            retval = dev::Syscmd_ReadStrptrMaybe(elem, str);
            retval = retval && syscmd_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Cfg: { // finput:abt.FDb.cfg
            dev::Cfg elem;
            retval = dev::Cfg_ReadStrptrMaybe(elem, str);
            retval = retval && cfg_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Uname: { // finput:abt.FDb.uname
            dev::Uname elem;
            retval = dev::Uname_ReadStrptrMaybe(elem, str);
            retval = retval && uname_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Compiler: { // finput:abt.FDb.compiler
            dev::Compiler elem;
            retval = dev::Compiler_ReadStrptrMaybe(elem, str);
            retval = retval && compiler_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Arch: { // finput:abt.FDb.arch
            dev::Arch elem;
            retval = dev::Arch_ReadStrptrMaybe(elem, str);
            retval = retval && arch_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Targsyslib: { // finput:abt.FDb.targsyslib
            dev::Targsyslib elem;
            retval = dev::Targsyslib_ReadStrptrMaybe(elem, str);
            retval = retval && targsyslib_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Syslib: { // finput:abt.FDb.syslib
            dev::Syslib elem;
            retval = dev::Syslib_ReadStrptrMaybe(elem, str);
            retval = retval && syslib_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Include: { // finput:abt.FDb.include
            dev::Include elem;
            retval = dev::Include_ReadStrptrMaybe(elem, str);
            retval = retval && include_InputMaybe(elem);
            break;
        }
        case abt_TableId_dmmeta_Ns: { // finput:abt.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            break;
        }
        case abt_TableId_dev_Builddir: { // finput:abt.FDb.builddir
            dev::Builddir elem;
            retval = dev::Builddir_ReadStrptrMaybe(elem, str);
            retval = retval && builddir_InputMaybe(elem);
            break;
        }
        default:
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- abt.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool abt::LoadTuplesMaybe(algo::strptr root, bool recursive) {
    bool retval = true;
    if (FileQ(root)) {
        retval = abt::LoadTuplesFile(root, recursive);
    } else if (root == "-") {
        retval = abt::LoadTuplesFd(algo::Fildes(0),"(stdin)",recursive);
    } else if (DirectoryQ(root)) {
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ns"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dmmeta.dispsigcheck"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.uname"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.tool_opt"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.target"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.syslib"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.targsyslib"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.targsrc"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.targdep"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.syscmd"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.syscmddep"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.include"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.compiler"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.cfg"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.arch"),recursive);
        retval = retval && abt::LoadTuplesFile(algo::SsimFname(root,"dev.builddir"),recursive);
    } else {
        algo_lib::AppendErrtext("path", root);
        algo_lib::AppendErrtext("comment", "Wrong working directory?");
        retval = false;
    }
    return retval;
}

// --- abt.FDb._db.LoadTuplesFile
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
bool abt::LoadTuplesFile(algo::strptr fname, bool recursive) {
    bool retval = true;
    algo_lib::FFildes fildes;
    // missing files are not an error
    fildes.fd = OpenRead(fname,algo::FileFlags());
    if (ValidQ(fildes.fd)) {
        retval = LoadTuplesFd(fildes.fd, fname, recursive);
    }
    return retval;
}

// --- abt.FDb._db.LoadTuplesFd
// Load all finputs from given file descriptor.
bool abt::LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) {
    bool retval = true;
    ind_beg(algo::FileLine_curs,line,fd) {
        if (recursive) {
            retval = retval && algo_lib::InsertStrptrMaybe(line);
        }
        retval = retval && abt::InsertStrptrMaybe(line);
        if (!retval) {
            algo_lib::_db.errtext << eol
            << fname << ":"
            << (ind_curs(line).i+1)
            << ": " << line << eol;
            break;
        }
    }ind_end;
    return retval;
}

// --- abt.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool abt::LoadSsimfileMaybe(algo::strptr fname, bool recursive) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = abt::LoadTuplesFile(fname, recursive);
    }
    return retval;
}

// --- abt.FDb._db.Steps
// Calls Step function of dependencies
void abt::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- abt.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- abt.FDb.ind_syscmd.Find
// Find row by key. Return NULL if not found.
abt::FSyscmd* abt::ind_syscmd_Find(i64 key) {
    u32 index = ::i64_Hash(0, key) & (_db.ind_syscmd_buckets_n - 1);
    abt::FSyscmd *ret = _db.ind_syscmd_buckets_elems[index];
    for (; ret && !((*ret).syscmd == key); ret = ret->ind_syscmd_next) {
    }
    return ret;
}

// --- abt.FDb.ind_syscmd.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FSyscmd& abt::ind_syscmd_GetOrCreate(i64 key) {
    abt::FSyscmd* ret = ind_syscmd_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &syscmd_Alloc();
        (*ret).syscmd = key;
        bool good = syscmd_XrefMaybe(*ret);
        if (!good) {
            syscmd_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_syscmd  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_syscmd.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_syscmd_InsertMaybe(abt::FSyscmd& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_syscmd_next == (abt::FSyscmd*)-1)) {// check if in hash already
        row.ind_syscmd_hashval = ::i64_Hash(0, row.syscmd);
        ind_syscmd_Reserve(1);
        u32 index = row.ind_syscmd_hashval & (_db.ind_syscmd_buckets_n - 1);
        abt::FSyscmd* *prev = &_db.ind_syscmd_buckets_elems[index];
        do {
            abt::FSyscmd* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).syscmd == row.syscmd) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_syscmd_next;
        } while (true);
        if (retval) {
            row.ind_syscmd_next = *prev;
            _db.ind_syscmd_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_syscmd.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_syscmd_Remove(abt::FSyscmd& row) {
    if (LIKELY(row.ind_syscmd_next != (abt::FSyscmd*)-1)) {// check if in hash already
        u32 index = row.ind_syscmd_hashval & (_db.ind_syscmd_buckets_n - 1);
        abt::FSyscmd* *prev = &_db.ind_syscmd_buckets_elems[index]; // addr of pointer to current element
        while (abt::FSyscmd *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_syscmd_next; // unlink (singly linked list)
                _db.ind_syscmd_n--;
                row.ind_syscmd_next = (abt::FSyscmd*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_syscmd_next;
        }
    }
}

// --- abt.FDb.ind_syscmd.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_syscmd_Reserve(int n) {
    ind_syscmd_AbsReserve(_db.ind_syscmd_n + n);
}

// --- abt.FDb.ind_syscmd.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_syscmd_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_syscmd_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FSyscmd*);
        u32 new_size = new_nbuckets * sizeof(abt::FSyscmd*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FSyscmd* *new_buckets = (abt::FSyscmd**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_syscmd");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_syscmd_buckets_n; i++) {
            abt::FSyscmd* elem = _db.ind_syscmd_buckets_elems[i];
            while (elem) {
                abt::FSyscmd &row        = *elem;
                abt::FSyscmd* next       = row.ind_syscmd_next;
                u32 index          = row.ind_syscmd_hashval & (new_nbuckets-1);
                row.ind_syscmd_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_syscmd_buckets_elems, old_size);
        _db.ind_syscmd_buckets_elems = new_buckets;
        _db.ind_syscmd_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.ind_running.Find
// Find row by key. Return NULL if not found.
abt::FSyscmd* abt::ind_running_Find(i32 key) {
    u32 index = ::i32_Hash(0, key) & (_db.ind_running_buckets_n - 1);
    abt::FSyscmd *ret = _db.ind_running_buckets_elems[index];
    for (; ret && !((*ret).pid == key); ret = ret->ind_running_next) {
    }
    return ret;
}

// --- abt.FDb.ind_running.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FSyscmd& abt::ind_running_GetOrCreate(i32 key) {
    abt::FSyscmd* ret = ind_running_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &syscmd_Alloc();
        (*ret).pid = key;
        bool good = syscmd_XrefMaybe(*ret);
        if (!good) {
            syscmd_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_running  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_running.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_running_InsertMaybe(abt::FSyscmd& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_running_next == (abt::FSyscmd*)-1)) {// check if in hash already
        row.ind_running_hashval = ::i32_Hash(0, row.pid);
        ind_running_Reserve(1);
        u32 index = row.ind_running_hashval & (_db.ind_running_buckets_n - 1);
        abt::FSyscmd* *prev = &_db.ind_running_buckets_elems[index];
        do {
            abt::FSyscmd* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).pid == row.pid) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_running_next;
        } while (true);
        if (retval) {
            row.ind_running_next = *prev;
            _db.ind_running_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_running.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_running_Remove(abt::FSyscmd& row) {
    if (LIKELY(row.ind_running_next != (abt::FSyscmd*)-1)) {// check if in hash already
        u32 index = row.ind_running_hashval & (_db.ind_running_buckets_n - 1);
        abt::FSyscmd* *prev = &_db.ind_running_buckets_elems[index]; // addr of pointer to current element
        while (abt::FSyscmd *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_running_next; // unlink (singly linked list)
                _db.ind_running_n--;
                row.ind_running_next = (abt::FSyscmd*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_running_next;
        }
    }
}

// --- abt.FDb.ind_running.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_running_Reserve(int n) {
    ind_running_AbsReserve(_db.ind_running_n + n);
}

// --- abt.FDb.ind_running.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_running_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_running_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FSyscmd*);
        u32 new_size = new_nbuckets * sizeof(abt::FSyscmd*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FSyscmd* *new_buckets = (abt::FSyscmd**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_running");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_running_buckets_n; i++) {
            abt::FSyscmd* elem = _db.ind_running_buckets_elems[i];
            while (elem) {
                abt::FSyscmd &row        = *elem;
                abt::FSyscmd* next       = row.ind_running_next;
                u32 index          = row.ind_running_hashval & (new_nbuckets-1);
                row.ind_running_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_running_buckets_elems, old_size);
        _db.ind_running_buckets_elems = new_buckets;
        _db.ind_running_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.ind_srcfile.Find
// Find row by key. Return NULL if not found.
abt::FSrcfile* abt::ind_srcfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr200_Hash(0, key) & (_db.ind_srcfile_buckets_n - 1);
    abt::FSrcfile *ret = _db.ind_srcfile_buckets_elems[index];
    for (; ret && !((*ret).srcfile == key); ret = ret->ind_srcfile_next) {
    }
    return ret;
}

// --- abt.FDb.ind_srcfile.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FSrcfile& abt::ind_srcfile_GetOrCreate(const algo::strptr& key) {
    abt::FSrcfile* ret = ind_srcfile_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &srcfile_Alloc();
        (*ret).srcfile = key;
        bool good = srcfile_XrefMaybe(*ret);
        if (!good) {
            srcfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_srcfile  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_srcfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_srcfile_InsertMaybe(abt::FSrcfile& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_srcfile_next == (abt::FSrcfile*)-1)) {// check if in hash already
        row.ind_srcfile_hashval = algo::Smallstr200_Hash(0, row.srcfile);
        ind_srcfile_Reserve(1);
        u32 index = row.ind_srcfile_hashval & (_db.ind_srcfile_buckets_n - 1);
        abt::FSrcfile* *prev = &_db.ind_srcfile_buckets_elems[index];
        do {
            abt::FSrcfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).srcfile == row.srcfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_srcfile_next;
        } while (true);
        if (retval) {
            row.ind_srcfile_next = *prev;
            _db.ind_srcfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_srcfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_srcfile_Remove(abt::FSrcfile& row) {
    if (LIKELY(row.ind_srcfile_next != (abt::FSrcfile*)-1)) {// check if in hash already
        u32 index = row.ind_srcfile_hashval & (_db.ind_srcfile_buckets_n - 1);
        abt::FSrcfile* *prev = &_db.ind_srcfile_buckets_elems[index]; // addr of pointer to current element
        while (abt::FSrcfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_srcfile_next; // unlink (singly linked list)
                _db.ind_srcfile_n--;
                row.ind_srcfile_next = (abt::FSrcfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_srcfile_next;
        }
    }
}

// --- abt.FDb.ind_srcfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_srcfile_Reserve(int n) {
    ind_srcfile_AbsReserve(_db.ind_srcfile_n + n);
}

// --- abt.FDb.ind_srcfile.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_srcfile_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_srcfile_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FSrcfile*);
        u32 new_size = new_nbuckets * sizeof(abt::FSrcfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FSrcfile* *new_buckets = (abt::FSrcfile**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_srcfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_srcfile_buckets_n; i++) {
            abt::FSrcfile* elem = _db.ind_srcfile_buckets_elems[i];
            while (elem) {
                abt::FSrcfile &row        = *elem;
                abt::FSrcfile* next       = row.ind_srcfile_next;
                u32 index          = row.ind_srcfile_hashval & (new_nbuckets-1);
                row.ind_srcfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_srcfile_buckets_elems, old_size);
        _db.ind_srcfile_buckets_elems = new_buckets;
        _db.ind_srcfile_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.cfg.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FCfg& abt::cfg_Alloc() {
    abt::FCfg* row = cfg_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.cfg  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.cfg.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FCfg* abt::cfg_AllocMaybe() {
    abt::FCfg *row = (abt::FCfg*)cfg_AllocMem();
    if (row) {
        new (row) abt::FCfg; // call constructor
    }
    return row;
}

// --- abt.FDb.cfg.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FCfg* abt::cfg_InsertMaybe(const dev::Cfg &value) {
    abt::FCfg *row = &cfg_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cfg_CopyIn(*row,const_cast<dev::Cfg&>(value));
    bool ok = cfg_XrefMaybe(*row); // this may return false
    if (!ok) {
        cfg_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.cfg.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::cfg_AllocMem() {
    u64 new_nelems     = _db.cfg_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FCfg*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cfg_lary[bsr];
        if (!lev) {
            lev=(abt::FCfg*)abt::lpool_AllocMem(sizeof(abt::FCfg) * (u64(1)<<bsr));
            _db.cfg_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cfg_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.cfg.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::cfg_RemoveLast() {
    u64 n = _db.cfg_n;
    if (n > 0) {
        n -= 1;
        cfg_qFind(u64(n)).~FCfg();
        _db.cfg_n = i32(n);
    }
}

// --- abt.FDb.cfg.InputMaybe
static bool abt::cfg_InputMaybe(dev::Cfg &elem) {
    bool retval = true;
    retval = cfg_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.cfg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::cfg_XrefMaybe(abt::FCfg &row) {
    bool retval = true;
    (void)row;
    // insert cfg into index ind_cfg
    if (true) { // user-defined insert condition
        bool success = ind_cfg_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_cfg"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_cfg.Find
// Find row by key. Return NULL if not found.
abt::FCfg* abt::ind_cfg_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_cfg_buckets_n - 1);
    abt::FCfg *ret = _db.ind_cfg_buckets_elems[index];
    for (; ret && !((*ret).cfg == key); ret = ret->ind_cfg_next) {
    }
    return ret;
}

// --- abt.FDb.ind_cfg.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FCfg& abt::ind_cfg_GetOrCreate(const algo::strptr& key) {
    abt::FCfg* ret = ind_cfg_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &cfg_Alloc();
        (*ret).cfg = key;
        bool good = cfg_XrefMaybe(*ret);
        if (!good) {
            cfg_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_cfg  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_cfg.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_cfg_InsertMaybe(abt::FCfg& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_cfg_next == (abt::FCfg*)-1)) {// check if in hash already
        row.ind_cfg_hashval = algo::Smallstr50_Hash(0, row.cfg);
        ind_cfg_Reserve(1);
        u32 index = row.ind_cfg_hashval & (_db.ind_cfg_buckets_n - 1);
        abt::FCfg* *prev = &_db.ind_cfg_buckets_elems[index];
        do {
            abt::FCfg* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).cfg == row.cfg) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_cfg_next;
        } while (true);
        if (retval) {
            row.ind_cfg_next = *prev;
            _db.ind_cfg_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_cfg.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_cfg_Remove(abt::FCfg& row) {
    if (LIKELY(row.ind_cfg_next != (abt::FCfg*)-1)) {// check if in hash already
        u32 index = row.ind_cfg_hashval & (_db.ind_cfg_buckets_n - 1);
        abt::FCfg* *prev = &_db.ind_cfg_buckets_elems[index]; // addr of pointer to current element
        while (abt::FCfg *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_cfg_next; // unlink (singly linked list)
                _db.ind_cfg_n--;
                row.ind_cfg_next = (abt::FCfg*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_cfg_next;
        }
    }
}

// --- abt.FDb.ind_cfg.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_cfg_Reserve(int n) {
    ind_cfg_AbsReserve(_db.ind_cfg_n + n);
}

// --- abt.FDb.ind_cfg.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_cfg_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_cfg_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FCfg*);
        u32 new_size = new_nbuckets * sizeof(abt::FCfg*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FCfg* *new_buckets = (abt::FCfg**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_cfg");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_cfg_buckets_n; i++) {
            abt::FCfg* elem = _db.ind_cfg_buckets_elems[i];
            while (elem) {
                abt::FCfg &row        = *elem;
                abt::FCfg* next       = row.ind_cfg_next;
                u32 index          = row.ind_cfg_hashval & (new_nbuckets-1);
                row.ind_cfg_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_cfg_buckets_elems, old_size);
        _db.ind_cfg_buckets_elems = new_buckets;
        _db.ind_cfg_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.uname.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FUname& abt::uname_Alloc() {
    abt::FUname* row = uname_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.uname  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.uname.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FUname* abt::uname_AllocMaybe() {
    abt::FUname *row = (abt::FUname*)uname_AllocMem();
    if (row) {
        new (row) abt::FUname; // call constructor
    }
    return row;
}

// --- abt.FDb.uname.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FUname* abt::uname_InsertMaybe(const dev::Uname &value) {
    abt::FUname *row = &uname_Alloc(); // if out of memory, process dies. if input error, return NULL.
    uname_CopyIn(*row,const_cast<dev::Uname&>(value));
    bool ok = uname_XrefMaybe(*row); // this may return false
    if (!ok) {
        uname_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.uname.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::uname_AllocMem() {
    u64 new_nelems     = _db.uname_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FUname*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.uname_lary[bsr];
        if (!lev) {
            lev=(abt::FUname*)abt::lpool_AllocMem(sizeof(abt::FUname) * (u64(1)<<bsr));
            _db.uname_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.uname_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.uname.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::uname_RemoveLast() {
    u64 n = _db.uname_n;
    if (n > 0) {
        n -= 1;
        uname_qFind(u64(n)).~FUname();
        _db.uname_n = i32(n);
    }
}

// --- abt.FDb.uname.InputMaybe
static bool abt::uname_InputMaybe(dev::Uname &elem) {
    bool retval = true;
    retval = uname_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.uname.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::uname_XrefMaybe(abt::FUname &row) {
    bool retval = true;
    (void)row;
    // insert uname into index ind_uname
    if (true) { // user-defined insert condition
        bool success = ind_uname_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_uname"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_uname.Find
// Find row by key. Return NULL if not found.
abt::FUname* abt::ind_uname_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_uname_buckets_n - 1);
    abt::FUname *ret = _db.ind_uname_buckets_elems[index];
    for (; ret && !((*ret).uname == key); ret = ret->ind_uname_next) {
    }
    return ret;
}

// --- abt.FDb.ind_uname.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FUname& abt::ind_uname_GetOrCreate(const algo::strptr& key) {
    abt::FUname* ret = ind_uname_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &uname_Alloc();
        (*ret).uname = key;
        bool good = uname_XrefMaybe(*ret);
        if (!good) {
            uname_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_uname  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_uname.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_uname_InsertMaybe(abt::FUname& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_uname_next == (abt::FUname*)-1)) {// check if in hash already
        row.ind_uname_hashval = algo::Smallstr50_Hash(0, row.uname);
        ind_uname_Reserve(1);
        u32 index = row.ind_uname_hashval & (_db.ind_uname_buckets_n - 1);
        abt::FUname* *prev = &_db.ind_uname_buckets_elems[index];
        do {
            abt::FUname* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).uname == row.uname) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_uname_next;
        } while (true);
        if (retval) {
            row.ind_uname_next = *prev;
            _db.ind_uname_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_uname.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_uname_Remove(abt::FUname& row) {
    if (LIKELY(row.ind_uname_next != (abt::FUname*)-1)) {// check if in hash already
        u32 index = row.ind_uname_hashval & (_db.ind_uname_buckets_n - 1);
        abt::FUname* *prev = &_db.ind_uname_buckets_elems[index]; // addr of pointer to current element
        while (abt::FUname *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_uname_next; // unlink (singly linked list)
                _db.ind_uname_n--;
                row.ind_uname_next = (abt::FUname*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_uname_next;
        }
    }
}

// --- abt.FDb.ind_uname.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_uname_Reserve(int n) {
    ind_uname_AbsReserve(_db.ind_uname_n + n);
}

// --- abt.FDb.ind_uname.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_uname_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_uname_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FUname*);
        u32 new_size = new_nbuckets * sizeof(abt::FUname*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FUname* *new_buckets = (abt::FUname**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_uname");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_uname_buckets_n; i++) {
            abt::FUname* elem = _db.ind_uname_buckets_elems[i];
            while (elem) {
                abt::FUname &row        = *elem;
                abt::FUname* next       = row.ind_uname_next;
                u32 index          = row.ind_uname_hashval & (new_nbuckets-1);
                row.ind_uname_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_uname_buckets_elems, old_size);
        _db.ind_uname_buckets_elems = new_buckets;
        _db.ind_uname_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.compiler.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FCompiler& abt::compiler_Alloc() {
    abt::FCompiler* row = compiler_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.compiler  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.compiler.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FCompiler* abt::compiler_AllocMaybe() {
    abt::FCompiler *row = (abt::FCompiler*)compiler_AllocMem();
    if (row) {
        new (row) abt::FCompiler; // call constructor
    }
    return row;
}

// --- abt.FDb.compiler.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FCompiler* abt::compiler_InsertMaybe(const dev::Compiler &value) {
    abt::FCompiler *row = &compiler_Alloc(); // if out of memory, process dies. if input error, return NULL.
    compiler_CopyIn(*row,const_cast<dev::Compiler&>(value));
    bool ok = compiler_XrefMaybe(*row); // this may return false
    if (!ok) {
        compiler_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.compiler.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::compiler_AllocMem() {
    u64 new_nelems     = _db.compiler_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FCompiler*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.compiler_lary[bsr];
        if (!lev) {
            lev=(abt::FCompiler*)abt::lpool_AllocMem(sizeof(abt::FCompiler) * (u64(1)<<bsr));
            _db.compiler_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.compiler_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.compiler.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::compiler_RemoveLast() {
    u64 n = _db.compiler_n;
    if (n > 0) {
        n -= 1;
        compiler_qFind(u64(n)).~FCompiler();
        _db.compiler_n = i32(n);
    }
}

// --- abt.FDb.compiler.InputMaybe
static bool abt::compiler_InputMaybe(dev::Compiler &elem) {
    bool retval = true;
    retval = compiler_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.compiler.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::compiler_XrefMaybe(abt::FCompiler &row) {
    bool retval = true;
    (void)row;
    // insert compiler into index ind_compiler
    if (true) { // user-defined insert condition
        bool success = ind_compiler_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_compiler"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_compiler.Find
// Find row by key. Return NULL if not found.
abt::FCompiler* abt::ind_compiler_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_compiler_buckets_n - 1);
    abt::FCompiler *ret = _db.ind_compiler_buckets_elems[index];
    for (; ret && !((*ret).compiler == key); ret = ret->ind_compiler_next) {
    }
    return ret;
}

// --- abt.FDb.ind_compiler.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FCompiler& abt::ind_compiler_GetOrCreate(const algo::strptr& key) {
    abt::FCompiler* ret = ind_compiler_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &compiler_Alloc();
        (*ret).compiler = key;
        bool good = compiler_XrefMaybe(*ret);
        if (!good) {
            compiler_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_compiler  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_compiler.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_compiler_InsertMaybe(abt::FCompiler& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_compiler_next == (abt::FCompiler*)-1)) {// check if in hash already
        row.ind_compiler_hashval = algo::Smallstr50_Hash(0, row.compiler);
        ind_compiler_Reserve(1);
        u32 index = row.ind_compiler_hashval & (_db.ind_compiler_buckets_n - 1);
        abt::FCompiler* *prev = &_db.ind_compiler_buckets_elems[index];
        do {
            abt::FCompiler* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).compiler == row.compiler) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_compiler_next;
        } while (true);
        if (retval) {
            row.ind_compiler_next = *prev;
            _db.ind_compiler_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_compiler.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_compiler_Remove(abt::FCompiler& row) {
    if (LIKELY(row.ind_compiler_next != (abt::FCompiler*)-1)) {// check if in hash already
        u32 index = row.ind_compiler_hashval & (_db.ind_compiler_buckets_n - 1);
        abt::FCompiler* *prev = &_db.ind_compiler_buckets_elems[index]; // addr of pointer to current element
        while (abt::FCompiler *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_compiler_next; // unlink (singly linked list)
                _db.ind_compiler_n--;
                row.ind_compiler_next = (abt::FCompiler*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_compiler_next;
        }
    }
}

// --- abt.FDb.ind_compiler.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_compiler_Reserve(int n) {
    ind_compiler_AbsReserve(_db.ind_compiler_n + n);
}

// --- abt.FDb.ind_compiler.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_compiler_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_compiler_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FCompiler*);
        u32 new_size = new_nbuckets * sizeof(abt::FCompiler*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FCompiler* *new_buckets = (abt::FCompiler**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_compiler");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_compiler_buckets_n; i++) {
            abt::FCompiler* elem = _db.ind_compiler_buckets_elems[i];
            while (elem) {
                abt::FCompiler &row        = *elem;
                abt::FCompiler* next       = row.ind_compiler_next;
                u32 index          = row.ind_compiler_hashval & (new_nbuckets-1);
                row.ind_compiler_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_compiler_buckets_elems, old_size);
        _db.ind_compiler_buckets_elems = new_buckets;
        _db.ind_compiler_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.arch.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FArch& abt::arch_Alloc() {
    abt::FArch* row = arch_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.arch  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.arch.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FArch* abt::arch_AllocMaybe() {
    abt::FArch *row = (abt::FArch*)arch_AllocMem();
    if (row) {
        new (row) abt::FArch; // call constructor
    }
    return row;
}

// --- abt.FDb.arch.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FArch* abt::arch_InsertMaybe(const dev::Arch &value) {
    abt::FArch *row = &arch_Alloc(); // if out of memory, process dies. if input error, return NULL.
    arch_CopyIn(*row,const_cast<dev::Arch&>(value));
    bool ok = arch_XrefMaybe(*row); // this may return false
    if (!ok) {
        arch_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.arch.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::arch_AllocMem() {
    u64 new_nelems     = _db.arch_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FArch*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.arch_lary[bsr];
        if (!lev) {
            lev=(abt::FArch*)abt::lpool_AllocMem(sizeof(abt::FArch) * (u64(1)<<bsr));
            _db.arch_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.arch_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.arch.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::arch_RemoveLast() {
    u64 n = _db.arch_n;
    if (n > 0) {
        n -= 1;
        arch_qFind(u64(n)).~FArch();
        _db.arch_n = i32(n);
    }
}

// --- abt.FDb.arch.InputMaybe
static bool abt::arch_InputMaybe(dev::Arch &elem) {
    bool retval = true;
    retval = arch_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.arch.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::arch_XrefMaybe(abt::FArch &row) {
    bool retval = true;
    (void)row;
    // insert arch into index ind_arch
    if (true) { // user-defined insert condition
        bool success = ind_arch_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_arch"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_arch.Find
// Find row by key. Return NULL if not found.
abt::FArch* abt::ind_arch_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_arch_buckets_n - 1);
    abt::FArch *ret = _db.ind_arch_buckets_elems[index];
    for (; ret && !((*ret).arch == key); ret = ret->ind_arch_next) {
    }
    return ret;
}

// --- abt.FDb.ind_arch.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FArch& abt::ind_arch_GetOrCreate(const algo::strptr& key) {
    abt::FArch* ret = ind_arch_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &arch_Alloc();
        (*ret).arch = key;
        bool good = arch_XrefMaybe(*ret);
        if (!good) {
            arch_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_arch  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_arch.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_arch_InsertMaybe(abt::FArch& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_arch_next == (abt::FArch*)-1)) {// check if in hash already
        row.ind_arch_hashval = algo::Smallstr50_Hash(0, row.arch);
        ind_arch_Reserve(1);
        u32 index = row.ind_arch_hashval & (_db.ind_arch_buckets_n - 1);
        abt::FArch* *prev = &_db.ind_arch_buckets_elems[index];
        do {
            abt::FArch* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).arch == row.arch) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_arch_next;
        } while (true);
        if (retval) {
            row.ind_arch_next = *prev;
            _db.ind_arch_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_arch.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_arch_Remove(abt::FArch& row) {
    if (LIKELY(row.ind_arch_next != (abt::FArch*)-1)) {// check if in hash already
        u32 index = row.ind_arch_hashval & (_db.ind_arch_buckets_n - 1);
        abt::FArch* *prev = &_db.ind_arch_buckets_elems[index]; // addr of pointer to current element
        while (abt::FArch *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_arch_next; // unlink (singly linked list)
                _db.ind_arch_n--;
                row.ind_arch_next = (abt::FArch*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_arch_next;
        }
    }
}

// --- abt.FDb.ind_arch.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_arch_Reserve(int n) {
    ind_arch_AbsReserve(_db.ind_arch_n + n);
}

// --- abt.FDb.ind_arch.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_arch_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_arch_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FArch*);
        u32 new_size = new_nbuckets * sizeof(abt::FArch*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FArch* *new_buckets = (abt::FArch**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_arch");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_arch_buckets_n; i++) {
            abt::FArch* elem = _db.ind_arch_buckets_elems[i];
            while (elem) {
                abt::FArch &row        = *elem;
                abt::FArch* next       = row.ind_arch_next;
                u32 index          = row.ind_arch_hashval & (new_nbuckets-1);
                row.ind_arch_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_arch_buckets_elems, old_size);
        _db.ind_arch_buckets_elems = new_buckets;
        _db.ind_arch_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.bh_syscmd.Dealloc
// Remove all elements from heap and free memory used by the array.
void abt::bh_syscmd_Dealloc() {
    bh_syscmd_RemoveAll();
    abt::lpool_FreeMem(_db.bh_syscmd_elems, sizeof(abt::FSyscmd*)*_db.bh_syscmd_max);
    _db.bh_syscmd_max   = 0;
    _db.bh_syscmd_elems = NULL;
}

// --- abt.FDb.bh_syscmd.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int abt::bh_syscmd_Downheap(abt::FSyscmd& row, int idx) {
    abt::FSyscmd* *elems = _db.bh_syscmd_elems;
    int n = _db.bh_syscmd_n;
    int child = idx*2+1;
    while (child < n) {
        abt::FSyscmd* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            abt::FSyscmd* q = elems[rchild]; // right child
            if (bh_syscmd_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_syscmd_ElemLt(*p,row)) {
            break;
        }
        p->bh_syscmd_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- abt.FDb.bh_syscmd.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void abt::bh_syscmd_Insert(abt::FSyscmd& row) {
    if (LIKELY(row.bh_syscmd_idx == -1)) {
        bh_syscmd_Reserve(1);
        int n = _db.bh_syscmd_n;
        _db.bh_syscmd_n = n + 1;
        int new_idx = bh_syscmd_Upheap(row, n);
        row.bh_syscmd_idx = new_idx;
        _db.bh_syscmd_elems[new_idx] = &row;
    }
}

// --- abt.FDb.bh_syscmd.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 abt::bh_syscmd_Reheap(abt::FSyscmd& row) {
    int old_idx = row.bh_syscmd_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_syscmd_Reserve(1);
        old_idx = _db.bh_syscmd_n++;
    }
    int new_idx = bh_syscmd_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_syscmd_Downheap(row, old_idx);
    }
    row.bh_syscmd_idx = new_idx;
    _db.bh_syscmd_elems[new_idx] = &row;
    return new_idx;
}

// --- abt.FDb.bh_syscmd.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 abt::bh_syscmd_ReheapFirst() {
    abt::FSyscmd &row = *_db.bh_syscmd_elems[0];
    i32 new_idx = bh_syscmd_Downheap(row, 0);
    row.bh_syscmd_idx = new_idx;
    _db.bh_syscmd_elems[new_idx] = &row;
    return new_idx;
}

// --- abt.FDb.bh_syscmd.Remove
// Remove element from index. If element is not in index, do nothing.
void abt::bh_syscmd_Remove(abt::FSyscmd& row) {
    if (bh_syscmd_InBheapQ(row)) {
        int old_idx = row.bh_syscmd_idx;
        if (_db.bh_syscmd_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_syscmd_idx = -1;           // mark not in heap
            i32 n = _db.bh_syscmd_n - 1; // index of last element in heap
            _db.bh_syscmd_n = n;         // decrease count
            if (old_idx != n) {
                abt::FSyscmd *elem = _db.bh_syscmd_elems[n];
                int new_idx = bh_syscmd_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_syscmd_Downheap(*elem, old_idx);
                }
                elem->bh_syscmd_idx = new_idx;
                _db.bh_syscmd_elems[new_idx] = elem;
            }
        }
    }
}

// --- abt.FDb.bh_syscmd.RemoveAll
// Remove all elements from binary heap
void abt::bh_syscmd_RemoveAll() {
    int n = _db.bh_syscmd_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_syscmd_elems[i]->bh_syscmd_idx = -1; // mark not-in-heap
    }
    _db.bh_syscmd_n = 0;
}

// --- abt.FDb.bh_syscmd.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
abt::FSyscmd* abt::bh_syscmd_RemoveFirst() {
    abt::FSyscmd *row = NULL;
    if (_db.bh_syscmd_n > 0) {
        row = _db.bh_syscmd_elems[0];
        row->bh_syscmd_idx = -1;           // mark not in heap
        i32 n = _db.bh_syscmd_n - 1; // index of last element in heap
        _db.bh_syscmd_n = n;         // decrease count
        if (n) {
            abt::FSyscmd &elem = *_db.bh_syscmd_elems[n];
            int new_idx = bh_syscmd_Downheap(elem, 0);
            elem.bh_syscmd_idx = new_idx;
            _db.bh_syscmd_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- abt.FDb.bh_syscmd.Reserve
// Reserve space in index for N more elements
void abt::bh_syscmd_Reserve(int n) {
    i32 old_max = _db.bh_syscmd_max;
    if (UNLIKELY(_db.bh_syscmd_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FSyscmd*);
        u32 new_size = new_max * sizeof(abt::FSyscmd*);
        void *new_mem = abt::lpool_ReallocMem(_db.bh_syscmd_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.bh_syscmd");
        }
        _db.bh_syscmd_elems = (abt::FSyscmd**)new_mem;
        _db.bh_syscmd_max = new_max;
    }
}

// --- abt.FDb.bh_syscmd.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int abt::bh_syscmd_Upheap(abt::FSyscmd& row, int idx) {
    abt::FSyscmd* *elems = _db.bh_syscmd_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        abt::FSyscmd* p = elems[j];
        if (!bh_syscmd_ElemLt(row, *p)) {
            break;
        }
        p->bh_syscmd_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- abt.FDb.bh_syscmd.ElemLt
inline static bool abt::bh_syscmd_ElemLt(abt::FSyscmd &a, abt::FSyscmd &b) {
    (void)_db;
    return execkey_Get(a) < execkey_Get(b);
}

// --- abt.FDb.zs_srcfile_read.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void abt::zs_srcfile_read_Insert(abt::FSrcfile& row) {
    if (!zs_srcfile_read_InLlistQ(row)) {
        abt::FSrcfile* old_tail       = _db.zs_srcfile_read_tail;
        row.zs_srcfile_read_next  = NULL;
        _db.zs_srcfile_read_tail = &row;
        abt::FSrcfile **new_row_a = &old_tail->zs_srcfile_read_next;
        abt::FSrcfile **new_row_b = &_db.zs_srcfile_read_head;
        abt::FSrcfile **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- abt.FDb.zs_srcfile_read.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void abt::zs_srcfile_read_Remove(abt::FSrcfile& row) {
    if (zs_srcfile_read_InLlistQ(row)) {
        abt::FSrcfile* old_head       = _db.zs_srcfile_read_head;
        (void)old_head; // in case it's not used
        abt::FSrcfile* prev=NULL;
        abt::FSrcfile* cur     = _db.zs_srcfile_read_head;
        while (cur) {  // search for element by pointer
            abt::FSrcfile* next = cur->zs_srcfile_read_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_srcfile_read_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_srcfile_read_next = next;
                } else {
                    _db.zs_srcfile_read_head = next;
                }
                row.zs_srcfile_read_next = (abt::FSrcfile*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- abt.FDb.zs_srcfile_read.RemoveAll
// Empty the index. (The rows are not deleted)
void abt::zs_srcfile_read_RemoveAll() {
    abt::FSrcfile* row = _db.zs_srcfile_read_head;
    _db.zs_srcfile_read_head = NULL;
    _db.zs_srcfile_read_tail = NULL;
    while (row) {
        abt::FSrcfile* row_next = row->zs_srcfile_read_next;
        row->zs_srcfile_read_next  = (abt::FSrcfile*)-1;
        row = row_next;
    }
}

// --- abt.FDb.zs_srcfile_read.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
abt::FSrcfile* abt::zs_srcfile_read_RemoveFirst() {
    abt::FSrcfile *row = NULL;
    row = _db.zs_srcfile_read_head;
    if (row) {
        abt::FSrcfile *next = row->zs_srcfile_read_next;
        _db.zs_srcfile_read_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_srcfile_read_tail = NULL;
        }
        row->zs_srcfile_read_next = (abt::FSrcfile*)-1; // mark as not-in-list
    }
    return row;
}

// --- abt.FDb.zs_sel_target.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void abt::zs_sel_target_Insert(abt::FTarget& row) {
    if (!zs_sel_target_InLlistQ(row)) {
        abt::FTarget* old_tail       = _db.zs_sel_target_tail;
        row.zs_sel_target_next  = NULL;
        _db.zs_sel_target_tail = &row;
        abt::FTarget **new_row_a = &old_tail->zs_sel_target_next;
        abt::FTarget **new_row_b = &_db.zs_sel_target_head;
        abt::FTarget **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zs_sel_target_n++;
    }
}

// --- abt.FDb.zs_sel_target.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void abt::zs_sel_target_Remove(abt::FTarget& row) {
    if (zs_sel_target_InLlistQ(row)) {
        abt::FTarget* old_head       = _db.zs_sel_target_head;
        (void)old_head; // in case it's not used
        abt::FTarget* prev=NULL;
        abt::FTarget* cur     = _db.zs_sel_target_head;
        while (cur) {  // search for element by pointer
            abt::FTarget* next = cur->zs_sel_target_next;
            if (cur == &row) {
                _db.zs_sel_target_n--;  // adjust count

                if (!next) {
                    _db.zs_sel_target_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_sel_target_next = next;
                } else {
                    _db.zs_sel_target_head = next;
                }
                row.zs_sel_target_next = (abt::FTarget*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- abt.FDb.zs_sel_target.RemoveAll
// Empty the index. (The rows are not deleted)
void abt::zs_sel_target_RemoveAll() {
    abt::FTarget* row = _db.zs_sel_target_head;
    _db.zs_sel_target_head = NULL;
    _db.zs_sel_target_tail = NULL;
    _db.zs_sel_target_n = 0;
    while (row) {
        abt::FTarget* row_next = row->zs_sel_target_next;
        row->zs_sel_target_next  = (abt::FTarget*)-1;
        row = row_next;
    }
}

// --- abt.FDb.zs_sel_target.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
abt::FTarget* abt::zs_sel_target_RemoveFirst() {
    abt::FTarget *row = NULL;
    row = _db.zs_sel_target_head;
    if (row) {
        abt::FTarget *next = row->zs_sel_target_next;
        _db.zs_sel_target_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_sel_target_tail = NULL;
        }
        _db.zs_sel_target_n--;
        row->zs_sel_target_next = (abt::FTarget*)-1; // mark as not-in-list
    }
    return row;
}

// --- abt.FDb.targsyslib.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FTargsyslib& abt::targsyslib_Alloc() {
    abt::FTargsyslib* row = targsyslib_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.targsyslib  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.targsyslib.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FTargsyslib* abt::targsyslib_AllocMaybe() {
    abt::FTargsyslib *row = (abt::FTargsyslib*)targsyslib_AllocMem();
    if (row) {
        new (row) abt::FTargsyslib; // call constructor
    }
    return row;
}

// --- abt.FDb.targsyslib.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FTargsyslib* abt::targsyslib_InsertMaybe(const dev::Targsyslib &value) {
    abt::FTargsyslib *row = &targsyslib_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targsyslib_CopyIn(*row,const_cast<dev::Targsyslib&>(value));
    bool ok = targsyslib_XrefMaybe(*row); // this may return false
    if (!ok) {
        targsyslib_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.targsyslib.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::targsyslib_AllocMem() {
    u64 new_nelems     = _db.targsyslib_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FTargsyslib*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targsyslib_lary[bsr];
        if (!lev) {
            lev=(abt::FTargsyslib*)abt::lpool_AllocMem(sizeof(abt::FTargsyslib) * (u64(1)<<bsr));
            _db.targsyslib_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targsyslib_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.targsyslib.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::targsyslib_RemoveLast() {
    u64 n = _db.targsyslib_n;
    if (n > 0) {
        n -= 1;
        targsyslib_qFind(u64(n)).~FTargsyslib();
        _db.targsyslib_n = i32(n);
    }
}

// --- abt.FDb.targsyslib.InputMaybe
static bool abt::targsyslib_InputMaybe(dev::Targsyslib &elem) {
    bool retval = true;
    retval = targsyslib_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.targsyslib.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::targsyslib_XrefMaybe(abt::FTargsyslib &row) {
    bool retval = true;
    (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // insert targsyslib into index c_targsyslib
    if (true) { // user-defined insert condition
        c_targsyslib_Insert(*p_target, row);
    }
    abt::FSyslib* p_syslib = abt::ind_syslib_Find(syslib_Get(row));
    if (UNLIKELY(!p_syslib)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_syslib" << Keyval("key", syslib_Get(row));
        return false;
    }
    // targsyslib: save pointer to syslib
    if (true) { // user-defined insert condition
        row.p_syslib = p_syslib;
    }
    return retval;
}

// --- abt.FDb.syslib.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FSyslib& abt::syslib_Alloc() {
    abt::FSyslib* row = syslib_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.syslib  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.syslib.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FSyslib* abt::syslib_AllocMaybe() {
    abt::FSyslib *row = (abt::FSyslib*)syslib_AllocMem();
    if (row) {
        new (row) abt::FSyslib; // call constructor
    }
    return row;
}

// --- abt.FDb.syslib.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FSyslib* abt::syslib_InsertMaybe(const dev::Syslib &value) {
    abt::FSyslib *row = &syslib_Alloc(); // if out of memory, process dies. if input error, return NULL.
    syslib_CopyIn(*row,const_cast<dev::Syslib&>(value));
    bool ok = syslib_XrefMaybe(*row); // this may return false
    if (!ok) {
        syslib_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.syslib.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::syslib_AllocMem() {
    u64 new_nelems     = _db.syslib_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FSyslib*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.syslib_lary[bsr];
        if (!lev) {
            lev=(abt::FSyslib*)abt::lpool_AllocMem(sizeof(abt::FSyslib) * (u64(1)<<bsr));
            _db.syslib_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.syslib_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.syslib.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::syslib_RemoveLast() {
    u64 n = _db.syslib_n;
    if (n > 0) {
        n -= 1;
        syslib_qFind(u64(n)).~FSyslib();
        _db.syslib_n = i32(n);
    }
}

// --- abt.FDb.syslib.InputMaybe
static bool abt::syslib_InputMaybe(dev::Syslib &elem) {
    bool retval = true;
    retval = syslib_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.syslib.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::syslib_XrefMaybe(abt::FSyslib &row) {
    bool retval = true;
    (void)row;
    // insert syslib into index ind_syslib
    if (true) { // user-defined insert condition
        bool success = ind_syslib_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_syslib"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_syslib.Find
// Find row by key. Return NULL if not found.
abt::FSyslib* abt::ind_syslib_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_syslib_buckets_n - 1);
    abt::FSyslib *ret = _db.ind_syslib_buckets_elems[index];
    for (; ret && !((*ret).syslib == key); ret = ret->ind_syslib_next) {
    }
    return ret;
}

// --- abt.FDb.ind_syslib.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FSyslib& abt::ind_syslib_GetOrCreate(const algo::strptr& key) {
    abt::FSyslib* ret = ind_syslib_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &syslib_Alloc();
        (*ret).syslib = key;
        bool good = syslib_XrefMaybe(*ret);
        if (!good) {
            syslib_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_syslib  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_syslib.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_syslib_InsertMaybe(abt::FSyslib& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_syslib_next == (abt::FSyslib*)-1)) {// check if in hash already
        row.ind_syslib_hashval = algo::Smallstr50_Hash(0, row.syslib);
        ind_syslib_Reserve(1);
        u32 index = row.ind_syslib_hashval & (_db.ind_syslib_buckets_n - 1);
        abt::FSyslib* *prev = &_db.ind_syslib_buckets_elems[index];
        do {
            abt::FSyslib* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).syslib == row.syslib) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_syslib_next;
        } while (true);
        if (retval) {
            row.ind_syslib_next = *prev;
            _db.ind_syslib_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_syslib.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_syslib_Remove(abt::FSyslib& row) {
    if (LIKELY(row.ind_syslib_next != (abt::FSyslib*)-1)) {// check if in hash already
        u32 index = row.ind_syslib_hashval & (_db.ind_syslib_buckets_n - 1);
        abt::FSyslib* *prev = &_db.ind_syslib_buckets_elems[index]; // addr of pointer to current element
        while (abt::FSyslib *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_syslib_next; // unlink (singly linked list)
                _db.ind_syslib_n--;
                row.ind_syslib_next = (abt::FSyslib*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_syslib_next;
        }
    }
}

// --- abt.FDb.ind_syslib.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_syslib_Reserve(int n) {
    ind_syslib_AbsReserve(_db.ind_syslib_n + n);
}

// --- abt.FDb.ind_syslib.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_syslib_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_syslib_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FSyslib*);
        u32 new_size = new_nbuckets * sizeof(abt::FSyslib*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FSyslib* *new_buckets = (abt::FSyslib**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_syslib");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_syslib_buckets_n; i++) {
            abt::FSyslib* elem = _db.ind_syslib_buckets_elems[i];
            while (elem) {
                abt::FSyslib &row        = *elem;
                abt::FSyslib* next       = row.ind_syslib_next;
                u32 index          = row.ind_syslib_hashval & (new_nbuckets-1);
                row.ind_syslib_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_syslib_buckets_elems, old_size);
        _db.ind_syslib_buckets_elems = new_buckets;
        _db.ind_syslib_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.include.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FInclude& abt::include_Alloc() {
    abt::FInclude* row = include_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.include  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.include.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FInclude* abt::include_AllocMaybe() {
    abt::FInclude *row = (abt::FInclude*)include_AllocMem();
    if (row) {
        new (row) abt::FInclude; // call constructor
    }
    return row;
}

// --- abt.FDb.include.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FInclude* abt::include_InsertMaybe(const dev::Include &value) {
    abt::FInclude *row = &include_Alloc(); // if out of memory, process dies. if input error, return NULL.
    include_CopyIn(*row,const_cast<dev::Include&>(value));
    bool ok = include_XrefMaybe(*row); // this may return false
    if (!ok) {
        include_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.include.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::include_AllocMem() {
    u64 new_nelems     = _db.include_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FInclude*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.include_lary[bsr];
        if (!lev) {
            lev=(abt::FInclude*)abt::lpool_AllocMem(sizeof(abt::FInclude) * (u64(1)<<bsr));
            _db.include_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.include_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.include.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::include_RemoveLast() {
    u64 n = _db.include_n;
    if (n > 0) {
        n -= 1;
        include_qFind(u64(n)).~FInclude();
        _db.include_n = i32(n);
    }
}

// --- abt.FDb.include.InputMaybe
static bool abt::include_InputMaybe(dev::Include &elem) {
    bool retval = true;
    retval = include_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.include.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::include_XrefMaybe(abt::FInclude &row) {
    bool retval = true;
    (void)row;
    // insert include into index ind_include
    if (true) { // user-defined insert condition
        bool success = ind_include_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_include"; // check for duplicate key
            return false;
        }
    }
    abt::FSrcfile* p_srcfile = abt::ind_srcfile_Find(srcfile_Get(row));
    if (UNLIKELY(!p_srcfile)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_srcfile" << Keyval("key", srcfile_Get(row));
        return false;
    }
    // insert include into index zd_include
    if (true) { // user-defined insert condition
        zd_include_Insert(*p_srcfile, row);
    }
    abt::FSrcfile* p_filename = abt::ind_srcfile_Find(filename_Get(row));
    if (UNLIKELY(!p_filename)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_srcfile" << Keyval("key", filename_Get(row));
        return false;
    }
    // include: save pointer to filename
    if (true) { // user-defined insert condition
        row.p_header = p_filename;
    }
    return retval;
}

// --- abt.FDb.ind_include.Find
// Find row by key. Return NULL if not found.
abt::FInclude* abt::ind_include_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr200_Hash(0, key) & (_db.ind_include_buckets_n - 1);
    abt::FInclude *ret = _db.ind_include_buckets_elems[index];
    for (; ret && !((*ret).include == key); ret = ret->ind_include_next) {
    }
    return ret;
}

// --- abt.FDb.ind_include.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FInclude& abt::ind_include_GetOrCreate(const algo::strptr& key) {
    abt::FInclude* ret = ind_include_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &include_Alloc();
        (*ret).include = key;
        bool good = include_XrefMaybe(*ret);
        if (!good) {
            include_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_include  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_include.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_include_InsertMaybe(abt::FInclude& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_include_next == (abt::FInclude*)-1)) {// check if in hash already
        row.ind_include_hashval = algo::Smallstr200_Hash(0, row.include);
        ind_include_Reserve(1);
        u32 index = row.ind_include_hashval & (_db.ind_include_buckets_n - 1);
        abt::FInclude* *prev = &_db.ind_include_buckets_elems[index];
        do {
            abt::FInclude* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).include == row.include) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_include_next;
        } while (true);
        if (retval) {
            row.ind_include_next = *prev;
            _db.ind_include_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_include.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_include_Remove(abt::FInclude& row) {
    if (LIKELY(row.ind_include_next != (abt::FInclude*)-1)) {// check if in hash already
        u32 index = row.ind_include_hashval & (_db.ind_include_buckets_n - 1);
        abt::FInclude* *prev = &_db.ind_include_buckets_elems[index]; // addr of pointer to current element
        while (abt::FInclude *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_include_next; // unlink (singly linked list)
                _db.ind_include_n--;
                row.ind_include_next = (abt::FInclude*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_include_next;
        }
    }
}

// --- abt.FDb.ind_include.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_include_Reserve(int n) {
    ind_include_AbsReserve(_db.ind_include_n + n);
}

// --- abt.FDb.ind_include.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_include_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_include_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FInclude*);
        u32 new_size = new_nbuckets * sizeof(abt::FInclude*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FInclude* *new_buckets = (abt::FInclude**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_include");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_include_buckets_n; i++) {
            abt::FInclude* elem = _db.ind_include_buckets_elems[i];
            while (elem) {
                abt::FInclude &row        = *elem;
                abt::FInclude* next       = row.ind_include_next;
                u32 index          = row.ind_include_hashval & (new_nbuckets-1);
                row.ind_include_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_include_buckets_elems, old_size);
        _db.ind_include_buckets_elems = new_buckets;
        _db.ind_include_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.sysincl.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> abt::sysincl_Addary(algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= _db.sysincl_elems && rhs.elems < _db.sysincl_elems + _db.sysincl_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("abt.tary_alias  field:abt.FDb.sysincl  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    sysincl_Reserve(nnew); // reserve space
    int at = _db.sysincl_n;
    for (int i = 0; i < nnew; i++) {
        new (_db.sysincl_elems + at + i) algo::cstring(rhs[i]);
        _db.sysincl_n++;
    }
    return algo::aryptr<algo::cstring>(_db.sysincl_elems + at, nnew);
}

// --- abt.FDb.sysincl.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& abt::sysincl_Alloc() {
    sysincl_Reserve(1);
    int n  = _db.sysincl_n;
    int at = n;
    algo::cstring *elems = _db.sysincl_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    _db.sysincl_n = n+1;
    return elems[at];
}

// --- abt.FDb.sysincl.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& abt::sysincl_AllocAt(int at) {
    sysincl_Reserve(1);
    int n  = _db.sysincl_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("abt.bad_alloc_at  field:abt.FDb.sysincl  comment:'index out of range'");
    }
    algo::cstring *elems = _db.sysincl_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    _db.sysincl_n = n+1;
    return elems[at];
}

// --- abt.FDb.sysincl.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> abt::sysincl_AllocN(int n_elems) {
    sysincl_Reserve(n_elems);
    int old_n  = _db.sysincl_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = _db.sysincl_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    _db.sysincl_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- abt.FDb.sysincl.AllocNAt
// Reserve space. Insert N elements at the given position of the array, return pointer to inserted elements
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::aryptr<algo::cstring> abt::sysincl_AllocNAt(int n_elems, int at) {
    sysincl_Reserve(n_elems);
    int n  = _db.sysincl_n;
    if (UNLIKELY(u64(at) > u64(n))) {
        FatalErrorExit("abt.bad_alloc_n_at  field:abt.FDb.sysincl  comment:'index out of range'");
    }
    algo::cstring *elems = _db.sysincl_elems;
    memmove(elems + at + n_elems, elems + at, (n - at) * sizeof(algo::cstring));
    for (int i = 0; i < n_elems; i++) {
        new (elems + at + i) algo::cstring(); // construct new element, default initialize
    }
    _db.sysincl_n = n+n_elems;
    return algo::aryptr<algo::cstring>(elems+at,n_elems);
}

// --- abt.FDb.sysincl.Remove
// Remove item by index. If index outside of range, do nothing.
void abt::sysincl_Remove(u32 i) {
    u32 lim = _db.sysincl_n;
    algo::cstring *elems = _db.sysincl_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        _db.sysincl_n = lim - 1;
    }
}

// --- abt.FDb.sysincl.RemoveAll
void abt::sysincl_RemoveAll() {
    u32 n = _db.sysincl_n;
    while (n > 0) {
        n -= 1;
        _db.sysincl_elems[n].~cstring();
        _db.sysincl_n = n;
    }
}

// --- abt.FDb.sysincl.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::sysincl_RemoveLast() {
    u64 n = _db.sysincl_n;
    if (n > 0) {
        n -= 1;
        sysincl_qFind(u64(n)).~cstring();
        _db.sysincl_n = n;
    }
}

// --- abt.FDb.sysincl.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void abt::sysincl_AbsReserve(int n) {
    u32 old_max  = _db.sysincl_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = abt::lpool_ReallocMem(_db.sysincl_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.tary_nomem  field:abt.FDb.sysincl  comment:'out of memory'");
        }
        _db.sysincl_elems = (algo::cstring*)new_mem;
        _db.sysincl_max = new_max;
    }
}

// --- abt.FDb.sysincl.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> abt::sysincl_AllocNVal(int n_elems, const algo::cstring& val) {
    sysincl_Reserve(n_elems);
    int old_n  = _db.sysincl_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = _db.sysincl_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    _db.sysincl_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- abt.FDb.sysincl.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool abt::sysincl_ReadStrptrMaybe(algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = sysincl_Alloc();
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        sysincl_RemoveLast();
    }
    return retval;
}

// --- abt.FDb.sysincl.Insary
// Insert array at specific position
// Insert N elements at specified index. Index must be in range or a fatal error occurs.Reserve space, and move existing elements to end.If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
void abt::sysincl_Insary(algo::aryptr<algo::cstring> rhs, int at) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= _db.sysincl_elems && rhs.elems < _db.sysincl_elems + _db.sysincl_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("abt.tary_alias  field:abt.FDb.sysincl  comment:'alias error: sub-array is being appended to the whole'");
    }
    if (UNLIKELY(u64(at) >= u64(_db.sysincl_elems+1))) {
        FatalErrorExit("abt.bad_insary  field:abt.FDb.sysincl  comment:'index out of range'");
    }
    int nnew = rhs.n_elems;
    int nmove = _db.sysincl_n - at;
    sysincl_Reserve(nnew); // reserve space
    for (int i = nmove-1; i >=0 ; --i) {
        new (_db.sysincl_elems + at + nnew + i) algo::cstring(_db.sysincl_elems[at + i]);
        _db.sysincl_elems[at + i].~cstring(); // destroy element
    }
    for (int i = 0; i < nnew; ++i) {
        new (_db.sysincl_elems + at + i) algo::cstring(rhs[i]);
    }
    _db.sysincl_n += nnew;
}

// --- abt.FDb.zs_origsel_target.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void abt::zs_origsel_target_Insert(abt::FTarget& row) {
    if (!zs_origsel_target_InLlistQ(row)) {
        abt::FTarget* old_tail       = _db.zs_origsel_target_tail;
        row.zs_origsel_target_next  = NULL;
        _db.zs_origsel_target_tail = &row;
        abt::FTarget **new_row_a = &old_tail->zs_origsel_target_next;
        abt::FTarget **new_row_b = &_db.zs_origsel_target_head;
        abt::FTarget **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- abt.FDb.zs_origsel_target.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void abt::zs_origsel_target_Remove(abt::FTarget& row) {
    if (zs_origsel_target_InLlistQ(row)) {
        abt::FTarget* old_head       = _db.zs_origsel_target_head;
        (void)old_head; // in case it's not used
        abt::FTarget* prev=NULL;
        abt::FTarget* cur     = _db.zs_origsel_target_head;
        while (cur) {  // search for element by pointer
            abt::FTarget* next = cur->zs_origsel_target_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_origsel_target_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_origsel_target_next = next;
                } else {
                    _db.zs_origsel_target_head = next;
                }
                row.zs_origsel_target_next = (abt::FTarget*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- abt.FDb.zs_origsel_target.RemoveAll
// Empty the index. (The rows are not deleted)
void abt::zs_origsel_target_RemoveAll() {
    abt::FTarget* row = _db.zs_origsel_target_head;
    _db.zs_origsel_target_head = NULL;
    _db.zs_origsel_target_tail = NULL;
    while (row) {
        abt::FTarget* row_next = row->zs_origsel_target_next;
        row->zs_origsel_target_next  = (abt::FTarget*)-1;
        row = row_next;
    }
}

// --- abt.FDb.zs_origsel_target.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
abt::FTarget* abt::zs_origsel_target_RemoveFirst() {
    abt::FTarget *row = NULL;
    row = _db.zs_origsel_target_head;
    if (row) {
        abt::FTarget *next = row->zs_origsel_target_next;
        _db.zs_origsel_target_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_origsel_target_tail = NULL;
        }
        row->zs_origsel_target_next = (abt::FTarget*)-1; // mark as not-in-list
    }
    return row;
}

// --- abt.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FNs& abt::ns_Alloc() {
    abt::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FNs* abt::ns_AllocMaybe() {
    abt::FNs *row = (abt::FNs*)ns_AllocMem();
    if (row) {
        new (row) abt::FNs; // call constructor
    }
    return row;
}

// --- abt.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FNs* abt::ns_InsertMaybe(const dmmeta::Ns &value) {
    abt::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(abt::FNs*)abt::lpool_AllocMem(sizeof(abt::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = i32(n);
    }
}

// --- abt.FDb.ns.InputMaybe
static bool abt::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::ns_XrefMaybe(abt::FNs &row) {
    bool retval = true;
    (void)row;
    // insert ns into index ind_ns
    if (true) { // user-defined insert condition
        bool success = ind_ns_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_ns"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_ns.Find
// Find row by key. Return NULL if not found.
abt::FNs* abt::ind_ns_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_ns_buckets_n - 1);
    abt::FNs *ret = _db.ind_ns_buckets_elems[index];
    for (; ret && !((*ret).ns == key); ret = ret->ind_ns_next) {
    }
    return ret;
}

// --- abt.FDb.ind_ns.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FNs& abt::ind_ns_GetOrCreate(const algo::strptr& key) {
    abt::FNs* ret = ind_ns_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ns_Alloc();
        (*ret).ns = key;
        bool good = ns_XrefMaybe(*ret);
        if (!good) {
            ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_ns  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_ns.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_ns_InsertMaybe(abt::FNs& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ns_next == (abt::FNs*)-1)) {// check if in hash already
        row.ind_ns_hashval = algo::Smallstr16_Hash(0, row.ns);
        ind_ns_Reserve(1);
        u32 index = row.ind_ns_hashval & (_db.ind_ns_buckets_n - 1);
        abt::FNs* *prev = &_db.ind_ns_buckets_elems[index];
        do {
            abt::FNs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ns_next;
        } while (true);
        if (retval) {
            row.ind_ns_next = *prev;
            _db.ind_ns_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_ns.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_ns_Remove(abt::FNs& row) {
    if (LIKELY(row.ind_ns_next != (abt::FNs*)-1)) {// check if in hash already
        u32 index = row.ind_ns_hashval & (_db.ind_ns_buckets_n - 1);
        abt::FNs* *prev = &_db.ind_ns_buckets_elems[index]; // addr of pointer to current element
        while (abt::FNs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ns_next; // unlink (singly linked list)
                _db.ind_ns_n--;
                row.ind_ns_next = (abt::FNs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ns_next;
        }
    }
}

// --- abt.FDb.ind_ns.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_ns_Reserve(int n) {
    ind_ns_AbsReserve(_db.ind_ns_n + n);
}

// --- abt.FDb.ind_ns.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_ns_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_ns_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FNs*);
        u32 new_size = new_nbuckets * sizeof(abt::FNs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FNs* *new_buckets = (abt::FNs**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_ns");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ns_buckets_n; i++) {
            abt::FNs* elem = _db.ind_ns_buckets_elems[i];
            while (elem) {
                abt::FNs &row        = *elem;
                abt::FNs* next       = row.ind_ns_next;
                u32 index          = row.ind_ns_hashval & (new_nbuckets-1);
                row.ind_ns_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_ns_buckets_elems, old_size);
        _db.ind_ns_buckets_elems = new_buckets;
        _db.ind_ns_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.filestat.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FFilestat& abt::filestat_Alloc() {
    abt::FFilestat* row = filestat_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.filestat  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.filestat.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FFilestat* abt::filestat_AllocMaybe() {
    abt::FFilestat *row = (abt::FFilestat*)filestat_AllocMem();
    if (row) {
        new (row) abt::FFilestat; // call constructor
    }
    return row;
}

// --- abt.FDb.filestat.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::filestat_AllocMem() {
    u64 new_nelems     = _db.filestat_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FFilestat*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.filestat_lary[bsr];
        if (!lev) {
            lev=(abt::FFilestat*)abt::lpool_AllocMem(sizeof(abt::FFilestat) * (u64(1)<<bsr));
            _db.filestat_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.filestat_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.filestat.RemoveAll
// Remove all elements from Lary
void abt::filestat_RemoveAll() {
    for (u64 n = _db.filestat_n; n>0; ) {
        n--;
        filestat_qFind(u64(n)).~FFilestat(); // destroy last element
        _db.filestat_n = i32(n);
    }
}

// --- abt.FDb.filestat.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::filestat_RemoveLast() {
    u64 n = _db.filestat_n;
    if (n > 0) {
        n -= 1;
        filestat_qFind(u64(n)).~FFilestat();
        _db.filestat_n = i32(n);
    }
}

// --- abt.FDb.filestat.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::filestat_XrefMaybe(abt::FFilestat &row) {
    bool retval = true;
    (void)row;
    // insert filestat into index ind_filestat
    if (true) { // user-defined insert condition
        bool success = ind_filestat_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_filestat"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- abt.FDb.ind_filestat.Find
// Find row by key. Return NULL if not found.
abt::FFilestat* abt::ind_filestat_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_filestat_buckets_n - 1);
    abt::FFilestat *ret = _db.ind_filestat_buckets_elems[index];
    for (; ret && !((*ret).filename == key); ret = ret->ind_filestat_next) {
    }
    return ret;
}

// --- abt.FDb.ind_filestat.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FFilestat& abt::ind_filestat_GetOrCreate(const algo::strptr& key) {
    abt::FFilestat* ret = ind_filestat_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &filestat_Alloc();
        (*ret).filename = key;
        bool good = filestat_XrefMaybe(*ret);
        if (!good) {
            filestat_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_filestat  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_filestat.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_filestat_InsertMaybe(abt::FFilestat& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_filestat_next == (abt::FFilestat*)-1)) {// check if in hash already
        row.ind_filestat_hashval = algo::cstring_Hash(0, row.filename);
        ind_filestat_Reserve(1);
        u32 index = row.ind_filestat_hashval & (_db.ind_filestat_buckets_n - 1);
        abt::FFilestat* *prev = &_db.ind_filestat_buckets_elems[index];
        do {
            abt::FFilestat* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).filename == row.filename) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_filestat_next;
        } while (true);
        if (retval) {
            row.ind_filestat_next = *prev;
            _db.ind_filestat_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_filestat.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_filestat_Remove(abt::FFilestat& row) {
    if (LIKELY(row.ind_filestat_next != (abt::FFilestat*)-1)) {// check if in hash already
        u32 index = row.ind_filestat_hashval & (_db.ind_filestat_buckets_n - 1);
        abt::FFilestat* *prev = &_db.ind_filestat_buckets_elems[index]; // addr of pointer to current element
        while (abt::FFilestat *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_filestat_next; // unlink (singly linked list)
                _db.ind_filestat_n--;
                row.ind_filestat_next = (abt::FFilestat*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_filestat_next;
        }
    }
}

// --- abt.FDb.ind_filestat.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_filestat_Reserve(int n) {
    ind_filestat_AbsReserve(_db.ind_filestat_n + n);
}

// --- abt.FDb.ind_filestat.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_filestat_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_filestat_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FFilestat*);
        u32 new_size = new_nbuckets * sizeof(abt::FFilestat*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FFilestat* *new_buckets = (abt::FFilestat**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_filestat");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_filestat_buckets_n; i++) {
            abt::FFilestat* elem = _db.ind_filestat_buckets_elems[i];
            while (elem) {
                abt::FFilestat &row        = *elem;
                abt::FFilestat* next       = row.ind_filestat_next;
                u32 index          = row.ind_filestat_hashval & (new_nbuckets-1);
                row.ind_filestat_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_filestat_buckets_elems, old_size);
        _db.ind_filestat_buckets_elems = new_buckets;
        _db.ind_filestat_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.builddir.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
abt::FBuilddir& abt::builddir_Alloc() {
    abt::FBuilddir* row = builddir_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("abt.out_of_mem  field:abt.FDb.builddir  comment:'Alloc failed'");
    }
    return *row;
}

// --- abt.FDb.builddir.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
abt::FBuilddir* abt::builddir_AllocMaybe() {
    abt::FBuilddir *row = (abt::FBuilddir*)builddir_AllocMem();
    if (row) {
        new (row) abt::FBuilddir; // call constructor
    }
    return row;
}

// --- abt.FDb.builddir.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
abt::FBuilddir* abt::builddir_InsertMaybe(const dev::Builddir &value) {
    abt::FBuilddir *row = &builddir_Alloc(); // if out of memory, process dies. if input error, return NULL.
    builddir_CopyIn(*row,const_cast<dev::Builddir&>(value));
    bool ok = builddir_XrefMaybe(*row); // this may return false
    if (!ok) {
        builddir_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- abt.FDb.builddir.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* abt::builddir_AllocMem() {
    u64 new_nelems     = _db.builddir_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    abt::FBuilddir*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.builddir_lary[bsr];
        if (!lev) {
            lev=(abt::FBuilddir*)abt::lpool_AllocMem(sizeof(abt::FBuilddir) * (u64(1)<<bsr));
            _db.builddir_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.builddir_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- abt.FDb.builddir.RemoveAll
// Remove all elements from Lary
void abt::builddir_RemoveAll() {
    for (u64 n = _db.builddir_n; n>0; ) {
        n--;
        builddir_qFind(u64(n)).~FBuilddir(); // destroy last element
        _db.builddir_n = i32(n);
    }
}

// --- abt.FDb.builddir.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void abt::builddir_RemoveLast() {
    u64 n = _db.builddir_n;
    if (n > 0) {
        n -= 1;
        builddir_qFind(u64(n)).~FBuilddir();
        _db.builddir_n = i32(n);
    }
}

// --- abt.FDb.builddir.InputMaybe
static bool abt::builddir_InputMaybe(dev::Builddir &elem) {
    bool retval = true;
    retval = builddir_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- abt.FDb.builddir.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool abt::builddir_XrefMaybe(abt::FBuilddir &row) {
    bool retval = true;
    (void)row;
    // insert builddir into index ind_builddir
    if (true) { // user-defined insert condition
        bool success = ind_builddir_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "abt.duplicate_key  xref:abt.FDb.ind_builddir"; // check for duplicate key
            return false;
        }
    }
    abt::FCompiler* p_compiler = abt::ind_compiler_Find(compiler_Get(row));
    if (UNLIKELY(!p_compiler)) {
        algo_lib::ResetErrtext() << "abt.bad_xref  index:abt.FDb.ind_compiler" << Keyval("key", compiler_Get(row));
        return false;
    }
    // builddir: save pointer to compiler
    if (true) { // user-defined insert condition
        row.p_compiler = p_compiler;
    }
    return retval;
}

// --- abt.FDb.ind_builddir.Find
// Find row by key. Return NULL if not found.
abt::FBuilddir* abt::ind_builddir_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_builddir_buckets_n - 1);
    abt::FBuilddir *ret = _db.ind_builddir_buckets_elems[index];
    for (; ret && !((*ret).builddir == key); ret = ret->ind_builddir_next) {
    }
    return ret;
}

// --- abt.FDb.ind_builddir.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
abt::FBuilddir& abt::ind_builddir_GetOrCreate(const algo::strptr& key) {
    abt::FBuilddir* ret = ind_builddir_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &builddir_Alloc();
        (*ret).builddir = key;
        bool good = builddir_XrefMaybe(*ret);
        if (!good) {
            builddir_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "abt.create_error  table:ind_builddir  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- abt.FDb.ind_builddir.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool abt::ind_builddir_InsertMaybe(abt::FBuilddir& row) {
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_builddir_next == (abt::FBuilddir*)-1)) {// check if in hash already
        row.ind_builddir_hashval = algo::Smallstr50_Hash(0, row.builddir);
        ind_builddir_Reserve(1);
        u32 index = row.ind_builddir_hashval & (_db.ind_builddir_buckets_n - 1);
        abt::FBuilddir* *prev = &_db.ind_builddir_buckets_elems[index];
        do {
            abt::FBuilddir* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).builddir == row.builddir) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_builddir_next;
        } while (true);
        if (retval) {
            row.ind_builddir_next = *prev;
            _db.ind_builddir_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- abt.FDb.ind_builddir.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void abt::ind_builddir_Remove(abt::FBuilddir& row) {
    if (LIKELY(row.ind_builddir_next != (abt::FBuilddir*)-1)) {// check if in hash already
        u32 index = row.ind_builddir_hashval & (_db.ind_builddir_buckets_n - 1);
        abt::FBuilddir* *prev = &_db.ind_builddir_buckets_elems[index]; // addr of pointer to current element
        while (abt::FBuilddir *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_builddir_next; // unlink (singly linked list)
                _db.ind_builddir_n--;
                row.ind_builddir_next = (abt::FBuilddir*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_builddir_next;
        }
    }
}

// --- abt.FDb.ind_builddir.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void abt::ind_builddir_Reserve(int n) {
    ind_builddir_AbsReserve(_db.ind_builddir_n + n);
}

// --- abt.FDb.ind_builddir.AbsReserve
// Reserve enough room for exacty N elements. Return success code.
void abt::ind_builddir_AbsReserve(int n) {
    u32 old_nbuckets = _db.ind_builddir_buckets_n;
    u32 new_nelems   = n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(abt::FBuilddir*);
        u32 new_size = new_nbuckets * sizeof(abt::FBuilddir*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        abt::FBuilddir* *new_buckets = (abt::FBuilddir**)abt::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FDb.ind_builddir");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_builddir_buckets_n; i++) {
            abt::FBuilddir* elem = _db.ind_builddir_buckets_elems[i];
            while (elem) {
                abt::FBuilddir &row        = *elem;
                abt::FBuilddir* next       = row.ind_builddir_next;
                u32 index          = row.ind_builddir_hashval & (new_nbuckets-1);
                row.ind_builddir_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        abt::lpool_FreeMem(_db.ind_builddir_buckets_elems, old_size);
        _db.ind_builddir_buckets_elems = new_buckets;
        _db.ind_builddir_buckets_n = new_nbuckets;
    }
}

// --- abt.FDb.zd_inclstack.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void abt::zd_inclstack_Insert(abt::FSrcfile& row) {
    if (!zd_inclstack_InLlistQ(row)) {
        abt::FSrcfile* old_tail = _db.zd_inclstack_tail;
        row.zd_inclstack_next = NULL;
        row.zd_inclstack_prev = old_tail;
        _db.zd_inclstack_tail = &row;
        abt::FSrcfile **new_row_a = &old_tail->zd_inclstack_next;
        abt::FSrcfile **new_row_b = &_db.zd_inclstack_head;
        abt::FSrcfile **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_inclstack_n++;
    }
}

// --- abt.FDb.zd_inclstack.Remove
// Remove element from index. If element is not in index, do nothing.
void abt::zd_inclstack_Remove(abt::FSrcfile& row) {
    if (zd_inclstack_InLlistQ(row)) {
        abt::FSrcfile* old_head       = _db.zd_inclstack_head;
        (void)old_head; // in case it's not used
        abt::FSrcfile* prev = row.zd_inclstack_prev;
        abt::FSrcfile* next = row.zd_inclstack_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        abt::FSrcfile **new_next_a = &prev->zd_inclstack_next;
        abt::FSrcfile **new_next_b = &_db.zd_inclstack_head;
        abt::FSrcfile **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        abt::FSrcfile **new_prev_a = &next->zd_inclstack_prev;
        abt::FSrcfile **new_prev_b = &_db.zd_inclstack_tail;
        abt::FSrcfile **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_inclstack_n--;
        row.zd_inclstack_next=(abt::FSrcfile*)-1; // not-in-list
    }
}

// --- abt.FDb.zd_inclstack.RemoveAll
// Empty the index. (The rows are not deleted)
void abt::zd_inclstack_RemoveAll() {
    abt::FSrcfile* row = _db.zd_inclstack_head;
    _db.zd_inclstack_head = NULL;
    _db.zd_inclstack_tail = NULL;
    _db.zd_inclstack_n = 0;
    while (row) {
        abt::FSrcfile* row_next = row->zd_inclstack_next;
        row->zd_inclstack_next  = (abt::FSrcfile*)-1;
        row->zd_inclstack_prev  = NULL;
        row = row_next;
    }
}

// --- abt.FDb.zd_inclstack.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
abt::FSrcfile* abt::zd_inclstack_RemoveFirst() {
    abt::FSrcfile *row = NULL;
    row = _db.zd_inclstack_head;
    if (row) {
        abt::FSrcfile *next = row->zd_inclstack_next;
        _db.zd_inclstack_head = next;
        abt::FSrcfile **new_end_a = &next->zd_inclstack_prev;
        abt::FSrcfile **new_end_b = &_db.zd_inclstack_tail;
        abt::FSrcfile **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_inclstack_n--;
        row->zd_inclstack_next = (abt::FSrcfile*)-1; // mark as not-in-list
    }
    return row;
}

// --- abt.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr abt::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- abt.FDb.trace.N
// Function return 1
inline static i32 abt::trace_N() {
    return 1;
}

// --- abt.FDb.bh_syscmd_curs.Add
static void abt::_db_bh_syscmd_curs_Add(_db_bh_syscmd_curs &curs, abt::FSyscmd& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    abt::FSyscmd* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        abt::FSyscmd* p = elems[j];
        if (!bh_syscmd_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- abt.FDb.bh_syscmd_curs.Reserve
void abt::_db_bh_syscmd_curs_Reserve(_db_bh_syscmd_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_syscmd_N();
        curs.temp_elems   = (abt::FSyscmd**)abt::lpool_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("abt.cursor_out_of_memory  func:abt.FDb.bh_syscmd_curs.Reserve");
        }
        curs.temp_max       = bh_syscmd_N();
    }
}

// --- abt.FDb.bh_syscmd_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void abt::_db_bh_syscmd_curs_Reset(_db_bh_syscmd_curs &curs, abt::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_syscmd_curs_Reserve(curs, bh_syscmd_N());
    curs.temp_n = 0;
    if (parent.bh_syscmd_n > 0) {
        abt::FSyscmd &first = *parent.bh_syscmd_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- abt.FDb.bh_syscmd_curs.Next
// Advance cursor.
void abt::_db_bh_syscmd_curs_Next(_db_bh_syscmd_curs &curs) {
    abt::FSyscmd* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        abt::FSyscmd* dead = elems[0];
        int i       = 0;
        abt::FSyscmd* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            abt::FSyscmd* choose = last;
            int l         = i*2+1;
            if (l<n) {
                abt::FSyscmd* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                abt::FSyscmd* er = elems[r];
                if (bh_syscmd_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_syscmd_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_syscmd_idx;
        i = (index*2+1);
        if (i < bh_syscmd_N()) {
            abt::FSyscmd &elem = *curs.parent->bh_syscmd_elems[i];
            _db_bh_syscmd_curs_Add(curs, elem);
        }
        if (i+1 < bh_syscmd_N()) {
            abt::FSyscmd &elem = *curs.parent->bh_syscmd_elems[i + 1];
            _db_bh_syscmd_curs_Add(curs, elem);
        }
    }
}

// --- abt.FDb..Init
// Set all fields to initial values.
void abt::FDb_Init() {
    memset(_db.lpool_free, 0, sizeof(_db.lpool_free));
    // initialize LAry srcfile (abt.FDb.srcfile)
    _db.srcfile_n = 0;
    memset(_db.srcfile_lary, 0, sizeof(_db.srcfile_lary)); // zero out all level pointers
    abt::FSrcfile* srcfile_first = (abt::FSrcfile*)abt::lpool_AllocMem(sizeof(abt::FSrcfile) * (u64(1)<<4));
    if (!srcfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.srcfile_lary[i]  = srcfile_first;
        srcfile_first    += 1ULL<<i;
    }
    // initialize LAry targdep (abt.FDb.targdep)
    _db.targdep_n = 0;
    memset(_db.targdep_lary, 0, sizeof(_db.targdep_lary)); // zero out all level pointers
    abt::FTargdep* targdep_first = (abt::FTargdep*)abt::lpool_AllocMem(sizeof(abt::FTargdep) * (u64(1)<<4));
    if (!targdep_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targdep_lary[i]  = targdep_first;
        targdep_first    += 1ULL<<i;
    }
    // initialize LAry tool_opt (abt.FDb.tool_opt)
    _db.tool_opt_n = 0;
    memset(_db.tool_opt_lary, 0, sizeof(_db.tool_opt_lary)); // zero out all level pointers
    abt::FToolOpt* tool_opt_first = (abt::FToolOpt*)abt::lpool_AllocMem(sizeof(abt::FToolOpt) * (u64(1)<<4));
    if (!tool_opt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tool_opt_lary[i]  = tool_opt_first;
        tool_opt_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FTarget;
    _db.ind_target_n             	= 0; // (abt.FDb.ind_target)
    _db.ind_target_buckets_n     	= 4; // (abt.FDb.ind_target)
    _db.ind_target_buckets_elems 	= (abt::FTarget**)abt::lpool_AllocMem(sizeof(abt::FTarget*)*_db.ind_target_buckets_n); // initial buckets (abt.FDb.ind_target)
    if (!_db.ind_target_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_target)
    }
    memset(_db.ind_target_buckets_elems, 0, sizeof(abt::FTarget*)*_db.ind_target_buckets_n); // (abt.FDb.ind_target)
    // initialize LAry target (abt.FDb.target)
    _db.target_n = 0;
    memset(_db.target_lary, 0, sizeof(_db.target_lary)); // zero out all level pointers
    abt::FTarget* target_first = (abt::FTarget*)abt::lpool_AllocMem(sizeof(abt::FTarget) * (u64(1)<<4));
    if (!target_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.target_lary[i]  = target_first;
        target_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FTargsrc;
    _db.ind_targsrc_n             	= 0; // (abt.FDb.ind_targsrc)
    _db.ind_targsrc_buckets_n     	= 4; // (abt.FDb.ind_targsrc)
    _db.ind_targsrc_buckets_elems 	= (abt::FTargsrc**)abt::lpool_AllocMem(sizeof(abt::FTargsrc*)*_db.ind_targsrc_buckets_n); // initial buckets (abt.FDb.ind_targsrc)
    if (!_db.ind_targsrc_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_targsrc)
    }
    memset(_db.ind_targsrc_buckets_elems, 0, sizeof(abt::FTargsrc*)*_db.ind_targsrc_buckets_n); // (abt.FDb.ind_targsrc)
    // initialize LAry targsrc (abt.FDb.targsrc)
    _db.targsrc_n = 0;
    memset(_db.targsrc_lary, 0, sizeof(_db.targsrc_lary)); // zero out all level pointers
    abt::FTargsrc* targsrc_first = (abt::FTargsrc*)abt::lpool_AllocMem(sizeof(abt::FTargsrc) * (u64(1)<<4));
    if (!targsrc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targsrc_lary[i]  = targsrc_first;
        targsrc_first    += 1ULL<<i;
    }
    // initialize LAry syscmddep (abt.FDb.syscmddep)
    _db.syscmddep_n = 0;
    memset(_db.syscmddep_lary, 0, sizeof(_db.syscmddep_lary)); // zero out all level pointers
    abt::FSyscmddep* syscmddep_first = (abt::FSyscmddep*)abt::lpool_AllocMem(sizeof(abt::FSyscmddep) * (u64(1)<<4));
    if (!syscmddep_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.syscmddep_lary[i]  = syscmddep_first;
        syscmddep_first    += 1ULL<<i;
    }
    // initialize LAry syscmd (abt.FDb.syscmd)
    _db.syscmd_n = 0;
    memset(_db.syscmd_lary, 0, sizeof(_db.syscmd_lary)); // zero out all level pointers
    abt::FSyscmd* syscmd_first = (abt::FSyscmd*)abt::lpool_AllocMem(sizeof(abt::FSyscmd) * (u64(1)<<4));
    if (!syscmd_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.syscmd_lary[i]  = syscmd_first;
        syscmd_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FSyscmd;
    _db.ind_syscmd_n             	= 0; // (abt.FDb.ind_syscmd)
    _db.ind_syscmd_buckets_n     	= 4; // (abt.FDb.ind_syscmd)
    _db.ind_syscmd_buckets_elems 	= (abt::FSyscmd**)abt::lpool_AllocMem(sizeof(abt::FSyscmd*)*_db.ind_syscmd_buckets_n); // initial buckets (abt.FDb.ind_syscmd)
    if (!_db.ind_syscmd_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_syscmd)
    }
    memset(_db.ind_syscmd_buckets_elems, 0, sizeof(abt::FSyscmd*)*_db.ind_syscmd_buckets_n); // (abt.FDb.ind_syscmd)
    // initialize hash table for abt::FSyscmd;
    _db.ind_running_n             	= 0; // (abt.FDb.ind_running)
    _db.ind_running_buckets_n     	= 4; // (abt.FDb.ind_running)
    _db.ind_running_buckets_elems 	= (abt::FSyscmd**)abt::lpool_AllocMem(sizeof(abt::FSyscmd*)*_db.ind_running_buckets_n); // initial buckets (abt.FDb.ind_running)
    if (!_db.ind_running_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_running)
    }
    memset(_db.ind_running_buckets_elems, 0, sizeof(abt::FSyscmd*)*_db.ind_running_buckets_n); // (abt.FDb.ind_running)
    // initialize hash table for abt::FSrcfile;
    _db.ind_srcfile_n             	= 0; // (abt.FDb.ind_srcfile)
    _db.ind_srcfile_buckets_n     	= 4; // (abt.FDb.ind_srcfile)
    _db.ind_srcfile_buckets_elems 	= (abt::FSrcfile**)abt::lpool_AllocMem(sizeof(abt::FSrcfile*)*_db.ind_srcfile_buckets_n); // initial buckets (abt.FDb.ind_srcfile)
    if (!_db.ind_srcfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_srcfile)
    }
    memset(_db.ind_srcfile_buckets_elems, 0, sizeof(abt::FSrcfile*)*_db.ind_srcfile_buckets_n); // (abt.FDb.ind_srcfile)
    // initialize LAry cfg (abt.FDb.cfg)
    _db.cfg_n = 0;
    memset(_db.cfg_lary, 0, sizeof(_db.cfg_lary)); // zero out all level pointers
    abt::FCfg* cfg_first = (abt::FCfg*)abt::lpool_AllocMem(sizeof(abt::FCfg) * (u64(1)<<4));
    if (!cfg_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cfg_lary[i]  = cfg_first;
        cfg_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FCfg;
    _db.ind_cfg_n             	= 0; // (abt.FDb.ind_cfg)
    _db.ind_cfg_buckets_n     	= 4; // (abt.FDb.ind_cfg)
    _db.ind_cfg_buckets_elems 	= (abt::FCfg**)abt::lpool_AllocMem(sizeof(abt::FCfg*)*_db.ind_cfg_buckets_n); // initial buckets (abt.FDb.ind_cfg)
    if (!_db.ind_cfg_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_cfg)
    }
    memset(_db.ind_cfg_buckets_elems, 0, sizeof(abt::FCfg*)*_db.ind_cfg_buckets_n); // (abt.FDb.ind_cfg)
    // initialize LAry uname (abt.FDb.uname)
    _db.uname_n = 0;
    memset(_db.uname_lary, 0, sizeof(_db.uname_lary)); // zero out all level pointers
    abt::FUname* uname_first = (abt::FUname*)abt::lpool_AllocMem(sizeof(abt::FUname) * (u64(1)<<4));
    if (!uname_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.uname_lary[i]  = uname_first;
        uname_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FUname;
    _db.ind_uname_n             	= 0; // (abt.FDb.ind_uname)
    _db.ind_uname_buckets_n     	= 4; // (abt.FDb.ind_uname)
    _db.ind_uname_buckets_elems 	= (abt::FUname**)abt::lpool_AllocMem(sizeof(abt::FUname*)*_db.ind_uname_buckets_n); // initial buckets (abt.FDb.ind_uname)
    if (!_db.ind_uname_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_uname)
    }
    memset(_db.ind_uname_buckets_elems, 0, sizeof(abt::FUname*)*_db.ind_uname_buckets_n); // (abt.FDb.ind_uname)
    // initialize LAry compiler (abt.FDb.compiler)
    _db.compiler_n = 0;
    memset(_db.compiler_lary, 0, sizeof(_db.compiler_lary)); // zero out all level pointers
    abt::FCompiler* compiler_first = (abt::FCompiler*)abt::lpool_AllocMem(sizeof(abt::FCompiler) * (u64(1)<<4));
    if (!compiler_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.compiler_lary[i]  = compiler_first;
        compiler_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FCompiler;
    _db.ind_compiler_n             	= 0; // (abt.FDb.ind_compiler)
    _db.ind_compiler_buckets_n     	= 4; // (abt.FDb.ind_compiler)
    _db.ind_compiler_buckets_elems 	= (abt::FCompiler**)abt::lpool_AllocMem(sizeof(abt::FCompiler*)*_db.ind_compiler_buckets_n); // initial buckets (abt.FDb.ind_compiler)
    if (!_db.ind_compiler_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_compiler)
    }
    memset(_db.ind_compiler_buckets_elems, 0, sizeof(abt::FCompiler*)*_db.ind_compiler_buckets_n); // (abt.FDb.ind_compiler)
    // initialize LAry arch (abt.FDb.arch)
    _db.arch_n = 0;
    memset(_db.arch_lary, 0, sizeof(_db.arch_lary)); // zero out all level pointers
    abt::FArch* arch_first = (abt::FArch*)abt::lpool_AllocMem(sizeof(abt::FArch) * (u64(1)<<4));
    if (!arch_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.arch_lary[i]  = arch_first;
        arch_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FArch;
    _db.ind_arch_n             	= 0; // (abt.FDb.ind_arch)
    _db.ind_arch_buckets_n     	= 4; // (abt.FDb.ind_arch)
    _db.ind_arch_buckets_elems 	= (abt::FArch**)abt::lpool_AllocMem(sizeof(abt::FArch*)*_db.ind_arch_buckets_n); // initial buckets (abt.FDb.ind_arch)
    if (!_db.ind_arch_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_arch)
    }
    memset(_db.ind_arch_buckets_elems, 0, sizeof(abt::FArch*)*_db.ind_arch_buckets_n); // (abt.FDb.ind_arch)
    _db.bh_syscmd_max   	= 0; // (abt.FDb.bh_syscmd)
    _db.bh_syscmd_n     	= 0; // (abt.FDb.bh_syscmd)
    _db.bh_syscmd_elems 	= NULL; // (abt.FDb.bh_syscmd)
    _db.zs_srcfile_read_head = NULL; // (abt.FDb.zs_srcfile_read)
    _db.zs_srcfile_read_tail = NULL; // (abt.FDb.zs_srcfile_read)
    _db.zs_sel_target_head = NULL; // (abt.FDb.zs_sel_target)
    _db.zs_sel_target_n = 0; // (abt.FDb.zs_sel_target)
    _db.zs_sel_target_tail = NULL; // (abt.FDb.zs_sel_target)
    // initialize LAry targsyslib (abt.FDb.targsyslib)
    _db.targsyslib_n = 0;
    memset(_db.targsyslib_lary, 0, sizeof(_db.targsyslib_lary)); // zero out all level pointers
    abt::FTargsyslib* targsyslib_first = (abt::FTargsyslib*)abt::lpool_AllocMem(sizeof(abt::FTargsyslib) * (u64(1)<<4));
    if (!targsyslib_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targsyslib_lary[i]  = targsyslib_first;
        targsyslib_first    += 1ULL<<i;
    }
    // initialize LAry syslib (abt.FDb.syslib)
    _db.syslib_n = 0;
    memset(_db.syslib_lary, 0, sizeof(_db.syslib_lary)); // zero out all level pointers
    abt::FSyslib* syslib_first = (abt::FSyslib*)abt::lpool_AllocMem(sizeof(abt::FSyslib) * (u64(1)<<4));
    if (!syslib_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.syslib_lary[i]  = syslib_first;
        syslib_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FSyslib;
    _db.ind_syslib_n             	= 0; // (abt.FDb.ind_syslib)
    _db.ind_syslib_buckets_n     	= 4; // (abt.FDb.ind_syslib)
    _db.ind_syslib_buckets_elems 	= (abt::FSyslib**)abt::lpool_AllocMem(sizeof(abt::FSyslib*)*_db.ind_syslib_buckets_n); // initial buckets (abt.FDb.ind_syslib)
    if (!_db.ind_syslib_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_syslib)
    }
    memset(_db.ind_syslib_buckets_elems, 0, sizeof(abt::FSyslib*)*_db.ind_syslib_buckets_n); // (abt.FDb.ind_syslib)
    // initialize LAry include (abt.FDb.include)
    _db.include_n = 0;
    memset(_db.include_lary, 0, sizeof(_db.include_lary)); // zero out all level pointers
    abt::FInclude* include_first = (abt::FInclude*)abt::lpool_AllocMem(sizeof(abt::FInclude) * (u64(1)<<4));
    if (!include_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.include_lary[i]  = include_first;
        include_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FInclude;
    _db.ind_include_n             	= 0; // (abt.FDb.ind_include)
    _db.ind_include_buckets_n     	= 4; // (abt.FDb.ind_include)
    _db.ind_include_buckets_elems 	= (abt::FInclude**)abt::lpool_AllocMem(sizeof(abt::FInclude*)*_db.ind_include_buckets_n); // initial buckets (abt.FDb.ind_include)
    if (!_db.ind_include_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_include)
    }
    memset(_db.ind_include_buckets_elems, 0, sizeof(abt::FInclude*)*_db.ind_include_buckets_n); // (abt.FDb.ind_include)
    _db.sysincl_elems 	= 0; // (abt.FDb.sysincl)
    _db.sysincl_n     	= 0; // (abt.FDb.sysincl)
    _db.sysincl_max   	= 0; // (abt.FDb.sysincl)
    _db.zs_origsel_target_head = NULL; // (abt.FDb.zs_origsel_target)
    _db.zs_origsel_target_tail = NULL; // (abt.FDb.zs_origsel_target)
    // initialize LAry ns (abt.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    abt::FNs* ns_first = (abt::FNs*)abt::lpool_AllocMem(sizeof(abt::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FNs;
    _db.ind_ns_n             	= 0; // (abt.FDb.ind_ns)
    _db.ind_ns_buckets_n     	= 4; // (abt.FDb.ind_ns)
    _db.ind_ns_buckets_elems 	= (abt::FNs**)abt::lpool_AllocMem(sizeof(abt::FNs*)*_db.ind_ns_buckets_n); // initial buckets (abt.FDb.ind_ns)
    if (!_db.ind_ns_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_ns)
    }
    memset(_db.ind_ns_buckets_elems, 0, sizeof(abt::FNs*)*_db.ind_ns_buckets_n); // (abt.FDb.ind_ns)
    _db.ccache = bool(false);
    _db.gcache = bool(false);
    // initialize LAry filestat (abt.FDb.filestat)
    _db.filestat_n = 0;
    memset(_db.filestat_lary, 0, sizeof(_db.filestat_lary)); // zero out all level pointers
    abt::FFilestat* filestat_first = (abt::FFilestat*)abt::lpool_AllocMem(sizeof(abt::FFilestat) * (u64(1)<<4));
    if (!filestat_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.filestat_lary[i]  = filestat_first;
        filestat_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FFilestat;
    _db.ind_filestat_n             	= 0; // (abt.FDb.ind_filestat)
    _db.ind_filestat_buckets_n     	= 4; // (abt.FDb.ind_filestat)
    _db.ind_filestat_buckets_elems 	= (abt::FFilestat**)abt::lpool_AllocMem(sizeof(abt::FFilestat*)*_db.ind_filestat_buckets_n); // initial buckets (abt.FDb.ind_filestat)
    if (!_db.ind_filestat_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_filestat)
    }
    memset(_db.ind_filestat_buckets_elems, 0, sizeof(abt::FFilestat*)*_db.ind_filestat_buckets_n); // (abt.FDb.ind_filestat)
    // initialize LAry builddir (abt.FDb.builddir)
    _db.builddir_n = 0;
    memset(_db.builddir_lary, 0, sizeof(_db.builddir_lary)); // zero out all level pointers
    abt::FBuilddir* builddir_first = (abt::FBuilddir*)abt::lpool_AllocMem(sizeof(abt::FBuilddir) * (u64(1)<<4));
    if (!builddir_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.builddir_lary[i]  = builddir_first;
        builddir_first    += 1ULL<<i;
    }
    // initialize hash table for abt::FBuilddir;
    _db.ind_builddir_n             	= 0; // (abt.FDb.ind_builddir)
    _db.ind_builddir_buckets_n     	= 4; // (abt.FDb.ind_builddir)
    _db.ind_builddir_buckets_elems 	= (abt::FBuilddir**)abt::lpool_AllocMem(sizeof(abt::FBuilddir*)*_db.ind_builddir_buckets_n); // initial buckets (abt.FDb.ind_builddir)
    if (!_db.ind_builddir_buckets_elems) {
        FatalErrorExit("out of memory"); // (abt.FDb.ind_builddir)
    }
    memset(_db.ind_builddir_buckets_elems, 0, sizeof(abt::FBuilddir*)*_db.ind_builddir_buckets_n); // (abt.FDb.ind_builddir)
    _db.c_builddir = NULL;
    _db.zd_inclstack_head = NULL; // (abt.FDb.zd_inclstack)
    _db.zd_inclstack_n = 0; // (abt.FDb.zd_inclstack)
    _db.zd_inclstack_tail = NULL; // (abt.FDb.zd_inclstack)
    _db.tty = bool(false);

    abt::InitReflection();
}

// --- abt.FDb..Uninit
void abt::FDb_Uninit() {
    abt::FDb &row = _db; (void)row;

    // abt.FDb.ind_builddir.Uninit (Thash)  //
    // skip destruction of ind_builddir in global scope

    // abt.FDb.builddir.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_filestat.Uninit (Thash)  //
    // skip destruction of ind_filestat in global scope

    // abt.FDb.filestat.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_ns.Uninit (Thash)  //
    // skip destruction of ind_ns in global scope

    // abt.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.sysincl.Uninit (Tary)  //Array of system include dirs to try
    // remove all elements from abt.FDb.sysincl
    sysincl_RemoveAll();
    // free memory for Tary abt.FDb.sysincl
    abt::lpool_FreeMem(_db.sysincl_elems, sizeof(algo::cstring)*_db.sysincl_max); // (abt.FDb.sysincl)

    // abt.FDb.ind_include.Uninit (Thash)  //
    // skip destruction of ind_include in global scope

    // abt.FDb.include.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_syslib.Uninit (Thash)  //
    // skip destruction of ind_syslib in global scope

    // abt.FDb.syslib.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.targsyslib.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.bh_syscmd.Uninit (Bheap)  //
    // skip destruction in global scope

    // abt.FDb.ind_arch.Uninit (Thash)  //
    // skip destruction of ind_arch in global scope

    // abt.FDb.arch.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_compiler.Uninit (Thash)  //
    // skip destruction of ind_compiler in global scope

    // abt.FDb.compiler.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_uname.Uninit (Thash)  //
    // skip destruction of ind_uname in global scope

    // abt.FDb.uname.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_cfg.Uninit (Thash)  //
    // skip destruction of ind_cfg in global scope

    // abt.FDb.cfg.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_srcfile.Uninit (Thash)  //
    // skip destruction of ind_srcfile in global scope

    // abt.FDb.ind_running.Uninit (Thash)  //
    // skip destruction of ind_running in global scope

    // abt.FDb.ind_syscmd.Uninit (Thash)  //
    // skip destruction of ind_syscmd in global scope

    // abt.FDb.syscmd.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.syscmddep.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.targsrc.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_targsrc.Uninit (Thash)  //
    // skip destruction of ind_targsrc in global scope

    // abt.FDb.target.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.ind_target.Uninit (Thash)  //
    // skip destruction of ind_target in global scope

    // abt.FDb.tool_opt.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.targdep.Uninit (Lary)  //
    // skip destruction in global scope

    // abt.FDb.srcfile.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- abt.FFilestat..Uninit
void abt::FFilestat_Uninit(abt::FFilestat& filestat) {
    abt::FFilestat &row = filestat; (void)row;
    ind_filestat_Remove(row); // remove filestat from index ind_filestat
}

// --- abt.FInclude.msghdr.CopyOut
// Copy fields out of row
void abt::include_CopyOut(abt::FInclude &row, dev::Include &out) {
    out.include = row.include;
    out.sys = row.sys;
    out.comment = row.comment;
}

// --- abt.FInclude.msghdr.CopyIn
// Copy fields in to row
void abt::include_CopyIn(abt::FInclude &row, dev::Include &in) {
    row.include = in.include;
    row.sys = in.sys;
    row.comment = in.comment;
}

// --- abt.FInclude.srcfile.Get
algo::Smallstr200 abt::srcfile_Get(abt::FInclude& include) {
    algo::Smallstr200 ret(algo::Pathcomp(include.include, ":LL"));
    return ret;
}

// --- abt.FInclude.filename.Get
algo::Smallstr200 abt::filename_Get(abt::FInclude& include) {
    algo::Smallstr200 ret(algo::Pathcomp(include.include, ":LR"));
    return ret;
}

// --- abt.FInclude..Uninit
void abt::FInclude_Uninit(abt::FInclude& include) {
    abt::FInclude &row = include; (void)row;
    ind_include_Remove(row); // remove include from index ind_include
    abt::FSrcfile* p_srcfile = abt::ind_srcfile_Find(srcfile_Get(row));
    if (p_srcfile)  {
        zd_include_Remove(*p_srcfile, row);// remove include from index zd_include
    }
}

// --- abt.FNs.base.CopyOut
// Copy fields out of row
void abt::ns_CopyOut(abt::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.license = row.license;
    out.comment = row.comment;
}

// --- abt.FNs.base.CopyIn
// Copy fields in to row
void abt::ns_CopyIn(abt::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.license = in.license;
    row.comment = in.comment;
}

// --- abt.FNs..Uninit
void abt::FNs_Uninit(abt::FNs& ns) {
    abt::FNs &row = ns; (void)row;
    ind_ns_Remove(row); // remove ns from index ind_ns
}

// --- abt.FSrcfile.msghdr.CopyOut
// Copy fields out of row
void abt::srcfile_CopyOut(abt::FSrcfile &row, dev::Srcfile &out) {
    out.srcfile = row.srcfile;
}

// --- abt.FSrcfile.msghdr.CopyIn
// Copy fields in to row
void abt::srcfile_CopyIn(abt::FSrcfile &row, dev::Srcfile &in) {
    row.srcfile = in.srcfile;
}

// --- abt.FSrcfile.ext.Get
algo::Smallstr10 abt::ext_Get(abt::FSrcfile& srcfile) {
    algo::Smallstr10 ret(algo::Pathcomp(srcfile.srcfile, ".RR"));
    return ret;
}

// --- abt.FSrcfile.zd_include.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void abt::zd_include_Insert(abt::FSrcfile& srcfile, abt::FInclude& row) {
    if (!srcfile_zd_include_InLlistQ(row)) {
        abt::FInclude* old_tail = srcfile.zd_include_tail;
        row.srcfile_zd_include_next = NULL;
        row.srcfile_zd_include_prev = old_tail;
        srcfile.zd_include_tail = &row;
        abt::FInclude **new_row_a = &old_tail->srcfile_zd_include_next;
        abt::FInclude **new_row_b = &srcfile.zd_include_head;
        abt::FInclude **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        srcfile.zd_include_n++;
    }
}

// --- abt.FSrcfile.zd_include.Remove
// Remove element from index. If element is not in index, do nothing.
void abt::zd_include_Remove(abt::FSrcfile& srcfile, abt::FInclude& row) {
    if (srcfile_zd_include_InLlistQ(row)) {
        abt::FInclude* old_head       = srcfile.zd_include_head;
        (void)old_head; // in case it's not used
        abt::FInclude* prev = row.srcfile_zd_include_prev;
        abt::FInclude* next = row.srcfile_zd_include_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        abt::FInclude **new_next_a = &prev->srcfile_zd_include_next;
        abt::FInclude **new_next_b = &srcfile.zd_include_head;
        abt::FInclude **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        abt::FInclude **new_prev_a = &next->srcfile_zd_include_prev;
        abt::FInclude **new_prev_b = &srcfile.zd_include_tail;
        abt::FInclude **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        srcfile.zd_include_n--;
        row.srcfile_zd_include_next=(abt::FInclude*)-1; // not-in-list
    }
}

// --- abt.FSrcfile.zd_include.RemoveAll
// Empty the index. (The rows are not deleted)
void abt::zd_include_RemoveAll(abt::FSrcfile& srcfile) {
    abt::FInclude* row = srcfile.zd_include_head;
    srcfile.zd_include_head = NULL;
    srcfile.zd_include_tail = NULL;
    srcfile.zd_include_n = 0;
    while (row) {
        abt::FInclude* row_next = row->srcfile_zd_include_next;
        row->srcfile_zd_include_next  = (abt::FInclude*)-1;
        row->srcfile_zd_include_prev  = NULL;
        row = row_next;
    }
}

// --- abt.FSrcfile.zd_include.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
abt::FInclude* abt::zd_include_RemoveFirst(abt::FSrcfile& srcfile) {
    abt::FInclude *row = NULL;
    row = srcfile.zd_include_head;
    if (row) {
        abt::FInclude *next = row->srcfile_zd_include_next;
        srcfile.zd_include_head = next;
        abt::FInclude **new_end_a = &next->srcfile_zd_include_prev;
        abt::FInclude **new_end_b = &srcfile.zd_include_tail;
        abt::FInclude **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        srcfile.zd_include_n--;
        row->srcfile_zd_include_next = (abt::FInclude*)-1; // mark as not-in-list
    }
    return row;
}

// --- abt.FSrcfile..Init
// Set all fields to initial values.
void abt::FSrcfile_Init(abt::FSrcfile& srcfile) {
    srcfile.p_target = NULL;
    srcfile.ood = bool(false);
    srcfile.cum_mod_visited = bool(false);
    srcfile.line_n = u64(0);
    srcfile.srcfile_visited = bool(false);
    srcfile.zd_include_head = NULL; // (abt.FSrcfile.zd_include)
    srcfile.zd_include_n = 0; // (abt.FSrcfile.zd_include)
    srcfile.zd_include_tail = NULL; // (abt.FSrcfile.zd_include)
    srcfile.printed = bool(false);
    srcfile.ind_srcfile_next = (abt::FSrcfile*)-1; // (abt.FDb.ind_srcfile) not-in-hash
    srcfile.ind_srcfile_hashval = 0; // stored hash value
    srcfile.zs_srcfile_read_next = (abt::FSrcfile*)-1; // (abt.FDb.zs_srcfile_read) not-in-list
    srcfile.zd_inclstack_next = (abt::FSrcfile*)-1; // (abt.FDb.zd_inclstack) not-in-list
    srcfile.zd_inclstack_prev = NULL; // (abt.FDb.zd_inclstack)
}

// --- abt.FSrcfile..Uninit
void abt::FSrcfile_Uninit(abt::FSrcfile& srcfile) {
    abt::FSrcfile &row = srcfile; (void)row;
    ind_srcfile_Remove(row); // remove srcfile from index ind_srcfile
    zs_srcfile_read_Remove(row); // remove srcfile from index zs_srcfile_read
    zd_inclstack_Remove(row); // remove srcfile from index zd_inclstack
}

// --- abt.FSyscmd.msghdr.CopyOut
// Copy fields out of row
void abt::syscmd_CopyOut(abt::FSyscmd &row, dev::Syscmd &out) {
    out.syscmd = row.syscmd;
    out.command = row.command;
    out.pid = row.pid;
    out.status = row.status;
    out.nprereq = row.nprereq;
    out.fail_prereq = row.fail_prereq;
    out.completed = row.completed;
    out.maxtime = row.maxtime;
}

// --- abt.FSyscmd.msghdr.CopyIn
// Copy fields in to row
void abt::syscmd_CopyIn(abt::FSyscmd &row, dev::Syscmd &in) {
    row.syscmd = in.syscmd;
    row.command = in.command;
    row.pid = in.pid;
    row.status = in.status;
    row.nprereq = in.nprereq;
    row.fail_prereq = in.fail_prereq;
    row.completed = in.completed;
    row.maxtime = in.maxtime;
}

// --- abt.FSyscmd.c_prior.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_prior_Insert(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    if (!row.syscmd_c_prior_in_ary) {
        c_prior_Reserve(syscmd, 1);
        u32 n  = syscmd.c_prior_n++;
        syscmd.c_prior_elems[n] = &row;
        row.syscmd_c_prior_in_ary = true;
    }
}

// --- abt.FSyscmd.c_prior.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool abt::c_prior_InsertMaybe(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    bool retval = !syscmd_c_prior_InAryQ(row);
    c_prior_Insert(syscmd,row); // check is performed in _Insert again
    return retval;
}

// --- abt.FSyscmd.c_prior.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_prior_Remove(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    int n = syscmd.c_prior_n;
    if (bool_Update(row.syscmd_c_prior_in_ary,false)) {
        abt::FSyscmddep* *elems = syscmd.c_prior_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = n-1; i>=0; i--) {
            abt::FSyscmddep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(abt::FSyscmddep*) * (n - j);
                memmove(elems + i, elems + j, nbytes);
                syscmd.c_prior_n = n - 1;
                break;
            }
        }
    }
}

// --- abt.FSyscmd.c_prior.Reserve
// Reserve space in index for N more elements;
void abt::c_prior_Reserve(abt::FSyscmd& syscmd, u32 n) {
    u32 old_max = syscmd.c_prior_max;
    if (UNLIKELY(syscmd.c_prior_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FSyscmddep*);
        u32 new_size = new_max * sizeof(abt::FSyscmddep*);
        void *new_mem = abt::lpool_ReallocMem(syscmd.c_prior_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FSyscmd.c_prior");
        }
        syscmd.c_prior_elems = (abt::FSyscmddep**)new_mem;
        syscmd.c_prior_max = new_max;
    }
}

// --- abt.FSyscmd.c_next.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_next_Insert(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    if (!row.syscmd_c_next_in_ary) {
        c_next_Reserve(syscmd, 1);
        u32 n  = syscmd.c_next_n++;
        syscmd.c_next_elems[n] = &row;
        row.syscmd_c_next_in_ary = true;
    }
}

// --- abt.FSyscmd.c_next.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool abt::c_next_InsertMaybe(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    bool retval = !syscmd_c_next_InAryQ(row);
    c_next_Insert(syscmd,row); // check is performed in _Insert again
    return retval;
}

// --- abt.FSyscmd.c_next.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_next_Remove(abt::FSyscmd& syscmd, abt::FSyscmddep& row) {
    int n = syscmd.c_next_n;
    if (bool_Update(row.syscmd_c_next_in_ary,false)) {
        abt::FSyscmddep* *elems = syscmd.c_next_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = n-1; i>=0; i--) {
            abt::FSyscmddep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(abt::FSyscmddep*) * (n - j);
                memmove(elems + i, elems + j, nbytes);
                syscmd.c_next_n = n - 1;
                break;
            }
        }
    }
}

// --- abt.FSyscmd.c_next.Reserve
// Reserve space in index for N more elements;
void abt::c_next_Reserve(abt::FSyscmd& syscmd, u32 n) {
    u32 old_max = syscmd.c_next_max;
    if (UNLIKELY(syscmd.c_next_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FSyscmddep*);
        u32 new_size = new_max * sizeof(abt::FSyscmddep*);
        void *new_mem = abt::lpool_ReallocMem(syscmd.c_next_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FSyscmd.c_next");
        }
        syscmd.c_next_elems = (abt::FSyscmddep**)new_mem;
        syscmd.c_next_max = new_max;
    }
}

// --- abt.FSyscmd..Init
// Set all fields to initial values.
void abt::FSyscmd_Init(abt::FSyscmd& syscmd) {
    syscmd.syscmd = i64(0);
    syscmd.pid = i32(0);
    syscmd.status = i32(0);
    syscmd.nprereq = i32(0);
    syscmd.fail_prereq = bool(false);
    syscmd.completed = bool(false);
    syscmd.maxtime = i32(0);
    syscmd.c_prior_elems = NULL; // (abt.FSyscmd.c_prior)
    syscmd.c_prior_n = 0; // (abt.FSyscmd.c_prior)
    syscmd.c_prior_max = 0; // (abt.FSyscmd.c_prior)
    syscmd.c_next_elems = NULL; // (abt.FSyscmd.c_next)
    syscmd.c_next_n = 0; // (abt.FSyscmd.c_next)
    syscmd.c_next_max = 0; // (abt.FSyscmd.c_next)
    syscmd.rowid = i32(0);
    syscmd.line_n = u64(0);
    syscmd.redirect = bool(true);
    syscmd.ind_syscmd_next = (abt::FSyscmd*)-1; // (abt.FDb.ind_syscmd) not-in-hash
    syscmd.ind_syscmd_hashval = 0; // stored hash value
    syscmd.ind_running_next = (abt::FSyscmd*)-1; // (abt.FDb.ind_running) not-in-hash
    syscmd.ind_running_hashval = 0; // stored hash value
    syscmd.bh_syscmd_idx = -1; // (abt.FDb.bh_syscmd) not-in-heap
}

// --- abt.FSyscmd..Uninit
void abt::FSyscmd_Uninit(abt::FSyscmd& syscmd) {
    abt::FSyscmd &row = syscmd; (void)row;
    ind_syscmd_Remove(row); // remove syscmd from index ind_syscmd
    ind_running_Remove(row); // remove syscmd from index ind_running
    bh_syscmd_Remove(row); // remove syscmd from index bh_syscmd

    // abt.FSyscmd.c_next.Uninit (Ptrary)  //
    abt::lpool_FreeMem(syscmd.c_next_elems, sizeof(abt::FSyscmddep*)*syscmd.c_next_max); // (abt.FSyscmd.c_next)

    // abt.FSyscmd.c_prior.Uninit (Ptrary)  //
    abt::lpool_FreeMem(syscmd.c_prior_elems, sizeof(abt::FSyscmddep*)*syscmd.c_prior_max); // (abt.FSyscmd.c_prior)
}

// --- abt.FSyscmddep.msghdr.CopyOut
// Copy fields out of row
void abt::syscmddep_CopyOut(abt::FSyscmddep &row, dev::Syscmddep &out) {
    out.child = row.child;
    out.parent = row.parent;
}

// --- abt.FSyscmddep.msghdr.CopyIn
// Copy fields in to row
void abt::syscmddep_CopyIn(abt::FSyscmddep &row, dev::Syscmddep &in) {
    row.child = in.child;
    row.parent = in.parent;
}

// --- abt.FSyscmddep..Uninit
void abt::FSyscmddep_Uninit(abt::FSyscmddep& syscmddep) {
    abt::FSyscmddep &row = syscmddep; (void)row;
    abt::FSyscmd* p_child = abt::ind_syscmd_Find(row.child);
    if (p_child)  {
        c_prior_Remove(*p_child, row);// remove syscmddep from index c_prior
    }
    abt::FSyscmd* p_parent = abt::ind_syscmd_Find(row.parent);
    if (p_parent)  {
        c_next_Remove(*p_parent, row);// remove syscmddep from index c_next
    }
}

// --- abt.FSyslib.msghdr.CopyOut
// Copy fields out of row
void abt::syslib_CopyOut(abt::FSyslib &row, dev::Syslib &out) {
    out.syslib = row.syslib;
    out.comment = row.comment;
}

// --- abt.FSyslib.msghdr.CopyIn
// Copy fields in to row
void abt::syslib_CopyIn(abt::FSyslib &row, dev::Syslib &in) {
    row.syslib = in.syslib;
    row.comment = in.comment;
}

// --- abt.FSyslib..Uninit
void abt::FSyslib_Uninit(abt::FSyslib& syslib) {
    abt::FSyslib &row = syslib; (void)row;
    ind_syslib_Remove(row); // remove syslib from index ind_syslib
}

// --- abt.FTargdep.msghdr.CopyOut
// Copy fields out of row
void abt::targdep_CopyOut(abt::FTargdep &row, dev::Targdep &out) {
    out.targdep = row.targdep;
    out.comment = row.comment;
}

// --- abt.FTargdep.msghdr.CopyIn
// Copy fields in to row
void abt::targdep_CopyIn(abt::FTargdep &row, dev::Targdep &in) {
    row.targdep = in.targdep;
    row.comment = in.comment;
}

// --- abt.FTargdep.target.Get
algo::Smallstr16 abt::target_Get(abt::FTargdep& targdep) {
    algo::Smallstr16 ret(algo::Pathcomp(targdep.targdep, ".RL"));
    return ret;
}

// --- abt.FTargdep.parent.Get
algo::Smallstr16 abt::parent_Get(abt::FTargdep& targdep) {
    algo::Smallstr16 ret(algo::Pathcomp(targdep.targdep, ".RR"));
    return ret;
}

// --- abt.FTargdep..Uninit
void abt::FTargdep_Uninit(abt::FTargdep& targdep) {
    abt::FTargdep &row = targdep; (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (p_target)  {
        c_targdep_Remove(*p_target, row);// remove targdep from index c_targdep
    }
}

// --- abt.FTarget.msghdr.CopyOut
// Copy fields out of row
void abt::target_CopyOut(abt::FTarget &row, dev::Target &out) {
    out.target = row.target;
}

// --- abt.FTarget.msghdr.CopyIn
// Copy fields in to row
void abt::target_CopyIn(abt::FTarget &row, dev::Target &in) {
    row.target = in.target;
}

// --- abt.FTarget.c_targsrc.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_targsrc_Insert(abt::FTarget& target, abt::FTargsrc& row) {
    if (!row.target_c_targsrc_in_ary) {
        c_targsrc_Reserve(target, 1);
        u32 n  = target.c_targsrc_n++;
        target.c_targsrc_elems[n] = &row;
        row.target_c_targsrc_in_ary = true;
    }
}

// --- abt.FTarget.c_targsrc.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool abt::c_targsrc_InsertMaybe(abt::FTarget& target, abt::FTargsrc& row) {
    bool retval = !target_c_targsrc_InAryQ(row);
    c_targsrc_Insert(target,row); // check is performed in _Insert again
    return retval;
}

// --- abt.FTarget.c_targsrc.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_targsrc_Remove(abt::FTarget& target, abt::FTargsrc& row) {
    int n = target.c_targsrc_n;
    if (bool_Update(row.target_c_targsrc_in_ary,false)) {
        abt::FTargsrc* *elems = target.c_targsrc_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = n-1; i>=0; i--) {
            abt::FTargsrc* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(abt::FTargsrc*) * (n - j);
                memmove(elems + i, elems + j, nbytes);
                target.c_targsrc_n = n - 1;
                break;
            }
        }
    }
}

// --- abt.FTarget.c_targsrc.Reserve
// Reserve space in index for N more elements;
void abt::c_targsrc_Reserve(abt::FTarget& target, u32 n) {
    u32 old_max = target.c_targsrc_max;
    if (UNLIKELY(target.c_targsrc_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FTargsrc*);
        u32 new_size = new_max * sizeof(abt::FTargsrc*);
        void *new_mem = abt::lpool_ReallocMem(target.c_targsrc_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FTarget.c_targsrc");
        }
        target.c_targsrc_elems = (abt::FTargsrc**)new_mem;
        target.c_targsrc_max = new_max;
    }
}

// --- abt.FTarget.c_srcfile.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_srcfile_Insert(abt::FTarget& target, abt::FSrcfile& row) {
    c_srcfile_Reserve(target, 1);
    u32 n  = target.c_srcfile_n++;
    target.c_srcfile_elems[n] = &row;
}

// --- abt.FTarget.c_srcfile.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool abt::c_srcfile_ScanInsertMaybe(abt::FTarget& target, abt::FSrcfile& row) {
    bool retval = true;
    u32 n  = target.c_srcfile_n;
    for (u32 i = 0; i < n; i++) {
        if (target.c_srcfile_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_srcfile_Reserve(target, 1);
        target.c_srcfile_elems[n] = &row;
        target.c_srcfile_n = n+1;
    }
    return retval;
}

// --- abt.FTarget.c_srcfile.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_srcfile_Remove(abt::FTarget& target, abt::FSrcfile& row) {
    int n = target.c_srcfile_n;
    int j=0;
    for (int i=0; i<n; i++) {
        if (target.c_srcfile_elems[i] == &row) {
        } else {
            if (j != i) {
                target.c_srcfile_elems[j] = target.c_srcfile_elems[i];
            }
            j++;
        }
    }
    target.c_srcfile_n = j;
}

// --- abt.FTarget.c_srcfile.Reserve
// Reserve space in index for N more elements;
void abt::c_srcfile_Reserve(abt::FTarget& target, u32 n) {
    u32 old_max = target.c_srcfile_max;
    if (UNLIKELY(target.c_srcfile_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FSrcfile*);
        u32 new_size = new_max * sizeof(abt::FSrcfile*);
        void *new_mem = abt::lpool_ReallocMem(target.c_srcfile_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FTarget.c_srcfile");
        }
        target.c_srcfile_elems = (abt::FSrcfile**)new_mem;
        target.c_srcfile_max = new_max;
    }
}

// --- abt.FTarget.c_targdep.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_targdep_Insert(abt::FTarget& target, abt::FTargdep& row) {
    if (!row.target_c_targdep_in_ary) {
        c_targdep_Reserve(target, 1);
        u32 n  = target.c_targdep_n++;
        target.c_targdep_elems[n] = &row;
        row.target_c_targdep_in_ary = true;
    }
}

// --- abt.FTarget.c_targdep.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool abt::c_targdep_InsertMaybe(abt::FTarget& target, abt::FTargdep& row) {
    bool retval = !target_c_targdep_InAryQ(row);
    c_targdep_Insert(target,row); // check is performed in _Insert again
    return retval;
}

// --- abt.FTarget.c_targdep.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_targdep_Remove(abt::FTarget& target, abt::FTargdep& row) {
    int n = target.c_targdep_n;
    if (bool_Update(row.target_c_targdep_in_ary,false)) {
        abt::FTargdep* *elems = target.c_targdep_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = n-1; i>=0; i--) {
            abt::FTargdep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(abt::FTargdep*) * (n - j);
                memmove(elems + i, elems + j, nbytes);
                target.c_targdep_n = n - 1;
                break;
            }
        }
    }
}

// --- abt.FTarget.c_targdep.Reserve
// Reserve space in index for N more elements;
void abt::c_targdep_Reserve(abt::FTarget& target, u32 n) {
    u32 old_max = target.c_targdep_max;
    if (UNLIKELY(target.c_targdep_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FTargdep*);
        u32 new_size = new_max * sizeof(abt::FTargdep*);
        void *new_mem = abt::lpool_ReallocMem(target.c_targdep_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FTarget.c_targdep");
        }
        target.c_targdep_elems = (abt::FTargdep**)new_mem;
        target.c_targdep_max = new_max;
    }
}

// --- abt.FTarget.c_targsyslib.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_targsyslib_Insert(abt::FTarget& target, abt::FTargsyslib& row) {
    if (!row.target_c_targsyslib_in_ary) {
        c_targsyslib_Reserve(target, 1);
        u32 n  = target.c_targsyslib_n++;
        target.c_targsyslib_elems[n] = &row;
        row.target_c_targsyslib_in_ary = true;
    }
}

// --- abt.FTarget.c_targsyslib.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool abt::c_targsyslib_InsertMaybe(abt::FTarget& target, abt::FTargsyslib& row) {
    bool retval = !target_c_targsyslib_InAryQ(row);
    c_targsyslib_Insert(target,row); // check is performed in _Insert again
    return retval;
}

// --- abt.FTarget.c_targsyslib.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_targsyslib_Remove(abt::FTarget& target, abt::FTargsyslib& row) {
    int n = target.c_targsyslib_n;
    if (bool_Update(row.target_c_targsyslib_in_ary,false)) {
        abt::FTargsyslib* *elems = target.c_targsyslib_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = n-1; i>=0; i--) {
            abt::FTargsyslib* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(abt::FTargsyslib*) * (n - j);
                memmove(elems + i, elems + j, nbytes);
                target.c_targsyslib_n = n - 1;
                break;
            }
        }
    }
}

// --- abt.FTarget.c_targsyslib.Reserve
// Reserve space in index for N more elements;
void abt::c_targsyslib_Reserve(abt::FTarget& target, u32 n) {
    u32 old_max = target.c_targsyslib_max;
    if (UNLIKELY(target.c_targsyslib_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FTargsyslib*);
        u32 new_size = new_max * sizeof(abt::FTargsyslib*);
        void *new_mem = abt::lpool_ReallocMem(target.c_targsyslib_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FTarget.c_targsyslib");
        }
        target.c_targsyslib_elems = (abt::FTargsyslib**)new_mem;
        target.c_targsyslib_max = new_max;
    }
}

// --- abt.FTarget.c_alldep.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void abt::c_alldep_Insert(abt::FTarget& target, abt::FTarget& row) {
    c_alldep_Reserve(target, 1);
    u32 n  = target.c_alldep_n++;
    target.c_alldep_elems[n] = &row;
}

// --- abt.FTarget.c_alldep.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool abt::c_alldep_ScanInsertMaybe(abt::FTarget& target, abt::FTarget& row) {
    bool retval = true;
    u32 n  = target.c_alldep_n;
    for (u32 i = 0; i < n; i++) {
        if (target.c_alldep_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_alldep_Reserve(target, 1);
        target.c_alldep_elems[n] = &row;
        target.c_alldep_n = n+1;
    }
    return retval;
}

// --- abt.FTarget.c_alldep.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void abt::c_alldep_Remove(abt::FTarget& target, abt::FTarget& row) {
    int n = target.c_alldep_n;
    int j=0;
    for (int i=0; i<n; i++) {
        if (target.c_alldep_elems[i] == &row) {
        } else {
            if (j != i) {
                target.c_alldep_elems[j] = target.c_alldep_elems[i];
            }
            j++;
        }
    }
    target.c_alldep_n = j;
}

// --- abt.FTarget.c_alldep.Reserve
// Reserve space in index for N more elements;
void abt::c_alldep_Reserve(abt::FTarget& target, u32 n) {
    u32 old_max = target.c_alldep_max;
    if (UNLIKELY(target.c_alldep_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(abt::FTarget*);
        u32 new_size = new_max * sizeof(abt::FTarget*);
        void *new_mem = abt::lpool_ReallocMem(target.c_alldep_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("abt.out_of_memory  field:abt.FTarget.c_alldep");
        }
        target.c_alldep_elems = (abt::FTarget**)new_mem;
        target.c_alldep_max = new_max;
    }
}

// --- abt.FTarget..Init
// Set all fields to initial values.
void abt::FTarget_Init(abt::FTarget& target) {
    target.ood = bool(false);
    target.syscmd_start = NULL;
    target.syscmd_compile = NULL;
    target.syscmd_link = NULL;
    target.syscmd_end = NULL;
    target.c_targsrc_elems = NULL; // (abt.FTarget.c_targsrc)
    target.c_targsrc_n = 0; // (abt.FTarget.c_targsrc)
    target.c_targsrc_max = 0; // (abt.FTarget.c_targsrc)
    target.c_srcfile_elems = NULL; // (abt.FTarget.c_srcfile)
    target.c_srcfile_n = 0; // (abt.FTarget.c_srcfile)
    target.c_srcfile_max = 0; // (abt.FTarget.c_srcfile)
    target.c_targdep_elems = NULL; // (abt.FTarget.c_targdep)
    target.c_targdep_n = 0; // (abt.FTarget.c_targdep)
    target.c_targdep_max = 0; // (abt.FTarget.c_targdep)
    target.ood_visited = bool(false);
    target.c_targsyslib_elems = NULL; // (abt.FTarget.c_targsyslib)
    target.c_targsyslib_n = 0; // (abt.FTarget.c_targsyslib)
    target.c_targsyslib_max = 0; // (abt.FTarget.c_targsyslib)
    target.c_alldep_elems = NULL; // (abt.FTarget.c_alldep)
    target.c_alldep_n = 0; // (abt.FTarget.c_alldep)
    target.c_alldep_max = 0; // (abt.FTarget.c_alldep)
    target.p_ns = NULL;
    target.libdep_visited = bool(false);
    target.origsel = bool(false);
    target.ind_target_next = (abt::FTarget*)-1; // (abt.FDb.ind_target) not-in-hash
    target.ind_target_hashval = 0; // stored hash value
    target.zs_sel_target_next = (abt::FTarget*)-1; // (abt.FDb.zs_sel_target) not-in-list
    target.zs_origsel_target_next = (abt::FTarget*)-1; // (abt.FDb.zs_origsel_target) not-in-list
}

// --- abt.FTarget..Uninit
void abt::FTarget_Uninit(abt::FTarget& target) {
    abt::FTarget &row = target; (void)row;
    ind_target_Remove(row); // remove target from index ind_target
    zs_sel_target_Remove(row); // remove target from index zs_sel_target
    zs_origsel_target_Remove(row); // remove target from index zs_origsel_target

    // abt.FTarget.c_alldep.Uninit (Ptrary)  //Transitive closure of all dependencies for this target
    abt::lpool_FreeMem(target.c_alldep_elems, sizeof(abt::FTarget*)*target.c_alldep_max); // (abt.FTarget.c_alldep)

    // abt.FTarget.c_targsyslib.Uninit (Ptrary)  //
    abt::lpool_FreeMem(target.c_targsyslib_elems, sizeof(abt::FTargsyslib*)*target.c_targsyslib_max); // (abt.FTarget.c_targsyslib)

    // abt.FTarget.c_targdep.Uninit (Ptrary)  //
    abt::lpool_FreeMem(target.c_targdep_elems, sizeof(abt::FTargdep*)*target.c_targdep_max); // (abt.FTarget.c_targdep)

    // abt.FTarget.c_srcfile.Uninit (Ptrary)  //
    abt::lpool_FreeMem(target.c_srcfile_elems, sizeof(abt::FSrcfile*)*target.c_srcfile_max); // (abt.FTarget.c_srcfile)

    // abt.FTarget.c_targsrc.Uninit (Ptrary)  //
    abt::lpool_FreeMem(target.c_targsrc_elems, sizeof(abt::FTargsrc*)*target.c_targsrc_max); // (abt.FTarget.c_targsrc)
}

// --- abt.FTargsrc.msghdr.CopyOut
// Copy fields out of row
void abt::targsrc_CopyOut(abt::FTargsrc &row, dev::Targsrc &out) {
    out.targsrc = row.targsrc;
    out.comment = row.comment;
}

// --- abt.FTargsrc.msghdr.CopyIn
// Copy fields in to row
void abt::targsrc_CopyIn(abt::FTargsrc &row, dev::Targsrc &in) {
    row.targsrc = in.targsrc;
    row.comment = in.comment;
}

// --- abt.FTargsrc.target.Get
algo::Smallstr16 abt::target_Get(abt::FTargsrc& targsrc) {
    algo::Smallstr16 ret(algo::Pathcomp(targsrc.targsrc, "/LL"));
    return ret;
}

// --- abt.FTargsrc.src.Get
algo::Smallstr200 abt::src_Get(abt::FTargsrc& targsrc) {
    algo::Smallstr200 ret(algo::Pathcomp(targsrc.targsrc, "/LR"));
    return ret;
}

// --- abt.FTargsrc.ext.Get
algo::Smallstr10 abt::ext_Get(abt::FTargsrc& targsrc) {
    algo::Smallstr10 ret(algo::Pathcomp(targsrc.targsrc, ".RR"));
    return ret;
}

// --- abt.FTargsrc..Uninit
void abt::FTargsrc_Uninit(abt::FTargsrc& targsrc) {
    abt::FTargsrc &row = targsrc; (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (p_target)  {
        c_targsrc_Remove(*p_target, row);// remove targsrc from index c_targsrc
    }
    ind_targsrc_Remove(row); // remove targsrc from index ind_targsrc
}

// --- abt.FTargsyslib.msghdr.CopyOut
// Copy fields out of row
void abt::targsyslib_CopyOut(abt::FTargsyslib &row, dev::Targsyslib &out) {
    out.targsyslib = row.targsyslib;
    out.comment = row.comment;
}

// --- abt.FTargsyslib.msghdr.CopyIn
// Copy fields in to row
void abt::targsyslib_CopyIn(abt::FTargsyslib &row, dev::Targsyslib &in) {
    row.targsyslib = in.targsyslib;
    row.comment = in.comment;
}

// --- abt.FTargsyslib.target.Get
algo::Smallstr16 abt::target_Get(abt::FTargsyslib& targsyslib) {
    algo::Smallstr16 ret(algo::Pathcomp(targsyslib.targsyslib, "/LR.LL"));
    return ret;
}

// --- abt.FTargsyslib.syslib.Get
algo::Smallstr50 abt::syslib_Get(abt::FTargsyslib& targsyslib) {
    algo::Smallstr50 ret(algo::Pathcomp(targsyslib.targsyslib, "/LR.LR"));
    return ret;
}

// --- abt.FTargsyslib.uname.Get
algo::Smallstr50 abt::uname_Get(abt::FTargsyslib& targsyslib) {
    algo::Smallstr50 ret(algo::Pathcomp(targsyslib.targsyslib, "/LL"));
    return ret;
}

// --- abt.FTargsyslib.prefix.Get
algo::Smallstr50 abt::prefix_Get(abt::FTargsyslib& targsyslib) {
    algo::Smallstr50 ret(algo::Pathcomp(targsyslib.targsyslib, ".RL"));
    return ret;
}

// --- abt.FTargsyslib..Uninit
void abt::FTargsyslib_Uninit(abt::FTargsyslib& targsyslib) {
    abt::FTargsyslib &row = targsyslib; (void)row;
    abt::FTarget* p_target = abt::ind_target_Find(target_Get(row));
    if (p_target)  {
        c_targsyslib_Remove(*p_target, row);// remove targsyslib from index c_targsyslib
    }
}

// --- abt.FToolOpt.msghdr.CopyOut
// Copy fields out of row
void abt::tool_opt_CopyOut(abt::FToolOpt &row, dev::ToolOpt &out) {
    out.tool_opt = row.tool_opt;
    out.comment = row.comment;
}

// --- abt.FToolOpt.msghdr.CopyIn
// Copy fields in to row
void abt::tool_opt_CopyIn(abt::FToolOpt &row, dev::ToolOpt &in) {
    row.tool_opt = in.tool_opt;
    row.comment = in.comment;
}

// --- abt.FToolOpt.uname.Get
algo::Smallstr50 abt::uname_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LL.LL-LL"));
    return ret;
}

// --- abt.FToolOpt.compiler.Get
algo::Smallstr50 abt::compiler_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LL.LL-LR"));
    return ret;
}

// --- abt.FToolOpt.cfg.Get
algo::Smallstr50 abt::cfg_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LL.LR-LL"));
    return ret;
}

// --- abt.FToolOpt.arch.Get
algo::Smallstr50 abt::arch_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LL.LR-LR"));
    return ret;
}

// --- abt.FToolOpt.target.Get
algo::Smallstr50 abt::target_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LR:LL-LL"));
    return ret;
}

// --- abt.FToolOpt.opt_type.Get
algo::Smallstr50 abt::opt_type_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, "/LR:LL-LR"));
    return ret;
}

// --- abt.FToolOpt.opt.Get
algo::Smallstr100 abt::opt_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr100 ret(algo::Pathcomp(tool_opt.tool_opt, "/LR:LR"));
    return ret;
}

// --- abt.FToolOpt.sortfld.Get
algo::Smallstr50 abt::sortfld_Get(abt::FToolOpt& tool_opt) {
    algo::Smallstr50 ret(algo::Pathcomp(tool_opt.tool_opt, ".LL"));
    return ret;
}

// --- abt.FToolOpt.regx_opt.Print
// Print back to string
void abt::regx_opt_Print(abt::FToolOpt& tool_opt, algo::cstring &out) {
    Regx_Print(tool_opt.regx_opt, out);
}

// --- abt.FToolOpt.regx_target.Print
// Print back to string
void abt::regx_target_Print(abt::FToolOpt& tool_opt, algo::cstring &out) {
    Regx_Print(tool_opt.regx_target, out);
}

// --- abt.FUname.msghdr.CopyOut
// Copy fields out of row
void abt::uname_CopyOut(abt::FUname &row, dev::Uname &out) {
    out.uname = row.uname;
    out.comment = row.comment;
}

// --- abt.FUname.msghdr.CopyIn
// Copy fields in to row
void abt::uname_CopyIn(abt::FUname &row, dev::Uname &in) {
    row.uname = in.uname;
    row.comment = in.comment;
}

// --- abt.FUname..Uninit
void abt::FUname_Uninit(abt::FUname& uname) {
    abt::FUname &row = uname; (void)row;
    ind_uname_Remove(row); // remove uname from index ind_uname
}

// --- abt.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* abt::value_ToCstr(const abt::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case abt_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- abt.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void abt::value_Print(const abt::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- abt.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool abt::value_SetStrptrMaybe(abt::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,abt_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- abt.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void abt::value_SetStrptr(abt::FieldId& parent, algo::strptr rhs, abt_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- abt.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool abt::value_ReadStrptrMaybe(abt::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- abt.FieldId..ReadStrptrMaybe
// Read fields of abt::FieldId from an ascii string.
// The format of the string is the format of the abt::FieldId's only field
bool abt::FieldId_ReadStrptrMaybe(abt::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- abt.FieldId..Print
// print string representation of ROW to string STR
// cfmt:abt.FieldId.String  printfmt:Raw
void abt::FieldId_Print(abt::FieldId& row, algo::cstring& str) {
    abt::value_Print(row, str);
}

// --- abt.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* abt::value_ToCstr(const abt::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case abt_TableId_dev_Arch          : ret = "dev.Arch";  break;
        case abt_TableId_dev_Builddir      : ret = "dev.Builddir";  break;
        case abt_TableId_dev_Cfg           : ret = "dev.Cfg";  break;
        case abt_TableId_dev_Compiler      : ret = "dev.Compiler";  break;
        case abt_TableId_dev_Include       : ret = "dev.Include";  break;
        case abt_TableId_dmmeta_Ns         : ret = "dmmeta.Ns";  break;
        case abt_TableId_dev_Syscmd        : ret = "dev.Syscmd";  break;
        case abt_TableId_dev_Syscmddep     : ret = "dev.Syscmddep";  break;
        case abt_TableId_dev_Syslib        : ret = "dev.Syslib";  break;
        case abt_TableId_dev_Targdep       : ret = "dev.Targdep";  break;
        case abt_TableId_dev_Target        : ret = "dev.Target";  break;
        case abt_TableId_dev_Targsrc       : ret = "dev.Targsrc";  break;
        case abt_TableId_dev_Targsyslib    : ret = "dev.Targsyslib";  break;
        case abt_TableId_dev_ToolOpt       : ret = "dev.ToolOpt";  break;
        case abt_TableId_dev_Uname         : ret = "dev.Uname";  break;
    }
    return ret;
}

// --- abt.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void abt::value_Print(const abt::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- abt.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool abt::value_SetStrptrMaybe(abt::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('d','e','v','.','C','f','g'): {
                    value_SetEnum(parent,abt_TableId_dev_Cfg); ret = true; break;
                }
                case LE_STR7('d','e','v','.','c','f','g'): {
                    value_SetEnum(parent,abt_TableId_dev_cfg); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','A','r','c','h'): {
                    value_SetEnum(parent,abt_TableId_dev_Arch); ret = true; break;
                }
                case LE_STR8('d','e','v','.','a','r','c','h'): {
                    value_SetEnum(parent,abt_TableId_dev_arch); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','U','n','a','m'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,abt_TableId_dev_Uname); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','u','n','a','m'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,abt_TableId_dev_uname); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,abt_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,abt_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','S','y','s','c'): {
                    if (memcmp(rhs.elems+8,"md",2)==0) { value_SetEnum(parent,abt_TableId_dev_Syscmd); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','S','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,abt_TableId_dev_Syslib); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,abt_TableId_dev_Target); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','s','y','s','c'): {
                    if (memcmp(rhs.elems+8,"md",2)==0) { value_SetEnum(parent,abt_TableId_dev_syscmd); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','s','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,abt_TableId_dev_syslib); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,abt_TableId_dev_target); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','I','n','c','l'): {
                    if (memcmp(rhs.elems+8,"ude",3)==0) { value_SetEnum(parent,abt_TableId_dev_Include); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"dep",3)==0) { value_SetEnum(parent,abt_TableId_dev_Targdep); ret = true; break; }
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,abt_TableId_dev_Targsrc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','T','o','o','l'): {
                    if (memcmp(rhs.elems+8,"Opt",3)==0) { value_SetEnum(parent,abt_TableId_dev_ToolOpt); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','i','n','c','l'): {
                    if (memcmp(rhs.elems+8,"ude",3)==0) { value_SetEnum(parent,abt_TableId_dev_include); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"dep",3)==0) { value_SetEnum(parent,abt_TableId_dev_targdep); ret = true; break; }
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,abt_TableId_dev_targsrc); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','B','u','i','l'): {
                    if (memcmp(rhs.elems+8,"ddir",4)==0) { value_SetEnum(parent,abt_TableId_dev_Builddir); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','C','o','m','p'): {
                    if (memcmp(rhs.elems+8,"iler",4)==0) { value_SetEnum(parent,abt_TableId_dev_Compiler); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','b','u','i','l'): {
                    if (memcmp(rhs.elems+8,"ddir",4)==0) { value_SetEnum(parent,abt_TableId_dev_builddir); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','c','o','m','p'): {
                    if (memcmp(rhs.elems+8,"iler",4)==0) { value_SetEnum(parent,abt_TableId_dev_compiler); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','o','o','l'): {
                    if (memcmp(rhs.elems+8,"_opt",4)==0) { value_SetEnum(parent,abt_TableId_dev_tool_opt); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','S','y','s','c'): {
                    if (memcmp(rhs.elems+8,"mddep",5)==0) { value_SetEnum(parent,abt_TableId_dev_Syscmddep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','s','y','s','c'): {
                    if (memcmp(rhs.elems+8,"mddep",5)==0) { value_SetEnum(parent,abt_TableId_dev_syscmddep); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"syslib",6)==0) { value_SetEnum(parent,abt_TableId_dev_Targsyslib); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"syslib",6)==0) { value_SetEnum(parent,abt_TableId_dev_targsyslib); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- abt.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void abt::value_SetStrptr(abt::TableId& parent, algo::strptr rhs, abt_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- abt.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool abt::value_ReadStrptrMaybe(abt::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- abt.TableId..ReadStrptrMaybe
// Read fields of abt::TableId from an ascii string.
// The format of the string is the format of the abt::TableId's only field
bool abt::TableId_ReadStrptrMaybe(abt::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- abt.TableId..Print
// print string representation of ROW to string STR
// cfmt:abt.TableId.String  printfmt:Raw
void abt::TableId_Print(abt::TableId& row, algo::cstring& str) {
    abt::value_Print(row, str);
}

// --- abt.config..Print
// print string representation of ROW to string STR
// cfmt:abt.config.String  printfmt:Tuple
void abt::config_Print(abt::config& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "abt.config";

    algo::Smallstr50_Print(row.builddir, temp);
    PrintAttrSpaceReset(str,"builddir", temp);

    i32_Print(row.ood_src, temp);
    PrintAttrSpaceReset(str,"ood_src", temp);

    i32_Print(row.ood_target, temp);
    PrintAttrSpaceReset(str,"ood_target", temp);

    algo::Smallstr20_Print(row.cache, temp);
    PrintAttrSpaceReset(str,"cache", temp);
}

// --- abt...SizeCheck
inline static void abt::SizeCheck() {
}

// --- abt...StaticCheck
void abt::StaticCheck() {
    algo_assert(_offset_of(abt::FieldId, value) + sizeof(((abt::FieldId*)0)->value) == sizeof(abt::FieldId));
}

// --- abt...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        abt::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        algo_lib::_db.clock = algo::CurrSchedTime(); // initialize clock
        abt::ReadArgv(); // dmmeta.main:abt
        abt::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("abt.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        abt::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- abt...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
