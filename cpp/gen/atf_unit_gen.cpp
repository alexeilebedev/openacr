//
// cpp/gen/atf_unit_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/atf_unit_gen.h"
#include "include/gen/atf_unit_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/atf_gen.h"
#include "include/gen/atf_gen.inl.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/lib_exec_gen.h"
#include "include/gen/lib_exec_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_sql_gen.h"
#include "include/gen/lib_sql_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
lib_exec::FDb   lib_exec::_db;    // dependency found via dev.targdep
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
lib_sql::FDb    lib_sql::_db;     // dependency found via dev.targdep
atf_unit::FDb   atf_unit::_db;    // dependency found via dev.targdep

namespace atf_unit {
const char *atf_unit_help =
"atf_unit: Algo Test Framework: unit tests\n"
"Usage: atf_unit [options]\n"
"    [unittest]        string  SQL regex, selecting test to run. default: \"%\"\n"
"    -nofork                   Do not fork for destructive tests. default: false\n"
"    -arg              string  Argument to pass to tool\n"
"    -data_dir         string  Data directory. default: \"data\"\n"
"    -debug                    Break at testcase in debugger. default: 0\n"
"    -perf_secs        double  # Of seconds to run perf tests for. default: 1.0\n"
"    -pertest_timeout  int     Max runtime of any individual unit test. default: 900\n"
"    -verbose                  Enable verbose mode\n"
"    -debug                    Enable debug mode\n"
"    -version                  Show version information\n"
"    -sig                      Print SHA1 signatures for dispatches\n"
"    -help                     Print this screen and exit\n"
;


const char *atf_unit_syntax =
"[unittest]:string=\"%\"\n"
" -nofork:flag\n"
" -arg:string=\n"
" -data_dir:string=\"data\"\n"
" -debug:flag=0\n"
" -perf_secs:double=1.0\n"
" -pertest_timeout:int=900\n"
;
} // namespace atf_unit
namespace atf_unit {
// Extract next character from STR and advance IDX
static int           val_Nextchar(const atf_unit::Cstr& parent, strptr &str, int &idx) __attribute__((nothrow));
// Returns the child that has greater height.
static atf_unit::FNumber* tr_number_TallerChild(atf_unit::FNumber& node) __attribute__((nothrow));
// Disconnects the subtree(branch) from the parent
static void          tr_number_Disconnect(atf_unit::FNumber& node) __attribute__((nothrow));
static bool          tr_number_ElemLt(atf_unit::FNumber &a, atf_unit::FNumber &b) __attribute__((nothrow));
static void          tr_number_updateDepth(atf_unit::FNumber& node) __attribute__((nothrow));
// rotates the tree in from->to direction
static void          tr_number_Turn(atf_unit::FNumber& from, atf_unit::FNumber& to) __attribute__((nothrow));
static void          tr_number_Connect(atf_unit::FNumber* parent, atf_unit::FNumber* child, bool left) __attribute__((nothrow));
static void          unittest_LoadStatic() __attribute__((nothrow));
// Load statically available data into tables, register tables and database.
static void          InitReflection();
// find trace by row id (used to implement reflection)
static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
// Function return 1
static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Swap values elem_a and elem_b
static void          sorted_Swap(atf_unit::Dbl &elem_a, atf_unit::Dbl &elem_b) __attribute__((nothrow));
// Left circular shift of three-tuple
static void          sorted_Rotleft(atf_unit::Dbl &elem_a, atf_unit::Dbl &elem_b, atf_unit::Dbl &elem_c) __attribute__((nothrow));
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool          sorted_Lt(atf_unit::Dbl elem_a, atf_unit::Dbl elem_b) __attribute__((nothrow));
// Internal insertion sort
static void          sorted_IntInsertionSort(atf_unit::Dbl *elems, int n) __attribute__((nothrow));
// Internal heap sort
static void          sorted_IntHeapSort(atf_unit::Dbl *elems, int n) __attribute__((nothrow));
// Quick sort engine
static void          sorted_IntQuickSort(atf_unit::Dbl *elems, int n, int depth) __attribute__((nothrow));
static void          SizeCheck();
} // end namespace atf_unit

// --- atf_unit.Cstr.val.Nextchar
// Extract next character from STR and advance IDX
inline static int atf_unit::val_Nextchar(const atf_unit::Cstr& parent, strptr &str, int &idx) {
    (void)parent;
    int i = idx;
    int ch = str.elems[i];
    i++;
    idx = i;
    return ch;
}

// --- atf_unit.Cstr..FmtJson
// Create JSON representation of atf_unit::Cstr under PARENT node -- cprint:atf_unit.Cstr.Json
lib_json::FNode * atf_unit::Cstr_FmtJson(atf_unit::Cstr & row, lib_json::FNode *parent) {
    return algo::cstring_FmtJson(const_cast<atf_unit::Cstr&>(row).val,parent);;
}

// --- atf_unit.Dbl..ReadStrptrMaybe
// Read fields of atf_unit::Dbl from an ascii string.
// The format of the string is the format of the atf_unit::Dbl's only field
bool atf_unit::Dbl_ReadStrptrMaybe(atf_unit::Dbl &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && double_ReadStrptrMaybe(parent.val, in_str);
    return retval;
}

// --- atf_unit.Dbl..Print
// print string representation of atf_unit::Dbl to string LHS, no header -- cprint:atf_unit.Dbl.String
void atf_unit::Dbl_Print(atf_unit::Dbl row, algo::cstring &str) {
    double_Print(row.val, str);
}

// --- atf_unit.Dbl..FmtJson
// Create JSON representation of atf_unit::Dbl under PARENT node -- cprint:atf_unit.Dbl.Json
lib_json::FNode * atf_unit::Dbl_FmtJson(atf_unit::Dbl row, lib_json::FNode *parent) {
    return double_FmtJson(const_cast<atf_unit::Dbl&>(row).val,parent);;
}

// --- atf_unit.TestArgtuple1..ReadFieldMaybe
bool atf_unit::TestArgtuple1_ReadFieldMaybe(atf_unit::TestArgtuple1 &parent, algo::strptr field, algo::strptr strval) {
    atf_unit::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atf_unit_FieldId_str_fld1: retval = algo::cstring_ReadStrptrMaybe(parent.str_fld1, strval); break;
        case atf_unit_FieldId_dbl_fld1: retval = double_ReadStrptrMaybe(parent.dbl_fld1, strval); break;
        case atf_unit_FieldId_xyz: retval = i32_ReadStrptrMaybe(parent.xyz, strval); break;
        case atf_unit_FieldId_test: retval = double_ReadStrptrMaybe(parent.test, strval); break;
        case atf_unit_FieldId_value: retval = algo::cstring_ReadStrptrMaybe(parent.value, strval); break;
        case atf_unit_FieldId_test2: retval = i32_ReadStrptrMaybe(parent.test2, strval); break;
        case atf_unit_FieldId_abc: retval = algo::cstring_ReadStrptrMaybe(parent.abc, strval); break;
        case atf_unit_FieldId_x: retval = bool_ReadStrptrMaybe(parent.x, strval); break;
        case atf_unit_FieldId_y: retval = bool_ReadStrptrMaybe(parent.y, strval); break;
        case atf_unit_FieldId_z: retval = bool_ReadStrptrMaybe(parent.z, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_unit.TestArgtuple1..ReadStrptrMaybe
// Read fields of atf_unit::TestArgtuple1 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_unit::TestArgtuple1_ReadStrptrMaybe(atf_unit::TestArgtuple1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_unit.TestArgtuple1");
    int anon_idx = 0;
    ind_beg(algo::Attr_curs, attr, in_str) {
        if (ch_N(attr.name) == 0) {
            attr.name = TestArgtuple1_GetAnon(parent, anon_idx++);
        }
        retval = retval && TestArgtuple1_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_unit.TestArgtuple1..ReadTupleMaybe
// Read fields of atf_unit::TestArgtuple1 from attributes of ascii tuple TUPLE
bool atf_unit::TestArgtuple1_ReadTupleMaybe(atf_unit::TestArgtuple1 &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = TestArgtuple1_GetAnon(parent, anon_idx++);
        }
        retval = TestArgtuple1_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_unit.TestArgtuple1..Init
// Set all fields to initial values.
void atf_unit::TestArgtuple1_Init(atf_unit::TestArgtuple1& parent) {
    parent.dbl_fld1 = double(0.0);
    parent.xyz = i32(0);
    parent.test = double(0);
    parent.value = algo::strptr("");
    parent.test2 = i32(0);
    parent.abc = algo::strptr("");
    parent.x = bool(false);
    parent.y = bool(false);
    parent.z = bool(true);
}

// --- atf_unit.TestArgtuple1..Print
// print string representation of atf_unit::TestArgtuple1 to string LHS, no header -- cprint:atf_unit.TestArgtuple1.String
void atf_unit::TestArgtuple1_Print(atf_unit::TestArgtuple1 & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.TestArgtuple1";

    algo::cstring_Print(row.str_fld1, temp);
    PrintAttrSpaceReset(str,"", temp);

    double_Print(row.dbl_fld1, temp);
    PrintAttrSpaceReset(str,"", temp);

    i32_Print(row.xyz, temp);
    PrintAttrSpaceReset(str,"xyz", temp);

    double_Print(row.test, temp);
    PrintAttrSpaceReset(str,"test", temp);

    algo::cstring_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    i32_Print(row.test2, temp);
    PrintAttrSpaceReset(str,"test2", temp);

    algo::cstring_Print(row.abc, temp);
    PrintAttrSpaceReset(str,"abc", temp);

    bool_Print(row.x, temp);
    PrintAttrSpaceReset(str,"x", temp);

    bool_Print(row.y, temp);
    PrintAttrSpaceReset(str,"y", temp);

    bool_Print(row.z, temp);
    PrintAttrSpaceReset(str,"z", temp);
}

// --- atf_unit.TestArgtuple1..GetAnon
algo::strptr atf_unit::TestArgtuple1_GetAnon(atf_unit::TestArgtuple1 &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("str_fld1", 8);
        case(1): return strptr("dbl_fld1", 8);
        default: return strptr();
    }
}

// --- atf_unit.trace..Print
// print string representation of atf_unit::trace to string LHS, no header -- cprint:atf_unit.trace.String
void atf_unit::trace_Print(atf_unit::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- atf_unit.FDb.number.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FNumber& atf_unit::number_Alloc() {
    atf_unit::FNumber* row = number_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_unit.out_of_mem  field:atf_unit.FDb.number  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_unit.FDb.number.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FNumber* atf_unit::number_AllocMaybe() {
    atf_unit::FNumber *row = (atf_unit::FNumber*)number_AllocMem();
    if (row) {
        new (row) atf_unit::FNumber; // call constructor
    }
    return row;
}

// --- atf_unit.FDb.number.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_unit::number_Delete(atf_unit::FNumber &row) {
    row.~FNumber();
    number_FreeMem(row);
}

// --- atf_unit.FDb.number.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* atf_unit::number_AllocMem() {
    atf_unit::FNumber *row = _db.number_free;
    if (UNLIKELY(!row)) {
        number_Reserve(1);
        row = _db.number_free;
    }
    if (row) {
        _db.number_free = row->number_next;
    }
    return row;
}

// --- atf_unit.FDb.number.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void atf_unit::number_FreeMem(atf_unit::FNumber &row) {
    if (UNLIKELY(row.number_next != (atf_unit::FNumber*)-1)) {
        FatalErrorExit("atf_unit.tpool_double_delete  pool:atf_unit.FDb.number  comment:'double deletion caught'");
    }
    row.number_next = _db.number_free; // insert into free list
    _db.number_free  = &row;
}

// --- atf_unit.FDb.number.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 atf_unit::number_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.number_blocksize; // underlying allocator is probably Lpool
        u64 reserved = number_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- atf_unit.FDb.number.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 atf_unit::number_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(atf_unit::FNumber)) {
        atf_unit::FNumber *mem = (atf_unit::FNumber*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(atf_unit::FNumber) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].number_next = _db.number_free;
            _db.number_free = mem+i;
        }
    }
    return ret;
}

// --- atf_unit.FDb.number.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::number_XrefMaybe(atf_unit::FNumber &row) {
    bool retval = true;
    (void)row;
    // insert number into index tr_number
    if (true) { // user-defined insert condition
        tr_number_Insert(row);
    }
    return retval;
}

// --- atf_unit.FDb.tr_number.FirstImpl
atf_unit::FNumber* atf_unit::tr_number_FirstImpl(atf_unit::FNumber* root) {
    atf_unit::FNumber *result = root;
    while(result != NULL && result->tr_number_left != NULL){
        result = result->tr_number_left;
    }
    return result;
}

// --- atf_unit.FDb.tr_number.First
// Return pointer to the first(smallest) element in the tree
atf_unit::FNumber* atf_unit::tr_number_First() {
    return tr_number_FirstImpl(_db.tr_number_root);
}

// --- atf_unit.FDb.tr_number.InsertImpl
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_unit::tr_number_InsertImpl(atf_unit::FNumber* parent, atf_unit::FNumber& row) {
    bool left = false;
    while(parent != NULL){
        left = tr_number_ElemLt(row, *parent);
        atf_unit::FNumber* side = left ? parent->tr_number_left : parent->tr_number_right;
        if(side == NULL){
            break;
        }
        parent = side;
    }
    tr_number_Connect(parent, &row, left);
}

// --- atf_unit.FDb.tr_number.Insert
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_unit::tr_number_Insert(atf_unit::FNumber& row) {
    if(!tr_number_InTreeQ(row)){
        _db.tr_number_n++;
        tr_number_InsertImpl(_db.tr_number_root, row);
        _db.tr_number_root = tr_number_Propagate(row);
    }
}

// --- atf_unit.FDb.tr_number.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_unit::tr_number_Remove(atf_unit::FNumber& row) {
    if(!tr_number_InTreeQ(row)){
        return;
    }
    atf_unit::FNumber* next = NULL;
    if(row.tr_number_depth > 1){
        next = tr_number_Balance(row) < 0 ? tr_number_FirstImpl(row.tr_number_right) : tr_number_LastImpl(row.tr_number_left);
        atf_unit::FNumber* leaf = tr_number_TallerChild(*next);
        if(leaf){
            tr_number_Turn(*leaf, *next);
        }
    }
    atf_unit::FNumber* root = row.tr_number_up;
    atf_unit::FNumber* prop = root;//propagate point
    if(next){
        prop = next->tr_number_up == &row ? next : next->tr_number_up;
        tr_number_Disconnect(*next);
        tr_number_Connect(next, row.tr_number_left, true);
        tr_number_Connect(next, row.tr_number_right, false);
    }
    bool dir = root && root->tr_number_left == &row;
    tr_number_Connect(root, next, dir);
    _db.tr_number_root = prop ? tr_number_Propagate(*prop) : NULL;
    row.tr_number_depth = 0;
    row.tr_number_left = NULL;
    row.tr_number_right = NULL;
    row.tr_number_up = (atf_unit::FNumber*)-1;
    _db.tr_number_n--;
}

// --- atf_unit.FDb.tr_number.RemoveFirst
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void atf_unit::tr_number_RemoveFirst() {
    if(!tr_number_EmptyQ()){
        tr_number_Remove(*tr_number_First());
    }
}

// --- atf_unit.FDb.tr_number.Balance
i32 atf_unit::tr_number_Balance(atf_unit::FNumber& row) {
    i32 left  = row.tr_number_left  ? row.tr_number_left->tr_number_depth  : 0;
    i32 right = row.tr_number_right ? row.tr_number_right->tr_number_depth : 0;
    return left - right;
}

// --- atf_unit.FDb.tr_number.Propagate
// Recalculate depth and keep rebalancing if needed
atf_unit::FNumber* atf_unit::tr_number_Propagate(atf_unit::FNumber& pnode) {
    atf_unit::FNumber *root = &pnode;
    atf_unit::FNumber* node = &pnode;
    while(node != NULL){
        tr_number_updateDepth(*node);
        tr_number_Rebalance(*node);
        root = node;
        node = node->tr_number_up;
    }
    return root;
}

// --- atf_unit.FDb.tr_number.TallerChild
// Returns the child that has greater height.
inline static atf_unit::FNumber* atf_unit::tr_number_TallerChild(atf_unit::FNumber& node) {
    return tr_number_Balance(node) < 0 ? node.tr_number_right : node.tr_number_left;
}

// --- atf_unit.FDb.tr_number.Disconnect
// Disconnects the subtree(branch) from the parent
static void atf_unit::tr_number_Disconnect(atf_unit::FNumber& node) {
    atf_unit::FNumber* parent = node.tr_number_up;
    if(parent != NULL){
        bool left = parent->tr_number_left == &node;
        (left ? parent->tr_number_left : parent->tr_number_right) = NULL;
    }
    node.tr_number_up = NULL;
}

// --- atf_unit.FDb.tr_number.Rebalance
// Rebalances the node if needed.
void atf_unit::tr_number_Rebalance(atf_unit::FNumber& node) {
    if(Abs(tr_number_Balance(node)) > 1){
        atf_unit::FNumber* deep1 = tr_number_TallerChild(node);
        atf_unit::FNumber* deep2 = tr_number_TallerChild(*deep1);
        bool turn = tr_number_Balance(*deep1)!=0 && (node.tr_number_left == deep1) != (deep1->tr_number_left == deep2);
        if(turn){
            tr_number_Turn(*deep2, *deep1);
            TSwap(deep1, deep2);
        }
        tr_number_Turn(*deep1, node);
        tr_number_updateDepth(node);
        tr_number_updateDepth(*deep2);
        tr_number_updateDepth(*deep1);
    }
}

// --- atf_unit.FDb.tr_number.Next
atf_unit::FNumber* atf_unit::tr_number_Next(atf_unit::FNumber& node) {
    atf_unit::FNumber *result = &node;
    if(result->tr_number_right == NULL){
        while(result->tr_number_up != NULL && result->tr_number_up->tr_number_right == result){
            result = result->tr_number_up;
        }
        result = result->tr_number_up;
    }else{
        result = tr_number_FirstImpl(result->tr_number_right);
    }
    return result;
}

// --- atf_unit.FDb.tr_number.Prev
atf_unit::FNumber* atf_unit::tr_number_Prev(atf_unit::FNumber& node) {
    atf_unit::FNumber *result = &node;
    if(result->tr_number_left == NULL){
        while(result->tr_number_up != NULL && result->tr_number_up->tr_number_left == result){
            result = result->tr_number_up;
        }
        result = result->tr_number_up;
    }else{
        result = tr_number_LastImpl(result->tr_number_left);
    }
    return result;
}

// --- atf_unit.FDb.tr_number.LastImpl
atf_unit::FNumber* atf_unit::tr_number_LastImpl(atf_unit::FNumber* root) {
    atf_unit::FNumber *result = root;
    while(result != NULL && result->tr_number_right != NULL){
        result = result->tr_number_right;
    }
    return result;
}

// --- atf_unit.FDb.tr_number.Last
// Return pointer to the last(largest) element in tree
atf_unit::FNumber* atf_unit::tr_number_Last() {
    return tr_number_LastImpl(_db.tr_number_root);
}

// --- atf_unit.FDb.tr_number.ElemLt
inline static bool atf_unit::tr_number_ElemLt(atf_unit::FNumber &a, atf_unit::FNumber &b) {
    (void)_db;
    return a.num < b.num;
}

// --- atf_unit.FDb.tr_number.UpdateDepth
static void atf_unit::tr_number_updateDepth(atf_unit::FNumber& node) {
    i32 ldepth = node.tr_number_left  != NULL ? node.tr_number_left->tr_number_depth : 0;
    i32 rdepth = node.tr_number_right != NULL ? node.tr_number_right->tr_number_depth : 0;
    node.tr_number_depth = i32_Max(ldepth, rdepth) + 1;
}

// --- atf_unit.FDb.tr_number.Turn
// rotates the tree in from->to direction
static void atf_unit::tr_number_Turn(atf_unit::FNumber& from, atf_unit::FNumber& to) {
    atf_unit::FNumber* root = to.tr_number_up;
    bool dir = root && root->tr_number_left == &to;
    tr_number_Connect(root, &from, dir);
    dir = to.tr_number_left == &from;
    atf_unit::FNumber* orphan = (dir ? from.tr_number_right : from.tr_number_left);//other side
    tr_number_Connect(&from, &to , !dir);
    tr_number_Connect(&to, orphan, dir);
}

// --- atf_unit.FDb.tr_number.Connect
inline static void atf_unit::tr_number_Connect(atf_unit::FNumber* parent, atf_unit::FNumber* child, bool left) {
    if(parent){
        (&parent->tr_number_left)[!left] = child;
    }
    if(child){
        child->tr_number_up = parent;
    }
}

// --- atf_unit.FDb.tr_number.RemoveAllImpl
// Empty the index. (rows may be deleted if cascdel)
void atf_unit::tr_number_RemoveAllImpl(atf_unit::FNumber* root, bool del) {
    if(root != NULL){
        tr_number_RemoveAllImpl(root->tr_number_left, del);
        tr_number_RemoveAllImpl(root->tr_number_right, del);
        tr_number_Disconnect(*root);
        root->tr_number_depth = 0;//the pointers are taken care of by Disconnect
        root->tr_number_up = (atf_unit::FNumber*)-1;//the pointers are taken care of by Disconnect
    }
}

// --- atf_unit.FDb.tr_number.Reinsert
// Reinsert a row with modified key(Reheap semantics)
void atf_unit::tr_number_Reinsert(atf_unit::FNumber& node) {
    tr_number_Remove(node);
    tr_number_Insert(node);
}

// --- atf_unit.FDb.tr_number.FirstGe
// Find the first element that is greater or equal to a sortfld value
atf_unit::FNumber* atf_unit::tr_number_FirstGe(const i32& val) {
    atf_unit::FNumber* result = _db.tr_number_root;
    bool left = false;
    while(result){
        left = !((*result).num < val);
        atf_unit::FNumber* side = left ? result->tr_number_left : result->tr_number_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && (*result).num < val){
        result = tr_number_Next(*result);
    }
    return result;
}

// --- atf_unit.FDb.tr_number.LastLt
// Find the last element that is smaller or equal to a sortfld value
atf_unit::FNumber* atf_unit::tr_number_LastLt(const i32& val) {
    atf_unit::FNumber* result = _db.tr_number_root;
    bool left = false;
    while(result){
        left = val < (*result).num;
        atf_unit::FNumber* side = left ? result->tr_number_left : result->tr_number_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && !((*result).num < val)){
        result = tr_number_Prev(*result);
    }
    return result;
}

// --- atf_unit.FDb.unittest.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FUnittest& atf_unit::unittest_Alloc() {
    atf_unit::FUnittest* row = unittest_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_unit.out_of_mem  field:atf_unit.FDb.unittest  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_unit.FDb.unittest.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FUnittest* atf_unit::unittest_AllocMaybe() {
    atf_unit::FUnittest *row = (atf_unit::FUnittest*)unittest_AllocMem();
    if (row) {
        new (row) atf_unit::FUnittest; // call constructor
    }
    return row;
}

// --- atf_unit.FDb.unittest.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_unit::FUnittest* atf_unit::unittest_InsertMaybe(const atfdb::Unittest &value) {
    atf_unit::FUnittest *row = &unittest_Alloc(); // if out of memory, process dies. if input error, return NULL.
    unittest_CopyIn(*row,const_cast<atfdb::Unittest&>(value));
    bool ok = unittest_XrefMaybe(*row); // this may return false
    if (!ok) {
        unittest_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_unit.FDb.unittest.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_unit::unittest_AllocMem() {
    u64 new_nelems     = _db.unittest_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_unit::FUnittest*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.unittest_lary[bsr];
        if (!lev) {
            lev=(atf_unit::FUnittest*)algo_lib::malloc_AllocMem(sizeof(atf_unit::FUnittest) * (u64(1)<<bsr));
            _db.unittest_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.unittest_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- atf_unit.FDb.unittest.RemoveAll
// Remove all elements from Lary
void atf_unit::unittest_RemoveAll() {
    for (u64 n = _db.unittest_n; n>0; ) {
        n--;
        unittest_qFind(u64(n)).~FUnittest(); // destroy last element
        _db.unittest_n = n;
    }
}

// --- atf_unit.FDb.unittest.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::unittest_RemoveLast() {
    u64 n = _db.unittest_n;
    if (n > 0) {
        n -= 1;
        unittest_qFind(u64(n)).~FUnittest();
        _db.unittest_n = n;
    }
}

// --- atf_unit.FDb.unittest.LoadStatic
static void atf_unit::unittest_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)();
    } data[] = {
        { "atfdb.unittest  unittest:acr.Check1  comment:\"\"", atf_unit::unittest_acr_Check1 }
        ,{ "atfdb.unittest  unittest:acr.Del1  comment:\"\"", atf_unit::unittest_acr_Del1 }
        ,{ "atfdb.unittest  unittest:acr.Field1  comment:\"\"", atf_unit::unittest_acr_Field1 }
        ,{ "atfdb.unittest  unittest:acr.Fldfunc1  comment:\"\"", atf_unit::unittest_acr_Fldfunc1 }
        ,{ "atfdb.unittest  unittest:acr.Insert1  comment:\"\"", atf_unit::unittest_acr_Insert1 }
        ,{ "atfdb.unittest  unittest:acr.Insert2  comment:\"\"", atf_unit::unittest_acr_Insert2 }
        ,{ "atfdb.unittest  unittest:acr.Merge1  comment:\"\"", atf_unit::unittest_acr_Merge1 }
        ,{ "atfdb.unittest  unittest:acr.Meta1  comment:\"\"", atf_unit::unittest_acr_Meta1 }
        ,{ "atfdb.unittest  unittest:acr.Read1  comment:\"\"", atf_unit::unittest_acr_Read1 }
        ,{ "atfdb.unittest  unittest:acr.Read2  comment:\"\"", atf_unit::unittest_acr_Read2 }
        ,{ "atfdb.unittest  unittest:acr.Read3  comment:\"\"", atf_unit::unittest_acr_Read3 }
        ,{ "atfdb.unittest  unittest:acr.Read5  comment:\"\"", atf_unit::unittest_acr_Read5 }
        ,{ "atfdb.unittest  unittest:acr.Regx1  comment:\"\"", atf_unit::unittest_acr_Regx1 }
        ,{ "atfdb.unittest  unittest:acr.Replace1  comment:\"\"", atf_unit::unittest_acr_Replace1 }
        ,{ "atfdb.unittest  unittest:acr.Rowid1  comment:\"\"", atf_unit::unittest_acr_Rowid1 }
        ,{ "atfdb.unittest  unittest:acr.Unused1  comment:\"\"", atf_unit::unittest_acr_Unused1 }
        ,{ "atfdb.unittest  unittest:acr.Write1  comment:\"\"", atf_unit::unittest_acr_Write1 }
        ,{ "atfdb.unittest  unittest:acr.Write2  comment:\"\"", atf_unit::unittest_acr_Write2 }
        ,{ "atfdb.unittest  unittest:acr.Xref1  comment:\"\"", atf_unit::unittest_acr_Xref1 }
        ,{ "atfdb.unittest  unittest:acr.Xref2  comment:\"\"", atf_unit::unittest_acr_Xref2 }
        ,{ "atfdb.unittest  unittest:acr_ed.CreateTarget  comment:\"\"", atf_unit::unittest_acr_ed_CreateTarget }
        ,{ "atfdb.unittest  unittest:algo_lib.Abs  comment:\"\"", atf_unit::unittest_algo_lib_Abs }
        ,{ "atfdb.unittest  unittest:algo_lib.Aligned  comment:\"\"", atf_unit::unittest_algo_lib_Aligned }
        ,{ "atfdb.unittest  unittest:algo_lib.Argtuple2  comment:\"\"", atf_unit::unittest_algo_lib_Argtuple2 }
        ,{ "atfdb.unittest  unittest:algo_lib.Argtuple_ReadArgv  comment:\"\"", atf_unit::unittest_algo_lib_Argtuple_ReadArgv }
        ,{ "atfdb.unittest  unittest:algo_lib.Argtuple_ReadStrptr  comment:\"\"", atf_unit::unittest_algo_lib_Argtuple_ReadStrptr }
        ,{ "atfdb.unittest  unittest:algo_lib.AvlvsMap  comment:\"\"", atf_unit::unittest_algo_lib_AvlvsMap }
        ,{ "atfdb.unittest  unittest:algo_lib.CSVTokens  comment:\"\"", atf_unit::unittest_algo_lib_CSVTokens }
        ,{ "atfdb.unittest  unittest:algo_lib.CString  comment:\"\"", atf_unit::unittest_algo_lib_CString }
        ,{ "atfdb.unittest  unittest:algo_lib.CaseConversion  comment:\"\"", atf_unit::unittest_algo_lib_CaseConversion }
        ,{ "atfdb.unittest  unittest:algo_lib.Ceiling  comment:\"\"", atf_unit::unittest_algo_lib_Ceiling }
        ,{ "atfdb.unittest  unittest:algo_lib.Charset  comment:\"\"", atf_unit::unittest_algo_lib_Charset }
        ,{ "atfdb.unittest  unittest:algo_lib.CheckIpmask  comment:\"\"", atf_unit::unittest_algo_lib_CheckIpmask }
        ,{ "atfdb.unittest  unittest:algo_lib.CheckShiftMask  comment:\"\"", atf_unit::unittest_algo_lib_CheckShiftMask }
        ,{ "atfdb.unittest  unittest:algo_lib.Clipped  comment:\"\"", atf_unit::unittest_algo_lib_Clipped }
        ,{ "atfdb.unittest  unittest:algo_lib.Cmp  comment:\"\"", atf_unit::unittest_algo_lib_Cmp }
        ,{ "atfdb.unittest  unittest:algo_lib.Datecache  comment:\"\"", atf_unit::unittest_algo_lib_Datecache }
        ,{ "atfdb.unittest  unittest:algo_lib.DayName  comment:\"\"", atf_unit::unittest_algo_lib_DayName }
        ,{ "atfdb.unittest  unittest:algo_lib.DirBeg  comment:\"Test Dir_curs\"", atf_unit::unittest_algo_lib_DirBeg }
        ,{ "atfdb.unittest  unittest:algo_lib.DoTestRounding  comment:\"\"", atf_unit::unittest_algo_lib_DoTestRounding }
        ,{ "atfdb.unittest  unittest:algo_lib.FileLine_curs  comment:\"\"", atf_unit::unittest_algo_lib_FileLine_curs }
        ,{ "atfdb.unittest  unittest:algo_lib.FileToString  comment:\"\"", atf_unit::unittest_algo_lib_FileToString }
        ,{ "atfdb.unittest  unittest:algo_lib.FmtBufDec  comment:\"\"", atf_unit::unittest_algo_lib_FmtBufDec }
        ,{ "atfdb.unittest  unittest:algo_lib.I32Dec3Fmt  comment:\"Formatting of Dec number\"", atf_unit::unittest_algo_lib_I32Dec3Fmt }
        ,{ "atfdb.unittest  unittest:algo_lib.IntPrice  comment:\"\"", atf_unit::unittest_algo_lib_IntPrice }
        ,{ "atfdb.unittest  unittest:algo_lib.Interlocked  comment:\"\"", atf_unit::unittest_algo_lib_Interlocked }
        ,{ "atfdb.unittest  unittest:algo_lib.Keyval  comment:\"\"", atf_unit::unittest_algo_lib_Keyval }
        ,{ "atfdb.unittest  unittest:algo_lib.Lockfile  comment:\"\"", atf_unit::unittest_algo_lib_Lockfile }
        ,{ "atfdb.unittest  unittest:algo_lib.MinMax  comment:\"\"", atf_unit::unittest_algo_lib_MinMax }
        ,{ "atfdb.unittest  unittest:algo_lib.NToh  comment:\"\"", atf_unit::unittest_algo_lib_NToh }
        ,{ "atfdb.unittest  unittest:algo_lib.NextSep  comment:\"\"", atf_unit::unittest_algo_lib_NextSep }
        ,{ "atfdb.unittest  unittest:algo_lib.OrderID  comment:\"\"", atf_unit::unittest_algo_lib_OrderID }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseHex1  comment:\"\"", atf_unit::unittest_algo_lib_ParseHex1 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseHex2  comment:\"\"", atf_unit::unittest_algo_lib_ParseHex2 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNum  comment:\"\"", atf_unit::unittest_algo_lib_ParseNum }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber  comment:\"\"", atf_unit::unittest_algo_lib_ParseNumber }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Empty1  comment:\"zero length should result in OK = false\"", atf_unit::unittest_algo_lib_ParseNumber_Empty1 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Empty2  comment:\"zero length should result in OK = false\"", atf_unit::unittest_algo_lib_ParseNumber_Empty2 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Empty3  comment:\"zero length should result in OK = false\"", atf_unit::unittest_algo_lib_ParseNumber_Empty3 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Empty4  comment:\"zero length should result in OK = false\"", atf_unit::unittest_algo_lib_ParseNumber_Empty4 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Overflow1  comment:\"Test for LnumU32Str7Base36 overflow\"", atf_unit::unittest_algo_lib_ParseNumber_Overflow1 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Overflow2  comment:\"Test for LnumU64Str20 overflow\"", atf_unit::unittest_algo_lib_ParseNumber_Overflow2 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseNumber_Overflow3  comment:\"Test for LnumU64Str22 overflow\"", atf_unit::unittest_algo_lib_ParseNumber_Overflow3 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseOct1  comment:\"\"", atf_unit::unittest_algo_lib_ParseOct1 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseOct3  comment:\"\"", atf_unit::unittest_algo_lib_ParseOct3 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseURL1  comment:\"\"", atf_unit::unittest_algo_lib_ParseURL1 }
        ,{ "atfdb.unittest  unittest:algo_lib.ParseUnTime  comment:\"\"", atf_unit::unittest_algo_lib_ParseUnTime }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfIntrinsics  comment:\"\"", atf_unit::unittest_algo_lib_PerfIntrinsics }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfMinMaxAvg  comment:\"\"", atf_unit::unittest_algo_lib_PerfMinMaxAvg }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfParseDouble  comment:\"\"", atf_unit::unittest_algo_lib_PerfParseDouble }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfParseNum  comment:\"\"", atf_unit::unittest_algo_lib_PerfParseNum }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfSort  comment:\"\"", atf_unit::unittest_algo_lib_PerfSort }
        ,{ "atfdb.unittest  unittest:algo_lib.PerfTruncVsFtol  comment:\"\"", atf_unit::unittest_algo_lib_PerfTruncVsFtol }
        ,{ "atfdb.unittest  unittest:algo_lib.PopCnt1  comment:\"\"", atf_unit::unittest_algo_lib_PopCnt1 }
        ,{ "atfdb.unittest  unittest:algo_lib.PopCnt2  comment:\"\"", atf_unit::unittest_algo_lib_PopCnt2 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintBash  comment:\"\"", atf_unit::unittest_algo_lib_PrintBash }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintCppQuoted  comment:\"\"", atf_unit::unittest_algo_lib_PrintCppQuoted }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas1  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas1 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas2  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas2 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas3  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas3 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas4  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas4 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas5  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas5 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas6  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas6 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas7  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas7 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintDoubleWithCommas8  comment:\"\"", atf_unit::unittest_algo_lib_PrintDoubleWithCommas8 }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintHex  comment:\"\"", atf_unit::unittest_algo_lib_PrintHex }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintPad  comment:\"\"", atf_unit::unittest_algo_lib_PrintPad }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintSsim  comment:\"\"", atf_unit::unittest_algo_lib_PrintSsim }
        ,{ "atfdb.unittest  unittest:algo_lib.PrintTime  comment:\"\"", atf_unit::unittest_algo_lib_PrintTime }
        ,{ "atfdb.unittest  unittest:algo_lib.ReadLine  comment:\"\"", atf_unit::unittest_algo_lib_ReadLine }
        ,{ "atfdb.unittest  unittest:algo_lib.ReadModuleId  comment:\"\"", atf_unit::unittest_algo_lib_ReadModuleId }
        ,{ "atfdb.unittest  unittest:algo_lib.Regx  comment:\"\"", atf_unit::unittest_algo_lib_Regx }
        ,{ "atfdb.unittest  unittest:algo_lib.RegxReadTwice  comment:\"\"", atf_unit::unittest_algo_lib_RegxReadTwice }
        ,{ "atfdb.unittest  unittest:algo_lib.RegxReadTwice2  comment:\"\"", atf_unit::unittest_algo_lib_RegxReadTwice2 }
        ,{ "atfdb.unittest  unittest:algo_lib.RegxShortCircuit  comment:\"\"", atf_unit::unittest_algo_lib_RegxShortCircuit }
        ,{ "atfdb.unittest  unittest:algo_lib.RemDirRecurse  comment:,", atf_unit::unittest_algo_lib_RemDirRecurse }
        ,{ "atfdb.unittest  unittest:algo_lib.RemDirRecurse1  comment:\"\"", atf_unit::unittest_algo_lib_RemDirRecurse1 }
        ,{ "atfdb.unittest  unittest:algo_lib.RemDirRecurse2  comment:\"File in directory, remove without top-level\"", atf_unit::unittest_algo_lib_RemDirRecurse2 }
        ,{ "atfdb.unittest  unittest:algo_lib.RemDirRecurse3  comment:\"Do not follow symlinks\"", atf_unit::unittest_algo_lib_RemDirRecurse3 }
        ,{ "atfdb.unittest  unittest:algo_lib.RemDirRecurse4  comment:\"Three levels deep\"", atf_unit::unittest_algo_lib_RemDirRecurse4 }
        ,{ "atfdb.unittest  unittest:algo_lib.Replscope  comment:\"\"", atf_unit::unittest_algo_lib_Replscope }
        ,{ "atfdb.unittest  unittest:algo_lib.SchedTime  comment:\"\"", atf_unit::unittest_algo_lib_SchedTime }
        ,{ "atfdb.unittest  unittest:algo_lib.Sleep  comment:\"\"", atf_unit::unittest_algo_lib_Sleep }
        ,{ "atfdb.unittest  unittest:algo_lib.Smallstr  comment:\"\"", atf_unit::unittest_algo_lib_Smallstr }
        ,{ "atfdb.unittest  unittest:algo_lib.Strfind  comment:\"\"", atf_unit::unittest_algo_lib_Strfind }
        ,{ "atfdb.unittest  unittest:algo_lib.StringCase  comment:\"\"", atf_unit::unittest_algo_lib_StringCase }
        ,{ "atfdb.unittest  unittest:algo_lib.StringFind  comment:\"\"", atf_unit::unittest_algo_lib_StringFind }
        ,{ "atfdb.unittest  unittest:algo_lib.StringIter  comment:\"\"", atf_unit::unittest_algo_lib_StringIter }
        ,{ "atfdb.unittest  unittest:algo_lib.StringSubrange  comment:\"\"", atf_unit::unittest_algo_lib_StringSubrange }
        ,{ "atfdb.unittest  unittest:algo_lib.StringToFile  comment:\"\"", atf_unit::unittest_algo_lib_StringToFile }
        ,{ "atfdb.unittest  unittest:algo_lib.SubstringIndex  comment:\"\"", atf_unit::unittest_algo_lib_SubstringIndex }
        ,{ "atfdb.unittest  unittest:algo_lib.Tabulate  comment:\"\"", atf_unit::unittest_algo_lib_Tabulate }
        ,{ "atfdb.unittest  unittest:algo_lib.Tempfile  comment:\"\"", atf_unit::unittest_algo_lib_Tempfile }
        ,{ "atfdb.unittest  unittest:algo_lib.TestBitSet  comment:\"Bitset over Tary\"", atf_unit::unittest_algo_lib_TestBitSet }
        ,{ "atfdb.unittest  unittest:algo_lib.TestFbitset  comment:\"Bitset over Inlary u16\"", atf_unit::unittest_algo_lib_TestFbitset }
        ,{ "atfdb.unittest  unittest:algo_lib.TestFbitset2  comment:\"Bitset over single u8\"", atf_unit::unittest_algo_lib_TestFbitset2 }
        ,{ "atfdb.unittest  unittest:algo_lib.TestFbitset3  comment:\"Bitset over single u64\"", atf_unit::unittest_algo_lib_TestFbitset3 }
        ,{ "atfdb.unittest  unittest:algo_lib.TestFbitset4  comment:\"Bitset over single u128\"", atf_unit::unittest_algo_lib_TestFbitset4 }
        ,{ "atfdb.unittest  unittest:algo_lib.TestString  comment:\"\"", atf_unit::unittest_algo_lib_TestString }
        ,{ "atfdb.unittest  unittest:algo_lib.TestStringFmt  comment:\"Print 128-bit number: large number\"", atf_unit::unittest_algo_lib_TestStringFmt }
        ,{ "atfdb.unittest  unittest:algo_lib.TestStringFmt2  comment:\"Print 128-bit number: 0\"", atf_unit::unittest_algo_lib_TestStringFmt2 }
        ,{ "atfdb.unittest  unittest:algo_lib.TestStringFmt3  comment:\"Print 128-bit number: huge number\"", atf_unit::unittest_algo_lib_TestStringFmt3 }
        ,{ "atfdb.unittest  unittest:algo_lib.TimeConstants  comment:\"\"", atf_unit::unittest_algo_lib_TimeConstants }
        ,{ "atfdb.unittest  unittest:algo_lib.TimeConversion  comment:\"\"", atf_unit::unittest_algo_lib_TimeConversion }
        ,{ "atfdb.unittest  unittest:algo_lib.Tuple  comment:\"\"", atf_unit::unittest_algo_lib_Tuple }
        ,{ "atfdb.unittest  unittest:algo_lib.Tuple1  comment:\"\"", atf_unit::unittest_algo_lib_Tuple1 }
        ,{ "atfdb.unittest  unittest:algo_lib.Tuple2  comment:\"\"", atf_unit::unittest_algo_lib_Tuple2 }
        ,{ "atfdb.unittest  unittest:algo_lib.U128PrintHex  comment:\"\"", atf_unit::unittest_algo_lib_U128PrintHex }
        ,{ "atfdb.unittest  unittest:algo_lib.UnescapeC  comment:\"\"", atf_unit::unittest_algo_lib_UnescapeC }
        ,{ "atfdb.unittest  unittest:algo_lib.strptr_Eq  comment:\"\"", atf_unit::unittest_algo_lib_strptr_Eq }
        ,{ "atfdb.unittest  unittest:algo_lib.test_strptr  comment:\"\"", atf_unit::unittest_algo_lib_test_strptr }
        ,{ "atfdb.unittest  unittest:amc.Unit  comment:\"\"", atf_unit::unittest_amc_Unit }
        ,{ "atfdb.unittest  unittest:lib_exec.Dependency  comment:\"\"", atf_unit::unittest_lib_exec_Dependency }
        ,{ "atfdb.unittest  unittest:lib_exec.Parallel1  comment:\"\"", atf_unit::unittest_lib_exec_Parallel1 }
        ,{ "atfdb.unittest  unittest:lib_exec.Timeout  comment:\"\"", atf_unit::unittest_lib_exec_Timeout }
        ,{ "atfdb.unittest  unittest:lib_exec.TooManyFds  comment:\"\"", atf_unit::unittest_lib_exec_TooManyFds }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayAll  comment:\"Array with many elements with all value types\"", atf_unit::unittest_lib_json_ArrayAll }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayEmptyArray  comment:\"Single empty array in array\"", atf_unit::unittest_lib_json_ArrayEmptyArray }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayEmptyObject  comment:\"Single empty object in array\"", atf_unit::unittest_lib_json_ArrayEmptyObject }
        ,{ "atfdb.unittest  unittest:lib_json.ArraySimpleNumber  comment:\"Single simple number array\"", atf_unit::unittest_lib_json_ArraySimpleNumber }
        ,{ "atfdb.unittest  unittest:lib_json.ArraySimpleString  comment:\"Single simple string array\"", atf_unit::unittest_lib_json_ArraySimpleString }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayTokenFalse  comment:\"Single false token array\"", atf_unit::unittest_lib_json_ArrayTokenFalse }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayTokenNull  comment:\"Single null token array\"", atf_unit::unittest_lib_json_ArrayTokenNull }
        ,{ "atfdb.unittest  unittest:lib_json.ArrayTokenTrue  comment:\"Single true token array\"", atf_unit::unittest_lib_json_ArrayTokenTrue }
        ,{ "atfdb.unittest  unittest:lib_json.CtrlCharEscape  comment:\"Control char escape\"", atf_unit::unittest_lib_json_CtrlCharEscape }
        ,{ "atfdb.unittest  unittest:lib_json.Empty  comment:\"Empty input\"", atf_unit::unittest_lib_json_Empty }
        ,{ "atfdb.unittest  unittest:lib_json.EmptyArray  comment:\"Single empty array\"", atf_unit::unittest_lib_json_EmptyArray }
        ,{ "atfdb.unittest  unittest:lib_json.Emptyobject  comment:\"Single empty object\"", atf_unit::unittest_lib_json_Emptyobject }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorArrayColon  comment:\"Error case -  colon in array\"", atf_unit::unittest_lib_json_ErrorArrayColon }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorArrayComma1  comment:\"Error case - no comma\"", atf_unit::unittest_lib_json_ErrorArrayComma1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorArrayComma2  comment:\"Error case - extra comma 1\"", atf_unit::unittest_lib_json_ErrorArrayComma2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorArrayComma3  comment:\"Error case - extra comma 2\"", atf_unit::unittest_lib_json_ErrorArrayComma3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorArrayComma4  comment:\"Error case - extra comma 3\"", atf_unit::unittest_lib_json_ErrorArrayComma4 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadNumber  comment:\"Error case - bad number\"", atf_unit::unittest_lib_json_ErrorBadNumber }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadString1  comment:\"Error case - unterminated string\"", atf_unit::unittest_lib_json_ErrorBadString1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadString2  comment:\"Error case - unterminated escape string\"", atf_unit::unittest_lib_json_ErrorBadString2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadString3  comment:\"Error case - bad escape string\"", atf_unit::unittest_lib_json_ErrorBadString3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadToken1  comment:\"Error case - bad token\"", atf_unit::unittest_lib_json_ErrorBadToken1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadToken2  comment:\"Error case - bad token\"", atf_unit::unittest_lib_json_ErrorBadToken2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString1  comment:\"Error case - bad unicode escape string 1\"", atf_unit::unittest_lib_json_ErrorBadUString1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString2  comment:\"Error case - bad unicode escape string 2\"", atf_unit::unittest_lib_json_ErrorBadUString2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString3  comment:\"Error case - bad unicode escape string 3\"", atf_unit::unittest_lib_json_ErrorBadUString3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString4  comment:\"Error case - bad unicode escape string 4\"", atf_unit::unittest_lib_json_ErrorBadUString4 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString5  comment:\"Error case - bad unicode escape string 5\"", atf_unit::unittest_lib_json_ErrorBadUString5 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString6  comment:\"Error case - bad unicode escape string 6\"", atf_unit::unittest_lib_json_ErrorBadUString6 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBadUString7  comment:\"Error case - bad unicode escape string 7\"", atf_unit::unittest_lib_json_ErrorBadUString7 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBareColon  comment:\"Error case - bare colon\"", atf_unit::unittest_lib_json_ErrorBareColon }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBareComma  comment:\"Error case - bare comma\"", atf_unit::unittest_lib_json_ErrorBareComma }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBareValuesWithColon  comment:\"Error case - bare values separated by colon\"", atf_unit::unittest_lib_json_ErrorBareValuesWithColon }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBareValuesWithComma  comment:\"Error case - bare values separated by comma\"", atf_unit::unittest_lib_json_ErrorBareValuesWithComma }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch1  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch10  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch10 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch11  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch11 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch12  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch12 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch13  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch13 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch14  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch14 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch2  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch3  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch4  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch4 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch5  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch5 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch6  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch6 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch7  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch7 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch8  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch8 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorBrMismatch9  comment:\"Error case - bracket/brace mismatch\"", atf_unit::unittest_lib_json_ErrorBrMismatch9 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectColon1  comment:\"Error case - no colon\"", atf_unit::unittest_lib_json_ErrorObjectColon1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectColon2  comment:\"Error case - extra colon 1\"", atf_unit::unittest_lib_json_ErrorObjectColon2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectColon3  comment:\"Error case - extra colon 2\"", atf_unit::unittest_lib_json_ErrorObjectColon3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectColon4  comment:\"Error case - extra colon 3\"", atf_unit::unittest_lib_json_ErrorObjectColon4 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectColon5  comment:\"Error case - extra colon 4\"", atf_unit::unittest_lib_json_ErrorObjectColon5 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectComma1  comment:\"Error case - no comma\"", atf_unit::unittest_lib_json_ErrorObjectComma1 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectComma2  comment:\"Error case - extra comma 1\"", atf_unit::unittest_lib_json_ErrorObjectComma2 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectComma3  comment:\"Error case - extra comma 2\"", atf_unit::unittest_lib_json_ErrorObjectComma3 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectComma4  comment:\"Error case - extra comma 3\"", atf_unit::unittest_lib_json_ErrorObjectComma4 }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectDupField  comment:\"Error case - duplicate field\"", atf_unit::unittest_lib_json_ErrorObjectDupField }
        ,{ "atfdb.unittest  unittest:lib_json.ErrorObjectNoValue  comment:\"Error case - no value\"", atf_unit::unittest_lib_json_ErrorObjectNoValue }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_Object  comment:\"Json conversion: non-trivial object\"", atf_unit::unittest_lib_json_FmtJson_Object }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_TypeA  comment:\"Json conversion: wrapped integer\"", atf_unit::unittest_lib_json_FmtJson_TypeA }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_bool_false  comment:\"Json conversion: bool false\"", atf_unit::unittest_lib_json_FmtJson_bool_false }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_bool_true  comment:\"Json conversion: bool true\"", atf_unit::unittest_lib_json_FmtJson_bool_true }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_char  comment:\"Json conversion: cstring\"", atf_unit::unittest_lib_json_FmtJson_char }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_double_prec  comment:\"Json conversion: doube just works\"", atf_unit::unittest_lib_json_FmtJson_double_prec }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_float_prec  comment:\"Json conversion: float just works\"", atf_unit::unittest_lib_json_FmtJson_float_prec }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i16_max  comment:\"Json conversion: I16 max\"", atf_unit::unittest_lib_json_FmtJson_i16_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i16_min  comment:\"Json conversion: I16 min\"", atf_unit::unittest_lib_json_FmtJson_i16_min }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i32_max  comment:\"Json conversion: I32 max\"", atf_unit::unittest_lib_json_FmtJson_i32_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i32_min  comment:\"Json conversion: I32 min\"", atf_unit::unittest_lib_json_FmtJson_i32_min }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i64_max  comment:\"Json conversion: I64 max\"", atf_unit::unittest_lib_json_FmtJson_i64_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i64_min  comment:\"Json conversion: I64 min\"", atf_unit::unittest_lib_json_FmtJson_i64_min }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i8_max  comment:\"Json conversion: I8 max\"", atf_unit::unittest_lib_json_FmtJson_i8_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_i8_min  comment:\"Json conversion: I8 min\"", atf_unit::unittest_lib_json_FmtJson_i8_min }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u16_0  comment:\"Json conversion: U16 0\"", atf_unit::unittest_lib_json_FmtJson_u16_0 }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u16_max  comment:\"Json conversion: U16 max\"", atf_unit::unittest_lib_json_FmtJson_u16_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u32_0  comment:\"Json conversion: U32 0\"", atf_unit::unittest_lib_json_FmtJson_u32_0 }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u32_max  comment:\"Json conversion: U32 max\"", atf_unit::unittest_lib_json_FmtJson_u32_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u64_0  comment:\"Json conversion: U64 0\"", atf_unit::unittest_lib_json_FmtJson_u64_0 }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u64_max  comment:\"Json conversion: U64 max\"", atf_unit::unittest_lib_json_FmtJson_u64_max }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u8_0  comment:\"Json conversion: U8 0\"", atf_unit::unittest_lib_json_FmtJson_u8_0 }
        ,{ "atfdb.unittest  unittest:lib_json.FmtJson_u8_max  comment:\"Json conversion: U8 max\"", atf_unit::unittest_lib_json_FmtJson_u8_max }
        ,{ "atfdb.unittest  unittest:lib_json.NumberCombined1  comment:\"Number - combined 1\"", atf_unit::unittest_lib_json_NumberCombined1 }
        ,{ "atfdb.unittest  unittest:lib_json.NumberCombined2  comment:\"Number - combined 2\"", atf_unit::unittest_lib_json_NumberCombined2 }
        ,{ "atfdb.unittest  unittest:lib_json.NumberDecimal  comment:\"Number - decimal dot\"", atf_unit::unittest_lib_json_NumberDecimal }
        ,{ "atfdb.unittest  unittest:lib_json.NumberExponent1  comment:\"Number - exponent\"", atf_unit::unittest_lib_json_NumberExponent1 }
        ,{ "atfdb.unittest  unittest:lib_json.NumberExponent2  comment:\"Number - lowercase exponent\"", atf_unit::unittest_lib_json_NumberExponent2 }
        ,{ "atfdb.unittest  unittest:lib_json.NumberManyDigits  comment:\"Number - many digits\"", atf_unit::unittest_lib_json_NumberManyDigits }
        ,{ "atfdb.unittest  unittest:lib_json.NumberZero  comment:\"Zero number\"", atf_unit::unittest_lib_json_NumberZero }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldAll  comment:\"Many object fields with all value types\"", atf_unit::unittest_lib_json_ObjFieldAll }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldEmptyArray  comment:\"Single empty array  field\"", atf_unit::unittest_lib_json_ObjFieldEmptyArray }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldEmptyObject  comment:\"Single empty object field\"", atf_unit::unittest_lib_json_ObjFieldEmptyObject }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldSimpleNumber  comment:\"Single simple number field\"", atf_unit::unittest_lib_json_ObjFieldSimpleNumber }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldSimpleString  comment:\"Single simple string field\"", atf_unit::unittest_lib_json_ObjFieldSimpleString }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldTokenFalse  comment:\"Single false token field\"", atf_unit::unittest_lib_json_ObjFieldTokenFalse }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldTokenNull  comment:\"Single null token field\"", atf_unit::unittest_lib_json_ObjFieldTokenNull }
        ,{ "atfdb.unittest  unittest:lib_json.ObjFieldTokenTrue  comment:\"Single true token field\"", atf_unit::unittest_lib_json_ObjFieldTokenTrue }
        ,{ "atfdb.unittest  unittest:lib_json.SecString  comment:\"Single json security string\"", atf_unit::unittest_lib_json_SecString }
        ,{ "atfdb.unittest  unittest:lib_json.SimpleNumber  comment:\"Single simple number\"", atf_unit::unittest_lib_json_SimpleNumber }
        ,{ "atfdb.unittest  unittest:lib_json.SimpleString  comment:\"Single simple string\"", atf_unit::unittest_lib_json_SimpleString }
        ,{ "atfdb.unittest  unittest:lib_json.StringEmpty  comment:\"String -  empty\"", atf_unit::unittest_lib_json_StringEmpty }
        ,{ "atfdb.unittest  unittest:lib_json.StringWithEscapes  comment:\"String - escapes\"", atf_unit::unittest_lib_json_StringWithEscapes }
        ,{ "atfdb.unittest  unittest:lib_json.TokenFalse  comment:\"Single false token\"", atf_unit::unittest_lib_json_TokenFalse }
        ,{ "atfdb.unittest  unittest:lib_json.TokenNull  comment:\"Single null token\"", atf_unit::unittest_lib_json_TokenNull }
        ,{ "atfdb.unittest  unittest:lib_json.TokenTrue  comment:\"Single true token\"", atf_unit::unittest_lib_json_TokenTrue }
        ,{ "atfdb.unittest  unittest:lib_json.Typical  comment:\"Normal case similar to typical usage\"", atf_unit::unittest_lib_json_Typical }
        ,{ "atfdb.unittest  unittest:lib_sql.Main  comment:\"\"", atf_unit::unittest_lib_sql_Main }
        ,{NULL, NULL}
    };
    (void)data;
    atfdb::Unittest unittest;
    for (int i=0; data[i].s; i++) {
        (void)atfdb::Unittest_ReadStrptrMaybe(unittest, strptr(data[i].s));
        atf_unit::FUnittest *elem = unittest_InsertMaybe(unittest);
        vrfy(elem, tempstr("atf_unit.static_insert_fatal_error")
        << Keyval("tuple",strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- atf_unit.FDb.unittest.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::unittest_XrefMaybe(atf_unit::FUnittest &row) {
    bool retval = true;
    (void)row;
    // insert unittest into index ind_unittest
    if (true) { // user-defined insert condition
        bool success = ind_unittest_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_unit.duplicate_key  xref:atf_unit.FDb.ind_unittest"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_unit.FDb._db.MainArgs
// Main function
void atf_unit::MainArgs(int argc, char **argv) {
    Argtuple argtuple;
    Argtuple_ReadArgv(argtuple, argc,argv,atf_unit_syntax, atf_unit_help);
    vrfy(atf_unit_ReadTupleMaybe(atf_unit::_db.cmdline, argtuple.tuple),"where:read_cmdline");
    vrfy(atf_unit::LoadTuplesMaybe(atf_unit::_db.cmdline.data_dir)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
    atf_unit::Main(); // call through to user-defined main
}

// --- atf_unit.FDb._db.MainLoop
// Main loop.
void atf_unit::MainLoop() {
    SchedTime time(get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        algo_lib::Step(); // dependent namespace specified via (dev.targdep)
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- atf_unit.FDb._db.Step
// Main step
void atf_unit::Step() {
}

// --- atf_unit.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void atf_unit::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("atf_unit", NULL, NULL, atf_unit::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "atf_unit.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(atf_unit::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)atf_unit::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
}

// --- atf_unit.FDb._db.StaticCheck
void atf_unit::StaticCheck() {
    algo_assert(sizeof(atf_unit::unittest_step_hook) == 8); // csize:atf_unit.unittest_step_hook
    algo_assert(_offset_of(atf_unit::FieldId, value) + sizeof(((atf_unit::FieldId*)0)->value) == sizeof(atf_unit::FieldId));
}

// --- atf_unit.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool atf_unit::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    (void)str;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_unit.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool atf_unit::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    (void)root;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_unit.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool atf_unit::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, atf_unit::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- atf_unit.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- atf_unit.FDb.ind_unittest.Find
// Find row by key. Return NULL if not found.
atf_unit::FUnittest* atf_unit::ind_unittest_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_unittest_buckets_n - 1);
    atf_unit::FUnittest* *e = &_db.ind_unittest_buckets_elems[index];
    atf_unit::FUnittest* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).unittest == key;
        if (done) break;
        e         = &ret->ind_unittest_next;
    } while (true);
    return ret;
}

// --- atf_unit.FDb.ind_unittest.FindX
// Look up row by key and return reference. Throw exception if not found
atf_unit::FUnittest& atf_unit::ind_unittest_FindX(const algo::strptr& key) {
    atf_unit::FUnittest* ret = ind_unittest_Find(key);
    vrfy(ret, tempstr() << "atf_unit.key_error  table:ind_unittest  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- atf_unit.FDb.ind_unittest.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_unit::FUnittest& atf_unit::ind_unittest_GetOrCreate(const algo::strptr& key) {
    atf_unit::FUnittest* ret = ind_unittest_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &unittest_Alloc();
        (*ret).unittest = key;
        bool good = unittest_XrefMaybe(*ret);
        if (!good) {
            unittest_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- atf_unit.FDb.ind_unittest.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_unit::ind_unittest_InsertMaybe(atf_unit::FUnittest& row) {
    ind_unittest_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_unittest_next == (atf_unit::FUnittest*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.unittest) & (_db.ind_unittest_buckets_n - 1);
        atf_unit::FUnittest* *prev = &_db.ind_unittest_buckets_elems[index];
        do {
            atf_unit::FUnittest* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).unittest == row.unittest) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_unittest_next;
        } while (true);
        if (retval) {
            row.ind_unittest_next = *prev;
            _db.ind_unittest_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_unit.FDb.ind_unittest.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_unit::ind_unittest_Remove(atf_unit::FUnittest& row) {
    if (LIKELY(row.ind_unittest_next != (atf_unit::FUnittest*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.unittest) & (_db.ind_unittest_buckets_n - 1);
        atf_unit::FUnittest* *prev = &_db.ind_unittest_buckets_elems[index]; // addr of pointer to current element
        while (atf_unit::FUnittest *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_unittest_next; // unlink (singly linked list)
                _db.ind_unittest_n--;
                row.ind_unittest_next = (atf_unit::FUnittest*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_unittest_next;
        }
    }
}

// --- atf_unit.FDb.ind_unittest.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_unit::ind_unittest_Reserve(int n) {
    u32 old_nbuckets = _db.ind_unittest_buckets_n;
    u32 new_nelems   = _db.ind_unittest_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_unit::FUnittest*);
        u32 new_size = new_nbuckets * sizeof(atf_unit::FUnittest*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_unit::FUnittest* *new_buckets = (atf_unit::FUnittest**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_unit.out_of_memory  field:atf_unit.FDb.ind_unittest");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_unittest_buckets_n; i++) {
            atf_unit::FUnittest* elem = _db.ind_unittest_buckets_elems[i];
            while (elem) {
                atf_unit::FUnittest &row        = *elem;
                atf_unit::FUnittest* next       = row.ind_unittest_next;
                u32 index          = Smallstr50_Hash(0, row.unittest) & (new_nbuckets-1);
                row.ind_unittest_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_unittest_buckets_elems, old_size);
        _db.ind_unittest_buckets_elems = new_buckets;
        _db.ind_unittest_buckets_n = new_nbuckets;
    }
}

// --- atf_unit.FDb.ind_testrun.Find
// Find row by key. Return NULL if not found.
atf_unit::FTestrun* atf_unit::ind_testrun_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_testrun_buckets_n - 1);
    atf_unit::FTestrun* *e = &_db.ind_testrun_buckets_elems[index];
    atf_unit::FTestrun* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).testrun == key;
        if (done) break;
        e         = &ret->ind_testrun_next;
    } while (true);
    return ret;
}

// --- atf_unit.FDb.ind_testrun.FindX
// Look up row by key and return reference. Throw exception if not found
atf_unit::FTestrun& atf_unit::ind_testrun_FindX(const algo::strptr& key) {
    atf_unit::FTestrun* ret = ind_testrun_Find(key);
    vrfy(ret, tempstr() << "atf_unit.key_error  table:ind_testrun  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- atf_unit.FDb.ind_testrun.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_unit::ind_testrun_InsertMaybe(atf_unit::FTestrun& row) {
    ind_testrun_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_testrun_next == (atf_unit::FTestrun*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.testrun) & (_db.ind_testrun_buckets_n - 1);
        atf_unit::FTestrun* *prev = &_db.ind_testrun_buckets_elems[index];
        do {
            atf_unit::FTestrun* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).testrun == row.testrun) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_testrun_next;
        } while (true);
        if (retval) {
            row.ind_testrun_next = *prev;
            _db.ind_testrun_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_unit.FDb.ind_testrun.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_unit::ind_testrun_Remove(atf_unit::FTestrun& row) {
    if (LIKELY(row.ind_testrun_next != (atf_unit::FTestrun*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.testrun) & (_db.ind_testrun_buckets_n - 1);
        atf_unit::FTestrun* *prev = &_db.ind_testrun_buckets_elems[index]; // addr of pointer to current element
        while (atf_unit::FTestrun *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_testrun_next; // unlink (singly linked list)
                _db.ind_testrun_n--;
                row.ind_testrun_next = (atf_unit::FTestrun*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_testrun_next;
        }
    }
}

// --- atf_unit.FDb.ind_testrun.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_unit::ind_testrun_Reserve(int n) {
    u32 old_nbuckets = _db.ind_testrun_buckets_n;
    u32 new_nelems   = _db.ind_testrun_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_unit::FTestrun*);
        u32 new_size = new_nbuckets * sizeof(atf_unit::FTestrun*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_unit::FTestrun* *new_buckets = (atf_unit::FTestrun**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_unit.out_of_memory  field:atf_unit.FDb.ind_testrun");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_testrun_buckets_n; i++) {
            atf_unit::FTestrun* elem = _db.ind_testrun_buckets_elems[i];
            while (elem) {
                atf_unit::FTestrun &row        = *elem;
                atf_unit::FTestrun* next       = row.ind_testrun_next;
                u32 index          = Smallstr50_Hash(0, row.testrun) & (new_nbuckets-1);
                row.ind_testrun_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_testrun_buckets_elems, old_size);
        _db.ind_testrun_buckets_elems = new_buckets;
        _db.ind_testrun_buckets_n = new_nbuckets;
    }
}

// --- atf_unit.FDb.testrun.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FTestrun& atf_unit::testrun_Alloc() {
    atf_unit::FTestrun* row = testrun_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_unit.out_of_mem  field:atf_unit.FDb.testrun  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_unit.FDb.testrun.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FTestrun* atf_unit::testrun_AllocMaybe() {
    atf_unit::FTestrun *row = (atf_unit::FTestrun*)testrun_AllocMem();
    if (row) {
        new (row) atf_unit::FTestrun; // call constructor
    }
    return row;
}

// --- atf_unit.FDb.testrun.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_unit::FTestrun* atf_unit::testrun_InsertMaybe(const atf::Testrun &value) {
    atf_unit::FTestrun *row = &testrun_Alloc(); // if out of memory, process dies. if input error, return NULL.
    testrun_CopyIn(*row,const_cast<atf::Testrun&>(value));
    bool ok = testrun_XrefMaybe(*row); // this may return false
    if (!ok) {
        testrun_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_unit.FDb.testrun.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_unit::testrun_AllocMem() {
    u64 new_nelems     = _db.testrun_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_unit::FTestrun*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.testrun_lary[bsr];
        if (!lev) {
            lev=(atf_unit::FTestrun*)algo_lib::malloc_AllocMem(sizeof(atf_unit::FTestrun) * (u64(1)<<bsr));
            _db.testrun_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.testrun_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- atf_unit.FDb.testrun.RemoveAll
// Remove all elements from Lary
void atf_unit::testrun_RemoveAll() {
    for (u64 n = _db.testrun_n; n>0; ) {
        n--;
        testrun_qFind(u64(n)).~FTestrun(); // destroy last element
        _db.testrun_n = n;
    }
}

// --- atf_unit.FDb.testrun.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::testrun_RemoveLast() {
    u64 n = _db.testrun_n;
    if (n > 0) {
        n -= 1;
        testrun_qFind(u64(n)).~FTestrun();
        _db.testrun_n = n;
    }
}

// --- atf_unit.FDb.testrun.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::testrun_XrefMaybe(atf_unit::FTestrun &row) {
    bool retval = true;
    (void)row;
    atf_unit::FUnittest* p_testrun = atf_unit::ind_unittest_Find(row.testrun);
    if (UNLIKELY(!p_testrun)) {
        algo_lib::ResetErrtext() << "atf_unit.bad_xref  index:atf_unit.FDb.ind_unittest" << Keyval("key", row.testrun);
        return false;
    }
    // insert testrun into index c_testrun
    if (true) { // user-defined insert condition
        bool success = c_testrun_InsertMaybe(*p_testrun, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_unit.duplicate_key  xref:atf_unit.FUnittest.c_testrun"; // check for duplicate key
            return false;
        }
    }
    // testrun: save pointer to testrun
    if (true) { // user-defined insert condition
        row.p_test = p_testrun;
    }
    // insert testrun into index ind_testrun
    if (true) { // user-defined insert condition
        bool success = ind_testrun_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_unit.duplicate_key  xref:atf_unit.FDb.ind_testrun"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_unit.FDb.acr_ed.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int atf_unit::acr_ed_Start() {
    int retval = 0;
    if (_db.acr_ed_pid == 0) {
        verblog(acr_ed_ToCmdline()); // maybe print command
        _db.acr_ed_status = 0; // reset last status
        _db.acr_ed_pid = fork();
        if (_db.acr_ed_pid == 0) { // child
            algo_lib::DieWithParent();
            if (_db.acr_ed_timeout > 0) {
                alarm(_db.acr_ed_timeout);
            }
            algo_lib::ApplyRedirect(_db.acr_ed_stdin, 0);
            algo_lib::ApplyRedirect(_db.acr_ed_stdout, 1);
            algo_lib::ApplyRedirect(_db.acr_ed_stderr, 2);
            retval = acr_ed_Execv();
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("atf_unit.acr_ed_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (_db.acr_ed_pid == -1) {
            retval = errno; // failed to fork
        } else {
            retval = _db.acr_ed_status; // parent
        }
    }
    return retval;
}

// --- atf_unit.FDb.acr_ed.Kill
// Kill subprocess and wait
void atf_unit::acr_ed_Kill() {
    if (_db.acr_ed_pid != 0) {
        kill(_db.acr_ed_pid,9);
        acr_ed_Wait();
    }
}

// --- atf_unit.FDb.acr_ed.Wait
// Wait for subprocess to return
void atf_unit::acr_ed_Wait() {
    if (_db.acr_ed_pid != 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(_db.acr_ed_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == _db.acr_ed_pid) {
            _db.acr_ed_status = wait_status;
            _db.acr_ed_pid = 0;
        }
    }
}

// --- atf_unit.FDb.acr_ed.Exec
// Start + Wait
// Execute subprocess and return exit code
int atf_unit::acr_ed_Exec() {
    acr_ed_Start();
    acr_ed_Wait();
    return _db.acr_ed_status;
}

// --- atf_unit.FDb.acr_ed.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void atf_unit::acr_ed_ExecX() {
    int rc = acr_ed_Exec();
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_ed_ToCmdline())
    << Keyval("comment",algo::DescribeWaitStatus(_db.acr_ed_status)));
}

// --- atf_unit.FDb.acr_ed.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr_ed.Argv
int atf_unit::acr_ed_Execv() {
    char *argv[41+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << _db.acr_ed_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (_db.acr_ed_cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(_db.acr_ed_cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.create != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-create:";
        bool_Print(_db.acr_ed_cmd.create, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.del != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-del:";
        bool_Print(_db.acr_ed_cmd.del, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.rename != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rename:";
        cstring_Print(_db.acr_ed_cmd.rename, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.replace != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(_db.acr_ed_cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.finput != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-finput:";
        bool_Print(_db.acr_ed_cmd.finput, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.srcfile != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-srcfile:";
        cstring_Print(_db.acr_ed_cmd.srcfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.gstatic != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-gstatic:";
        bool_Print(_db.acr_ed_cmd.gstatic, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.indexed != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-indexed:";
        bool_Print(_db.acr_ed_cmd.indexed, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.target != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        Smallstr16_Print(_db.acr_ed_cmd.target, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.nstype != "exe") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nstype:";
        Smallstr50_Print(_db.acr_ed_cmd.nstype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.ctype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ctype:";
        Smallstr50_Print(_db.acr_ed_cmd.ctype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.pooltype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pooltype:";
        Smallstr50_Print(_db.acr_ed_cmd.pooltype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.ssimfile != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ssimfile:";
        Smallstr50_Print(_db.acr_ed_cmd.ssimfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.subset != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-subset:";
        Smallstr50_Print(_db.acr_ed_cmd.subset, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.subset2 != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-subset2:";
        Smallstr50_Print(_db.acr_ed_cmd.subset2, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.separator != ".") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-separator:";
        cstring_Print(_db.acr_ed_cmd.separator, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.field != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        Smallstr100_Print(_db.acr_ed_cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.arg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arg:";
        Smallstr50_Print(_db.acr_ed_cmd.arg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.dflt != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dflt:";
        cstring_Print(_db.acr_ed_cmd.dflt, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.anon != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-anon:";
        bool_Print(_db.acr_ed_cmd.anon, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.bigend != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-bigend:";
        bool_Print(_db.acr_ed_cmd.bigend, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.cascdel != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cascdel:";
        bool_Print(_db.acr_ed_cmd.cascdel, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.before != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-before:";
        Smallstr100_Print(_db.acr_ed_cmd.before, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.substr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-substr:";
        Smallstr100_Print(_db.acr_ed_cmd.substr, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.srcfield != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-srcfield:";
        Smallstr100_Print(_db.acr_ed_cmd.srcfield, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.fstep != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fstep:";
        Smallstr100_Print(_db.acr_ed_cmd.fstep, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.inscond != "true") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-inscond:";
        cstring_Print(_db.acr_ed_cmd.inscond, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.reftype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-reftype:";
        Smallstr50_Print(_db.acr_ed_cmd.reftype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.hashfld != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-hashfld:";
        Smallstr100_Print(_db.acr_ed_cmd.hashfld, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.sortfld != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sortfld:";
        Smallstr100_Print(_db.acr_ed_cmd.sortfld, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.unittest != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unittest:";
        cstring_Print(_db.acr_ed_cmd.unittest, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.normcheck != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-normcheck:";
        cstring_Print(_db.acr_ed_cmd.normcheck, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.cppfunc != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cppfunc:";
        cstring_Print(_db.acr_ed_cmd.cppfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(_db.acr_ed_cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.via != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-via:";
        cstring_Print(_db.acr_ed_cmd.via, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.showcpp != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-showcpp:";
        bool_Print(_db.acr_ed_cmd.showcpp, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(_db.acr_ed_cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(_db.acr_ed_cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.comment != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-comment:";
        cstring_Print(_db.acr_ed_cmd.comment, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.acr_ed_cmd.sandbox != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sandbox:";
        bool_Print(_db.acr_ed_cmd.sandbox, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    return execv(Zeroterm(_db.acr_ed_path),argv);
}

// --- atf_unit.FDb.acr_ed.ToCmdline
algo::tempstr atf_unit::acr_ed_ToCmdline() {
    algo::tempstr retval;
    retval << _db.acr_ed_path << " ";
    command::acr_ed_PrintArgv(_db.acr_ed_cmd,retval);
    if (ch_N(_db.acr_ed_stdin)) {
        retval << " " << _db.acr_ed_stdin;
    }
    if (ch_N(_db.acr_ed_stdout)) {
        retval << " " << _db.acr_ed_stdout;
    }
    if (ch_N(_db.acr_ed_stderr)) {
        retval << " 2" << _db.acr_ed_stderr;
    }
    return retval;
}

// --- atf_unit.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr atf_unit::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- atf_unit.FDb.trace.N
// Function return 1
inline static i32 atf_unit::trace_N() {
    return 1;
}

// --- atf_unit.FDb..Init
// Set all fields to initial values.
void atf_unit::FDb_Init() {
    // number: initialize Tpool
    _db.number_free      = NULL;
    _db.number_blocksize = BumpToPow2(64 * sizeof(atf_unit::FNumber)); // allocate 64-127 elements at a time
    _db.tr_number_root = NULL; // (atf_unit.FDb.tr_number)
    _db.tr_number_n = 0;
    // initialize LAry unittest (atf_unit.FDb.unittest)
    _db.unittest_n = 0;
    memset(_db.unittest_lary, 0, sizeof(_db.unittest_lary)); // zero out all level pointers
    atf_unit::FUnittest* unittest_first = (atf_unit::FUnittest*)algo_lib::malloc_AllocMem(sizeof(atf_unit::FUnittest) * (u64(1)<<4));
    if (!unittest_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.unittest_lary[i]  = unittest_first;
        unittest_first    += 1ULL<<i;
    }
    // initialize hash table for atf_unit::FUnittest;
    _db.ind_unittest_n             	= 0; // (atf_unit.FDb.ind_unittest)
    _db.ind_unittest_buckets_n     	= 4; // (atf_unit.FDb.ind_unittest)
    _db.ind_unittest_buckets_elems 	= (atf_unit::FUnittest**)algo_lib::malloc_AllocMem(sizeof(atf_unit::FUnittest*)*_db.ind_unittest_buckets_n); // initial buckets (atf_unit.FDb.ind_unittest)
    if (!_db.ind_unittest_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_unit.FDb.ind_unittest)
    }
    memset(_db.ind_unittest_buckets_elems, 0, sizeof(atf_unit::FUnittest*)*_db.ind_unittest_buckets_n); // (atf_unit.FDb.ind_unittest)
    _db.c_test = NULL;
    _db.perf_cycle_budget = u64(0);
    // initialize hash table for atf_unit::FTestrun;
    _db.ind_testrun_n             	= 0; // (atf_unit.FDb.ind_testrun)
    _db.ind_testrun_buckets_n     	= 4; // (atf_unit.FDb.ind_testrun)
    _db.ind_testrun_buckets_elems 	= (atf_unit::FTestrun**)algo_lib::malloc_AllocMem(sizeof(atf_unit::FTestrun*)*_db.ind_testrun_buckets_n); // initial buckets (atf_unit.FDb.ind_testrun)
    if (!_db.ind_testrun_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_unit.FDb.ind_testrun)
    }
    memset(_db.ind_testrun_buckets_elems, 0, sizeof(atf_unit::FTestrun*)*_db.ind_testrun_buckets_n); // (atf_unit.FDb.ind_testrun)
    // initialize LAry testrun (atf_unit.FDb.testrun)
    _db.testrun_n = 0;
    memset(_db.testrun_lary, 0, sizeof(_db.testrun_lary)); // zero out all level pointers
    atf_unit::FTestrun* testrun_first = (atf_unit::FTestrun*)algo_lib::malloc_AllocMem(sizeof(atf_unit::FTestrun) * (u64(1)<<4));
    if (!testrun_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.testrun_lary[i]  = testrun_first;
        testrun_first    += 1ULL<<i;
    }
    _db.acr_ed_path = algo::strptr("bin/acr_ed");
    _db.acr_ed_pid = pid_t(0);
    _db.acr_ed_timeout = i32(0);
    _db.acr_ed_status = i32(0);

    atf_unit::InitReflection();
    unittest_LoadStatic();
}

// --- atf_unit.FDb..Uninit
void atf_unit::FDb_Uninit() {
    atf_unit::FDb &row = _db; (void)row;

    // atf_unit.FDb.acr_ed.Uninit (Exec)  //
    acr_ed_Kill(); // kill child, ensure forward progress

    // atf_unit.FDb.testrun.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_unit.FDb.ind_testrun.Uninit (Thash)  //
    // skip destruction of ind_testrun in global scope

    // atf_unit.FDb.ind_unittest.Uninit (Thash)  //
    // skip destruction of ind_unittest in global scope

    // atf_unit.FDb.unittest.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- atf_unit.FNumber..Uninit
void atf_unit::FNumber_Uninit(atf_unit::FNumber& number) {
    atf_unit::FNumber &row = number; (void)row;
    tr_number_Remove(row); // remove number from index tr_number
}

// --- atf_unit.FPerfSort.orig.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::Dbl& atf_unit::orig_Alloc(atf_unit::FPerfSort& parent) {
    orig_Reserve(parent, 1);
    int n  = parent.orig_n;
    int at = n;
    atf_unit::Dbl *elems = parent.orig_elems;
    new (elems + at) atf_unit::Dbl(); // construct new element, default initializer
    parent.orig_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.orig.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::Dbl& atf_unit::orig_AllocAt(atf_unit::FPerfSort& parent, int at) {
    orig_Reserve(parent, 1);
    int n  = parent.orig_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_unit.bad_alloc_at  field:atf_unit.FPerfSort.orig  comment:'index out of range'");
    }
    atf_unit::Dbl *elems = parent.orig_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_unit::Dbl));
    new (elems + at) atf_unit::Dbl(); // construct element, default initializer
    parent.orig_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.orig.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::Dbl> atf_unit::orig_AllocN(atf_unit::FPerfSort& parent, int n_elems) {
    orig_Reserve(parent, n_elems);
    int old_n  = parent.orig_n;
    int new_n = old_n + n_elems;
    atf_unit::Dbl *elems = parent.orig_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_unit::Dbl(); // construct new element, default initialize
    }
    parent.orig_n = new_n;
    return algo::aryptr<atf_unit::Dbl>(elems + old_n, n_elems);
}

// --- atf_unit.FPerfSort.orig.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_unit::orig_Remove(atf_unit::FPerfSort& parent, u32 i) {
    u32 lim = parent.orig_n;
    atf_unit::Dbl *elems = parent.orig_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(atf_unit::Dbl) * (lim - (i + 1)));
        parent.orig_n = lim - 1;
    }
}

// --- atf_unit.FPerfSort.orig.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::orig_RemoveLast(atf_unit::FPerfSort& parent) {
    u64 n = parent.orig_n;
    if (n > 0) {
        n -= 1;
        parent.orig_n = n;
    }
}

// --- atf_unit.FPerfSort.orig.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_unit::orig_AbsReserve(atf_unit::FPerfSort& parent, int n) {
    u32 old_max  = parent.orig_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::malloc_ReallocMem(parent.orig_elems, old_max * sizeof(atf_unit::Dbl), new_max * sizeof(atf_unit::Dbl));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("atf_unit.tary_nomem  field:atf_unit.FPerfSort.orig  comment:'out of memory'");
    }
    parent.orig_elems = (atf_unit::Dbl*)new_mem;
    parent.orig_max = new_max;
}

// --- atf_unit.FPerfSort.orig.Setary
// Copy contents of RHS to PARENT.
void atf_unit::orig_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) {
    orig_RemoveAll(parent);
    int nnew = rhs.orig_n;
    orig_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.orig_elems + i) atf_unit::Dbl(orig_qFind(rhs, i));
        parent.orig_n = i + 1;
    }
}

// --- atf_unit.FPerfSort.orig.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::orig_XrefMaybe(atf_unit::Dbl &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_unit.FPerfSort.sorted.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_unit::Dbl> atf_unit::sorted_Addary(atf_unit::FPerfSort& parent, algo::aryptr<atf_unit::Dbl> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.sorted_elems && rhs.elems < parent.sorted_elems + parent.sorted_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_unit.tary_alias  field:atf_unit.FPerfSort.sorted  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    sorted_Reserve(parent, nnew); // reserve space
    int at = parent.sorted_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.sorted_elems + at + i) atf_unit::Dbl(rhs[i]);
        parent.sorted_n++;
    }
    return algo::aryptr<atf_unit::Dbl>(parent.sorted_elems + at, nnew);
}

// --- atf_unit.FPerfSort.sorted.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::Dbl& atf_unit::sorted_Alloc(atf_unit::FPerfSort& parent) {
    sorted_Reserve(parent, 1);
    int n  = parent.sorted_n;
    int at = n;
    atf_unit::Dbl *elems = parent.sorted_elems;
    new (elems + at) atf_unit::Dbl(); // construct new element, default initializer
    parent.sorted_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.sorted.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::Dbl& atf_unit::sorted_AllocAt(atf_unit::FPerfSort& parent, int at) {
    sorted_Reserve(parent, 1);
    int n  = parent.sorted_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_unit.bad_alloc_at  field:atf_unit.FPerfSort.sorted  comment:'index out of range'");
    }
    atf_unit::Dbl *elems = parent.sorted_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_unit::Dbl));
    new (elems + at) atf_unit::Dbl(); // construct element, default initializer
    parent.sorted_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.sorted.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::Dbl> atf_unit::sorted_AllocN(atf_unit::FPerfSort& parent, int n_elems) {
    sorted_Reserve(parent, n_elems);
    int old_n  = parent.sorted_n;
    int new_n = old_n + n_elems;
    atf_unit::Dbl *elems = parent.sorted_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_unit::Dbl(); // construct new element, default initialize
    }
    parent.sorted_n = new_n;
    return algo::aryptr<atf_unit::Dbl>(elems + old_n, n_elems);
}

// --- atf_unit.FPerfSort.sorted.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_unit::sorted_Remove(atf_unit::FPerfSort& parent, u32 i) {
    u32 lim = parent.sorted_n;
    atf_unit::Dbl *elems = parent.sorted_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(atf_unit::Dbl) * (lim - (i + 1)));
        parent.sorted_n = lim - 1;
    }
}

// --- atf_unit.FPerfSort.sorted.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::sorted_RemoveLast(atf_unit::FPerfSort& parent) {
    u64 n = parent.sorted_n;
    if (n > 0) {
        n -= 1;
        parent.sorted_n = n;
    }
}

// --- atf_unit.FPerfSort.sorted.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_unit::sorted_AbsReserve(atf_unit::FPerfSort& parent, int n) {
    u32 old_max  = parent.sorted_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::malloc_ReallocMem(parent.sorted_elems, old_max * sizeof(atf_unit::Dbl), new_max * sizeof(atf_unit::Dbl));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("atf_unit.tary_nomem  field:atf_unit.FPerfSort.sorted  comment:'out of memory'");
    }
    parent.sorted_elems = (atf_unit::Dbl*)new_mem;
    parent.sorted_max = new_max;
}

// --- atf_unit.FPerfSort.sorted.Setary
// Copy contents of RHS to PARENT.
void atf_unit::sorted_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) {
    sorted_RemoveAll(parent);
    int nnew = rhs.sorted_n;
    sorted_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.sorted_elems + i) atf_unit::Dbl(sorted_qFind(rhs, i));
        parent.sorted_n = i + 1;
    }
}

// --- atf_unit.FPerfSort.sorted.Setary2
// Copy specified array into sorted, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_unit::sorted_Setary(atf_unit::FPerfSort& parent, const algo::aryptr<atf_unit::Dbl> &rhs) {
    sorted_RemoveAll(parent);
    sorted_Addary(parent, rhs);
}

// --- atf_unit.FPerfSort.sorted.Swap
// Swap values elem_a and elem_b
inline static void atf_unit::sorted_Swap(atf_unit::Dbl &elem_a, atf_unit::Dbl &elem_b) {
    atf_unit::Dbl temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- atf_unit.FPerfSort.sorted.Rotleft
// Left circular shift of three-tuple
inline static void atf_unit::sorted_Rotleft(atf_unit::Dbl &elem_a, atf_unit::Dbl &elem_b, atf_unit::Dbl &elem_c) {
    atf_unit::Dbl temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- atf_unit.FPerfSort.sorted.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_unit::sorted_Lt(atf_unit::Dbl elem_a, atf_unit::Dbl elem_b) {
    bool ret;
    ret = elem_a.val < elem_b.val;
    return ret;
}

// --- atf_unit.FPerfSort.sorted.SortedQ
// Verify whether array is sorted
bool atf_unit::sorted_SortedQ(atf_unit::FPerfSort& parent) {
    atf_unit::Dbl *elems = sorted_Getary(parent).elems;
    int n = sorted_N(parent);
    for (int i = 1; i < n; i++) {
        if (sorted_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_unit.FPerfSort.sorted.IntInsertionSort
// Internal insertion sort
static void atf_unit::sorted_IntInsertionSort(atf_unit::Dbl *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        atf_unit::Dbl tmp = elems[i];
        // shift elements up by one
        if (sorted_Lt(tmp, elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && sorted_Lt(tmp, elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- atf_unit.FPerfSort.sorted.IntHeapSort
// Internal heap sort
static void atf_unit::sorted_IntHeapSort(atf_unit::Dbl *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (sorted_Lt(elems[j], elems[k])) {
            sorted_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && sorted_Lt(elems[l], elems[l+1]);
            if (sorted_Lt(elems[l], elems[i])) {
                break;
            }
            sorted_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            sorted_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_unit.FPerfSort.sorted.IntQuickSort
// Quick sort engine
static void atf_unit::sorted_IntQuickSort(atf_unit::Dbl *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            sorted_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (sorted_Lt(elems[pp], elems[pi])) {
            sorted_Swap(elems[pi], elems[pp]);
        }
        if (sorted_Lt(elems[pj], elems[pp])) {
            if (sorted_Lt(elems[pj], elems[pi])) {
                sorted_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                sorted_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        sorted_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        atf_unit::Dbl pivot = elems[pj];
        for(;;){
            while (sorted_Lt(elems[++pi], pivot)) {
            }
            while (sorted_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            sorted_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        sorted_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    sorted_IntInsertionSort(elems,n);
}

// --- atf_unit.FPerfSort.sorted.InsertionSort
// Insertion sort
void atf_unit::sorted_InsertionSort(atf_unit::FPerfSort& parent) {
    atf_unit::Dbl *elems = sorted_Getary(parent).elems;
    int n = sorted_N(parent);
    sorted_IntInsertionSort(elems, n);
}

// --- atf_unit.FPerfSort.sorted.HeapSort
// Heap sort
void atf_unit::sorted_HeapSort(atf_unit::FPerfSort& parent) {
    atf_unit::Dbl *elems = sorted_Getary(parent).elems;
    int n = sorted_N(parent);
    sorted_IntHeapSort(elems, n);
}

// --- atf_unit.FPerfSort.sorted.QuickSort
// Quick sort
void atf_unit::sorted_QuickSort(atf_unit::FPerfSort& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = CeilingLog2(u32(sorted_N(parent) + 1)) + 3;
    atf_unit::Dbl *elems = sorted_Getary(parent).elems;
    int n = sorted_N(parent);
    sorted_IntQuickSort(elems, n, max_depth);
}

// --- atf_unit.FPerfSort.index.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& atf_unit::index_Alloc(atf_unit::FPerfSort& parent) {
    index_Reserve(parent, 1);
    int n  = parent.index_n;
    int at = n;
    i32 *elems = parent.index_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    parent.index_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.index.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& atf_unit::index_AllocAt(atf_unit::FPerfSort& parent, int at) {
    index_Reserve(parent, 1);
    int n  = parent.index_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_unit.bad_alloc_at  field:atf_unit.FPerfSort.index  comment:'index out of range'");
    }
    i32 *elems = parent.index_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    parent.index_n = n+1;
    return elems[at];
}

// --- atf_unit.FPerfSort.index.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> atf_unit::index_AllocN(atf_unit::FPerfSort& parent, int n_elems) {
    index_Reserve(parent, n_elems);
    int old_n  = parent.index_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.index_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    parent.index_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- atf_unit.FPerfSort.index.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_unit::index_Remove(atf_unit::FPerfSort& parent, u32 i) {
    u32 lim = parent.index_n;
    i32 *elems = parent.index_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        parent.index_n = lim - 1;
    }
}

// --- atf_unit.FPerfSort.index.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::index_RemoveLast(atf_unit::FPerfSort& parent) {
    u64 n = parent.index_n;
    if (n > 0) {
        n -= 1;
        parent.index_n = n;
    }
}

// --- atf_unit.FPerfSort.index.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_unit::index_AbsReserve(atf_unit::FPerfSort& parent, int n) {
    u32 old_max  = parent.index_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::malloc_ReallocMem(parent.index_elems, old_max * sizeof(i32), new_max * sizeof(i32));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("atf_unit.tary_nomem  field:atf_unit.FPerfSort.index  comment:'out of memory'");
    }
    parent.index_elems = (i32*)new_mem;
    parent.index_max = new_max;
}

// --- atf_unit.FPerfSort.index.Setary
// Copy contents of RHS to PARENT.
void atf_unit::index_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) {
    index_RemoveAll(parent);
    int nnew = rhs.index_n;
    index_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.index_elems + i) i32(index_qFind(rhs, i));
        parent.index_n = i + 1;
    }
}

// --- atf_unit.FPerfSort..Uninit
void atf_unit::FPerfSort_Uninit(atf_unit::FPerfSort& parent) {
    atf_unit::FPerfSort &row = parent; (void)row;

    // atf_unit.FPerfSort.index.Uninit (Tary)  //
    // remove all elements from atf_unit.FPerfSort.index
    index_RemoveAll(parent);
    // free memory for Tary atf_unit.FPerfSort.index
    algo_lib::malloc_FreeMem(parent.index_elems, sizeof(i32)*parent.index_max); // (atf_unit.FPerfSort.index)

    // atf_unit.FPerfSort.sorted.Uninit (Tary)  //
    // remove all elements from atf_unit.FPerfSort.sorted
    sorted_RemoveAll(parent);
    // free memory for Tary atf_unit.FPerfSort.sorted
    algo_lib::malloc_FreeMem(parent.sorted_elems, sizeof(atf_unit::Dbl)*parent.sorted_max); // (atf_unit.FPerfSort.sorted)

    // atf_unit.FPerfSort.orig.Uninit (Tary)  //
    // remove all elements from atf_unit.FPerfSort.orig
    orig_RemoveAll(parent);
    // free memory for Tary atf_unit.FPerfSort.orig
    algo_lib::malloc_FreeMem(parent.orig_elems, sizeof(atf_unit::Dbl)*parent.orig_max); // (atf_unit.FPerfSort.orig)
}

// --- atf_unit.FTestrun.msghdr.CopyOut
// Copy fields out of row
void atf_unit::testrun_CopyOut(atf_unit::FTestrun &row, atf::Testrun &out) {
    out.testrun = row.testrun;
    out.testresult = row.testresult;
    out.n_step = row.n_step;
    out.n_cmp = row.n_cmp;
    out.comment = row.comment;
}

// --- atf_unit.FTestrun.msghdr.CopyIn
// Copy fields in to row
void atf_unit::testrun_CopyIn(atf_unit::FTestrun &row, atf::Testrun &in) {
    row.testrun = in.testrun;
    row.testresult = in.testresult;
    row.n_step = in.n_step;
    row.n_cmp = in.n_cmp;
    row.comment = in.comment;
}

// --- atf_unit.FTestrun..Uninit
void atf_unit::FTestrun_Uninit(atf_unit::FTestrun& testrun) {
    atf_unit::FTestrun &row = testrun; (void)row;
    atf_unit::FUnittest* p_testrun = atf_unit::ind_unittest_Find(row.testrun);
    if (p_testrun)  {
        c_testrun_Remove(*p_testrun, row);// remove testrun from index c_testrun
    }
    ind_testrun_Remove(row); // remove testrun from index ind_testrun
}

// --- atf_unit.FTestrun..Print
// print string representation of atf_unit::FTestrun to string LHS, no header -- cprint:atf_unit.FTestrun.String
void atf_unit::FTestrun_Print(atf_unit::FTestrun & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.FTestrun";

    algo::Smallstr50_Print(row.testrun, temp);
    PrintAttrSpaceReset(str,"testrun", temp);

    atf::Testresult_Print(row.testresult, temp);
    PrintAttrSpaceReset(str,"testresult", temp);

    u64_Print(row.n_step, temp);
    PrintAttrSpaceReset(str,"n_step", temp);

    u64_Print(row.n_cmp, temp);
    PrintAttrSpaceReset(str,"n_cmp", temp);

    algo::cstring_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atf_unit.FUnittest.msghdr.CopyOut
// Copy fields out of row
void atf_unit::unittest_CopyOut(atf_unit::FUnittest &row, atfdb::Unittest &out) {
    out.unittest = row.unittest;
    out.comment = row.comment;
}

// --- atf_unit.FUnittest.msghdr.CopyIn
// Copy fields in to row
void atf_unit::unittest_CopyIn(atf_unit::FUnittest &row, atfdb::Unittest &in) {
    row.unittest = in.unittest;
    row.comment = in.comment;
}

// --- atf_unit.FUnittest.target.Get
algo::Smallstr16 atf_unit::target_Get(atf_unit::FUnittest& unittest) {
    algo::Smallstr16 ret(algo::Pathcomp(unittest.unittest, ".RL"));
    return ret;
}

// --- atf_unit.FUnittest.testname.Get
algo::Smallstr50 atf_unit::testname_Get(atf_unit::FUnittest& unittest) {
    algo::Smallstr50 ret(algo::Pathcomp(unittest.unittest, ".RR"));
    return ret;
}

// --- atf_unit.FUnittest..Uninit
void atf_unit::FUnittest_Uninit(atf_unit::FUnittest& unittest) {
    atf_unit::FUnittest &row = unittest; (void)row;
    ind_unittest_Remove(row); // remove unittest from index ind_unittest
}

// --- atf_unit.FUnittest..Print
// print string representation of atf_unit::FUnittest to string LHS, no header -- cprint:atf_unit.FUnittest.String
void atf_unit::FUnittest_Print(atf_unit::FUnittest & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.FUnittest";

    algo::Smallstr50_Print(row.unittest, temp);
    PrintAttrSpaceReset(str,"unittest", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);

    u64_PrintHex(u64((const atf_unit::FTestrun*)row.c_testrun), temp, 8, true);
    PrintAttrSpaceReset(str,"c_testrun", temp);
}

// --- atf_unit.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_unit::value_ToCstr(const atf_unit::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_unit_FieldId_val          : ret = "val";  break;
        case atf_unit_FieldId_str_fld1     : ret = "str_fld1";  break;
        case atf_unit_FieldId_dbl_fld1     : ret = "dbl_fld1";  break;
        case atf_unit_FieldId_xyz          : ret = "xyz";  break;
        case atf_unit_FieldId_test         : ret = "test";  break;
        case atf_unit_FieldId_value        : ret = "value";  break;
        case atf_unit_FieldId_test2        : ret = "test2";  break;
        case atf_unit_FieldId_abc          : ret = "abc";  break;
        case atf_unit_FieldId_x            : ret = "x";  break;
        case atf_unit_FieldId_y            : ret = "y";  break;
        case atf_unit_FieldId_z            : ret = "z";  break;
        case atf_unit_FieldId_typea        : ret = "typea";  break;
        case atf_unit_FieldId_j            : ret = "j";  break;
    }
    return ret;
}

// --- atf_unit.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_unit::value_Print(const atf_unit::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_unit.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_unit::value_SetStrptrMaybe(atf_unit::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'j': {
                    value_SetEnum(parent,atf_unit_FieldId_j); ret = true; break;
                }
                case 'x': {
                    value_SetEnum(parent,atf_unit_FieldId_x); ret = true; break;
                }
                case 'y': {
                    value_SetEnum(parent,atf_unit_FieldId_y); ret = true; break;
                }
                case 'z': {
                    value_SetEnum(parent,atf_unit_FieldId_z); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','b','c'): {
                    value_SetEnum(parent,atf_unit_FieldId_abc); ret = true; break;
                }
                case LE_STR3('v','a','l'): {
                    value_SetEnum(parent,atf_unit_FieldId_val); ret = true; break;
                }
                case LE_STR3('x','y','z'): {
                    value_SetEnum(parent,atf_unit_FieldId_xyz); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(ReadLE32(rhs.elems))) {
                case LE_STR4('t','e','s','t'): {
                    value_SetEnum(parent,atf_unit_FieldId_test); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('t','e','s','t','2'): {
                    value_SetEnum(parent,atf_unit_FieldId_test2); ret = true; break;
                }
                case LE_STR5('t','y','p','e','a'): {
                    value_SetEnum(parent,atf_unit_FieldId_typea); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,atf_unit_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','b','l','_','f','l','d','1'): {
                    value_SetEnum(parent,atf_unit_FieldId_dbl_fld1); ret = true; break;
                }
                case LE_STR8('s','t','r','_','f','l','d','1'): {
                    value_SetEnum(parent,atf_unit_FieldId_str_fld1); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_unit.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_unit::value_SetStrptr(atf_unit::FieldId& parent, algo::strptr rhs, atf_unit_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_unit.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_unit::value_ReadStrptrMaybe(atf_unit::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_unit.FieldId..ReadStrptrMaybe
// Read fields of atf_unit::FieldId from an ascii string.
// The format of the string is the format of the atf_unit::FieldId's only field
bool atf_unit::FieldId_ReadStrptrMaybe(atf_unit::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && atf_unit::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_unit.FieldId..Print
// print string representation of atf_unit::FieldId to string LHS, no header -- cprint:atf_unit.FieldId.String
void atf_unit::FieldId_Print(atf_unit::FieldId & row, algo::cstring &str) {
    atf_unit::value_Print(row, str);
}

// --- atf_unit.ShStreamAry.shstream.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::ShStream& atf_unit::shstream_Alloc(atf_unit::ShStreamAry& parent) {
    shstream_Reserve(parent, 1);
    int n  = parent.shstream_n;
    int at = n;
    atf_unit::ShStream *elems = parent.shstream_elems;
    new (elems + at) atf_unit::ShStream(); // construct new element, default initializer
    parent.shstream_n = n+1;
    return elems[at];
}

// --- atf_unit.ShStreamAry.shstream.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::ShStream& atf_unit::shstream_AllocAt(atf_unit::ShStreamAry& parent, int at) {
    shstream_Reserve(parent, 1);
    int n  = parent.shstream_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_unit.bad_alloc_at  field:atf_unit.ShStreamAry.shstream  comment:'index out of range'");
    }
    atf_unit::ShStream *elems = parent.shstream_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_unit::ShStream));
    new (elems + at) atf_unit::ShStream(); // construct element, default initializer
    parent.shstream_n = n+1;
    return elems[at];
}

// --- atf_unit.ShStreamAry.shstream.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::ShStream> atf_unit::shstream_AllocN(atf_unit::ShStreamAry& parent, int n_elems) {
    shstream_Reserve(parent, n_elems);
    int old_n  = parent.shstream_n;
    int new_n = old_n + n_elems;
    atf_unit::ShStream *elems = parent.shstream_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_unit::ShStream(); // construct new element, default initialize
    }
    parent.shstream_n = new_n;
    return algo::aryptr<atf_unit::ShStream>(elems + old_n, n_elems);
}

// --- atf_unit.ShStreamAry.shstream.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_unit::shstream_Remove(atf_unit::ShStreamAry& parent, u32 i) {
    u32 lim = parent.shstream_n;
    atf_unit::ShStream *elems = parent.shstream_elems;
    if (i < lim) {
        elems[i].~ShStream(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(atf_unit::ShStream) * (lim - (i + 1)));
        parent.shstream_n = lim - 1;
    }
}

// --- atf_unit.ShStreamAry.shstream.RemoveAll
void atf_unit::shstream_RemoveAll(atf_unit::ShStreamAry& parent) {
    u32 n = parent.shstream_n;
    while (n > 0) {
        n -= 1;
        parent.shstream_elems[n].~ShStream();
        parent.shstream_n = n;
    }
}

// --- atf_unit.ShStreamAry.shstream.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_unit::shstream_RemoveLast(atf_unit::ShStreamAry& parent) {
    u64 n = parent.shstream_n;
    if (n > 0) {
        n -= 1;
        shstream_qFind(parent, u64(n)).~ShStream();
        parent.shstream_n = n;
    }
}

// --- atf_unit.ShStreamAry.shstream.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_unit::shstream_AbsReserve(atf_unit::ShStreamAry& parent, int n) {
    u32 old_max  = parent.shstream_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::malloc_ReallocMem(parent.shstream_elems, old_max * sizeof(atf_unit::ShStream), new_max * sizeof(atf_unit::ShStream));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("atf_unit.tary_nomem  field:atf_unit.ShStreamAry.shstream  comment:'out of memory'");
    }
    parent.shstream_elems = (atf_unit::ShStream*)new_mem;
    parent.shstream_max = new_max;
}

// --- atf_unit.ShStreamAry.shstream.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool atf_unit::shstream_XrefMaybe(atf_unit::ShStream &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_unit.ShStreamAry..Uninit
void atf_unit::ShStreamAry_Uninit(atf_unit::ShStreamAry& parent) {
    atf_unit::ShStreamAry &row = parent; (void)row;

    // atf_unit.ShStreamAry.shstream.Uninit (Tary)  //
    // remove all elements from atf_unit.ShStreamAry.shstream
    shstream_RemoveAll(parent);
    // free memory for Tary atf_unit.ShStreamAry.shstream
    algo_lib::malloc_FreeMem(parent.shstream_elems, sizeof(atf_unit::ShStream)*parent.shstream_max); // (atf_unit.ShStreamAry.shstream)
}

// --- atf_unit.TypeA..ReadStrptrMaybe
// Read fields of atf_unit::TypeA from an ascii string.
// The format of the string is the format of the atf_unit::TypeA's only field
bool atf_unit::TypeA_ReadStrptrMaybe(atf_unit::TypeA &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.typea, in_str);
    return retval;
}

// --- atf_unit.TypeA..Print
// print string representation of atf_unit::TypeA to string LHS, no header -- cprint:atf_unit.TypeA.String
void atf_unit::TypeA_Print(atf_unit::TypeA & row, algo::cstring &str) {
    i32_Print(row.typea, str);
}

// --- atf_unit.TypeA..FmtJson
// Create JSON representation of atf_unit::TypeA under PARENT node -- cprint:atf_unit.TypeA.Json
lib_json::FNode * atf_unit::TypeA_FmtJson(atf_unit::TypeA & row, lib_json::FNode *parent) {
    return i32_FmtJson(const_cast<atf_unit::TypeA&>(row).typea,parent);;
}

// --- atf_unit.TypeB..ReadFieldMaybe
bool atf_unit::TypeB_ReadFieldMaybe(atf_unit::TypeB &parent, algo::strptr field, algo::strptr strval) {
    atf_unit::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atf_unit_FieldId_typea: retval = i32_ReadStrptrMaybe(parent.typea, strval); break;
        case atf_unit_FieldId_j: retval = i32_ReadStrptrMaybe(parent.j, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_unit.TypeB..ReadStrptrMaybe
// Read fields of atf_unit::TypeB from an ascii string.
// The format of the string is an ssim Tuple
bool atf_unit::TypeB_ReadStrptrMaybe(atf_unit::TypeB &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_unit.TypeB");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TypeB_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_unit.TypeB..Print
// print string representation of atf_unit::TypeB to string LHS, no header -- cprint:atf_unit.TypeB.String
void atf_unit::TypeB_Print(atf_unit::TypeB & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.TypeB";

    i32_Print(row.typea, temp);
    PrintAttrSpaceReset(str,"typea", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_unit.TypeB..FmtJson
// Create JSON representation of atf_unit::TypeB under PARENT node -- cprint:atf_unit.TypeB.Json
lib_json::FNode * atf_unit::TypeB_FmtJson(atf_unit::TypeB & row, lib_json::FNode *parent) {
    lib_json::FNode *object_node = &lib_json::node_Alloc();
    object_node->p_parent = parent?parent:object_node;
    object_node->type   = lib_json_FNode_type_object;
    node_XrefMaybe(*object_node);

    lib_json::FNode *typea_field_node = &lib_json::node_Alloc();
    typea_field_node->p_parent = object_node;
    typea_field_node->type   = lib_json_FNode_type_field;
    typea_field_node->value  = "typea";
    node_XrefMaybe(*typea_field_node);
    i32_FmtJson(const_cast<atf_unit::TypeB&>(row).typea,typea_field_node);

    lib_json::FNode *j_field_node = &lib_json::node_Alloc();
    j_field_node->p_parent = object_node;
    j_field_node->type   = lib_json_FNode_type_field;
    j_field_node->value  = "j";
    node_XrefMaybe(*j_field_node);
    i32_FmtJson(const_cast<atf_unit::TypeB&>(row).j,j_field_node);
    return object_node;
}

// --- atf_unit.TestJson..Init
// Set all fields to initial values.
void atf_unit::TestJson_Init(atf_unit::TestJson& parent) {
    parent.fld_bool = bool(false);
    parent.fld_u8 = u8(0);
    parent.fld_i8 = i8(0);
    parent.fld_u16 = u16(0);
    parent.fld_i16 = i16(0);
    parent.fld_u32 = u32(0);
    parent.fld_i32 = i32(0);
    parent.fld_u64 = u64(0);
    parent.fld_i64 = i64(0);
    parent.fld_float = float(0.f);
    parent.fld_double = double(0.0);
    parent.fld_char = char(0);
}

// --- atf_unit.TestJson..Print
// print string representation of atf_unit::TestJson to string LHS, no header -- cprint:atf_unit.TestJson.String
void atf_unit::TestJson_Print(atf_unit::TestJson & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf_unit.TestJson";

    bool_Print(row.fld_bool, temp);
    PrintAttrSpaceReset(str,"fld_bool", temp);

    u8_Print(row.fld_u8, temp);
    PrintAttrSpaceReset(str,"fld_u8", temp);

    i8_Print(row.fld_i8, temp);
    PrintAttrSpaceReset(str,"fld_i8", temp);

    u16_Print(row.fld_u16, temp);
    PrintAttrSpaceReset(str,"fld_u16", temp);

    i16_Print(row.fld_i16, temp);
    PrintAttrSpaceReset(str,"fld_i16", temp);

    u32_Print(row.fld_u32, temp);
    PrintAttrSpaceReset(str,"fld_u32", temp);

    i32_Print(row.fld_i32, temp);
    PrintAttrSpaceReset(str,"fld_i32", temp);

    u64_Print(row.fld_u64, temp);
    PrintAttrSpaceReset(str,"fld_u64", temp);

    i64_Print(row.fld_i64, temp);
    PrintAttrSpaceReset(str,"fld_i64", temp);

    float_Print(row.fld_float, temp);
    PrintAttrSpaceReset(str,"fld_float", temp);

    double_Print(row.fld_double, temp);
    PrintAttrSpaceReset(str,"fld_double", temp);

    char_Print(row.fld_char, temp);
    PrintAttrSpaceReset(str,"fld_char", temp);

    algo::cstring_Print(row.fld_cstring, temp);
    PrintAttrSpaceReset(str,"fld_cstring", temp);

    atf_unit::TypeA_Print(row.fld_atftypea, temp);
    PrintAttrSpaceReset(str,"fld_atftypea", temp);

    atf_unit::Dbl_Print(row.fld_atfdbl, temp);
    PrintAttrSpaceReset(str,"fld_atfdbl", temp);

    atf_unit::TypeB_Print(row.fld_atftypeb, temp);
    PrintAttrSpaceReset(str,"fld_atftypeb", temp);
}

// --- atf_unit.TestJson..FmtJson
// Create JSON representation of atf_unit::TestJson under PARENT node -- cprint:atf_unit.TestJson.Json
lib_json::FNode * atf_unit::TestJson_FmtJson(atf_unit::TestJson & row, lib_json::FNode *parent) {
    lib_json::FNode *object_node = &lib_json::node_Alloc();
    object_node->p_parent = parent?parent:object_node;
    object_node->type   = lib_json_FNode_type_object;
    node_XrefMaybe(*object_node);

    lib_json::FNode *fld_bool_field_node = &lib_json::node_Alloc();
    fld_bool_field_node->p_parent = object_node;
    fld_bool_field_node->type   = lib_json_FNode_type_field;
    fld_bool_field_node->value  = "fld_bool";
    node_XrefMaybe(*fld_bool_field_node);
    bool_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_bool,fld_bool_field_node);

    lib_json::FNode *fld_u8_field_node = &lib_json::node_Alloc();
    fld_u8_field_node->p_parent = object_node;
    fld_u8_field_node->type   = lib_json_FNode_type_field;
    fld_u8_field_node->value  = "fld_u8";
    node_XrefMaybe(*fld_u8_field_node);
    u8_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_u8,fld_u8_field_node);

    lib_json::FNode *fld_i8_field_node = &lib_json::node_Alloc();
    fld_i8_field_node->p_parent = object_node;
    fld_i8_field_node->type   = lib_json_FNode_type_field;
    fld_i8_field_node->value  = "fld_i8";
    node_XrefMaybe(*fld_i8_field_node);
    i8_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_i8,fld_i8_field_node);

    lib_json::FNode *fld_u16_field_node = &lib_json::node_Alloc();
    fld_u16_field_node->p_parent = object_node;
    fld_u16_field_node->type   = lib_json_FNode_type_field;
    fld_u16_field_node->value  = "fld_u16";
    node_XrefMaybe(*fld_u16_field_node);
    u16_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_u16,fld_u16_field_node);

    lib_json::FNode *fld_i16_field_node = &lib_json::node_Alloc();
    fld_i16_field_node->p_parent = object_node;
    fld_i16_field_node->type   = lib_json_FNode_type_field;
    fld_i16_field_node->value  = "fld_i16";
    node_XrefMaybe(*fld_i16_field_node);
    i16_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_i16,fld_i16_field_node);

    lib_json::FNode *fld_u32_field_node = &lib_json::node_Alloc();
    fld_u32_field_node->p_parent = object_node;
    fld_u32_field_node->type   = lib_json_FNode_type_field;
    fld_u32_field_node->value  = "fld_u32";
    node_XrefMaybe(*fld_u32_field_node);
    u32_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_u32,fld_u32_field_node);

    lib_json::FNode *fld_i32_field_node = &lib_json::node_Alloc();
    fld_i32_field_node->p_parent = object_node;
    fld_i32_field_node->type   = lib_json_FNode_type_field;
    fld_i32_field_node->value  = "fld_i32";
    node_XrefMaybe(*fld_i32_field_node);
    i32_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_i32,fld_i32_field_node);

    lib_json::FNode *fld_u64_field_node = &lib_json::node_Alloc();
    fld_u64_field_node->p_parent = object_node;
    fld_u64_field_node->type   = lib_json_FNode_type_field;
    fld_u64_field_node->value  = "fld_u64";
    node_XrefMaybe(*fld_u64_field_node);
    u64_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_u64,fld_u64_field_node);

    lib_json::FNode *fld_i64_field_node = &lib_json::node_Alloc();
    fld_i64_field_node->p_parent = object_node;
    fld_i64_field_node->type   = lib_json_FNode_type_field;
    fld_i64_field_node->value  = "fld_i64";
    node_XrefMaybe(*fld_i64_field_node);
    i64_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_i64,fld_i64_field_node);

    lib_json::FNode *fld_float_field_node = &lib_json::node_Alloc();
    fld_float_field_node->p_parent = object_node;
    fld_float_field_node->type   = lib_json_FNode_type_field;
    fld_float_field_node->value  = "fld_float";
    node_XrefMaybe(*fld_float_field_node);
    float_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_float,fld_float_field_node);

    lib_json::FNode *fld_double_field_node = &lib_json::node_Alloc();
    fld_double_field_node->p_parent = object_node;
    fld_double_field_node->type   = lib_json_FNode_type_field;
    fld_double_field_node->value  = "fld_double";
    node_XrefMaybe(*fld_double_field_node);
    double_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_double,fld_double_field_node);

    lib_json::FNode *fld_char_field_node = &lib_json::node_Alloc();
    fld_char_field_node->p_parent = object_node;
    fld_char_field_node->type   = lib_json_FNode_type_field;
    fld_char_field_node->value  = "fld_char";
    node_XrefMaybe(*fld_char_field_node);
    char_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_char,fld_char_field_node);

    lib_json::FNode *fld_strptr_field_node = &lib_json::node_Alloc();
    fld_strptr_field_node->p_parent = object_node;
    fld_strptr_field_node->type   = lib_json_FNode_type_field;
    fld_strptr_field_node->value  = "fld_strptr";
    node_XrefMaybe(*fld_strptr_field_node);
    algo::strptr_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_strptr,fld_strptr_field_node);

    lib_json::FNode *fld_cstring_field_node = &lib_json::node_Alloc();
    fld_cstring_field_node->p_parent = object_node;
    fld_cstring_field_node->type   = lib_json_FNode_type_field;
    fld_cstring_field_node->value  = "fld_cstring";
    node_XrefMaybe(*fld_cstring_field_node);
    algo::cstring_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_cstring,fld_cstring_field_node);

    lib_json::FNode *fld_atftypea_field_node = &lib_json::node_Alloc();
    fld_atftypea_field_node->p_parent = object_node;
    fld_atftypea_field_node->type   = lib_json_FNode_type_field;
    fld_atftypea_field_node->value  = "fld_atftypea";
    node_XrefMaybe(*fld_atftypea_field_node);
    atf_unit::TypeA_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_atftypea,fld_atftypea_field_node);

    lib_json::FNode *fld_atfcstr_field_node = &lib_json::node_Alloc();
    fld_atfcstr_field_node->p_parent = object_node;
    fld_atfcstr_field_node->type   = lib_json_FNode_type_field;
    fld_atfcstr_field_node->value  = "fld_atfcstr";
    node_XrefMaybe(*fld_atfcstr_field_node);
    atf_unit::Cstr_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_atfcstr,fld_atfcstr_field_node);

    lib_json::FNode *fld_atfdbl_field_node = &lib_json::node_Alloc();
    fld_atfdbl_field_node->p_parent = object_node;
    fld_atfdbl_field_node->type   = lib_json_FNode_type_field;
    fld_atfdbl_field_node->value  = "fld_atfdbl";
    node_XrefMaybe(*fld_atfdbl_field_node);
    atf_unit::Dbl_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_atfdbl,fld_atfdbl_field_node);

    lib_json::FNode *fld_atftypeb_field_node = &lib_json::node_Alloc();
    fld_atftypeb_field_node->p_parent = object_node;
    fld_atftypeb_field_node->type   = lib_json_FNode_type_field;
    fld_atftypeb_field_node->value  = "fld_atftypeb";
    node_XrefMaybe(*fld_atftypeb_field_node);
    atf_unit::TypeB_FmtJson(const_cast<atf_unit::TestJson&>(row).fld_atftypeb,fld_atftypeb_field_node);
    return object_node;
}

// --- atf_unit...main
int main(int argc, char **argv) {
    try {
        algo_lib::FDb_Init();
        lib_exec::FDb_Init();
        lib_json::FDb_Init();
        lib_sql::FDb_Init();
        atf_unit::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::_db.epoll_fd = epoll_create(1);
        if (algo_lib::_db.epoll_fd == -1) {
            FatalErrorExit("epoll_create");
        }
        atf_unit::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:atf_unit
    } catch(algo_lib::ErrorX &x) {
        prerr("atf_unit.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        atf_unit::FDb_Uninit();
        lib_sql::FDb_Uninit();
        lib_json::FDb_Uninit();
        lib_exec::FDb_Uninit();
        algo_lib::FDb_Uninit();
    } catch(algo_lib::ErrorX &x) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    return algo_lib::_db.exit_code;
}

// --- atf_unit...SizeCheck
inline static void atf_unit::SizeCheck() {
}
