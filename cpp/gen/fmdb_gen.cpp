//
// cpp/gen/fmdb_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/fmdb_gen.h"
#include "include/gen/fmdb_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/fm_gen.h"
#include "include/gen/fm_gen.inl.h"
//#pragma endinclude
namespace fmdb { // gen:ns_print_proto
    // func:fmdb...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- fmdb.Alarm.code.Get
fm::Code fmdb::code_Get(fmdb::Alarm& parent) {
    fm::Code ret(algo::Pathcomp(parent.alarm, "@LL"));
    return ret;
}

// --- fmdb.Alarm.code.Get2
fm::Code fmdb::Alarm_code_Get(algo::strptr arg) {
    fm::Code ret(algo::Pathcomp(arg, "@LL"));
    return ret;
}

// --- fmdb.Alarm.object.Get
algo::Smallstr200 fmdb::object_Get(fmdb::Alarm& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.alarm, "@LR"));
    return ret;
}

// --- fmdb.Alarm.object.Get2
algo::Smallstr200 fmdb::Alarm_object_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, "@LR"));
    return ret;
}

// --- fmdb.Alarm.objtype.Get
fm::Objtype fmdb::objtype_Get(fmdb::Alarm& parent) {
    fm::Objtype ret(algo::Pathcomp(object_Get(parent), ".LL"));
    return ret;
}

// --- fmdb.Alarm.objtype.Get2
fm::Objtype fmdb::Alarm_objtype_Get(algo::strptr arg) {
    fm::Objtype ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- fmdb.Alarm.objinst.Get
fm::Objinst fmdb::objinst_Get(fmdb::Alarm& parent) {
    fm::Objinst ret(algo::Pathcomp(object_Get(parent), ".LR"));
    return ret;
}

// --- fmdb.Alarm.objinst.Get2
fm::Objinst fmdb::Alarm_objinst_Get(algo::strptr arg) {
    fm::Objinst ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- fmdb.Alarm.objprefix.Get
algo::Smallstr50 fmdb::objprefix_Get(fmdb::Alarm& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(objinst_Get(parent), ".LL"));
    return ret;
}

// --- fmdb.Alarm.objprefix.Get2
algo::Smallstr50 fmdb::Alarm_objprefix_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- fmdb.Alarm..Concat_code_object
tempstr fmdb::Alarm_Concat_code_object( const algo::strptr& code ,const algo::strptr& object ) {
    return tempstr() << code <<'@'<< object ;
}

// --- fmdb.Alarm..Concat_objtype_objinst
tempstr fmdb::Alarm_Concat_objtype_objinst( const algo::strptr& objtype ,const algo::strptr& objinst ) {
    return tempstr() << objtype <<'.'<< objinst ;
}

// --- fmdb.Alarm..ReadFieldMaybe
bool fmdb::Alarm_ReadFieldMaybe(fmdb::Alarm& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    fmdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case fmdb_FieldId_alarm: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.alarm, strval);
            break;
        }
        case fmdb_FieldId_code: {
            retval = false;
            break;
        }
        case fmdb_FieldId_object: {
            retval = false;
            break;
        }
        case fmdb_FieldId_objtype: {
            retval = false;
            break;
        }
        case fmdb_FieldId_objinst: {
            retval = false;
            break;
        }
        case fmdb_FieldId_objprefix: {
            retval = false;
            break;
        }
        case fmdb_FieldId_flag: {
            retval = fm::Flag_ReadStrptrMaybe(parent.flag, strval);
            break;
        }
        case fmdb_FieldId_severity: {
            retval = fm::Severity_ReadStrptrMaybe(parent.severity, strval);
            break;
        }
        case fmdb_FieldId_n_occurred: {
            retval = i32_ReadStrptrMaybe(parent.n_occurred, strval);
            break;
        }
        case fmdb_FieldId_first_time: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.first_time, strval);
            break;
        }
        case fmdb_FieldId_last_time: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.last_time, strval);
            break;
        }
        case fmdb_FieldId_clear_time: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.clear_time, strval);
            break;
        }
        case fmdb_FieldId_update_time: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.update_time, strval);
            break;
        }
        case fmdb_FieldId_objtype_summary: {
            retval = fm::Summary_ReadStrptrMaybe(parent.objtype_summary, strval);
            break;
        }
        case fmdb_FieldId_summary: {
            retval = fm::Summary_ReadStrptrMaybe(parent.summary, strval);
            break;
        }
        case fmdb_FieldId_description: {
            retval = fm::Description_ReadStrptrMaybe(parent.description, strval);
            break;
        }
        case fmdb_FieldId_source: {
            retval = fm::Source_ReadStrptrMaybe(parent.source, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- fmdb.Alarm..ReadStrptrMaybe
// Read fields of fmdb::Alarm from an ascii string.
// The format of the string is an ssim Tuple
bool fmdb::Alarm_ReadStrptrMaybe(fmdb::Alarm &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "fmdb.alarm") || algo::StripTypeTag(in_str, "fmdb.Alarm");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Alarm_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- fmdb.Alarm..Init
// Set all fields to initial values.
void fmdb::Alarm_Init(fmdb::Alarm& parent) {
    parent.n_occurred = i32(0);
}

// --- fmdb.Alarm..Print
// print string representation of ROW to string STR
// cfmt:fmdb.Alarm.String  printfmt:Tuple
void fmdb::Alarm_Print(fmdb::Alarm& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "fmdb.alarm";

    algo::Smallstr200_Print(row.alarm, temp);
    PrintAttrSpaceReset(str,"alarm", temp);

    fm::Flag_Print(row.flag, temp);
    PrintAttrSpaceReset(str,"flag", temp);

    fm::Severity_Print(row.severity, temp);
    PrintAttrSpaceReset(str,"severity", temp);

    i32_Print(row.n_occurred, temp);
    PrintAttrSpaceReset(str,"n_occurred", temp);

    algo::UnTime_Print(row.first_time, temp);
    PrintAttrSpaceReset(str,"first_time", temp);

    algo::UnTime_Print(row.last_time, temp);
    PrintAttrSpaceReset(str,"last_time", temp);

    algo::UnTime_Print(row.clear_time, temp);
    PrintAttrSpaceReset(str,"clear_time", temp);

    algo::UnTime_Print(row.update_time, temp);
    PrintAttrSpaceReset(str,"update_time", temp);

    fm::Summary_Print(row.objtype_summary, temp);
    PrintAttrSpaceReset(str,"objtype_summary", temp);

    fm::Summary_Print(row.summary, temp);
    PrintAttrSpaceReset(str,"summary", temp);

    fm::Description_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);

    fm::Source_Print(row.source, temp);
    PrintAttrSpaceReset(str,"source", temp);
}

// --- fmdb.AlmCode..ReadFieldMaybe
bool fmdb::AlmCode_ReadFieldMaybe(fmdb::AlmCode& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    fmdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case fmdb_FieldId_alm_code: {
            retval = fm::Code_ReadStrptrMaybe(parent.alm_code, strval);
            break;
        }
        case fmdb_FieldId_severity: {
            retval = fm::Severity_ReadStrptrMaybe(parent.severity, strval);
            break;
        }
        case fmdb_FieldId_source: {
            retval = fm::Source_ReadStrptrMaybe(parent.source, strval);
            break;
        }
        case fmdb_FieldId_summary: {
            retval = fm::Summary_ReadStrptrMaybe(parent.summary, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- fmdb.AlmCode..ReadStrptrMaybe
// Read fields of fmdb::AlmCode from an ascii string.
// The format of the string is an ssim Tuple
bool fmdb::AlmCode_ReadStrptrMaybe(fmdb::AlmCode &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "fmdb.alm_code") || algo::StripTypeTag(in_str, "fmdb.AlmCode");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && AlmCode_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- fmdb.AlmCode..Print
// print string representation of ROW to string STR
// cfmt:fmdb.AlmCode.String  printfmt:Tuple
void fmdb::AlmCode_Print(fmdb::AlmCode& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "fmdb.alm_code";

    fm::Code_Print(row.alm_code, temp);
    PrintAttrSpaceReset(str,"alm_code", temp);

    fm::Severity_Print(row.severity, temp);
    PrintAttrSpaceReset(str,"severity", temp);

    fm::Source_Print(row.source, temp);
    PrintAttrSpaceReset(str,"source", temp);

    fm::Summary_Print(row.summary, temp);
    PrintAttrSpaceReset(str,"summary", temp);
}

// --- fmdb.AlmObjtype..ReadFieldMaybe
bool fmdb::AlmObjtype_ReadFieldMaybe(fmdb::AlmObjtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    fmdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case fmdb_FieldId_alm_objtype: {
            retval = fm::Objtype_ReadStrptrMaybe(parent.alm_objtype, strval);
            break;
        }
        case fmdb_FieldId_summary: {
            retval = fm::Summary_ReadStrptrMaybe(parent.summary, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- fmdb.AlmObjtype..ReadStrptrMaybe
// Read fields of fmdb::AlmObjtype from an ascii string.
// The format of the string is an ssim Tuple
bool fmdb::AlmObjtype_ReadStrptrMaybe(fmdb::AlmObjtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "fmdb.alm_objtype") || algo::StripTypeTag(in_str, "fmdb.AlmObjtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && AlmObjtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- fmdb.AlmObjtype..Print
// print string representation of ROW to string STR
// cfmt:fmdb.AlmObjtype.String  printfmt:Tuple
void fmdb::AlmObjtype_Print(fmdb::AlmObjtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "fmdb.alm_objtype";

    fm::Objtype_Print(row.alm_objtype, temp);
    PrintAttrSpaceReset(str,"alm_objtype", temp);

    fm::Summary_Print(row.summary, temp);
    PrintAttrSpaceReset(str,"summary", temp);
}

// --- fmdb.AlmSource..ReadFieldMaybe
bool fmdb::AlmSource_ReadFieldMaybe(fmdb::AlmSource& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    fmdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case fmdb_FieldId_alm_source: {
            retval = fm::Source_ReadStrptrMaybe(parent.alm_source, strval);
            break;
        }
        case fmdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- fmdb.AlmSource..ReadStrptrMaybe
// Read fields of fmdb::AlmSource from an ascii string.
// The format of the string is an ssim Tuple
bool fmdb::AlmSource_ReadStrptrMaybe(fmdb::AlmSource &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "fmdb.alm_source") || algo::StripTypeTag(in_str, "fmdb.AlmSource");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && AlmSource_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- fmdb.AlmSource..Print
// print string representation of ROW to string STR
// cfmt:fmdb.AlmSource.String  printfmt:Tuple
void fmdb::AlmSource_Print(fmdb::AlmSource& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "fmdb.alm_source";

    fm::Source_Print(row.alm_source, temp);
    PrintAttrSpaceReset(str,"alm_source", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- fmdb.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* fmdb::value_ToCstr(const fmdb::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case fmdb_FieldId_alarm            : ret = "alarm";  break;
        case fmdb_FieldId_code             : ret = "code";  break;
        case fmdb_FieldId_object           : ret = "object";  break;
        case fmdb_FieldId_objtype          : ret = "objtype";  break;
        case fmdb_FieldId_objinst          : ret = "objinst";  break;
        case fmdb_FieldId_objprefix        : ret = "objprefix";  break;
        case fmdb_FieldId_flag             : ret = "flag";  break;
        case fmdb_FieldId_severity         : ret = "severity";  break;
        case fmdb_FieldId_n_occurred       : ret = "n_occurred";  break;
        case fmdb_FieldId_first_time       : ret = "first_time";  break;
        case fmdb_FieldId_last_time        : ret = "last_time";  break;
        case fmdb_FieldId_clear_time       : ret = "clear_time";  break;
        case fmdb_FieldId_update_time      : ret = "update_time";  break;
        case fmdb_FieldId_objtype_summary  : ret = "objtype_summary";  break;
        case fmdb_FieldId_summary          : ret = "summary";  break;
        case fmdb_FieldId_description      : ret = "description";  break;
        case fmdb_FieldId_source           : ret = "source";  break;
        case fmdb_FieldId_alm_code         : ret = "alm_code";  break;
        case fmdb_FieldId_alm_objtype      : ret = "alm_objtype";  break;
        case fmdb_FieldId_alm_source       : ret = "alm_source";  break;
        case fmdb_FieldId_comment          : ret = "comment";  break;
        case fmdb_FieldId_value            : ret = "value";  break;
    }
    return ret;
}

// --- fmdb.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void fmdb::value_Print(const fmdb::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- fmdb.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool fmdb::value_SetStrptrMaybe(fmdb::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,fmdb_FieldId_code); ret = true; break;
                }
                case LE_STR4('f','l','a','g'): {
                    value_SetEnum(parent,fmdb_FieldId_flag); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','l','a','r','m'): {
                    value_SetEnum(parent,fmdb_FieldId_alarm); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,fmdb_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('o','b','j','e','c','t'): {
                    value_SetEnum(parent,fmdb_FieldId_object); ret = true; break;
                }
                case LE_STR6('s','o','u','r','c','e'): {
                    value_SetEnum(parent,fmdb_FieldId_source); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,fmdb_FieldId_comment); ret = true; break;
                }
                case LE_STR7('o','b','j','i','n','s','t'): {
                    value_SetEnum(parent,fmdb_FieldId_objinst); ret = true; break;
                }
                case LE_STR7('o','b','j','t','y','p','e'): {
                    value_SetEnum(parent,fmdb_FieldId_objtype); ret = true; break;
                }
                case LE_STR7('s','u','m','m','a','r','y'): {
                    value_SetEnum(parent,fmdb_FieldId_summary); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','l','m','_','c','o','d','e'): {
                    value_SetEnum(parent,fmdb_FieldId_alm_code); ret = true; break;
                }
                case LE_STR8('s','e','v','e','r','i','t','y'): {
                    value_SetEnum(parent,fmdb_FieldId_severity); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('l','a','s','t','_','t','i','m'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,fmdb_FieldId_last_time); ret = true; break; }
                    break;
                }
                case LE_STR8('o','b','j','p','r','e','f','i'): {
                    if (memcmp(rhs.elems+8,"x",1)==0) { value_SetEnum(parent,fmdb_FieldId_objprefix); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','l','m','_','s','o','u','r'): {
                    if (memcmp(rhs.elems+8,"ce",2)==0) { value_SetEnum(parent,fmdb_FieldId_alm_source); ret = true; break; }
                    break;
                }
                case LE_STR8('c','l','e','a','r','_','t','i'): {
                    if (memcmp(rhs.elems+8,"me",2)==0) { value_SetEnum(parent,fmdb_FieldId_clear_time); ret = true; break; }
                    break;
                }
                case LE_STR8('f','i','r','s','t','_','t','i'): {
                    if (memcmp(rhs.elems+8,"me",2)==0) { value_SetEnum(parent,fmdb_FieldId_first_time); ret = true; break; }
                    break;
                }
                case LE_STR8('n','_','o','c','c','u','r','r'): {
                    if (memcmp(rhs.elems+8,"ed",2)==0) { value_SetEnum(parent,fmdb_FieldId_n_occurred); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','l','m','_','o','b','j','t'): {
                    if (memcmp(rhs.elems+8,"ype",3)==0) { value_SetEnum(parent,fmdb_FieldId_alm_objtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','s','c','r','i','p','t'): {
                    if (memcmp(rhs.elems+8,"ion",3)==0) { value_SetEnum(parent,fmdb_FieldId_description); ret = true; break; }
                    break;
                }
                case LE_STR8('u','p','d','a','t','e','_','t'): {
                    if (memcmp(rhs.elems+8,"ime",3)==0) { value_SetEnum(parent,fmdb_FieldId_update_time); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('o','b','j','t','y','p','e','_'): {
                    if (memcmp(rhs.elems+8,"summary",7)==0) { value_SetEnum(parent,fmdb_FieldId_objtype_summary); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- fmdb.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void fmdb::value_SetStrptr(fmdb::FieldId& parent, algo::strptr rhs, fmdb_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- fmdb.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool fmdb::value_ReadStrptrMaybe(fmdb::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- fmdb.FieldId..ReadStrptrMaybe
// Read fields of fmdb::FieldId from an ascii string.
// The format of the string is the format of the fmdb::FieldId's only field
bool fmdb::FieldId_ReadStrptrMaybe(fmdb::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- fmdb.FieldId..Print
// print string representation of ROW to string STR
// cfmt:fmdb.FieldId.String  printfmt:Raw
void fmdb::FieldId_Print(fmdb::FieldId& row, algo::cstring& str) {
    fmdb::value_Print(row, str);
}

// --- fmdb...SizeCheck
inline static void fmdb::SizeCheck() {
}
