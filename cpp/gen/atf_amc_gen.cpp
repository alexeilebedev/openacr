//
// cpp/gen/atf_amc_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/atf_amc_gen.h"
#include "include/gen/atf_amc_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/lib_exec_gen.h"
#include "include/gen/lib_exec_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
lib_exec::FDb   lib_exec::_db;    // dependency found via dev.targdep
atf_amc::FDb    atf_amc::_db;     // dependency found via dev.targdep

atf_amc::cascdel_bh_child_bheap_curs::~cascdel_bh_child_bheap_curs() {
    algo_lib::malloc_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

atf_amc::_db_bh_typec_curs::~_db_bh_typec_curs() {
    algo_lib::malloc_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

namespace atf_amc {
const char *atf_amc_help =
"atf_amc: Unit tests for amc (see amctest table)\n"
"Usage: atf_amc [[-amctest:]<regx>] [options]\n"
"    OPTION      TYPE    DFLT    COMMENT\n"
"    -in         string  \"data\"  Input directory or filename, - for stdin\n"
"    [amctest]   regx    \"%\"     SQL regex, selecting test to run\n"
"    -dofork             Y       Use fork\n"
"    -q                          Quiet mode\n"
"    -verbose    int             Verbosity level (0..255); alias -v; cumulative\n"
"    -debug      int             Debug level (0..255); alias -d; cumulative\n"
"    -help                       Print help and exit; alias -h\n"
"    -version                    Print version and exit\n"
"    -signature                  Show signatures and exit; alias -sig\n"
;


} // namespace atf_amc
atf_amc::typea_bh_typeb_curs::~typea_bh_typeb_curs() {
    algo_lib::malloc_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

namespace atf_amc { // gen:ns_gsymbol
    const char* atfdb_test_gsymbol_char_TestChar("TestChar");
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_gsymbol
    const atfdb::TestGsymbolPkeyPkey atfdb_test_gsymbol_pkey_TestPkey("TestPkey");
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_gsymbol
    const algo::strptr atfdb_test_gsymbol_strptr_TestStrptr("TestStrptr");
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_print_proto
    // func:atf_amc.BitfldType1.bit1.ReadStrptrMaybe
    static bool          bit1_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.BitfldType1.bits5.ReadStrptrMaybe
    static bool          bits5_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.BitfldType2.bit0.ReadStrptrMaybe
    static bool          bit0_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.BitfldType2.bit1.ReadStrptrMaybe
    static bool          bit1_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.Bytebuf.in.Shift
    static void          in_Shift(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.BytebufDyn.in.Shift
    static void          in_Shift(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
    // Extract next character from STR and advance IDX
    // func:atf_amc.Cstr.val.Nextchar
    static int           val_Nextchar(const atf_amc::Cstr& parent, algo::strptr &str, int &idx) __attribute__((nothrow));
    // func:atf_amc.DispFilter.strval.ReadStrptrMaybe
    static bool          strval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.strval_regx.ReadStrptrMaybe
    static bool          strval_regx_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.strval2.ReadStrptrMaybe
    static bool          strval2_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.strval2_regx.ReadStrptrMaybe
    static bool          strval2_regx_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.start_dateval.ReadStrptrMaybe
    static bool          start_dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.end_dateval.ReadStrptrMaybe
    static bool          end_dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.dateval.ReadStrptrMaybe
    static bool          dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.start_intval.ReadStrptrMaybe
    static bool          start_intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.end_intval.ReadStrptrMaybe
    static bool          end_intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.DispFilter.intval.ReadStrptrMaybe
    static bool          intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    // func:atf_amc.FCascdel.bh_child_bheap.Downheap
    static int           bh_child_bheap_Downheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    // func:atf_amc.FCascdel.bh_child_bheap.Upheap
    static int           bh_child_bheap_Upheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row, int idx) __attribute__((nothrow));
    // func:atf_amc.FCascdel.bh_child_bheap.ElemLt
    static bool          bh_child_bheap_ElemLt(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, atf_amc::FCascdel &b) __attribute__((nothrow));
    // func:atf_amc.FCascdel.bh_child_bheap.ElemLtval
    static bool          bh_child_bheap_ElemLtval(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, const u32 &b) __attribute__((nothrow));
    // func:atf_amc.FCascdel.bh_child_bheap_curs.Add
    static void          cascdel_bh_child_bheap_curs_Add(cascdel_bh_child_bheap_curs &curs, atf_amc::FCascdel& row);
    // Returns the child that has greater height.
    // func:atf_amc.FCascdel.tr_child_atree.TallerChild
    static atf_amc::FCascdel* tr_child_atree_TallerChild(atf_amc::FCascdel& node) __attribute__((nothrow));
    // Disconnects the subtree(branch) from the parent
    // func:atf_amc.FCascdel.tr_child_atree.Disconnect
    static void          tr_child_atree_Disconnect(atf_amc::FCascdel& node) __attribute__((nothrow));
    // func:atf_amc.FCascdel.tr_child_atree.ElemLt
    static bool          tr_child_atree_ElemLt(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, atf_amc::FCascdel &b) __attribute__((nothrow));
    // func:atf_amc.FCascdel.tr_child_atree.UpdateDepth
    static void          tr_child_atree_updateDepth(atf_amc::FCascdel& node) __attribute__((nothrow));
    // rotates the tree in from->to direction
    // func:atf_amc.FCascdel.tr_child_atree.Turn
    static void          tr_child_atree_Turn(atf_amc::FCascdel& from, atf_amc::FCascdel& to) __attribute__((nothrow));
    // func:atf_amc.FCascdel.tr_child_atree.Connect
    static void          tr_child_atree_Connect(atf_amc::FCascdel* parent, atf_amc::FCascdel* child, bool left) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    // func:atf_amc.FDb.bh_typec.Downheap
    static int           bh_typec_Downheap(atf_amc::FTypeC& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    // func:atf_amc.FDb.bh_typec.Upheap
    static int           bh_typec_Upheap(atf_amc::FTypeC& row, int idx) __attribute__((nothrow));
    // func:atf_amc.FDb.bh_typec.ElemLt
    static bool          bh_typec_ElemLt(atf_amc::FTypeC &a, atf_amc::FTypeC &b) __attribute__((nothrow));
    // func:atf_amc.FDb.bh_typec_curs.Add
    static void          _db_bh_typec_curs_Add(_db_bh_typec_curs &curs, atf_amc::FTypeC& row);
    // func:atf_amc.FDb.types.InputMaybe
    static bool          types_InputMaybe(atf_amc::TypeS &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    // func:atf_amc.FDb._db.InitReflection
    static void          InitReflection();
    // func:atf_amc.FDb.typet.InputMaybe
    static bool          typet_InputMaybe(atf_amc::TypeT &elem) __attribute__((nothrow));
    // First element of index changed.
    // func:atf_amc.FDb.cd_in_msg.FirstChanged
    static void          cd_in_msg_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    // func:atf_amc.FDb.cd_in_msg.UpdateCycles
    static void          cd_in_msg_UpdateCycles() __attribute__((nothrow));
    // func:atf_amc.FDb.cd_in_msg.Call
    static void          cd_in_msg_Call() __attribute__((nothrow));
    // func:atf_amc.FDb.amctest.LoadStatic
    static void          amctest_LoadStatic() __attribute__((nothrow));
    // Returns the child that has greater height.
    // func:atf_amc.FDb.tr_avl.TallerChild
    static atf_amc::FAvl* tr_avl_TallerChild(atf_amc::FAvl& node) __attribute__((nothrow));
    // Disconnects the subtree(branch) from the parent
    // func:atf_amc.FDb.tr_avl.Disconnect
    static void          tr_avl_Disconnect(atf_amc::FAvl& node) __attribute__((nothrow));
    // func:atf_amc.FDb.tr_avl.ElemLt
    static bool          tr_avl_ElemLt(atf_amc::FAvl &a, atf_amc::FAvl &b) __attribute__((nothrow));
    // func:atf_amc.FDb.tr_avl.UpdateDepth
    static void          tr_avl_updateDepth(atf_amc::FAvl& node) __attribute__((nothrow));
    // rotates the tree in from->to direction
    // func:atf_amc.FDb.tr_avl.Turn
    static void          tr_avl_Turn(atf_amc::FAvl& from, atf_amc::FAvl& to) __attribute__((nothrow));
    // func:atf_amc.FDb.tr_avl.Connect
    static void          tr_avl_Connect(atf_amc::FAvl* parent, atf_amc::FAvl* child, bool left) __attribute__((nothrow));
    // func:atf_amc.FDb.listtype.LoadStatic
    static void          listtype_LoadStatic() __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    // func:atf_amc.FDb.trace.RowidFind
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    // func:atf_amc.FDb.trace.N
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Swap values elem_a and elem_b
    // func:atf_amc.FPerfSortString.sorted1.Swap
    static void          sorted1_Swap(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    // func:atf_amc.FPerfSortString.sorted1.Rotleft
    static void          sorted1_Rotleft(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b, atf_amc::Cstr &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    // func:atf_amc.FPerfSortString.sorted1.Lt
    static bool          sorted1_Lt(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    // func:atf_amc.FPerfSortString.sorted1.IntInsertionSort
    static void          sorted1_IntInsertionSort(atf_amc::Cstr *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    // func:atf_amc.FPerfSortString.sorted1.IntHeapSort
    static void          sorted1_IntHeapSort(atf_amc::Cstr *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    // func:atf_amc.FPerfSortString.sorted1.IntQuickSort
    static void          sorted1_IntQuickSort(atf_amc::Cstr *elems, int n, int depth) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    // func:atf_amc.FTypeA.bh_typeb.Downheap
    static int           bh_typeb_Downheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    // func:atf_amc.FTypeA.bh_typeb.Upheap
    static int           bh_typeb_Upheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row, int idx) __attribute__((nothrow));
    // func:atf_amc.FTypeA.bh_typeb.ElemLt
    static bool          bh_typeb_ElemLt(atf_amc::FTypeA& typea, atf_amc::FTypeB &a, atf_amc::FTypeB &b) __attribute__((nothrow));
    // func:atf_amc.FTypeA.bh_typeb_curs.Add
    static void          typea_bh_typeb_curs_Add(typea_bh_typeb_curs &curs, atf_amc::FTypeB& row);
    // Swap values elem_a and elem_b
    // func:atf_amc.FUnitSort.tary.Swap
    static void          tary_Swap(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    // func:atf_amc.FUnitSort.tary.Rotleft
    static void          tary_Rotleft(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b, atf_amc::TypeA &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    // func:atf_amc.FUnitSort.tary.Lt
    static bool          tary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    // func:atf_amc.FUnitSort.tary.IntInsertionSort
    static void          tary_IntInsertionSort(atf_amc::TypeA *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    // func:atf_amc.FUnitSort.tary.IntHeapSort
    static void          tary_IntHeapSort(atf_amc::TypeA *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    // func:atf_amc.FUnitSort.tary.IntQuickSort
    static void          tary_IntQuickSort(atf_amc::TypeA *elems, int n, int depth) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    // func:atf_amc.FUnitSort.c_ptrary.Swap
    static void          c_ptrary_Swap(atf_amc::TypeA* &elem_a, atf_amc::TypeA* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    // func:atf_amc.FUnitSort.c_ptrary.Rotleft
    static void          c_ptrary_Rotleft(atf_amc::TypeA* &elem_a, atf_amc::TypeA* &elem_b, atf_amc::TypeA* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    // func:atf_amc.FUnitSort.c_ptrary.Lt
    static bool          c_ptrary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    // func:atf_amc.FUnitSort.c_ptrary.IntInsertionSort
    static void          c_ptrary_IntInsertionSort(atf_amc::TypeA* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    // func:atf_amc.FUnitSort.c_ptrary.IntHeapSort
    static void          c_ptrary_IntHeapSort(atf_amc::TypeA* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    // func:atf_amc.FUnitSort.c_ptrary.IntQuickSort
    static void          c_ptrary_IntQuickSort(atf_amc::TypeA* *elems, int n, int depth) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    // func:atf_amc.FUnitSort.fixary.Swap
    static void          fixary_Swap(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    // func:atf_amc.FUnitSort.fixary.Rotleft
    static void          fixary_Rotleft(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b, atf_amc::TypeA &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    // func:atf_amc.FUnitSort.fixary.Lt
    static bool          fixary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    // func:atf_amc.FUnitSort.fixary.IntInsertionSort
    static void          fixary_IntInsertionSort(atf_amc::TypeA *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    // func:atf_amc.FUnitSort.fixary.IntHeapSort
    static void          fixary_IntHeapSort(atf_amc::TypeA *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    // func:atf_amc.FUnitSort.fixary.IntQuickSort
    static void          fixary_IntQuickSort(atf_amc::TypeA *elems, int n, int depth) __attribute__((nothrow));
    // Internal function to scan for a message
    //
    // func:atf_amc.Linebuf.in.Scanmsg
    static void          in_Scanmsg(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.Linebuf.in.Shift
    static void          in_Shift(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
    // Internal function to scan for a message
    //
    // func:atf_amc.Msgbuf.in.Scanmsg
    static void          in_Scanmsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.Msgbuf.in.Shift
    static void          in_Shift(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.Msgbuf.out_extra.Shift
    static void          out_extra_Shift(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
    // Internal function to scan for a message
    //
    // func:atf_amc.Msgbuf.in_extra.Scanmsg
    static void          in_extra_Scanmsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    // func:atf_amc.Msgbuf.in_extra.Shift
    static void          in_extra_Shift(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value1.ReadStrptrMaybe
    static bool          value1_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value2.ReadStrptrMaybe
    static bool          value2_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value3.ReadStrptrMaybe
    static bool          value3_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value4.ReadStrptrMaybe
    static bool          value4_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value5.ReadStrptrMaybe
    static bool          value5_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value6.ReadStrptrMaybe
    static bool          value6_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskMultiple.value7.ReadStrptrMaybe
    static bool          value7_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value.ReadStrptrMaybe
    static bool          value_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value2.ReadStrptrMaybe
    static bool          value2_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value3.ReadStrptrMaybe
    static bool          value3_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value21.ReadStrptrMaybe
    static bool          value21_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value22.ReadStrptrMaybe
    static bool          value22_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value23.ReadStrptrMaybe
    static bool          value23_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value24.ReadStrptrMaybe
    static bool          value24_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value25.ReadStrptrMaybe
    static bool          value25_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value26.ReadStrptrMaybe
    static bool          value26_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value20.ReadStrptrMaybe
    static bool          value20_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value28.ReadStrptrMaybe
    static bool          value28_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value29.ReadStrptrMaybe
    static bool          value29_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value30.ReadStrptrMaybe
    static bool          value30_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value31.ReadStrptrMaybe
    static bool          value31_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value32.ReadStrptrMaybe
    static bool          value32_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value27.ReadStrptrMaybe
    static bool          value27_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value19.ReadStrptrMaybe
    static bool          value19_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value18.ReadStrptrMaybe
    static bool          value18_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value4.ReadStrptrMaybe
    static bool          value4_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value5.ReadStrptrMaybe
    static bool          value5_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value6.ReadStrptrMaybe
    static bool          value6_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value7.ReadStrptrMaybe
    static bool          value7_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value8.ReadStrptrMaybe
    static bool          value8_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value9.ReadStrptrMaybe
    static bool          value9_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value69.ReadStrptrMaybe
    static bool          value69_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value11.ReadStrptrMaybe
    static bool          value11_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value12.ReadStrptrMaybe
    static bool          value12_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value13.ReadStrptrMaybe
    static bool          value13_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value14.ReadStrptrMaybe
    static bool          value14_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value15.ReadStrptrMaybe
    static bool          value15_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value16.ReadStrptrMaybe
    static bool          value16_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value33.ReadStrptrMaybe
    static bool          value33_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value10.ReadStrptrMaybe
    static bool          value10_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value17.ReadStrptrMaybe
    static bool          value17_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value35.ReadStrptrMaybe
    static bool          value35_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value55.ReadStrptrMaybe
    static bool          value55_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value56.ReadStrptrMaybe
    static bool          value56_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value57.ReadStrptrMaybe
    static bool          value57_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value58.ReadStrptrMaybe
    static bool          value58_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value59.ReadStrptrMaybe
    static bool          value59_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value60.ReadStrptrMaybe
    static bool          value60_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value54.ReadStrptrMaybe
    static bool          value54_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value62.ReadStrptrMaybe
    static bool          value62_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value63.ReadStrptrMaybe
    static bool          value63_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value64.ReadStrptrMaybe
    static bool          value64_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value65.ReadStrptrMaybe
    static bool          value65_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value66.ReadStrptrMaybe
    static bool          value66_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value67.ReadStrptrMaybe
    static bool          value67_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value68.ReadStrptrMaybe
    static bool          value68_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value61.ReadStrptrMaybe
    static bool          value61_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value34.ReadStrptrMaybe
    static bool          value34_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value52.ReadStrptrMaybe
    static bool          value52_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value36.ReadStrptrMaybe
    static bool          value36_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value37.ReadStrptrMaybe
    static bool          value37_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value38.ReadStrptrMaybe
    static bool          value38_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value39.ReadStrptrMaybe
    static bool          value39_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value40.ReadStrptrMaybe
    static bool          value40_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value41.ReadStrptrMaybe
    static bool          value41_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value42.ReadStrptrMaybe
    static bool          value42_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value53.ReadStrptrMaybe
    static bool          value53_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value44.ReadStrptrMaybe
    static bool          value44_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value45.ReadStrptrMaybe
    static bool          value45_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value46.ReadStrptrMaybe
    static bool          value46_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value47.ReadStrptrMaybe
    static bool          value47_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value48.ReadStrptrMaybe
    static bool          value48_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value49.ReadStrptrMaybe
    static bool          value49_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value50.ReadStrptrMaybe
    static bool          value50_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value51.ReadStrptrMaybe
    static bool          value51_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value43.ReadStrptrMaybe
    static bool          value43_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value70.ReadStrptrMaybe
    static bool          value70_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU128.value71.ReadStrptrMaybe
    static bool          value71_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU32.value.ReadStrptrMaybe
    static bool          value_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU32.value2.ReadStrptrMaybe
    static bool          value2_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU32.value3.ReadStrptrMaybe
    static bool          value3_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU32.value4.ReadStrptrMaybe
    static bool          value4_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:atf_amc.PmaskU32.value5.ReadStrptrMaybe
    static bool          value5_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
    // Extract next character from STR and advance IDX
    // func:atf_amc.SortedStr.novs.Nextchar
    static int           novs_Nextchar(const atf_amc::SortedStr& parent, algo::strptr &str, int &idx) __attribute__((nothrow));
    // Extract next character from STR and advance IDX
    // func:atf_amc.SortedStr.vs.Nextchar
    static u64           vs_Nextchar(const atf_amc::SortedStr& parent, algo::strptr &str, int &idx) __attribute__((nothrow));
    // func:atf_amc.TypeBE64.value.ReadStrptrMaybe
    static bool          value_ReadStrptrMaybe(atf_amc::TypeBE64 &parent, algo::strptr in_str) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    // func:atf_amc.VarlenH.typeh.Swap
    static void          typeh_Swap(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    // func:atf_amc.VarlenH.typeh.Rotleft
    static void          typeh_Rotleft(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b, atf_amc::TypeH &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    // func:atf_amc.VarlenH.typeh.Lt
    static bool          typeh_Lt(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    // func:atf_amc.VarlenH.typeh.IntInsertionSort
    static void          typeh_IntInsertionSort(atf_amc::TypeH *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    // func:atf_amc.VarlenH.typeh.IntHeapSort
    static void          typeh_IntHeapSort(atf_amc::TypeH *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    // func:atf_amc.VarlenH.typeh.IntQuickSort
    static void          typeh_IntQuickSort(atf_amc::TypeH *elems, int n, int depth) __attribute__((nothrow));
    // func:atf_amc...SizeCheck
    static void          SizeCheck();
} // gen:ns_print_proto

// --- atf_amc.AmcCleanup2..Uninit
void atf_amc::AmcCleanup2_Uninit(atf_amc::AmcCleanup2& parent) {
    atf_amc::AmcCleanup2 &row = parent; (void)row;
    field2_Cleanup(parent); // dmmeta.fcleanup:atf_amc.AmcCleanup2.field2
    field1_Cleanup(parent); // dmmeta.fcleanup:atf_amc.AmcCleanup2.field1
}

// --- atf_amc.AmcSubstr1.boolval.Get
bool atf_amc::boolval_Get(atf_amc::AmcSubstr1& parent) {
    bool ret;
    ret = false; // default value
    (void)bool_ReadStrptrMaybe(ret, algo::Pathcomp(parent.strval, ".LR"));
    return ret;
}

// --- atf_amc.AmcSubstr1.intval.Get
i32 atf_amc::intval_Get(atf_amc::AmcSubstr1& parent) {
    i32 ret;
    ret = 0; // default value
    (void)i32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.strval, ".LR"));
    return ret;
}

// --- atf_amc.BitfldType1.bit1.ReadStrptrMaybe
inline static bool atf_amc::bit1_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) {
    bool retval = true;
    u64 bit1_tmp;
    retval = u64_ReadStrptrMaybe(bit1_tmp, in_str);
    if (retval) {
        bit1_Set(parent, bit1_tmp);
    }
    return retval;
}

// --- atf_amc.BitfldType1.bits5.ReadStrptrMaybe
inline static bool atf_amc::bits5_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) {
    bool retval = true;
    u64 bits5_tmp;
    retval = u64_ReadStrptrMaybe(bits5_tmp, in_str);
    if (retval) {
        bits5_Set(parent, bits5_tmp);
    }
    return retval;
}

// --- atf_amc.BitfldType1..ReadFieldMaybe
bool atf_amc::BitfldType1_ReadFieldMaybe(atf_amc::BitfldType1& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = u64_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case atf_amc_FieldId_bit1: {
            retval = bit1_ReadStrptrMaybe(parent, strval);
            break;
        }
        case atf_amc_FieldId_bits5: {
            retval = bits5_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.BitfldType1..ReadStrptrMaybe
// Read fields of atf_amc::BitfldType1 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::BitfldType1_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.BitfldType1");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && BitfldType1_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.BitfldType1..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.BitfldType1.String  printfmt:Tuple
void atf_amc::BitfldType1_Print(atf_amc::BitfldType1& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.BitfldType1";

    u64_Print(bit1_Get(row), temp);
    PrintAttrSpaceReset(str,"bit1", temp);

    u64_Print(bits5_Get(row), temp);
    PrintAttrSpaceReset(str,"bits5", temp);
}

// --- atf_amc.BitfldType2.bit0.ReadStrptrMaybe
inline static bool atf_amc::bit0_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) {
    bool retval = true;
    bool bit0_tmp;
    retval = bool_ReadStrptrMaybe(bit0_tmp, in_str);
    if (retval) {
        bit0_Set(parent, bit0_tmp);
    }
    return retval;
}

// --- atf_amc.BitfldType2.bit1.ReadStrptrMaybe
inline static bool atf_amc::bit1_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) {
    bool retval = true;
    bool bit1_tmp;
    retval = bool_ReadStrptrMaybe(bit1_tmp, in_str);
    if (retval) {
        bit1_Set(parent, bit1_tmp);
    }
    return retval;
}

// --- atf_amc.BitfldType2..ReadFieldMaybe
bool atf_amc::BitfldType2_ReadFieldMaybe(atf_amc::BitfldType2& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = u64_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case atf_amc_FieldId_bit0: {
            retval = bit0_ReadStrptrMaybe(parent, strval);
            break;
        }
        case atf_amc_FieldId_bit1: {
            retval = bit1_ReadStrptrMaybe(parent, strval);
            break;
        }
        case atf_amc_FieldId_freebool: {
            retval = bool_ReadStrptrMaybe(parent.freebool, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.BitfldType2..ReadStrptrMaybe
// Read fields of atf_amc::BitfldType2 from an ascii string.
bool atf_amc::BitfldType2_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    bit0_Set(parent, false);
    bit1_Set(parent, false);
    parent.freebool = false;
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            atf_amc::FieldId field_id;
            bool ok = atf_amc::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case atf_amc_FieldId_bit0: {
                        bit0_Set(parent, true);
                    } break;
                    case atf_amc_FieldId_bit1: {
                        bit1_Set(parent, true);
                    } break;
                    case atf_amc_FieldId_freebool: {
                        parent.freebool = true;
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- atf_amc.BitfldType2..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.BitfldType2.String  printfmt:Bitset
void atf_amc::BitfldType2_Print(atf_amc::BitfldType2& row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (bit0_Get(row)) {
        str << ls << "bit0";
    }
    if (bit1_Get(row)) {
        str << ls << "bit1";
    }
    if (row.freebool) {
        str << ls << "freebool";
    }
}

// --- atf_amc.Bitset.fld1.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::fld1_ReadStrptrMaybe(atf_amc::Bitset& parent, algo::strptr in_str) {
    bool retval = true;
    if (4>0) {
        retval = u16_ReadStrptrMaybe(parent.fld1_elems[0], in_str);
    }
    return retval;
}

// --- atf_amc.Bitset.fld1_bitcurs.Next
// proceed to next item
void atf_amc::Bitset_fld1_bitcurs_Next(Bitset_fld1_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 16;
    int offset = curs.bit % 16;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 16 + offset;
}

// --- atf_amc.Bitset.fld8_bitcurs.Next
// proceed to next item
void atf_amc::Bitset_fld8_bitcurs_Next(Bitset_fld8_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 8;
    int offset = curs.bit % 8;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 8 + offset;
}

// --- atf_amc.Bitset.fld64_bitcurs.Next
// proceed to next item
void atf_amc::Bitset_fld64_bitcurs_Next(Bitset_fld64_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 64;
    int offset = curs.bit % 64;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 64 + offset;
}

// --- atf_amc.Bytebuf.in.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is any number of bytes > 0
// 
algo::aryptr<char> atf_amc::in_GetMsg(atf_amc::Bytebuf& bytebuf) {
    algo::aryptr<char> ret;
    if (in_N(bytebuf) == 0) {
    }
    char *hdr = (char*)(bytebuf.in_elems + bytebuf.in_start);
    if (in_N(bytebuf)) {
        ret.elems = hdr; // if no elements, return value is NULL
        ret.n_elems = in_N(bytebuf);
    }
    return ret;
}

// --- atf_amc.Bytebuf.in.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::in_RemoveAll(atf_amc::Bytebuf& bytebuf) {
    bytebuf.in_start    = 0;
    bytebuf.in_end      = 0;
}

// --- atf_amc.Bytebuf.in.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::in_Shift(atf_amc::Bytebuf& bytebuf) {
    i32 start = bytebuf.in_start;
    i32 bytes_n = bytebuf.in_end - start;
    if (bytes_n > 0) {
        memmove(bytebuf.in_elems, bytebuf.in_elems + start, bytes_n);
    }
    bytebuf.in_end = bytes_n;
    bytebuf.in_start = 0;
}

// --- atf_amc.Bytebuf.in.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void atf_amc::in_SkipBytes(atf_amc::Bytebuf& bytebuf, int n) {
    int avail = bytebuf.in_end - bytebuf.in_start;
    n = i32_Min(n,avail);
    bytebuf.in_start += n;
}

// --- atf_amc.Bytebuf.in.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::in_WriteAll(atf_amc::Bytebuf& bytebuf, u8 *in, i32 in_n) {
    int max = in_Max(bytebuf);
    // check if message doesn't fit. if so, shift bytes over.
    if (bytebuf.in_end + in_n > max) {
        in_Shift(bytebuf);
    }
    // now try to write the message.
    i32 end = bytebuf.in_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(bytebuf.in_elems + end, in, in_n);
        bytebuf.in_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.Bytebuf..Init
// Set all fields to initial values.
void atf_amc::Bytebuf_Init(atf_amc::Bytebuf& bytebuf) {
    bytebuf.in_end = 0; // in: initialize
    bytebuf.in_start = 0; // in: initialize
    bytebuf.in_eof = false; // in: initialize
    bytebuf.in_epoll_enable = true; // in: initialize
}

// --- atf_amc.Bytebuf..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Bytebuf.String  printfmt:Raw
void atf_amc::Bytebuf_Print(atf_amc::Bytebuf& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- atf_amc.BytebufDyn.in.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is any number of bytes > 0
// 
algo::aryptr<char> atf_amc::in_GetMsg(atf_amc::BytebufDyn& bytebuf_dyn) {
    algo::aryptr<char> ret;
    if (in_N(bytebuf_dyn) == 0) {
    }
    char *hdr = (char*)(bytebuf_dyn.in_elems + bytebuf_dyn.in_start);
    if (in_N(bytebuf_dyn)) {
        ret.elems = hdr; // if no elements, return value is NULL
        ret.n_elems = in_N(bytebuf_dyn);
    }
    return ret;
}

// --- atf_amc.BytebufDyn.in.Realloc
// Set buffer size.
// Unconditionally reallocate buffer to have size NEW_MAX
// If the buffer has data in it, NEW_MAX is adjusted so that the data is not lost
// (best to call this before filling the buffer)
void atf_amc::in_Realloc(atf_amc::BytebufDyn& bytebuf_dyn, int new_max) {
    new_max = i32_Max(new_max, bytebuf_dyn.in_end);
    u8 *new_mem = bytebuf_dyn.in_elems
    ? (u8*)algo_lib::malloc_ReallocMem(bytebuf_dyn.in_elems, bytebuf_dyn.in_max, new_max)
    : (u8*)algo_lib::malloc_AllocMem(new_max);
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("atf_amc.fbuf_nomem  field:atf_amc.BytebufDyn.in  comment:'out of memory'");
    }
    bytebuf_dyn.in_elems = new_mem;
    bytebuf_dyn.in_max = new_max;
}

// --- atf_amc.BytebufDyn.in.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::in_RemoveAll(atf_amc::BytebufDyn& bytebuf_dyn) {
    bytebuf_dyn.in_start    = 0;
    bytebuf_dyn.in_end      = 0;
}

// --- atf_amc.BytebufDyn.in.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::in_Shift(atf_amc::BytebufDyn& bytebuf_dyn) {
    i32 start = bytebuf_dyn.in_start;
    i32 bytes_n = bytebuf_dyn.in_end - start;
    if (bytes_n > 0) {
        memmove(bytebuf_dyn.in_elems, bytebuf_dyn.in_elems + start, bytes_n);
    }
    bytebuf_dyn.in_end = bytes_n;
    bytebuf_dyn.in_start = 0;
}

// --- atf_amc.BytebufDyn.in.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void atf_amc::in_SkipBytes(atf_amc::BytebufDyn& bytebuf_dyn, int n) {
    int avail = bytebuf_dyn.in_end - bytebuf_dyn.in_start;
    n = i32_Min(n,avail);
    bytebuf_dyn.in_start += n;
}

// --- atf_amc.BytebufDyn.in.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::in_WriteAll(atf_amc::BytebufDyn& bytebuf_dyn, u8 *in, i32 in_n) {
    int max = in_Max(bytebuf_dyn);
    // check if message doesn't fit. if so, shift bytes over.
    if (bytebuf_dyn.in_end + in_n > max) {
        in_Shift(bytebuf_dyn);
    }
    // now try to write the message.
    i32 end = bytebuf_dyn.in_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(bytebuf_dyn.in_elems + end, in, in_n);
        bytebuf_dyn.in_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.BytebufDyn..Init
// Set all fields to initial values.
void atf_amc::BytebufDyn_Init(atf_amc::BytebufDyn& bytebuf_dyn) {
    bytebuf_dyn.in_elems = NULL; // in: initialize
    bytebuf_dyn.in_max = 0; // in: initialize
    bytebuf_dyn.in_end = 0; // in: initialize
    bytebuf_dyn.in_start = 0; // in: initialize
    bytebuf_dyn.in_eof = false; // in: initialize
    bytebuf_dyn.in_epoll_enable = true; // in: initialize
}

// --- atf_amc.BytebufDyn..Uninit
void atf_amc::BytebufDyn_Uninit(atf_amc::BytebufDyn& bytebuf_dyn) {
    atf_amc::BytebufDyn &row = bytebuf_dyn; (void)row;

    // atf_amc.BytebufDyn.in.Uninit (Fbuf)  //Streaming buffer
    if (bytebuf_dyn.in_elems) {
        algo_lib::malloc_FreeMem(bytebuf_dyn.in_elems, sizeof(char)*bytebuf_dyn.in_max); // (atf_amc.BytebufDyn.in)
    }
    bytebuf_dyn.in_elems = NULL;
    bytebuf_dyn.in_max = 0;
}

// --- atf_amc.BytebufDyn..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.BytebufDyn.String  printfmt:Raw
void atf_amc::BytebufDyn_Print(atf_amc::BytebufDyn& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- atf_amc.Cstr.val.Nextchar
// Extract next character from STR and advance IDX
inline static int atf_amc::val_Nextchar(const atf_amc::Cstr& parent, algo::strptr &str, int &idx) {
    (void)parent;
    int i = idx;
    int ch = str.elems[i];
    i++;
    idx = i;
    return ch;
}

// --- atf_amc.Cstr..FmtJson
// Create JSON representation of atf_amc::Cstr under PARENT node
// cfmt:atf_amc.Cstr.Json  printfmt:Auto
lib_json::FNode * atf_amc::Cstr_FmtJson(atf_amc::Cstr& row, lib_json::FNode *parent) {
    return algo::cstring_FmtJson(const_cast<atf_amc::Cstr&>(row).val,parent);;
}

// --- atf_amc.Ctype1Attr..ReadStrptrMaybe
// Read fields of atf_amc::Ctype1Attr from an ascii string.
// The format of the string is the format of the atf_amc::Ctype1Attr's only field
bool atf_amc::Ctype1Attr_ReadStrptrMaybe(atf_amc::Ctype1Attr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u32_ReadStrptrMaybe(parent.attr1, in_str);
    return retval;
}

// --- atf_amc.Ctype1Attr..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype1Attr.String  printfmt:Raw
void atf_amc::Ctype1Attr_Print(atf_amc::Ctype1Attr& row, algo::cstring& str) {
    u32_Print(row.attr1, str);
}

// --- atf_amc.Ctype2Attr..ReadFieldMaybe
bool atf_amc::Ctype2Attr_ReadFieldMaybe(atf_amc::Ctype2Attr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_attr1: {
            retval = u32_ReadStrptrMaybe(parent.attr1, strval);
            break;
        }
        case atf_amc_FieldId_attr2: {
            retval = u32_ReadStrptrMaybe(parent.attr2, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Ctype2Attr..ReadStrptrMaybe
// Read fields of atf_amc::Ctype2Attr from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::Ctype2Attr_ReadStrptrMaybe(atf_amc::Ctype2Attr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.Ctype2Attr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Ctype2Attr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.Ctype2Attr..ReadTupleMaybe
// Read fields of atf_amc::Ctype2Attr from attributes of ascii tuple TUPLE
bool atf_amc::Ctype2Attr_ReadTupleMaybe(atf_amc::Ctype2Attr &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = Ctype2Attr_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.Ctype2Attr..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype2Attr.String  printfmt:Tuple
void atf_amc::Ctype2Attr_Print(atf_amc::Ctype2Attr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.Ctype2Attr";

    u32_Print(row.attr1, temp);
    PrintAttrSpaceReset(str,"attr1", temp);

    u32_Print(row.attr2, temp);
    PrintAttrSpaceReset(str,"attr2", temp);
}

// --- atf_amc.Ctype2AttrAnon..ReadFieldMaybe
bool atf_amc::Ctype2AttrAnon_ReadFieldMaybe(atf_amc::Ctype2AttrAnon& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_attr1: {
            retval = u32_ReadStrptrMaybe(parent.attr1, strval);
            break;
        }
        case atf_amc_FieldId_attr2: {
            retval = u32_ReadStrptrMaybe(parent.attr2, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Ctype2AttrAnon..ReadStrptrMaybe
// Read fields of atf_amc::Ctype2AttrAnon from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::Ctype2AttrAnon_ReadStrptrMaybe(atf_amc::Ctype2AttrAnon &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.Ctype2AttrAnon");
    int anon_idx = 0;
    ind_beg(algo::Attr_curs, attr, in_str) {
        if (ch_N(attr.name) == 0) {
            attr.name = Ctype2AttrAnon_GetAnon(parent, anon_idx++);
        }
        retval = retval && Ctype2AttrAnon_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.Ctype2AttrAnon..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype2AttrAnon.String  printfmt:Tuple
void atf_amc::Ctype2AttrAnon_Print(atf_amc::Ctype2AttrAnon& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.Ctype2AttrAnon";

    u32_Print(row.attr1, temp);
    PrintAttrSpaceReset(str,"attr1", temp);

    u32_Print(row.attr2, temp);
    PrintAttrSpaceReset(str,"attr2", temp);
}

// --- atf_amc.Ctype2AttrAnon..GetAnon
algo::strptr atf_amc::Ctype2AttrAnon_GetAnon(atf_amc::Ctype2AttrAnon &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("attr1", 5);
        case(1): return strptr("attr2", 5);
        default: return algo::strptr();
    }
}

// --- atf_amc.DelType1.u32val.Access
// Get or Create
// Access value, creating it if necessary. Process dies if not successful.
u32& atf_amc::u32val_Access(atf_amc::DelType1& parent) {
    u32 *ret=parent.u32val;
    if (!ret) {
        ret = (u32*)algo_lib::malloc_AllocMem(sizeof(u32));
        if (!ret) {
            FatalErrorExit("out of memory allocating u32 (in atf_amc::DelType1.u32val)");
        }
        new(ret) u32(34);
        parent.u32val = ret;
    }
    return *ret;
}

// --- atf_amc.DelType1.u32val.Delete
// Delete value.
void atf_amc::u32val_Delete(atf_amc::DelType1& parent) {
    if (parent.u32val) {
        algo_lib::malloc_FreeMem(parent.u32val, sizeof(u32));
        parent.u32val = NULL;
    }
}

// --- atf_amc.DelType1..Uninit
void atf_amc::DelType1_Uninit(atf_amc::DelType1& parent) {
    atf_amc::DelType1 &row = parent; (void)row;

    // atf_amc.DelType1.u32val.Uninit (Delptr)  //
    u32val_Delete(parent);
}

// --- atf_amc.DispCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::DispCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_DispCase_atf_amc_DispType1: ret = "atf_amc.DispType1";  break;
        case atf_amc_DispCase_atf_amc_DispType2: ret = "atf_amc.DispType2";  break;
        case atf_amc_DispCase_atf_amc_DispType3: ret = "atf_amc.DispType3";  break;
    }
    return ret;
}

// --- atf_amc.DispCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::DispCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.DispCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"DispType1",9)==0) { value_SetEnum(parent,atf_amc_DispCase_atf_amc_DispType1); ret = true; break; }
                    if (memcmp(rhs.elems+8,"DispType2",9)==0) { value_SetEnum(parent,atf_amc_DispCase_atf_amc_DispType2); ret = true; break; }
                    if (memcmp(rhs.elems+8,"DispType3",9)==0) { value_SetEnum(parent,atf_amc_DispCase_atf_amc_DispType3); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.DispCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::DispCase& parent, algo::strptr rhs, atf_amc_DispCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.DispCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.DispCase..ReadStrptrMaybe
// Read fields of atf_amc::DispCase from an ascii string.
// The format of the string is the format of the atf_amc::DispCase's only field
bool atf_amc::DispCase_ReadStrptrMaybe(atf_amc::DispCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.DispFilter.pmask.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::pmask_ReadStrptrMaybe(atf_amc::DispFilter& parent, algo::strptr in_str) {
    bool retval = true;
    if (1>0) {
        retval = u64_ReadStrptrMaybe(parent.pmask_elems[0], in_str);
    }
    return retval;
}

// --- atf_amc.DispFilter.strval.ReadStrptrMaybe
inline static bool atf_amc::strval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    algo::Smallstr20 strval_tmp;
    retval = algo::Smallstr20_ReadStrptrMaybe(strval_tmp, in_str);
    if (retval) {
        strval_Set(parent, strval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.strval_regx.ReadStrptrMaybe
inline static bool atf_amc::strval_regx_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo_lib::Regx_ReadStrptrMaybe(parent.strval_regx, in_str);
    strval_regx_SetPresent(parent);
    return retval;
}

// --- atf_amc.DispFilter.strval2.ReadStrptrMaybe
inline static bool atf_amc::strval2_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    algo::Smallstr20 strval2_tmp;
    retval = algo::Smallstr20_ReadStrptrMaybe(strval2_tmp, in_str);
    if (retval) {
        strval2_Set(parent, strval2_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.strval2_regx.ReadStrptrMaybe
inline static bool atf_amc::strval2_regx_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo_lib::Regx_ReadStrptrMaybe(parent.strval2_regx, in_str);
    strval2_regx_SetPresent(parent);
    return retval;
}

// --- atf_amc.DispFilter.start_dateval.ReadStrptrMaybe
inline static bool atf_amc::start_dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    algo::UnTime start_dateval_tmp;
    retval = algo::UnTime_ReadStrptrMaybe(start_dateval_tmp, in_str);
    if (retval) {
        start_dateval_Set(parent, start_dateval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.end_dateval.ReadStrptrMaybe
inline static bool atf_amc::end_dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    algo::UnTime end_dateval_tmp;
    retval = algo::UnTime_ReadStrptrMaybe(end_dateval_tmp, in_str);
    if (retval) {
        end_dateval_Set(parent, end_dateval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.dateval.ReadStrptrMaybe
inline static bool atf_amc::dateval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    algo::UnTime dateval_tmp;
    retval = algo::UnTime_ReadStrptrMaybe(dateval_tmp, in_str);
    if (retval) {
        dateval_Set(parent, dateval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.start_intval.ReadStrptrMaybe
inline static bool atf_amc::start_intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    u32 start_intval_tmp;
    retval = u32_ReadStrptrMaybe(start_intval_tmp, in_str);
    if (retval) {
        start_intval_Set(parent, start_intval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.end_intval.ReadStrptrMaybe
inline static bool atf_amc::end_intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    u32 end_intval_tmp;
    retval = u32_ReadStrptrMaybe(end_intval_tmp, in_str);
    if (retval) {
        end_intval_Set(parent, end_intval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.intval.ReadStrptrMaybe
inline static bool atf_amc::intval_ReadStrptrMaybe(atf_amc::DispFilter &parent, algo::strptr in_str) {
    bool retval = true;
    u32 intval_tmp;
    retval = u32_ReadStrptrMaybe(intval_tmp, in_str);
    if (retval) {
        intval_Set(parent, intval_tmp);
    }
    return retval;
}

// --- atf_amc.DispFilter.pmask_bitcurs.Next
// proceed to next item
void atf_amc::DispFilter_pmask_bitcurs_Next(DispFilter_pmask_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 64;
    int offset = curs.bit % 64;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 64 + offset;
}

// --- atf_amc.DispFilter..ReadFieldMaybe
bool atf_amc::DispFilter_ReadFieldMaybe(atf_amc::DispFilter& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_pmask: {
            retval = pmask_ReadStrptrMaybe(parent, strval);
            break;
        }
        case atf_amc_FieldId_strval: {
            retval = strval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 0);
            }
            break;
        }
        case atf_amc_FieldId_strval_regx: {
            retval = strval_regx_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 1);
            }
            break;
        }
        case atf_amc_FieldId_strval2: {
            retval = strval2_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 2);
            }
            break;
        }
        case atf_amc_FieldId_strval2_regx: {
            retval = strval2_regx_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 3);
            }
            break;
        }
        case atf_amc_FieldId_start_dateval: {
            retval = start_dateval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 4);
            }
            break;
        }
        case atf_amc_FieldId_end_dateval: {
            retval = end_dateval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 5);
            }
            break;
        }
        case atf_amc_FieldId_dateval: {
            retval = dateval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 6);
            }
            break;
        }
        case atf_amc_FieldId_start_intval: {
            retval = start_intval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 7);
            }
            break;
        }
        case atf_amc_FieldId_end_intval: {
            retval = end_intval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 8);
            }
            break;
        }
        case atf_amc_FieldId_intval: {
            retval = intval_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 9);
            }
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.DispFilter..ReadTupleMaybe
// Read fields of atf_amc::DispFilter from attributes of ascii tuple TUPLE
bool atf_amc::DispFilter_ReadTupleMaybe(atf_amc::DispFilter &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = DispFilter_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.DispFilter..Init
// Set all fields to initial values.
void atf_amc::DispFilter_Init(atf_amc::DispFilter& parent) {
    for (int i = 0; i < 1; i++) {
        parent.pmask_elems[i] = 0;
    }
    parent.start_intval = u32(0);
    parent.end_intval = u32(0);
    parent.intval = u32(0);
}

// --- atf_amc.DispFilter..MatchDispType1
bool atf_amc::DispFilter_MatchDispType1(atf_amc::DispFilter &parent, atf_amc::DispType1 &msg) {
    bool ret = true;
    tempstr fieldstr;
    if (strval_PresentQ(parent) && !(msg.strval == parent.strval)) {
        return false;
    }
    if (strval_regx_PresentQ(parent)) {
        ch_RemoveAll(fieldstr);
        Smallstr20_Print(msg.strval, fieldstr);
        if (!algo_lib::Regx_Match(parent.strval_regx, fieldstr)) {
            return false;
        }
    }
    if (strval2_PresentQ(parent) && !(msg.strval2 == parent.strval2)) {
        return false;
    }
    if (strval2_regx_PresentQ(parent)) {
        ch_RemoveAll(fieldstr);
        Smallstr20_Print(msg.strval2, fieldstr);
        if (!algo_lib::Regx_Match(parent.strval2_regx, fieldstr)) {
            return false;
        }
    }
    if (dateval_PresentQ(parent) && !(msg.dateval == parent.dateval)) {
        return false;
    }
    if (start_dateval_PresentQ(parent) && msg.dateval < parent.start_dateval) {
        return false;
    }
    if (end_dateval_PresentQ(parent) && parent.end_dateval < msg.dateval) {
        return false;
    }
    return ret;
}

// --- atf_amc.DispFilter..MatchDispType2
bool atf_amc::DispFilter_MatchDispType2(atf_amc::DispFilter &parent, atf_amc::DispType2 &msg) {
    bool ret = true;
    tempstr fieldstr;
    if (intval_PresentQ(parent) && !(msg.intval == parent.intval)) {
        return false;
    }
    if (start_intval_PresentQ(parent) && msg.intval < parent.start_intval) {
        return false;
    }
    if (end_intval_PresentQ(parent) && parent.end_intval < msg.intval) {
        return false;
    }
    return ret;
}

// --- atf_amc.DispFilter..MatchDispType3
bool atf_amc::DispFilter_MatchDispType3(atf_amc::DispFilter &parent, atf_amc::DispType3 &msg) {
    bool ret = true;
    tempstr fieldstr;
    if (intval_PresentQ(parent) && !(msg.intval == parent.intval)) {
        return false;
    }
    if (start_intval_PresentQ(parent) && msg.intval < parent.start_intval) {
        return false;
    }
    if (end_intval_PresentQ(parent) && parent.end_intval < msg.intval) {
        return false;
    }
    if (strval_PresentQ(parent) && !(msg.strval == parent.strval)) {
        return false;
    }
    if (strval_regx_PresentQ(parent)) {
        ch_RemoveAll(fieldstr);
        Smallstr20_Print(msg.strval, fieldstr);
        if (!algo_lib::Regx_Match(parent.strval_regx, fieldstr)) {
            return false;
        }
    }
    return ret;
}

// --- atf_amc.DispType1..ReadFieldMaybe
bool atf_amc::DispType1_ReadFieldMaybe(atf_amc::DispType1& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_strval: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.strval, strval);
            break;
        }
        case atf_amc_FieldId_strval2: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.strval2, strval);
            break;
        }
        case atf_amc_FieldId_dateval: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.dateval, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.DispType1..ReadStrptrMaybe
// Read fields of atf_amc::DispType1 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::DispType1_ReadStrptrMaybe(atf_amc::DispType1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.DispType1");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DispType1_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.DispType1..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType1.String  printfmt:Tuple
void atf_amc::DispType1_Print(atf_amc::DispType1& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.DispType1";

    algo::Smallstr20_Print(row.strval, temp);
    PrintAttrSpaceReset(str,"strval", temp);

    algo::Smallstr20_Print(row.strval2, temp);
    PrintAttrSpaceReset(str,"strval2", temp);

    algo::UnTime_Print(row.dateval, temp);
    PrintAttrSpaceReset(str,"dateval", temp);
}

// --- atf_amc.DispType2..ReadStrptrMaybe
// Read fields of atf_amc::DispType2 from an ascii string.
// The format of the string is the format of the atf_amc::DispType2's only field
bool atf_amc::DispType2_ReadStrptrMaybe(atf_amc::DispType2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u32_ReadStrptrMaybe(parent.intval, in_str);
    return retval;
}

// --- atf_amc.DispType2..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType2.String  printfmt:Raw
void atf_amc::DispType2_Print(atf_amc::DispType2& row, algo::cstring& str) {
    u32_Print(row.intval, str);
}

// --- atf_amc.DispType3..ReadFieldMaybe
bool atf_amc::DispType3_ReadFieldMaybe(atf_amc::DispType3& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_intval: {
            retval = u32_ReadStrptrMaybe(parent.intval, strval);
            break;
        }
        case atf_amc_FieldId_strval: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.strval, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.DispType3..ReadStrptrMaybe
// Read fields of atf_amc::DispType3 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::DispType3_ReadStrptrMaybe(atf_amc::DispType3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.DispType3");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DispType3_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.DispType3..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType3.String  printfmt:Tuple
void atf_amc::DispType3_Print(atf_amc::DispType3& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.DispType3";

    u32_Print(row.intval, temp);
    PrintAttrSpaceReset(str,"intval", temp);

    algo::Smallstr20_Print(row.strval, temp);
    PrintAttrSpaceReset(str,"strval", temp);
}

// --- atf_amc.FAmctest.msghdr.CopyOut
// Copy fields out of row
void atf_amc::amctest_CopyOut(atf_amc::FAmctest &row, atfdb::Amctest &out) {
    out.amctest = row.amctest;
    out.comment = row.comment;
}

// --- atf_amc.FAmctest.msghdr.CopyIn
// Copy fields in to row
void atf_amc::amctest_CopyIn(atf_amc::FAmctest &row, atfdb::Amctest &in) {
    row.amctest = in.amctest;
    row.comment = in.comment;
}

// --- atf_amc.FAmctest..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FAmctest.String  printfmt:Tuple
void atf_amc::FAmctest_Print(atf_amc::FAmctest& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FAmctest";

    algo::Smallstr50_Print(row.amctest, temp);
    PrintAttrSpaceReset(str,"amctest", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);

    bool_Print(row.success, temp);
    PrintAttrSpaceReset(str,"success", temp);

    u64_PrintHex(u64(row.c_syscmd), temp, 8, true);
    PrintAttrSpaceReset(str,"c_syscmd", temp);
}

// --- atf_amc.FAvl..Uninit
void atf_amc::FAvl_Uninit(atf_amc::FAvl& avl) {
    atf_amc::FAvl &row = avl; (void)row;
    tr_avl_Remove(row); // remove avl from index tr_avl
}

// --- atf_amc.FCascdel.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::type_ToCstr(const atf_amc::FCascdel& cascdel) {
    const char *ret = NULL;
    switch(type_GetEnum(cascdel)) {
        case atf_amc_FCascdel_type_none    : ret = "none";  break;
        case atf_amc_FCascdel_type_ptr     : ret = "ptr";  break;
        case atf_amc_FCascdel_type_ptrary  : ret = "ptrary";  break;
        case atf_amc_FCascdel_type_thash   : ret = "thash";  break;
        case atf_amc_FCascdel_type_bheap   : ret = "bheap";  break;
        case atf_amc_FCascdel_type_zdlist  : ret = "zdlist";  break;
    }
    return ret;
}

// --- atf_amc.FCascdel.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void atf_amc::type_Print(const atf_amc::FCascdel& cascdel, algo::cstring &lhs) {
    const char *strval = type_ToCstr(cascdel);
    if (strval) {
        lhs << strval;
    } else {
        lhs << cascdel.type;
    }
}

// --- atf_amc.FCascdel.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::type_SetStrptrMaybe(atf_amc::FCascdel& cascdel, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('p','t','r'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_ptr); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('n','o','n','e'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_none); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','t','r','e','e'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_atree); ret = true; break;
                }
                case LE_STR5('b','h','e','a','p'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_bheap); ret = true; break;
                }
                case LE_STR5('t','h','a','s','h'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_thash); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('p','t','r','a','r','y'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_ptrary); ret = true; break;
                }
                case LE_STR6('z','d','l','i','s','t'): {
                    type_SetEnum(cascdel,atf_amc_FCascdel_type_zdlist); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.FCascdel.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::type_SetStrptr(atf_amc::FCascdel& cascdel, algo::strptr rhs, atf_amc_FCascdel_type_Enum dflt) {
    if (!type_SetStrptrMaybe(cascdel,rhs)) type_SetEnum(cascdel,dflt);
}

// --- atf_amc.FCascdel.child_ptr.Cascdel
// Delete referred-to items.
// Deleted pointed-to item.
void atf_amc::child_ptr_Cascdel(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *ptr = cascdel.child_ptr;
    if (ptr) {
        cascdel_Delete(*ptr);
        cascdel.child_ptr = NULL;
    }
}

// --- atf_amc.FCascdel.c_child_ptrary.Cascdel
// Delete all elements pointed to by the index.
void atf_amc::c_child_ptrary_Cascdel(atf_amc::FCascdel& cascdel) {
    // Clear c_child_ptrary_n so that calls to atf_amc.FCascdel.c_child_ptrary.Remove do not have to scan
    // the array for pointers or shift anything.
    // This is somewhat of a hack.
    i32 n = cascdel.c_child_ptrary_n;
    cascdel.c_child_ptrary_n = 0;
    for (i32 i = n - 1; i >= 0; i--) {
        atf_amc::FCascdel &row = *cascdel.c_child_ptrary_elems[i];
        row.cascdel_c_child_ptrary_in_ary = false;
        cascdel_Delete(row);
    }
}

// --- atf_amc.FCascdel.c_child_ptrary.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void atf_amc::c_child_ptrary_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (bool_Update(row.cascdel_c_child_ptrary_in_ary,true)) {
        // reserve space
        c_child_ptrary_Reserve(cascdel, 1);
        u32 n  = cascdel.c_child_ptrary_n;
        u32 at = n;
        atf_amc::FCascdel* *elems = cascdel.c_child_ptrary_elems;
        elems[at] = &row;
        cascdel.c_child_ptrary_n = n+1;

    }
}

// --- atf_amc.FCascdel.c_child_ptrary.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool atf_amc::c_child_ptrary_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    bool retval = !row.cascdel_c_child_ptrary_in_ary;
    c_child_ptrary_Insert(cascdel,row); // check is performed in _Insert again
    return retval;
}

// --- atf_amc.FCascdel.c_child_ptrary.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void atf_amc::c_child_ptrary_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (bool_Update(row.cascdel_c_child_ptrary_in_ary,false)) {
        int lim = cascdel.c_child_ptrary_n;
        atf_amc::FCascdel* *elems = cascdel.c_child_ptrary_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            atf_amc::FCascdel* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(atf_amc::FCascdel*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                cascdel.c_child_ptrary_n = lim - 1;
                break;
            }
        }
    }
}

// --- atf_amc.FCascdel.c_child_ptrary.Reserve
// Reserve space in index for N more elements;
void atf_amc::c_child_ptrary_Reserve(atf_amc::FCascdel& cascdel, u32 n) {
    u32 old_max = cascdel.c_child_ptrary_max;
    if (UNLIKELY(cascdel.c_child_ptrary_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::FCascdel*);
        u32 new_size = new_max * sizeof(atf_amc::FCascdel*);
        void *new_mem = algo_lib::malloc_ReallocMem(cascdel.c_child_ptrary_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FCascdel.c_child_ptrary");
        }
        cascdel.c_child_ptrary_elems = (atf_amc::FCascdel**)new_mem;
        cascdel.c_child_ptrary_max = new_max;
    }
}

// --- atf_amc.FCascdel.ind_child_thash.Cascdel
// Delete all rows reachable through the hash index
void atf_amc::ind_child_thash_Cascdel(atf_amc::FCascdel& cascdel) {
    if (cascdel.ind_child_thash_n) {
        for (int i = 0; i < cascdel.ind_child_thash_buckets_n; i++) {
            atf_amc::FCascdel *elem = cascdel.ind_child_thash_buckets_elems[i];
            while (elem) {
                atf_amc::FCascdel *next = elem->ind_child_thash_next;
                cascdel_Delete(*elem);
                elem = next;
            }
        }
    }
}

// --- atf_amc.FCascdel.ind_child_thash.Find
// Find row by key. Return NULL if not found.
atf_amc::FCascdel* atf_amc::ind_child_thash_Find(atf_amc::FCascdel& cascdel, u32 key) {
    u32 index = ::u32_Hash(0, key) & (cascdel.ind_child_thash_buckets_n - 1);
    atf_amc::FCascdel* *e = &cascdel.ind_child_thash_buckets_elems[index];
    atf_amc::FCascdel* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).key == key;
        if (done) break;
        e         = &ret->ind_child_thash_next;
    } while (true);
    return ret;
}

// --- atf_amc.FCascdel.ind_child_thash.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_amc::ind_child_thash_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    ind_child_thash_Reserve(cascdel, 1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_child_thash_next == (atf_amc::FCascdel*)-1)) {// check if in hash already
        u32 index = ::u32_Hash(0, row.key) & (cascdel.ind_child_thash_buckets_n - 1);
        atf_amc::FCascdel* *prev = &cascdel.ind_child_thash_buckets_elems[index];
        do {
            atf_amc::FCascdel* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).key == row.key) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_child_thash_next;
        } while (true);
        if (retval) {
            row.ind_child_thash_next = *prev;
            cascdel.ind_child_thash_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_amc.FCascdel.ind_child_thash.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_amc::ind_child_thash_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (LIKELY(row.ind_child_thash_next != (atf_amc::FCascdel*)-1)) {// check if in hash already
        u32 index = ::u32_Hash(0, row.key) & (cascdel.ind_child_thash_buckets_n - 1);
        atf_amc::FCascdel* *prev = &cascdel.ind_child_thash_buckets_elems[index]; // addr of pointer to current element
        while (atf_amc::FCascdel *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_child_thash_next; // unlink (singly linked list)
                cascdel.ind_child_thash_n--;
                row.ind_child_thash_next = (atf_amc::FCascdel*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_child_thash_next;
        }
    }
}

// --- atf_amc.FCascdel.ind_child_thash.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_amc::ind_child_thash_Reserve(atf_amc::FCascdel& cascdel, int n) {
    u32 old_nbuckets = cascdel.ind_child_thash_buckets_n;
    u32 new_nelems   = cascdel.ind_child_thash_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_amc::FCascdel*);
        u32 new_size = new_nbuckets * sizeof(atf_amc::FCascdel*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_amc::FCascdel* *new_buckets = (atf_amc::FCascdel**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FCascdel.ind_child_thash");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < cascdel.ind_child_thash_buckets_n; i++) {
            atf_amc::FCascdel* elem = cascdel.ind_child_thash_buckets_elems[i];
            while (elem) {
                atf_amc::FCascdel &row        = *elem;
                atf_amc::FCascdel* next       = row.ind_child_thash_next;
                u32 index          = ::u32_Hash(0, row.key) & (new_nbuckets-1);
                row.ind_child_thash_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(cascdel.ind_child_thash_buckets_elems, old_size);
        cascdel.ind_child_thash_buckets_elems = new_buckets;
        cascdel.ind_child_thash_buckets_n = new_nbuckets;
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.Cascdel
// Delete referred-to items.
// Delete all elements referenced by the heap.
void atf_amc::bh_child_bheap_Cascdel(atf_amc::FCascdel& cascdel) {
    i32 n = cascdel.bh_child_bheap_n;
    while (n > 0) {
        n--;
        atf_amc::FCascdel &elem = *cascdel.bh_child_bheap_elems[n]; // pick cheapest element to remove
        elem.bh_child_bheap_idx = -1; // mark not-in-heap
        cascdel.bh_child_bheap_n = n;
        cascdel_Delete(elem);
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.Dealloc
// Remove all elements from heap and free memory used by the array.
void atf_amc::bh_child_bheap_Dealloc(atf_amc::FCascdel& cascdel) {
    bh_child_bheap_RemoveAll(cascdel);
    algo_lib::malloc_FreeMem(cascdel.bh_child_bheap_elems, sizeof(atf_amc::FCascdel*)*cascdel.bh_child_bheap_max);
    cascdel.bh_child_bheap_max   = 0;
    cascdel.bh_child_bheap_elems = NULL;
}

// --- atf_amc.FCascdel.bh_child_bheap.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int atf_amc::bh_child_bheap_Downheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row, int idx) {
    atf_amc::FCascdel* *elems = cascdel.bh_child_bheap_elems;
    int n = cascdel.bh_child_bheap_n;
    int child = idx*2+1;
    while (child < n) {
        atf_amc::FCascdel* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            atf_amc::FCascdel* q = elems[rchild]; // right child
            if (bh_child_bheap_ElemLt(cascdel, *q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_child_bheap_ElemLt(cascdel, *p,row)) {
            break;
        }
        p->bh_child_bheap_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- atf_amc.FCascdel.bh_child_bheap.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void atf_amc::bh_child_bheap_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (LIKELY(row.bh_child_bheap_idx == -1)) {
        bh_child_bheap_Reserve(cascdel, 1);
        int n = cascdel.bh_child_bheap_n;
        cascdel.bh_child_bheap_n = n + 1;
        int new_idx = bh_child_bheap_Upheap(cascdel, row, n);
        row.bh_child_bheap_idx = new_idx;
        cascdel.bh_child_bheap_elems[new_idx] = &row;
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 atf_amc::bh_child_bheap_Reheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    int old_idx = row.bh_child_bheap_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_child_bheap_Reserve(cascdel, 1);
        old_idx = cascdel.bh_child_bheap_n++;
    }
    int new_idx = bh_child_bheap_Upheap(cascdel, row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_child_bheap_Downheap(cascdel, row, old_idx);
    }
    row.bh_child_bheap_idx = new_idx;
    cascdel.bh_child_bheap_elems[new_idx] = &row;
    return new_idx;
}

// --- atf_amc.FCascdel.bh_child_bheap.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 atf_amc::bh_child_bheap_ReheapFirst(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel &row = *cascdel.bh_child_bheap_elems[0];
    i32 new_idx = bh_child_bheap_Downheap(cascdel, row, 0);
    row.bh_child_bheap_idx = new_idx;
    cascdel.bh_child_bheap_elems[new_idx] = &row;
    return new_idx;
}

// --- atf_amc.FCascdel.bh_child_bheap.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::bh_child_bheap_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (bh_child_bheap_InBheapQ(row)) {
        int old_idx = row.bh_child_bheap_idx;
        if (cascdel.bh_child_bheap_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_child_bheap_idx = -1;           // mark not in heap
            i32 n = cascdel.bh_child_bheap_n - 1; // index of last element in heap
            cascdel.bh_child_bheap_n = n;         // decrease count
            if (old_idx != n) {
                atf_amc::FCascdel *elem = cascdel.bh_child_bheap_elems[n];
                int new_idx = bh_child_bheap_Upheap(cascdel, *elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_child_bheap_Downheap(cascdel, *elem, old_idx);
                }
                elem->bh_child_bheap_idx = new_idx;
                cascdel.bh_child_bheap_elems[new_idx] = elem;
            }
        }
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.RemoveAll
// Remove all elements from binary heap
void atf_amc::bh_child_bheap_RemoveAll(atf_amc::FCascdel& cascdel) {
    int n = cascdel.bh_child_bheap_n;
    for (int i = n - 1; i>=0; i--) {
        cascdel.bh_child_bheap_elems[i]->bh_child_bheap_idx = -1; // mark not-in-heap
    }
    cascdel.bh_child_bheap_n = 0;
}

// --- atf_amc.FCascdel.bh_child_bheap.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FCascdel* atf_amc::bh_child_bheap_RemoveFirst(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    if (cascdel.bh_child_bheap_n > 0) {
        row = cascdel.bh_child_bheap_elems[0];
        row->bh_child_bheap_idx = -1;           // mark not in heap
        i32 n = cascdel.bh_child_bheap_n - 1; // index of last element in heap
        cascdel.bh_child_bheap_n = n;         // decrease count
        if (n) {
            atf_amc::FCascdel &elem = *cascdel.bh_child_bheap_elems[n];
            int new_idx = bh_child_bheap_Downheap(cascdel, elem, 0);
            elem.bh_child_bheap_idx = new_idx;
            cascdel.bh_child_bheap_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- atf_amc.FCascdel.bh_child_bheap.Reserve
// Reserve space in index for N more elements
void atf_amc::bh_child_bheap_Reserve(atf_amc::FCascdel& cascdel, int n) {
    i32 old_max = cascdel.bh_child_bheap_max;
    if (UNLIKELY(cascdel.bh_child_bheap_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::FCascdel*);
        u32 new_size = new_max * sizeof(atf_amc::FCascdel*);
        void *new_mem = algo_lib::malloc_ReallocMem(cascdel.bh_child_bheap_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FCascdel.bh_child_bheap");
        }
        cascdel.bh_child_bheap_elems = (atf_amc::FCascdel**)new_mem;
        cascdel.bh_child_bheap_max = new_max;
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.Set
// Set row key to new value.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
void atf_amc::key_Set(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) {
    row.key = new_key;
    bool ins = row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap; // user-defined insert condition (xref)
    if (ins) {
        bh_child_bheap_Reheap(cascdel, row);
    } else {
        bh_child_bheap_Remove(cascdel, row);
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.SetIfBetter
// Set row key to new value. If row not in heap, the key is set to new value
// Otherwise, the key is changed only if the new key is better than the old.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
void atf_amc::key_SetIfBetter(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) {
    bool better = true;
    if (bh_child_bheap_InBheapQ(row)) {
        better = !bh_child_bheap_ElemLtval(cascdel, row,new_key); // this is really Not Worse, not Better
    }
    if (better) {
        key_Set(cascdel, row, new_key);
    }
}

// --- atf_amc.FCascdel.bh_child_bheap.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int atf_amc::bh_child_bheap_Upheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row, int idx) {
    atf_amc::FCascdel* *elems = cascdel.bh_child_bheap_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        atf_amc::FCascdel* p = elems[j];
        if (!bh_child_bheap_ElemLt(cascdel, row, *p)) {
            break;
        }
        p->bh_child_bheap_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- atf_amc.FCascdel.bh_child_bheap.ElemLt
inline static bool atf_amc::bh_child_bheap_ElemLt(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, atf_amc::FCascdel &b) {
    (void)cascdel;
    return a.key < b.key;
}

// --- atf_amc.FCascdel.bh_child_bheap.ElemLtval
inline static bool atf_amc::bh_child_bheap_ElemLtval(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, const u32 &b) {
    (void)cascdel;
    return a.key < (u32&)b;
}

// --- atf_amc.FCascdel.zd_childlist.Cascdel
// Delete all elements in the linked list.
void atf_amc::zd_childlist_Cascdel(atf_amc::FCascdel& cascdel) {
    while (atf_amc::FCascdel *zd_childlist_first = zd_childlist_First(cascdel)) {
        cascdel_Delete(*zd_childlist_first);
    }
}

// --- atf_amc.FCascdel.zd_childlist.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zd_childlist_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (!zd_childlist_InLlistQ(row)) {
        atf_amc::FCascdel* old_tail = cascdel.zd_childlist_tail;
        row.zd_childlist_next = NULL;
        row.zd_childlist_prev = old_tail;
        cascdel.zd_childlist_tail = &row;
        atf_amc::FCascdel **new_row_a = &old_tail->zd_childlist_next;
        atf_amc::FCascdel **new_row_b = &cascdel.zd_childlist_head;
        atf_amc::FCascdel **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        cascdel.zd_childlist_n++;
    }
}

// --- atf_amc.FCascdel.zd_childlist.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zd_childlist_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if (zd_childlist_InLlistQ(row)) {
        atf_amc::FCascdel* old_head       = cascdel.zd_childlist_head;
        (void)old_head; // in case it's not used
        atf_amc::FCascdel* prev = row.zd_childlist_prev;
        atf_amc::FCascdel* next = row.zd_childlist_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FCascdel **new_next_a = &prev->zd_childlist_next;
        atf_amc::FCascdel **new_next_b = &cascdel.zd_childlist_head;
        atf_amc::FCascdel **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FCascdel **new_prev_a = &next->zd_childlist_prev;
        atf_amc::FCascdel **new_prev_b = &cascdel.zd_childlist_tail;
        atf_amc::FCascdel **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        cascdel.zd_childlist_n--;
        row.zd_childlist_next=(atf_amc::FCascdel*)-1; // not-in-list
    }
}

// --- atf_amc.FCascdel.zd_childlist.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zd_childlist_RemoveAll(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel* row = cascdel.zd_childlist_head;
    cascdel.zd_childlist_head = NULL;
    cascdel.zd_childlist_tail = NULL;
    cascdel.zd_childlist_n = 0;
    while (row) {
        atf_amc::FCascdel* row_next = row->zd_childlist_next;
        row->zd_childlist_next  = (atf_amc::FCascdel*)-1;
        row->zd_childlist_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FCascdel.zd_childlist.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FCascdel* atf_amc::zd_childlist_RemoveFirst(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    row = cascdel.zd_childlist_head;
    if (row) {
        atf_amc::FCascdel *next = row->zd_childlist_next;
        cascdel.zd_childlist_head = next;
        atf_amc::FCascdel **new_end_a = &next->zd_childlist_prev;
        atf_amc::FCascdel **new_end_b = &cascdel.zd_childlist_tail;
        atf_amc::FCascdel **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        cascdel.zd_childlist_n--;
        row->zd_childlist_next = (atf_amc::FCascdel*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FCascdel.tr_child_atree.Cascdel
// Delete all elements in the tree.
void atf_amc::tr_child_atree_Cascdel(atf_amc::FCascdel& cascdel) {
    tr_child_atree_RemoveAllImpl(cascdel, cascdel.tr_child_atree_root, true);
    cascdel.tr_child_atree_root = NULL;
    cascdel.tr_child_atree_n = 0;
}

// --- atf_amc.FCascdel.tr_child_atree.FirstImpl
atf_amc::FCascdel* atf_amc::tr_child_atree_FirstImpl(atf_amc::FCascdel* root) {
    atf_amc::FCascdel *result = root;
    while(result != NULL && result->tr_child_atree_left != NULL){
        result = result->tr_child_atree_left;
    }
    return result;
}

// --- atf_amc.FCascdel.tr_child_atree.First
// Return pointer to the first(smallest) element in the tree
atf_amc::FCascdel* atf_amc::tr_child_atree_First(atf_amc::FCascdel& cascdel) {
    return tr_child_atree_FirstImpl(cascdel.tr_child_atree_root);
}

// --- atf_amc.FCascdel.tr_child_atree.InsertImpl
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_amc::tr_child_atree_InsertImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* parent, atf_amc::FCascdel& row) {
    bool left = false;
    while(parent != NULL){
        left = tr_child_atree_ElemLt(cascdel, row, *parent);
        atf_amc::FCascdel* side = left ? parent->tr_child_atree_left : parent->tr_child_atree_right;
        if(side == NULL){
            break;
        }
        parent = side;
    }
    tr_child_atree_Connect(parent, &row, left);
}

// --- atf_amc.FCascdel.tr_child_atree.Insert
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_amc::tr_child_atree_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if(!tr_child_atree_InTreeQ(row)){
        cascdel.tr_child_atree_n++;
        tr_child_atree_InsertImpl(cascdel, cascdel.tr_child_atree_root, row);
        cascdel.tr_child_atree_root = tr_child_atree_Propagate(row);
    }
}

// --- atf_amc.FCascdel.tr_child_atree.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::tr_child_atree_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    if(!tr_child_atree_InTreeQ(row)){
        return;
    }
    atf_amc::FCascdel* next = NULL;
    if(row.tr_child_atree_depth > 1){
        next = tr_child_atree_Balance(row) < 0 ? tr_child_atree_FirstImpl(row.tr_child_atree_right) : tr_child_atree_LastImpl(row.tr_child_atree_left);
        atf_amc::FCascdel* leaf = tr_child_atree_TallerChild(*next);
        if(leaf){
            tr_child_atree_Turn(*leaf, *next);
        }
    }
    atf_amc::FCascdel* root = row.tr_child_atree_up;
    atf_amc::FCascdel* prop = root;//propagate point
    if(next){
        prop = next->tr_child_atree_up == &row ? next : next->tr_child_atree_up;
        tr_child_atree_Disconnect(*next);
        tr_child_atree_Connect(next, row.tr_child_atree_left, true);
        tr_child_atree_Connect(next, row.tr_child_atree_right, false);
    }
    bool dir = root && root->tr_child_atree_left == &row;
    tr_child_atree_Connect(root, next, dir);
    cascdel.tr_child_atree_root = prop ? tr_child_atree_Propagate(*prop) : NULL;
    row.tr_child_atree_depth = 0;
    row.tr_child_atree_left = NULL;
    row.tr_child_atree_right = NULL;
    row.tr_child_atree_up = (atf_amc::FCascdel*)-1;
    cascdel.tr_child_atree_n--;
}

// --- atf_amc.FCascdel.tr_child_atree.RemoveFirst
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void atf_amc::tr_child_atree_RemoveFirst(atf_amc::FCascdel& cascdel) {
    if(!tr_child_atree_EmptyQ(cascdel)){
        tr_child_atree_Remove(cascdel, *tr_child_atree_First(cascdel));
    }
}

// --- atf_amc.FCascdel.tr_child_atree.Balance
i32 atf_amc::tr_child_atree_Balance(atf_amc::FCascdel& row) {
    i32 left  = row.tr_child_atree_left  ? row.tr_child_atree_left->tr_child_atree_depth  : 0;
    i32 right = row.tr_child_atree_right ? row.tr_child_atree_right->tr_child_atree_depth : 0;
    return left - right;
}

// --- atf_amc.FCascdel.tr_child_atree.Propagate
// Recalculate depth and keep rebalancing if needed
atf_amc::FCascdel* atf_amc::tr_child_atree_Propagate(atf_amc::FCascdel& pnode) {
    atf_amc::FCascdel *root = &pnode;
    atf_amc::FCascdel* node = &pnode;
    while(node != NULL){
        tr_child_atree_updateDepth(*node);
        tr_child_atree_Rebalance(*node);
        root = node;
        node = node->tr_child_atree_up;
    }
    return root;
}

// --- atf_amc.FCascdel.tr_child_atree.TallerChild
// Returns the child that has greater height.
inline static atf_amc::FCascdel* atf_amc::tr_child_atree_TallerChild(atf_amc::FCascdel& node) {
    return tr_child_atree_Balance(node) < 0 ? node.tr_child_atree_right : node.tr_child_atree_left;
}

// --- atf_amc.FCascdel.tr_child_atree.Disconnect
// Disconnects the subtree(branch) from the parent
static void atf_amc::tr_child_atree_Disconnect(atf_amc::FCascdel& node) {
    atf_amc::FCascdel* parent = node.tr_child_atree_up;
    if(parent != NULL){
        bool left = parent->tr_child_atree_left == &node;
        (left ? parent->tr_child_atree_left : parent->tr_child_atree_right) = NULL;
    }
    node.tr_child_atree_up = NULL;
}

// --- atf_amc.FCascdel.tr_child_atree.Rebalance
// Rebalances the node if needed.
void atf_amc::tr_child_atree_Rebalance(atf_amc::FCascdel& node) {
    if (algo::Abs(tr_child_atree_Balance(node)) > 1){
        atf_amc::FCascdel* deep1 = tr_child_atree_TallerChild(node);
        atf_amc::FCascdel* deep2 = tr_child_atree_TallerChild(*deep1);
        bool turn = tr_child_atree_Balance(*deep1)!=0 && (node.tr_child_atree_left == deep1) != (deep1->tr_child_atree_left == deep2);
        if(turn){
            tr_child_atree_Turn(*deep2, *deep1);
            algo::TSwap(deep1, deep2);
        }
        tr_child_atree_Turn(*deep1, node);
        tr_child_atree_updateDepth(node);
        tr_child_atree_updateDepth(*deep2);
        tr_child_atree_updateDepth(*deep1);
    }
}

// --- atf_amc.FCascdel.tr_child_atree.Next
atf_amc::FCascdel* atf_amc::tr_child_atree_Next(atf_amc::FCascdel& node) {
    atf_amc::FCascdel *result = &node;
    if(result->tr_child_atree_right == NULL){
        while(result->tr_child_atree_up != NULL && result->tr_child_atree_up->tr_child_atree_right == result){
            result = result->tr_child_atree_up;
        }
        result = result->tr_child_atree_up;
    }else{
        result = tr_child_atree_FirstImpl(result->tr_child_atree_right);
    }
    return result;
}

// --- atf_amc.FCascdel.tr_child_atree.Prev
atf_amc::FCascdel* atf_amc::tr_child_atree_Prev(atf_amc::FCascdel& node) {
    atf_amc::FCascdel *result = &node;
    if(result->tr_child_atree_left == NULL){
        while(result->tr_child_atree_up != NULL && result->tr_child_atree_up->tr_child_atree_left == result){
            result = result->tr_child_atree_up;
        }
        result = result->tr_child_atree_up;
    }else{
        result = tr_child_atree_LastImpl(result->tr_child_atree_left);
    }
    return result;
}

// --- atf_amc.FCascdel.tr_child_atree.LastImpl
atf_amc::FCascdel* atf_amc::tr_child_atree_LastImpl(atf_amc::FCascdel* root) {
    atf_amc::FCascdel *result = root;
    while(result != NULL && result->tr_child_atree_right != NULL){
        result = result->tr_child_atree_right;
    }
    return result;
}

// --- atf_amc.FCascdel.tr_child_atree.Last
// Return pointer to the last(largest) element in tree
atf_amc::FCascdel* atf_amc::tr_child_atree_Last(atf_amc::FCascdel& cascdel) {
    return tr_child_atree_LastImpl(cascdel.tr_child_atree_root);
}

// --- atf_amc.FCascdel.tr_child_atree.ElemLt
inline static bool atf_amc::tr_child_atree_ElemLt(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &a, atf_amc::FCascdel &b) {
    (void)cascdel;
    return a.key < b.key;
}

// --- atf_amc.FCascdel.tr_child_atree.UpdateDepth
static void atf_amc::tr_child_atree_updateDepth(atf_amc::FCascdel& node) {
    i32 ldepth = node.tr_child_atree_left  != NULL ? node.tr_child_atree_left->tr_child_atree_depth : 0;
    i32 rdepth = node.tr_child_atree_right != NULL ? node.tr_child_atree_right->tr_child_atree_depth : 0;
    node.tr_child_atree_depth = i32_Max(ldepth, rdepth) + 1;
}

// --- atf_amc.FCascdel.tr_child_atree.Turn
// rotates the tree in from->to direction
static void atf_amc::tr_child_atree_Turn(atf_amc::FCascdel& from, atf_amc::FCascdel& to) {
    atf_amc::FCascdel* root = to.tr_child_atree_up;
    bool dir = root && root->tr_child_atree_left == &to;
    tr_child_atree_Connect(root, &from, dir);
    dir = to.tr_child_atree_left == &from;
    atf_amc::FCascdel* orphan = (dir ? from.tr_child_atree_right : from.tr_child_atree_left);//other side
    tr_child_atree_Connect(&from, &to , !dir);
    tr_child_atree_Connect(&to, orphan, dir);
}

// --- atf_amc.FCascdel.tr_child_atree.Connect
inline static void atf_amc::tr_child_atree_Connect(atf_amc::FCascdel* parent, atf_amc::FCascdel* child, bool left) {
    if(parent){
        (left ? parent->tr_child_atree_left : parent->tr_child_atree_right) = child;
    }
    if(child){
        child->tr_child_atree_up = parent;
    }
}

// --- atf_amc.FCascdel.tr_child_atree.RemoveAllImpl
// Empty the index. (rows may be deleted if cascdel)
void atf_amc::tr_child_atree_RemoveAllImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* root, bool del) {
    if(root != NULL){
        tr_child_atree_RemoveAllImpl(cascdel, root->tr_child_atree_left, del);
        tr_child_atree_RemoveAllImpl(cascdel, root->tr_child_atree_right, del);
        tr_child_atree_Disconnect(*root);
        root->tr_child_atree_depth = 0;//the pointers are taken care of by Disconnect
        root->tr_child_atree_up = (atf_amc::FCascdel*)-1;//the pointers are taken care of by Disconnect
        if(del){
            cascdel_Delete(*root);
        }
    }
}

// --- atf_amc.FCascdel.tr_child_atree.Reinsert
// Reinsert a row with modified key(Reheap semantics)
void atf_amc::tr_child_atree_Reinsert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& node) {
    tr_child_atree_Remove(cascdel, node);
    tr_child_atree_Insert(cascdel, node);
}

// --- atf_amc.FCascdel.tr_child_atree.FirstGe
// Find the first element that is greater or equal to a sortfld value
atf_amc::FCascdel* atf_amc::tr_child_atree_FirstGe(atf_amc::FCascdel& cascdel, const u32& val) {
    atf_amc::FCascdel* result = cascdel.tr_child_atree_root;
    bool left = false;
    while(result){
        left = !((*result).key < val);
        atf_amc::FCascdel* side = left ? result->tr_child_atree_left : result->tr_child_atree_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && (*result).key < val){
        result = tr_child_atree_Next(*result);
    }
    return result;
}

// --- atf_amc.FCascdel.tr_child_atree.LastLt
// Find the last element that is smaller or equal to a sortfld value
atf_amc::FCascdel* atf_amc::tr_child_atree_LastLt(atf_amc::FCascdel& cascdel, const u32& val) {
    atf_amc::FCascdel* result = cascdel.tr_child_atree_root;
    bool left = false;
    while(result){
        left = val < (*result).key;
        atf_amc::FCascdel* side = left ? result->tr_child_atree_left : result->tr_child_atree_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && !((*result).key < val)){
        result = tr_child_atree_Prev(*result);
    }
    return result;
}

// --- atf_amc.FCascdel..Init
// Set all fields to initial values.
void atf_amc::FCascdel_Init(atf_amc::FCascdel& cascdel) {
    cascdel.p_parent = NULL;
    cascdel.key = u32(0);
    cascdel.type = u32(0);
    cascdel.child_ptr = NULL;
    cascdel.c_child_ptrary_elems = NULL; // (atf_amc.FCascdel.c_child_ptrary)
    cascdel.c_child_ptrary_n = 0; // (atf_amc.FCascdel.c_child_ptrary)
    cascdel.c_child_ptrary_max = 0; // (atf_amc.FCascdel.c_child_ptrary)
    // initialize hash table for atf_amc::FCascdel;
    cascdel.ind_child_thash_n             	= 0; // (atf_amc.FCascdel.ind_child_thash)
    cascdel.ind_child_thash_buckets_n     	= 4; // (atf_amc.FCascdel.ind_child_thash)
    cascdel.ind_child_thash_buckets_elems 	= (atf_amc::FCascdel**)algo_lib::malloc_AllocMem(sizeof(atf_amc::FCascdel*)*cascdel.ind_child_thash_buckets_n); // initial buckets (atf_amc.FCascdel.ind_child_thash)
    if (!cascdel.ind_child_thash_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_amc.FCascdel.ind_child_thash)
    }
    memset(cascdel.ind_child_thash_buckets_elems, 0, sizeof(atf_amc::FCascdel*)*cascdel.ind_child_thash_buckets_n); // (atf_amc.FCascdel.ind_child_thash)
    cascdel.bh_child_bheap_max   	= 0; // (atf_amc.FCascdel.bh_child_bheap)
    cascdel.bh_child_bheap_n     	= 0; // (atf_amc.FCascdel.bh_child_bheap)
    cascdel.bh_child_bheap_elems 	= NULL; // (atf_amc.FCascdel.bh_child_bheap)
    cascdel.zd_childlist_head = NULL; // (atf_amc.FCascdel.zd_childlist)
    cascdel.zd_childlist_n = 0; // (atf_amc.FCascdel.zd_childlist)
    cascdel.zd_childlist_tail = NULL; // (atf_amc.FCascdel.zd_childlist)
    cascdel.tr_child_atree_root = NULL; // (atf_amc.FCascdel.tr_child_atree)
    cascdel.tr_child_atree_n = 0;
    cascdel.cascdel_c_child_ptrary_in_ary = bool(false);
    cascdel.ind_child_thash_next = (atf_amc::FCascdel*)-1; // (atf_amc.FCascdel.ind_child_thash) not-in-hash
    cascdel.bh_child_bheap_idx = -1; // (atf_amc.FCascdel.bh_child_bheap) not-in-heap
    cascdel.zd_childlist_next = (atf_amc::FCascdel*)-1; // (atf_amc.FCascdel.zd_childlist) not-in-list
    cascdel.zd_childlist_prev = NULL; // (atf_amc.FCascdel.zd_childlist)
    cascdel.tr_child_atree_up = (atf_amc::FCascdel*)-1; // (atf_amc.FCascdel.tr_child_atree) not in tree
    cascdel.tr_child_atree_left = NULL;
    cascdel.tr_child_atree_right = NULL;
    cascdel.tr_child_atree_depth = 0;
    cascdel.cascdel_next = (atf_amc::FCascdel*)-1; // (atf_amc.FDb.cascdel) not-in-tpool's freelist
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.Add
static void atf_amc::cascdel_bh_child_bheap_curs_Add(cascdel_bh_child_bheap_curs &curs, atf_amc::FCascdel& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    atf_amc::FCascdel* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        atf_amc::FCascdel* p = elems[j];
        if (!bh_child_bheap_ElemLt((*curs.parent), row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.Reserve
void atf_amc::cascdel_bh_child_bheap_curs_Reserve(cascdel_bh_child_bheap_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_child_bheap_N((*curs.parent));
        curs.temp_elems   = (atf_amc::FCascdel**)algo_lib::malloc_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("atf_amc.cursor_out_of_memory  func:atf_amc.FCascdel.bh_child_bheap_curs.Reserve");
        }
        curs.temp_max       = bh_child_bheap_N((*curs.parent));
    }
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void atf_amc::cascdel_bh_child_bheap_curs_Reset(cascdel_bh_child_bheap_curs &curs, atf_amc::FCascdel &parent) {
    curs.parent       = &parent;
    cascdel_bh_child_bheap_curs_Reserve(curs, bh_child_bheap_N((*curs.parent)));
    curs.temp_n = 0;
    if (parent.bh_child_bheap_n > 0) {
        atf_amc::FCascdel &first = *parent.bh_child_bheap_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.Next
// Advance cursor.
void atf_amc::cascdel_bh_child_bheap_curs_Next(cascdel_bh_child_bheap_curs &curs) {
    atf_amc::FCascdel* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        atf_amc::FCascdel* dead = elems[0];
        int i       = 0;
        atf_amc::FCascdel* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            atf_amc::FCascdel* choose = last;
            int l         = i*2+1;
            if (l<n) {
                atf_amc::FCascdel* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                atf_amc::FCascdel* er = elems[r];
                if (bh_child_bheap_ElemLt((*curs.parent),*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_child_bheap_ElemLt((*curs.parent),*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_child_bheap_idx;
        i = (index*2+1);
        if (i < bh_child_bheap_N((*curs.parent))) {
            atf_amc::FCascdel &elem = *curs.parent->bh_child_bheap_elems[i];
            cascdel_bh_child_bheap_curs_Add(curs, elem);
        }
        if (i+1 < bh_child_bheap_N((*curs.parent))) {
            atf_amc::FCascdel &elem = *curs.parent->bh_child_bheap_elems[i + 1];
            cascdel_bh_child_bheap_curs_Add(curs, elem);
        }
    }
}

// --- atf_amc.FCascdel..Uninit
void atf_amc::FCascdel_Uninit(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel &row = cascdel; (void)row;
    tr_child_atree_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.tr_child_atree
    zd_childlist_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.zd_childlist
    bh_child_bheap_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.bh_child_bheap
    ind_child_thash_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.ind_child_thash
    c_child_ptrary_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.c_child_ptrary
    child_ptr_Cascdel(cascdel); // dmmeta.cascdel:atf_amc.FCascdel.child_ptr
    atf_amc::FCascdel* p_p_parent = row.p_parent;
    if (p_p_parent)  {
        child_ptr_Remove(*p_p_parent, row);// remove cascdel from index child_ptr
    }
    if (p_p_parent)  {
        c_child_ptrary_Remove(*p_p_parent, row);// remove cascdel from index c_child_ptrary
    }
    if (p_p_parent)  {
        ind_child_thash_Remove(*p_p_parent, row);// remove cascdel from index ind_child_thash
    }
    if (p_p_parent)  {
        bh_child_bheap_Remove(*p_p_parent, row);// remove cascdel from index bh_child_bheap
    }
    if (p_p_parent)  {
        zd_childlist_Remove(*p_p_parent, row);// remove cascdel from index zd_childlist
    }
    if (p_p_parent)  {
        tr_child_atree_Remove(*p_p_parent, row);// remove cascdel from index tr_child_atree
    }
    key_Cleanup(cascdel); // dmmeta.fcleanup:atf_amc.FCascdel.key

    // atf_amc.FCascdel.bh_child_bheap.Uninit (Bheap)  //
    algo_lib::malloc_FreeMem((u8*)cascdel.bh_child_bheap_elems, sizeof(atf_amc::FCascdel*)*cascdel.bh_child_bheap_max); // (atf_amc.FCascdel.bh_child_bheap)

    // atf_amc.FCascdel.ind_child_thash.Uninit (Thash)  //
    algo_lib::malloc_FreeMem(cascdel.ind_child_thash_buckets_elems, sizeof(atf_amc::FCascdel*)*cascdel.ind_child_thash_buckets_n); // (atf_amc.FCascdel.ind_child_thash)

    // atf_amc.FCascdel.c_child_ptrary.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(cascdel.c_child_ptrary_elems, sizeof(atf_amc::FCascdel*)*cascdel.c_child_ptrary_max); // (atf_amc.FCascdel.c_child_ptrary)
}

// --- atf_amc.FCascdel..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FCascdel.String  printfmt:Tuple
void atf_amc::FCascdel_Print(atf_amc::FCascdel& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FCascdel";

    u32_Print(row.key, temp);
    PrintAttrSpaceReset(str,"key", temp);

    atf_amc::type_Print(row, temp);
    PrintAttrSpaceReset(str,"type", temp);

    u64_PrintHex(u64(row.child_ptr), temp, 8, true);
    PrintAttrSpaceReset(str,"child_ptr", temp);

    bool_Print(row.cascdel_c_child_ptrary_in_ary, temp);
    PrintAttrSpaceReset(str,"cascdel_c_child_ptrary_in_ary", temp);
}

// --- atf_amc.FCstring.msghdr.CopyOut
// Copy fields out of row
void atf_amc::cstring_CopyOut(atf_amc::FCstring &row, atf_amc::Cstring &out) {
    out.str = row.str;
}

// --- atf_amc.FCstring.msghdr.CopyIn
// Copy fields in to row
void atf_amc::cstring_CopyIn(atf_amc::FCstring &row, atf_amc::Cstring &in) {
    row.str = in.str;
}

// --- atf_amc.FCstring..Uninit
void atf_amc::FCstring_Uninit(atf_amc::FCstring& cstring) {
    atf_amc::FCstring &row = cstring; (void)row;
    ind_cstring_Remove(row); // remove cstring from index ind_cstring
}

// --- atf_amc.FListtype.base.CopyOut
// Copy fields out of row
void atf_amc::listtype_CopyOut(atf_amc::FListtype &row, dmmeta::Listtype &out) {
    out.listtype = row.listtype;
    out.circular = row.circular;
    out.haveprev = row.haveprev;
    out.instail = row.instail;
    out.comment = row.comment;
}

// --- atf_amc.FListtype.base.CopyIn
// Copy fields in to row
void atf_amc::listtype_CopyIn(atf_amc::FListtype &row, dmmeta::Listtype &in) {
    row.listtype = in.listtype;
    row.circular = in.circular;
    row.haveprev = in.haveprev;
    row.instail = in.instail;
    row.comment = in.comment;
}

// --- atf_amc.trace..Init
// Set all fields to initial values.
void atf_amc::trace_Init(atf_amc::trace& parent) {
    parent.step_bh_typec = u64(0);
    parent.step_bh_typec_cycles = u64(0);
    parent.step_zsl_h_typec = u64(0);
    parent.step_zsl_h_typec_cycles = u64(0);
    parent.step_zs_t_typec = u64(0);
    parent.step_zs_t_typec_cycles = u64(0);
    parent.step_csl_h_typec = u64(0);
    parent.step_csl_h_typec_cycles = u64(0);
    parent.step_cs_t_typec = u64(0);
    parent.step_cs_t_typec_cycles = u64(0);
    parent.step_cd_in_msg = u64(0);
    parent.step_cd_in_msg_cycles = u64(0);
}

// --- atf_amc.trace..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.trace.String  printfmt:Tuple
void atf_amc::trace_Print(atf_amc::trace& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.trace";

    u64_Print(row.step_bh_typec, temp);
    PrintAttrSpaceReset(str,"step_bh_typec", temp);

    u64_Print(row.step_bh_typec_cycles, temp);
    PrintAttrSpaceReset(str,"step_bh_typec_cycles", temp);

    u64_Print(row.step_zsl_h_typec, temp);
    PrintAttrSpaceReset(str,"step_zsl_h_typec", temp);

    u64_Print(row.step_zsl_h_typec_cycles, temp);
    PrintAttrSpaceReset(str,"step_zsl_h_typec_cycles", temp);

    u64_Print(row.step_zs_t_typec, temp);
    PrintAttrSpaceReset(str,"step_zs_t_typec", temp);

    u64_Print(row.step_zs_t_typec_cycles, temp);
    PrintAttrSpaceReset(str,"step_zs_t_typec_cycles", temp);

    u64_Print(row.step_csl_h_typec, temp);
    PrintAttrSpaceReset(str,"step_csl_h_typec", temp);

    u64_Print(row.step_csl_h_typec_cycles, temp);
    PrintAttrSpaceReset(str,"step_csl_h_typec_cycles", temp);

    u64_Print(row.step_cs_t_typec, temp);
    PrintAttrSpaceReset(str,"step_cs_t_typec", temp);

    u64_Print(row.step_cs_t_typec_cycles, temp);
    PrintAttrSpaceReset(str,"step_cs_t_typec_cycles", temp);

    u64_Print(row.step_cd_in_msg, temp);
    PrintAttrSpaceReset(str,"step_cd_in_msg", temp);

    u64_Print(row.step_cd_in_msg_cycles, temp);
    PrintAttrSpaceReset(str,"step_cd_in_msg_cycles", temp);
}

// --- atf_amc.FDb.bh_typec.Dealloc
// Remove all elements from heap and free memory used by the array.
void atf_amc::bh_typec_Dealloc() {
    bh_typec_RemoveAll();
    algo_lib::malloc_FreeMem(_db.bh_typec_elems, sizeof(atf_amc::FTypeC*)*_db.bh_typec_max);
    _db.bh_typec_max   = 0;
    _db.bh_typec_elems = NULL;
}

// --- atf_amc.FDb.bh_typec.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int atf_amc::bh_typec_Downheap(atf_amc::FTypeC& row, int idx) {
    atf_amc::FTypeC* *elems = _db.bh_typec_elems;
    int n = _db.bh_typec_n;
    int child = idx*2+1;
    while (child < n) {
        atf_amc::FTypeC* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            atf_amc::FTypeC* q = elems[rchild]; // right child
            if (bh_typec_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_typec_ElemLt(*p,row)) {
            break;
        }
        p->bh_typec_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- atf_amc.FDb.bh_typec.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void atf_amc::bh_typec_Insert(atf_amc::FTypeC& row) {
    if (LIKELY(row.bh_typec_idx == -1)) {
        bh_typec_Reserve(1);
        int n = _db.bh_typec_n;
        _db.bh_typec_n = n + 1;
        int new_idx = bh_typec_Upheap(row, n);
        row.bh_typec_idx = new_idx;
        _db.bh_typec_elems[new_idx] = &row;
        if (new_idx==0) {
            bh_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.bh_typec.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// If first item of the is changed, update fstep:atf_amc.FDb.bh_typec
i32 atf_amc::bh_typec_Reheap(atf_amc::FTypeC& row) {
    int old_idx = row.bh_typec_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_typec_Reserve(1);
        old_idx = _db.bh_typec_n++;
    }
    int new_idx = bh_typec_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_typec_Downheap(row, old_idx);
    }
    row.bh_typec_idx = new_idx;
    _db.bh_typec_elems[new_idx] = &row;
    bool changed = new_idx==0 || old_idx==0;
    if (changed) {
        bh_typec_FirstChanged();
    }
    return new_idx;
}

// --- atf_amc.FDb.bh_typec.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// Update fstep:atf_amc.FDb.bh_typec
i32 atf_amc::bh_typec_ReheapFirst() {
    atf_amc::FTypeC &row = *_db.bh_typec_elems[0];
    i32 new_idx = bh_typec_Downheap(row, 0);
    row.bh_typec_idx = new_idx;
    _db.bh_typec_elems[new_idx] = &row;
    if (new_idx != 0) {
        bh_typec_FirstChanged();
    }
    return new_idx;
}

// --- atf_amc.FDb.bh_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::bh_typec_Remove(atf_amc::FTypeC& row) {
    if (bh_typec_InBheapQ(row)) {
        int old_idx = row.bh_typec_idx;
        if (_db.bh_typec_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_typec_idx = -1;           // mark not in heap
            i32 n = _db.bh_typec_n - 1; // index of last element in heap
            _db.bh_typec_n = n;         // decrease count
            if (old_idx != n) {
                atf_amc::FTypeC *elem = _db.bh_typec_elems[n];
                int new_idx = bh_typec_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_typec_Downheap(*elem, old_idx);
                }
                elem->bh_typec_idx = new_idx;
                _db.bh_typec_elems[new_idx] = elem;
            }
            if (old_idx == 0) {
                bh_typec_FirstChanged();
            }
        }
    }
}

// --- atf_amc.FDb.bh_typec.RemoveAll
// Remove all elements from binary heap
void atf_amc::bh_typec_RemoveAll() {
    int n = _db.bh_typec_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_typec_elems[i]->bh_typec_idx = -1; // mark not-in-heap
    }
    _db.bh_typec_n = 0;
    if (n > 0) {
        bh_typec_FirstChanged();
    }
}

// --- atf_amc.FDb.bh_typec.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FTypeC* atf_amc::bh_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    if (_db.bh_typec_n > 0) {
        row = _db.bh_typec_elems[0];
        row->bh_typec_idx = -1;           // mark not in heap
        i32 n = _db.bh_typec_n - 1; // index of last element in heap
        _db.bh_typec_n = n;         // decrease count
        if (n) {
            atf_amc::FTypeC &elem = *_db.bh_typec_elems[n];
            int new_idx = bh_typec_Downheap(elem, 0);
            elem.bh_typec_idx = new_idx;
            _db.bh_typec_elems[new_idx] = &elem;
        }
        bh_typec_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.bh_typec.Reserve
// Reserve space in index for N more elements
void atf_amc::bh_typec_Reserve(int n) {
    i32 old_max = _db.bh_typec_max;
    if (UNLIKELY(_db.bh_typec_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::FTypeC*);
        u32 new_size = new_max * sizeof(atf_amc::FTypeC*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.bh_typec_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.bh_typec");
        }
        _db.bh_typec_elems = (atf_amc::FTypeC**)new_mem;
        _db.bh_typec_max = new_max;
    }
}

// --- atf_amc.FDb.bh_typec.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int atf_amc::bh_typec_Upheap(atf_amc::FTypeC& row, int idx) {
    atf_amc::FTypeC* *elems = _db.bh_typec_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        atf_amc::FTypeC* p = elems[j];
        if (!bh_typec_ElemLt(row, *p)) {
            break;
        }
        p->bh_typec_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- atf_amc.FDb.bh_typec.ElemLt
inline static bool atf_amc::bh_typec_ElemLt(atf_amc::FTypeC &a, atf_amc::FTypeC &b) {
    (void)_db;
    return a.typec < b.typec;
}

// --- atf_amc.FDb.bh_typec.UpdateCycles
// Update cycles count from previous clock capture
void atf_amc::bh_typec_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_bh_typec;
    atf_amc::_db.trace.step_bh_typec_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.zdl_h_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zdl_h_typec_Insert(atf_amc::FTypeC& row) {
    if (!zdl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head = _db.zdl_h_typec_head;
        row.zdl_h_typec_prev = NULL;
        row.zdl_h_typec_next = old_head;
        _db.zdl_h_typec_head  = &row;
        atf_amc::FTypeC **new_row_a = &old_head->zdl_h_typec_prev;
        atf_amc::FTypeC **new_row_b = &_db.zdl_h_typec_tail;
        atf_amc::FTypeC **new_row = old_head ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zdl_h_typec_n++;
    }
}

// --- atf_amc.FDb.zdl_h_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zdl_h_typec_Remove(atf_amc::FTypeC& row) {
    if (zdl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.zdl_h_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC* prev = row.zdl_h_typec_prev;
        atf_amc::FTypeC* next = row.zdl_h_typec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeC **new_next_a = &prev->zdl_h_typec_next;
        atf_amc::FTypeC **new_next_b = &_db.zdl_h_typec_head;
        atf_amc::FTypeC **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FTypeC **new_prev_a = &next->zdl_h_typec_prev;
        atf_amc::FTypeC **new_prev_b = &_db.zdl_h_typec_tail;
        atf_amc::FTypeC **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zdl_h_typec_n--;
        row.zdl_h_typec_next=(atf_amc::FTypeC*)-1; // not-in-list
    }
}

// --- atf_amc.FDb.zdl_h_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zdl_h_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.zdl_h_typec_head;
    _db.zdl_h_typec_head = NULL;
    _db.zdl_h_typec_tail = NULL;
    _db.zdl_h_typec_n = 0;
    while (row) {
        atf_amc::FTypeC* row_next = row->zdl_h_typec_next;
        row->zdl_h_typec_next  = (atf_amc::FTypeC*)-1;
        row->zdl_h_typec_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FDb.zdl_h_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC* atf_amc::zdl_h_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_h_typec_head;
    if (row) {
        atf_amc::FTypeC *next = row->zdl_h_typec_next;
        _db.zdl_h_typec_head = next;
        atf_amc::FTypeC **new_end_a = &next->zdl_h_typec_prev;
        atf_amc::FTypeC **new_end_b = &_db.zdl_h_typec_tail;
        atf_amc::FTypeC **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zdl_h_typec_n--;
        row->zdl_h_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.zd_t_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zd_t_typec_Insert(atf_amc::FTypeC& row) {
    if (!zd_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_tail = _db.zd_t_typec_tail;
        row.zd_t_typec_next = NULL;
        row.zd_t_typec_prev = old_tail;
        _db.zd_t_typec_tail = &row;
        atf_amc::FTypeC **new_row_a = &old_tail->zd_t_typec_next;
        atf_amc::FTypeC **new_row_b = &_db.zd_t_typec_head;
        atf_amc::FTypeC **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_t_typec_n++;
    }
}

// --- atf_amc.FDb.zd_t_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zd_t_typec_Remove(atf_amc::FTypeC& row) {
    if (zd_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.zd_t_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC* prev = row.zd_t_typec_prev;
        atf_amc::FTypeC* next = row.zd_t_typec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeC **new_next_a = &prev->zd_t_typec_next;
        atf_amc::FTypeC **new_next_b = &_db.zd_t_typec_head;
        atf_amc::FTypeC **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FTypeC **new_prev_a = &next->zd_t_typec_prev;
        atf_amc::FTypeC **new_prev_b = &_db.zd_t_typec_tail;
        atf_amc::FTypeC **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_t_typec_n--;
        row.zd_t_typec_next=(atf_amc::FTypeC*)-1; // not-in-list
    }
}

// --- atf_amc.FDb.zd_t_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zd_t_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.zd_t_typec_head;
    _db.zd_t_typec_head = NULL;
    _db.zd_t_typec_tail = NULL;
    _db.zd_t_typec_n = 0;
    while (row) {
        atf_amc::FTypeC* row_next = row->zd_t_typec_next;
        row->zd_t_typec_next  = (atf_amc::FTypeC*)-1;
        row->zd_t_typec_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FDb.zd_t_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC* atf_amc::zd_t_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zd_t_typec_head;
    if (row) {
        atf_amc::FTypeC *next = row->zd_t_typec_next;
        _db.zd_t_typec_head = next;
        atf_amc::FTypeC **new_end_a = &next->zd_t_typec_prev;
        atf_amc::FTypeC **new_end_b = &_db.zd_t_typec_tail;
        atf_amc::FTypeC **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_t_typec_n--;
        row->zd_t_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.zd_typed.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zd_typed_Insert(atf_amc::FTypeD& row) {
    if (!zd_typed_InLlistQ(row)) {
        atf_amc::FTypeD* old_tail = _db.zd_typed_tail;
        row.zd_typed_next = NULL;
        row.zd_typed_prev = old_tail;
        _db.zd_typed_tail = &row;
        atf_amc::FTypeD **new_row_a = &old_tail->zd_typed_next;
        atf_amc::FTypeD **new_row_b = &_db.zd_typed_head;
        atf_amc::FTypeD **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_typed_n++;
    }
}

// --- atf_amc.FDb.zd_typed.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zd_typed_Remove(atf_amc::FTypeD& row) {
    if (zd_typed_InLlistQ(row)) {
        atf_amc::FTypeD* old_head       = _db.zd_typed_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeD* prev = row.zd_typed_prev;
        atf_amc::FTypeD* next = row.zd_typed_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeD **new_next_a = &prev->zd_typed_next;
        atf_amc::FTypeD **new_next_b = &_db.zd_typed_head;
        atf_amc::FTypeD **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FTypeD **new_prev_a = &next->zd_typed_prev;
        atf_amc::FTypeD **new_prev_b = &_db.zd_typed_tail;
        atf_amc::FTypeD **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_typed_n--;
        row.zd_typed_next=(atf_amc::FTypeD*)-1; // not-in-list
    }
}

// --- atf_amc.FDb.zd_typed.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zd_typed_RemoveAll() {
    atf_amc::FTypeD* row = _db.zd_typed_head;
    _db.zd_typed_head = NULL;
    _db.zd_typed_tail = NULL;
    _db.zd_typed_n = 0;
    while (row) {
        atf_amc::FTypeD* row_next = row->zd_typed_next;
        row->zd_typed_next  = (atf_amc::FTypeD*)-1;
        row->zd_typed_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FDb.zd_typed.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeD* atf_amc::zd_typed_RemoveFirst() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zd_typed_head;
    if (row) {
        atf_amc::FTypeD *next = row->zd_typed_next;
        _db.zd_typed_head = next;
        atf_amc::FTypeD **new_end_a = &next->zd_typed_prev;
        atf_amc::FTypeD **new_end_b = &_db.zd_typed_tail;
        atf_amc::FTypeD **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_typed_n--;
        row->zd_typed_next = (atf_amc::FTypeD*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.zs_t_typed.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zs_t_typed_Insert(atf_amc::FTypeD& row) {
    if (!zs_t_typed_InLlistQ(row)) {
        atf_amc::FTypeD* old_tail       = _db.zs_t_typed_tail;
        row.zs_t_typed_next  = NULL;
        _db.zs_t_typed_tail = &row;
        atf_amc::FTypeD **new_row_a = &old_tail->zs_t_typed_next;
        atf_amc::FTypeD **new_row_b = &_db.zs_t_typed_head;
        atf_amc::FTypeD **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zs_t_typed_n++;
    }
}

// --- atf_amc.FDb.zs_t_typed.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void atf_amc::zs_t_typed_Remove(atf_amc::FTypeD& row) {
    if (zs_t_typed_InLlistQ(row)) {
        atf_amc::FTypeD* old_head       = _db.zs_t_typed_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeD* prev=NULL;
        atf_amc::FTypeD* cur     = _db.zs_t_typed_head;
        while (cur) {  // search for element by pointer
            atf_amc::FTypeD* next = cur->zs_t_typed_next;
            if (cur == &row) {
                _db.zs_t_typed_n--;  // adjust count

                if (!next) {
                    _db.zs_t_typed_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_t_typed_next = next;
                } else {
                    _db.zs_t_typed_head = next;
                }
                row.zs_t_typed_next = (atf_amc::FTypeD*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- atf_amc.FDb.zs_t_typed.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zs_t_typed_RemoveAll() {
    atf_amc::FTypeD* row = _db.zs_t_typed_head;
    _db.zs_t_typed_head = NULL;
    _db.zs_t_typed_tail = NULL;
    _db.zs_t_typed_n = 0;
    while (row) {
        atf_amc::FTypeD* row_next = row->zs_t_typed_next;
        row->zs_t_typed_next  = (atf_amc::FTypeD*)-1;
        row = row_next;
    }
}

// --- atf_amc.FDb.zs_t_typed.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeD* atf_amc::zs_t_typed_RemoveFirst() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zs_t_typed_head;
    if (row) {
        atf_amc::FTypeD *next = row->zs_t_typed_next;
        _db.zs_t_typed_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_t_typed_tail = NULL;
        }
        _db.zs_t_typed_n--;
        row->zs_t_typed_next = (atf_amc::FTypeD*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.cd_typed.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::cd_typed_Insert(atf_amc::FTypeD& row) {
    if (!cd_typed_InLlistQ(row)) {
        if (_db.cd_typed_head) {
            row.cd_typed_next = _db.cd_typed_head;
            row.cd_typed_prev = _db.cd_typed_head->cd_typed_prev;
            row.cd_typed_prev->cd_typed_next = &row;
            row.cd_typed_next->cd_typed_prev = &row;
        } else {
            row.cd_typed_next = &row;
            row.cd_typed_prev = &row;
            _db.cd_typed_head = &row;
        }
        _db.cd_typed_n++;
    }
}

// --- atf_amc.FDb.cd_typed.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::cd_typed_Remove(atf_amc::FTypeD& row) {
    if (cd_typed_InLlistQ(row)) {
        atf_amc::FTypeD* old_head       = _db.cd_typed_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeD *oldnext = row.cd_typed_next;
        atf_amc::FTypeD *oldprev = row.cd_typed_prev;
        oldnext->cd_typed_prev = oldprev; // remove element from list
        oldprev->cd_typed_next = oldnext;
        _db.cd_typed_n--;  // adjust count
        if (&row == _db.cd_typed_head) {
            _db.cd_typed_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_typed_next = (atf_amc::FTypeD*)-1; // mark element as not-in-list);
        row.cd_typed_prev = NULL; // clear back-pointer
    }
}

// --- atf_amc.FDb.cd_typed.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::cd_typed_RemoveAll() {
    atf_amc::FTypeD* row = _db.cd_typed_head;
    atf_amc::FTypeD* head = _db.cd_typed_head;
    _db.cd_typed_head = NULL;
    _db.cd_typed_n = 0;
    while (row) {
        atf_amc::FTypeD* row_next = row->cd_typed_next;
        row->cd_typed_next  = (atf_amc::FTypeD*)-1;
        row->cd_typed_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
}

// --- atf_amc.FDb.cd_typed.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeD* atf_amc::cd_typed_RemoveFirst() {
    atf_amc::FTypeD *row = NULL;
    row = _db.cd_typed_head;
    if (row) {
        bool hasmore = row!=row->cd_typed_next;
        _db.cd_typed_head = hasmore ? row->cd_typed_next : NULL;
        row->cd_typed_next->cd_typed_prev = row->cd_typed_prev;
        row->cd_typed_prev->cd_typed_next = row->cd_typed_next;
        row->cd_typed_prev = NULL;
        _db.cd_typed_n--;
        row->cd_typed_next = (atf_amc::FTypeD*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.cd_typed.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeD* atf_amc::cd_typed_RotateFirst() {
    atf_amc::FTypeD *row = NULL;
    row = _db.cd_typed_head;
    if (row) {
        _db.cd_typed_head = row->cd_typed_next;
    }
    return row;
}

// --- atf_amc.FDb.zsl_h_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zsl_h_typec_Insert(atf_amc::FTypeC& row) {
    if (!zsl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head = _db.zsl_h_typec_head;
        row.zsl_h_typec_next  = old_head;
        _db.zsl_h_typec_head = &row;
        if (!old_head) {
            _db.zsl_h_typec_tail = &row;
        }
        _db.zsl_h_typec_n++;
        if (_db.zsl_h_typec_head == &row) {
            zsl_h_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.zsl_h_typec.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void atf_amc::zsl_h_typec_Remove(atf_amc::FTypeC& row) {
    if (zsl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.zsl_h_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC* prev=NULL;
        atf_amc::FTypeC* cur     = _db.zsl_h_typec_head;
        while (cur) {  // search for element by pointer
            atf_amc::FTypeC* next = cur->zsl_h_typec_next;
            if (cur == &row) {
                _db.zsl_h_typec_n--;  // adjust count

                if (!next) {
                    _db.zsl_h_typec_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zsl_h_typec_next = next;
                } else {
                    _db.zsl_h_typec_head = next;
                }
                row.zsl_h_typec_next = (atf_amc::FTypeC*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
        if (old_head != _db.zsl_h_typec_head) {
            zsl_h_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.zsl_h_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zsl_h_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.zsl_h_typec_head;
    _db.zsl_h_typec_head = NULL;
    _db.zsl_h_typec_tail = NULL;
    _db.zsl_h_typec_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        atf_amc::FTypeC* row_next = row->zsl_h_typec_next;
        row->zsl_h_typec_next  = (atf_amc::FTypeC*)-1;
        row = row_next;
    }
    if (do_fire) {
        zsl_h_typec_FirstChanged();
    }
}

// --- atf_amc.FDb.zsl_h_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC* atf_amc::zsl_h_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zsl_h_typec_head;
    if (row) {
        atf_amc::FTypeC *next = row->zsl_h_typec_next;
        _db.zsl_h_typec_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zsl_h_typec_tail = NULL;
        }
        _db.zsl_h_typec_n--;
        row->zsl_h_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
        zsl_h_typec_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.zsl_h_typec.UpdateCycles
// Update cycles count from previous clock capture
void atf_amc::zsl_h_typec_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_zsl_h_typec;
    atf_amc::_db.trace.step_zsl_h_typec_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.zs_t_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zs_t_typec_Insert(atf_amc::FTypeC& row) {
    if (!zs_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_tail       = _db.zs_t_typec_tail;
        row.zs_t_typec_next  = NULL;
        _db.zs_t_typec_tail = &row;
        atf_amc::FTypeC **new_row_a = &old_tail->zs_t_typec_next;
        atf_amc::FTypeC **new_row_b = &_db.zs_t_typec_head;
        atf_amc::FTypeC **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zs_t_typec_n++;
        if (_db.zs_t_typec_head == &row) {
            zs_t_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.zs_t_typec.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void atf_amc::zs_t_typec_Remove(atf_amc::FTypeC& row) {
    if (zs_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.zs_t_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC* prev=NULL;
        atf_amc::FTypeC* cur     = _db.zs_t_typec_head;
        while (cur) {  // search for element by pointer
            atf_amc::FTypeC* next = cur->zs_t_typec_next;
            if (cur == &row) {
                _db.zs_t_typec_n--;  // adjust count

                if (!next) {
                    _db.zs_t_typec_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_t_typec_next = next;
                } else {
                    _db.zs_t_typec_head = next;
                }
                row.zs_t_typec_next = (atf_amc::FTypeC*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
        if (old_head != _db.zs_t_typec_head) {
            zs_t_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.zs_t_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zs_t_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.zs_t_typec_head;
    _db.zs_t_typec_head = NULL;
    _db.zs_t_typec_tail = NULL;
    _db.zs_t_typec_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        atf_amc::FTypeC* row_next = row->zs_t_typec_next;
        row->zs_t_typec_next  = (atf_amc::FTypeC*)-1;
        row = row_next;
    }
    if (do_fire) {
        zs_t_typec_FirstChanged();
    }
}

// --- atf_amc.FDb.zs_t_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC* atf_amc::zs_t_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zs_t_typec_head;
    if (row) {
        atf_amc::FTypeC *next = row->zs_t_typec_next;
        _db.zs_t_typec_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_t_typec_tail = NULL;
        }
        _db.zs_t_typec_n--;
        row->zs_t_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
        zs_t_typec_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.zs_t_typec.UpdateCycles
// Update cycles count from previous clock capture
void atf_amc::zs_t_typec_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_zs_t_typec;
    atf_amc::_db.trace.step_zs_t_typec_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.zs_mt_typec.DestructiveFirst
// If index is empty, return NULL
// Otherwise return first key in index.
// NOTE: this function must be called from the reading thread.
// NOTE: if called from the writing thread, it might result in loss of data.
atf_amc::FTypeC* atf_amc::zs_mt_typec_DestructiveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zs_mt_typec_head;
    if (row == NULL && _db.zs_mt_typec_mt != NULL) {
        // grab elements from mt-safe portion of the linked list and reverse them.
        // due to the above if statement being not quite safe, must check if the fetched
        // value is NULL or not.
        atf_amc::FTypeC* temp = __sync_lock_test_and_set(&_db.zs_mt_typec_mt, NULL);
        if (temp) {
            do {
                atf_amc::FTypeC* next     = temp->zs_mt_typec_next;
                temp->zs_mt_typec_next = row;
                row              = temp;
                temp             = next;
            } while (temp);
        }
        // update pointer to first element.
        _db.zs_mt_typec_head = row;
    }
    return row;
}

// --- atf_amc.FDb.zs_mt_typec.Insert
// Insert row. Row must not already be in index. If row is already in index, the behavior is undefined.
void atf_amc::zs_mt_typec_Insert(atf_amc::FTypeC& row) {
    if (!zs_mt_typec_InLlistQ(row)) {
        // insertion into thread-safe linked list.
        atf_amc::FTypeC *temp = NULL;
        atf_amc::FTypeC *oldval = _db.zs_mt_typec_mt;
        do {
            temp = oldval;
            row.zs_mt_typec_next = temp;
            oldval = __sync_val_compare_and_swap(&_db.zs_mt_typec_mt, temp, &row);
        } while (oldval != temp);
    }
}

// --- atf_amc.FDb.zs_mt_typec.Remove
// If element is not in index, do nothing.
// Otherwise, throw exception: ZSListMT elements cannot
// be removed from the list except via RemoveFIrst.
void atf_amc::zs_mt_typec_Remove(atf_amc::FTypeC& row) {
    // cannot remove from ZSListMT
    // should the process die here?
    (void)_db;//only to avoid -Wunused-parameter
    (void)row;//only to avoid -Wunused-parameter
}

// --- atf_amc.FDb.zs_mt_typec.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
atf_amc::FTypeC* atf_amc::zs_mt_typec_RemoveFirst() {
    atf_amc::FTypeC *row = zs_mt_typec_DestructiveFirst();
    if (row) {
        atf_amc::FTypeC *next = row->zs_mt_typec_next;
        _db.zs_mt_typec_head = next;
        row->zs_mt_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.zdl_hnt_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zdl_hnt_typec_Insert(atf_amc::FTypeC& row) {
    if (!zdl_hnt_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head = _db.zdl_hnt_typec_head;
        row.zdl_hnt_typec_prev = NULL;
        row.zdl_hnt_typec_next = old_head;
        _db.zdl_hnt_typec_head  = &row;
        if (old_head) {
            old_head->zdl_hnt_typec_prev = &row;
        }
        _db.zdl_hnt_typec_n++;
    }
}

// --- atf_amc.FDb.zdl_hnt_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zdl_hnt_typec_Remove(atf_amc::FTypeC& row) {
    if (zdl_hnt_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.zdl_hnt_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC* prev = row.zdl_hnt_typec_prev;
        atf_amc::FTypeC* next = row.zdl_hnt_typec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeC **new_next_a = &prev->zdl_hnt_typec_next;
        atf_amc::FTypeC **new_next_b = &_db.zdl_hnt_typec_head;
        atf_amc::FTypeC **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is not last, adjust next element's prev
        if (next != NULL) {
            next->zdl_hnt_typec_prev = prev;
        }
        _db.zdl_hnt_typec_n--;
        row.zdl_hnt_typec_next=(atf_amc::FTypeC*)-1; // not-in-list
    }
}

// --- atf_amc.FDb.zdl_hnt_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zdl_hnt_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.zdl_hnt_typec_head;
    _db.zdl_hnt_typec_head = NULL;
    _db.zdl_hnt_typec_n = 0;
    while (row) {
        atf_amc::FTypeC* row_next = row->zdl_hnt_typec_next;
        row->zdl_hnt_typec_next  = (atf_amc::FTypeC*)-1;
        row->zdl_hnt_typec_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FDb.zdl_hnt_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC* atf_amc::zdl_hnt_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_hnt_typec_head;
    if (row) {
        atf_amc::FTypeC *next = row->zdl_hnt_typec_next;
        _db.zdl_hnt_typec_head = next;
        _db.zdl_hnt_typec_n--;
        row->zdl_hnt_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.cdl_h_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::cdl_h_typec_Insert(atf_amc::FTypeC& row) {
    if (!cdl_h_typec_InLlistQ(row)) {
        if (_db.cdl_h_typec_head) {
            row.cdl_h_typec_next = _db.cdl_h_typec_head;
            row.cdl_h_typec_prev = _db.cdl_h_typec_head->cdl_h_typec_prev;
            row.cdl_h_typec_prev->cdl_h_typec_next = &row;
            row.cdl_h_typec_next->cdl_h_typec_prev = &row;
            _db.cdl_h_typec_head = &row;
        } else {
            row.cdl_h_typec_next = &row;
            row.cdl_h_typec_prev = &row;
            _db.cdl_h_typec_head = &row;
        }
        _db.cdl_h_typec_n++;
    }
}

// --- atf_amc.FDb.cdl_h_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::cdl_h_typec_Remove(atf_amc::FTypeC& row) {
    if (cdl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.cdl_h_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC *oldnext = row.cdl_h_typec_next;
        atf_amc::FTypeC *oldprev = row.cdl_h_typec_prev;
        oldnext->cdl_h_typec_prev = oldprev; // remove element from list
        oldprev->cdl_h_typec_next = oldnext;
        _db.cdl_h_typec_n--;  // adjust count
        if (&row == _db.cdl_h_typec_head) {
            _db.cdl_h_typec_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cdl_h_typec_next = (atf_amc::FTypeC*)-1; // mark element as not-in-list);
        row.cdl_h_typec_prev = NULL; // clear back-pointer
    }
}

// --- atf_amc.FDb.cdl_h_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::cdl_h_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.cdl_h_typec_head;
    atf_amc::FTypeC* head = _db.cdl_h_typec_head;
    _db.cdl_h_typec_head = NULL;
    _db.cdl_h_typec_n = 0;
    while (row) {
        atf_amc::FTypeC* row_next = row->cdl_h_typec_next;
        row->cdl_h_typec_next  = (atf_amc::FTypeC*)-1;
        row->cdl_h_typec_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
}

// --- atf_amc.FDb.cdl_h_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC* atf_amc::cdl_h_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cdl_h_typec_head;
    if (row) {
        bool hasmore = row!=row->cdl_h_typec_next;
        _db.cdl_h_typec_head = hasmore ? row->cdl_h_typec_next : NULL;
        row->cdl_h_typec_next->cdl_h_typec_prev = row->cdl_h_typec_prev;
        row->cdl_h_typec_prev->cdl_h_typec_next = row->cdl_h_typec_next;
        row->cdl_h_typec_prev = NULL;
        _db.cdl_h_typec_n--;
        row->cdl_h_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.cdl_h_typec.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC* atf_amc::cdl_h_typec_RotateFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cdl_h_typec_head;
    if (row) {
        _db.cdl_h_typec_head = row->cdl_h_typec_next;
    }
    return row;
}

// --- atf_amc.FDb.cd_t_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::cd_t_typec_Insert(atf_amc::FTypeC& row) {
    if (!cd_t_typec_InLlistQ(row)) {
        if (_db.cd_t_typec_head) {
            row.cd_t_typec_next = _db.cd_t_typec_head;
            row.cd_t_typec_prev = _db.cd_t_typec_head->cd_t_typec_prev;
            row.cd_t_typec_prev->cd_t_typec_next = &row;
            row.cd_t_typec_next->cd_t_typec_prev = &row;
        } else {
            row.cd_t_typec_next = &row;
            row.cd_t_typec_prev = &row;
            _db.cd_t_typec_head = &row;
        }
        _db.cd_t_typec_n++;
    }
}

// --- atf_amc.FDb.cd_t_typec.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::cd_t_typec_Remove(atf_amc::FTypeC& row) {
    if (cd_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.cd_t_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC *oldnext = row.cd_t_typec_next;
        atf_amc::FTypeC *oldprev = row.cd_t_typec_prev;
        oldnext->cd_t_typec_prev = oldprev; // remove element from list
        oldprev->cd_t_typec_next = oldnext;
        _db.cd_t_typec_n--;  // adjust count
        if (&row == _db.cd_t_typec_head) {
            _db.cd_t_typec_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_t_typec_next = (atf_amc::FTypeC*)-1; // mark element as not-in-list);
        row.cd_t_typec_prev = NULL; // clear back-pointer
    }
}

// --- atf_amc.FDb.cd_t_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::cd_t_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.cd_t_typec_head;
    atf_amc::FTypeC* head = _db.cd_t_typec_head;
    _db.cd_t_typec_head = NULL;
    _db.cd_t_typec_n = 0;
    while (row) {
        atf_amc::FTypeC* row_next = row->cd_t_typec_next;
        row->cd_t_typec_next  = (atf_amc::FTypeC*)-1;
        row->cd_t_typec_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
}

// --- atf_amc.FDb.cd_t_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC* atf_amc::cd_t_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cd_t_typec_head;
    if (row) {
        bool hasmore = row!=row->cd_t_typec_next;
        _db.cd_t_typec_head = hasmore ? row->cd_t_typec_next : NULL;
        row->cd_t_typec_next->cd_t_typec_prev = row->cd_t_typec_prev;
        row->cd_t_typec_prev->cd_t_typec_next = row->cd_t_typec_next;
        row->cd_t_typec_prev = NULL;
        _db.cd_t_typec_n--;
        row->cd_t_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FDb.cd_t_typec.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC* atf_amc::cd_t_typec_RotateFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cd_t_typec_head;
    if (row) {
        _db.cd_t_typec_head = row->cd_t_typec_next;
    }
    return row;
}

// --- atf_amc.FDb.csl_h_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::csl_h_typec_Insert(atf_amc::FTypeC& row) {
    if (!csl_h_typec_InLlistQ(row)) {
        if (_db.csl_h_typec_head) {
            row.csl_h_typec_next = _db.csl_h_typec_head;
            _db.csl_h_typec_tail->csl_h_typec_next = &row;
            _db.csl_h_typec_head = &row;
        } else {
            row.csl_h_typec_next = &row;
            _db.csl_h_typec_head = &row;
            _db.csl_h_typec_tail = &row;
        }
        _db.csl_h_typec_n++;
        if (_db.csl_h_typec_head == &row) {
            csl_h_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.csl_h_typec.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void atf_amc::csl_h_typec_Remove(atf_amc::FTypeC& row) {
    if (csl_h_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.csl_h_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC *oldnext = row.csl_h_typec_next;
        // find previous element with linear search -- always scans the entire list
        atf_amc::FTypeC *oldprev = row.csl_h_typec_next;
        while (oldprev->csl_h_typec_next != &row) {
            oldprev = oldprev->csl_h_typec_next;
        }
        oldprev->csl_h_typec_next = oldnext;
        _db.csl_h_typec_n--;  // adjust count
        if (&row == _db.csl_h_typec_head) {
            _db.csl_h_typec_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        if (&row == _db.csl_h_typec_tail) {
            _db.csl_h_typec_tail = oldprev==&row ? NULL : oldprev; // adjust list tail
        }
        row.csl_h_typec_next = (atf_amc::FTypeC*)-1; // mark element as not-in-list);
        if (old_head != _db.csl_h_typec_head) {
            csl_h_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.csl_h_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::csl_h_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.csl_h_typec_head;
    atf_amc::FTypeC* head = _db.csl_h_typec_head;
    _db.csl_h_typec_head = NULL;
    _db.csl_h_typec_tail = NULL;
    _db.csl_h_typec_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        atf_amc::FTypeC* row_next = row->csl_h_typec_next;
        row->csl_h_typec_next  = (atf_amc::FTypeC*)-1;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        csl_h_typec_FirstChanged();
    }
}

// --- atf_amc.FDb.csl_h_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC* atf_amc::csl_h_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.csl_h_typec_head;
    if (row) {
        bool hasmore = row!=row->csl_h_typec_next;
        _db.csl_h_typec_head = hasmore ? row->csl_h_typec_next : NULL;
        _db.csl_h_typec_tail->csl_h_typec_next = row->csl_h_typec_next;
        // clear list's tail pointer if list is empty.
        if (!hasmore) {
            _db.csl_h_typec_tail = NULL;
        }
        _db.csl_h_typec_n--;
        row->csl_h_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
        csl_h_typec_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.csl_h_typec.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC* atf_amc::csl_h_typec_RotateFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.csl_h_typec_head;
    if (row) {
        _db.csl_h_typec_tail = _db.csl_h_typec_head;
        _db.csl_h_typec_head = row->csl_h_typec_next;
    }
    return row;
}

// --- atf_amc.FDb.csl_h_typec.UpdateCycles
// Update cycles count from previous clock capture
void atf_amc::csl_h_typec_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_csl_h_typec;
    atf_amc::_db.trace.step_csl_h_typec_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.cs_t_typec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::cs_t_typec_Insert(atf_amc::FTypeC& row) {
    if (!cs_t_typec_InLlistQ(row)) {
        if (_db.cs_t_typec_head) {
            row.cs_t_typec_next = _db.cs_t_typec_head;
            _db.cs_t_typec_tail->cs_t_typec_next = &row;
            _db.cs_t_typec_tail = &row;
        } else {
            row.cs_t_typec_next = &row;
            _db.cs_t_typec_head = &row;
            _db.cs_t_typec_tail = &row;
        }
        _db.cs_t_typec_n++;
        if (_db.cs_t_typec_head == &row) {
            cs_t_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.cs_t_typec.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void atf_amc::cs_t_typec_Remove(atf_amc::FTypeC& row) {
    if (cs_t_typec_InLlistQ(row)) {
        atf_amc::FTypeC* old_head       = _db.cs_t_typec_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeC *oldnext = row.cs_t_typec_next;
        // find previous element with linear search -- always scans the entire list
        atf_amc::FTypeC *oldprev = row.cs_t_typec_next;
        while (oldprev->cs_t_typec_next != &row) {
            oldprev = oldprev->cs_t_typec_next;
        }
        oldprev->cs_t_typec_next = oldnext;
        _db.cs_t_typec_n--;  // adjust count
        if (&row == _db.cs_t_typec_head) {
            _db.cs_t_typec_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        if (&row == _db.cs_t_typec_tail) {
            _db.cs_t_typec_tail = oldprev==&row ? NULL : oldprev; // adjust list tail
        }
        row.cs_t_typec_next = (atf_amc::FTypeC*)-1; // mark element as not-in-list);
        if (old_head != _db.cs_t_typec_head) {
            cs_t_typec_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.cs_t_typec.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::cs_t_typec_RemoveAll() {
    atf_amc::FTypeC* row = _db.cs_t_typec_head;
    atf_amc::FTypeC* head = _db.cs_t_typec_head;
    _db.cs_t_typec_head = NULL;
    _db.cs_t_typec_tail = NULL;
    _db.cs_t_typec_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        atf_amc::FTypeC* row_next = row->cs_t_typec_next;
        row->cs_t_typec_next  = (atf_amc::FTypeC*)-1;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cs_t_typec_FirstChanged();
    }
}

// --- atf_amc.FDb.cs_t_typec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC* atf_amc::cs_t_typec_RemoveFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cs_t_typec_head;
    if (row) {
        bool hasmore = row!=row->cs_t_typec_next;
        _db.cs_t_typec_head = hasmore ? row->cs_t_typec_next : NULL;
        _db.cs_t_typec_tail->cs_t_typec_next = row->cs_t_typec_next;
        // clear list's tail pointer if list is empty.
        if (!hasmore) {
            _db.cs_t_typec_tail = NULL;
        }
        _db.cs_t_typec_n--;
        row->cs_t_typec_next = (atf_amc::FTypeC*)-1; // mark as not-in-list
        cs_t_typec_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.cs_t_typec.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC* atf_amc::cs_t_typec_RotateFirst() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cs_t_typec_head;
    if (row) {
        _db.cs_t_typec_tail = _db.cs_t_typec_head;
        _db.cs_t_typec_head = row->cs_t_typec_next;
    }
    return row;
}

// --- atf_amc.FDb.cs_t_typec.UpdateCycles
// Update cycles count from previous clock capture
void atf_amc::cs_t_typec_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_cs_t_typec;
    atf_amc::_db.trace.step_cs_t_typec_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.typea.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeA& atf_amc::typea_Alloc() {
    atf_amc::FTypeA* row = typea_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.typea  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.typea.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeA* atf_amc::typea_AllocMaybe() {
    atf_amc::FTypeA *row = (atf_amc::FTypeA*)typea_AllocMem();
    if (row) {
        new (row) atf_amc::FTypeA; // call constructor
        row->rowid = i32(typea_N() - 1);
    }
    return row;
}

// --- atf_amc.FDb.typea.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeA* atf_amc::typea_InsertMaybe(const atf_amc::TypeA &value) {
    atf_amc::FTypeA *row = &typea_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typea_CopyIn(*row,const_cast<atf_amc::TypeA&>(value));
    bool ok = typea_XrefMaybe(*row); // this may return false
    if (!ok) {
        typea_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.typea.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::typea_AllocMem() {
    u64 new_nelems     = _db.typea_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FTypeA*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.typea_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FTypeA*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeA) * (u64(1)<<bsr));
            _db.typea_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.typea_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.typea.RemoveAll
// Remove all elements from Lary
void atf_amc::typea_RemoveAll() {
    for (u64 n = _db.typea_n; n>0; ) {
        n--;
        typea_qFind(i32(n)).~FTypeA(); // destroy last element
        _db.typea_n = i32(n);
    }
}

// --- atf_amc.FDb.typea.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::typea_RemoveLast() {
    u64 n = _db.typea_n;
    if (n > 0) {
        n -= 1;
        typea_qFind(i32(n)).~FTypeA();
        _db.typea_n = i32(n);
    }
}

// --- atf_amc.FDb.typea.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typea_XrefMaybe(atf_amc::FTypeA &row) {
    bool retval = true;
    (void)row;
    // insert typea into index ind_typea
    if (true) { // user-defined insert condition
        bool success = ind_typea_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FDb.ind_typea"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_amc.FDb.types.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeS& atf_amc::types_Alloc() {
    atf_amc::FTypeS* row = types_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.types  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.types.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeS* atf_amc::types_AllocMaybe() {
    atf_amc::FTypeS *row = (atf_amc::FTypeS*)types_AllocMem();
    if (row) {
        new (row) atf_amc::FTypeS; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.types.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeS* atf_amc::types_InsertMaybe(const atf_amc::TypeS &value) {
    atf_amc::FTypeS *row = &types_Alloc(); // if out of memory, process dies. if input error, return NULL.
    types_CopyIn(*row,const_cast<atf_amc::TypeS&>(value));
    bool ok = types_XrefMaybe(*row); // this may return false
    if (!ok) {
        types_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.types.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::types_AllocMem() {
    u64 new_nelems     = _db.types_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FTypeS*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.types_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FTypeS*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeS) * (u64(1)<<bsr));
            _db.types_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.types_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.types.RemoveAll
// Remove all elements from Lary
void atf_amc::types_RemoveAll() {
    for (u64 n = _db.types_n; n>0; ) {
        n--;
        types_qFind(u64(n)).~FTypeS(); // destroy last element
        _db.types_n = i32(n);
    }
}

// --- atf_amc.FDb.types.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::types_RemoveLast() {
    u64 n = _db.types_n;
    if (n > 0) {
        n -= 1;
        types_qFind(u64(n)).~FTypeS();
        _db.types_n = i32(n);
    }
}

// --- atf_amc.FDb.types.InputMaybe
static bool atf_amc::types_InputMaybe(atf_amc::TypeS &elem) {
    bool retval = true;
    retval = types_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- atf_amc.FDb.types.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::types_XrefMaybe(atf_amc::FTypeS &row) {
    bool retval = true;
    (void)row;
    // insert types into index ind_types
    if (true) { // user-defined insert condition
        bool success = ind_types_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FDb.ind_types"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_types.Find
// Find row by key. Return NULL if not found.
atf_amc::FTypeS* atf_amc::ind_types_Find(i32 key) {
    u32 index = ::i32_Hash(0, key) & (_db.ind_types_buckets_n - 1);
    atf_amc::FTypeS* *e = &_db.ind_types_buckets_elems[index];
    atf_amc::FTypeS* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).types == key;
        if (done) break;
        e         = &ret->ind_types_next;
    } while (true);
    return ret;
}

// --- atf_amc.FDb.ind_types.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FTypeS& atf_amc::ind_types_GetOrCreate(i32 key) {
    atf_amc::FTypeS* ret = ind_types_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &types_Alloc();
        (*ret).types = key;
        bool good = types_XrefMaybe(*ret);
        if (!good) {
            types_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "atf_amc.create_error  table:ind_types  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- atf_amc.FDb.ind_types.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_amc::ind_types_InsertMaybe(atf_amc::FTypeS& row) {
    ind_types_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_types_next == (atf_amc::FTypeS*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.types) & (_db.ind_types_buckets_n - 1);
        atf_amc::FTypeS* *prev = &_db.ind_types_buckets_elems[index];
        do {
            atf_amc::FTypeS* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).types == row.types) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_types_next;
        } while (true);
        if (retval) {
            row.ind_types_next = *prev;
            _db.ind_types_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_types.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_amc::ind_types_Remove(atf_amc::FTypeS& row) {
    if (LIKELY(row.ind_types_next != (atf_amc::FTypeS*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.types) & (_db.ind_types_buckets_n - 1);
        atf_amc::FTypeS* *prev = &_db.ind_types_buckets_elems[index]; // addr of pointer to current element
        while (atf_amc::FTypeS *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_types_next; // unlink (singly linked list)
                _db.ind_types_n--;
                row.ind_types_next = (atf_amc::FTypeS*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_types_next;
        }
    }
}

// --- atf_amc.FDb.ind_types.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_amc::ind_types_Reserve(int n) {
    u32 old_nbuckets = _db.ind_types_buckets_n;
    u32 new_nelems   = _db.ind_types_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_amc::FTypeS*);
        u32 new_size = new_nbuckets * sizeof(atf_amc::FTypeS*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_amc::FTypeS* *new_buckets = (atf_amc::FTypeS**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.ind_types");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_types_buckets_n; i++) {
            atf_amc::FTypeS* elem = _db.ind_types_buckets_elems[i];
            while (elem) {
                atf_amc::FTypeS &row        = *elem;
                atf_amc::FTypeS* next       = row.ind_types_next;
                u32 index          = ::i32_Hash(0, row.types) & (new_nbuckets-1);
                row.ind_types_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_types_buckets_elems, old_size);
        _db.ind_types_buckets_elems = new_buckets;
        _db.ind_types_buckets_n = new_nbuckets;
    }
}

// --- atf_amc.FDb.ind_typea.Find
// Find row by key. Return NULL if not found.
atf_amc::FTypeA* atf_amc::ind_typea_Find(i32 key) {
    u32 index = ::i32_Hash(0, key) & (_db.ind_typea_buckets_n - 1);
    atf_amc::FTypeA* *e = &_db.ind_typea_buckets_elems[index];
    atf_amc::FTypeA* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).typea == key;
        if (done) break;
        e         = &ret->ind_typea_next;
    } while (true);
    return ret;
}

// --- atf_amc.FDb.ind_typea.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FTypeA& atf_amc::ind_typea_GetOrCreate(i32 key) {
    atf_amc::FTypeA* ret = ind_typea_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &typea_Alloc();
        (*ret).typea = key;
        bool good = typea_XrefMaybe(*ret);
        if (!good) {
            typea_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "atf_amc.create_error  table:ind_typea  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- atf_amc.FDb.ind_typea.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_amc::ind_typea_InsertMaybe(atf_amc::FTypeA& row) {
    ind_typea_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_typea_next == (atf_amc::FTypeA*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.typea) & (_db.ind_typea_buckets_n - 1);
        atf_amc::FTypeA* *prev = &_db.ind_typea_buckets_elems[index];
        do {
            atf_amc::FTypeA* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).typea == row.typea) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_typea_next;
        } while (true);
        if (retval) {
            row.ind_typea_next = *prev;
            _db.ind_typea_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_typea.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_amc::ind_typea_Remove(atf_amc::FTypeA& row) {
    if (LIKELY(row.ind_typea_next != (atf_amc::FTypeA*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.typea) & (_db.ind_typea_buckets_n - 1);
        atf_amc::FTypeA* *prev = &_db.ind_typea_buckets_elems[index]; // addr of pointer to current element
        while (atf_amc::FTypeA *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_typea_next; // unlink (singly linked list)
                _db.ind_typea_n--;
                row.ind_typea_next = (atf_amc::FTypeA*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_typea_next;
        }
    }
}

// --- atf_amc.FDb.ind_typea.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_amc::ind_typea_Reserve(int n) {
    u32 old_nbuckets = _db.ind_typea_buckets_n;
    u32 new_nelems   = _db.ind_typea_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_amc::FTypeA*);
        u32 new_size = new_nbuckets * sizeof(atf_amc::FTypeA*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_amc::FTypeA* *new_buckets = (atf_amc::FTypeA**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.ind_typea");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_typea_buckets_n; i++) {
            atf_amc::FTypeA* elem = _db.ind_typea_buckets_elems[i];
            while (elem) {
                atf_amc::FTypeA &row        = *elem;
                atf_amc::FTypeA* next       = row.ind_typea_next;
                u32 index          = ::i32_Hash(0, row.typea) & (new_nbuckets-1);
                row.ind_typea_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_typea_buckets_elems, old_size);
        _db.ind_typea_buckets_elems = new_buckets;
        _db.ind_typea_buckets_n = new_nbuckets;
    }
}

// --- atf_amc.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     atf_amc.FDb.cmdline
//     algo_lib.FDb.cmdline
void atf_amc::ReadArgv() {
    command::atf_amc &cmd = atf_amc::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    int anonidx=0;
    algo::strptr nextanon = command::atf_amc_GetAnon(cmd, anonidx);
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::atf_amc_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"atf_amc: unknown option "<<Keyval("value",arg)<<eol;
            } else {
                if (isanon) {
                    if (attrname == nextanon) { // treat named anon (positional) argument as unnamed
                        attrname = ""; // treat it as unnamed
                    } else if (nextanon != "") { // disallow out-of-order anon (positional) args
                        err<<"atf_amc: error at "<<algo::strptr_ToSsim(arg)<<": must be preceded by [-"<<nextanon<<"]"<<eol;
                    }
                }
            }
        }
        // look up anon field name based on index
        // anon fields are only allowed in the leaf ns, never base
        if (ch_N(attrname) == 0) {
            attrname = nextanon;
            nextanon = command::atf_amc_GetAnon(cmd, ++anonidx);
            command::FieldId_ReadStrptrMaybe(attrid,attrname);
            whichns=1;
        }
        if (ch_N(attrname) == 0) {
            err << "atf_amc: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::atf_amc_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"atf_amc: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    // dmmeta.floadtuples:atf_amc.FDb.cmdline
    if (!dohelp && err=="") {
        algo_lib::ResetErrtext();
        if (!atf_amc::LoadTuplesMaybe(cmd.in,true)) {
            err << "atf_amc.load_input  "<<algo_lib::DetachBadTags()<<eol;
        }
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(atf_amc_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
}

// --- atf_amc.FDb._db.MainLoop
// Main loop.
void atf_amc::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        atf_amc::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- atf_amc.FDb._db.Step
// Main step
void atf_amc::Step() {
    bh_typec_Call();
    zsl_h_typec_Call();
    zs_t_typec_Call();
    csl_h_typec_Call();
    cs_t_typec_Call();
    cd_in_msg_Call();
}

// --- atf_amc.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void atf_amc::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("atf_amc", atf_amc::InsertStrptrMaybe, atf_amc::Step, atf_amc::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "atf_amc.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(atf_amc::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)atf_amc::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'atf_amc.Disp'  signature:'d11df8e45dfabb45e515398cd71d30a184879014'");
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'atf_amc.Msgs'  signature:'f80a13e46fff2c18de1f4dbbbb11703d07c170d2'");
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'atf_amc.Ssimfiles'  signature:'f2409fade5c9373dc13379fe888df9435e3c0987'");
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'atf_amc.Input'  signature:'3b9943558be9b03e79fade60297ec50f1d4702a3'");
}

// --- atf_amc.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool atf_amc::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    atf_amc::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case atf_amc_TableId_atf_amc_TypeS: { // finput:atf_amc.FDb.types
            atf_amc::TypeS elem;
            retval = atf_amc::TypeS_ReadStrptrMaybe(elem, str);
            retval = retval && types_InputMaybe(elem);
            break;
        }
        case atf_amc_TableId_atf_amc_TypeT: { // finput:atf_amc.FDb.typet
            atf_amc::TypeT elem;
            retval = atf_amc::TypeT_ReadStrptrMaybe(elem, str);
            retval = retval && typet_InputMaybe(elem);
            break;
        }
        default:
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- atf_amc.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool atf_amc::LoadTuplesMaybe(algo::strptr root, bool recursive) {
    bool retval = true;
    if (FileQ(root)) {
        retval = atf_amc::LoadTuplesFile(root, recursive);
    } else if (root == "-") {
        retval = atf_amc::LoadTuplesFd(algo::Fildes(0),"(stdin)",recursive);
    } else if (DirectoryQ(root)) {
        retval = retval && atf_amc::LoadTuplesFile(algo::SsimFname(root,"dmmeta.dispsigcheck"),recursive);
    } else {
        algo_lib::SaveBadTag("path", root);
        algo_lib::SaveBadTag("comment", "Wrong working directory?");
        retval = false;
    }
    return retval;
}

// --- atf_amc.FDb._db.LoadTuplesFile
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
bool atf_amc::LoadTuplesFile(algo::strptr fname, bool recursive) {
    bool retval = true;
    algo_lib::FFildes fildes;
    // missing files are not an error
    fildes.fd = OpenRead(fname,algo::FileFlags());
    if (ValidQ(fildes.fd)) {
        retval = LoadTuplesFd(fildes.fd, fname, recursive);
    }
    return retval;
}

// --- atf_amc.FDb._db.LoadTuplesFd
// Load all finputs from given file descriptor.
bool atf_amc::LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) {
    bool retval = true;
    ind_beg(algo::FileLine_curs,line,fd) {
        if (recursive) {
            retval = retval && algo_lib::InsertStrptrMaybe(line);
        }
        retval = retval && atf_amc::InsertStrptrMaybe(line);
        if (!retval) {
            algo_lib::_db.errtext << eol
            << fname << ":"
            << (ind_curs(line).i+1)
            << ": " << line << eol;
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool atf_amc::LoadSsimfileMaybe(algo::strptr fname, bool recursive) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = atf_amc::LoadTuplesFile(fname, recursive);
    }
    return retval;
}

// --- atf_amc.FDb._db.Steps
// Calls Step function of dependencies
void atf_amc::Steps() {
    atf_amc::Step(); // dependent namespace specified via (dev.targdep)
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- atf_amc.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- atf_amc.FDb.typet.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeT& atf_amc::typet_Alloc() {
    atf_amc::FTypeT* row = typet_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.typet  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.typet.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeT* atf_amc::typet_AllocMaybe() {
    atf_amc::FTypeT *row = (atf_amc::FTypeT*)typet_AllocMem();
    if (row) {
        new (row) atf_amc::FTypeT; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.typet.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeT* atf_amc::typet_InsertMaybe(const atf_amc::TypeT &value) {
    atf_amc::FTypeT *row = &typet_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typet_CopyIn(*row,const_cast<atf_amc::TypeT&>(value));
    bool ok = typet_XrefMaybe(*row); // this may return false
    if (!ok) {
        typet_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.typet.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::typet_AllocMem() {
    u64 new_nelems     = _db.typet_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FTypeT*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.typet_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FTypeT*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeT) * (u64(1)<<bsr));
            _db.typet_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.typet_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.typet.RemoveAll
// Remove all elements from Lary
void atf_amc::typet_RemoveAll() {
    for (u64 n = _db.typet_n; n>0; ) {
        n--;
        typet_qFind(u64(n)).~FTypeT(); // destroy last element
        _db.typet_n = i32(n);
    }
}

// --- atf_amc.FDb.typet.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::typet_RemoveLast() {
    u64 n = _db.typet_n;
    if (n > 0) {
        n -= 1;
        typet_qFind(u64(n)).~FTypeT();
        _db.typet_n = i32(n);
    }
}

// --- atf_amc.FDb.typet.InputMaybe
static bool atf_amc::typet_InputMaybe(atf_amc::TypeT &elem) {
    bool retval = true;
    retval = typet_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- atf_amc.FDb.typet.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typet_XrefMaybe(atf_amc::FTypeT &row) {
    bool retval = true;
    (void)row;
    atf_amc::FTypeS* p_types = atf_amc::ind_types_Find(row.types);
    if (UNLIKELY(!p_types)) {
        algo_lib::ResetErrtext() << "atf_amc.bad_xref  index:atf_amc.FDb.ind_types" << Keyval("key", row.types);
        return false;
    }
    // insert typet into index zdl_typet
    if (true) { // user-defined insert condition
        zdl_typet_Insert(*p_types, row);
    }
    return retval;
}

// --- atf_amc.FDb.cstring.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FCstring& atf_amc::cstring_Alloc() {
    atf_amc::FCstring* row = cstring_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.cstring  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.cstring.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FCstring* atf_amc::cstring_AllocMaybe() {
    atf_amc::FCstring *row = (atf_amc::FCstring*)cstring_AllocMem();
    if (row) {
        new (row) atf_amc::FCstring; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.cstring.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FCstring* atf_amc::cstring_InsertMaybe(const atf_amc::Cstring &value) {
    atf_amc::FCstring *row = &cstring_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cstring_CopyIn(*row,const_cast<atf_amc::Cstring&>(value));
    bool ok = cstring_XrefMaybe(*row); // this may return false
    if (!ok) {
        cstring_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.cstring.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::cstring_AllocMem() {
    u64 new_nelems     = _db.cstring_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FCstring*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cstring_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FCstring*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FCstring) * (u64(1)<<bsr));
            _db.cstring_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cstring_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.cstring.RemoveAll
// Remove all elements from Lary
void atf_amc::cstring_RemoveAll() {
    for (u64 n = _db.cstring_n; n>0; ) {
        n--;
        cstring_qFind(u64(n)).~FCstring(); // destroy last element
        _db.cstring_n = i32(n);
    }
}

// --- atf_amc.FDb.cstring.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::cstring_RemoveLast() {
    u64 n = _db.cstring_n;
    if (n > 0) {
        n -= 1;
        cstring_qFind(u64(n)).~FCstring();
        _db.cstring_n = i32(n);
    }
}

// --- atf_amc.FDb.cstring.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::cstring_XrefMaybe(atf_amc::FCstring &row) {
    bool retval = true;
    (void)row;
    // insert cstring into index ind_cstring
    if (true) { // user-defined insert condition
        bool success = ind_cstring_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FDb.ind_cstring"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_cstring.Find
// Find row by key. Return NULL if not found.
atf_amc::FCstring* atf_amc::ind_cstring_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_cstring_buckets_n - 1);
    atf_amc::FCstring* *e = &_db.ind_cstring_buckets_elems[index];
    atf_amc::FCstring* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).str == key;
        if (done) break;
        e         = &ret->ind_cstring_next;
    } while (true);
    return ret;
}

// --- atf_amc.FDb.ind_cstring.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FCstring& atf_amc::ind_cstring_GetOrCreate(const algo::strptr& key) {
    atf_amc::FCstring* ret = ind_cstring_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &cstring_Alloc();
        (*ret).str = key;
        bool good = cstring_XrefMaybe(*ret);
        if (!good) {
            cstring_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "atf_amc.create_error  table:ind_cstring  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- atf_amc.FDb.ind_cstring.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_amc::ind_cstring_InsertMaybe(atf_amc::FCstring& row) {
    ind_cstring_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_cstring_next == (atf_amc::FCstring*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.str) & (_db.ind_cstring_buckets_n - 1);
        atf_amc::FCstring* *prev = &_db.ind_cstring_buckets_elems[index];
        do {
            atf_amc::FCstring* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).str == row.str) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_cstring_next;
        } while (true);
        if (retval) {
            row.ind_cstring_next = *prev;
            _db.ind_cstring_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_cstring.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_amc::ind_cstring_Remove(atf_amc::FCstring& row) {
    if (LIKELY(row.ind_cstring_next != (atf_amc::FCstring*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.str) & (_db.ind_cstring_buckets_n - 1);
        atf_amc::FCstring* *prev = &_db.ind_cstring_buckets_elems[index]; // addr of pointer to current element
        while (atf_amc::FCstring *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_cstring_next; // unlink (singly linked list)
                _db.ind_cstring_n--;
                row.ind_cstring_next = (atf_amc::FCstring*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_cstring_next;
        }
    }
}

// --- atf_amc.FDb.ind_cstring.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_amc::ind_cstring_Reserve(int n) {
    u32 old_nbuckets = _db.ind_cstring_buckets_n;
    u32 new_nelems   = _db.ind_cstring_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_amc::FCstring*);
        u32 new_size = new_nbuckets * sizeof(atf_amc::FCstring*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_amc::FCstring* *new_buckets = (atf_amc::FCstring**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.ind_cstring");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_cstring_buckets_n; i++) {
            atf_amc::FCstring* elem = _db.ind_cstring_buckets_elems[i];
            while (elem) {
                atf_amc::FCstring &row        = *elem;
                atf_amc::FCstring* next       = row.ind_cstring_next;
                u32 index          = algo::cstring_Hash(0, row.str) & (new_nbuckets-1);
                row.ind_cstring_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_cstring_buckets_elems, old_size);
        _db.ind_cstring_buckets_elems = new_buckets;
        _db.ind_cstring_buckets_n = new_nbuckets;
    }
}

// --- atf_amc.FDb.msgbuf.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::msgbuf_XrefMaybe(atf_amc::Msgbuf &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.bytebuf.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::bytebuf_XrefMaybe(atf_amc::Bytebuf &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.linebuf.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::linebuf_XrefMaybe(atf_amc::Linebuf &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.cd_in_msg.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::cd_in_msg_Insert(atf_amc::Msgbuf& row) {
    if (!cd_in_msg_InLlistQ(row)) {
        if (_db.cd_in_msg_head) {
            row.cd_in_msg_next = _db.cd_in_msg_head;
            row.cd_in_msg_prev = _db.cd_in_msg_head->cd_in_msg_prev;
            row.cd_in_msg_prev->cd_in_msg_next = &row;
            row.cd_in_msg_next->cd_in_msg_prev = &row;
        } else {
            row.cd_in_msg_next = &row;
            row.cd_in_msg_prev = &row;
            _db.cd_in_msg_head = &row;
        }
        if (_db.cd_in_msg_head == &row) {
            cd_in_msg_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.cd_in_msg.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::cd_in_msg_Remove(atf_amc::Msgbuf& row) {
    if (cd_in_msg_InLlistQ(row)) {
        atf_amc::Msgbuf* old_head       = _db.cd_in_msg_head;
        (void)old_head; // in case it's not used
        atf_amc::Msgbuf *oldnext = row.cd_in_msg_next;
        atf_amc::Msgbuf *oldprev = row.cd_in_msg_prev;
        oldnext->cd_in_msg_prev = oldprev; // remove element from list
        oldprev->cd_in_msg_next = oldnext;
        if (&row == _db.cd_in_msg_head) {
            _db.cd_in_msg_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_in_msg_next = (atf_amc::Msgbuf*)-1; // mark element as not-in-list);
        row.cd_in_msg_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_in_msg_head) {
            cd_in_msg_FirstChanged();
        }
    }
}

// --- atf_amc.FDb.cd_in_msg.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::cd_in_msg_RemoveAll() {
    atf_amc::Msgbuf* row = _db.cd_in_msg_head;
    atf_amc::Msgbuf* head = _db.cd_in_msg_head;
    _db.cd_in_msg_head = NULL;
    bool do_fire = (NULL != row);
    while (row) {
        atf_amc::Msgbuf* row_next = row->cd_in_msg_next;
        row->cd_in_msg_next  = (atf_amc::Msgbuf*)-1;
        row->cd_in_msg_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_in_msg_FirstChanged();
    }
}

// --- atf_amc.FDb.cd_in_msg.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::Msgbuf* atf_amc::cd_in_msg_RemoveFirst() {
    atf_amc::Msgbuf *row = NULL;
    row = _db.cd_in_msg_head;
    if (row) {
        bool hasmore = row!=row->cd_in_msg_next;
        _db.cd_in_msg_head = hasmore ? row->cd_in_msg_next : NULL;
        row->cd_in_msg_next->cd_in_msg_prev = row->cd_in_msg_prev;
        row->cd_in_msg_prev->cd_in_msg_next = row->cd_in_msg_next;
        row->cd_in_msg_prev = NULL;
        row->cd_in_msg_next = (atf_amc::Msgbuf*)-1; // mark as not-in-list
        cd_in_msg_FirstChanged();
    }
    return row;
}

// --- atf_amc.FDb.cd_in_msg.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::Msgbuf* atf_amc::cd_in_msg_RotateFirst() {
    atf_amc::Msgbuf *row = NULL;
    row = _db.cd_in_msg_head;
    if (row) {
        _db.cd_in_msg_head = row->cd_in_msg_next;
    }
    return row;
}

// --- atf_amc.FDb.cd_in_msg.FirstChanged
// First element of index changed.
static void atf_amc::cd_in_msg_FirstChanged() {
}

// --- atf_amc.FDb.cd_in_msg.UpdateCycles
// Update cycles count from previous clock capture
inline static void atf_amc::cd_in_msg_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++atf_amc::_db.trace.step_cd_in_msg;
    atf_amc::_db.trace.step_cd_in_msg_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- atf_amc.FDb.cd_in_msg.Call
inline static void atf_amc::cd_in_msg_Call() {
    if (!atf_amc::cd_in_msg_EmptyQ()) { // fstep:atf_amc.FDb.cd_in_msg
        atf_amc::cd_in_msg_Step(); // steptype:Inline: call function on every step
        cd_in_msg_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- atf_amc.FDb.typeb.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeB& atf_amc::typeb_Alloc() {
    atf_amc::FTypeB* row = typeb_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.typeb  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.typeb.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeB* atf_amc::typeb_AllocMaybe() {
    atf_amc::FTypeB *row = (atf_amc::FTypeB*)typeb_AllocMem();
    if (row) {
        new (row) atf_amc::FTypeB; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.typeb.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeB* atf_amc::typeb_InsertMaybe(const atf_amc::TypeB &value) {
    atf_amc::FTypeB *row = &typeb_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typeb_CopyIn(*row,const_cast<atf_amc::TypeB&>(value));
    bool ok = typeb_XrefMaybe(*row); // this may return false
    if (!ok) {
        typeb_Delete(*row); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.typeb.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::typeb_Delete(atf_amc::FTypeB &row) {
    row.~FTypeB();
    typeb_FreeMem(row);
}

// --- atf_amc.FDb.typeb.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* atf_amc::typeb_AllocMem() {
    atf_amc::FTypeB *row = _db.typeb_free;
    if (UNLIKELY(!row)) {
        typeb_Reserve(1);
        row = _db.typeb_free;
    }
    if (row) {
        _db.typeb_free = row->typeb_next;
    }
    return row;
}

// --- atf_amc.FDb.typeb.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void atf_amc::typeb_FreeMem(atf_amc::FTypeB &row) {
    if (UNLIKELY(row.typeb_next != (atf_amc::FTypeB*)-1)) {
        FatalErrorExit("atf_amc.tpool_double_delete  pool:atf_amc.FDb.typeb  comment:'double deletion caught'");
    }
    row.typeb_next = _db.typeb_free; // insert into free list
    _db.typeb_free  = &row;
}

// --- atf_amc.FDb.typeb.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 atf_amc::typeb_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.typeb_blocksize; // underlying allocator is probably Lpool
        u64 reserved = typeb_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- atf_amc.FDb.typeb.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 atf_amc::typeb_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(atf_amc::FTypeB)) {
        atf_amc::FTypeB *mem = (atf_amc::FTypeB*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(atf_amc::FTypeB) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].typeb_next = _db.typeb_free;
            _db.typeb_free = mem+i;
        }
    }
    return ret;
}

// --- atf_amc.FDb.typeb.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typeb_XrefMaybe(atf_amc::FTypeB &row) {
    bool retval = true;
    (void)row;
    atf_amc::FTypeA* p_typea = atf_amc::ind_typea_Find(row.typea);
    if (UNLIKELY(!p_typea)) {
        algo_lib::ResetErrtext() << "atf_amc.bad_xref  index:atf_amc.FDb.ind_typea" << Keyval("key", row.typea);
        return false;
    }
    // insert typeb into index zdl_typeb
    if (true) { // user-defined insert condition
        zdl_typeb_Insert(*p_typea, row);
    }
    return retval;
}

// --- atf_amc.FDb.pooledbe64.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::PooledBE64& atf_amc::pooledbe64_Alloc() {
    atf_amc::PooledBE64* row = pooledbe64_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.pooledbe64  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.pooledbe64.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::PooledBE64* atf_amc::pooledbe64_AllocMaybe() {
    atf_amc::PooledBE64 *row = (atf_amc::PooledBE64*)pooledbe64_AllocMem();
    if (row) {
        new (row) atf_amc::PooledBE64; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.pooledbe64.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::pooledbe64_Delete(atf_amc::PooledBE64 &row) {
    row.~PooledBE64();
    pooledbe64_FreeMem(row);
}

// --- atf_amc.FDb.pooledbe64.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* atf_amc::pooledbe64_AllocMem() {
    atf_amc::PooledBE64 *row = _db.pooledbe64_free;
    if (UNLIKELY(!row)) {
        pooledbe64_Reserve(1);
        row = _db.pooledbe64_free;
    }
    if (row) {
        _db.pooledbe64_free = row->pooledbe64_next;
    }
    return row;
}

// --- atf_amc.FDb.pooledbe64.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void atf_amc::pooledbe64_FreeMem(atf_amc::PooledBE64 &row) {
    if (UNLIKELY(row.pooledbe64_next != (atf_amc::PooledBE64*)-1)) {
        FatalErrorExit("atf_amc.tpool_double_delete  pool:atf_amc.FDb.pooledbe64  comment:'double deletion caught'");
    }
    row.pooledbe64_next = _db.pooledbe64_free; // insert into free list
    _db.pooledbe64_free  = &row;
}

// --- atf_amc.FDb.pooledbe64.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 atf_amc::pooledbe64_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.pooledbe64_blocksize; // underlying allocator is probably Lpool
        u64 reserved = pooledbe64_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- atf_amc.FDb.pooledbe64.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 atf_amc::pooledbe64_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(atf_amc::PooledBE64)) {
        atf_amc::PooledBE64 *mem = (atf_amc::PooledBE64*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(atf_amc::PooledBE64) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].pooledbe64_next = _db.pooledbe64_free;
            _db.pooledbe64_free = mem+i;
        }
    }
    return ret;
}

// --- atf_amc.FDb.pooledbe64.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::pooledbe64_XrefMaybe(atf_amc::PooledBE64 &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.varlen_extern.FreeMem
// Free block of memory previously returned by Lpool.
void atf_amc::varlen_extern_FreeMem(void* mem, u64 size) {
    size = u64_Max(size,1ULL<<4);
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (mem && cell < 36) {
        varlen_extern_Lpblock *temp = (varlen_extern_Lpblock*)mem; // push  singly linked list
        temp->next = _db.varlen_extern_free[cell];
        _db.varlen_extern_free[cell] = temp;
        _db.varlen_extern_n--;
    }
}

// --- atf_amc.FDb.varlen_extern.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
void* atf_amc::varlen_extern_AllocMem(u64 size) {
    void *retval = NULL;
    size     = u64_Max(size,1<<4); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (cell < 36) {
        u64 i    = cell;
        // try to find a block that's at least as large as required.
        // if found, remove from free list
        for (; i < 36; i++) {
            varlen_extern_Lpblock *blk = _db.varlen_extern_free[i];
            if (blk) {
                _db.varlen_extern_free[i] = blk->next;
                retval = blk;
                break;
            }
        }
        // if suitable size block is not found, create a new one
        // by requesting a block from the base allocator.
        if (UNLIKELY(!retval)) {
            i = u64_Max(cell, 21-4); // 2MB min -- allow huge page to be used
            retval = algo_lib::malloc_AllocMem(1ULL<<(i+4));
        }
        if (LIKELY(retval)) {
            // if block is more than 2x as large as needed, return the upper half to the free
            // list (repeatedly). meanwhile, retval doesn't change.
            while (i > cell) {
                i--;
                int half = 1ULL<<(i+4);
                varlen_extern_Lpblock *blk = (varlen_extern_Lpblock*)((u8*)retval + half);
                blk->next = _db.varlen_extern_free[i];
                _db.varlen_extern_free[i] = blk;
            }
        }
        _db.varlen_extern_n += retval != NULL;
    }
    return retval;
}

// --- atf_amc.FDb.varlen_extern.ReserveBuffers
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
bool atf_amc::varlen_extern_ReserveBuffers(u64 nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 1<<4);
    u64 cell = algo::u64_BitScanReverse(bufsize-1) + 1 - 4;
    if (cell < 36) {
        for (u64 i = 0; i < nbuf; i++) {
            u64 size = 1ULL<<(cell+4);
            varlen_extern_Lpblock *temp = (varlen_extern_Lpblock*)algo_lib::malloc_AllocMem(size);
            if (temp == NULL) {
                retval = false;
                break;// why continue?
            } else {
                temp->next = _db.varlen_extern_free[cell];
                _db.varlen_extern_free[cell] = temp;
            }
        }
    }
    return retval;
}

// --- atf_amc.FDb.varlen_extern.ReallocMem
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
void* atf_amc::varlen_extern_ReallocMem(void* oldmem, u64 old_size, u64 new_size) {
    void *ret = oldmem;
    if (new_size != old_size) {
        ret = varlen_extern_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            varlen_extern_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- atf_amc.FDb.varlen_extern.Alloc
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
atf_amc::VarlenExtern& atf_amc::varlen_extern_Alloc(i32 n_varfld) {
    atf_amc::VarlenExtern* row = varlen_extern_AllocMaybe(n_varfld);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.varlen_extern  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.varlen_extern.AllocExtra
atf_amc::VarlenExtern& atf_amc::varlen_extern_AllocExtra(void *extra, i32 nbyte_extra) {
    atf_amc::VarlenExtern *row = varlen_extern_AllocExtraMaybe(extra, nbyte_extra);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.varlen_extern  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.varlen_extern.AllocExtraMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenExtern* atf_amc::varlen_extern_AllocExtraMaybe(void *extra, i32 nbyte_extra) {
    atf_amc::VarlenExtern *row = (atf_amc::VarlenExtern*)varlen_extern_AllocMem(sizeof(atf_amc::VarlenExtern) + nbyte_extra);
    if (row) {
        new (row) atf_amc::VarlenExtern; // call constructor
        length_Set(*row, u32(sizeof(atf_amc::VarlenExtern) + nbyte_extra - 0));
        if (extra) {
            memcpy((u8*)row + sizeof(atf_amc::VarlenExtern), extra, nbyte_extra);
        }
    }
    return row;
}

// --- atf_amc.FDb.varlen_extern.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::varlen_extern_Delete(atf_amc::VarlenExtern &row) {
    int length = i32(length_Get(row));
    row.~VarlenExtern();
    varlen_extern_FreeMem(&row, length);
}

// --- atf_amc.FDb.varlen_extern.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::varlen_extern_XrefMaybe(atf_amc::VarlenExtern &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.amctest.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FAmctest& atf_amc::amctest_Alloc() {
    atf_amc::FAmctest* row = amctest_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.amctest  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.amctest.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FAmctest* atf_amc::amctest_AllocMaybe() {
    atf_amc::FAmctest *row = (atf_amc::FAmctest*)amctest_AllocMem();
    if (row) {
        new (row) atf_amc::FAmctest; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.amctest.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FAmctest* atf_amc::amctest_InsertMaybe(const atfdb::Amctest &value) {
    atf_amc::FAmctest *row = &amctest_Alloc(); // if out of memory, process dies. if input error, return NULL.
    amctest_CopyIn(*row,const_cast<atfdb::Amctest&>(value));
    bool ok = amctest_XrefMaybe(*row); // this may return false
    if (!ok) {
        amctest_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.amctest.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::amctest_AllocMem() {
    u64 new_nelems     = _db.amctest_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FAmctest*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.amctest_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FAmctest*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FAmctest) * (u64(1)<<bsr));
            _db.amctest_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.amctest_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.amctest.RemoveAll
// Remove all elements from Lary
void atf_amc::amctest_RemoveAll() {
    for (u64 n = _db.amctest_n; n>0; ) {
        n--;
        amctest_qFind(u64(n)).~FAmctest(); // destroy last element
        _db.amctest_n = i32(n);
    }
}

// --- atf_amc.FDb.amctest.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::amctest_RemoveLast() {
    u64 n = _db.amctest_n;
    if (n > 0) {
        n -= 1;
        amctest_qFind(u64(n)).~FAmctest();
        _db.amctest_n = i32(n);
    }
}

// --- atf_amc.FDb.amctest.LoadStatic
static void atf_amc::amctest_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)();
    } data[] = {
        { "atfdb.amctest  amctest:AmcSort  comment:\"\"", atf_amc::amctest_AmcSort }
        ,{ "atfdb.amctest  amctest:BhFirstChanged1  comment:\"\"", atf_amc::amctest_BhFirstChanged1 }
        ,{ "atfdb.amctest  amctest:BhFirstChanged2  comment:\"Insert 100 items in ascending order -- check that trigger fires once\"", atf_amc::amctest_BhFirstChanged2 }
        ,{ "atfdb.amctest  amctest:BhFirstChanged3  comment:\"Insert 100 items in descending order -- check that trigger fires for each\"", atf_amc::amctest_BhFirstChanged3 }
        ,{ "atfdb.amctest  amctest:BheapCursor  comment:\"Test bheap cursor, cascade deletion\"", atf_amc::amctest_BheapCursor }
        ,{ "atfdb.amctest  amctest:BheapInsert100  comment:\"Ascending, descending, mixed\"", atf_amc::amctest_BheapInsert100 }
        ,{ "atfdb.amctest  amctest:BigEndian  comment:\"\"", atf_amc::amctest_BigEndian }
        ,{ "atfdb.amctest  amctest:BigendFconst  comment:\"\"", atf_amc::amctest_BigendFconst }
        ,{ "atfdb.amctest  amctest:BitfldBitset  comment:\"Test bitfield extraction/insertion when reading bitset field\"", atf_amc::amctest_BitfldBitset }
        ,{ "atfdb.amctest  amctest:BitfldNet  comment:\"Test bitfield extraction/insertion (big-endian storage)\"", atf_amc::amctest_BitfldNet }
        ,{ "atfdb.amctest  amctest:BitfldTuple  comment:\"Test bitfield extraction/insertion when reading tuple\"", atf_amc::amctest_BitfldTuple }
        ,{ "atfdb.amctest  amctest:BitsetBitcurs  comment:\"\"", atf_amc::amctest_BitsetBitcurs }
        ,{ "atfdb.amctest  amctest:BitsetInlary16  comment:\"Bitset over Inlary u16\"", atf_amc::amctest_BitsetInlary16 }
        ,{ "atfdb.amctest  amctest:BitsetTary64  comment:\"Bitset over Tary u64\"", atf_amc::amctest_BitsetTary64 }
        ,{ "atfdb.amctest  amctest:BitsetVal128  comment:\"Bitset over single u128\"", atf_amc::amctest_BitsetVal128 }
        ,{ "atfdb.amctest  amctest:BitsetVal64  comment:\"Bitset over single u64\"", atf_amc::amctest_BitsetVal64 }
        ,{ "atfdb.amctest  amctest:BitsetVal8  comment:\"Bitset over single u8\"", atf_amc::amctest_BitsetVal8 }
        ,{ "atfdb.amctest  amctest:CascdelAtree  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelAtree }
        ,{ "atfdb.amctest  amctest:CascdelBheap  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelBheap }
        ,{ "atfdb.amctest  amctest:CascdelBheapChain  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelBheapChain }
        ,{ "atfdb.amctest  amctest:CascdelPtr  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelPtr }
        ,{ "atfdb.amctest  amctest:CascdelPtrary  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelPtrary }
        ,{ "atfdb.amctest  amctest:CascdelPtraryChain  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelPtraryChain }
        ,{ "atfdb.amctest  amctest:CascdelThash  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelThash }
        ,{ "atfdb.amctest  amctest:CascdelThashChain  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelThashChain }
        ,{ "atfdb.amctest  amctest:CascdelZdlist  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelZdlist }
        ,{ "atfdb.amctest  amctest:CascdelZdlistChain  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelZdlistChain }
        ,{ "atfdb.amctest  amctest:CascdelZslist  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelZslist }
        ,{ "atfdb.amctest  amctest:CascdelZslistChain  comment:\"Test for cascade deletion\"", atf_amc::amctest_CascdelZslistChain }
        ,{ "atfdb.amctest  amctest:CastDown  comment:\"Cast from header to message\"", atf_amc::amctest_CastDown }
        ,{ "atfdb.amctest  amctest:CastDownFail  comment:\"Cast from header to unrelated message type\"", atf_amc::amctest_CastDownFail }
        ,{ "atfdb.amctest  amctest:CastDownTooShort  comment:\"Cast from header to message -- length too short\"", atf_amc::amctest_CastDownTooShort }
        ,{ "atfdb.amctest  amctest:CastUp  comment:\"Cast from message to its header\"", atf_amc::amctest_CastUp }
        ,{ "atfdb.amctest  amctest:CdlistDfltCtor  comment:\"\"", atf_amc::amctest_CdlistDfltCtor }
        ,{ "atfdb.amctest  amctest:CdlistFlush100  comment:\"\"", atf_amc::amctest_CdlistFlush100 }
        ,{ "atfdb.amctest  amctest:CdlistFlushEmpty  comment:\"\"", atf_amc::amctest_CdlistFlushEmpty }
        ,{ "atfdb.amctest  amctest:CdlistInsert1  comment:\"\"", atf_amc::amctest_CdlistInsert1 }
        ,{ "atfdb.amctest  amctest:CdlistInsert2  comment:\"\"", atf_amc::amctest_CdlistInsert2 }
        ,{ "atfdb.amctest  amctest:CdlistInsert3  comment:\"\"", atf_amc::amctest_CdlistInsert3 }
        ,{ "atfdb.amctest  amctest:CdlistInsertHead1  comment:\"\"", atf_amc::amctest_CdlistInsertHead1 }
        ,{ "atfdb.amctest  amctest:CdlistInsertHead2  comment:\"\"", atf_amc::amctest_CdlistInsertHead2 }
        ,{ "atfdb.amctest  amctest:CdlistInsertHead3  comment:\"\"", atf_amc::amctest_CdlistInsertHead3 }
        ,{ "atfdb.amctest  amctest:CdlistInsertMaybe  comment:\"\"", atf_amc::amctest_CdlistInsertMaybe }
        ,{ "atfdb.amctest  amctest:CdlistItemDfltCtor  comment:\"\"", atf_amc::amctest_CdlistItemDfltCtor }
        ,{ "atfdb.amctest  amctest:CdlistRemove  comment:\"\"", atf_amc::amctest_CdlistRemove }
        ,{ "atfdb.amctest  amctest:CdlistRemoveFirst  comment:\"\"", atf_amc::amctest_CdlistRemoveFirst }
        ,{ "atfdb.amctest  amctest:CdlistRotateFirst  comment:\"\"", atf_amc::amctest_CdlistRotateFirst }
        ,{ "atfdb.amctest  amctest:CleanupOrder  comment:\"\"", atf_amc::amctest_CleanupOrder }
        ,{ "atfdb.amctest  amctest:CopyOut1  comment:Pre-check", atf_amc::amctest_CopyOut1 }
        ,{ "atfdb.amctest  amctest:CopyOut2  comment:\"Check that derived fields were copied to base\"", atf_amc::amctest_CopyOut2 }
        ,{ "atfdb.amctest  amctest:CopyOut3  comment:\"Check that type/length fields were not copied to base\"", atf_amc::amctest_CopyOut3 }
        ,{ "atfdb.amctest  amctest:CslistFirstChangedFlush  comment:\"\"", atf_amc::amctest_CslistFirstChangedFlush }
        ,{ "atfdb.amctest  amctest:CslistFirstChangedInsert  comment:\"\"", atf_amc::amctest_CslistFirstChangedInsert }
        ,{ "atfdb.amctest  amctest:CslistFirstChangedRemove  comment:\"\"", atf_amc::amctest_CslistFirstChangedRemove }
        ,{ "atfdb.amctest  amctest:CslistFirstChangedRemoveFirst  comment:\"\"", atf_amc::amctest_CslistFirstChangedRemoveFirst }
        ,{ "atfdb.amctest  amctest:CslistHeadFirstChangedInsert  comment:\"\"", atf_amc::amctest_CslistHeadFirstChangedInsert }
        ,{ "atfdb.amctest  amctest:CslistInsert1  comment:\"\"", atf_amc::amctest_CslistInsert1 }
        ,{ "atfdb.amctest  amctest:CslistInsert2  comment:\"\"", atf_amc::amctest_CslistInsert2 }
        ,{ "atfdb.amctest  amctest:CslistInsert3  comment:\"\"", atf_amc::amctest_CslistInsert3 }
        ,{ "atfdb.amctest  amctest:CslistInsertHead1  comment:\"\"", atf_amc::amctest_CslistInsertHead1 }
        ,{ "atfdb.amctest  amctest:CslistInsertHead2  comment:\"\"", atf_amc::amctest_CslistInsertHead2 }
        ,{ "atfdb.amctest  amctest:CslistInsertHead3  comment:\"\"", atf_amc::amctest_CslistInsertHead3 }
        ,{ "atfdb.amctest  amctest:CslistRemove  comment:\"\"", atf_amc::amctest_CslistRemove }
        ,{ "atfdb.amctest  amctest:CslistRemoveFirst  comment:\"\"", atf_amc::amctest_CslistRemoveFirst }
        ,{ "atfdb.amctest  amctest:CslistRotateFirst  comment:\"\"", atf_amc::amctest_CslistRotateFirst }
        ,{ "atfdb.amctest  amctest:Delptr  comment:\"Test Delptr\"", atf_amc::amctest_Delptr }
        ,{ "atfdb.amctest  amctest:DispRead1  comment:\"Read a message containing varlen char field\"", atf_amc::amctest_DispRead1 }
        ,{ "atfdb.amctest  amctest:DispRead2  comment:\"Read a message containing several varlen fields\"", atf_amc::amctest_DispRead2 }
        ,{ "atfdb.amctest  amctest:DispRead3  comment:\"Time reading\"", atf_amc::amctest_DispRead3 }
        ,{ "atfdb.amctest  amctest:DispRead4  comment:\"Read Seqmsg with varlen payload\"", atf_amc::amctest_DispRead4 }
        ,{ "atfdb.amctest  amctest:DispReadSsimfile  comment:\"Use a Dispatch to read several tuples\"", atf_amc::amctest_DispReadSsimfile }
        ,{ "atfdb.amctest  amctest:ExecSh  comment:\"Execute subshell process\"", atf_amc::amctest_ExecSh }
        ,{ "atfdb.amctest  amctest:ExecVerbose  comment:\"Exec with verbose\"", atf_amc::amctest_ExecVerbose }
        ,{ "atfdb.amctest  amctest:Exec_Status  comment:\"Check return status of waitpid()\"", atf_amc::amctest_Exec_Status }
        ,{ "atfdb.amctest  amctest:Fcmp  comment:\"Test string comparison functions as generated with fcmp\"", atf_amc::amctest_Fcmp }
        ,{ "atfdb.amctest  amctest:Fconst  comment:\"Test for fconst\"", atf_amc::amctest_Fconst }
        ,{ "atfdb.amctest  amctest:Gsymbol  comment:\"Check gsymbol constants\"", atf_amc::amctest_Gsymbol }
        ,{ "atfdb.amctest  amctest:Hook1  comment:\"Test Hook functions\"", atf_amc::amctest_Hook1 }
        ,{ "atfdb.amctest  amctest:Hook2  comment:\"Test Hook functions\"", atf_amc::amctest_Hook2 }
        ,{ "atfdb.amctest  amctest:ImdXref  comment:\"\"", atf_amc::amctest_ImdXref }
        ,{ "atfdb.amctest  amctest:Inlary_ReadPrint  comment:\"Check Inlary read/print\"", atf_amc::amctest_Inlary_ReadPrint }
        ,{ "atfdb.amctest  amctest:LaryFind  comment:\"\"", atf_amc::amctest_LaryFind }
        ,{ "atfdb.amctest  amctest:LineIter  comment:\"Iterate over lines\"", atf_amc::amctest_LineIter }
        ,{ "atfdb.amctest  amctest:Lpool  comment:\"\"", atf_amc::amctest_Lpool }
        ,{ "atfdb.amctest  amctest:LpoolLockMem  comment:\"\"", atf_amc::amctest_LpoolLockMem }
        ,{ "atfdb.amctest  amctest:Minmax  comment:\"\"", atf_amc::amctest_Minmax }
        ,{ "atfdb.amctest  amctest:MsgCurs  comment:\"Check message cursor over memptr\"", atf_amc::amctest_MsgCurs }
        ,{ "atfdb.amctest  amctest:MsgCurs2  comment:\"\"", atf_amc::amctest_MsgCurs2 }
        ,{ "atfdb.amctest  amctest:MsgCurs3  comment:\"\"", atf_amc::amctest_MsgCurs3 }
        ,{ "atfdb.amctest  amctest:MsgCurs4  comment:\"\"", atf_amc::amctest_MsgCurs4 }
        ,{ "atfdb.amctest  amctest:MsgLength  comment:\"Check GetMsgLength, GetMsgMemptr functions\"", atf_amc::amctest_MsgLength }
        ,{ "atfdb.amctest  amctest:Numstr  comment:\"\"", atf_amc::amctest_Numstr }
        ,{ "atfdb.amctest  amctest:NumstrCorruption  comment:\"Check that corruption doesn't occur during numstr formatting.\"", atf_amc::amctest_NumstrCorruption }
        ,{ "atfdb.amctest  amctest:OptAlloc  comment:\"\"", atf_amc::amctest_OptAlloc }
        ,{ "atfdb.amctest  amctest:OptG  comment:,", atf_amc::amctest_OptG }
        ,{ "atfdb.amctest  amctest:OptG2  comment:\"Outer length too short\"", atf_amc::amctest_OptG2 }
        ,{ "atfdb.amctest  amctest:OptG8  comment:\"Construct OptG in memptr\"", atf_amc::amctest_OptG8 }
        ,{ "atfdb.amctest  amctest:OptG9  comment:\"Print struct with Opt member\"", atf_amc::amctest_OptG9 }
        ,{ "atfdb.amctest  amctest:OptOptG10  comment:\"Read struct with Opt member\"", atf_amc::amctest_OptOptG10 }
        ,{ "atfdb.amctest  amctest:OptOptG3  comment:\"Access valid opt varlen field successfully\"", atf_amc::amctest_OptOptG3 }
        ,{ "atfdb.amctest  amctest:OptOptG4  comment:\"??\"", atf_amc::amctest_OptOptG4 }
        ,{ "atfdb.amctest  amctest:OptOptG5  comment:\"Inner length too short\"", atf_amc::amctest_OptOptG5 }
        ,{ "atfdb.amctest  amctest:OptOptG6  comment:\"Inner length extends past outer length\"", atf_amc::amctest_OptOptG6 }
        ,{ "atfdb.amctest  amctest:OptOptG7  comment:\"Fetch two optional elements\"", atf_amc::amctest_OptOptG7 }
        ,{ "atfdb.amctest  amctest:OptOptG8  comment:\"Construct OptOptG in memptr\"", atf_amc::amctest_OptOptG8 }
        ,{ "atfdb.amctest  amctest:OptOptG9  comment:\"Print struct with Opt member\"", atf_amc::amctest_OptOptG9 }
        ,{ "atfdb.amctest  amctest:PerfSortString  comment:\"\"", atf_amc::amctest_PerfSortString }
        ,{ "atfdb.amctest  amctest:PerfThashRemove  comment:\"\"", atf_amc::amctest_PerfThashRemove }
        ,{ "atfdb.amctest  amctest:PmaskMultiple  comment:\"Check Pmask Multiple\"", atf_amc::amctest_PmaskMultiple }
        ,{ "atfdb.amctest  amctest:PrintBase36  comment:\"\"", atf_amc::amctest_PrintBase36 }
        ,{ "atfdb.amctest  amctest:PrintRawGconst  comment:\"Check that gconst field within tuple is printed as raw\"", atf_amc::amctest_PrintRawGconst }
        ,{ "atfdb.amctest  amctest:PtraryCursor  comment:\"Test Ptrary cursor\"", atf_amc::amctest_PtraryCursor }
        ,{ "atfdb.amctest  amctest:PtraryInsert  comment:\"Insert/Remove invariants for Ptrary\"", atf_amc::amctest_PtraryInsert }
        ,{ "atfdb.amctest  amctest:ReadProc  comment:\"Read from subprocess\"", atf_amc::amctest_ReadProc }
        ,{ "atfdb.amctest  amctest:ReadTuple1  comment:\"A single field is printed without field name\"", atf_amc::amctest_ReadTuple1 }
        ,{ "atfdb.amctest  amctest:ReadTuple2  comment:\"Two fields are printed as name-value pairs.\"", atf_amc::amctest_ReadTuple2 }
        ,{ "atfdb.amctest  amctest:ReadTuple2a  comment:\"Two anon fields are printed as name-value pairs.\"", atf_amc::amctest_ReadTuple2a }
        ,{ "atfdb.amctest  amctest:ReadTuple3  comment:Attr_curs", atf_amc::amctest_ReadTuple3 }
        ,{ "atfdb.amctest  amctest:ReadTuple4  comment:\"Attr_curs -- empty string\"", atf_amc::amctest_ReadTuple4 }
        ,{ "atfdb.amctest  amctest:ReadTuple5  comment:\"Attr_curs -- quoted strings\"", atf_amc::amctest_ReadTuple5 }
        ,{ "atfdb.amctest  amctest:Scratch  comment:\"Scratch area for new test development\"", atf_amc::amctest_Scratch }
        ,{ "atfdb.amctest  amctest:SetGetnumBase10  comment:\"\"", atf_amc::amctest_SetGetnumBase10 }
        ,{ "atfdb.amctest  amctest:SubstrDfltval  comment:\"\"", atf_amc::amctest_SubstrDfltval }
        ,{ "atfdb.amctest  amctest:TaryInit  comment:\"u32: Add element to Tary, check that it's initialized\"", atf_amc::amctest_TaryInit }
        ,{ "atfdb.amctest  amctest:TaryInit2  comment:\"u32: Add N elements to Tary, check that they're initialized\"", atf_amc::amctest_TaryInit2 }
        ,{ "atfdb.amctest  amctest:TaryInit3  comment:\"u8: Add element to Tary, check that it's initialized\"", atf_amc::amctest_TaryInit3 }
        ,{ "atfdb.amctest  amctest:TaryInit4  comment:\"u8: Add N elements to Tary, check that they're initialized\"", atf_amc::amctest_TaryInit4 }
        ,{ "atfdb.amctest  amctest:TaryReserve  comment:\"\"", atf_amc::amctest_TaryReserve }
        ,{ "atfdb.amctest  amctest:TestBitfld  comment:\"U16 bitfields: Set values, check that they were set\"", atf_amc::amctest_TestBitfld }
        ,{ "atfdb.amctest  amctest:TestBitfld2  comment:\"U128 bitfields: Set values, check that they were set\"", atf_amc::amctest_TestBitfld2 }
        ,{ "atfdb.amctest  amctest:TestCstring1  comment:\"Basic test\"", atf_amc::amctest_TestCstring1 }
        ,{ "atfdb.amctest  amctest:TestCstring2  comment:\"Insert cstring.\"", atf_amc::amctest_TestCstring2 }
        ,{ "atfdb.amctest  amctest:TestDispFilter  comment:\"DispFilter Basic Match\"", atf_amc::amctest_TestDispFilter }
        ,{ "atfdb.amctest  amctest:TestDispFilter2  comment:\"DispFilter Regx\"", atf_amc::amctest_TestDispFilter2 }
        ,{ "atfdb.amctest  amctest:TestDispFilter3  comment:\"DispFilter Explicit int field\"", atf_amc::amctest_TestDispFilter3 }
        ,{ "atfdb.amctest  amctest:TestDispFilter4  comment:\"DispFilter Date\"", atf_amc::amctest_TestDispFilter4 }
        ,{ "atfdb.amctest  amctest:TestInsertX2  comment:\"Insert instance of TypeT, xrefing with type A\"", atf_amc::amctest_TestInsertX2 }
        ,{ "atfdb.amctest  amctest:TestInsertX3  comment:\"Insert instance of TypeT, invalid xref with type A. Expect rollback\"", atf_amc::amctest_TestInsertX3 }
        ,{ "atfdb.amctest  amctest:TestPmask1  comment:\"Default ctor, check that pmask field is !PresentQ\"", atf_amc::amctest_TestPmask1 }
        ,{ "atfdb.amctest  amctest:TestPmask2  comment:\"Set field, check that field is PresentQ\"", atf_amc::amctest_TestPmask2 }
        ,{ "atfdb.amctest  amctest:TestPmask3  comment:\"Read ctype from string that doesn't have pmask field. It must be !PresentQ\"", atf_amc::amctest_TestPmask3 }
        ,{ "atfdb.amctest  amctest:TestPmask4  comment:\"Read ctype from string that has a pmask field. It must be PresentQ\"", atf_amc::amctest_TestPmask4 }
        ,{ "atfdb.amctest  amctest:TestPmask5  comment:\"Check explicitly that pmask is being updated by Set\"", atf_amc::amctest_TestPmask5 }
        ,{ "atfdb.amctest  amctest:TestPmask6  comment:\"Check that pmask isn't read from string\"", atf_amc::amctest_TestPmask6 }
        ,{ "atfdb.amctest  amctest:TestPmask7  comment:\"Check that 128-bit pmask works.\"", atf_amc::amctest_TestPmask7 }
        ,{ "atfdb.amctest  amctest:TestPmask8  comment:\"Check pmask-555.\"", atf_amc::amctest_TestPmask8 }
        ,{ "atfdb.amctest  amctest:TestRegx1  comment:\"\"", atf_amc::amctest_TestRegx1 }
        ,{ "atfdb.amctest  amctest:TestSep1  comment:\"Print Test\"", atf_amc::amctest_TestSep1 }
        ,{ "atfdb.amctest  amctest:TestSep2  comment:\"Read Test\"", atf_amc::amctest_TestSep2 }
        ,{ "atfdb.amctest  amctest:TestString  comment:\"\"", atf_amc::amctest_TestString }
        ,{ "atfdb.amctest  amctest:ThashEmpty  comment:\"\"", atf_amc::amctest_ThashEmpty }
        ,{ "atfdb.amctest  amctest:ThashFindRemove  comment:\"\"", atf_amc::amctest_ThashFindRemove }
        ,{ "atfdb.amctest  amctest:ThashGetOrCreate  comment:\"\"", atf_amc::amctest_ThashGetOrCreate }
        ,{ "atfdb.amctest  amctest:ThashInsertMaybe  comment:\"\"", atf_amc::amctest_ThashInsertMaybe }
        ,{ "atfdb.amctest  amctest:ThashRemove  comment:\"\"", atf_amc::amctest_ThashRemove }
        ,{ "atfdb.amctest  amctest:ThashXref  comment:\"\"", atf_amc::amctest_ThashXref }
        ,{ "atfdb.amctest  amctest:Typetag  comment:\"\"", atf_amc::amctest_Typetag }
        ,{ "atfdb.amctest  amctest:VarlenAlloc  comment:\"\"", atf_amc::amctest_VarlenAlloc }
        ,{ "atfdb.amctest  amctest:VarlenExternLength  comment:\"\"", atf_amc::amctest_VarlenExternLength }
        ,{ "atfdb.amctest  amctest:VarlenMsgs  comment:\"Variable-length messages (Opt+Varlen)\"", atf_amc::amctest_VarlenMsgs }
        ,{ "atfdb.amctest  amctest:VarlenMsgsPnew  comment:\"Variable-length messages (Opt+Varlen) pnew\"", atf_amc::amctest_VarlenMsgsPnew }
        ,{ "atfdb.amctest  amctest:ZdlistDelCurs  comment:\"\"", atf_amc::amctest_ZdlistDelCurs }
        ,{ "atfdb.amctest  amctest:ZdlistDfltCtor  comment:\"\"", atf_amc::amctest_ZdlistDfltCtor }
        ,{ "atfdb.amctest  amctest:ZdlistFlush100  comment:\"\"", atf_amc::amctest_ZdlistFlush100 }
        ,{ "atfdb.amctest  amctest:ZdlistFlushEmpty  comment:\"\"", atf_amc::amctest_ZdlistFlushEmpty }
        ,{ "atfdb.amctest  amctest:ZdlistInsert1  comment:\"\"", atf_amc::amctest_ZdlistInsert1 }
        ,{ "atfdb.amctest  amctest:ZdlistInsert2  comment:\"\"", atf_amc::amctest_ZdlistInsert2 }
        ,{ "atfdb.amctest  amctest:ZdlistInsert3  comment:\"\"", atf_amc::amctest_ZdlistInsert3 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHead1  comment:\"\"", atf_amc::amctest_ZdlistInsertHead1 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHead2  comment:\"\"", atf_amc::amctest_ZdlistInsertHead2 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHead3  comment:\"\"", atf_amc::amctest_ZdlistInsertHead3 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHeadNoTail1  comment:\"\"", atf_amc::amctest_ZdlistInsertHeadNoTail1 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHeadNoTail2  comment:\"\"", atf_amc::amctest_ZdlistInsertHeadNoTail2 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertHeadNoTail3  comment:\"\"", atf_amc::amctest_ZdlistInsertHeadNoTail3 }
        ,{ "atfdb.amctest  amctest:ZdlistInsertMaybe  comment:\"\"", atf_amc::amctest_ZdlistInsertMaybe }
        ,{ "atfdb.amctest  amctest:ZdlistItemDfltCtor  comment:\"\"", atf_amc::amctest_ZdlistItemDfltCtor }
        ,{ "atfdb.amctest  amctest:ZdlistRemove  comment:\"\"", atf_amc::amctest_ZdlistRemove }
        ,{ "atfdb.amctest  amctest:ZdlistRemoveFirst  comment:\"\"", atf_amc::amctest_ZdlistRemoveFirst }
        ,{ "atfdb.amctest  amctest:ZslistFirstChangedFlush  comment:\"\"", atf_amc::amctest_ZslistFirstChangedFlush }
        ,{ "atfdb.amctest  amctest:ZslistFirstChangedInsert  comment:\"\"", atf_amc::amctest_ZslistFirstChangedInsert }
        ,{ "atfdb.amctest  amctest:ZslistFirstChangedRemove  comment:\"\"", atf_amc::amctest_ZslistFirstChangedRemove }
        ,{ "atfdb.amctest  amctest:ZslistFirstChangedRemoveFirst  comment:\"\"", atf_amc::amctest_ZslistFirstChangedRemoveFirst }
        ,{ "atfdb.amctest  amctest:ZslistHeadFirstChangedInsert  comment:\"\"", atf_amc::amctest_ZslistHeadFirstChangedInsert }
        ,{ "atfdb.amctest  amctest:ZslistInsert1  comment:\"\"", atf_amc::amctest_ZslistInsert1 }
        ,{ "atfdb.amctest  amctest:ZslistInsert2  comment:\"\"", atf_amc::amctest_ZslistInsert2 }
        ,{ "atfdb.amctest  amctest:ZslistInsert3  comment:\"\"", atf_amc::amctest_ZslistInsert3 }
        ,{ "atfdb.amctest  amctest:ZslistInsertHead1  comment:\"\"", atf_amc::amctest_ZslistInsertHead1 }
        ,{ "atfdb.amctest  amctest:ZslistInsertHead2  comment:\"\"", atf_amc::amctest_ZslistInsertHead2 }
        ,{ "atfdb.amctest  amctest:ZslistInsertHead3  comment:\"\"", atf_amc::amctest_ZslistInsertHead3 }
        ,{ "atfdb.amctest  amctest:ZslistRemove  comment:\"\"", atf_amc::amctest_ZslistRemove }
        ,{ "atfdb.amctest  amctest:ZslistRemoveFirst  comment:\"\"", atf_amc::amctest_ZslistRemoveFirst }
        ,{ "atfdb.amctest  amctest:Zslistmt1  comment:\"\"", atf_amc::amctest_Zslistmt1 }
        ,{ "atfdb.amctest  amctest:Zslistmt2  comment:\"\"", atf_amc::amctest_Zslistmt2 }
        ,{ "atfdb.amctest  amctest:Zslistmt3  comment:\"\"", atf_amc::amctest_Zslistmt3 }
        ,{ "atfdb.amctest  amctest:ZslistmtDfltCtor  comment:\"\"", atf_amc::amctest_ZslistmtDfltCtor }
        ,{ "atfdb.amctest  amctest:ZslistmtItemDfltCtor  comment:\"\"", atf_amc::amctest_ZslistmtItemDfltCtor }
        ,{ "atfdb.amctest  amctest:atree_RangeSearch  comment:\"Range searching on atree\"", atf_amc::amctest_atree_RangeSearch }
        ,{ "atfdb.amctest  amctest:atree_test1  comment:\"Play with the tree, constantly verify invariants\"", atf_amc::amctest_atree_test1 }
        ,{ "atfdb.amctest  amctest:atree_test2  comment:\"Test FirstGe and LastLt\"", atf_amc::amctest_atree_test2 }
        ,{ "atfdb.amctest  amctest:bytebuf_dyn_test1  comment:\"Check buffer sizes\"", atf_amc::amctest_bytebuf_dyn_test1 }
        ,{ "atfdb.amctest  amctest:bytebuf_test1  comment:\"Initial state -- no data\"", atf_amc::amctest_bytebuf_test1 }
        ,{ "atfdb.amctest  amctest:bytebuf_test2  comment:\"Write some bytes, read back\"", atf_amc::amctest_bytebuf_test2 }
        ,{ "atfdb.amctest  amctest:fstep_Inline  comment:\"Check step type\"", atf_amc::amctest_fstep_Inline }
        ,{ "atfdb.amctest  amctest:fstep_InlineOnce  comment:\"Check step type\"", atf_amc::amctest_fstep_InlineOnce }
        ,{ "atfdb.amctest  amctest:fstep_InlineRecur  comment:\"Check step type\"", atf_amc::amctest_fstep_InlineRecur }
        ,{ "atfdb.amctest  amctest:fstep_TimeHookRecur  comment:\"Check step type\"", atf_amc::amctest_fstep_TimeHookRecur }
        ,{ "atfdb.amctest  amctest:linebuf_test1  comment:\"Initial state -- no line\"", atf_amc::amctest_linebuf_test1 }
        ,{ "atfdb.amctest  amctest:linebuf_test2  comment:\"write a line, read line back\"", atf_amc::amctest_linebuf_test2 }
        ,{ "atfdb.amctest  amctest:linebuf_test3  comment:\"write a line in two phases, no message in between\"", atf_amc::amctest_linebuf_test3 }
        ,{ "atfdb.amctest  amctest:linebuf_test4  comment:\"Write an empty line, read line back\"", atf_amc::amctest_linebuf_test4 }
        ,{ "atfdb.amctest  amctest:linebuf_test5  comment:\"Line too large -- will never fit. Set EOF\"", atf_amc::amctest_linebuf_test5 }
        ,{ "atfdb.amctest  amctest:msgbuf_extra_test  comment:\"Write messages with extra len to temp buffer and read them\"", atf_amc::amctest_msgbuf_extra_test }
        ,{ "atfdb.amctest  amctest:msgbuf_test0  comment:\"initial state - no message\"", atf_amc::amctest_msgbuf_test0 }
        ,{ "atfdb.amctest  amctest:msgbuf_test1  comment:\"write message, read message back\"", atf_amc::amctest_msgbuf_test1 }
        ,{ "atfdb.amctest  amctest:msgbuf_test10  comment:\"Force 10,000 messages of various sizes through a pipe\"", atf_amc::amctest_msgbuf_test10 }
        ,{ "atfdb.amctest  amctest:msgbuf_test1_1  comment:\"write partial message, read should fail\"", atf_amc::amctest_msgbuf_test1_1 }
        ,{ "atfdb.amctest  amctest:msgbuf_test1_2  comment:\"write message, call RemoveAll, read should fail\"", atf_amc::amctest_msgbuf_test1_2 }
        ,{ "atfdb.amctest  amctest:msgbuf_test2  comment:\"good message, then not enough data.\"", atf_amc::amctest_msgbuf_test2 }
        ,{ "atfdb.amctest  amctest:msgbuf_test3  comment:\"good message, then not enough data\"", atf_amc::amctest_msgbuf_test3 }
        ,{ "atfdb.amctest  amctest:msgbuf_test4  comment:\"message, read partial message, supply new data, read message\"", atf_amc::amctest_msgbuf_test4 }
        ,{ "atfdb.amctest  amctest:msgbuf_test5  comment:\"If GetMsg returns NULL, buffer is removed from read list\"", atf_amc::amctest_msgbuf_test5 }
        ,{ "atfdb.amctest  amctest:msgbuf_test6  comment:\"Write runt message to buffer, check that eof and error flags are set\"", atf_amc::amctest_msgbuf_test6 }
        ,{ "atfdb.amctest  amctest:msgbuf_test7  comment:\"Write HUGE message to buffer, check that error flag is set\"", atf_amc::amctest_msgbuf_test7 }
        ,{ "atfdb.amctest  amctest:msgbuf_test8  comment:\"Write message to pipe, read it\"", atf_amc::amctest_msgbuf_test8 }
        ,{ "atfdb.amctest  amctest:msgbuf_test9  comment:\"Write 2 messages to temp buffer. Feed them 1 by one through buffer\"", atf_amc::amctest_msgbuf_test9 }
        ,{NULL, NULL}
    };
    (void)data;
    atfdb::Amctest amctest;
    for (int i=0; data[i].s; i++) {
        (void)atfdb::Amctest_ReadStrptrMaybe(amctest, algo::strptr(data[i].s));
        atf_amc::FAmctest *elem = amctest_InsertMaybe(amctest);
        vrfy(elem, tempstr("atf_amc.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- atf_amc.FDb.amctest.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::amctest_XrefMaybe(atf_amc::FAmctest &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.cascdel.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FCascdel& atf_amc::cascdel_Alloc() {
    atf_amc::FCascdel* row = cascdel_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.cascdel  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.cascdel.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FCascdel* atf_amc::cascdel_AllocMaybe() {
    atf_amc::FCascdel *row = (atf_amc::FCascdel*)cascdel_AllocMem();
    if (row) {
        new (row) atf_amc::FCascdel; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.cascdel.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::cascdel_Delete(atf_amc::FCascdel &row) {
    row.~FCascdel();
    cascdel_FreeMem(row);
}

// --- atf_amc.FDb.cascdel.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* atf_amc::cascdel_AllocMem() {
    atf_amc::FCascdel *row = _db.cascdel_free;
    if (UNLIKELY(!row)) {
        cascdel_Reserve(1);
        row = _db.cascdel_free;
    }
    if (row) {
        _db.cascdel_free = row->cascdel_next;
    }
    return row;
}

// --- atf_amc.FDb.cascdel.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void atf_amc::cascdel_FreeMem(atf_amc::FCascdel &row) {
    if (UNLIKELY(row.cascdel_next != (atf_amc::FCascdel*)-1)) {
        FatalErrorExit("atf_amc.tpool_double_delete  pool:atf_amc.FDb.cascdel  comment:'double deletion caught'");
    }
    row.cascdel_next = _db.cascdel_free; // insert into free list
    _db.cascdel_free  = &row;
}

// --- atf_amc.FDb.cascdel.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 atf_amc::cascdel_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.cascdel_blocksize; // underlying allocator is probably Lpool
        u64 reserved = cascdel_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- atf_amc.FDb.cascdel.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 atf_amc::cascdel_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(atf_amc::FCascdel)) {
        atf_amc::FCascdel *mem = (atf_amc::FCascdel*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(atf_amc::FCascdel) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].cascdel_next = _db.cascdel_free;
            _db.cascdel_free = mem+i;
        }
    }
    return ret;
}

// --- atf_amc.FDb.cascdel.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::cascdel_XrefMaybe(atf_amc::FCascdel &row) {
    bool retval = true;
    (void)row;
    atf_amc::FCascdel* p_p_parent = row.p_parent;
    if (UNLIKELY(!p_p_parent)) {
        algo_lib::ResetErrtext() << "atf_amc.null_ref  xref:atf_amc.FCascdel.child_ptr";
        return false;
    }
    // insert cascdel into index child_ptr
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_ptr) { // user-defined insert condition
        bool success = child_ptr_InsertMaybe(*p_p_parent, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FCascdel.child_ptr"; // check for duplicate key
            return false;
        }
    }
    // insert cascdel into index c_child_ptrary
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_ptrary) { // user-defined insert condition
        c_child_ptrary_Insert(*p_p_parent, row);
    }
    // insert cascdel into index ind_child_thash
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_thash) { // user-defined insert condition
        bool success = ind_child_thash_InsertMaybe(*p_p_parent, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FCascdel.ind_child_thash"; // check for duplicate key
            return false;
        }
    }
    // insert cascdel into index bh_child_bheap
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap) { // user-defined insert condition
        bh_child_bheap_Insert(*p_p_parent, row);
    }
    // insert cascdel into index zd_childlist
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_zdlist) { // user-defined insert condition
        zd_childlist_Insert(*p_p_parent, row);
    }
    // insert cascdel into index tr_child_atree
    if (row.p_parent != &row && row.type==atf_amc_FCascdel_type_atree) { // user-defined insert condition
        tr_child_atree_Insert(*p_p_parent, row);
    }
    return retval;
}

// --- atf_amc.FDb.optalloc.FreeMem
// Free block of memory previously returned by Lpool.
void atf_amc::optalloc_FreeMem(void* mem, u64 size) {
    size = u64_Max(size,1ULL<<4);
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (mem && cell < 36) {
        optalloc_Lpblock *temp = (optalloc_Lpblock*)mem; // push  singly linked list
        temp->next = _db.optalloc_free[cell];
        _db.optalloc_free[cell] = temp;
        _db.optalloc_n--;
    }
}

// --- atf_amc.FDb.optalloc.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
void* atf_amc::optalloc_AllocMem(u64 size) {
    void *retval = NULL;
    size     = u64_Max(size,1<<4); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (cell < 36) {
        u64 i    = cell;
        // try to find a block that's at least as large as required.
        // if found, remove from free list
        for (; i < 36; i++) {
            optalloc_Lpblock *blk = _db.optalloc_free[i];
            if (blk) {
                _db.optalloc_free[i] = blk->next;
                retval = blk;
                break;
            }
        }
        // if suitable size block is not found, create a new one
        // by requesting a block from the base allocator.
        if (UNLIKELY(!retval)) {
            i = u64_Max(cell, 21-4); // 2MB min -- allow huge page to be used
            retval = algo_lib::malloc_AllocMem(1ULL<<(i+4));
        }
        if (LIKELY(retval)) {
            // if block is more than 2x as large as needed, return the upper half to the free
            // list (repeatedly). meanwhile, retval doesn't change.
            while (i > cell) {
                i--;
                int half = 1ULL<<(i+4);
                optalloc_Lpblock *blk = (optalloc_Lpblock*)((u8*)retval + half);
                blk->next = _db.optalloc_free[i];
                _db.optalloc_free[i] = blk;
            }
        }
        _db.optalloc_n += retval != NULL;
    }
    return retval;
}

// --- atf_amc.FDb.optalloc.ReserveBuffers
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
bool atf_amc::optalloc_ReserveBuffers(u64 nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 1<<4);
    u64 cell = algo::u64_BitScanReverse(bufsize-1) + 1 - 4;
    if (cell < 36) {
        for (u64 i = 0; i < nbuf; i++) {
            u64 size = 1ULL<<(cell+4);
            optalloc_Lpblock *temp = (optalloc_Lpblock*)algo_lib::malloc_AllocMem(size);
            if (temp == NULL) {
                retval = false;
                break;// why continue?
            } else {
                temp->next = _db.optalloc_free[cell];
                _db.optalloc_free[cell] = temp;
            }
        }
    }
    return retval;
}

// --- atf_amc.FDb.optalloc.ReallocMem
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
void* atf_amc::optalloc_ReallocMem(void* oldmem, u64 old_size, u64 new_size) {
    void *ret = oldmem;
    if (new_size != old_size) {
        ret = optalloc_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            optalloc_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- atf_amc.FDb.optalloc.AllocExtra
atf_amc::OptAlloc& atf_amc::optalloc_AllocExtra(void *extra, i32 nbyte_extra) {
    atf_amc::OptAlloc *row = optalloc_AllocExtraMaybe(extra, nbyte_extra);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.optalloc  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.optalloc.AllocExtraMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::OptAlloc* atf_amc::optalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) {
    atf_amc::OptAlloc *row = (atf_amc::OptAlloc*)optalloc_AllocMem(sizeof(atf_amc::OptAlloc) + nbyte_extra);
    if (row) {
        new (row) atf_amc::OptAlloc; // call constructor
        row->length = u32(sizeof(atf_amc::OptAlloc) + nbyte_extra - 0);
        if (extra) {
            memcpy((u8*)row + sizeof(atf_amc::OptAlloc), extra, nbyte_extra);
        }
    }
    return row;
}

// --- atf_amc.FDb.optalloc.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::optalloc_Delete(atf_amc::OptAlloc &row) {
    int length = i32(row.length);
    row.~OptAlloc();
    optalloc_FreeMem(&row, length);
}

// --- atf_amc.FDb.optalloc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::optalloc_XrefMaybe(atf_amc::OptAlloc &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.varlenalloc.FreeMem
// Free block of memory previously returned by Lpool.
void atf_amc::varlenalloc_FreeMem(void* mem, u64 size) {
    size = u64_Max(size,1ULL<<4);
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (mem && cell < 36) {
        varlenalloc_Lpblock *temp = (varlenalloc_Lpblock*)mem; // push  singly linked list
        temp->next = _db.varlenalloc_free[cell];
        _db.varlenalloc_free[cell] = temp;
        _db.varlenalloc_n--;
    }
}

// --- atf_amc.FDb.varlenalloc.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
void* atf_amc::varlenalloc_AllocMem(u64 size) {
    void *retval = NULL;
    size     = u64_Max(size,1<<4); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (cell < 36) {
        u64 i    = cell;
        // try to find a block that's at least as large as required.
        // if found, remove from free list
        for (; i < 36; i++) {
            varlenalloc_Lpblock *blk = _db.varlenalloc_free[i];
            if (blk) {
                _db.varlenalloc_free[i] = blk->next;
                retval = blk;
                break;
            }
        }
        // if suitable size block is not found, create a new one
        // by requesting a block from the base allocator.
        if (UNLIKELY(!retval)) {
            i = u64_Max(cell, 21-4); // 2MB min -- allow huge page to be used
            retval = algo_lib::malloc_AllocMem(1ULL<<(i+4));
        }
        if (LIKELY(retval)) {
            // if block is more than 2x as large as needed, return the upper half to the free
            // list (repeatedly). meanwhile, retval doesn't change.
            while (i > cell) {
                i--;
                int half = 1ULL<<(i+4);
                varlenalloc_Lpblock *blk = (varlenalloc_Lpblock*)((u8*)retval + half);
                blk->next = _db.varlenalloc_free[i];
                _db.varlenalloc_free[i] = blk;
            }
        }
        _db.varlenalloc_n += retval != NULL;
    }
    return retval;
}

// --- atf_amc.FDb.varlenalloc.ReserveBuffers
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
bool atf_amc::varlenalloc_ReserveBuffers(u64 nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 1<<4);
    u64 cell = algo::u64_BitScanReverse(bufsize-1) + 1 - 4;
    if (cell < 36) {
        for (u64 i = 0; i < nbuf; i++) {
            u64 size = 1ULL<<(cell+4);
            varlenalloc_Lpblock *temp = (varlenalloc_Lpblock*)algo_lib::malloc_AllocMem(size);
            if (temp == NULL) {
                retval = false;
                break;// why continue?
            } else {
                temp->next = _db.varlenalloc_free[cell];
                _db.varlenalloc_free[cell] = temp;
            }
        }
    }
    return retval;
}

// --- atf_amc.FDb.varlenalloc.ReallocMem
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
void* atf_amc::varlenalloc_ReallocMem(void* oldmem, u64 old_size, u64 new_size) {
    void *ret = oldmem;
    if (new_size != old_size) {
        ret = varlenalloc_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            varlenalloc_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- atf_amc.FDb.varlenalloc.Alloc
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
atf_amc::VarlenAlloc& atf_amc::varlenalloc_Alloc(i32 n_varfld) {
    atf_amc::VarlenAlloc* row = varlenalloc_AllocMaybe(n_varfld);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.varlenalloc  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.varlenalloc.AllocExtra
atf_amc::VarlenAlloc& atf_amc::varlenalloc_AllocExtra(void *extra, i32 nbyte_extra) {
    atf_amc::VarlenAlloc *row = varlenalloc_AllocExtraMaybe(extra, nbyte_extra);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.varlenalloc  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.varlenalloc.AllocExtraMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenAlloc* atf_amc::varlenalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) {
    atf_amc::VarlenAlloc *row = (atf_amc::VarlenAlloc*)varlenalloc_AllocMem(sizeof(atf_amc::VarlenAlloc) + nbyte_extra);
    if (row) {
        new (row) atf_amc::VarlenAlloc; // call constructor
        row->length = u32(sizeof(atf_amc::VarlenAlloc) + nbyte_extra - 0);
        if (extra) {
            memcpy((u8*)row + sizeof(atf_amc::VarlenAlloc), extra, nbyte_extra);
        }
    }
    return row;
}

// --- atf_amc.FDb.varlenalloc.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::varlenalloc_Delete(atf_amc::VarlenAlloc &row) {
    int length = i32(row.length);
    row.~VarlenAlloc();
    varlenalloc_FreeMem(&row, length);
}

// --- atf_amc.FDb.varlenalloc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::varlenalloc_XrefMaybe(atf_amc::VarlenAlloc &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.optg.FreeMem
// Free block of memory previously returned by Lpool.
void atf_amc::optg_FreeMem(void* mem, u64 size) {
    size = u64_Max(size,1ULL<<4);
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (mem && cell < 36) {
        optg_Lpblock *temp = (optg_Lpblock*)mem; // push  singly linked list
        temp->next = _db.optg_free[cell];
        _db.optg_free[cell] = temp;
        _db.optg_n--;
    }
}

// --- atf_amc.FDb.optg.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
void* atf_amc::optg_AllocMem(u64 size) {
    void *retval = NULL;
    size     = u64_Max(size,1<<4); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1) + 1 - 4;
    if (cell < 36) {
        u64 i    = cell;
        // try to find a block that's at least as large as required.
        // if found, remove from free list
        for (; i < 36; i++) {
            optg_Lpblock *blk = _db.optg_free[i];
            if (blk) {
                _db.optg_free[i] = blk->next;
                retval = blk;
                break;
            }
        }
        // if suitable size block is not found, create a new one
        // by requesting a block from the base allocator.
        if (UNLIKELY(!retval)) {
            i = u64_Max(cell, 21-4); // 2MB min -- allow huge page to be used
            retval = algo_lib::malloc_AllocMem(1ULL<<(i+4));
        }
        if (LIKELY(retval)) {
            // if block is more than 2x as large as needed, return the upper half to the free
            // list (repeatedly). meanwhile, retval doesn't change.
            while (i > cell) {
                i--;
                int half = 1ULL<<(i+4);
                optg_Lpblock *blk = (optg_Lpblock*)((u8*)retval + half);
                blk->next = _db.optg_free[i];
                _db.optg_free[i] = blk;
            }
        }
        _db.optg_n += retval != NULL;
    }
    return retval;
}

// --- atf_amc.FDb.optg.ReserveBuffers
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
bool atf_amc::optg_ReserveBuffers(u64 nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 1<<4);
    u64 cell = algo::u64_BitScanReverse(bufsize-1) + 1 - 4;
    if (cell < 36) {
        for (u64 i = 0; i < nbuf; i++) {
            u64 size = 1ULL<<(cell+4);
            optg_Lpblock *temp = (optg_Lpblock*)algo_lib::malloc_AllocMem(size);
            if (temp == NULL) {
                retval = false;
                break;// why continue?
            } else {
                temp->next = _db.optg_free[cell];
                _db.optg_free[cell] = temp;
            }
        }
    }
    return retval;
}

// --- atf_amc.FDb.optg.ReallocMem
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
void* atf_amc::optg_ReallocMem(void* oldmem, u64 old_size, u64 new_size) {
    void *ret = oldmem;
    if (new_size != old_size) {
        ret = optg_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            optg_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- atf_amc.FDb.optg.AllocExtra
atf_amc::FOptG& atf_amc::optg_AllocExtra(void *extra, i32 nbyte_extra) {
    atf_amc::FOptG *row = optg_AllocExtraMaybe(extra, nbyte_extra);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.optg  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.optg.AllocExtraMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FOptG* atf_amc::optg_AllocExtraMaybe(void *extra, i32 nbyte_extra) {
    atf_amc::FOptG *row = (atf_amc::FOptG*)optg_AllocMem(sizeof(atf_amc::FOptG) + nbyte_extra);
    if (row) {
        new (row) atf_amc::FOptG; // call constructor
        row->length = u32(sizeof(atf_amc::FOptG) + nbyte_extra - 0);
        if (extra) {
            memcpy((u8*)row + sizeof(atf_amc::FOptG), extra, nbyte_extra);
        }
    }
    return row;
}

// --- atf_amc.FDb.optg.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FOptG* atf_amc::optg_InsertMaybe(const atf_amc::OptG &value) {
    u8 *addon_addr = (u8*)&value + ssizeof(atf_amc::OptG);
    int addon_len = i32(value.length) - ssizeof(atf_amc::OptG);
    atf_amc::FOptG *row = &optg_AllocExtra(addon_addr, addon_len);
    optg_CopyIn(*row,const_cast<atf_amc::OptG&>(value));
    bool ok = optg_XrefMaybe(*row); // this may return false
    if (!ok) {
        optg_Delete(*row); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.optg.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::optg_Delete(atf_amc::FOptG &row) {
    int length = i32(row.length);
    row.~FOptG();
    optg_FreeMem(&row, length);
}

// --- atf_amc.FDb.optg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::optg_XrefMaybe(atf_amc::FOptG &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.c_typek.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void atf_amc::c_typek_Insert(atf_amc::FTypeK& row) {
    if (bool_Update(row._db_c_typek_in_ary,true)) {
        // reserve space
        c_typek_Reserve(1);
        u32 n  = _db.c_typek_n;
        u32 at = n;
        atf_amc::FTypeK* *elems = _db.c_typek_elems;
        elems[at] = &row;
        _db.c_typek_n = n+1;

    }
}

// --- atf_amc.FDb.c_typek.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool atf_amc::c_typek_InsertMaybe(atf_amc::FTypeK& row) {
    bool retval = !row._db_c_typek_in_ary;
    c_typek_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- atf_amc.FDb.c_typek.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void atf_amc::c_typek_Remove(atf_amc::FTypeK& row) {
    if (bool_Update(row._db_c_typek_in_ary,false)) {
        int lim = _db.c_typek_n;
        atf_amc::FTypeK* *elems = _db.c_typek_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            atf_amc::FTypeK* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(atf_amc::FTypeK*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_typek_n = lim - 1;
                break;
            }
        }
    }
}

// --- atf_amc.FDb.c_typek.Reserve
// Reserve space in index for N more elements;
void atf_amc::c_typek_Reserve(u32 n) {
    u32 old_max = _db.c_typek_max;
    if (UNLIKELY(_db.c_typek_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::FTypeK*);
        u32 new_size = new_max * sizeof(atf_amc::FTypeK*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.c_typek_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.c_typek");
        }
        _db.c_typek_elems = (atf_amc::FTypeK**)new_mem;
        _db.c_typek_max = new_max;
    }
}

// --- atf_amc.FDb.avl.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FAvl& atf_amc::avl_Alloc() {
    atf_amc::FAvl* row = avl_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.avl  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.avl.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FAvl* atf_amc::avl_AllocMaybe() {
    atf_amc::FAvl *row = (atf_amc::FAvl*)avl_AllocMem();
    if (row) {
        new (row) atf_amc::FAvl; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.avl.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::avl_AllocMem() {
    u64 new_nelems     = _db.avl_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FAvl*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.avl_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FAvl*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FAvl) * (u64(1)<<bsr));
            _db.avl_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.avl_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.avl.RemoveAll
// Remove all elements from Lary
void atf_amc::avl_RemoveAll() {
    for (u64 n = _db.avl_n; n>0; ) {
        n--;
        avl_qFind(u64(n)).~FAvl(); // destroy last element
        _db.avl_n = i32(n);
    }
}

// --- atf_amc.FDb.avl.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::avl_RemoveLast() {
    u64 n = _db.avl_n;
    if (n > 0) {
        n -= 1;
        avl_qFind(u64(n)).~FAvl();
        _db.avl_n = i32(n);
    }
}

// --- atf_amc.FDb.avl.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::avl_XrefMaybe(atf_amc::FAvl &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.tr_avl.FirstImpl
atf_amc::FAvl* atf_amc::tr_avl_FirstImpl(atf_amc::FAvl* root) {
    atf_amc::FAvl *result = root;
    while(result != NULL && result->tr_avl_left != NULL){
        result = result->tr_avl_left;
    }
    return result;
}

// --- atf_amc.FDb.tr_avl.First
// Return pointer to the first(smallest) element in the tree
atf_amc::FAvl* atf_amc::tr_avl_First() {
    return tr_avl_FirstImpl(_db.tr_avl_root);
}

// --- atf_amc.FDb.tr_avl.InsertImpl
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_amc::tr_avl_InsertImpl(atf_amc::FAvl* parent, atf_amc::FAvl& row) {
    bool left = false;
    while(parent != NULL){
        left = tr_avl_ElemLt(row, *parent);
        atf_amc::FAvl* side = left ? parent->tr_avl_left : parent->tr_avl_right;
        if(side == NULL){
            break;
        }
        parent = side;
    }
    tr_avl_Connect(parent, &row, left);
}

// --- atf_amc.FDb.tr_avl.Insert
// Insert row into the tree. If row is already in the tree, do nothing.
void atf_amc::tr_avl_Insert(atf_amc::FAvl& row) {
    if(!tr_avl_InTreeQ(row)){
        _db.tr_avl_n++;
        tr_avl_InsertImpl(_db.tr_avl_root, row);
        _db.tr_avl_root = tr_avl_Propagate(row);
    }
}

// --- atf_amc.FDb.tr_avl.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::tr_avl_Remove(atf_amc::FAvl& row) {
    if(!tr_avl_InTreeQ(row)){
        return;
    }
    atf_amc::FAvl* next = NULL;
    if(row.tr_avl_depth > 1){
        next = tr_avl_Balance(row) < 0 ? tr_avl_FirstImpl(row.tr_avl_right) : tr_avl_LastImpl(row.tr_avl_left);
        atf_amc::FAvl* leaf = tr_avl_TallerChild(*next);
        if(leaf){
            tr_avl_Turn(*leaf, *next);
        }
    }
    atf_amc::FAvl* root = row.tr_avl_up;
    atf_amc::FAvl* prop = root;//propagate point
    if(next){
        prop = next->tr_avl_up == &row ? next : next->tr_avl_up;
        tr_avl_Disconnect(*next);
        tr_avl_Connect(next, row.tr_avl_left, true);
        tr_avl_Connect(next, row.tr_avl_right, false);
    }
    bool dir = root && root->tr_avl_left == &row;
    tr_avl_Connect(root, next, dir);
    _db.tr_avl_root = prop ? tr_avl_Propagate(*prop) : NULL;
    row.tr_avl_depth = 0;
    row.tr_avl_left = NULL;
    row.tr_avl_right = NULL;
    row.tr_avl_up = (atf_amc::FAvl*)-1;
    _db.tr_avl_n--;
}

// --- atf_amc.FDb.tr_avl.RemoveFirst
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void atf_amc::tr_avl_RemoveFirst() {
    if(!tr_avl_EmptyQ()){
        tr_avl_Remove(*tr_avl_First());
    }
}

// --- atf_amc.FDb.tr_avl.Balance
i32 atf_amc::tr_avl_Balance(atf_amc::FAvl& row) {
    i32 left  = row.tr_avl_left  ? row.tr_avl_left->tr_avl_depth  : 0;
    i32 right = row.tr_avl_right ? row.tr_avl_right->tr_avl_depth : 0;
    return left - right;
}

// --- atf_amc.FDb.tr_avl.Propagate
// Recalculate depth and keep rebalancing if needed
atf_amc::FAvl* atf_amc::tr_avl_Propagate(atf_amc::FAvl& pnode) {
    atf_amc::FAvl *root = &pnode;
    atf_amc::FAvl* node = &pnode;
    while(node != NULL){
        tr_avl_updateDepth(*node);
        tr_avl_Rebalance(*node);
        root = node;
        node = node->tr_avl_up;
    }
    return root;
}

// --- atf_amc.FDb.tr_avl.TallerChild
// Returns the child that has greater height.
inline static atf_amc::FAvl* atf_amc::tr_avl_TallerChild(atf_amc::FAvl& node) {
    return tr_avl_Balance(node) < 0 ? node.tr_avl_right : node.tr_avl_left;
}

// --- atf_amc.FDb.tr_avl.Disconnect
// Disconnects the subtree(branch) from the parent
static void atf_amc::tr_avl_Disconnect(atf_amc::FAvl& node) {
    atf_amc::FAvl* parent = node.tr_avl_up;
    if(parent != NULL){
        bool left = parent->tr_avl_left == &node;
        (left ? parent->tr_avl_left : parent->tr_avl_right) = NULL;
    }
    node.tr_avl_up = NULL;
}

// --- atf_amc.FDb.tr_avl.Rebalance
// Rebalances the node if needed.
void atf_amc::tr_avl_Rebalance(atf_amc::FAvl& node) {
    if (algo::Abs(tr_avl_Balance(node)) > 1){
        atf_amc::FAvl* deep1 = tr_avl_TallerChild(node);
        atf_amc::FAvl* deep2 = tr_avl_TallerChild(*deep1);
        bool turn = tr_avl_Balance(*deep1)!=0 && (node.tr_avl_left == deep1) != (deep1->tr_avl_left == deep2);
        if(turn){
            tr_avl_Turn(*deep2, *deep1);
            algo::TSwap(deep1, deep2);
        }
        tr_avl_Turn(*deep1, node);
        tr_avl_updateDepth(node);
        tr_avl_updateDepth(*deep2);
        tr_avl_updateDepth(*deep1);
    }
}

// --- atf_amc.FDb.tr_avl.Next
atf_amc::FAvl* atf_amc::tr_avl_Next(atf_amc::FAvl& node) {
    atf_amc::FAvl *result = &node;
    if(result->tr_avl_right == NULL){
        while(result->tr_avl_up != NULL && result->tr_avl_up->tr_avl_right == result){
            result = result->tr_avl_up;
        }
        result = result->tr_avl_up;
    }else{
        result = tr_avl_FirstImpl(result->tr_avl_right);
    }
    return result;
}

// --- atf_amc.FDb.tr_avl.Prev
atf_amc::FAvl* atf_amc::tr_avl_Prev(atf_amc::FAvl& node) {
    atf_amc::FAvl *result = &node;
    if(result->tr_avl_left == NULL){
        while(result->tr_avl_up != NULL && result->tr_avl_up->tr_avl_left == result){
            result = result->tr_avl_up;
        }
        result = result->tr_avl_up;
    }else{
        result = tr_avl_LastImpl(result->tr_avl_left);
    }
    return result;
}

// --- atf_amc.FDb.tr_avl.LastImpl
atf_amc::FAvl* atf_amc::tr_avl_LastImpl(atf_amc::FAvl* root) {
    atf_amc::FAvl *result = root;
    while(result != NULL && result->tr_avl_right != NULL){
        result = result->tr_avl_right;
    }
    return result;
}

// --- atf_amc.FDb.tr_avl.Last
// Return pointer to the last(largest) element in tree
atf_amc::FAvl* atf_amc::tr_avl_Last() {
    return tr_avl_LastImpl(_db.tr_avl_root);
}

// --- atf_amc.FDb.tr_avl.ElemLt
inline static bool atf_amc::tr_avl_ElemLt(atf_amc::FAvl &a, atf_amc::FAvl &b) {
    (void)_db;
    return a.n < b.n;
}

// --- atf_amc.FDb.tr_avl.UpdateDepth
static void atf_amc::tr_avl_updateDepth(atf_amc::FAvl& node) {
    i32 ldepth = node.tr_avl_left  != NULL ? node.tr_avl_left->tr_avl_depth : 0;
    i32 rdepth = node.tr_avl_right != NULL ? node.tr_avl_right->tr_avl_depth : 0;
    node.tr_avl_depth = i32_Max(ldepth, rdepth) + 1;
}

// --- atf_amc.FDb.tr_avl.Turn
// rotates the tree in from->to direction
static void atf_amc::tr_avl_Turn(atf_amc::FAvl& from, atf_amc::FAvl& to) {
    atf_amc::FAvl* root = to.tr_avl_up;
    bool dir = root && root->tr_avl_left == &to;
    tr_avl_Connect(root, &from, dir);
    dir = to.tr_avl_left == &from;
    atf_amc::FAvl* orphan = (dir ? from.tr_avl_right : from.tr_avl_left);//other side
    tr_avl_Connect(&from, &to , !dir);
    tr_avl_Connect(&to, orphan, dir);
}

// --- atf_amc.FDb.tr_avl.Connect
inline static void atf_amc::tr_avl_Connect(atf_amc::FAvl* parent, atf_amc::FAvl* child, bool left) {
    if(parent){
        (left ? parent->tr_avl_left : parent->tr_avl_right) = child;
    }
    if(child){
        child->tr_avl_up = parent;
    }
}

// --- atf_amc.FDb.tr_avl.RemoveAllImpl
// Empty the index. (rows may be deleted if cascdel)
void atf_amc::tr_avl_RemoveAllImpl(atf_amc::FAvl* root, bool del) {
    if(root != NULL){
        tr_avl_RemoveAllImpl(root->tr_avl_left, del);
        tr_avl_RemoveAllImpl(root->tr_avl_right, del);
        tr_avl_Disconnect(*root);
        root->tr_avl_depth = 0;//the pointers are taken care of by Disconnect
        root->tr_avl_up = (atf_amc::FAvl*)-1;//the pointers are taken care of by Disconnect
    }
}

// --- atf_amc.FDb.tr_avl.Reinsert
// Reinsert a row with modified key(Reheap semantics)
void atf_amc::tr_avl_Reinsert(atf_amc::FAvl& node) {
    tr_avl_Remove(node);
    tr_avl_Insert(node);
}

// --- atf_amc.FDb.tr_avl.FirstGe
// Find the first element that is greater or equal to a sortfld value
atf_amc::FAvl* atf_amc::tr_avl_FirstGe(const i32& val) {
    atf_amc::FAvl* result = _db.tr_avl_root;
    bool left = false;
    while(result){
        left = !((*result).n < val);
        atf_amc::FAvl* side = left ? result->tr_avl_left : result->tr_avl_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && (*result).n < val){
        result = tr_avl_Next(*result);
    }
    return result;
}

// --- atf_amc.FDb.tr_avl.LastLt
// Find the last element that is smaller or equal to a sortfld value
atf_amc::FAvl* atf_amc::tr_avl_LastLt(const i32& val) {
    atf_amc::FAvl* result = _db.tr_avl_root;
    bool left = false;
    while(result){
        left = val < (*result).n;
        atf_amc::FAvl* side = left ? result->tr_avl_left : result->tr_avl_right;
        if(side==NULL){
            break;
        }
        result = side;
    }
    while(result && !((*result).n < val)){
        result = tr_avl_Prev(*result);
    }
    return result;
}

// --- atf_amc.FDb.listtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FListtype& atf_amc::listtype_Alloc() {
    atf_amc::FListtype* row = listtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.listtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.listtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FListtype* atf_amc::listtype_AllocMaybe() {
    atf_amc::FListtype *row = (atf_amc::FListtype*)listtype_AllocMem();
    if (row) {
        new (row) atf_amc::FListtype; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.listtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FListtype* atf_amc::listtype_InsertMaybe(const dmmeta::Listtype &value) {
    atf_amc::FListtype *row = &listtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    listtype_CopyIn(*row,const_cast<dmmeta::Listtype&>(value));
    bool ok = listtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.listtype.RemoveAll
// Destroy all elements of Inlary
void atf_amc::listtype_RemoveAll() {
    for (u64 n = _db.listtype_n; n>0; ) {
        n--;
        reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data)[n].~FListtype(); // destroy last element
        _db.listtype_n=n;
    }
}

// --- atf_amc.FDb.listtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::listtype_RemoveLast() {
    u64 n = _db.listtype_n;
    if (n > 0) {
        n -= 1;
        reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data)[n].~FListtype();
        _db.listtype_n = n;
    }
}

// --- atf_amc.FDb.listtype.LoadStatic
static void atf_amc::listtype_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)(atf_amc::FListtype&);
    } data[] = {
        { "dmmeta.listtype  listtype:cd  circular:Y  haveprev:Y  instail:Y  comment:\"Circular doubly-linked queue\"", atf_amc::listtype_cd }
        ,{ "dmmeta.listtype  listtype:cdl  circular:Y  haveprev:Y  instail:N  comment:\"Circular double-linked lifo (stack)\"", atf_amc::listtype_cdl }
        ,{ "dmmeta.listtype  listtype:cs  circular:Y  haveprev:N  instail:Y  comment:\"Circular singly-linked queue\"", atf_amc::listtype_cs }
        ,{ "dmmeta.listtype  listtype:csl  circular:Y  haveprev:N  instail:N  comment:\"Circular singly-linked lifo (stack)\"", atf_amc::listtype_csl }
        ,{ "dmmeta.listtype  listtype:zd  circular:N  haveprev:Y  instail:Y  comment:\"Zero-terminated doubly-linked queue\"", atf_amc::listtype_zd }
        ,{ "dmmeta.listtype  listtype:zdl  circular:N  haveprev:Y  instail:N  comment:\"Zero-terminated doubly-linked lifo (stack)\"", atf_amc::listtype_zdl }
        ,{ "dmmeta.listtype  listtype:zs  circular:N  haveprev:N  instail:Y  comment:\"Zero-terminated singly-linked queue\"", atf_amc::listtype_zs }
        ,{ "dmmeta.listtype  listtype:zsl  circular:N  haveprev:N  instail:N  comment:\"Zero-terminated singly-linked lifo (stack)\"", atf_amc::listtype_zsl }
        ,{NULL, NULL}
    };
    (void)data;
    dmmeta::Listtype listtype;
    for (int i=0; data[i].s; i++) {
        (void)dmmeta::Listtype_ReadStrptrMaybe(listtype, algo::strptr(data[i].s));
        atf_amc::FListtype *elem = listtype_InsertMaybe(listtype);
        vrfy(elem, tempstr("atf_amc.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- atf_amc.FDb.listtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::listtype_XrefMaybe(atf_amc::FListtype &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.typed.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeD& atf_amc::typed_Alloc() {
    atf_amc::FTypeD* row = typed_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.typed  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.typed.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeD* atf_amc::typed_AllocMaybe() {
    atf_amc::FTypeD *row = (atf_amc::FTypeD*)typed_AllocMem();
    if (row) {
        new (row) atf_amc::FTypeD; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.typed.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeD* atf_amc::typed_InsertMaybe(const atf_amc::TypeC &value) {
    atf_amc::FTypeD *row = &typed_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typed_CopyIn(*row,const_cast<atf_amc::TypeC&>(value));
    bool ok = typed_XrefMaybe(*row); // this may return false
    if (!ok) {
        typed_Delete(*row); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FDb.typed.Delete
// Remove row from all global and cross indices, then deallocate row
void atf_amc::typed_Delete(atf_amc::FTypeD &row) {
    row.~FTypeD();
    typed_FreeMem(row);
}

// --- atf_amc.FDb.typed.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* atf_amc::typed_AllocMem() {
    atf_amc::FTypeD *row = _db.typed_free;
    if (UNLIKELY(!row)) {
        typed_Reserve(1);
        row = _db.typed_free;
    }
    if (row) {
        _db.typed_free = row->typed_next;
    }
    return row;
}

// --- atf_amc.FDb.typed.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void atf_amc::typed_FreeMem(atf_amc::FTypeD &row) {
    if (UNLIKELY(row.typed_next != (atf_amc::FTypeD*)-1)) {
        FatalErrorExit("atf_amc.tpool_double_delete  pool:atf_amc.FDb.typed  comment:'double deletion caught'");
    }
    row.typed_next = _db.typed_free; // insert into free list
    _db.typed_free  = &row;
}

// --- atf_amc.FDb.typed.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 atf_amc::typed_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.typed_blocksize; // underlying allocator is probably Lpool
        u64 reserved = typed_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- atf_amc.FDb.typed.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 atf_amc::typed_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(atf_amc::FTypeD)) {
        atf_amc::FTypeD *mem = (atf_amc::FTypeD*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(atf_amc::FTypeD) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].typed_next = _db.typed_free;
            _db.typed_free = mem+i;
        }
    }
    return ret;
}

// --- atf_amc.FDb.typed.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typed_XrefMaybe(atf_amc::FTypeD &row) {
    bool retval = true;
    (void)row;
    // insert typed into index zd_typed
    if (true) { // user-defined insert condition
        zd_typed_Insert(row);
    }
    // insert typed into index zs_t_typed
    if (true) { // user-defined insert condition
        zs_t_typed_Insert(row);
    }
    // insert typed into index cd_typed
    if (true) { // user-defined insert condition
        cd_typed_Insert(row);
    }
    return retval;
}

// --- atf_amc.FDb.bytebuf_dyn.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::bytebuf_dyn_XrefMaybe(atf_amc::BytebufDyn &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FDb.ind_thash_elem.Find
// Find row by key. Return NULL if not found.
atf_amc::FThashElem* atf_amc::ind_thash_elem_Find(u64 key) {
    u32 index = ::u64_Hash(0, key) & (_db.ind_thash_elem_buckets_n - 1);
    atf_amc::FThashElem* *e = &_db.ind_thash_elem_buckets_elems[index];
    atf_amc::FThashElem* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).key == key;
        if (done) break;
        e         = &ret->ind_thash_elem_next;
    } while (true);
    return ret;
}

// --- atf_amc.FDb.ind_thash_elem.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FThashElem& atf_amc::ind_thash_elem_GetOrCreate(u64 key) {
    atf_amc::FThashElem* ret = ind_thash_elem_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &thash_elem_Alloc();
        (*ret).key = key;
        bool good = thash_elem_XrefMaybe(*ret);
        if (!good) {
            thash_elem_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "atf_amc.create_error  table:ind_thash_elem  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- atf_amc.FDb.ind_thash_elem.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool atf_amc::ind_thash_elem_InsertMaybe(atf_amc::FThashElem& row) {
    ind_thash_elem_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_thash_elem_next == (atf_amc::FThashElem*)-1)) {// check if in hash already
        u32 index = ::u64_Hash(0, row.key) & (_db.ind_thash_elem_buckets_n - 1);
        atf_amc::FThashElem* *prev = &_db.ind_thash_elem_buckets_elems[index];
        do {
            atf_amc::FThashElem* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).key == row.key) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_thash_elem_next;
        } while (true);
        if (retval) {
            row.ind_thash_elem_next = *prev;
            _db.ind_thash_elem_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- atf_amc.FDb.ind_thash_elem.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void atf_amc::ind_thash_elem_Remove(atf_amc::FThashElem& row) {
    if (LIKELY(row.ind_thash_elem_next != (atf_amc::FThashElem*)-1)) {// check if in hash already
        u32 index = ::u64_Hash(0, row.key) & (_db.ind_thash_elem_buckets_n - 1);
        atf_amc::FThashElem* *prev = &_db.ind_thash_elem_buckets_elems[index]; // addr of pointer to current element
        while (atf_amc::FThashElem *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_thash_elem_next; // unlink (singly linked list)
                _db.ind_thash_elem_n--;
                row.ind_thash_elem_next = (atf_amc::FThashElem*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_thash_elem_next;
        }
    }
}

// --- atf_amc.FDb.ind_thash_elem.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void atf_amc::ind_thash_elem_Reserve(int n) {
    u32 old_nbuckets = _db.ind_thash_elem_buckets_n;
    u32 new_nelems   = _db.ind_thash_elem_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(atf_amc::FThashElem*);
        u32 new_size = new_nbuckets * sizeof(atf_amc::FThashElem*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        atf_amc::FThashElem* *new_buckets = (atf_amc::FThashElem**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FDb.ind_thash_elem");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_thash_elem_buckets_n; i++) {
            atf_amc::FThashElem* elem = _db.ind_thash_elem_buckets_elems[i];
            while (elem) {
                atf_amc::FThashElem &row        = *elem;
                atf_amc::FThashElem* next       = row.ind_thash_elem_next;
                u32 index          = ::u64_Hash(0, row.key) & (new_nbuckets-1);
                row.ind_thash_elem_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_thash_elem_buckets_elems, old_size);
        _db.ind_thash_elem_buckets_elems = new_buckets;
        _db.ind_thash_elem_buckets_n = new_nbuckets;
    }
}

// --- atf_amc.FDb.ind_thash_elem.FindRemove
atf_amc::FThashElem* atf_amc::ind_thash_elem_FindRemove(u64 key) {
    u32 index = ::u64_Hash(0, key) & (_db.ind_thash_elem_buckets_n - 1);
    atf_amc::FThashElem* *prev = &_db.ind_thash_elem_buckets_elems[index];
    atf_amc::FThashElem* ret=NULL;
    do {
        ret       = *prev;
        bool done = !ret || (*ret).key == key;
        if (done) break;
        prev         = &ret->ind_thash_elem_next;
    } while (true);
    if (ret) {
        *prev = ret->ind_thash_elem_next;
        ret->ind_thash_elem_next = (atf_amc::FThashElem*)-1; // not-in-hash
        _db.ind_thash_elem_n--;
    }
    return ret;
}

// --- atf_amc.FDb.thash_elem.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FThashElem& atf_amc::thash_elem_Alloc() {
    atf_amc::FThashElem* row = thash_elem_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FDb.thash_elem  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FDb.thash_elem.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FThashElem* atf_amc::thash_elem_AllocMaybe() {
    atf_amc::FThashElem *row = (atf_amc::FThashElem*)thash_elem_AllocMem();
    if (row) {
        new (row) atf_amc::FThashElem; // call constructor
    }
    return row;
}

// --- atf_amc.FDb.thash_elem.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::thash_elem_AllocMem() {
    u64 new_nelems     = _db.thash_elem_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    atf_amc::FThashElem*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.thash_elem_lary[bsr];
        if (!lev) {
            lev=(atf_amc::FThashElem*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FThashElem) * (u64(1)<<bsr));
            _db.thash_elem_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.thash_elem_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.FDb.thash_elem.RemoveAll
// Remove all elements from Lary
void atf_amc::thash_elem_RemoveAll() {
    for (u64 n = _db.thash_elem_n; n>0; ) {
        n--;
        thash_elem_qFind(u64(n)).~FThashElem(); // destroy last element
        _db.thash_elem_n = i32(n);
    }
}

// --- atf_amc.FDb.thash_elem.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::thash_elem_RemoveLast() {
    u64 n = _db.thash_elem_n;
    if (n > 0) {
        n -= 1;
        thash_elem_qFind(u64(n)).~FThashElem();
        _db.thash_elem_n = i32(n);
    }
}

// --- atf_amc.FDb.thash_elem.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::thash_elem_XrefMaybe(atf_amc::FThashElem &row) {
    bool retval = true;
    (void)row;
    // insert thash_elem into index ind_thash_elem
    if (true) { // user-defined insert condition
        bool success = ind_thash_elem_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "atf_amc.duplicate_key  xref:atf_amc.FDb.ind_thash_elem"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- atf_amc.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr atf_amc::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- atf_amc.FDb.trace.N
// Function return 1
inline static i32 atf_amc::trace_N() {
    return 1;
}

// --- atf_amc.FDb.bh_typec_curs.Add
static void atf_amc::_db_bh_typec_curs_Add(_db_bh_typec_curs &curs, atf_amc::FTypeC& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    atf_amc::FTypeC* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        atf_amc::FTypeC* p = elems[j];
        if (!bh_typec_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- atf_amc.FDb.bh_typec_curs.Reserve
void atf_amc::_db_bh_typec_curs_Reserve(_db_bh_typec_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_typec_N();
        curs.temp_elems   = (atf_amc::FTypeC**)algo_lib::malloc_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("atf_amc.cursor_out_of_memory  func:atf_amc.FDb.bh_typec_curs.Reserve");
        }
        curs.temp_max       = bh_typec_N();
    }
}

// --- atf_amc.FDb.bh_typec_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void atf_amc::_db_bh_typec_curs_Reset(_db_bh_typec_curs &curs, atf_amc::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_typec_curs_Reserve(curs, bh_typec_N());
    curs.temp_n = 0;
    if (parent.bh_typec_n > 0) {
        atf_amc::FTypeC &first = *parent.bh_typec_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- atf_amc.FDb.bh_typec_curs.Next
// Advance cursor.
void atf_amc::_db_bh_typec_curs_Next(_db_bh_typec_curs &curs) {
    atf_amc::FTypeC* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        atf_amc::FTypeC* dead = elems[0];
        int i       = 0;
        atf_amc::FTypeC* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            atf_amc::FTypeC* choose = last;
            int l         = i*2+1;
            if (l<n) {
                atf_amc::FTypeC* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                atf_amc::FTypeC* er = elems[r];
                if (bh_typec_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_typec_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_typec_idx;
        i = (index*2+1);
        if (i < bh_typec_N()) {
            atf_amc::FTypeC &elem = *curs.parent->bh_typec_elems[i];
            _db_bh_typec_curs_Add(curs, elem);
        }
        if (i+1 < bh_typec_N()) {
            atf_amc::FTypeC &elem = *curs.parent->bh_typec_elems[i + 1];
            _db_bh_typec_curs_Add(curs, elem);
        }
    }
}

// --- atf_amc.FDb..Init
// Set all fields to initial values.
void atf_amc::FDb_Init() {
    _db.bh_typec_max   	= 0; // (atf_amc.FDb.bh_typec)
    _db.bh_typec_n     	= 0; // (atf_amc.FDb.bh_typec)
    _db.bh_typec_elems 	= NULL; // (atf_amc.FDb.bh_typec)
    _db.zdl_h_typec_head = NULL; // (atf_amc.FDb.zdl_h_typec)
    _db.zdl_h_typec_n = 0; // (atf_amc.FDb.zdl_h_typec)
    _db.zdl_h_typec_tail = NULL; // (atf_amc.FDb.zdl_h_typec)
    _db.zd_t_typec_head = NULL; // (atf_amc.FDb.zd_t_typec)
    _db.zd_t_typec_n = 0; // (atf_amc.FDb.zd_t_typec)
    _db.zd_t_typec_tail = NULL; // (atf_amc.FDb.zd_t_typec)
    _db.zd_typed_head = NULL; // (atf_amc.FDb.zd_typed)
    _db.zd_typed_n = 0; // (atf_amc.FDb.zd_typed)
    _db.zd_typed_tail = NULL; // (atf_amc.FDb.zd_typed)
    _db.zs_t_typed_head = NULL; // (atf_amc.FDb.zs_t_typed)
    _db.zs_t_typed_n = 0; // (atf_amc.FDb.zs_t_typed)
    _db.zs_t_typed_tail = NULL; // (atf_amc.FDb.zs_t_typed)
    _db.cd_typed_head = NULL; // (atf_amc.FDb.cd_typed)
    _db.cd_typed_n = 0; // (atf_amc.FDb.cd_typed)
    _db.zsl_h_typec_head = NULL; // (atf_amc.FDb.zsl_h_typec)
    _db.zsl_h_typec_n = 0; // (atf_amc.FDb.zsl_h_typec)
    _db.zsl_h_typec_tail = NULL; // (atf_amc.FDb.zsl_h_typec)
    _db.zs_t_typec_head = NULL; // (atf_amc.FDb.zs_t_typec)
    _db.zs_t_typec_n = 0; // (atf_amc.FDb.zs_t_typec)
    _db.zs_t_typec_tail = NULL; // (atf_amc.FDb.zs_t_typec)
    _db.zs_mt_typec_head = NULL; // (atf_amc.FDb.zs_mt_typec)
    _db.zs_mt_typec_mt = NULL; // (atf_amc.FDb.zs_mt_typec)
    _db.zdl_hnt_typec_head = NULL; // (atf_amc.FDb.zdl_hnt_typec)
    _db.zdl_hnt_typec_n = 0; // (atf_amc.FDb.zdl_hnt_typec)
    _db.cdl_h_typec_head = NULL; // (atf_amc.FDb.cdl_h_typec)
    _db.cdl_h_typec_n = 0; // (atf_amc.FDb.cdl_h_typec)
    _db.cd_t_typec_head = NULL; // (atf_amc.FDb.cd_t_typec)
    _db.cd_t_typec_n = 0; // (atf_amc.FDb.cd_t_typec)
    _db.csl_h_typec_head = NULL; // (atf_amc.FDb.csl_h_typec)
    _db.csl_h_typec_n = 0; // (atf_amc.FDb.csl_h_typec)
    _db.csl_h_typec_tail = NULL; // (atf_amc.FDb.csl_h_typec)
    _db.cs_t_typec_head = NULL; // (atf_amc.FDb.cs_t_typec)
    _db.cs_t_typec_n = 0; // (atf_amc.FDb.cs_t_typec)
    _db.cs_t_typec_tail = NULL; // (atf_amc.FDb.cs_t_typec)
    // initialize LAry typea (atf_amc.FDb.typea)
    _db.typea_n = 0;
    memset(_db.typea_lary, 0, sizeof(_db.typea_lary)); // zero out all level pointers
    atf_amc::FTypeA* typea_first = (atf_amc::FTypeA*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeA) * (u64(1)<<4));
    if (!typea_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.typea_lary[i]  = typea_first;
        typea_first    += 1ULL<<i;
    }
    // initialize LAry types (atf_amc.FDb.types)
    _db.types_n = 0;
    memset(_db.types_lary, 0, sizeof(_db.types_lary)); // zero out all level pointers
    atf_amc::FTypeS* types_first = (atf_amc::FTypeS*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeS) * (u64(1)<<4));
    if (!types_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.types_lary[i]  = types_first;
        types_first    += 1ULL<<i;
    }
    // initialize hash table for atf_amc::FTypeS;
    _db.ind_types_n             	= 0; // (atf_amc.FDb.ind_types)
    _db.ind_types_buckets_n     	= 4; // (atf_amc.FDb.ind_types)
    _db.ind_types_buckets_elems 	= (atf_amc::FTypeS**)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeS*)*_db.ind_types_buckets_n); // initial buckets (atf_amc.FDb.ind_types)
    if (!_db.ind_types_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_amc.FDb.ind_types)
    }
    memset(_db.ind_types_buckets_elems, 0, sizeof(atf_amc::FTypeS*)*_db.ind_types_buckets_n); // (atf_amc.FDb.ind_types)
    // initialize hash table for atf_amc::FTypeA;
    _db.ind_typea_n             	= 0; // (atf_amc.FDb.ind_typea)
    _db.ind_typea_buckets_n     	= 4; // (atf_amc.FDb.ind_typea)
    _db.ind_typea_buckets_elems 	= (atf_amc::FTypeA**)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeA*)*_db.ind_typea_buckets_n); // initial buckets (atf_amc.FDb.ind_typea)
    if (!_db.ind_typea_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_amc.FDb.ind_typea)
    }
    memset(_db.ind_typea_buckets_elems, 0, sizeof(atf_amc::FTypeA*)*_db.ind_typea_buckets_n); // (atf_amc.FDb.ind_typea)
    _db.cs_h_count = i32(0);
    _db.cs_t_count = i32(0);
    _db.zs_h_count = i32(0);
    _db.zs_t_count = i32(0);
    _db.zs_mt_count = i32(0);
    _db.bh_count = i32(0);
    // initialize LAry typet (atf_amc.FDb.typet)
    _db.typet_n = 0;
    memset(_db.typet_lary, 0, sizeof(_db.typet_lary)); // zero out all level pointers
    atf_amc::FTypeT* typet_first = (atf_amc::FTypeT*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FTypeT) * (u64(1)<<4));
    if (!typet_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.typet_lary[i]  = typet_first;
        typet_first    += 1ULL<<i;
    }
    // initialize LAry cstring (atf_amc.FDb.cstring)
    _db.cstring_n = 0;
    memset(_db.cstring_lary, 0, sizeof(_db.cstring_lary)); // zero out all level pointers
    atf_amc::FCstring* cstring_first = (atf_amc::FCstring*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FCstring) * (u64(1)<<4));
    if (!cstring_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cstring_lary[i]  = cstring_first;
        cstring_first    += 1ULL<<i;
    }
    // initialize hash table for atf_amc::FCstring;
    _db.ind_cstring_n             	= 0; // (atf_amc.FDb.ind_cstring)
    _db.ind_cstring_buckets_n     	= 4; // (atf_amc.FDb.ind_cstring)
    _db.ind_cstring_buckets_elems 	= (atf_amc::FCstring**)algo_lib::malloc_AllocMem(sizeof(atf_amc::FCstring*)*_db.ind_cstring_buckets_n); // initial buckets (atf_amc.FDb.ind_cstring)
    if (!_db.ind_cstring_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_amc.FDb.ind_cstring)
    }
    memset(_db.ind_cstring_buckets_elems, 0, sizeof(atf_amc::FCstring*)*_db.ind_cstring_buckets_n); // (atf_amc.FDb.ind_cstring)
    _db.cd_in_msg_head = NULL; // (atf_amc.FDb.cd_in_msg)
    // typeb: initialize Tpool
    _db.typeb_free      = NULL;
    _db.typeb_blocksize = algo::BumpToPow2(64 * sizeof(atf_amc::FTypeB)); // allocate 64-127 elements at a time
    // pooledbe64: initialize Tpool
    _db.pooledbe64_free      = NULL;
    _db.pooledbe64_blocksize = algo::BumpToPow2(64 * sizeof(atf_amc::PooledBE64)); // allocate 64-127 elements at a time
    memset(_db.varlen_extern_free, 0, sizeof(_db.varlen_extern_free));
    _db.varlen_extern_n = 0;
    // initialize LAry amctest (atf_amc.FDb.amctest)
    _db.amctest_n = 0;
    memset(_db.amctest_lary, 0, sizeof(_db.amctest_lary)); // zero out all level pointers
    atf_amc::FAmctest* amctest_first = (atf_amc::FAmctest*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FAmctest) * (u64(1)<<4));
    if (!amctest_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.amctest_lary[i]  = amctest_first;
        amctest_first    += 1ULL<<i;
    }
    // cascdel: initialize Tpool
    _db.cascdel_free      = NULL;
    _db.cascdel_blocksize = algo::BumpToPow2(64 * sizeof(atf_amc::FCascdel)); // allocate 64-127 elements at a time
    _db.cascdel_next_key = u32(0);
    memset(_db.optalloc_free, 0, sizeof(_db.optalloc_free));
    _db.optalloc_n = 0;
    memset(_db.varlenalloc_free, 0, sizeof(_db.varlenalloc_free));
    _db.varlenalloc_n = 0;
    memset(_db.optg_free, 0, sizeof(_db.optg_free));
    _db.optg_n = 0;
    _db.c_typek_elems = NULL; // (atf_amc.FDb.c_typek)
    _db.c_typek_n = 0; // (atf_amc.FDb.c_typek)
    _db.c_typek_max = 0; // (atf_amc.FDb.c_typek)
    // initialize LAry avl (atf_amc.FDb.avl)
    _db.avl_n = 0;
    memset(_db.avl_lary, 0, sizeof(_db.avl_lary)); // zero out all level pointers
    atf_amc::FAvl* avl_first = (atf_amc::FAvl*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FAvl) * (u64(1)<<4));
    if (!avl_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.avl_lary[i]  = avl_first;
        avl_first    += 1ULL<<i;
    }
    _db.tr_avl_root = NULL; // (atf_amc.FDb.tr_avl)
    _db.tr_avl_n = 0;
    _db.listtype_n = 0; // listtype: initialize count
    _db.dofork = bool(false);
    // typed: initialize Tpool
    _db.typed_free      = NULL;
    _db.typed_blocksize = algo::BumpToPow2(64 * sizeof(atf_amc::FTypeD)); // allocate 64-127 elements at a time
    // initialize hash table for atf_amc::FThashElem;
    _db.ind_thash_elem_n             	= 0; // (atf_amc.FDb.ind_thash_elem)
    _db.ind_thash_elem_buckets_n     	= 4; // (atf_amc.FDb.ind_thash_elem)
    _db.ind_thash_elem_buckets_elems 	= (atf_amc::FThashElem**)algo_lib::malloc_AllocMem(sizeof(atf_amc::FThashElem*)*_db.ind_thash_elem_buckets_n); // initial buckets (atf_amc.FDb.ind_thash_elem)
    if (!_db.ind_thash_elem_buckets_elems) {
        FatalErrorExit("out of memory"); // (atf_amc.FDb.ind_thash_elem)
    }
    memset(_db.ind_thash_elem_buckets_elems, 0, sizeof(atf_amc::FThashElem*)*_db.ind_thash_elem_buckets_n); // (atf_amc.FDb.ind_thash_elem)
    // initialize LAry thash_elem (atf_amc.FDb.thash_elem)
    _db.thash_elem_n = 0;
    memset(_db.thash_elem_lary, 0, sizeof(_db.thash_elem_lary)); // zero out all level pointers
    atf_amc::FThashElem* thash_elem_first = (atf_amc::FThashElem*)algo_lib::malloc_AllocMem(sizeof(atf_amc::FThashElem) * (u64(1)<<4));
    if (!thash_elem_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.thash_elem_lary[i]  = thash_elem_first;
        thash_elem_first    += 1ULL<<i;
    }

    atf_amc::InitReflection();
    amctest_LoadStatic(); // gen:ns_gstatic  gstatic:atf_amc.FDb.amctest  load atf_amc.FAmctest records
    listtype_LoadStatic(); // gen:ns_gstatic  gstatic:atf_amc.FDb.listtype  load atf_amc.FListtype records
}

// --- atf_amc.FDb..Uninit
void atf_amc::FDb_Uninit() {
    atf_amc::FDb &row = _db; (void)row;

    // atf_amc.FDb.thash_elem.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.ind_thash_elem.Uninit (Thash)  //
    // skip destruction of ind_thash_elem in global scope

    // atf_amc.FDb.listtype.Uninit (Inlary)  //
    // skip destruction in global scope

    // atf_amc.FDb.avl.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.c_typek.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(_db.c_typek_elems, sizeof(atf_amc::FTypeK*)*_db.c_typek_max); // (atf_amc.FDb.c_typek)

    // atf_amc.FDb.amctest.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.ind_cstring.Uninit (Thash)  //
    // skip destruction of ind_cstring in global scope

    // atf_amc.FDb.cstring.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.typet.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.ind_typea.Uninit (Thash)  //
    // skip destruction of ind_typea in global scope

    // atf_amc.FDb.ind_types.Uninit (Thash)  //
    // skip destruction of ind_types in global scope

    // atf_amc.FDb.types.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.typea.Uninit (Lary)  //
    // skip destruction in global scope

    // atf_amc.FDb.bh_typec.Uninit (Bheap)  //
    // skip destruction in global scope
}

// --- atf_amc.TypeG..ReadStrptrMaybe
// Read fields of atf_amc::TypeG from an ascii string.
// The format of the string is the format of the atf_amc::TypeG's only field
bool atf_amc::TypeG_ReadStrptrMaybe(atf_amc::TypeG &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.typeg, in_str);
    return retval;
}

// --- atf_amc.TypeG..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeG.String  printfmt:Raw
void atf_amc::TypeG_Print(atf_amc::TypeG& row, algo::cstring& str) {
    i32_Print(row.typeg, str);
}

// --- atf_amc.FOptG.optg.CopyOut
// Copy fields out of row
void atf_amc::optg_CopyOut(atf_amc::FOptG &row, atf_amc::OptG &out) {
    // length: field value is computed
    // typeg: unknown field type (Opt), skipped
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.FOptG.optg.CopyIn
// Copy fields in to row
void atf_amc::optg_CopyIn(atf_amc::FOptG &row, atf_amc::OptG &in) {
    // length: field value is computed
    // typeg: unknown field reftype (Opt), skipped
    (void)row;//only to avoid -Wunused-parameter
    (void)in;//only to avoid -Wunused-parameter
}

// --- atf_amc.FOptG.typeg.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::typeg_Getary(atf_amc::FOptG& optg) {
    u8 *end = (u8*)&optg + sizeof(atf_amc::FOptG);
    return algo::aryptr<u8>(end, i32(optg.length) - ssizeof(atf_amc::FOptG));
}

// --- atf_amc.FPerfSortString.orig.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_amc::Cstr> atf_amc::orig_Addary(atf_amc::FPerfSortString& parent, algo::aryptr<atf_amc::Cstr> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.orig_elems && rhs.elems < parent.orig_elems + parent.orig_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_amc.tary_alias  field:atf_amc.FPerfSortString.orig  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    orig_Reserve(parent, nnew); // reserve space
    int at = parent.orig_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.orig_elems + at + i) atf_amc::Cstr(rhs[i]);
        parent.orig_n++;
    }
    return algo::aryptr<atf_amc::Cstr>(parent.orig_elems + at, nnew);
}

// --- atf_amc.FPerfSortString.orig.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::Cstr& atf_amc::orig_Alloc(atf_amc::FPerfSortString& parent) {
    orig_Reserve(parent, 1);
    int n  = parent.orig_n;
    int at = n;
    atf_amc::Cstr *elems = parent.orig_elems;
    new (elems + at) atf_amc::Cstr(); // construct new element, default initializer
    parent.orig_n = n+1;
    return elems[at];
}

// --- atf_amc.FPerfSortString.orig.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::Cstr& atf_amc::orig_AllocAt(atf_amc::FPerfSortString& parent, int at) {
    orig_Reserve(parent, 1);
    int n  = parent.orig_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_amc.bad_alloc_at  field:atf_amc.FPerfSortString.orig  comment:'index out of range'");
    }
    atf_amc::Cstr *elems = parent.orig_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_amc::Cstr));
    new (elems + at) atf_amc::Cstr(); // construct element, default initializer
    parent.orig_n = n+1;
    return elems[at];
}

// --- atf_amc.FPerfSortString.orig.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> atf_amc::orig_AllocN(atf_amc::FPerfSortString& parent, int n_elems) {
    orig_Reserve(parent, n_elems);
    int old_n  = parent.orig_n;
    int new_n = old_n + n_elems;
    atf_amc::Cstr *elems = parent.orig_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::Cstr(); // construct new element, default initialize
    }
    parent.orig_n = new_n;
    return algo::aryptr<atf_amc::Cstr>(elems + old_n, n_elems);
}

// --- atf_amc.FPerfSortString.orig.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_amc::orig_Remove(atf_amc::FPerfSortString& parent, u32 i) {
    u32 lim = parent.orig_n;
    atf_amc::Cstr *elems = parent.orig_elems;
    if (i < lim) {
        elems[i].~Cstr(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(atf_amc::Cstr) * (lim - (i + 1)));
        parent.orig_n = lim - 1;
    }
}

// --- atf_amc.FPerfSortString.orig.RemoveAll
void atf_amc::orig_RemoveAll(atf_amc::FPerfSortString& parent) {
    u32 n = parent.orig_n;
    while (n > 0) {
        n -= 1;
        parent.orig_elems[n].~Cstr();
        parent.orig_n = n;
    }
}

// --- atf_amc.FPerfSortString.orig.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::orig_RemoveLast(atf_amc::FPerfSortString& parent) {
    u64 n = parent.orig_n;
    if (n > 0) {
        n -= 1;
        orig_qFind(parent, u64(n)).~Cstr();
        parent.orig_n = n;
    }
}

// --- atf_amc.FPerfSortString.orig.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_amc::orig_AbsReserve(atf_amc::FPerfSortString& parent, int n) {
    u32 old_max  = parent.orig_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.orig_elems, old_max * sizeof(atf_amc::Cstr), new_max * sizeof(atf_amc::Cstr));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.tary_nomem  field:atf_amc.FPerfSortString.orig  comment:'out of memory'");
        }
        parent.orig_elems = (atf_amc::Cstr*)new_mem;
        parent.orig_max = new_max;
    }
}

// --- atf_amc.FPerfSortString.orig.Setary
// Copy contents of RHS to PARENT.
void atf_amc::orig_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) {
    orig_RemoveAll(parent);
    int nnew = rhs.orig_n;
    orig_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.orig_elems + i) atf_amc::Cstr(orig_qFind(rhs, i));
        parent.orig_n = i + 1;
    }
}

// --- atf_amc.FPerfSortString.orig.Setary2
// Copy specified array into orig, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_amc::orig_Setary(atf_amc::FPerfSortString& parent, const algo::aryptr<atf_amc::Cstr> &rhs) {
    orig_RemoveAll(parent);
    orig_Addary(parent, rhs);
}

// --- atf_amc.FPerfSortString.orig.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> atf_amc::orig_AllocNVal(atf_amc::FPerfSortString& parent, int n_elems, const atf_amc::Cstr& val) {
    orig_Reserve(parent, n_elems);
    int old_n  = parent.orig_n;
    int new_n = old_n + n_elems;
    atf_amc::Cstr *elems = parent.orig_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::Cstr(val);
    }
    parent.orig_n = new_n;
    return algo::aryptr<atf_amc::Cstr>(elems + old_n, n_elems);
}

// --- atf_amc.FPerfSortString.sorted1.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_amc::Cstr> atf_amc::sorted1_Addary(atf_amc::FPerfSortString& parent, algo::aryptr<atf_amc::Cstr> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.sorted1_elems && rhs.elems < parent.sorted1_elems + parent.sorted1_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_amc.tary_alias  field:atf_amc.FPerfSortString.sorted1  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    sorted1_Reserve(parent, nnew); // reserve space
    int at = parent.sorted1_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.sorted1_elems + at + i) atf_amc::Cstr(rhs[i]);
        parent.sorted1_n++;
    }
    return algo::aryptr<atf_amc::Cstr>(parent.sorted1_elems + at, nnew);
}

// --- atf_amc.FPerfSortString.sorted1.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::Cstr& atf_amc::sorted1_Alloc(atf_amc::FPerfSortString& parent) {
    sorted1_Reserve(parent, 1);
    int n  = parent.sorted1_n;
    int at = n;
    atf_amc::Cstr *elems = parent.sorted1_elems;
    new (elems + at) atf_amc::Cstr(); // construct new element, default initializer
    parent.sorted1_n = n+1;
    return elems[at];
}

// --- atf_amc.FPerfSortString.sorted1.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::Cstr& atf_amc::sorted1_AllocAt(atf_amc::FPerfSortString& parent, int at) {
    sorted1_Reserve(parent, 1);
    int n  = parent.sorted1_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_amc.bad_alloc_at  field:atf_amc.FPerfSortString.sorted1  comment:'index out of range'");
    }
    atf_amc::Cstr *elems = parent.sorted1_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_amc::Cstr));
    new (elems + at) atf_amc::Cstr(); // construct element, default initializer
    parent.sorted1_n = n+1;
    return elems[at];
}

// --- atf_amc.FPerfSortString.sorted1.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> atf_amc::sorted1_AllocN(atf_amc::FPerfSortString& parent, int n_elems) {
    sorted1_Reserve(parent, n_elems);
    int old_n  = parent.sorted1_n;
    int new_n = old_n + n_elems;
    atf_amc::Cstr *elems = parent.sorted1_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::Cstr(); // construct new element, default initialize
    }
    parent.sorted1_n = new_n;
    return algo::aryptr<atf_amc::Cstr>(elems + old_n, n_elems);
}

// --- atf_amc.FPerfSortString.sorted1.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_amc::sorted1_Remove(atf_amc::FPerfSortString& parent, u32 i) {
    u32 lim = parent.sorted1_n;
    atf_amc::Cstr *elems = parent.sorted1_elems;
    if (i < lim) {
        elems[i].~Cstr(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(atf_amc::Cstr) * (lim - (i + 1)));
        parent.sorted1_n = lim - 1;
    }
}

// --- atf_amc.FPerfSortString.sorted1.RemoveAll
void atf_amc::sorted1_RemoveAll(atf_amc::FPerfSortString& parent) {
    u32 n = parent.sorted1_n;
    while (n > 0) {
        n -= 1;
        parent.sorted1_elems[n].~Cstr();
        parent.sorted1_n = n;
    }
}

// --- atf_amc.FPerfSortString.sorted1.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::sorted1_RemoveLast(atf_amc::FPerfSortString& parent) {
    u64 n = parent.sorted1_n;
    if (n > 0) {
        n -= 1;
        sorted1_qFind(parent, u64(n)).~Cstr();
        parent.sorted1_n = n;
    }
}

// --- atf_amc.FPerfSortString.sorted1.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_amc::sorted1_AbsReserve(atf_amc::FPerfSortString& parent, int n) {
    u32 old_max  = parent.sorted1_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.sorted1_elems, old_max * sizeof(atf_amc::Cstr), new_max * sizeof(atf_amc::Cstr));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.tary_nomem  field:atf_amc.FPerfSortString.sorted1  comment:'out of memory'");
        }
        parent.sorted1_elems = (atf_amc::Cstr*)new_mem;
        parent.sorted1_max = new_max;
    }
}

// --- atf_amc.FPerfSortString.sorted1.Setary
// Copy contents of RHS to PARENT.
void atf_amc::sorted1_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) {
    sorted1_RemoveAll(parent);
    int nnew = rhs.sorted1_n;
    sorted1_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.sorted1_elems + i) atf_amc::Cstr(sorted1_qFind(rhs, i));
        parent.sorted1_n = i + 1;
    }
}

// --- atf_amc.FPerfSortString.sorted1.Setary2
// Copy specified array into sorted1, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_amc::sorted1_Setary(atf_amc::FPerfSortString& parent, const algo::aryptr<atf_amc::Cstr> &rhs) {
    sorted1_RemoveAll(parent);
    sorted1_Addary(parent, rhs);
}

// --- atf_amc.FPerfSortString.sorted1.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> atf_amc::sorted1_AllocNVal(atf_amc::FPerfSortString& parent, int n_elems, const atf_amc::Cstr& val) {
    sorted1_Reserve(parent, n_elems);
    int old_n  = parent.sorted1_n;
    int new_n = old_n + n_elems;
    atf_amc::Cstr *elems = parent.sorted1_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::Cstr(val);
    }
    parent.sorted1_n = new_n;
    return algo::aryptr<atf_amc::Cstr>(elems + old_n, n_elems);
}

// --- atf_amc.FPerfSortString.sorted1.Swap
// Swap values elem_a and elem_b
inline static void atf_amc::sorted1_Swap(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b) {
    u8 temp[sizeof(atf_amc::Cstr)];
    memcpy(&temp  , &elem_a, sizeof(atf_amc::Cstr));
    memcpy(&elem_a, &elem_b, sizeof(atf_amc::Cstr));
    memcpy(&elem_b, &temp  , sizeof(atf_amc::Cstr));
}

// --- atf_amc.FPerfSortString.sorted1.Rotleft
// Left circular shift of three-tuple
inline static void atf_amc::sorted1_Rotleft(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b, atf_amc::Cstr &elem_c) {
    u8 temp[sizeof(atf_amc::Cstr)];
    memcpy(&temp, &elem_a   , sizeof(atf_amc::Cstr));
    memcpy(&elem_a   , &elem_b   , sizeof(atf_amc::Cstr));
    memcpy(&elem_b   , &elem_c   , sizeof(atf_amc::Cstr));
    memcpy(&elem_c   , &temp, sizeof(atf_amc::Cstr));
}

// --- atf_amc.FPerfSortString.sorted1.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_amc::sorted1_Lt(atf_amc::Cstr &elem_a, atf_amc::Cstr &elem_b) {
    bool ret;
    ret = val_Lt(elem_a, elem_b);
    return ret;
}

// --- atf_amc.FPerfSortString.sorted1.SortedQ
// Verify whether array is sorted
bool atf_amc::sorted1_SortedQ(atf_amc::FPerfSortString& parent) {
    atf_amc::Cstr *elems = sorted1_Getary(parent).elems;
    int n = sorted1_N(parent);
    for (int i = 1; i < n; i++) {
        if (sorted1_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_amc.FPerfSortString.sorted1.IntInsertionSort
// Internal insertion sort
static void atf_amc::sorted1_IntInsertionSort(atf_amc::Cstr *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        // find the spot for ith element.
        while (j>0 && sorted1_Lt(elems[i], elems[j-1])) {
            j--;
        }
        if (j<i) {
            u8 tmp[sizeof(atf_amc::Cstr)];
            memcpy (tmp                       , &elems[i], sizeof(atf_amc::Cstr)      );
            memmove(&elems[j+1], &elems[j], sizeof(atf_amc::Cstr)*(i-j));
            memcpy (&elems[j]  , tmp                     , sizeof(atf_amc::Cstr)      );
        }
    }
}

// --- atf_amc.FPerfSortString.sorted1.IntHeapSort
// Internal heap sort
static void atf_amc::sorted1_IntHeapSort(atf_amc::Cstr *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (sorted1_Lt(elems[j], elems[k])) {
            sorted1_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && sorted1_Lt(elems[l], elems[l+1]);
            if (sorted1_Lt(elems[l], elems[i])) {
                break;
            }
            sorted1_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            sorted1_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_amc.FPerfSortString.sorted1.IntQuickSort
// Quick sort engine
static void atf_amc::sorted1_IntQuickSort(atf_amc::Cstr *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            sorted1_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (sorted1_Lt(elems[pp], elems[pi])) {
            sorted1_Swap(elems[pi], elems[pp]);
        }
        if (sorted1_Lt(elems[pj], elems[pp])) {
            if (sorted1_Lt(elems[pj], elems[pi])) {
                sorted1_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                sorted1_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        sorted1_Swap(elems[--pj], elems[pp]);
        // reference to pivot
        atf_amc::Cstr &pivot = elems[pj];
        for(;;){
            while (sorted1_Lt(elems[++pi], pivot)) {
            }
            while (sorted1_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            sorted1_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        sorted1_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    sorted1_IntInsertionSort(elems,n);
}

// --- atf_amc.FPerfSortString.sorted1.InsertionSort
// Insertion sort
void atf_amc::sorted1_InsertionSort(atf_amc::FPerfSortString& parent) {
    atf_amc::Cstr *elems = sorted1_Getary(parent).elems;
    int n = sorted1_N(parent);
    sorted1_IntInsertionSort(elems, n);
}

// --- atf_amc.FPerfSortString.sorted1.HeapSort
// Heap sort
void atf_amc::sorted1_HeapSort(atf_amc::FPerfSortString& parent) {
    atf_amc::Cstr *elems = sorted1_Getary(parent).elems;
    int n = sorted1_N(parent);
    sorted1_IntHeapSort(elems, n);
}

// --- atf_amc.FPerfSortString.sorted1.QuickSort
// Quick sort
void atf_amc::sorted1_QuickSort(atf_amc::FPerfSortString& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(sorted1_N(parent) + 1)) + 3;
    atf_amc::Cstr *elems = sorted1_Getary(parent).elems;
    int n = sorted1_N(parent);
    sorted1_IntQuickSort(elems, n, max_depth);
}

// --- atf_amc.FPerfSortString..Uninit
void atf_amc::FPerfSortString_Uninit(atf_amc::FPerfSortString& parent) {
    atf_amc::FPerfSortString &row = parent; (void)row;

    // atf_amc.FPerfSortString.sorted1.Uninit (Tary)  //
    // remove all elements from atf_amc.FPerfSortString.sorted1
    sorted1_RemoveAll(parent);
    // free memory for Tary atf_amc.FPerfSortString.sorted1
    algo_lib::malloc_FreeMem(parent.sorted1_elems, sizeof(atf_amc::Cstr)*parent.sorted1_max); // (atf_amc.FPerfSortString.sorted1)

    // atf_amc.FPerfSortString.orig.Uninit (Tary)  //
    // remove all elements from atf_amc.FPerfSortString.orig
    orig_RemoveAll(parent);
    // free memory for Tary atf_amc.FPerfSortString.orig
    algo_lib::malloc_FreeMem(parent.orig_elems, sizeof(atf_amc::Cstr)*parent.orig_max); // (atf_amc.FPerfSortString.orig)
}

// --- atf_amc.FThashElem..Uninit
void atf_amc::FThashElem_Uninit(atf_amc::FThashElem& thash_elem) {
    atf_amc::FThashElem &row = thash_elem; (void)row;
    ind_thash_elem_Remove(row); // remove thash_elem from index ind_thash_elem
}

// --- atf_amc.FTypeC.msghdr.CopyOut
// Copy fields out of row
void atf_amc::typec_CopyOut(atf_amc::FTypeC &row, atf_amc::TypeC &out) {
    out.typec = row.typec;
}

// --- atf_amc.FTypeC.msghdr.CopyIn
// Copy fields in to row
void atf_amc::typec_CopyIn(atf_amc::FTypeC &row, atf_amc::TypeC &in) {
    row.typec = in.typec;
}

// --- atf_amc.FTypeC..Uninit
void atf_amc::FTypeC_Uninit(atf_amc::FTypeC& typec) {
    atf_amc::FTypeC &row = typec; (void)row;
    zsl_h_typec_Remove(row); // remove typec from index zsl_h_typec
    zs_t_typec_Remove(row); // remove typec from index zs_t_typec
    zs_mt_typec_Remove(row); // remove typec from index zs_mt_typec
    bh_typec_Remove(row); // remove typec from index bh_typec
    zdl_h_typec_Remove(row); // remove typec from index zdl_h_typec
    zd_t_typec_Remove(row); // remove typec from index zd_t_typec
    zdl_hnt_typec_Remove(row); // remove typec from index zdl_hnt_typec
    csl_h_typec_Remove(row); // remove typec from index csl_h_typec
    cs_t_typec_Remove(row); // remove typec from index cs_t_typec
    cdl_h_typec_Remove(row); // remove typec from index cdl_h_typec
    cd_t_typec_Remove(row); // remove typec from index cd_t_typec
}

// --- atf_amc.FTypeC..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeC.String  printfmt:Raw
void atf_amc::FTypeC_Print(atf_amc::FTypeC& row, algo::cstring& str) {
    i32_Print(row.typec, str);
}

// --- atf_amc.FTypeA.msghdr.CopyOut
// Copy fields out of row
void atf_amc::typea_CopyOut(atf_amc::FTypeA &row, atf_amc::TypeA &out) {
    out.typea = row.typea;
}

// --- atf_amc.FTypeA.msghdr.CopyIn
// Copy fields in to row
void atf_amc::typea_CopyIn(atf_amc::FTypeA &row, atf_amc::TypeA &in) {
    row.typea = in.typea;
}

// --- atf_amc.FTypeA.typec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeC& atf_amc::typec_Alloc(atf_amc::FTypeA& typea) {
    atf_amc::FTypeC* row = typec_AllocMaybe(typea);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.FTypeA.typec  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.FTypeA.typec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeC* atf_amc::typec_AllocMaybe(atf_amc::FTypeA& typea) {
    atf_amc::FTypeC *row = (atf_amc::FTypeC*)typec_AllocMem(typea);
    if (row) {
        new (row) atf_amc::FTypeC; // call constructor
    }
    return row;
}

// --- atf_amc.FTypeA.typec.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeC* atf_amc::typec_InsertMaybe(atf_amc::FTypeA& typea, const atf_amc::TypeC &value) {
    atf_amc::FTypeC *row = &typec_Alloc(typea); // if out of memory, process dies. if input error, return NULL.
    typec_CopyIn(*row,const_cast<atf_amc::TypeC&>(value));
    bool ok = typec_XrefMaybe(*row); // this may return false
    if (!ok) {
        typec_RemoveLast(typea); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- atf_amc.FTypeA.typec.RemoveAll
// Destroy all elements of Inlary
void atf_amc::typec_RemoveAll(atf_amc::FTypeA& typea) {
    for (u64 n = typea.typec_n; n>0; ) {
        n--;
        reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data)[n].~FTypeC(); // destroy last element
        typea.typec_n=n;
    }
}

// --- atf_amc.FTypeA.typec.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::typec_RemoveLast(atf_amc::FTypeA& typea) {
    u64 n = typea.typec_n;
    if (n > 0) {
        n -= 1;
        reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data)[n].~FTypeC();
        typea.typec_n = n;
    }
}

// --- atf_amc.FTypeA.typec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typec_XrefMaybe(atf_amc::FTypeC &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FTypeA.zdl_typeb.Cascdel
// Delete all elements in the linked list.
void atf_amc::zdl_typeb_Cascdel(atf_amc::FTypeA& typea) {
    while (atf_amc::FTypeB *zdl_typeb_first = zdl_typeb_First(typea)) {
        typeb_Delete(*zdl_typeb_first);
    }
}

// --- atf_amc.FTypeA.zdl_typeb.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zdl_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) {
    if (!zdl_typeb_InLlistQ(row)) {
        atf_amc::FTypeB* old_head = typea.zdl_typeb_head;
        row.zdl_typeb_prev = NULL;
        row.zdl_typeb_next = old_head;
        typea.zdl_typeb_head  = &row;
        atf_amc::FTypeB **new_row_a = &old_head->zdl_typeb_prev;
        atf_amc::FTypeB **new_row_b = &typea.zdl_typeb_tail;
        atf_amc::FTypeB **new_row = old_head ? new_row_a : new_row_b;
        *new_row = &row;
        typea.zdl_typeb_n++;
    }
}

// --- atf_amc.FTypeA.zdl_typeb.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zdl_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) {
    if (zdl_typeb_InLlistQ(row)) {
        atf_amc::FTypeB* old_head       = typea.zdl_typeb_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeB* prev = row.zdl_typeb_prev;
        atf_amc::FTypeB* next = row.zdl_typeb_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeB **new_next_a = &prev->zdl_typeb_next;
        atf_amc::FTypeB **new_next_b = &typea.zdl_typeb_head;
        atf_amc::FTypeB **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FTypeB **new_prev_a = &next->zdl_typeb_prev;
        atf_amc::FTypeB **new_prev_b = &typea.zdl_typeb_tail;
        atf_amc::FTypeB **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        typea.zdl_typeb_n--;
        row.zdl_typeb_next=(atf_amc::FTypeB*)-1; // not-in-list
    }
}

// --- atf_amc.FTypeA.zdl_typeb.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zdl_typeb_RemoveAll(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB* row = typea.zdl_typeb_head;
    typea.zdl_typeb_head = NULL;
    typea.zdl_typeb_tail = NULL;
    typea.zdl_typeb_n = 0;
    while (row) {
        atf_amc::FTypeB* row_next = row->zdl_typeb_next;
        row->zdl_typeb_next  = (atf_amc::FTypeB*)-1;
        row->zdl_typeb_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FTypeA.zdl_typeb.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeB* atf_amc::zdl_typeb_RemoveFirst(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    row = typea.zdl_typeb_head;
    if (row) {
        atf_amc::FTypeB *next = row->zdl_typeb_next;
        typea.zdl_typeb_head = next;
        atf_amc::FTypeB **new_end_a = &next->zdl_typeb_prev;
        atf_amc::FTypeB **new_end_b = &typea.zdl_typeb_tail;
        atf_amc::FTypeB **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        typea.zdl_typeb_n--;
        row->zdl_typeb_next = (atf_amc::FTypeB*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FTypeA.bh_typeb.Cascdel
// Delete referred-to items.
// Delete all elements referenced by the heap.
void atf_amc::bh_typeb_Cascdel(atf_amc::FTypeA& typea) {
    i32 n = typea.bh_typeb_n;
    while (n > 0) {
        n--;
        atf_amc::FTypeB &elem = *typea.bh_typeb_elems[n]; // pick cheapest element to remove
        elem.bh_typeb_idx = -1; // mark not-in-heap
        typea.bh_typeb_n = n;
        typeb_Delete(elem);
    }
}

// --- atf_amc.FTypeA.bh_typeb.Dealloc
// Remove all elements from heap and free memory used by the array.
void atf_amc::bh_typeb_Dealloc(atf_amc::FTypeA& typea) {
    bh_typeb_RemoveAll(typea);
    algo_lib::malloc_FreeMem(typea.bh_typeb_elems, sizeof(atf_amc::FTypeB*)*typea.bh_typeb_max);
    typea.bh_typeb_max   = 0;
    typea.bh_typeb_elems = NULL;
}

// --- atf_amc.FTypeA.bh_typeb.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int atf_amc::bh_typeb_Downheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row, int idx) {
    atf_amc::FTypeB* *elems = typea.bh_typeb_elems;
    int n = typea.bh_typeb_n;
    int child = idx*2+1;
    while (child < n) {
        atf_amc::FTypeB* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            atf_amc::FTypeB* q = elems[rchild]; // right child
            if (bh_typeb_ElemLt(typea, *q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_typeb_ElemLt(typea, *p,row)) {
            break;
        }
        p->bh_typeb_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- atf_amc.FTypeA.bh_typeb.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void atf_amc::bh_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) {
    if (LIKELY(row.bh_typeb_idx == -1)) {
        bh_typeb_Reserve(typea, 1);
        int n = typea.bh_typeb_n;
        typea.bh_typeb_n = n + 1;
        int new_idx = bh_typeb_Upheap(typea, row, n);
        row.bh_typeb_idx = new_idx;
        typea.bh_typeb_elems[new_idx] = &row;
    }
}

// --- atf_amc.FTypeA.bh_typeb.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 atf_amc::bh_typeb_Reheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) {
    int old_idx = row.bh_typeb_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_typeb_Reserve(typea, 1);
        old_idx = typea.bh_typeb_n++;
    }
    int new_idx = bh_typeb_Upheap(typea, row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_typeb_Downheap(typea, row, old_idx);
    }
    row.bh_typeb_idx = new_idx;
    typea.bh_typeb_elems[new_idx] = &row;
    return new_idx;
}

// --- atf_amc.FTypeA.bh_typeb.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 atf_amc::bh_typeb_ReheapFirst(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB &row = *typea.bh_typeb_elems[0];
    i32 new_idx = bh_typeb_Downheap(typea, row, 0);
    row.bh_typeb_idx = new_idx;
    typea.bh_typeb_elems[new_idx] = &row;
    return new_idx;
}

// --- atf_amc.FTypeA.bh_typeb.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::bh_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) {
    if (bh_typeb_InBheapQ(row)) {
        int old_idx = row.bh_typeb_idx;
        if (typea.bh_typeb_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_typeb_idx = -1;           // mark not in heap
            i32 n = typea.bh_typeb_n - 1; // index of last element in heap
            typea.bh_typeb_n = n;         // decrease count
            if (old_idx != n) {
                atf_amc::FTypeB *elem = typea.bh_typeb_elems[n];
                int new_idx = bh_typeb_Upheap(typea, *elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_typeb_Downheap(typea, *elem, old_idx);
                }
                elem->bh_typeb_idx = new_idx;
                typea.bh_typeb_elems[new_idx] = elem;
            }
        }
    }
}

// --- atf_amc.FTypeA.bh_typeb.RemoveAll
// Remove all elements from binary heap
void atf_amc::bh_typeb_RemoveAll(atf_amc::FTypeA& typea) {
    int n = typea.bh_typeb_n;
    for (int i = n - 1; i>=0; i--) {
        typea.bh_typeb_elems[i]->bh_typeb_idx = -1; // mark not-in-heap
    }
    typea.bh_typeb_n = 0;
}

// --- atf_amc.FTypeA.bh_typeb.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FTypeB* atf_amc::bh_typeb_RemoveFirst(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    if (typea.bh_typeb_n > 0) {
        row = typea.bh_typeb_elems[0];
        row->bh_typeb_idx = -1;           // mark not in heap
        i32 n = typea.bh_typeb_n - 1; // index of last element in heap
        typea.bh_typeb_n = n;         // decrease count
        if (n) {
            atf_amc::FTypeB &elem = *typea.bh_typeb_elems[n];
            int new_idx = bh_typeb_Downheap(typea, elem, 0);
            elem.bh_typeb_idx = new_idx;
            typea.bh_typeb_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- atf_amc.FTypeA.bh_typeb.Reserve
// Reserve space in index for N more elements
void atf_amc::bh_typeb_Reserve(atf_amc::FTypeA& typea, int n) {
    i32 old_max = typea.bh_typeb_max;
    if (UNLIKELY(typea.bh_typeb_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::FTypeB*);
        u32 new_size = new_max * sizeof(atf_amc::FTypeB*);
        void *new_mem = algo_lib::malloc_ReallocMem(typea.bh_typeb_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FTypeA.bh_typeb");
        }
        typea.bh_typeb_elems = (atf_amc::FTypeB**)new_mem;
        typea.bh_typeb_max = new_max;
    }
}

// --- atf_amc.FTypeA.bh_typeb.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int atf_amc::bh_typeb_Upheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row, int idx) {
    atf_amc::FTypeB* *elems = typea.bh_typeb_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        atf_amc::FTypeB* p = elems[j];
        if (!bh_typeb_ElemLt(typea, row, *p)) {
            break;
        }
        p->bh_typeb_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- atf_amc.FTypeA.bh_typeb.ElemLt
inline static bool atf_amc::bh_typeb_ElemLt(atf_amc::FTypeA& typea, atf_amc::FTypeB &a, atf_amc::FTypeB &b) {
    (void)typea;
    return a.j < b.j;
}

// --- atf_amc.FTypeA..Init
// Set all fields to initial values.
void atf_amc::FTypeA_Init(atf_amc::FTypeA& typea) {
    typea.typea = i32(0);
    typea.typec_n = 0; // typec: initialize count
    typea.zdl_typeb_head = NULL; // (atf_amc.FTypeA.zdl_typeb)
    typea.zdl_typeb_n = 0; // (atf_amc.FTypeA.zdl_typeb)
    typea.zdl_typeb_tail = NULL; // (atf_amc.FTypeA.zdl_typeb)
    typea.rowid = i32(0);
    typea.bh_typeb_max   	= 0; // (atf_amc.FTypeA.bh_typeb)
    typea.bh_typeb_n     	= 0; // (atf_amc.FTypeA.bh_typeb)
    typea.bh_typeb_elems 	= NULL; // (atf_amc.FTypeA.bh_typeb)
    typea.ind_typea_next = (atf_amc::FTypeA*)-1; // (atf_amc.FDb.ind_typea) not-in-hash
}

// --- atf_amc.FTypeA.bh_typeb_curs.Add
static void atf_amc::typea_bh_typeb_curs_Add(typea_bh_typeb_curs &curs, atf_amc::FTypeB& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    atf_amc::FTypeB* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        atf_amc::FTypeB* p = elems[j];
        if (!bh_typeb_ElemLt((*curs.parent), row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- atf_amc.FTypeA.bh_typeb_curs.Reserve
void atf_amc::typea_bh_typeb_curs_Reserve(typea_bh_typeb_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_typeb_N((*curs.parent));
        curs.temp_elems   = (atf_amc::FTypeB**)algo_lib::malloc_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("atf_amc.cursor_out_of_memory  func:atf_amc.FTypeA.bh_typeb_curs.Reserve");
        }
        curs.temp_max       = bh_typeb_N((*curs.parent));
    }
}

// --- atf_amc.FTypeA.bh_typeb_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void atf_amc::typea_bh_typeb_curs_Reset(typea_bh_typeb_curs &curs, atf_amc::FTypeA &parent) {
    curs.parent       = &parent;
    typea_bh_typeb_curs_Reserve(curs, bh_typeb_N((*curs.parent)));
    curs.temp_n = 0;
    if (parent.bh_typeb_n > 0) {
        atf_amc::FTypeB &first = *parent.bh_typeb_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- atf_amc.FTypeA.bh_typeb_curs.Next
// Advance cursor.
void atf_amc::typea_bh_typeb_curs_Next(typea_bh_typeb_curs &curs) {
    atf_amc::FTypeB* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        atf_amc::FTypeB* dead = elems[0];
        int i       = 0;
        atf_amc::FTypeB* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            atf_amc::FTypeB* choose = last;
            int l         = i*2+1;
            if (l<n) {
                atf_amc::FTypeB* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                atf_amc::FTypeB* er = elems[r];
                if (bh_typeb_ElemLt((*curs.parent),*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_typeb_ElemLt((*curs.parent),*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_typeb_idx;
        i = (index*2+1);
        if (i < bh_typeb_N((*curs.parent))) {
            atf_amc::FTypeB &elem = *curs.parent->bh_typeb_elems[i];
            typea_bh_typeb_curs_Add(curs, elem);
        }
        if (i+1 < bh_typeb_N((*curs.parent))) {
            atf_amc::FTypeB &elem = *curs.parent->bh_typeb_elems[i + 1];
            typea_bh_typeb_curs_Add(curs, elem);
        }
    }
}

// --- atf_amc.FTypeA..Uninit
void atf_amc::FTypeA_Uninit(atf_amc::FTypeA& typea) {
    atf_amc::FTypeA &row = typea; (void)row;
    bh_typeb_Cascdel(typea); // dmmeta.cascdel:atf_amc.FTypeA.bh_typeb
    zdl_typeb_Cascdel(typea); // dmmeta.cascdel:atf_amc.FTypeA.zdl_typeb
    ind_typea_Remove(row); // remove typea from index ind_typea

    // atf_amc.FTypeA.bh_typeb.Uninit (Bheap)  //
    algo_lib::malloc_FreeMem((u8*)typea.bh_typeb_elems, sizeof(atf_amc::FTypeB*)*typea.bh_typeb_max); // (atf_amc.FTypeA.bh_typeb)

    // atf_amc.FTypeA.typec.Uninit (Inlary)  //
    typec_RemoveAll(typea);
}

// --- atf_amc.FTypeA..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeA.String  printfmt:Tuple
void atf_amc::FTypeA_Print(atf_amc::FTypeA& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FTypeA";

    i32_Print(row.typea, temp);
    PrintAttrSpaceReset(str,"typea", temp);

    ind_beg(typea_typec_curs,typec,row) {
        atf_amc::FTypeC_Print(typec, temp);
        tempstr name;
        name << "typec.";
        name << ind_curs(typec).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;

    i32_Print(row.rowid, temp);
    PrintAttrSpaceReset(str,"rowid", temp);
}

// --- atf_amc.FTypeB.msghdr.CopyOut
// Copy fields out of row
void atf_amc::typeb_CopyOut(atf_amc::FTypeB &row, atf_amc::TypeB &out) {
    out.typea = row.typea;
    out.j = row.j;
}

// --- atf_amc.FTypeB.msghdr.CopyIn
// Copy fields in to row
void atf_amc::typeb_CopyIn(atf_amc::FTypeB &row, atf_amc::TypeB &in) {
    row.typea = in.typea;
    row.j = in.j;
}

// --- atf_amc.FTypeB..Uninit
void atf_amc::FTypeB_Uninit(atf_amc::FTypeB& typeb) {
    atf_amc::FTypeB &row = typeb; (void)row;
    atf_amc::FTypeA* p_typea = atf_amc::ind_typea_Find(row.typea);
    if (p_typea)  {
        zdl_typeb_Remove(*p_typea, row);// remove typeb from index zdl_typeb
    }
    if (p_typea)  {
        bh_typeb_Remove(*p_typea, row);// remove typeb from index bh_typeb
    }
}

// --- atf_amc.FTypeB..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeB.String  printfmt:Tuple
void atf_amc::FTypeB_Print(atf_amc::FTypeB& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FTypeB";

    i32_Print(row.typea, temp);
    PrintAttrSpaceReset(str,"typea", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_amc.FTypeD.msghdr.CopyOut
// Copy fields out of row
void atf_amc::typed_CopyOut(atf_amc::FTypeD &row, atf_amc::TypeC &out) {
    out.typec = row.typec;
}

// --- atf_amc.FTypeD.msghdr.CopyIn
// Copy fields in to row
void atf_amc::typed_CopyIn(atf_amc::FTypeD &row, atf_amc::TypeC &in) {
    row.typec = in.typec;
}

// --- atf_amc.FTypeD..Uninit
void atf_amc::FTypeD_Uninit(atf_amc::FTypeD& typed) {
    atf_amc::FTypeD &row = typed; (void)row;
    zd_typed_Remove(row); // remove typed from index zd_typed
    zs_t_typed_Remove(row); // remove typed from index zs_t_typed
    cd_typed_Remove(row); // remove typed from index cd_typed
}

// --- atf_amc.FTypeD..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeD.String  printfmt:Raw
void atf_amc::FTypeD_Print(atf_amc::FTypeD& row, algo::cstring& str) {
    i32_Print(row.typec, str);
}

// --- atf_amc.FTypeS.msghdr.CopyOut
// Copy fields out of row
void atf_amc::types_CopyOut(atf_amc::FTypeS &row, atf_amc::TypeS &out) {
    out.types = row.types;
    out.comment = row.comment;
}

// --- atf_amc.FTypeS.msghdr.CopyIn
// Copy fields in to row
void atf_amc::types_CopyIn(atf_amc::FTypeS &row, atf_amc::TypeS &in) {
    row.types = in.types;
    row.comment = in.comment;
}

// --- atf_amc.FTypeS.zdl_typet.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void atf_amc::zdl_typet_Insert(atf_amc::FTypeS& types, atf_amc::FTypeT& row) {
    if (!zdl_typet_InLlistQ(row)) {
        atf_amc::FTypeT* old_head = types.zdl_typet_head;
        row.zdl_typet_prev = NULL;
        row.zdl_typet_next = old_head;
        types.zdl_typet_head  = &row;
        atf_amc::FTypeT **new_row_a = &old_head->zdl_typet_prev;
        atf_amc::FTypeT **new_row_b = &types.zdl_typet_tail;
        atf_amc::FTypeT **new_row = old_head ? new_row_a : new_row_b;
        *new_row = &row;
        types.zdl_typet_n++;
    }
}

// --- atf_amc.FTypeS.zdl_typet.Remove
// Remove element from index. If element is not in index, do nothing.
void atf_amc::zdl_typet_Remove(atf_amc::FTypeS& types, atf_amc::FTypeT& row) {
    if (zdl_typet_InLlistQ(row)) {
        atf_amc::FTypeT* old_head       = types.zdl_typet_head;
        (void)old_head; // in case it's not used
        atf_amc::FTypeT* prev = row.zdl_typet_prev;
        atf_amc::FTypeT* next = row.zdl_typet_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        atf_amc::FTypeT **new_next_a = &prev->zdl_typet_next;
        atf_amc::FTypeT **new_next_b = &types.zdl_typet_head;
        atf_amc::FTypeT **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        atf_amc::FTypeT **new_prev_a = &next->zdl_typet_prev;
        atf_amc::FTypeT **new_prev_b = &types.zdl_typet_tail;
        atf_amc::FTypeT **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        types.zdl_typet_n--;
        row.zdl_typet_next=(atf_amc::FTypeT*)-1; // not-in-list
    }
}

// --- atf_amc.FTypeS.zdl_typet.RemoveAll
// Empty the index. (The rows are not deleted)
void atf_amc::zdl_typet_RemoveAll(atf_amc::FTypeS& types) {
    atf_amc::FTypeT* row = types.zdl_typet_head;
    types.zdl_typet_head = NULL;
    types.zdl_typet_tail = NULL;
    types.zdl_typet_n = 0;
    while (row) {
        atf_amc::FTypeT* row_next = row->zdl_typet_next;
        row->zdl_typet_next  = (atf_amc::FTypeT*)-1;
        row->zdl_typet_prev  = NULL;
        row = row_next;
    }
}

// --- atf_amc.FTypeS.zdl_typet.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeT* atf_amc::zdl_typet_RemoveFirst(atf_amc::FTypeS& types) {
    atf_amc::FTypeT *row = NULL;
    row = types.zdl_typet_head;
    if (row) {
        atf_amc::FTypeT *next = row->zdl_typet_next;
        types.zdl_typet_head = next;
        atf_amc::FTypeT **new_end_a = &next->zdl_typet_prev;
        atf_amc::FTypeT **new_end_b = &types.zdl_typet_tail;
        atf_amc::FTypeT **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        types.zdl_typet_n--;
        row->zdl_typet_next = (atf_amc::FTypeT*)-1; // mark as not-in-list
    }
    return row;
}

// --- atf_amc.FTypeS..Uninit
void atf_amc::FTypeS_Uninit(atf_amc::FTypeS& types) {
    atf_amc::FTypeS &row = types; (void)row;
    ind_types_Remove(row); // remove types from index ind_types
}

// --- atf_amc.FTypeS..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeS.String  printfmt:Tuple
void atf_amc::FTypeS_Print(atf_amc::FTypeS& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FTypeS";

    i32_Print(row.types, temp);
    PrintAttrSpaceReset(str,"types", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atf_amc.FTypeT.msghdr.CopyOut
// Copy fields out of row
void atf_amc::typet_CopyOut(atf_amc::FTypeT &row, atf_amc::TypeT &out) {
    out.types = row.types;
    out.j = row.j;
}

// --- atf_amc.FTypeT.msghdr.CopyIn
// Copy fields in to row
void atf_amc::typet_CopyIn(atf_amc::FTypeT &row, atf_amc::TypeT &in) {
    row.types = in.types;
    row.j = in.j;
}

// --- atf_amc.FTypeT..Uninit
void atf_amc::FTypeT_Uninit(atf_amc::FTypeT& typet) {
    atf_amc::FTypeT &row = typet; (void)row;
    atf_amc::FTypeS* p_types = atf_amc::ind_types_Find(row.types);
    if (p_types)  {
        zdl_typet_Remove(*p_types, row);// remove typet from index zdl_typet
    }
}

// --- atf_amc.FTypeT..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeT.String  printfmt:Tuple
void atf_amc::FTypeT_Print(atf_amc::FTypeT& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.FTypeT";

    i32_Print(row.types, temp);
    PrintAttrSpaceReset(str,"types", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_amc.TypeA..ReadStrptrMaybe
// Read fields of atf_amc::TypeA from an ascii string.
// The format of the string is the format of the atf_amc::TypeA's only field
bool atf_amc::TypeA_ReadStrptrMaybe(atf_amc::TypeA &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.typea, in_str);
    return retval;
}

// --- atf_amc.TypeA..FmtJson
// Create JSON representation of atf_amc::TypeA under PARENT node
// cfmt:atf_amc.TypeA.Json  printfmt:Auto
lib_json::FNode * atf_amc::TypeA_FmtJson(atf_amc::TypeA& row, lib_json::FNode *parent) {
    return i32_FmtJson(const_cast<atf_amc::TypeA&>(row).typea,parent);;
}

// --- atf_amc.TypeA..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeA.String  printfmt:Raw
void atf_amc::TypeA_Print(atf_amc::TypeA& row, algo::cstring& str) {
    i32_Print(row.typea, str);
}

// --- atf_amc.FUnitSort.tary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_amc::TypeA> atf_amc::tary_Addary(atf_amc::FUnitSort& parent, algo::aryptr<atf_amc::TypeA> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.tary_elems && rhs.elems < parent.tary_elems + parent.tary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_amc.tary_alias  field:atf_amc.FUnitSort.tary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    tary_Reserve(parent, nnew); // reserve space
    int at = parent.tary_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.tary_elems + at + i) atf_amc::TypeA(rhs[i]);
        parent.tary_n++;
    }
    return algo::aryptr<atf_amc::TypeA>(parent.tary_elems + at, nnew);
}

// --- atf_amc.FUnitSort.tary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::TypeA& atf_amc::tary_Alloc(atf_amc::FUnitSort& parent) {
    tary_Reserve(parent, 1);
    int n  = parent.tary_n;
    int at = n;
    atf_amc::TypeA *elems = parent.tary_elems;
    new (elems + at) atf_amc::TypeA(); // construct new element, default initializer
    parent.tary_n = n+1;
    return elems[at];
}

// --- atf_amc.FUnitSort.tary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::TypeA& atf_amc::tary_AllocAt(atf_amc::FUnitSort& parent, int at) {
    tary_Reserve(parent, 1);
    int n  = parent.tary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_amc.bad_alloc_at  field:atf_amc.FUnitSort.tary  comment:'index out of range'");
    }
    atf_amc::TypeA *elems = parent.tary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(atf_amc::TypeA));
    new (elems + at) atf_amc::TypeA(); // construct element, default initializer
    parent.tary_n = n+1;
    return elems[at];
}

// --- atf_amc.FUnitSort.tary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::TypeA> atf_amc::tary_AllocN(atf_amc::FUnitSort& parent, int n_elems) {
    tary_Reserve(parent, n_elems);
    int old_n  = parent.tary_n;
    int new_n = old_n + n_elems;
    atf_amc::TypeA *elems = parent.tary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::TypeA(); // construct new element, default initialize
    }
    parent.tary_n = new_n;
    return algo::aryptr<atf_amc::TypeA>(elems + old_n, n_elems);
}

// --- atf_amc.FUnitSort.tary.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_amc::tary_Remove(atf_amc::FUnitSort& parent, u32 i) {
    u32 lim = parent.tary_n;
    atf_amc::TypeA *elems = parent.tary_elems;
    if (i < lim) {
        elems[i].~TypeA(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(atf_amc::TypeA) * (lim - (i + 1)));
        parent.tary_n = lim - 1;
    }
}

// --- atf_amc.FUnitSort.tary.RemoveAll
void atf_amc::tary_RemoveAll(atf_amc::FUnitSort& parent) {
    u32 n = parent.tary_n;
    while (n > 0) {
        n -= 1;
        parent.tary_elems[n].~TypeA();
        parent.tary_n = n;
    }
}

// --- atf_amc.FUnitSort.tary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::tary_RemoveLast(atf_amc::FUnitSort& parent) {
    u64 n = parent.tary_n;
    if (n > 0) {
        n -= 1;
        tary_qFind(parent, u64(n)).~TypeA();
        parent.tary_n = n;
    }
}

// --- atf_amc.FUnitSort.tary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_amc::tary_AbsReserve(atf_amc::FUnitSort& parent, int n) {
    u32 old_max  = parent.tary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.tary_elems, old_max * sizeof(atf_amc::TypeA), new_max * sizeof(atf_amc::TypeA));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.tary_nomem  field:atf_amc.FUnitSort.tary  comment:'out of memory'");
        }
        parent.tary_elems = (atf_amc::TypeA*)new_mem;
        parent.tary_max = new_max;
    }
}

// --- atf_amc.FUnitSort.tary.Setary
// Copy contents of RHS to PARENT.
void atf_amc::tary_Setary(atf_amc::FUnitSort& parent, atf_amc::FUnitSort &rhs) {
    tary_RemoveAll(parent);
    int nnew = rhs.tary_n;
    tary_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.tary_elems + i) atf_amc::TypeA(tary_qFind(rhs, i));
        parent.tary_n = i + 1;
    }
}

// --- atf_amc.FUnitSort.tary.Setary2
// Copy specified array into tary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_amc::tary_Setary(atf_amc::FUnitSort& parent, const algo::aryptr<atf_amc::TypeA> &rhs) {
    tary_RemoveAll(parent);
    tary_Addary(parent, rhs);
}

// --- atf_amc.FUnitSort.tary.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::TypeA> atf_amc::tary_AllocNVal(atf_amc::FUnitSort& parent, int n_elems, const atf_amc::TypeA& val) {
    tary_Reserve(parent, n_elems);
    int old_n  = parent.tary_n;
    int new_n = old_n + n_elems;
    atf_amc::TypeA *elems = parent.tary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) atf_amc::TypeA(val);
    }
    parent.tary_n = new_n;
    return algo::aryptr<atf_amc::TypeA>(elems + old_n, n_elems);
}

// --- atf_amc.FUnitSort.tary.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool atf_amc::tary_ReadStrptrMaybe(atf_amc::FUnitSort& parent, algo::strptr in_str) {
    bool retval = true;
    atf_amc::TypeA &elem = tary_Alloc(parent);
    retval = atf_amc::TypeA_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        tary_RemoveLast(parent);
    }
    return retval;
}

// --- atf_amc.FUnitSort.tary.Swap
// Swap values elem_a and elem_b
inline static void atf_amc::tary_Swap(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) {
    u8 temp[sizeof(atf_amc::TypeA)];
    memcpy(&temp  , &elem_a, sizeof(atf_amc::TypeA));
    memcpy(&elem_a, &elem_b, sizeof(atf_amc::TypeA));
    memcpy(&elem_b, &temp  , sizeof(atf_amc::TypeA));
}

// --- atf_amc.FUnitSort.tary.Rotleft
// Left circular shift of three-tuple
inline static void atf_amc::tary_Rotleft(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b, atf_amc::TypeA &elem_c) {
    u8 temp[sizeof(atf_amc::TypeA)];
    memcpy(&temp, &elem_a   , sizeof(atf_amc::TypeA));
    memcpy(&elem_a   , &elem_b   , sizeof(atf_amc::TypeA));
    memcpy(&elem_b   , &elem_c   , sizeof(atf_amc::TypeA));
    memcpy(&elem_c   , &temp, sizeof(atf_amc::TypeA));
}

// --- atf_amc.FUnitSort.tary.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_amc::tary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) {
    bool ret;
    ret = elem_a.typea < elem_b.typea;
    return ret;
}

// --- atf_amc.FUnitSort.tary.SortedQ
// Verify whether array is sorted
bool atf_amc::tary_SortedQ(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = tary_Getary(parent).elems;
    int n = tary_N(parent);
    for (int i = 1; i < n; i++) {
        if (tary_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_amc.FUnitSort.tary.IntInsertionSort
// Internal insertion sort
static void atf_amc::tary_IntInsertionSort(atf_amc::TypeA *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        // find the spot for ith element.
        while (j>0 && tary_Lt(elems[i], elems[j-1])) {
            j--;
        }
        if (j<i) {
            u8 tmp[sizeof(atf_amc::TypeA)];
            memcpy (tmp                       , &elems[i], sizeof(atf_amc::TypeA)      );
            memmove(&elems[j+1], &elems[j], sizeof(atf_amc::TypeA)*(i-j));
            memcpy (&elems[j]  , tmp                     , sizeof(atf_amc::TypeA)      );
        }
    }
}

// --- atf_amc.FUnitSort.tary.IntHeapSort
// Internal heap sort
static void atf_amc::tary_IntHeapSort(atf_amc::TypeA *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (tary_Lt(elems[j], elems[k])) {
            tary_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && tary_Lt(elems[l], elems[l+1]);
            if (tary_Lt(elems[l], elems[i])) {
                break;
            }
            tary_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            tary_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_amc.FUnitSort.tary.IntQuickSort
// Quick sort engine
static void atf_amc::tary_IntQuickSort(atf_amc::TypeA *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            tary_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (tary_Lt(elems[pp], elems[pi])) {
            tary_Swap(elems[pi], elems[pp]);
        }
        if (tary_Lt(elems[pj], elems[pp])) {
            if (tary_Lt(elems[pj], elems[pi])) {
                tary_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                tary_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        tary_Swap(elems[--pj], elems[pp]);
        // reference to pivot
        atf_amc::TypeA &pivot = elems[pj];
        for(;;){
            while (tary_Lt(elems[++pi], pivot)) {
            }
            while (tary_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            tary_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        tary_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    tary_IntInsertionSort(elems,n);
}

// --- atf_amc.FUnitSort.tary.InsertionSort
// Insertion sort
void atf_amc::tary_InsertionSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = tary_Getary(parent).elems;
    int n = tary_N(parent);
    tary_IntInsertionSort(elems, n);
}

// --- atf_amc.FUnitSort.tary.HeapSort
// Heap sort
void atf_amc::tary_HeapSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = tary_Getary(parent).elems;
    int n = tary_N(parent);
    tary_IntHeapSort(elems, n);
}

// --- atf_amc.FUnitSort.tary.QuickSort
// Quick sort
void atf_amc::tary_QuickSort(atf_amc::FUnitSort& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(tary_N(parent) + 1)) + 3;
    atf_amc::TypeA *elems = tary_Getary(parent).elems;
    int n = tary_N(parent);
    tary_IntQuickSort(elems, n, max_depth);
}

// --- atf_amc.FUnitSort.c_ptrary.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void atf_amc::c_ptrary_Insert(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) {
    // reserve space
    c_ptrary_Reserve(parent, 1);
    u32 n  = parent.c_ptrary_n;
    u32 at = n;
    atf_amc::TypeA* *elems = parent.c_ptrary_elems;
    elems[at] = &row;
    parent.c_ptrary_n = n+1;

}

// --- atf_amc.FUnitSort.c_ptrary.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool atf_amc::c_ptrary_ScanInsertMaybe(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) {
    bool retval = true;
    u32 n  = parent.c_ptrary_n;
    for (u32 i = 0; i < n; i++) {
        if (parent.c_ptrary_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ptrary_Reserve(parent, 1);
        parent.c_ptrary_elems[n] = &row;
        parent.c_ptrary_n = n+1;
    }
    return retval;
}

// --- atf_amc.FUnitSort.c_ptrary.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void atf_amc::c_ptrary_Remove(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) {
    int lim = parent.c_ptrary_n;
    atf_amc::TypeA* *elems = parent.c_ptrary_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        atf_amc::TypeA* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(atf_amc::TypeA*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            parent.c_ptrary_n = lim - 1;
            break;
        }
    }
}

// --- atf_amc.FUnitSort.c_ptrary.Reserve
// Reserve space in index for N more elements;
void atf_amc::c_ptrary_Reserve(atf_amc::FUnitSort& parent, u32 n) {
    u32 old_max = parent.c_ptrary_max;
    if (UNLIKELY(parent.c_ptrary_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(atf_amc::TypeA*);
        u32 new_size = new_max * sizeof(atf_amc::TypeA*);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.c_ptrary_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.out_of_memory  field:atf_amc.FUnitSort.c_ptrary");
        }
        parent.c_ptrary_elems = (atf_amc::TypeA**)new_mem;
        parent.c_ptrary_max = new_max;
    }
}

// --- atf_amc.FUnitSort.c_ptrary.Swap
// Swap values elem_a and elem_b
inline static void atf_amc::c_ptrary_Swap(atf_amc::TypeA* &elem_a, atf_amc::TypeA* &elem_b) {
    atf_amc::TypeA *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- atf_amc.FUnitSort.c_ptrary.Rotleft
// Left circular shift of three-tuple
inline static void atf_amc::c_ptrary_Rotleft(atf_amc::TypeA* &elem_a, atf_amc::TypeA* &elem_b, atf_amc::TypeA* &elem_c) {
    atf_amc::TypeA *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- atf_amc.FUnitSort.c_ptrary.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_amc::c_ptrary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) {
    bool ret;
    ret = elem_a.typea < elem_b.typea;
    return ret;
}

// --- atf_amc.FUnitSort.c_ptrary.SortedQ
// Verify whether array is sorted
bool atf_amc::c_ptrary_SortedQ(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA* *elems = c_ptrary_Getary(parent).elems;
    int n = c_ptrary_N(parent);
    for (int i = 1; i < n; i++) {
        if (c_ptrary_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_amc.FUnitSort.c_ptrary.IntInsertionSort
// Internal insertion sort
static void atf_amc::c_ptrary_IntInsertionSort(atf_amc::TypeA* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        atf_amc::TypeA *tmp = elems[i];
        // shift elements up by one
        if (c_ptrary_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_ptrary_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- atf_amc.FUnitSort.c_ptrary.IntHeapSort
// Internal heap sort
static void atf_amc::c_ptrary_IntHeapSort(atf_amc::TypeA* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_ptrary_Lt(*elems[j], *elems[k])) {
            c_ptrary_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_ptrary_Lt(*elems[l], *elems[l+1]);
            if (c_ptrary_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_ptrary_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_ptrary_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_amc.FUnitSort.c_ptrary.IntQuickSort
// Quick sort engine
static void atf_amc::c_ptrary_IntQuickSort(atf_amc::TypeA* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_ptrary_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_ptrary_Lt(*elems[pp], *elems[pi])) {
            c_ptrary_Swap(elems[pi], elems[pp]);
        }
        if (c_ptrary_Lt(*elems[pj], *elems[pp])) {
            if (c_ptrary_Lt(*elems[pj], *elems[pi])) {
                c_ptrary_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_ptrary_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_ptrary_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        atf_amc::TypeA *pivot = elems[pj];
        for(;;){
            while (c_ptrary_Lt(*elems[++pi], *pivot)) {
            }
            while (c_ptrary_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_ptrary_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_ptrary_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_ptrary_IntInsertionSort(elems,n);
}

// --- atf_amc.FUnitSort.c_ptrary.InsertionSort
// Insertion sort
void atf_amc::c_ptrary_InsertionSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA* *elems = c_ptrary_Getary(parent).elems;
    int n = c_ptrary_N(parent);
    c_ptrary_IntInsertionSort(elems, n);
}

// --- atf_amc.FUnitSort.c_ptrary.HeapSort
// Heap sort
void atf_amc::c_ptrary_HeapSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA* *elems = c_ptrary_Getary(parent).elems;
    int n = c_ptrary_N(parent);
    c_ptrary_IntHeapSort(elems, n);
}

// --- atf_amc.FUnitSort.c_ptrary.QuickSort
// Quick sort
void atf_amc::c_ptrary_QuickSort(atf_amc::FUnitSort& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_ptrary_N(parent) + 1)) + 3;
    atf_amc::TypeA* *elems = c_ptrary_Getary(parent).elems;
    int n = c_ptrary_N(parent);
    c_ptrary_IntQuickSort(elems, n, max_depth);
}

// --- atf_amc.FUnitSort.fixary.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::fixary_ReadStrptrMaybe(atf_amc::FUnitSort& parent, algo::strptr in_str) {
    bool retval = true;
    if (100>0) {
        retval = atf_amc::TypeA_ReadStrptrMaybe(parent.fixary_elems[0], in_str);
    }
    return retval;
}

// --- atf_amc.FUnitSort.fixary.Swap
// Swap values elem_a and elem_b
inline static void atf_amc::fixary_Swap(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) {
    u8 temp[sizeof(atf_amc::TypeA)];
    memcpy(&temp  , &elem_a, sizeof(atf_amc::TypeA));
    memcpy(&elem_a, &elem_b, sizeof(atf_amc::TypeA));
    memcpy(&elem_b, &temp  , sizeof(atf_amc::TypeA));
}

// --- atf_amc.FUnitSort.fixary.Rotleft
// Left circular shift of three-tuple
inline static void atf_amc::fixary_Rotleft(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b, atf_amc::TypeA &elem_c) {
    u8 temp[sizeof(atf_amc::TypeA)];
    memcpy(&temp, &elem_a   , sizeof(atf_amc::TypeA));
    memcpy(&elem_a   , &elem_b   , sizeof(atf_amc::TypeA));
    memcpy(&elem_b   , &elem_c   , sizeof(atf_amc::TypeA));
    memcpy(&elem_c   , &temp, sizeof(atf_amc::TypeA));
}

// --- atf_amc.FUnitSort.fixary.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_amc::fixary_Lt(atf_amc::TypeA &elem_a, atf_amc::TypeA &elem_b) {
    bool ret;
    ret = elem_a.typea < elem_b.typea;
    return ret;
}

// --- atf_amc.FUnitSort.fixary.SortedQ
// Verify whether array is sorted
bool atf_amc::fixary_SortedQ(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = fixary_Getary(parent).elems;
    int n = fixary_N(parent);
    for (int i = 1; i < n; i++) {
        if (fixary_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_amc.FUnitSort.fixary.IntInsertionSort
// Internal insertion sort
static void atf_amc::fixary_IntInsertionSort(atf_amc::TypeA *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        // find the spot for ith element.
        while (j>0 && fixary_Lt(elems[i], elems[j-1])) {
            j--;
        }
        if (j<i) {
            u8 tmp[sizeof(atf_amc::TypeA)];
            memcpy (tmp                       , &elems[i], sizeof(atf_amc::TypeA)      );
            memmove(&elems[j+1], &elems[j], sizeof(atf_amc::TypeA)*(i-j));
            memcpy (&elems[j]  , tmp                     , sizeof(atf_amc::TypeA)      );
        }
    }
}

// --- atf_amc.FUnitSort.fixary.IntHeapSort
// Internal heap sort
static void atf_amc::fixary_IntHeapSort(atf_amc::TypeA *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (fixary_Lt(elems[j], elems[k])) {
            fixary_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && fixary_Lt(elems[l], elems[l+1]);
            if (fixary_Lt(elems[l], elems[i])) {
                break;
            }
            fixary_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            fixary_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_amc.FUnitSort.fixary.IntQuickSort
// Quick sort engine
static void atf_amc::fixary_IntQuickSort(atf_amc::TypeA *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            fixary_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (fixary_Lt(elems[pp], elems[pi])) {
            fixary_Swap(elems[pi], elems[pp]);
        }
        if (fixary_Lt(elems[pj], elems[pp])) {
            if (fixary_Lt(elems[pj], elems[pi])) {
                fixary_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                fixary_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        fixary_Swap(elems[--pj], elems[pp]);
        // reference to pivot
        atf_amc::TypeA &pivot = elems[pj];
        for(;;){
            while (fixary_Lt(elems[++pi], pivot)) {
            }
            while (fixary_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            fixary_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        fixary_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    fixary_IntInsertionSort(elems,n);
}

// --- atf_amc.FUnitSort.fixary.InsertionSort
// Insertion sort
void atf_amc::fixary_InsertionSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = fixary_Getary(parent).elems;
    int n = fixary_N(parent);
    fixary_IntInsertionSort(elems, n);
}

// --- atf_amc.FUnitSort.fixary.HeapSort
// Heap sort
void atf_amc::fixary_HeapSort(atf_amc::FUnitSort& parent) {
    atf_amc::TypeA *elems = fixary_Getary(parent).elems;
    int n = fixary_N(parent);
    fixary_IntHeapSort(elems, n);
}

// --- atf_amc.FUnitSort.fixary.QuickSort
// Quick sort
void atf_amc::fixary_QuickSort(atf_amc::FUnitSort& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(fixary_N(parent) + 1)) + 3;
    atf_amc::TypeA *elems = fixary_Getary(parent).elems;
    int n = fixary_N(parent);
    fixary_IntQuickSort(elems, n, max_depth);
}

// --- atf_amc.FUnitSort.fixary.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::fixary_XrefMaybe(atf_amc::TypeA &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.FUnitSort..Uninit
void atf_amc::FUnitSort_Uninit(atf_amc::FUnitSort& parent) {
    atf_amc::FUnitSort &row = parent; (void)row;

    // atf_amc.FUnitSort.c_ptrary.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(parent.c_ptrary_elems, sizeof(atf_amc::TypeA*)*parent.c_ptrary_max); // (atf_amc.FUnitSort.c_ptrary)

    // atf_amc.FUnitSort.tary.Uninit (Tary)  //
    // remove all elements from atf_amc.FUnitSort.tary
    tary_RemoveAll(parent);
    // free memory for Tary atf_amc.FUnitSort.tary
    algo_lib::malloc_FreeMem(parent.tary_elems, sizeof(atf_amc::TypeA)*parent.tary_max); // (atf_amc.FUnitSort.tary)
}

// --- atf_amc.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_FieldId_value         : ret = "value";  break;
        case atf_amc_FieldId_bit1          : ret = "bit1";  break;
        case atf_amc_FieldId_bits5         : ret = "bits5";  break;
        case atf_amc_FieldId_bit0          : ret = "bit0";  break;
        case atf_amc_FieldId_freebool      : ret = "freebool";  break;
        case atf_amc_FieldId_attr1         : ret = "attr1";  break;
        case atf_amc_FieldId_attr2         : ret = "attr2";  break;
        case atf_amc_FieldId_strval        : ret = "strval";  break;
        case atf_amc_FieldId_strval2       : ret = "strval2";  break;
        case atf_amc_FieldId_dateval       : ret = "dateval";  break;
        case atf_amc_FieldId_intval        : ret = "intval";  break;
        case atf_amc_FieldId_fixary        : ret = "fixary";  break;
        case atf_amc_FieldId_inlary        : ret = "inlary";  break;
        case atf_amc_FieldId_len           : ret = "len";  break;
        case atf_amc_FieldId_type          : ret = "type";  break;
        case atf_amc_FieldId_length        : ret = "length";  break;
        case atf_amc_FieldId_base          : ret = "base";  break;
        case atf_amc_FieldId_a             : ret = "a";  break;
        case atf_amc_FieldId_b             : ret = "b";  break;
        case atf_amc_FieldId_o             : ret = "o";  break;
        case atf_amc_FieldId_v             : ret = "v";  break;
        case atf_amc_FieldId_typeg         : ret = "typeg";  break;
        case atf_amc_FieldId_optg          : ret = "optg";  break;
        case atf_amc_FieldId_present       : ret = "present";  break;
        case atf_amc_FieldId_assigned      : ret = "assigned";  break;
        case atf_amc_FieldId_nullable      : ret = "nullable";  break;
        case atf_amc_FieldId_value1        : ret = "value1";  break;
        case atf_amc_FieldId_value2        : ret = "value2";  break;
        case atf_amc_FieldId_value3        : ret = "value3";  break;
        case atf_amc_FieldId_value4        : ret = "value4";  break;
        case atf_amc_FieldId_value5        : ret = "value5";  break;
        case atf_amc_FieldId_value6        : ret = "value6";  break;
        case atf_amc_FieldId_value7        : ret = "value7";  break;
        case atf_amc_FieldId_pmask         : ret = "pmask";  break;
        case atf_amc_FieldId_value21       : ret = "value21";  break;
        case atf_amc_FieldId_value22       : ret = "value22";  break;
        case atf_amc_FieldId_value23       : ret = "value23";  break;
        case atf_amc_FieldId_value24       : ret = "value24";  break;
        case atf_amc_FieldId_value25       : ret = "value25";  break;
        case atf_amc_FieldId_value26       : ret = "value26";  break;
        case atf_amc_FieldId_value20       : ret = "value20";  break;
        case atf_amc_FieldId_value28       : ret = "value28";  break;
        case atf_amc_FieldId_value29       : ret = "value29";  break;
        case atf_amc_FieldId_value30       : ret = "value30";  break;
        case atf_amc_FieldId_value31       : ret = "value31";  break;
        case atf_amc_FieldId_value32       : ret = "value32";  break;
        case atf_amc_FieldId_value27       : ret = "value27";  break;
        case atf_amc_FieldId_value19       : ret = "value19";  break;
        case atf_amc_FieldId_value18       : ret = "value18";  break;
        case atf_amc_FieldId_value8        : ret = "value8";  break;
        case atf_amc_FieldId_value9        : ret = "value9";  break;
        case atf_amc_FieldId_value69       : ret = "value69";  break;
        case atf_amc_FieldId_value11       : ret = "value11";  break;
        case atf_amc_FieldId_value12       : ret = "value12";  break;
        case atf_amc_FieldId_value13       : ret = "value13";  break;
        case atf_amc_FieldId_value14       : ret = "value14";  break;
        case atf_amc_FieldId_value15       : ret = "value15";  break;
        case atf_amc_FieldId_value16       : ret = "value16";  break;
        case atf_amc_FieldId_value33       : ret = "value33";  break;
        case atf_amc_FieldId_value10       : ret = "value10";  break;
        case atf_amc_FieldId_value17       : ret = "value17";  break;
        case atf_amc_FieldId_value35       : ret = "value35";  break;
        case atf_amc_FieldId_value55       : ret = "value55";  break;
        case atf_amc_FieldId_value56       : ret = "value56";  break;
        case atf_amc_FieldId_value57       : ret = "value57";  break;
        case atf_amc_FieldId_value58       : ret = "value58";  break;
        case atf_amc_FieldId_value59       : ret = "value59";  break;
        case atf_amc_FieldId_value60       : ret = "value60";  break;
        case atf_amc_FieldId_value54       : ret = "value54";  break;
        case atf_amc_FieldId_value62       : ret = "value62";  break;
        case atf_amc_FieldId_value63       : ret = "value63";  break;
        case atf_amc_FieldId_value64       : ret = "value64";  break;
        case atf_amc_FieldId_value65       : ret = "value65";  break;
        case atf_amc_FieldId_value66       : ret = "value66";  break;
        case atf_amc_FieldId_value67       : ret = "value67";  break;
        case atf_amc_FieldId_value68       : ret = "value68";  break;
        case atf_amc_FieldId_value61       : ret = "value61";  break;
        case atf_amc_FieldId_value34       : ret = "value34";  break;
        case atf_amc_FieldId_value52       : ret = "value52";  break;
        case atf_amc_FieldId_value36       : ret = "value36";  break;
        case atf_amc_FieldId_value37       : ret = "value37";  break;
        case atf_amc_FieldId_value38       : ret = "value38";  break;
        case atf_amc_FieldId_value39       : ret = "value39";  break;
        case atf_amc_FieldId_value40       : ret = "value40";  break;
        case atf_amc_FieldId_value41       : ret = "value41";  break;
        case atf_amc_FieldId_value42       : ret = "value42";  break;
        case atf_amc_FieldId_value53       : ret = "value53";  break;
        case atf_amc_FieldId_value44       : ret = "value44";  break;
        case atf_amc_FieldId_value45       : ret = "value45";  break;
        case atf_amc_FieldId_value46       : ret = "value46";  break;
        case atf_amc_FieldId_value47       : ret = "value47";  break;
        case atf_amc_FieldId_value48       : ret = "value48";  break;
        case atf_amc_FieldId_value49       : ret = "value49";  break;
        case atf_amc_FieldId_value50       : ret = "value50";  break;
        case atf_amc_FieldId_value51       : ret = "value51";  break;
        case atf_amc_FieldId_value43       : ret = "value43";  break;
        case atf_amc_FieldId_value70       : ret = "value70";  break;
        case atf_amc_FieldId_value71       : ret = "value71";  break;
        case atf_amc_FieldId_ch            : ret = "ch";  break;
        case atf_amc_FieldId_val1          : ret = "val1";  break;
        case atf_amc_FieldId_val2          : ret = "val2";  break;
        case atf_amc_FieldId_val3          : ret = "val3";  break;
        case atf_amc_FieldId_msghdr        : ret = "msghdr";  break;
        case atf_amc_FieldId_payload       : ret = "payload";  break;
        case atf_amc_FieldId_val           : ret = "val";  break;
        case atf_amc_FieldId_text          : ret = "text";  break;
        case atf_amc_FieldId_typea         : ret = "typea";  break;
        case atf_amc_FieldId_j             : ret = "j";  break;
        case atf_amc_FieldId_typec         : ret = "typec";  break;
        case atf_amc_FieldId_typeh         : ret = "typeh";  break;
        case atf_amc_FieldId_types         : ret = "types";  break;
        case atf_amc_FieldId_comment       : ret = "comment";  break;
        case atf_amc_FieldId_i             : ret = "i";  break;
        case atf_amc_FieldId_k             : ret = "k";  break;
        case atf_amc_FieldId_strval_regx   : ret = "strval_regx";  break;
        case atf_amc_FieldId_strval2_regx  : ret = "strval2_regx";  break;
        case atf_amc_FieldId_start_dateval : ret = "start_dateval";  break;
        case atf_amc_FieldId_end_dateval   : ret = "end_dateval";  break;
        case atf_amc_FieldId_start_intval  : ret = "start_intval";  break;
        case atf_amc_FieldId_end_intval    : ret = "end_intval";  break;
    }
    return ret;
}

// --- atf_amc.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'a': {
                    value_SetEnum(parent,atf_amc_FieldId_a); ret = true; break;
                }
                case 'b': {
                    value_SetEnum(parent,atf_amc_FieldId_b); ret = true; break;
                }
                case 'i': {
                    value_SetEnum(parent,atf_amc_FieldId_i); ret = true; break;
                }
                case 'j': {
                    value_SetEnum(parent,atf_amc_FieldId_j); ret = true; break;
                }
                case 'k': {
                    value_SetEnum(parent,atf_amc_FieldId_k); ret = true; break;
                }
                case 'o': {
                    value_SetEnum(parent,atf_amc_FieldId_o); ret = true; break;
                }
                case 'v': {
                    value_SetEnum(parent,atf_amc_FieldId_v); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('c','h'): {
                    value_SetEnum(parent,atf_amc_FieldId_ch); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('l','e','n'): {
                    value_SetEnum(parent,atf_amc_FieldId_len); ret = true; break;
                }
                case LE_STR3('v','a','l'): {
                    value_SetEnum(parent,atf_amc_FieldId_val); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,atf_amc_FieldId_base); ret = true; break;
                }
                case LE_STR4('b','i','t','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_bit0); ret = true; break;
                }
                case LE_STR4('b','i','t','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_bit1); ret = true; break;
                }
                case LE_STR4('o','p','t','g'): {
                    value_SetEnum(parent,atf_amc_FieldId_optg); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,atf_amc_FieldId_text); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,atf_amc_FieldId_type); ret = true; break;
                }
                case LE_STR4('v','a','l','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_val1); ret = true; break;
                }
                case LE_STR4('v','a','l','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_val2); ret = true; break;
                }
                case LE_STR4('v','a','l','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_val3); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','t','t','r','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_attr1); ret = true; break;
                }
                case LE_STR5('a','t','t','r','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_attr2); ret = true; break;
                }
                case LE_STR5('b','i','t','s','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_bits5); ret = true; break;
                }
                case LE_STR5('p','m','a','s','k'): {
                    value_SetEnum(parent,atf_amc_FieldId_pmask); ret = true; break;
                }
                case LE_STR5('t','y','p','e','a'): {
                    value_SetEnum(parent,atf_amc_FieldId_typea); ret = true; break;
                }
                case LE_STR5('t','y','p','e','c'): {
                    value_SetEnum(parent,atf_amc_FieldId_typec); ret = true; break;
                }
                case LE_STR5('t','y','p','e','g'): {
                    value_SetEnum(parent,atf_amc_FieldId_typeg); ret = true; break;
                }
                case LE_STR5('t','y','p','e','h'): {
                    value_SetEnum(parent,atf_amc_FieldId_typeh); ret = true; break;
                }
                case LE_STR5('t','y','p','e','s'): {
                    value_SetEnum(parent,atf_amc_FieldId_types); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,atf_amc_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('f','i','x','a','r','y'): {
                    value_SetEnum(parent,atf_amc_FieldId_fixary); ret = true; break;
                }
                case LE_STR6('i','n','l','a','r','y'): {
                    value_SetEnum(parent,atf_amc_FieldId_inlary); ret = true; break;
                }
                case LE_STR6('i','n','t','v','a','l'): {
                    value_SetEnum(parent,atf_amc_FieldId_intval); ret = true; break;
                }
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,atf_amc_FieldId_length); ret = true; break;
                }
                case LE_STR6('m','s','g','h','d','r'): {
                    value_SetEnum(parent,atf_amc_FieldId_msghdr); ret = true; break;
                }
                case LE_STR6('s','t','r','v','a','l'): {
                    value_SetEnum(parent,atf_amc_FieldId_strval); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value1); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value2); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value3); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value4); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value5); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value6); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value7); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value8); ret = true; break;
                }
                case LE_STR6('v','a','l','u','e','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value9); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,atf_amc_FieldId_comment); ret = true; break;
                }
                case LE_STR7('d','a','t','e','v','a','l'): {
                    value_SetEnum(parent,atf_amc_FieldId_dateval); ret = true; break;
                }
                case LE_STR7('p','a','y','l','o','a','d'): {
                    value_SetEnum(parent,atf_amc_FieldId_payload); ret = true; break;
                }
                case LE_STR7('p','r','e','s','e','n','t'): {
                    value_SetEnum(parent,atf_amc_FieldId_present); ret = true; break;
                }
                case LE_STR7('s','t','r','v','a','l','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_strval2); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value10); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value11); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value12); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value13); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value14); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value15); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value16); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value17); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value18); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','1','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value19); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value20); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value21); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value22); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value23); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value24); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value25); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value26); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value27); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value28); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','2','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value29); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value30); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value31); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value32); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value33); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value34); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value35); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value36); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value37); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value38); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','3','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value39); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value40); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value41); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value42); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value43); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value44); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value45); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value46); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value47); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value48); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','4','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value49); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value50); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value51); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value52); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value53); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value54); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value55); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value56); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value57); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value58); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','5','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value59); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value60); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value61); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','2'): {
                    value_SetEnum(parent,atf_amc_FieldId_value62); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','3'): {
                    value_SetEnum(parent,atf_amc_FieldId_value63); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','4'): {
                    value_SetEnum(parent,atf_amc_FieldId_value64); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','5'): {
                    value_SetEnum(parent,atf_amc_FieldId_value65); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','6'): {
                    value_SetEnum(parent,atf_amc_FieldId_value66); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','7'): {
                    value_SetEnum(parent,atf_amc_FieldId_value67); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','8'): {
                    value_SetEnum(parent,atf_amc_FieldId_value68); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','6','9'): {
                    value_SetEnum(parent,atf_amc_FieldId_value69); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','7','0'): {
                    value_SetEnum(parent,atf_amc_FieldId_value70); ret = true; break;
                }
                case LE_STR7('v','a','l','u','e','7','1'): {
                    value_SetEnum(parent,atf_amc_FieldId_value71); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','s','s','i','g','n','e','d'): {
                    value_SetEnum(parent,atf_amc_FieldId_assigned); ret = true; break;
                }
                case LE_STR8('f','r','e','e','b','o','o','l'): {
                    value_SetEnum(parent,atf_amc_FieldId_freebool); ret = true; break;
                }
                case LE_STR8('n','u','l','l','a','b','l','e'): {
                    value_SetEnum(parent,atf_amc_FieldId_nullable); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('e','n','d','_','i','n','t','v'): {
                    if (memcmp(rhs.elems+8,"al",2)==0) { value_SetEnum(parent,atf_amc_FieldId_end_intval); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('e','n','d','_','d','a','t','e'): {
                    if (memcmp(rhs.elems+8,"val",3)==0) { value_SetEnum(parent,atf_amc_FieldId_end_dateval); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','v','a','l','_','r'): {
                    if (memcmp(rhs.elems+8,"egx",3)==0) { value_SetEnum(parent,atf_amc_FieldId_strval_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','a','r','t','_','i','n'): {
                    if (memcmp(rhs.elems+8,"tval",4)==0) { value_SetEnum(parent,atf_amc_FieldId_start_intval); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','v','a','l','2','_'): {
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,atf_amc_FieldId_strval2_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','a','r','t','_','d','a'): {
                    if (memcmp(rhs.elems+8,"teval",5)==0) { value_SetEnum(parent,atf_amc_FieldId_start_dateval); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::FieldId& parent, algo::strptr rhs, atf_amc_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.FieldId..ReadStrptrMaybe
// Read fields of atf_amc::FieldId from an ascii string.
// The format of the string is the format of the atf_amc::FieldId's only field
bool atf_amc::FieldId_ReadStrptrMaybe(atf_amc::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.FieldId..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.FieldId.String  printfmt:Raw
void atf_amc::FieldId_Print(atf_amc::FieldId& row, algo::cstring& str) {
    atf_amc::value_Print(row, str);
}

// --- atf_amc.InlaryPrint.fixary.Print
// Convert fixary to a string.
// The separator character is ' '.
void atf_amc::fixary_Print(atf_amc::InlaryPrint& parent, algo::cstring &rhs) {
    ind_beg(InlaryPrint_fixary_curs,fixary_elem,parent) {
        if (ind_curs(fixary_elem).index > 0) {
            rhs << ' ';
        }
        u32_Print(fixary_elem, rhs);
    }ind_end;
}

// --- atf_amc.InlaryPrint.fixary.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::fixary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) {
    bool retval = true;
    for (int i=0; in_str != "" && i < 3; i++) {
        algo::strptr token;
        algo::NextSep(in_str, ' ', token);
        retval = u32_ReadStrptrMaybe(parent.fixary_elems[i], token);
        if (!retval) {
            break;
        }
    }
    return retval;
}

// --- atf_amc.InlaryPrint.inlary.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
u32& atf_amc::inlary_Alloc(atf_amc::InlaryPrint& parent) {
    u32* row = inlary_AllocMaybe(parent);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.InlaryPrint.inlary  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.InlaryPrint.inlary.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
u32* atf_amc::inlary_AllocMaybe(atf_amc::InlaryPrint& parent) {
    u32 *row = (u32*)inlary_AllocMem(parent);
    if (row) {
        new (row) u32; // call constructor
    }
    return row;
}

// --- atf_amc.InlaryPrint.inlary.RemoveAll
// Destroy all elements of Inlary
void atf_amc::inlary_RemoveAll(atf_amc::InlaryPrint& parent) {
    parent.inlary_n = 0;
}

// --- atf_amc.InlaryPrint.inlary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::inlary_RemoveLast(atf_amc::InlaryPrint& parent) {
    u64 n = parent.inlary_n;
    if (n > 0) {
        n -= 1;
        parent.inlary_n = n;
    }
}

// --- atf_amc.InlaryPrint.inlary.Print
// Convert inlary to a string.
// The separator character is ' '.
void atf_amc::inlary_Print(atf_amc::InlaryPrint& parent, algo::cstring &rhs) {
    ind_beg(InlaryPrint_inlary_curs,inlary_elem,parent) {
        if (ind_curs(inlary_elem).index > 0) {
            rhs << ' ';
        }
        u32_Print(inlary_elem, rhs);
    }ind_end;
}

// --- atf_amc.InlaryPrint.inlary.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::inlary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) {
    bool retval = true;
    inlary_RemoveAll(parent);
    for (int i=0; in_str != "" && i < 10; i++) {
        algo::strptr token;
        algo::NextSep(in_str, ' ', token);
        if (i >= 0) { // make room for new element...
            u32 &elem = inlary_Alloc(parent);
            (void)elem; // will succeed due to a previous check
        }
        retval = u32_ReadStrptrMaybe(reinterpret_cast<u32*>(parent.inlary_data)[i], token);
        if (!retval) {
            inlary_RemoveLast(parent);
            break;
        }
    }
    return retval;
}

// --- atf_amc.InlaryPrint..ReadFieldMaybe
bool atf_amc::InlaryPrint_ReadFieldMaybe(atf_amc::InlaryPrint& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_fixary: {
            retval = fixary_ReadStrptrMaybe(parent, strval);
            break;
        }
        case atf_amc_FieldId_inlary: {
            retval = inlary_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.InlaryPrint..ReadStrptrMaybe
// Read fields of atf_amc::InlaryPrint from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::InlaryPrint_ReadStrptrMaybe(atf_amc::InlaryPrint &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.InlaryPrint");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && InlaryPrint_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.InlaryPrint..Init
// Set all fields to initial values.
void atf_amc::InlaryPrint_Init(atf_amc::InlaryPrint& parent) {
    for (int i = 0; i < 3; i++) {
        parent.fixary_elems[i] = 0;
    }
    parent.inlary_n = 0; // inlary: initialize count
}

// --- atf_amc.InlaryPrint..Uninit
void atf_amc::InlaryPrint_Uninit(atf_amc::InlaryPrint& parent) {
    atf_amc::InlaryPrint &row = parent; (void)row;

    // atf_amc.InlaryPrint.inlary.Uninit (Inlary)  //
    inlary_RemoveAll(parent);
}

// --- atf_amc.InlaryPrint..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.InlaryPrint.String  printfmt:Tuple
void atf_amc::InlaryPrint_Print(atf_amc::InlaryPrint& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.InlaryPrint";

    atf_amc::fixary_Print(row, temp);
    PrintAttrSpaceReset(str,"fixary", temp);

    atf_amc::inlary_Print(row, temp);
    PrintAttrSpaceReset(str,"inlary", temp);
}

// --- atf_amc.Lary32.lary.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
u32& atf_amc::lary_Alloc(atf_amc::Lary32& parent) {
    u32* row = lary_AllocMaybe(parent);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("atf_amc.out_of_mem  field:atf_amc.Lary32.lary  comment:'Alloc failed'");
    }
    return *row;
}

// --- atf_amc.Lary32.lary.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
u32* atf_amc::lary_AllocMaybe(atf_amc::Lary32& parent) {
    u32 *row = (u32*)lary_AllocMem(parent);
    if (row) {
        new (row) u32; // call constructor
    }
    return row;
}

// --- atf_amc.Lary32.lary.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* atf_amc::lary_AllocMem(atf_amc::Lary32& parent) {
    u64 new_nelems     = parent.lary_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    u32*  lev   = NULL;
    if (bsr < 32) {
        lev = parent.lary_lary[bsr];
        if (!lev) {
            lev=(u32*)algo_lib::malloc_AllocMem(sizeof(u32) * (u64(1)<<bsr));
            parent.lary_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        parent.lary_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- atf_amc.Lary32.lary.RemoveAll
// Remove all elements from Lary
void atf_amc::lary_RemoveAll(atf_amc::Lary32& parent) {
    parent.lary_n = 0;
}

// --- atf_amc.Lary32.lary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::lary_RemoveLast(atf_amc::Lary32& parent) {
    u64 n = parent.lary_n;
    if (n > 0) {
        n -= 1;
        parent.lary_n = i32(n);
    }
}

// --- atf_amc.Lary32..Init
// Set all fields to initial values.
void atf_amc::Lary32_Init(atf_amc::Lary32& parent) {
    // initialize LAry lary (atf_amc.Lary32.lary)
    parent.lary_n = 0;
    memset(parent.lary_lary, 0, sizeof(parent.lary_lary)); // zero out all level pointers
    u32* lary_first = (u32*)algo_lib::malloc_AllocMem(sizeof(u32) * (u64(1)<<4));
    if (!lary_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        parent.lary_lary[i]  = lary_first;
        lary_first    += 1ULL<<i;
    }
}

// --- atf_amc.Lary32..Uninit
void atf_amc::Lary32_Uninit(atf_amc::Lary32& parent) {
    atf_amc::Lary32 &row = parent; (void)row;

    // atf_amc.Lary32.lary.Uninit (Lary)  //
    // destroy atf_amc.Lary32.lary
    // destroy all elements
    lary_RemoveAll(parent);
    // destroy all levels. stop when NULL level is found -- there is nothing beyond it
    algo_lib::malloc_FreeMem(parent.lary_lary[0],sizeof(u32) * (u64(1)<<4));
    for (u64 i = 4; i < 32 && parent.lary_lary[i]; i++) {
        algo_lib::malloc_FreeMem(parent.lary_lary[i],sizeof(u32) * (u64(1)<<i));
    }
}

// --- atf_amc.Linebuf.in.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
// 
algo::aryptr<char> atf_amc::in_GetMsg(atf_amc::Linebuf& linebuf) {
    algo::aryptr<char> ret;
    if (!linebuf.in_msgvalid) {
        in_Scanmsg(linebuf);
    }
    char *hdr = (char*)(linebuf.in_elems + linebuf.in_start);
    if (linebuf.in_msgvalid) {
        ret.elems = hdr;
        ret.n_elems = linebuf.in_msglen;
    }
    return ret;
}

// --- atf_amc.Linebuf.in.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::in_RemoveAll(atf_amc::Linebuf& linebuf) {
    linebuf.in_start    = 0;
    linebuf.in_end      = 0;
    linebuf.in_msgvalid = false;
    linebuf.in_msglen   = 0; // reset message length -- important for delimited streams
}

// --- atf_amc.Linebuf.in.Scanmsg
// Internal function to scan for a message
// 
static void atf_amc::in_Scanmsg(atf_amc::Linebuf& linebuf) {
    char *hdr = (char*)(linebuf.in_elems + linebuf.in_start);
    i32 avail = in_N(linebuf);
    i32 msglen;
    bool found = false;
    // scan for delimiter starting from the previous place where we left off.
    // at the end, save offset back to linebuf so we don't have to re-scan.
    // returned message length **does not include delimiter**.
    // a line that exceeds buffer length is not returned.
    for (msglen = linebuf.in_msglen; msglen < avail; msglen += sizeof(char)) {
        if (hdr[msglen] == '\n') { // delimiter?
            found = true;
            break;
        }
    }
    if (!found && msglen >= in_Max(linebuf)) {
        linebuf.in_eof = true; // cause user to detect eof
        linebuf.in_err = algo::FromErrno(E2BIG); // argument list too big -- closest error code
    }
    linebuf.in_msglen = msglen;
    linebuf.in_msgvalid = found;
}

// --- atf_amc.Linebuf.in.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::in_Shift(atf_amc::Linebuf& linebuf) {
    i32 start = linebuf.in_start;
    i32 bytes_n = linebuf.in_end - start;
    if (bytes_n > 0) {
        memmove(linebuf.in_elems, linebuf.in_elems + start, bytes_n);
    }
    linebuf.in_end = bytes_n;
    linebuf.in_start = 0;
}

// --- atf_amc.Linebuf.in.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void atf_amc::in_SkipBytes(atf_amc::Linebuf& linebuf, int n) {
    int avail = linebuf.in_end - linebuf.in_start;
    n = i32_Min(n,avail);
    linebuf.in_start += n;
}

// --- atf_amc.Linebuf.in.SkipMsg
// Skip current message, if any
// Skip current message, if any.
void atf_amc::in_SkipMsg(atf_amc::Linebuf& linebuf) {
    if (linebuf.in_msgvalid) {
        int skip = linebuf.in_msglen;
        skip += ssizeof(char); // delimiter
        i32 start = linebuf.in_start;
        start += skip;
        linebuf.in_start = start;
        linebuf.in_msgvalid = false;
        linebuf.in_msglen   = 0; // reset message length -- important for delimited streams
    }
}

// --- atf_amc.Linebuf.in.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::in_WriteAll(atf_amc::Linebuf& linebuf, u8 *in, i32 in_n) {
    int max = in_Max(linebuf);
    // check if message doesn't fit. if so, shift bytes over.
    if (linebuf.in_end + in_n > max) {
        in_Shift(linebuf);
    }
    // now try to write the message.
    i32 end = linebuf.in_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(linebuf.in_elems + end, in, in_n);
        linebuf.in_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.Linebuf..Init
// Set all fields to initial values.
void atf_amc::Linebuf_Init(atf_amc::Linebuf& linebuf) {
    linebuf.in_end = 0; // in: initialize
    linebuf.in_start = 0; // in: initialize
    linebuf.in_eof = false; // in: initialize
    linebuf.in_msgvalid = false; // in: initialize
    linebuf.in_msglen = 0; // in: initialize
    linebuf.in_epoll_enable = true; // in: initialize
}

// --- atf_amc.Linebuf..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Linebuf.String  printfmt:Raw
void atf_amc::Linebuf_Print(atf_amc::Linebuf& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgHdrLT.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::type_ToCstr(const atf_amc::MsgHdrLT& o) {
    const char *ret = NULL;
    switch(type_GetEnum(o)) {
        case atf_amc_MsgHdrLT_type_atf_amc_MsgLTA: ret = "atf_amc.MsgLTA";  break;
        case atf_amc_MsgHdrLT_type_atf_amc_MsgLTB: ret = "atf_amc.MsgLTB";  break;
        case atf_amc_MsgHdrLT_type_atf_amc_MsgLTO: ret = "atf_amc.MsgLTO";  break;
        case atf_amc_MsgHdrLT_type_atf_amc_MsgLTV: ret = "atf_amc.MsgLTV";  break;
    }
    return ret;
}

// --- atf_amc.MsgHdrLT.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void atf_amc::type_Print(const atf_amc::MsgHdrLT& o, algo::cstring &lhs) {
    const char *strval = type_ToCstr(o);
    if (strval) {
        lhs << strval;
    } else {
        lhs << o.type;
    }
}

// --- atf_amc.MsgHdrLT.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::type_SetStrptrMaybe(atf_amc::MsgHdrLT& o, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"MsgLTA",6)==0) { type_SetEnum(o,atf_amc_MsgHdrLT_type_atf_amc_MsgLTA); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTB",6)==0) { type_SetEnum(o,atf_amc_MsgHdrLT_type_atf_amc_MsgLTB); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTO",6)==0) { type_SetEnum(o,atf_amc_MsgHdrLT_type_atf_amc_MsgLTO); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTV",6)==0) { type_SetEnum(o,atf_amc_MsgHdrLT_type_atf_amc_MsgLTV); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.MsgHdrLT.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::type_SetStrptr(atf_amc::MsgHdrLT& o, algo::strptr rhs, atf_amc_MsgHdrLT_type_Enum dflt) {
    if (!type_SetStrptrMaybe(o,rhs)) type_SetEnum(o,dflt);
}

// --- atf_amc.MsgHdrLT.type.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::type_ReadStrptrMaybe(atf_amc::MsgHdrLT& o, algo::strptr rhs) {
    bool retval = false;
    retval = type_SetStrptrMaybe(o,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = char_ReadStrptrMaybe(o.type,rhs);
    }
    return retval;
}

// --- atf_amc.MsgHdrLT..ReadFieldMaybe
bool atf_amc::MsgHdrLT_ReadFieldMaybe(atf_amc::MsgHdrLT& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_len: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = type_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.MsgHdrLT..ReadStrptrMaybe
// Read fields of atf_amc::MsgHdrLT from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgHdrLT_ReadStrptrMaybe(atf_amc::MsgHdrLT &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgHdrLT");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgHdrLT_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgHdrLT..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgHdrLT.String  printfmt:Tuple
void atf_amc::MsgHdrLT_Print(atf_amc::MsgHdrLT& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgHdrLT";
    (void)row;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgHdrLTMsgsCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::MsgHdrLTMsgsCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTA: ret = "atf_amc.MsgLTA";  break;
        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTB: ret = "atf_amc.MsgLTB";  break;
        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTO: ret = "atf_amc.MsgLTO";  break;
        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTV: ret = "atf_amc.MsgLTV";  break;
    }
    return ret;
}

// --- atf_amc.MsgHdrLTMsgsCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::MsgHdrLTMsgsCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.MsgHdrLTMsgsCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"MsgLTA",6)==0) { value_SetEnum(parent,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTA); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTB",6)==0) { value_SetEnum(parent,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTB); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTO",6)==0) { value_SetEnum(parent,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTO); ret = true; break; }
                    if (memcmp(rhs.elems+8,"MsgLTV",6)==0) { value_SetEnum(parent,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTV); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.MsgHdrLTMsgsCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs, atf_amc_MsgHdrLTMsgsCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.MsgHdrLTMsgsCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.MsgHdrLTMsgsCase..ReadStrptrMaybe
// Read fields of atf_amc::MsgHdrLTMsgsCase from an ascii string.
// The format of the string is the format of the atf_amc::MsgHdrLTMsgsCase's only field
bool atf_amc::MsgHdrLTMsgsCase_ReadStrptrMaybe(atf_amc::MsgHdrLTMsgsCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.MsgType.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::MsgType& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_MsgType_atf_amc_Seqmsg: ret = "atf_amc.Seqmsg";  break;
        case atf_amc_MsgType_atf_amc_Text  : ret = "atf_amc.Text";  break;
        case atf_amc_MsgType_atf_amc_VarlenMsg: ret = "atf_amc.VarlenMsg";  break;
    }
    return ret;
}

// --- atf_amc.MsgType.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::MsgType& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.MsgType.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"Text",4)==0) { value_SetEnum(parent,atf_amc_MsgType_atf_amc_Text); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"Seqmsg",6)==0) { value_SetEnum(parent,atf_amc_MsgType_atf_amc_Seqmsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"VarlenMsg",9)==0) { value_SetEnum(parent,atf_amc_MsgType_atf_amc_VarlenMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.MsgType.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::MsgType& parent, algo::strptr rhs, atf_amc_MsgTypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.MsgType.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u16_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.MsgType..ReadStrptrMaybe
// Read fields of atf_amc::MsgType from an ascii string.
// The format of the string is the format of the atf_amc::MsgType's only field
bool atf_amc::MsgType_ReadStrptrMaybe(atf_amc::MsgType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.MsgType..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgType.String  printfmt:Raw
void atf_amc::MsgType_Print(atf_amc::MsgType row, algo::cstring& str) {
    atf_amc::value_Print(row, str);
}

// --- atf_amc.MsgLength..ReadStrptrMaybe
// Read fields of atf_amc::MsgLength from an ascii string.
// The format of the string is the format of the atf_amc::MsgLength's only field
bool atf_amc::MsgLength_ReadStrptrMaybe(atf_amc::MsgLength &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u16_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- atf_amc.MsgLength..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLength.String  printfmt:Raw
void atf_amc::MsgLength_Print(atf_amc::MsgLength row, algo::cstring& str) {
    u16_Print(row.value, str);
}

// --- atf_amc.MsgHeader..ReadFieldMaybe
bool atf_amc::MsgHeader_ReadFieldMaybe(atf_amc::MsgHeader& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    (void)parent;//only to avoid -Wunused-parameter
    (void)strval;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.MsgHeader..ReadStrptrMaybe
// Read fields of atf_amc::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgHeader_ReadStrptrMaybe(atf_amc::MsgHeader &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgHeader");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgHeader_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgHeader..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgHeader.String  printfmt:Tuple
void atf_amc::MsgHeader_Print(atf_amc::MsgHeader& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgHeader";
    (void)row;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgLTA.base.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::MsgLTA &row, atf_amc::MsgHdrLT &out) {
    // len: field value is computed
    // type: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgLTA..ReadFieldMaybe
bool atf_amc::MsgLTA_ReadFieldMaybe(atf_amc::MsgLTA& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_base: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_len: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_a: {
            retval = algo::RspaceStr4_ReadStrptrMaybe(parent.a, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.MsgLTA..ReadStrptrMaybe
// Read fields of atf_amc::MsgLTA from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgLTA_ReadStrptrMaybe(atf_amc::MsgLTA &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgLTA");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgLTA_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgLTA..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTA.String  printfmt:Tuple
void atf_amc::MsgLTA_Print(atf_amc::MsgLTA& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgLTA";

    algo::RspaceStr4_Print(row.a, temp);
    PrintAttrSpaceReset(str,"a", temp);
}

// --- atf_amc.MsgLTB.base.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::MsgLTB &row, atf_amc::MsgHdrLT &out) {
    // len: field value is computed
    // type: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgLTB..ReadFieldMaybe
bool atf_amc::MsgLTB_ReadFieldMaybe(atf_amc::MsgLTB& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_base: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_len: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_b: {
            retval = algo::RspaceStr6_ReadStrptrMaybe(parent.b, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.MsgLTB..ReadStrptrMaybe
// Read fields of atf_amc::MsgLTB from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgLTB_ReadStrptrMaybe(atf_amc::MsgLTB &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgLTB");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgLTB_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgLTB..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTB.String  printfmt:Tuple
void atf_amc::MsgLTB_Print(atf_amc::MsgLTB& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgLTB";

    algo::RspaceStr6_Print(row.b, temp);
    PrintAttrSpaceReset(str,"b", temp);
}

// --- atf_amc.MsgLTO.base.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::MsgLTO &row, atf_amc::MsgHdrLT &out) {
    // len: field value is computed
    // type: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgLTO.o.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::o_Getary(atf_amc::MsgLTO& parent) {
    u8 *end = (u8*)&parent + sizeof(atf_amc::MsgLTO);
    return algo::aryptr<u8>(end, i32(parent.len + 2) - ssizeof(atf_amc::MsgLTO));
}

// --- atf_amc.MsgLTO.o.Print
void atf_amc::o_Print(atf_amc::MsgLTO& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (atf_amc::MsgHdrLT *o = o_Get(parent)) {
        atf_amc::MsgHdrLTMsgs_Print(out, *o, INT_MAX);
    }
}

// --- atf_amc.MsgLTO.o.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::o_ReadStrptrMaybe(atf_amc::MsgLTO &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = atf_amc::MsgHdrLTMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.MsgLTO.o.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::o_XrefMaybe(atf_amc::MsgHdrLT &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.MsgLTO..ReadFieldMaybe
bool atf_amc::MsgLTO_ReadFieldMaybe(atf_amc::MsgLTO& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_base: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_len: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_o: {
            retval = o_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.MsgLTO..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::MsgLTO from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgLTO_ReadStrptrMaybe(atf_amc::MsgLTO &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgLTO");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgLTO_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgLTO..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTO.String  printfmt:Tuple
void atf_amc::MsgLTO_Print(atf_amc::MsgLTO& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgLTO";

    if (o_Get(row)) {
        atf_amc::o_Print(row, temp);
        PrintAttrSpaceReset(str,"o", temp);
    }
}

// --- atf_amc.MsgLTV.base.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::MsgLTV &row, atf_amc::MsgHdrLT &out) {
    // len: field value is computed
    // type: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgLTV.v.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> atf_amc::v_Getary(atf_amc::MsgLTV& parent) {
    return algo::aryptr<u8>(v_Addr(parent), v_N(parent));
}

// --- atf_amc.MsgLTV.v.Addr
u8* atf_amc::v_Addr(atf_amc::MsgLTV& parent) {
    return (u8*)((u8*)&parent + sizeof(atf_amc::MsgLTV)); // address of varlen portion
}

// --- atf_amc.MsgLTV.v.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::v_ReadStrptrMaybe(atf_amc::MsgLTV& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = atf_amc::MsgHdrLTMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Addary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.MsgLTV..ReadFieldMaybe
bool atf_amc::MsgLTV_ReadFieldMaybe(atf_amc::MsgLTV& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_base: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_len: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_v: {
            retval = v_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.MsgLTV..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::MsgLTV from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::MsgLTV_ReadStrptrMaybe(atf_amc::MsgLTV &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.MsgLTV");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgLTV_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.MsgLTV..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTV.String  printfmt:Tuple
void atf_amc::MsgLTV_Print(atf_amc::MsgLTV& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.MsgLTV";

    ind_beg(MsgLTV_v_curs,v,row) {
        atf_amc::MsgHdrLTMsgs_Print(temp, v, INT_MAX);
        tempstr name;
        name << "v.";
        name << ind_curs(v).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;
}

// --- atf_amc.Msgbuf.in.BeginRead
// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_amc::Msgbuf.in via FIohook field.
// Whenever the file descriptor becomes readable, insert msgbuf into cd_in_msg.
void atf_amc::in_BeginRead(atf_amc::Msgbuf& msgbuf, algo::Fildes fd) {
    callback_Set1(msgbuf.in_iohook, msgbuf, atf_amc::cd_in_msg_Insert);
    msgbuf.in_iohook.fildes = fd;
    IOEvtFlags flags;
    read_Set(flags, true);
    if (msgbuf.in_epoll_enable) {
        algo_lib::IohookAdd(msgbuf.in_iohook, flags);
    } else {
        atf_amc::cd_in_msg_Insert(msgbuf);
    }
}

// --- atf_amc.Msgbuf.in.EndRead
// Set EOF flag
void atf_amc::in_EndRead(atf_amc::Msgbuf& msgbuf) {
    if (ValidQ(msgbuf.in_iohook.fildes)) {
        msgbuf.in_eof = true;
        atf_amc::cd_in_msg_Insert(msgbuf);
    }
}

// --- atf_amc.Msgbuf.in.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is length-delimited based on field length field
// 
atf_amc::MsgHeader* atf_amc::in_GetMsg(atf_amc::Msgbuf& msgbuf) {
    atf_amc::MsgHeader* ret;
    if (!msgbuf.in_msgvalid) {
        in_Scanmsg(msgbuf);
        if (!msgbuf.in_msgvalid) {
            bool readable = in_Refill(msgbuf);
            if (readable) {
                in_Scanmsg(msgbuf);
            }
        }
    }
    atf_amc::MsgHeader *hdr = (atf_amc::MsgHeader*)(msgbuf.in_elems + msgbuf.in_start);
    ret = msgbuf.in_msgvalid ? hdr : NULL;
    return ret;
}

// --- atf_amc.Msgbuf.in.Refill
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
bool atf_amc::in_Refill(atf_amc::Msgbuf& msgbuf) {
    bool readable = ValidQ(msgbuf.in_iohook.fildes);
    if (readable) {
        int fd     = msgbuf.in_iohook.fildes.value;
        i32 max    = in_Max(msgbuf);
        i32 end    = msgbuf.in_end;
        i32 nbytes = end - msgbuf.in_start; // # bytes currently in buffer
        i32 nfree  = max - end; // bytes available at the end of buffer
        if (nbytes == 0 || nfree == 0) { // make more room for reading (or take advantage of free shift)
            in_Shift(msgbuf);
            end = msgbuf.in_end;
            nfree = max - end;
        }
        ssize_t ret         = read(fd, msgbuf.in_elems + end, nfree);
        readable            = !(ret < 0 && errno == EAGAIN);
        bool error          = ret < 0 && errno != EAGAIN; // detect permanent error on this fd
        bool eof            = error || (ret == 0 && nfree > 0);
        msgbuf.in_end += i32_Max(ret,0); // new end of bytes
        if (error) {
            msgbuf.in_err = algo::FromErrno(errno); // fetch errno
        }
        msgbuf.in_eof |= eof;
    }
    if (!readable && msgbuf.in_epoll_enable) {
        atf_amc::cd_in_msg_Remove(msgbuf);
    }
    return readable;
}

// --- atf_amc.Msgbuf.in.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::in_RemoveAll(atf_amc::Msgbuf& msgbuf) {
    msgbuf.in_start    = 0;
    msgbuf.in_end      = 0;
    msgbuf.in_msgvalid = false;
    msgbuf.in_msglen   = 0; // reset message length -- important for delimited streams
}

// --- atf_amc.Msgbuf.in.Scanmsg
// Internal function to scan for a message
// 
static void atf_amc::in_Scanmsg(atf_amc::Msgbuf& msgbuf) {
    atf_amc::MsgHeader *hdr = (atf_amc::MsgHeader*)(msgbuf.in_elems + msgbuf.in_start);
    i32 avail = in_N(msgbuf);
    i32 msglen;
    bool found = false;
    msglen = ssizeof(atf_amc::MsgHeader);
    if (avail >= msglen) {
        msglen = i32((*hdr).length); // check rest of the message
    }
    found = msglen >= ssizeof(atf_amc::MsgHeader) && avail >= msglen;
    if (msglen < ssizeof(atf_amc::MsgHeader) || msglen > in_Max(msgbuf)) {
        msgbuf.in_eof = true; // cause user to detect eof
        msgbuf.in_err = algo::FromErrno(E2BIG); // argument list too big -- closest error code
    }
    msgbuf.in_msglen = msglen;
    msgbuf.in_msgvalid = found;
}

// --- atf_amc.Msgbuf.in.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::in_Shift(atf_amc::Msgbuf& msgbuf) {
    i32 start = msgbuf.in_start;
    i32 bytes_n = msgbuf.in_end - start;
    if (bytes_n > 0) {
        memmove(msgbuf.in_elems, msgbuf.in_elems + start, bytes_n);
    }
    msgbuf.in_end = bytes_n;
    msgbuf.in_start = 0;
}

// --- atf_amc.Msgbuf.in.SkipMsg
// Skip current message, if any
// Skip current message, if any.
void atf_amc::in_SkipMsg(atf_amc::Msgbuf& msgbuf) {
    if (msgbuf.in_msgvalid) {
        int skip = msgbuf.in_msglen;
        i32 start = msgbuf.in_start;
        start += skip;
        msgbuf.in_start = start;
        msgbuf.in_msgvalid = false;
        msgbuf.in_msglen   = 0; // reset message length -- important for delimited streams
    }
}

// --- atf_amc.Msgbuf.in.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::in_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) {
    int max = in_Max(msgbuf);
    // check if message doesn't fit. if so, shift bytes over.
    if (msgbuf.in_end + in_n > max) {
        in_Shift(msgbuf);
    }
    // now try to write the message.
    i32 end = msgbuf.in_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(msgbuf.in_elems + end, in, in_n);
        msgbuf.in_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.Msgbuf.in.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::in_XrefMaybe(atf_amc::MsgHeader &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.Msgbuf.out_extra.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::out_extra_RemoveAll(atf_amc::Msgbuf& msgbuf) {
    msgbuf.out_extra_start    = 0;
    msgbuf.out_extra_end      = 0;
}

// --- atf_amc.Msgbuf.out_extra.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::out_extra_Shift(atf_amc::Msgbuf& msgbuf) {
    i32 start = msgbuf.out_extra_start;
    i32 bytes_n = msgbuf.out_extra_end - start;
    if (bytes_n > 0) {
        memmove(msgbuf.out_extra_elems, msgbuf.out_extra_elems + start, bytes_n);
    }
    msgbuf.out_extra_end = bytes_n;
    msgbuf.out_extra_start = 0;
}

// --- atf_amc.Msgbuf.out_extra.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void atf_amc::out_extra_SkipBytes(atf_amc::Msgbuf& msgbuf, int n) {
    int avail = msgbuf.out_extra_end - msgbuf.out_extra_start;
    n = i32_Min(n,avail);
    msgbuf.out_extra_start += n;
}

// --- atf_amc.Msgbuf.out_extra.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::out_extra_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) {
    int max = out_extra_Max(msgbuf);
    // check if message doesn't fit. if so, shift bytes over.
    if (msgbuf.out_extra_end + in_n > max) {
        out_extra_Shift(msgbuf);
    }
    // now try to write the message.
    i32 end = msgbuf.out_extra_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(msgbuf.out_extra_elems + end, in, in_n);
        msgbuf.out_extra_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.Msgbuf.out_extra.WriteMsg
// Write message to buffer. If the entire message is written, return true, otherwise false.
bool atf_amc::out_extra_WriteMsg(atf_amc::Msgbuf& msgbuf, atf_amc::MsgHdrLT &msg) {
    return out_extra_WriteAll(msgbuf, (u8*)&msg, i32(msg.len + 2));
}

// --- atf_amc.Msgbuf.in_extra.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is length-delimited based on field len field
// 
atf_amc::MsgHdrLT* atf_amc::in_extra_GetMsg(atf_amc::Msgbuf& msgbuf) {
    atf_amc::MsgHdrLT* ret;
    if (!msgbuf.in_extra_msgvalid) {
        in_extra_Scanmsg(msgbuf);
    }
    atf_amc::MsgHdrLT *hdr = (atf_amc::MsgHdrLT*)(msgbuf.in_extra_elems + msgbuf.in_extra_start);
    ret = msgbuf.in_extra_msgvalid ? hdr : NULL;
    return ret;
}

// --- atf_amc.Msgbuf.in_extra.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void atf_amc::in_extra_RemoveAll(atf_amc::Msgbuf& msgbuf) {
    msgbuf.in_extra_start    = 0;
    msgbuf.in_extra_end      = 0;
    msgbuf.in_extra_msgvalid = false;
    msgbuf.in_extra_msglen   = 0; // reset message length -- important for delimited streams
}

// --- atf_amc.Msgbuf.in_extra.Scanmsg
// Internal function to scan for a message
// 
static void atf_amc::in_extra_Scanmsg(atf_amc::Msgbuf& msgbuf) {
    atf_amc::MsgHdrLT *hdr = (atf_amc::MsgHdrLT*)(msgbuf.in_extra_elems + msgbuf.in_extra_start);
    i32 avail = in_extra_N(msgbuf);
    i32 msglen;
    bool found = false;
    msglen = ssizeof(atf_amc::MsgHdrLT);
    if (avail >= msglen) {
        msglen = i32((*hdr).len + 2); // check rest of the message
    }
    found = msglen >= ssizeof(atf_amc::MsgHdrLT) && avail >= msglen;
    if (msglen < ssizeof(atf_amc::MsgHdrLT) || msglen > in_extra_Max(msgbuf)) {
        msgbuf.in_extra_eof = true; // cause user to detect eof
        msgbuf.in_extra_err = algo::FromErrno(E2BIG); // argument list too big -- closest error code
    }
    msgbuf.in_extra_msglen = msglen;
    msgbuf.in_extra_msgvalid = found;
}

// --- atf_amc.Msgbuf.in_extra.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void atf_amc::in_extra_Shift(atf_amc::Msgbuf& msgbuf) {
    i32 start = msgbuf.in_extra_start;
    i32 bytes_n = msgbuf.in_extra_end - start;
    if (bytes_n > 0) {
        memmove(msgbuf.in_extra_elems, msgbuf.in_extra_elems + start, bytes_n);
    }
    msgbuf.in_extra_end = bytes_n;
    msgbuf.in_extra_start = 0;
}

// --- atf_amc.Msgbuf.in_extra.SkipMsg
// Skip current message, if any
// Skip current message, if any.
void atf_amc::in_extra_SkipMsg(atf_amc::Msgbuf& msgbuf) {
    if (msgbuf.in_extra_msgvalid) {
        int skip = msgbuf.in_extra_msglen;
        i32 start = msgbuf.in_extra_start;
        start += skip;
        msgbuf.in_extra_start = start;
        msgbuf.in_extra_msgvalid = false;
        msgbuf.in_extra_msglen   = 0; // reset message length -- important for delimited streams
    }
}

// --- atf_amc.Msgbuf.in_extra.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool atf_amc::in_extra_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) {
    int max = in_extra_Max(msgbuf);
    // check if message doesn't fit. if so, shift bytes over.
    if (msgbuf.in_extra_end + in_n > max) {
        in_extra_Shift(msgbuf);
    }
    // now try to write the message.
    i32 end = msgbuf.in_extra_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(msgbuf.in_extra_elems + end, in, in_n);
        msgbuf.in_extra_end = end + in_n;
    }
    return fits;
}

// --- atf_amc.Msgbuf..Init
// Set all fields to initial values.
void atf_amc::Msgbuf_Init(atf_amc::Msgbuf& msgbuf) {
    msgbuf.in_end = 0; // in: initialize
    msgbuf.in_start = 0; // in: initialize
    msgbuf.in_eof = false; // in: initialize
    msgbuf.in_msgvalid = false; // in: initialize
    msgbuf.in_msglen = 0; // in: initialize
    msgbuf.in_epoll_enable = true; // in: initialize
    msgbuf.out_extra_end = 0; // out_extra: initialize
    msgbuf.out_extra_start = 0; // out_extra: initialize
    msgbuf.out_extra_eof = false; // out_extra: initialize
    msgbuf.out_extra_epoll_enable = true; // out_extra: initialize
    msgbuf.in_extra_end = 0; // in_extra: initialize
    msgbuf.in_extra_start = 0; // in_extra: initialize
    msgbuf.in_extra_eof = false; // in_extra: initialize
    msgbuf.in_extra_msgvalid = false; // in_extra: initialize
    msgbuf.in_extra_msglen = 0; // in_extra: initialize
    msgbuf.in_extra_epoll_enable = true; // in_extra: initialize
    msgbuf.cd_in_msg_next = (atf_amc::Msgbuf*)-1; // (atf_amc.FDb.cd_in_msg) not-in-list
    msgbuf.cd_in_msg_prev = NULL; // (atf_amc.FDb.cd_in_msg)
}

// --- atf_amc.Msgbuf..Uninit
void atf_amc::Msgbuf_Uninit(atf_amc::Msgbuf& msgbuf) {
    atf_amc::Msgbuf &row = msgbuf; (void)row;
    cd_in_msg_Remove(row); // remove msgbuf from index cd_in_msg
}

// --- atf_amc.Msgbuf..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Msgbuf.String  printfmt:Raw
void atf_amc::Msgbuf_Print(atf_amc::Msgbuf& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- atf_amc.MsgsCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::MsgsCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_MsgsCase_atf_amc_VarlenK: ret = "atf_amc.VarlenK";  break;
    }
    return ret;
}

// --- atf_amc.MsgsCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::MsgsCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.MsgsCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"VarlenK",7)==0) { value_SetEnum(parent,atf_amc_MsgsCase_atf_amc_VarlenK); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.MsgsCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::MsgsCase& parent, algo::strptr rhs, atf_amc_MsgsCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.MsgsCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.MsgsCase..ReadStrptrMaybe
// Read fields of atf_amc::MsgsCase from an ascii string.
// The format of the string is the format of the atf_amc::MsgsCase's only field
bool atf_amc::MsgsCase_ReadStrptrMaybe(atf_amc::MsgsCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.NetBitfld1..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.NetBitfld1.String  printfmt:Raw
void atf_amc::NetBitfld1_Print(atf_amc::NetBitfld1& row, algo::cstring& str) {
    u16_Print(value_Get(row), str);
}

// --- atf_amc.OptAlloc.typeg.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::typeg_Getary(atf_amc::OptAlloc& optalloc) {
    u8 *end = (u8*)&optalloc + sizeof(atf_amc::OptAlloc);
    return algo::aryptr<u8>(end, i32(optalloc.length) - ssizeof(atf_amc::OptAlloc));
}

// --- atf_amc.OptAlloc.typeg.Print
void atf_amc::typeg_Print(atf_amc::OptAlloc& optalloc, cstring &out) {
    (void)out;
    (void)optalloc;
    if (atf_amc::TypeG *typeg = typeg_Get(optalloc)) {
        out << *typeg;
    }
}

// --- atf_amc.OptAlloc.typeg.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::typeg_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str) {
    bool retval = false;
    // field cannot be read
    (void)parent;//only to avoid -Wunused-parameter
    (void)in_str;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.OptAlloc.typeg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typeg_XrefMaybe(atf_amc::TypeG &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.OptAlloc..ReadFieldMaybe
bool atf_amc::OptAlloc_ReadFieldMaybe(atf_amc::OptAlloc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_typeg: {
            retval = typeg_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.OptAlloc..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptAlloc from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::OptAlloc_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.OptAlloc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptAlloc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.OptAlloc..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.OptAlloc.String  printfmt:Tuple
void atf_amc::OptAlloc_Print(atf_amc::OptAlloc& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.OptAlloc";

    if (typeg_Get(row)) {
        atf_amc::typeg_Print(row, temp);
        PrintAttrSpaceReset(str,"typeg", temp);
    }
}

// --- atf_amc.OptG.typeg.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::typeg_Getary(atf_amc::OptG& optg) {
    u8 *end = (u8*)&optg + sizeof(atf_amc::OptG);
    return algo::aryptr<u8>(end, i32(optg.length) - ssizeof(atf_amc::OptG));
}

// --- atf_amc.OptG.typeg.Print
void atf_amc::typeg_Print(atf_amc::OptG& optg, cstring &out) {
    (void)out;
    (void)optg;
    if (atf_amc::TypeG *typeg = typeg_Get(optg)) {
        out << *typeg;
    }
}

// --- atf_amc.OptG.typeg.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::typeg_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str) {
    bool retval = false;
    // field cannot be read
    (void)parent;//only to avoid -Wunused-parameter
    (void)in_str;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.OptG..ReadFieldMaybe
bool atf_amc::OptG_ReadFieldMaybe(atf_amc::OptG& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_typeg: {
            retval = typeg_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.OptG..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptG from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::OptG_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.OptG");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptG_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.OptG..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.OptG.String  printfmt:Tuple
void atf_amc::OptG_Print(atf_amc::OptG& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.OptG";

    if (typeg_Get(row)) {
        atf_amc::typeg_Print(row, temp);
        PrintAttrSpaceReset(str,"typeg", temp);
    }
}

// --- atf_amc.OptOptG.optg.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::optg_Getary(atf_amc::OptOptG& parent) {
    u8 *end = (u8*)&parent + sizeof(atf_amc::OptOptG);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(atf_amc::OptOptG));
}

// --- atf_amc.OptOptG.optg.Print
void atf_amc::optg_Print(atf_amc::OptOptG& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (atf_amc::OptG *optg = optg_Get(parent)) {
        out << *optg;
    }
}

// --- atf_amc.OptOptG.optg.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::optg_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo::ByteAry* varlenbuf_save = algo_lib::_db.varlenbuf) {
        int len = sizeof(atf_amc::OptG);
        atf_amc::OptG *ctype = new(ary_AllocN(*varlenbuf_save, len).elems) atf_amc::OptG; // default values
        algo::ByteAry varlenbuf; // use for varlen msgs
        algo_lib::_db.varlenbuf = &varlenbuf;
        retval = OptG_ReadStrptrMaybe(*ctype,in_str); // read the type
        len += ary_N(varlenbuf);
        ctype->length = u32(len);
        ary_Addary(*varlenbuf_save, ary_Getary(varlenbuf));
        algo_lib::_db.varlenbuf = varlenbuf_save;
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.OptOptG.optg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::optg_XrefMaybe(atf_amc::OptG &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.OptOptG..ReadFieldMaybe
bool atf_amc::OptOptG_ReadFieldMaybe(atf_amc::OptOptG& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_optg: {
            retval = optg_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.OptOptG..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptOptG from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::OptOptG_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.OptOptG");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptOptG_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.OptOptG..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.OptOptG.String  printfmt:Tuple
void atf_amc::OptOptG_Print(atf_amc::OptOptG& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.OptOptG";

    if (optg_Get(row)) {
        atf_amc::optg_Print(row, temp);
        PrintAttrSpaceReset(str,"optg", temp);
    }
}

// --- atf_amc.PmaskMultiple.value1.ReadStrptrMaybe
inline static bool atf_amc::value1_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value1_tmp;
    retval = u32_ReadStrptrMaybe(value1_tmp, in_str);
    if (retval) {
        value1_Set(parent, value1_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value2.ReadStrptrMaybe
inline static bool atf_amc::value2_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value2_tmp;
    retval = u32_ReadStrptrMaybe(value2_tmp, in_str);
    if (retval) {
        value2_Set(parent, value2_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value3.ReadStrptrMaybe
inline static bool atf_amc::value3_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value3_tmp;
    retval = u32_ReadStrptrMaybe(value3_tmp, in_str);
    if (retval) {
        value3_Set(parent, value3_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value4.ReadStrptrMaybe
inline static bool atf_amc::value4_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value4_tmp;
    retval = u32_ReadStrptrMaybe(value4_tmp, in_str);
    if (retval) {
        value4_Set(parent, value4_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value5.ReadStrptrMaybe
inline static bool atf_amc::value5_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value5_tmp;
    retval = u32_ReadStrptrMaybe(value5_tmp, in_str);
    if (retval) {
        value5_Set(parent, value5_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value6.ReadStrptrMaybe
inline static bool atf_amc::value6_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value6_tmp;
    retval = u32_ReadStrptrMaybe(value6_tmp, in_str);
    if (retval) {
        value6_Set(parent, value6_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.value7.ReadStrptrMaybe
inline static bool atf_amc::value7_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value7_tmp;
    retval = u32_ReadStrptrMaybe(value7_tmp, in_str);
    if (retval) {
        value7_Set(parent, value7_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple.present_bitcurs.Next
// proceed to next item
void atf_amc::PmaskMultiple_present_bitcurs_Next(PmaskMultiple_present_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 32;
    int offset = curs.bit % 32;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 32 + offset;
}

// --- atf_amc.PmaskMultiple.assigned_bitcurs.Next
// proceed to next item
void atf_amc::PmaskMultiple_assigned_bitcurs_Next(PmaskMultiple_assigned_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 32;
    int offset = curs.bit % 32;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 32 + offset;
}

// --- atf_amc.PmaskMultiple.nullable_bitcurs.Next
// proceed to next item
void atf_amc::PmaskMultiple_nullable_bitcurs_Next(PmaskMultiple_nullable_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 32;
    int offset = curs.bit % 32;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 32 + offset;
}

// --- atf_amc.PmaskMultiple..ReadFieldMaybe
bool atf_amc::PmaskMultiple_ReadFieldMaybe(atf_amc::PmaskMultiple& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_present: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_assigned: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_nullable: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_value1: {
            retval = value1_ReadStrptrMaybe(parent, strval);
            if (retval) {
                nullable_qSetBit(parent, 0);
                assigned_qSetBit(parent, 0);
                present_qSetBit(parent, 0);
            }
            break;
        }
        case atf_amc_FieldId_value2: {
            retval = value2_ReadStrptrMaybe(parent, strval);
            if (retval) {
                assigned_qSetBit(parent, 1);
                present_qSetBit(parent, 1);
            }
            break;
        }
        case atf_amc_FieldId_value3: {
            retval = value3_ReadStrptrMaybe(parent, strval);
            if (retval) {
                nullable_qSetBit(parent, 1);
                assigned_qSetBit(parent, 2);
                present_qSetBit(parent, 2);
            }
            break;
        }
        case atf_amc_FieldId_value4: {
            retval = value4_ReadStrptrMaybe(parent, strval);
            if (retval) {
                assigned_qSetBit(parent, 3);
                present_qSetBit(parent, 3);
            }
            break;
        }
        case atf_amc_FieldId_value5: {
            retval = value5_ReadStrptrMaybe(parent, strval);
            if (retval) {
                nullable_qSetBit(parent, 2);
                assigned_qSetBit(parent, 4);
                present_qSetBit(parent, 4);
            }
            break;
        }
        case atf_amc_FieldId_value6: {
            retval = value6_ReadStrptrMaybe(parent, strval);
            if (retval) {
                assigned_qSetBit(parent, 5);
                present_qSetBit(parent, 5);
            }
            break;
        }
        case atf_amc_FieldId_value7: {
            retval = value7_ReadStrptrMaybe(parent, strval);
            if (retval) {
                assigned_qSetBit(parent, 6);
                present_qSetBit(parent, 6);
            }
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.PmaskMultiple..ReadStrptrMaybe
// Read fields of atf_amc::PmaskMultiple from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::PmaskMultiple_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.PmaskMultiple");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PmaskMultiple_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.PmaskMultiple..Init
// Set all fields to initial values.
void atf_amc::PmaskMultiple_Init(atf_amc::PmaskMultiple& parent) {
    parent.present = u32(0);
    parent.assigned = u32(0);
    parent.nullable = u32(0);
    parent.value1 = u32(0);
    parent.value2 = u32(0);
    parent.value3 = u32(0);
    parent.value4 = u32(0);
    parent.value5 = u32(0);
    parent.value6 = u32(0);
    parent.value7 = u32(0);
}

// --- atf_amc.PmaskMultiple..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskMultiple.String  printfmt:Tuple
void atf_amc::PmaskMultiple_Print(atf_amc::PmaskMultiple& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.PmaskMultiple";

    if (value1_NullableQ(row)) {
        u32_Print(row.value1, temp);
        PrintAttrSpaceReset(str,"value1", temp);
    }

    u32_Print(row.value2, temp);
    PrintAttrSpaceReset(str,"value2", temp);

    if (value3_NullableQ(row)) {
        u32_Print(row.value3, temp);
        PrintAttrSpaceReset(str,"value3", temp);
    }

    u32_Print(row.value4, temp);
    PrintAttrSpaceReset(str,"value4", temp);

    if (value5_NullableQ(row)) {
        u32_Print(row.value5, temp);
        PrintAttrSpaceReset(str,"value5", temp);
    }

    u32_Print(row.value6, temp);
    PrintAttrSpaceReset(str,"value6", temp);

    u32_Print(row.value7, temp);
    PrintAttrSpaceReset(str,"value7", temp);
}

// --- atf_amc.PmaskU128.value.ReadStrptrMaybe
inline static bool atf_amc::value_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value_tmp;
    retval = u32_ReadStrptrMaybe(value_tmp, in_str);
    if (retval) {
        value_Set(parent, value_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value2.ReadStrptrMaybe
inline static bool atf_amc::value2_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value2_tmp;
    retval = u32_ReadStrptrMaybe(value2_tmp, in_str);
    if (retval) {
        value2_Set(parent, value2_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value3.ReadStrptrMaybe
inline static bool atf_amc::value3_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value3_tmp;
    retval = u32_ReadStrptrMaybe(value3_tmp, in_str);
    if (retval) {
        value3_Set(parent, value3_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value21.ReadStrptrMaybe
inline static bool atf_amc::value21_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value21_tmp;
    retval = u32_ReadStrptrMaybe(value21_tmp, in_str);
    if (retval) {
        value21_Set(parent, value21_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value22.ReadStrptrMaybe
inline static bool atf_amc::value22_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value22_tmp;
    retval = u32_ReadStrptrMaybe(value22_tmp, in_str);
    if (retval) {
        value22_Set(parent, value22_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value23.ReadStrptrMaybe
inline static bool atf_amc::value23_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value23_tmp;
    retval = u32_ReadStrptrMaybe(value23_tmp, in_str);
    if (retval) {
        value23_Set(parent, value23_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value24.ReadStrptrMaybe
inline static bool atf_amc::value24_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value24_tmp;
    retval = u32_ReadStrptrMaybe(value24_tmp, in_str);
    if (retval) {
        value24_Set(parent, value24_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value25.ReadStrptrMaybe
inline static bool atf_amc::value25_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value25_tmp;
    retval = u32_ReadStrptrMaybe(value25_tmp, in_str);
    if (retval) {
        value25_Set(parent, value25_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value26.ReadStrptrMaybe
inline static bool atf_amc::value26_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value26_tmp;
    retval = u32_ReadStrptrMaybe(value26_tmp, in_str);
    if (retval) {
        value26_Set(parent, value26_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value20.ReadStrptrMaybe
inline static bool atf_amc::value20_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value20_tmp;
    retval = u32_ReadStrptrMaybe(value20_tmp, in_str);
    if (retval) {
        value20_Set(parent, value20_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value28.ReadStrptrMaybe
inline static bool atf_amc::value28_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value28_tmp;
    retval = u32_ReadStrptrMaybe(value28_tmp, in_str);
    if (retval) {
        value28_Set(parent, value28_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value29.ReadStrptrMaybe
inline static bool atf_amc::value29_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value29_tmp;
    retval = u32_ReadStrptrMaybe(value29_tmp, in_str);
    if (retval) {
        value29_Set(parent, value29_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value30.ReadStrptrMaybe
inline static bool atf_amc::value30_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value30_tmp;
    retval = u32_ReadStrptrMaybe(value30_tmp, in_str);
    if (retval) {
        value30_Set(parent, value30_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value31.ReadStrptrMaybe
inline static bool atf_amc::value31_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value31_tmp;
    retval = u32_ReadStrptrMaybe(value31_tmp, in_str);
    if (retval) {
        value31_Set(parent, value31_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value32.ReadStrptrMaybe
inline static bool atf_amc::value32_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value32_tmp;
    retval = u32_ReadStrptrMaybe(value32_tmp, in_str);
    if (retval) {
        value32_Set(parent, value32_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value27.ReadStrptrMaybe
inline static bool atf_amc::value27_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value27_tmp;
    retval = u32_ReadStrptrMaybe(value27_tmp, in_str);
    if (retval) {
        value27_Set(parent, value27_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value19.ReadStrptrMaybe
inline static bool atf_amc::value19_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value19_tmp;
    retval = u32_ReadStrptrMaybe(value19_tmp, in_str);
    if (retval) {
        value19_Set(parent, value19_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value18.ReadStrptrMaybe
inline static bool atf_amc::value18_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value18_tmp;
    retval = u32_ReadStrptrMaybe(value18_tmp, in_str);
    if (retval) {
        value18_Set(parent, value18_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value4.ReadStrptrMaybe
inline static bool atf_amc::value4_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value4_tmp;
    retval = u32_ReadStrptrMaybe(value4_tmp, in_str);
    if (retval) {
        value4_Set(parent, value4_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value5.ReadStrptrMaybe
inline static bool atf_amc::value5_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value5_tmp;
    retval = u32_ReadStrptrMaybe(value5_tmp, in_str);
    if (retval) {
        value5_Set(parent, value5_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value6.ReadStrptrMaybe
inline static bool atf_amc::value6_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value6_tmp;
    retval = u32_ReadStrptrMaybe(value6_tmp, in_str);
    if (retval) {
        value6_Set(parent, value6_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value7.ReadStrptrMaybe
inline static bool atf_amc::value7_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value7_tmp;
    retval = u32_ReadStrptrMaybe(value7_tmp, in_str);
    if (retval) {
        value7_Set(parent, value7_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value8.ReadStrptrMaybe
inline static bool atf_amc::value8_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value8_tmp;
    retval = u32_ReadStrptrMaybe(value8_tmp, in_str);
    if (retval) {
        value8_Set(parent, value8_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value9.ReadStrptrMaybe
inline static bool atf_amc::value9_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value9_tmp;
    retval = u32_ReadStrptrMaybe(value9_tmp, in_str);
    if (retval) {
        value9_Set(parent, value9_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value69.ReadStrptrMaybe
inline static bool atf_amc::value69_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value69_tmp;
    retval = u32_ReadStrptrMaybe(value69_tmp, in_str);
    if (retval) {
        value69_Set(parent, value69_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value11.ReadStrptrMaybe
inline static bool atf_amc::value11_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value11_tmp;
    retval = u32_ReadStrptrMaybe(value11_tmp, in_str);
    if (retval) {
        value11_Set(parent, value11_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value12.ReadStrptrMaybe
inline static bool atf_amc::value12_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value12_tmp;
    retval = u32_ReadStrptrMaybe(value12_tmp, in_str);
    if (retval) {
        value12_Set(parent, value12_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value13.ReadStrptrMaybe
inline static bool atf_amc::value13_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value13_tmp;
    retval = u32_ReadStrptrMaybe(value13_tmp, in_str);
    if (retval) {
        value13_Set(parent, value13_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value14.ReadStrptrMaybe
inline static bool atf_amc::value14_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value14_tmp;
    retval = u32_ReadStrptrMaybe(value14_tmp, in_str);
    if (retval) {
        value14_Set(parent, value14_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value15.ReadStrptrMaybe
inline static bool atf_amc::value15_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value15_tmp;
    retval = u32_ReadStrptrMaybe(value15_tmp, in_str);
    if (retval) {
        value15_Set(parent, value15_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value16.ReadStrptrMaybe
inline static bool atf_amc::value16_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value16_tmp;
    retval = u32_ReadStrptrMaybe(value16_tmp, in_str);
    if (retval) {
        value16_Set(parent, value16_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value33.ReadStrptrMaybe
inline static bool atf_amc::value33_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value33_tmp;
    retval = u32_ReadStrptrMaybe(value33_tmp, in_str);
    if (retval) {
        value33_Set(parent, value33_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value10.ReadStrptrMaybe
inline static bool atf_amc::value10_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value10_tmp;
    retval = u32_ReadStrptrMaybe(value10_tmp, in_str);
    if (retval) {
        value10_Set(parent, value10_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value17.ReadStrptrMaybe
inline static bool atf_amc::value17_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value17_tmp;
    retval = u32_ReadStrptrMaybe(value17_tmp, in_str);
    if (retval) {
        value17_Set(parent, value17_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value35.ReadStrptrMaybe
inline static bool atf_amc::value35_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value35_tmp;
    retval = u32_ReadStrptrMaybe(value35_tmp, in_str);
    if (retval) {
        value35_Set(parent, value35_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value55.ReadStrptrMaybe
inline static bool atf_amc::value55_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value55_tmp;
    retval = u32_ReadStrptrMaybe(value55_tmp, in_str);
    if (retval) {
        value55_Set(parent, value55_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value56.ReadStrptrMaybe
inline static bool atf_amc::value56_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value56_tmp;
    retval = u32_ReadStrptrMaybe(value56_tmp, in_str);
    if (retval) {
        value56_Set(parent, value56_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value57.ReadStrptrMaybe
inline static bool atf_amc::value57_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value57_tmp;
    retval = u32_ReadStrptrMaybe(value57_tmp, in_str);
    if (retval) {
        value57_Set(parent, value57_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value58.ReadStrptrMaybe
inline static bool atf_amc::value58_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value58_tmp;
    retval = u32_ReadStrptrMaybe(value58_tmp, in_str);
    if (retval) {
        value58_Set(parent, value58_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value59.ReadStrptrMaybe
inline static bool atf_amc::value59_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value59_tmp;
    retval = u32_ReadStrptrMaybe(value59_tmp, in_str);
    if (retval) {
        value59_Set(parent, value59_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value60.ReadStrptrMaybe
inline static bool atf_amc::value60_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value60_tmp;
    retval = u32_ReadStrptrMaybe(value60_tmp, in_str);
    if (retval) {
        value60_Set(parent, value60_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value54.ReadStrptrMaybe
inline static bool atf_amc::value54_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value54_tmp;
    retval = u32_ReadStrptrMaybe(value54_tmp, in_str);
    if (retval) {
        value54_Set(parent, value54_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value62.ReadStrptrMaybe
inline static bool atf_amc::value62_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value62_tmp;
    retval = u32_ReadStrptrMaybe(value62_tmp, in_str);
    if (retval) {
        value62_Set(parent, value62_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value63.ReadStrptrMaybe
inline static bool atf_amc::value63_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value63_tmp;
    retval = u32_ReadStrptrMaybe(value63_tmp, in_str);
    if (retval) {
        value63_Set(parent, value63_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value64.ReadStrptrMaybe
inline static bool atf_amc::value64_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value64_tmp;
    retval = u32_ReadStrptrMaybe(value64_tmp, in_str);
    if (retval) {
        value64_Set(parent, value64_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value65.ReadStrptrMaybe
inline static bool atf_amc::value65_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value65_tmp;
    retval = u32_ReadStrptrMaybe(value65_tmp, in_str);
    if (retval) {
        value65_Set(parent, value65_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value66.ReadStrptrMaybe
inline static bool atf_amc::value66_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value66_tmp;
    retval = u32_ReadStrptrMaybe(value66_tmp, in_str);
    if (retval) {
        value66_Set(parent, value66_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value67.ReadStrptrMaybe
inline static bool atf_amc::value67_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value67_tmp;
    retval = u32_ReadStrptrMaybe(value67_tmp, in_str);
    if (retval) {
        value67_Set(parent, value67_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value68.ReadStrptrMaybe
inline static bool atf_amc::value68_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value68_tmp;
    retval = u32_ReadStrptrMaybe(value68_tmp, in_str);
    if (retval) {
        value68_Set(parent, value68_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value61.ReadStrptrMaybe
inline static bool atf_amc::value61_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value61_tmp;
    retval = u32_ReadStrptrMaybe(value61_tmp, in_str);
    if (retval) {
        value61_Set(parent, value61_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value34.ReadStrptrMaybe
inline static bool atf_amc::value34_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value34_tmp;
    retval = u32_ReadStrptrMaybe(value34_tmp, in_str);
    if (retval) {
        value34_Set(parent, value34_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value52.ReadStrptrMaybe
inline static bool atf_amc::value52_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value52_tmp;
    retval = u32_ReadStrptrMaybe(value52_tmp, in_str);
    if (retval) {
        value52_Set(parent, value52_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value36.ReadStrptrMaybe
inline static bool atf_amc::value36_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value36_tmp;
    retval = u32_ReadStrptrMaybe(value36_tmp, in_str);
    if (retval) {
        value36_Set(parent, value36_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value37.ReadStrptrMaybe
inline static bool atf_amc::value37_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value37_tmp;
    retval = u32_ReadStrptrMaybe(value37_tmp, in_str);
    if (retval) {
        value37_Set(parent, value37_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value38.ReadStrptrMaybe
inline static bool atf_amc::value38_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value38_tmp;
    retval = u32_ReadStrptrMaybe(value38_tmp, in_str);
    if (retval) {
        value38_Set(parent, value38_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value39.ReadStrptrMaybe
inline static bool atf_amc::value39_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value39_tmp;
    retval = u32_ReadStrptrMaybe(value39_tmp, in_str);
    if (retval) {
        value39_Set(parent, value39_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value40.ReadStrptrMaybe
inline static bool atf_amc::value40_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value40_tmp;
    retval = u32_ReadStrptrMaybe(value40_tmp, in_str);
    if (retval) {
        value40_Set(parent, value40_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value41.ReadStrptrMaybe
inline static bool atf_amc::value41_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value41_tmp;
    retval = u32_ReadStrptrMaybe(value41_tmp, in_str);
    if (retval) {
        value41_Set(parent, value41_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value42.ReadStrptrMaybe
inline static bool atf_amc::value42_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value42_tmp;
    retval = u32_ReadStrptrMaybe(value42_tmp, in_str);
    if (retval) {
        value42_Set(parent, value42_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value53.ReadStrptrMaybe
inline static bool atf_amc::value53_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value53_tmp;
    retval = u32_ReadStrptrMaybe(value53_tmp, in_str);
    if (retval) {
        value53_Set(parent, value53_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value44.ReadStrptrMaybe
inline static bool atf_amc::value44_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value44_tmp;
    retval = u32_ReadStrptrMaybe(value44_tmp, in_str);
    if (retval) {
        value44_Set(parent, value44_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value45.ReadStrptrMaybe
inline static bool atf_amc::value45_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value45_tmp;
    retval = u32_ReadStrptrMaybe(value45_tmp, in_str);
    if (retval) {
        value45_Set(parent, value45_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value46.ReadStrptrMaybe
inline static bool atf_amc::value46_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value46_tmp;
    retval = u32_ReadStrptrMaybe(value46_tmp, in_str);
    if (retval) {
        value46_Set(parent, value46_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value47.ReadStrptrMaybe
inline static bool atf_amc::value47_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value47_tmp;
    retval = u32_ReadStrptrMaybe(value47_tmp, in_str);
    if (retval) {
        value47_Set(parent, value47_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value48.ReadStrptrMaybe
inline static bool atf_amc::value48_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value48_tmp;
    retval = u32_ReadStrptrMaybe(value48_tmp, in_str);
    if (retval) {
        value48_Set(parent, value48_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value49.ReadStrptrMaybe
inline static bool atf_amc::value49_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value49_tmp;
    retval = u32_ReadStrptrMaybe(value49_tmp, in_str);
    if (retval) {
        value49_Set(parent, value49_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value50.ReadStrptrMaybe
inline static bool atf_amc::value50_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value50_tmp;
    retval = u32_ReadStrptrMaybe(value50_tmp, in_str);
    if (retval) {
        value50_Set(parent, value50_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value51.ReadStrptrMaybe
inline static bool atf_amc::value51_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value51_tmp;
    retval = u32_ReadStrptrMaybe(value51_tmp, in_str);
    if (retval) {
        value51_Set(parent, value51_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value43.ReadStrptrMaybe
inline static bool atf_amc::value43_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value43_tmp;
    retval = u32_ReadStrptrMaybe(value43_tmp, in_str);
    if (retval) {
        value43_Set(parent, value43_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value70.ReadStrptrMaybe
inline static bool atf_amc::value70_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value70_tmp;
    retval = u32_ReadStrptrMaybe(value70_tmp, in_str);
    if (retval) {
        value70_Set(parent, value70_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128.value71.ReadStrptrMaybe
inline static bool atf_amc::value71_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value71_tmp;
    retval = u32_ReadStrptrMaybe(value71_tmp, in_str);
    if (retval) {
        value71_Set(parent, value71_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU128..ReadFieldMaybe
bool atf_amc::PmaskU128_ReadFieldMaybe(atf_amc::PmaskU128& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_pmask: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 0);
            }
            break;
        }
        case atf_amc_FieldId_value2: {
            retval = value2_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 1);
            }
            break;
        }
        case atf_amc_FieldId_value3: {
            retval = value3_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 2);
            }
            break;
        }
        case atf_amc_FieldId_value21: {
            retval = value21_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 3);
            }
            break;
        }
        case atf_amc_FieldId_value22: {
            retval = value22_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 4);
            }
            break;
        }
        case atf_amc_FieldId_value23: {
            retval = value23_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 5);
            }
            break;
        }
        case atf_amc_FieldId_value24: {
            retval = value24_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 6);
            }
            break;
        }
        case atf_amc_FieldId_value25: {
            retval = value25_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 7);
            }
            break;
        }
        case atf_amc_FieldId_value26: {
            retval = value26_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 8);
            }
            break;
        }
        case atf_amc_FieldId_value20: {
            retval = value20_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 9);
            }
            break;
        }
        case atf_amc_FieldId_value28: {
            retval = value28_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 10);
            }
            break;
        }
        case atf_amc_FieldId_value29: {
            retval = value29_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 11);
            }
            break;
        }
        case atf_amc_FieldId_value30: {
            retval = value30_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 12);
            }
            break;
        }
        case atf_amc_FieldId_value31: {
            retval = value31_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 13);
            }
            break;
        }
        case atf_amc_FieldId_value32: {
            retval = value32_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 14);
            }
            break;
        }
        case atf_amc_FieldId_value27: {
            retval = value27_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 15);
            }
            break;
        }
        case atf_amc_FieldId_value19: {
            retval = value19_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 16);
            }
            break;
        }
        case atf_amc_FieldId_value18: {
            retval = value18_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 17);
            }
            break;
        }
        case atf_amc_FieldId_value4: {
            retval = value4_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 18);
            }
            break;
        }
        case atf_amc_FieldId_value5: {
            retval = value5_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 19);
            }
            break;
        }
        case atf_amc_FieldId_value6: {
            retval = value6_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 20);
            }
            break;
        }
        case atf_amc_FieldId_value7: {
            retval = value7_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 21);
            }
            break;
        }
        case atf_amc_FieldId_value8: {
            retval = value8_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 22);
            }
            break;
        }
        case atf_amc_FieldId_value9: {
            retval = value9_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 23);
            }
            break;
        }
        case atf_amc_FieldId_value69: {
            retval = value69_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 24);
            }
            break;
        }
        case atf_amc_FieldId_value11: {
            retval = value11_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 25);
            }
            break;
        }
        case atf_amc_FieldId_value12: {
            retval = value12_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 26);
            }
            break;
        }
        case atf_amc_FieldId_value13: {
            retval = value13_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 27);
            }
            break;
        }
        case atf_amc_FieldId_value14: {
            retval = value14_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 28);
            }
            break;
        }
        case atf_amc_FieldId_value15: {
            retval = value15_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 29);
            }
            break;
        }
        case atf_amc_FieldId_value16: {
            retval = value16_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 30);
            }
            break;
        }
        case atf_amc_FieldId_value33: {
            retval = value33_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 31);
            }
            break;
        }
        case atf_amc_FieldId_value10: {
            retval = value10_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 32);
            }
            break;
        }
        case atf_amc_FieldId_value17: {
            retval = value17_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 33);
            }
            break;
        }
        case atf_amc_FieldId_value35: {
            retval = value35_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 34);
            }
            break;
        }
        case atf_amc_FieldId_value55: {
            retval = value55_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 35);
            }
            break;
        }
        case atf_amc_FieldId_value56: {
            retval = value56_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 36);
            }
            break;
        }
        case atf_amc_FieldId_value57: {
            retval = value57_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 37);
            }
            break;
        }
        case atf_amc_FieldId_value58: {
            retval = value58_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 38);
            }
            break;
        }
        case atf_amc_FieldId_value59: {
            retval = value59_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 39);
            }
            break;
        }
        case atf_amc_FieldId_value60: {
            retval = value60_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 40);
            }
            break;
        }
        case atf_amc_FieldId_value54: {
            retval = value54_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 41);
            }
            break;
        }
        case atf_amc_FieldId_value62: {
            retval = value62_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 42);
            }
            break;
        }
        case atf_amc_FieldId_value63: {
            retval = value63_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 43);
            }
            break;
        }
        case atf_amc_FieldId_value64: {
            retval = value64_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 44);
            }
            break;
        }
        case atf_amc_FieldId_value65: {
            retval = value65_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 45);
            }
            break;
        }
        case atf_amc_FieldId_value66: {
            retval = value66_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 46);
            }
            break;
        }
        case atf_amc_FieldId_value67: {
            retval = value67_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 47);
            }
            break;
        }
        case atf_amc_FieldId_value68: {
            retval = value68_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 48);
            }
            break;
        }
        case atf_amc_FieldId_value61: {
            retval = value61_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 49);
            }
            break;
        }
        case atf_amc_FieldId_value34: {
            retval = value34_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 50);
            }
            break;
        }
        case atf_amc_FieldId_value52: {
            retval = value52_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 51);
            }
            break;
        }
        case atf_amc_FieldId_value36: {
            retval = value36_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 52);
            }
            break;
        }
        case atf_amc_FieldId_value37: {
            retval = value37_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 53);
            }
            break;
        }
        case atf_amc_FieldId_value38: {
            retval = value38_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 54);
            }
            break;
        }
        case atf_amc_FieldId_value39: {
            retval = value39_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 55);
            }
            break;
        }
        case atf_amc_FieldId_value40: {
            retval = value40_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 56);
            }
            break;
        }
        case atf_amc_FieldId_value41: {
            retval = value41_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 57);
            }
            break;
        }
        case atf_amc_FieldId_value42: {
            retval = value42_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 58);
            }
            break;
        }
        case atf_amc_FieldId_value53: {
            retval = value53_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 59);
            }
            break;
        }
        case atf_amc_FieldId_value44: {
            retval = value44_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 60);
            }
            break;
        }
        case atf_amc_FieldId_value45: {
            retval = value45_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 61);
            }
            break;
        }
        case atf_amc_FieldId_value46: {
            retval = value46_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 62);
            }
            break;
        }
        case atf_amc_FieldId_value47: {
            retval = value47_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 63);
            }
            break;
        }
        case atf_amc_FieldId_value48: {
            retval = value48_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 64);
            }
            break;
        }
        case atf_amc_FieldId_value49: {
            retval = value49_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 65);
            }
            break;
        }
        case atf_amc_FieldId_value50: {
            retval = value50_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 66);
            }
            break;
        }
        case atf_amc_FieldId_value51: {
            retval = value51_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 67);
            }
            break;
        }
        case atf_amc_FieldId_value43: {
            retval = value43_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 68);
            }
            break;
        }
        case atf_amc_FieldId_value70: {
            retval = value70_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 69);
            }
            break;
        }
        case atf_amc_FieldId_value71: {
            retval = value71_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 70);
            }
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.PmaskU128..ReadStrptrMaybe
// Read fields of atf_amc::PmaskU128 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::PmaskU128_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.PmaskU128");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PmaskU128_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.PmaskU128..Init
// Set all fields to initial values.
void atf_amc::PmaskU128_Init(atf_amc::PmaskU128& parent) {
    parent.pmask = u128(0);
    parent.value = u32(0);
    parent.value2 = u32(0);
    parent.value3 = u32(0);
    parent.value21 = u32(0);
    parent.value22 = u32(0);
    parent.value23 = u32(0);
    parent.value24 = u32(0);
    parent.value25 = u32(0);
    parent.value26 = u32(0);
    parent.value20 = u32(0);
    parent.value28 = u32(0);
    parent.value29 = u32(0);
    parent.value30 = u32(0);
    parent.value31 = u32(0);
    parent.value32 = u32(0);
    parent.value27 = u32(0);
    parent.value19 = u32(0);
    parent.value18 = u32(0);
    parent.value4 = u32(0);
    parent.value5 = u32(0);
    parent.value6 = u32(0);
    parent.value7 = u32(0);
    parent.value8 = u32(0);
    parent.value9 = u32(0);
    parent.value69 = u32(0);
    parent.value11 = u32(0);
    parent.value12 = u32(0);
    parent.value13 = u32(0);
    parent.value14 = u32(0);
    parent.value15 = u32(0);
    parent.value16 = u32(0);
    parent.value33 = u32(0);
    parent.value10 = u32(0);
    parent.value17 = u32(0);
    parent.value35 = u32(0);
    parent.value55 = u32(0);
    parent.value56 = u32(0);
    parent.value57 = u32(0);
    parent.value58 = u32(0);
    parent.value59 = u32(0);
    parent.value60 = u32(0);
    parent.value54 = u32(0);
    parent.value62 = u32(0);
    parent.value63 = u32(0);
    parent.value64 = u32(0);
    parent.value65 = u32(0);
    parent.value66 = u32(0);
    parent.value67 = u32(0);
    parent.value68 = u32(0);
    parent.value61 = u32(0);
    parent.value34 = u32(0);
    parent.value52 = u32(0);
    parent.value36 = u32(0);
    parent.value37 = u32(0);
    parent.value38 = u32(0);
    parent.value39 = u32(0);
    parent.value40 = u32(0);
    parent.value41 = u32(0);
    parent.value42 = u32(0);
    parent.value53 = u32(0);
    parent.value44 = u32(0);
    parent.value45 = u32(0);
    parent.value46 = u32(0);
    parent.value47 = u32(0);
    parent.value48 = u32(0);
    parent.value49 = u32(0);
    parent.value50 = u32(0);
    parent.value51 = u32(0);
    parent.value43 = u32(0);
    parent.value70 = u32(0);
    parent.value71 = u32(0);
}

// --- atf_amc.PmaskU128..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskU128.String  printfmt:Tuple
void atf_amc::PmaskU128_Print(atf_amc::PmaskU128& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.PmaskU128";

    u32_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    u32_Print(row.value2, temp);
    PrintAttrSpaceReset(str,"value2", temp);

    u32_Print(row.value3, temp);
    PrintAttrSpaceReset(str,"value3", temp);

    u32_Print(row.value21, temp);
    PrintAttrSpaceReset(str,"value21", temp);

    u32_Print(row.value22, temp);
    PrintAttrSpaceReset(str,"value22", temp);

    u32_Print(row.value23, temp);
    PrintAttrSpaceReset(str,"value23", temp);

    u32_Print(row.value24, temp);
    PrintAttrSpaceReset(str,"value24", temp);

    u32_Print(row.value25, temp);
    PrintAttrSpaceReset(str,"value25", temp);

    u32_Print(row.value26, temp);
    PrintAttrSpaceReset(str,"value26", temp);

    u32_Print(row.value20, temp);
    PrintAttrSpaceReset(str,"value20", temp);

    u32_Print(row.value28, temp);
    PrintAttrSpaceReset(str,"value28", temp);

    u32_Print(row.value29, temp);
    PrintAttrSpaceReset(str,"value29", temp);

    u32_Print(row.value30, temp);
    PrintAttrSpaceReset(str,"value30", temp);

    u32_Print(row.value31, temp);
    PrintAttrSpaceReset(str,"value31", temp);

    u32_Print(row.value32, temp);
    PrintAttrSpaceReset(str,"value32", temp);

    u32_Print(row.value27, temp);
    PrintAttrSpaceReset(str,"value27", temp);

    u32_Print(row.value19, temp);
    PrintAttrSpaceReset(str,"value19", temp);

    u32_Print(row.value18, temp);
    PrintAttrSpaceReset(str,"value18", temp);

    u32_Print(row.value4, temp);
    PrintAttrSpaceReset(str,"value4", temp);

    u32_Print(row.value5, temp);
    PrintAttrSpaceReset(str,"value5", temp);

    u32_Print(row.value6, temp);
    PrintAttrSpaceReset(str,"value6", temp);

    u32_Print(row.value7, temp);
    PrintAttrSpaceReset(str,"value7", temp);

    u32_Print(row.value8, temp);
    PrintAttrSpaceReset(str,"value8", temp);

    u32_Print(row.value9, temp);
    PrintAttrSpaceReset(str,"value9", temp);

    u32_Print(row.value69, temp);
    PrintAttrSpaceReset(str,"value69", temp);

    u32_Print(row.value11, temp);
    PrintAttrSpaceReset(str,"value11", temp);

    u32_Print(row.value12, temp);
    PrintAttrSpaceReset(str,"value12", temp);

    u32_Print(row.value13, temp);
    PrintAttrSpaceReset(str,"value13", temp);

    u32_Print(row.value14, temp);
    PrintAttrSpaceReset(str,"value14", temp);

    u32_Print(row.value15, temp);
    PrintAttrSpaceReset(str,"value15", temp);

    u32_Print(row.value16, temp);
    PrintAttrSpaceReset(str,"value16", temp);

    u32_Print(row.value33, temp);
    PrintAttrSpaceReset(str,"value33", temp);

    u32_Print(row.value10, temp);
    PrintAttrSpaceReset(str,"value10", temp);

    u32_Print(row.value17, temp);
    PrintAttrSpaceReset(str,"value17", temp);

    u32_Print(row.value35, temp);
    PrintAttrSpaceReset(str,"value35", temp);

    u32_Print(row.value55, temp);
    PrintAttrSpaceReset(str,"value55", temp);

    u32_Print(row.value56, temp);
    PrintAttrSpaceReset(str,"value56", temp);

    u32_Print(row.value57, temp);
    PrintAttrSpaceReset(str,"value57", temp);

    u32_Print(row.value58, temp);
    PrintAttrSpaceReset(str,"value58", temp);

    u32_Print(row.value59, temp);
    PrintAttrSpaceReset(str,"value59", temp);

    u32_Print(row.value60, temp);
    PrintAttrSpaceReset(str,"value60", temp);

    u32_Print(row.value54, temp);
    PrintAttrSpaceReset(str,"value54", temp);

    u32_Print(row.value62, temp);
    PrintAttrSpaceReset(str,"value62", temp);

    u32_Print(row.value63, temp);
    PrintAttrSpaceReset(str,"value63", temp);

    u32_Print(row.value64, temp);
    PrintAttrSpaceReset(str,"value64", temp);

    u32_Print(row.value65, temp);
    PrintAttrSpaceReset(str,"value65", temp);

    u32_Print(row.value66, temp);
    PrintAttrSpaceReset(str,"value66", temp);

    u32_Print(row.value67, temp);
    PrintAttrSpaceReset(str,"value67", temp);

    u32_Print(row.value68, temp);
    PrintAttrSpaceReset(str,"value68", temp);

    u32_Print(row.value61, temp);
    PrintAttrSpaceReset(str,"value61", temp);

    u32_Print(row.value34, temp);
    PrintAttrSpaceReset(str,"value34", temp);

    u32_Print(row.value52, temp);
    PrintAttrSpaceReset(str,"value52", temp);

    u32_Print(row.value36, temp);
    PrintAttrSpaceReset(str,"value36", temp);

    u32_Print(row.value37, temp);
    PrintAttrSpaceReset(str,"value37", temp);

    u32_Print(row.value38, temp);
    PrintAttrSpaceReset(str,"value38", temp);

    u32_Print(row.value39, temp);
    PrintAttrSpaceReset(str,"value39", temp);

    u32_Print(row.value40, temp);
    PrintAttrSpaceReset(str,"value40", temp);

    u32_Print(row.value41, temp);
    PrintAttrSpaceReset(str,"value41", temp);

    u32_Print(row.value42, temp);
    PrintAttrSpaceReset(str,"value42", temp);

    u32_Print(row.value53, temp);
    PrintAttrSpaceReset(str,"value53", temp);

    u32_Print(row.value44, temp);
    PrintAttrSpaceReset(str,"value44", temp);

    u32_Print(row.value45, temp);
    PrintAttrSpaceReset(str,"value45", temp);

    u32_Print(row.value46, temp);
    PrintAttrSpaceReset(str,"value46", temp);

    u32_Print(row.value47, temp);
    PrintAttrSpaceReset(str,"value47", temp);

    u32_Print(row.value48, temp);
    PrintAttrSpaceReset(str,"value48", temp);

    u32_Print(row.value49, temp);
    PrintAttrSpaceReset(str,"value49", temp);

    u32_Print(row.value50, temp);
    PrintAttrSpaceReset(str,"value50", temp);

    u32_Print(row.value51, temp);
    PrintAttrSpaceReset(str,"value51", temp);

    u32_Print(row.value43, temp);
    PrintAttrSpaceReset(str,"value43", temp);

    u32_Print(row.value70, temp);
    PrintAttrSpaceReset(str,"value70", temp);

    u32_Print(row.value71, temp);
    PrintAttrSpaceReset(str,"value71", temp);
}

// --- atf_amc.PmaskU32.value.ReadStrptrMaybe
inline static bool atf_amc::value_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value_tmp;
    retval = u32_ReadStrptrMaybe(value_tmp, in_str);
    if (retval) {
        value_Set(parent, value_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU32.value2.ReadStrptrMaybe
inline static bool atf_amc::value2_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value2_tmp;
    retval = u32_ReadStrptrMaybe(value2_tmp, in_str);
    if (retval) {
        value2_Set(parent, value2_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU32.value3.ReadStrptrMaybe
inline static bool atf_amc::value3_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value3_tmp;
    retval = u32_ReadStrptrMaybe(value3_tmp, in_str);
    if (retval) {
        value3_Set(parent, value3_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU32.value4.ReadStrptrMaybe
inline static bool atf_amc::value4_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value4_tmp;
    retval = u32_ReadStrptrMaybe(value4_tmp, in_str);
    if (retval) {
        value4_Set(parent, value4_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU32.value5.ReadStrptrMaybe
inline static bool atf_amc::value5_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    u32 value5_tmp;
    retval = u32_ReadStrptrMaybe(value5_tmp, in_str);
    if (retval) {
        value5_Set(parent, value5_tmp);
    }
    return retval;
}

// --- atf_amc.PmaskU32.pmask_bitcurs.Next
// proceed to next item
void atf_amc::PmaskU32_pmask_bitcurs_Next(PmaskU32_pmask_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 32;
    int offset = curs.bit % 32;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 32 + offset;
}

// --- atf_amc.PmaskU32..ReadFieldMaybe
bool atf_amc::PmaskU32_ReadFieldMaybe(atf_amc::PmaskU32& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_pmask: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 0);
            }
            break;
        }
        case atf_amc_FieldId_value2: {
            retval = value2_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 1);
            }
            break;
        }
        case atf_amc_FieldId_value3: {
            retval = value3_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 2);
            }
            break;
        }
        case atf_amc_FieldId_value4: {
            retval = value4_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 3);
            }
            break;
        }
        case atf_amc_FieldId_value5: {
            retval = value5_ReadStrptrMaybe(parent, strval);
            if (retval) {
                pmask_qSetBit(parent, 4);
            }
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.PmaskU32..ReadStrptrMaybe
// Read fields of atf_amc::PmaskU32 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::PmaskU32_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.PmaskU32");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PmaskU32_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.PmaskU32..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskU32.String  printfmt:Tuple
void atf_amc::PmaskU32_Print(atf_amc::PmaskU32& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.PmaskU32";

    u32_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    u32_Print(row.value2, temp);
    PrintAttrSpaceReset(str,"value2", temp);

    u32_Print(row.value3, temp);
    PrintAttrSpaceReset(str,"value3", temp);

    u32_Print(row.value4, temp);
    PrintAttrSpaceReset(str,"value4", temp);

    u32_Print(row.value5, temp);
    PrintAttrSpaceReset(str,"value5", temp);
}

// --- atf_amc.PmaskU555.pmask.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool atf_amc::pmask_ReadStrptrMaybe(atf_amc::PmaskU555& parent, algo::strptr in_str) {
    bool retval = true;
    if (10>0) {
        retval = u64_ReadStrptrMaybe(parent.pmask_elems[0], in_str);
    }
    return retval;
}

// --- atf_amc.PmaskU555.pmask_bitcurs.Next
// proceed to next item
void atf_amc::PmaskU555_pmask_bitcurs_Next(PmaskU555_pmask_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 64;
    int offset = curs.bit % 64;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 64 + offset;
}

// --- atf_amc.PooledBE64.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::PooledBE64& pooledbe64) {
    const char *ret = NULL;
    switch(value_GetEnum(pooledbe64)) {
        case atf_amc_PooledBE64_value_A    : ret = "A";  break;
        case atf_amc_PooledBE64_value_B    : ret = "B";  break;
    }
    return ret;
}

// --- atf_amc.PooledBE64.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::PooledBE64& pooledbe64, algo::cstring &lhs) {
    const char *strval = value_ToCstr(pooledbe64);
    if (strval) {
        lhs << strval;
    } else {
        lhs << value_Get(pooledbe64);
    }
}

// --- atf_amc.PooledBE64.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'A': {
                    value_SetEnum(pooledbe64,atf_amc_PooledBE64_value_A); ret = true; break;
                }
                case 'B': {
                    value_SetEnum(pooledbe64,atf_amc_PooledBE64_value_B); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.PooledBE64.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs, atf_amc_PooledBE64_value_Enum dflt) {
    if (!value_SetStrptrMaybe(pooledbe64,rhs)) value_SetEnum(pooledbe64,dflt);
}

// --- atf_amc.PooledBE64.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(pooledbe64,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        u64 value_tmp;
        retval = u64_ReadStrptrMaybe(value_tmp, rhs);
        if (retval) {
            value_Set(pooledbe64, value_tmp);
        }
    }
    return retval;
}

// --- atf_amc.PooledBE64..ReadFieldMaybe
bool atf_amc::PooledBE64_ReadFieldMaybe(atf_amc::PooledBE64& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.PooledBE64..ReadStrptrMaybe
// Read fields of atf_amc::PooledBE64 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::PooledBE64_ReadStrptrMaybe(atf_amc::PooledBE64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.PooledBE64");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PooledBE64_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.PooledBE64..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.PooledBE64.String  printfmt:Tuple
void atf_amc::PooledBE64_Print(atf_amc::PooledBE64& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.PooledBE64";

    atf_amc::value_Print(row, temp);
    PrintAttrSpaceReset(str,"value", temp);
}

// --- atf_amc.RnullStr6_U32.ch.Print
void atf_amc::ch_Print(atf_amc::RnullStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- atf_amc.RnullStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::ch_ReadStrptrMaybe(atf_amc::RnullStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- atf_amc.RnullStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void atf_amc::ch_SetStrptr(atf_amc::RnullStr6_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = 0;
    }
}

// --- atf_amc.RnullStr6_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 atf_amc::ch_Getnum(atf_amc::RnullStr6_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- atf_amc.RnullStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 atf_amc::ch_GetnumDflt(atf_amc::RnullStr6_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- atf_amc.RnullStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 atf_amc::ch_Geti64(atf_amc::RnullStr6_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- atf_amc.RnullStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool atf_amc::ch_SetnumMaybe(atf_amc::RnullStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- atf_amc.RnullStr6_U32..Hash
u32 atf_amc::RnullStr6_U32_Hash(u32 prev, const atf_amc::RnullStr6_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- atf_amc.RnullStr6_U32..ReadStrptrMaybe
// Read fields of atf_amc::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the atf_amc::RnullStr6_U32's only field
bool atf_amc::RnullStr6_U32_ReadStrptrMaybe(atf_amc::RnullStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.RnullStr6_U32..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.RnullStr6_U32.String  printfmt:Raw
void atf_amc::RnullStr6_U32_Print(atf_amc::RnullStr6_U32& row, algo::cstring& str) {
    atf_amc::ch_Print(row, str);
}

// --- atf_amc.RpasU32Str6.ch.Print
void atf_amc::ch_Print(atf_amc::RpasU32Str6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- atf_amc.RpasU32Str6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::ch_ReadStrptrMaybe(atf_amc::RpasU32Str6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- atf_amc.RpasU32Str6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void atf_amc::ch_SetStrptr(atf_amc::RpasU32Str6& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- atf_amc.RpasU32Str6.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 atf_amc::ch_Getnum(atf_amc::RpasU32Str6& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- atf_amc.RpasU32Str6.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 atf_amc::ch_GetnumDflt(atf_amc::RpasU32Str6& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- atf_amc.RpasU32Str6.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 atf_amc::ch_Geti64(atf_amc::RpasU32Str6& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- atf_amc.RpasU32Str6.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool atf_amc::ch_SetnumMaybe(atf_amc::RpasU32Str6& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- atf_amc.RpasU32Str6..Hash
u32 atf_amc::RpasU32Str6_Hash(u32 prev, const atf_amc::RpasU32Str6 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- atf_amc.RpasU32Str6..ReadStrptrMaybe
// Read fields of atf_amc::RpasU32Str6 from an ascii string.
// The format of the string is the format of the atf_amc::RpasU32Str6's only field
bool atf_amc::RpasU32Str6_ReadStrptrMaybe(atf_amc::RpasU32Str6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.RpasU32Str6..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.RpasU32Str6.String  printfmt:Raw
void atf_amc::RpasU32Str6_Print(atf_amc::RpasU32Str6& row, algo::cstring& str) {
    atf_amc::ch_Print(row, str);
}

// --- atf_amc.Sep1..ReadFieldMaybe
bool atf_amc::Sep1_ReadFieldMaybe(atf_amc::Sep1& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_val1: {
            retval = u32_ReadStrptrMaybe(parent.val1, strval);
            break;
        }
        case atf_amc_FieldId_val2: {
            retval = u32_ReadStrptrMaybe(parent.val2, strval);
            break;
        }
        case atf_amc_FieldId_val3: {
            retval = u32_ReadStrptrMaybe(parent.val3, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Sep1..ReadStrptrMaybe
// Read fields of atf_amc::Sep1 from an ascii string.
// The format of the string is a string with separated values
bool atf_amc::Sep1_ReadStrptrMaybe(atf_amc::Sep1 &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '-', value);
    retval = retval && u32_ReadStrptrMaybe(parent.val1, value);

    algo::NextSep(in_str, '/', value);
    retval = retval && u32_ReadStrptrMaybe(parent.val2, value);

    value = in_str;
    retval = retval && u32_ReadStrptrMaybe(parent.val3, value);
    return retval;
}

// --- atf_amc.Sep1..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Sep1.String  printfmt:Sep
void atf_amc::Sep1_Print(atf_amc::Sep1& row, algo::cstring& str) {
    u32_Print(row.val1, str);
    str << '-';
    u32_Print(row.val2, str);
    str << '/';
    u32_Print(row.val3, str);
}

// --- atf_amc.Seqmsg.msghdr.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::Seqmsg &row, atf_amc::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.Seqmsg.payload.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> atf_amc::payload_Getary(atf_amc::Seqmsg& parent) {
    u8 *end = (u8*)&parent + sizeof(atf_amc::Seqmsg);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(atf_amc::Seqmsg));
}

// --- atf_amc.Seqmsg.payload.Print
void atf_amc::payload_Print(atf_amc::Seqmsg& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (atf_amc::MsgHeader *payload = payload_Get(parent)) {
        atf_amc::MsgHeaderMsgs_Print(out, *payload, INT_MAX);
    }
}

// --- atf_amc.Seqmsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::payload_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = atf_amc::MsgHeaderMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.Seqmsg..ReadFieldMaybe
bool atf_amc::Seqmsg_ReadFieldMaybe(atf_amc::Seqmsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_msghdr: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Seqmsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::Seqmsg from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::Seqmsg_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.Seqmsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Seqmsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.Seqmsg..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Seqmsg.String  printfmt:Tuple
void atf_amc::Seqmsg_Print(atf_amc::Seqmsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.Seqmsg";

    if (payload_Get(row)) {
        atf_amc::payload_Print(row, temp);
        PrintAttrSpaceReset(str,"payload", temp);
    }
}

// --- atf_amc.SortedStr.novs.Nextchar
// Extract next character from STR and advance IDX
inline static int atf_amc::novs_Nextchar(const atf_amc::SortedStr& parent, algo::strptr &str, int &idx) {
    (void)parent;
    int i = idx;
    int ch = str.elems[i];
    i++;
    idx = i;
    return ch;
}

// --- atf_amc.SortedStr.vs.Nextchar
// Extract next character from STR and advance IDX
inline static u64 atf_amc::vs_Nextchar(const atf_amc::SortedStr& parent, algo::strptr &str, int &idx) {
    (void)parent;
    int i = idx;
    u64 ch = str.elems[i];
    i++;
    // detect number in string and eat it up into CH.
    // (this only works for base-10 numbers
    // Digits are sorted before chars
    if (unsigned(ch - '0') < 10) {
        while(i < str.n_elems) { // resulting char sorts before ascii 47
            unsigned dig = str.elems[i] - '0';
            if (dig >= 10) break;
            ch = ch * 10 + dig;
            i++;
        }
    } else if (ch > '9') {
        // create space between '0'..'9' for 15-digit numbers
        ch += 1000000000000000LL;
    }
    idx = i;
    return ch;
}

// --- atf_amc.SortedStr.vs.Cmp
// Compare two fields.
// Comparison uses version sort (detect embedded integers).
// Comparison is case-insensitive.
i32 atf_amc::vs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) {
    i32 retval = 0;
    int idx_a = 0;
    int idx_b = 0;
    algo::strptr str_a = ch_Getary(parent.vs);
    algo::strptr str_b = ch_Getary(rhs.vs);
    int n_a   = elems_N(str_a);
    int n_b   = elems_N(str_b);
    retval    = i32_Cmp(n_a,n_b);
    while (idx_a < n_a && idx_b < n_b) {
        u64 ch_a = vs_Nextchar(parent, str_a, idx_a);
        u64 ch_b = vs_Nextchar(rhs, str_b, idx_b);
        if (ch_a != ch_b) {
            retval = (ch_a > ch_b)*2-1;
            break;
        }
    }
    return retval;
}

// --- atf_amc.SsimfilesCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::SsimfilesCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_SsimfilesCase_dmmeta_Ctype: ret = "dmmeta.Ctype";  break;
    }
    return ret;
}

// --- atf_amc.SsimfilesCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::SsimfilesCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.SsimfilesCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,atf_amc_SsimfilesCase_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,atf_amc_SsimfilesCase_dmmeta_ctype); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.SsimfilesCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::SsimfilesCase& parent, algo::strptr rhs, atf_amc_SsimfilesCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.SsimfilesCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.SsimfilesCase..ReadStrptrMaybe
// Read fields of atf_amc::SsimfilesCase from an ascii string.
// The format of the string is the format of the atf_amc::SsimfilesCase's only field
bool atf_amc::SsimfilesCase_ReadStrptrMaybe(atf_amc::SsimfilesCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_TableId_atf_amc_TypeS : ret = "atf_amc.TypeS";  break;
        case atf_amc_TableId_atf_amc_TypeT : ret = "atf_amc.TypeT";  break;
    }
    return ret;
}

// --- atf_amc.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','t','f','_','a','m','c','.'): {
                    if (memcmp(rhs.elems+8,"TypeS",5)==0) { value_SetEnum(parent,atf_amc_TableId_atf_amc_TypeS); ret = true; break; }
                    if (memcmp(rhs.elems+8,"TypeT",5)==0) { value_SetEnum(parent,atf_amc_TableId_atf_amc_TypeT); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::TableId& parent, algo::strptr rhs, atf_amc_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.TableId..ReadStrptrMaybe
// Read fields of atf_amc::TableId from an ascii string.
// The format of the string is the format of the atf_amc::TableId's only field
bool atf_amc::TableId_ReadStrptrMaybe(atf_amc::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.TableId..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TableId.String  printfmt:Raw
void atf_amc::TableId_Print(atf_amc::TableId& row, algo::cstring& str) {
    atf_amc::value_Print(row, str);
}

// --- atf_amc.TaryU32.tary_u32.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u32> atf_amc::tary_u32_Addary(atf_amc::TaryU32& parent, algo::aryptr<u32> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.tary_u32_elems && rhs.elems < parent.tary_u32_elems + parent.tary_u32_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_amc.tary_alias  field:atf_amc.TaryU32.tary_u32  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    tary_u32_Reserve(parent, nnew); // reserve space
    int at = parent.tary_u32_n;
    memcpy(parent.tary_u32_elems + at, rhs.elems, nnew * sizeof(u32));
    parent.tary_u32_n += nnew;
    return algo::aryptr<u32>(parent.tary_u32_elems + at, nnew);
}

// --- atf_amc.TaryU32.tary_u32.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u32& atf_amc::tary_u32_Alloc(atf_amc::TaryU32& parent) {
    tary_u32_Reserve(parent, 1);
    int n  = parent.tary_u32_n;
    int at = n;
    u32 *elems = parent.tary_u32_elems;
    new (elems + at) u32(44); // construct new element, default initializer
    parent.tary_u32_n = n+1;
    return elems[at];
}

// --- atf_amc.TaryU32.tary_u32.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u32& atf_amc::tary_u32_AllocAt(atf_amc::TaryU32& parent, int at) {
    tary_u32_Reserve(parent, 1);
    int n  = parent.tary_u32_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_amc.bad_alloc_at  field:atf_amc.TaryU32.tary_u32  comment:'index out of range'");
    }
    u32 *elems = parent.tary_u32_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u32));
    new (elems + at) u32(44); // construct element, default initializer
    parent.tary_u32_n = n+1;
    return elems[at];
}

// --- atf_amc.TaryU32.tary_u32.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u32> atf_amc::tary_u32_AllocN(atf_amc::TaryU32& parent, int n_elems) {
    tary_u32_Reserve(parent, n_elems);
    int old_n  = parent.tary_u32_n;
    int new_n = old_n + n_elems;
    u32 *elems = parent.tary_u32_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u32(44); // construct new element, default initialize
    }
    parent.tary_u32_n = new_n;
    return algo::aryptr<u32>(elems + old_n, n_elems);
}

// --- atf_amc.TaryU32.tary_u32.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_amc::tary_u32_Remove(atf_amc::TaryU32& parent, u32 i) {
    u32 lim = parent.tary_u32_n;
    u32 *elems = parent.tary_u32_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u32) * (lim - (i + 1)));
        parent.tary_u32_n = lim - 1;
    }
}

// --- atf_amc.TaryU32.tary_u32.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::tary_u32_RemoveLast(atf_amc::TaryU32& parent) {
    u64 n = parent.tary_u32_n;
    if (n > 0) {
        n -= 1;
        parent.tary_u32_n = n;
    }
}

// --- atf_amc.TaryU32.tary_u32.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_amc::tary_u32_AbsReserve(atf_amc::TaryU32& parent, int n) {
    u32 old_max  = parent.tary_u32_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.tary_u32_elems, old_max * sizeof(u32), new_max * sizeof(u32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.tary_nomem  field:atf_amc.TaryU32.tary_u32  comment:'out of memory'");
        }
        parent.tary_u32_elems = (u32*)new_mem;
        parent.tary_u32_max = new_max;
    }
}

// --- atf_amc.TaryU32.tary_u32.Setary
// Copy contents of RHS to PARENT.
void atf_amc::tary_u32_Setary(atf_amc::TaryU32& parent, atf_amc::TaryU32 &rhs) {
    tary_u32_RemoveAll(parent);
    int nnew = rhs.tary_u32_n;
    tary_u32_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.tary_u32_elems + i) u32(tary_u32_qFind(rhs, i));
        parent.tary_u32_n = i + 1;
    }
}

// --- atf_amc.TaryU32.tary_u32.Setary2
// Copy specified array into tary_u32, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_amc::tary_u32_Setary(atf_amc::TaryU32& parent, const algo::aryptr<u32> &rhs) {
    tary_u32_RemoveAll(parent);
    tary_u32_Addary(parent, rhs);
}

// --- atf_amc.TaryU32.tary_u32.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u32> atf_amc::tary_u32_AllocNVal(atf_amc::TaryU32& parent, int n_elems, const u32& val) {
    tary_u32_Reserve(parent, n_elems);
    int old_n  = parent.tary_u32_n;
    int new_n = old_n + n_elems;
    u32 *elems = parent.tary_u32_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u32(val);
    }
    parent.tary_u32_n = new_n;
    return algo::aryptr<u32>(elems + old_n, n_elems);
}

// --- atf_amc.TaryU32.tary_u32.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool atf_amc::tary_u32_ReadStrptrMaybe(atf_amc::TaryU32& parent, algo::strptr in_str) {
    bool retval = true;
    u32 &elem = tary_u32_Alloc(parent);
    retval = u32_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        tary_u32_RemoveLast(parent);
    }
    return retval;
}

// --- atf_amc.TaryU32..Uninit
void atf_amc::TaryU32_Uninit(atf_amc::TaryU32& parent) {
    atf_amc::TaryU32 &row = parent; (void)row;

    // atf_amc.TaryU32.tary_u32.Uninit (Tary)  //
    // remove all elements from atf_amc.TaryU32.tary_u32
    tary_u32_RemoveAll(parent);
    // free memory for Tary atf_amc.TaryU32.tary_u32
    algo_lib::malloc_FreeMem(parent.tary_u32_elems, sizeof(u32)*parent.tary_u32_max); // (atf_amc.TaryU32.tary_u32)
}

// --- atf_amc.TaryU8.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u8> atf_amc::ary_Addary(atf_amc::TaryU8& parent, algo::aryptr<u8> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("atf_amc.tary_alias  field:atf_amc.TaryU8.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    memcpy(parent.ary_elems + at, rhs.elems, nnew * sizeof(u8));
    parent.ary_n += nnew;
    return algo::aryptr<u8>(parent.ary_elems + at, nnew);
}

// --- atf_amc.TaryU8.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& atf_amc::ary_Alloc(atf_amc::TaryU8& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u8 *elems = parent.ary_elems;
    new (elems + at) u8(44); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- atf_amc.TaryU8.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& atf_amc::ary_AllocAt(atf_amc::TaryU8& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("atf_amc.bad_alloc_at  field:atf_amc.TaryU8.ary  comment:'index out of range'");
    }
    u8 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(44); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- atf_amc.TaryU8.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> atf_amc::ary_AllocN(atf_amc::TaryU8& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.ary_elems;
    memset(elems + old_n, 44, new_n - old_n); // initialize new space
    parent.ary_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- atf_amc.TaryU8.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void atf_amc::ary_Remove(atf_amc::TaryU8& parent, u32 i) {
    u32 lim = parent.ary_n;
    u8 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- atf_amc.TaryU8.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void atf_amc::ary_RemoveLast(atf_amc::TaryU8& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- atf_amc.TaryU8.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void atf_amc::ary_AbsReserve(atf_amc::TaryU8& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("atf_amc.tary_nomem  field:atf_amc.TaryU8.ary  comment:'out of memory'");
        }
        parent.ary_elems = (u8*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- atf_amc.TaryU8.ary.Print
// Convert ary to a string.
// Array is printed as a regular string.
void atf_amc::ary_Print(atf_amc::TaryU8& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(ary_Getary(parent));
}

// --- atf_amc.TaryU8.ary.Setary
// Copy contents of RHS to PARENT.
void atf_amc::ary_Setary(atf_amc::TaryU8& parent, atf_amc::TaryU8 &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    memcpy(parent.ary_elems, rhs.ary_elems, nnew * sizeof(u8));
    parent.ary_n = nnew;
}

// --- atf_amc.TaryU8.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void atf_amc::ary_Setary(atf_amc::TaryU8& parent, const algo::aryptr<u8> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- atf_amc.TaryU8.ary.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> atf_amc::ary_AllocNVal(atf_amc::TaryU8& parent, int n_elems, const u8& val) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.ary_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.ary_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- atf_amc.TaryU8.ary.ReadStrptrMaybe
// The array is replaced with the input string. Function always succeeds.
bool atf_amc::ary_ReadStrptrMaybe(atf_amc::TaryU8& parent, algo::strptr in_str) {
    bool retval = true;
    ary_RemoveAll(parent);
    ary_Addary(parent,algo::strptr_ToMemptr(in_str));
    return retval;
}

// --- atf_amc.TaryU8..Uninit
void atf_amc::TaryU8_Uninit(atf_amc::TaryU8& parent) {
    atf_amc::TaryU8 &row = parent; (void)row;

    // atf_amc.TaryU8.ary.Uninit (Tary)  //
    // remove all elements from atf_amc.TaryU8.ary
    ary_RemoveAll(parent);
    // free memory for Tary atf_amc.TaryU8.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(u8)*parent.ary_max); // (atf_amc.TaryU8.ary)
}

// --- atf_amc.TestRegx1.val.Print
// Print back to string
void atf_amc::val_Print(atf_amc::TestRegx1& parent, algo::cstring &out) {
    Regx_Print(parent.val, out);
}

// --- atf_amc.TestRegx1.val.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool atf_amc::val_ReadStrptrMaybe(atf_amc::TestRegx1& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.val, in, true);
    return retval;
}

// --- atf_amc.TestRegx1..ReadFieldMaybe
bool atf_amc::TestRegx1_ReadFieldMaybe(atf_amc::TestRegx1& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_val: {
            retval = val_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TestRegx1..ReadStrptrMaybe
// Read fields of atf_amc::TestRegx1 from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::TestRegx1_ReadStrptrMaybe(atf_amc::TestRegx1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.TestRegx1");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TestRegx1_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.TestRegx1..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TestRegx1.String  printfmt:Tuple
void atf_amc::TestRegx1_Print(atf_amc::TestRegx1& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.TestRegx1";

    atf_amc::val_Print(row, temp);
    PrintAttrSpaceReset(str,"val", temp);
}

// --- atf_amc.TestType..ReadStrptrMaybe
// Read fields of atf_amc::TestType from an ascii string.
bool atf_amc::TestType_ReadStrptrMaybe(atf_amc::TestType &parent, algo::strptr in_str) {
    bool retval = true;
    (void)parent;//only to avoid -Wunused-parameter
    (void)in_str;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.TestType..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TestType.String  printfmt:Raw
void atf_amc::TestType_Print(atf_amc::TestType& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- atf_amc.Text.msghdr.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::Text &row, atf_amc::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.Text.text.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> atf_amc::text_Getary(atf_amc::Text& parent) {
    return algo::aryptr<char>(text_Addr(parent), text_N(parent));
}

// --- atf_amc.Text.text.Addr
char* atf_amc::text_Addr(atf_amc::Text& parent) {
    return (char*)((u8*)&parent + sizeof(atf_amc::Text)); // address of varlen portion
}

// --- atf_amc.Text.text.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::text_ReadStrptrMaybe(atf_amc::Text& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.Text.text.Print
// Convert text to a string.
// Array is printed as a regular string.
void atf_amc::text_Print(atf_amc::Text& parent, algo::cstring &rhs) {
    rhs << text_Getary(parent);
}

// --- atf_amc.Text..ReadFieldMaybe
bool atf_amc::Text_ReadFieldMaybe(atf_amc::Text& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_msghdr: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_text: {
            retval = text_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Text..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::Text from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::Text_ReadStrptrMaybe(atf_amc::Text &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.Text");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Text_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.Text..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Text.String  printfmt:Tuple
void atf_amc::Text_Print(atf_amc::Text& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.Text";

    atf_amc::text_Print(row, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- atf_amc.TypeB..ReadFieldMaybe
bool atf_amc::TypeB_ReadFieldMaybe(atf_amc::TypeB& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_typea: {
            retval = i32_ReadStrptrMaybe(parent.typea, strval);
            break;
        }
        case atf_amc_FieldId_j: {
            retval = i32_ReadStrptrMaybe(parent.j, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeB..ReadStrptrMaybe
// Read fields of atf_amc::TypeB from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::TypeB_ReadStrptrMaybe(atf_amc::TypeB &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.TypeB");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TypeB_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.TypeB..FmtJson
// Create JSON representation of atf_amc::TypeB under PARENT node
// cfmt:atf_amc.TypeB.Json  printfmt:Auto
lib_json::FNode * atf_amc::TypeB_FmtJson(atf_amc::TypeB& row, lib_json::FNode *parent) {
    lib_json::FNode *object_node = &lib_json::node_Alloc();
    object_node->p_parent = parent?parent:object_node;
    object_node->type   = lib_json_FNode_type_object;
    node_XrefMaybe(*object_node);

    lib_json::FNode *typea_field_node = &lib_json::node_Alloc();
    typea_field_node->p_parent = object_node;
    typea_field_node->type   = lib_json_FNode_type_field;
    typea_field_node->value  = "typea";
    node_XrefMaybe(*typea_field_node);
    i32_FmtJson(const_cast<atf_amc::TypeB&>(row).typea,typea_field_node);

    lib_json::FNode *j_field_node = &lib_json::node_Alloc();
    j_field_node->p_parent = object_node;
    j_field_node->type   = lib_json_FNode_type_field;
    j_field_node->value  = "j";
    node_XrefMaybe(*j_field_node);
    i32_FmtJson(const_cast<atf_amc::TypeB&>(row).j,j_field_node);
    return object_node;
}

// --- atf_amc.TypeB..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeB.String  printfmt:Tuple
void atf_amc::TypeB_Print(atf_amc::TypeB& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.TypeB";

    i32_Print(row.typea, temp);
    PrintAttrSpaceReset(str,"typea", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_amc.TypeBE32en.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::TypeBE32en& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_TypeBE32en_value_val1 : ret = "val1";  break;
        case atf_amc_TypeBE32en_value_val2 : ret = "val2";  break;
    }
    return ret;
}

// --- atf_amc.TypeBE32en.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::TypeBE32en& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << value_Get(parent);
    }
}

// --- atf_amc.TypeBE32en.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::TypeBE32en& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('v','a','l','1'): {
                    value_SetEnum(parent,atf_amc_TypeBE32en_value_val1); ret = true; break;
                }
                case LE_STR4('v','a','l','2'): {
                    value_SetEnum(parent,atf_amc_TypeBE32en_value_val2); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.TypeBE32en.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::TypeBE32en& parent, algo::strptr rhs, atf_amc_TypeBE32en_value_Enum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.TypeBE32en.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::TypeBE32en& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        u32 value_tmp;
        retval = u32_ReadStrptrMaybe(value_tmp, rhs);
        if (retval) {
            value_Set(parent, value_tmp);
        }
    }
    return retval;
}

// --- atf_amc.TypeBE32en..ReadFieldMaybe
bool atf_amc::TypeBE32en_ReadFieldMaybe(atf_amc::TypeBE32en& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeBE32en..ReadStrptrMaybe
// Read fields of atf_amc::TypeBE32en from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE32en's only field
bool atf_amc::TypeBE32en_ReadStrptrMaybe(atf_amc::TypeBE32en &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.TypeBE32en..ReadTupleMaybe
// Read fields of atf_amc::TypeBE32en from attributes of ascii tuple TUPLE
bool atf_amc::TypeBE32en_ReadTupleMaybe(atf_amc::TypeBE32en &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = TypeBE32en_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.TypeBE32en..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeBE32en.String  printfmt:Raw
void atf_amc::TypeBE32en_Print(atf_amc::TypeBE32en& row, algo::cstring& str) {
    atf_amc::value_Print(row, str);
}

// --- atf_amc.TypeBE64.value.ReadStrptrMaybe
inline static bool atf_amc::value_ReadStrptrMaybe(atf_amc::TypeBE64 &parent, algo::strptr in_str) {
    bool retval = true;
    u64 value_tmp;
    retval = u64_ReadStrptrMaybe(value_tmp, in_str);
    if (retval) {
        value_Set(parent, value_tmp);
    }
    return retval;
}

// --- atf_amc.TypeBE64..ReadFieldMaybe
bool atf_amc::TypeBE64_ReadFieldMaybe(atf_amc::TypeBE64& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeBE64..ReadStrptrMaybe
// Read fields of atf_amc::TypeBE64 from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE64's only field
bool atf_amc::TypeBE64_ReadStrptrMaybe(atf_amc::TypeBE64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.TypeBE64..ReadTupleMaybe
// Read fields of atf_amc::TypeBE64 from attributes of ascii tuple TUPLE
bool atf_amc::TypeBE64_ReadTupleMaybe(atf_amc::TypeBE64 &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = TypeBE64_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.TypeBE64..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeBE64.String  printfmt:Raw
void atf_amc::TypeBE64_Print(atf_amc::TypeBE64& row, algo::cstring& str) {
    u64_Print(value_Get(row), str);
}

// --- atf_amc.TypeC..ReadStrptrMaybe
// Read fields of atf_amc::TypeC from an ascii string.
// The format of the string is the format of the atf_amc::TypeC's only field
bool atf_amc::TypeC_ReadStrptrMaybe(atf_amc::TypeC &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.typec, in_str);
    return retval;
}

// --- atf_amc.TypeC..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeC.String  printfmt:Raw
void atf_amc::TypeC_Print(atf_amc::TypeC& row, algo::cstring& str) {
    i32_Print(row.typec, str);
}

// --- atf_amc.TypeH..ReadStrptrMaybe
// Read fields of atf_amc::TypeH from an ascii string.
// The format of the string is the format of the atf_amc::TypeH's only field
bool atf_amc::TypeH_ReadStrptrMaybe(atf_amc::TypeH &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.typeh, in_str);
    return retval;
}

// --- atf_amc.TypeH..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeH.String  printfmt:Raw
void atf_amc::TypeH_Print(atf_amc::TypeH& row, algo::cstring& str) {
    i32_Print(row.typeh, str);
}

// --- atf_amc.TypeS..ReadFieldMaybe
bool atf_amc::TypeS_ReadFieldMaybe(atf_amc::TypeS& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_types: {
            retval = i32_ReadStrptrMaybe(parent.types, strval);
            break;
        }
        case atf_amc_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeS..ReadStrptrMaybe
// Read fields of atf_amc::TypeS from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::TypeS_ReadStrptrMaybe(atf_amc::TypeS &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.TypeS");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TypeS_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.TypeS..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeS.String  printfmt:Tuple
void atf_amc::TypeS_Print(atf_amc::TypeS& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.TypeS";

    i32_Print(row.types, temp);
    PrintAttrSpaceReset(str,"types", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atf_amc.TypeT..ReadFieldMaybe
bool atf_amc::TypeT_ReadFieldMaybe(atf_amc::TypeT& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_types: {
            retval = i32_ReadStrptrMaybe(parent.types, strval);
            break;
        }
        case atf_amc_FieldId_j: {
            retval = i32_ReadStrptrMaybe(parent.j, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeT..ReadStrptrMaybe
// Read fields of atf_amc::TypeT from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::TypeT_ReadStrptrMaybe(atf_amc::TypeT &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.TypeT");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TypeT_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.TypeT..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeT.String  printfmt:Tuple
void atf_amc::TypeT_Print(atf_amc::TypeT& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.TypeT";

    i32_Print(row.types, temp);
    PrintAttrSpaceReset(str,"types", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_amc.TypeTVal..ReadFieldMaybe
bool atf_amc::TypeTVal_ReadFieldMaybe(atf_amc::TypeTVal& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_types: {
            retval = atf_amc::TypeS_ReadStrptrMaybe(parent.types, strval);
            break;
        }
        case atf_amc_FieldId_j: {
            retval = i32_ReadStrptrMaybe(parent.j, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.TypeTVal..ReadStrptrMaybe
// Read fields of atf_amc::TypeTVal from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::TypeTVal_ReadStrptrMaybe(atf_amc::TypeTVal &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.TypeTVal");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TypeTVal_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.TypeTVal..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeTVal.String  printfmt:Tuple
void atf_amc::TypeTVal_Print(atf_amc::TypeTVal& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.TypeTVal";

    atf_amc::TypeS_Print(row.types, temp);
    PrintAttrSpaceReset(str,"types", temp);

    i32_Print(row.j, temp);
    PrintAttrSpaceReset(str,"j", temp);
}

// --- atf_amc.Typefconst.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf_amc::value_ToCstr(const atf_amc::Typefconst& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_amc_Typefconst_value_strval1: ret = "strval1";  break;
        case atf_amc_Typefconst_value_strval2: ret = "strval2";  break;
    }
    return ret;
}

// --- atf_amc.Typefconst.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf_amc::value_Print(const atf_amc::Typefconst& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf_amc.Typefconst.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf_amc::value_SetStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('s','t','r','v','a','l','1'): {
                    value_SetEnum(parent,atf_amc_Typefconst_value_strval1); ret = true; break;
                }
                case LE_STR7('s','t','r','v','a','l','2'): {
                    value_SetEnum(parent,atf_amc_Typefconst_value_strval2); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf_amc.Typefconst.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf_amc::value_SetStrptr(atf_amc::Typefconst& parent, algo::strptr rhs, atf_amc_Typefconst_value_Enum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf_amc.Typefconst.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::value_ReadStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf_amc.Typefconst..ReadFieldMaybe
bool atf_amc::Typefconst_ReadFieldMaybe(atf_amc::Typefconst& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case atf_amc_FieldId_value: {
            retval = value_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.Typefconst..ReadStrptrMaybe
// Read fields of atf_amc::Typefconst from an ascii string.
// The format of the string is the format of the atf_amc::Typefconst's only field
bool atf_amc::Typefconst_ReadStrptrMaybe(atf_amc::Typefconst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf_amc.Typefconst..ReadTupleMaybe
// Read fields of atf_amc::Typefconst from attributes of ascii tuple TUPLE
bool atf_amc::Typefconst_ReadTupleMaybe(atf_amc::Typefconst &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = Typefconst_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atf_amc.Typefconst..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.Typefconst.String  printfmt:Raw
void atf_amc::Typefconst_Print(atf_amc::Typefconst& row, algo::cstring& str) {
    atf_amc::value_Print(row, str);
}

// --- atf_amc.VarlenAlloc.elem.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<i32> atf_amc::elem_Getary(atf_amc::VarlenAlloc& varlenalloc) {
    return algo::aryptr<i32>(elem_Addr(varlenalloc), elem_N(varlenalloc));
}

// --- atf_amc.VarlenAlloc.elem.Addr
i32* atf_amc::elem_Addr(atf_amc::VarlenAlloc& varlenalloc) {
    return (i32*)((u8*)&varlenalloc + sizeof(atf_amc::VarlenAlloc)); // address of varlen portion
}

// --- atf_amc.VarlenExtern.varlen.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u32> atf_amc::varlen_Getary(atf_amc::VarlenExtern& varlen_extern) {
    return algo::aryptr<u32>(varlen_Addr(varlen_extern), varlen_N(varlen_extern));
}

// --- atf_amc.VarlenExtern.varlen.Addr
u32* atf_amc::varlen_Addr(atf_amc::VarlenExtern& varlen_extern) {
    return (u32*)((u8*)&varlen_extern + sizeof(atf_amc::VarlenExtern)); // address of varlen portion
}

// --- atf_amc.VarlenH.typeh.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<atf_amc::TypeH> atf_amc::typeh_Getary(atf_amc::VarlenH& parent) {
    return algo::aryptr<atf_amc::TypeH>(typeh_Addr(parent), typeh_N(parent));
}

// --- atf_amc.VarlenH.typeh.Addr
atf_amc::TypeH* atf_amc::typeh_Addr(atf_amc::VarlenH& parent) {
    return (atf_amc::TypeH*)((u8*)&parent + sizeof(atf_amc::VarlenH)); // address of varlen portion
}

// --- atf_amc.VarlenH.typeh.Swap
// Swap values elem_a and elem_b
inline static void atf_amc::typeh_Swap(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b) {
    u8 temp[sizeof(atf_amc::TypeH)];
    memcpy(&temp  , &elem_a, sizeof(atf_amc::TypeH));
    memcpy(&elem_a, &elem_b, sizeof(atf_amc::TypeH));
    memcpy(&elem_b, &temp  , sizeof(atf_amc::TypeH));
}

// --- atf_amc.VarlenH.typeh.Rotleft
// Left circular shift of three-tuple
inline static void atf_amc::typeh_Rotleft(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b, atf_amc::TypeH &elem_c) {
    u8 temp[sizeof(atf_amc::TypeH)];
    memcpy(&temp, &elem_a   , sizeof(atf_amc::TypeH));
    memcpy(&elem_a   , &elem_b   , sizeof(atf_amc::TypeH));
    memcpy(&elem_b   , &elem_c   , sizeof(atf_amc::TypeH));
    memcpy(&elem_c   , &temp, sizeof(atf_amc::TypeH));
}

// --- atf_amc.VarlenH.typeh.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool atf_amc::typeh_Lt(atf_amc::TypeH &elem_a, atf_amc::TypeH &elem_b) {
    bool ret;
    ret = elem_a.typeh < elem_b.typeh;
    return ret;
}

// --- atf_amc.VarlenH.typeh.SortedQ
// Verify whether array is sorted
bool atf_amc::typeh_SortedQ(atf_amc::VarlenH& parent) {
    atf_amc::TypeH *elems = typeh_Getary(parent).elems;
    int n = typeh_N(parent);
    for (int i = 1; i < n; i++) {
        if (typeh_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- atf_amc.VarlenH.typeh.IntInsertionSort
// Internal insertion sort
static void atf_amc::typeh_IntInsertionSort(atf_amc::TypeH *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        // find the spot for ith element.
        while (j>0 && typeh_Lt(elems[i], elems[j-1])) {
            j--;
        }
        if (j<i) {
            u8 tmp[sizeof(atf_amc::TypeH)];
            memcpy (tmp                       , &elems[i], sizeof(atf_amc::TypeH)      );
            memmove(&elems[j+1], &elems[j], sizeof(atf_amc::TypeH)*(i-j));
            memcpy (&elems[j]  , tmp                     , sizeof(atf_amc::TypeH)      );
        }
    }
}

// --- atf_amc.VarlenH.typeh.IntHeapSort
// Internal heap sort
static void atf_amc::typeh_IntHeapSort(atf_amc::TypeH *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (typeh_Lt(elems[j], elems[k])) {
            typeh_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && typeh_Lt(elems[l], elems[l+1]);
            if (typeh_Lt(elems[l], elems[i])) {
                break;
            }
            typeh_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            typeh_Swap(elems[i],elems[k]);
        }
    }
}

// --- atf_amc.VarlenH.typeh.IntQuickSort
// Quick sort engine
static void atf_amc::typeh_IntQuickSort(atf_amc::TypeH *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            typeh_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (typeh_Lt(elems[pp], elems[pi])) {
            typeh_Swap(elems[pi], elems[pp]);
        }
        if (typeh_Lt(elems[pj], elems[pp])) {
            if (typeh_Lt(elems[pj], elems[pi])) {
                typeh_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                typeh_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        typeh_Swap(elems[--pj], elems[pp]);
        // reference to pivot
        atf_amc::TypeH &pivot = elems[pj];
        for(;;){
            while (typeh_Lt(elems[++pi], pivot)) {
            }
            while (typeh_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            typeh_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        typeh_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    typeh_IntInsertionSort(elems,n);
}

// --- atf_amc.VarlenH.typeh.InsertionSort
// Insertion sort
void atf_amc::typeh_InsertionSort(atf_amc::VarlenH& parent) {
    atf_amc::TypeH *elems = typeh_Getary(parent).elems;
    int n = typeh_N(parent);
    typeh_IntInsertionSort(elems, n);
}

// --- atf_amc.VarlenH.typeh.HeapSort
// Heap sort
void atf_amc::typeh_HeapSort(atf_amc::VarlenH& parent) {
    atf_amc::TypeH *elems = typeh_Getary(parent).elems;
    int n = typeh_N(parent);
    typeh_IntHeapSort(elems, n);
}

// --- atf_amc.VarlenH.typeh.QuickSort
// Quick sort
void atf_amc::typeh_QuickSort(atf_amc::VarlenH& parent) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(typeh_N(parent) + 1)) + 3;
    atf_amc::TypeH *elems = typeh_Getary(parent).elems;
    int n = typeh_N(parent);
    typeh_IntQuickSort(elems, n, max_depth);
}

// --- atf_amc.VarlenH.typeh.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::typeh_XrefMaybe(atf_amc::TypeH &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.VarlenK.i.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u32> atf_amc::i_Getary(atf_amc::VarlenK& k) {
    return algo::aryptr<u32>(i_Addr(k), i_N(k));
}

// --- atf_amc.VarlenK.i.Addr
u32* atf_amc::i_Addr(atf_amc::VarlenK& k) {
    return (u32*)((u8*)&k + sizeof(atf_amc::VarlenK)); // address of varlen portion
}

// --- atf_amc.VarlenK.i.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::i_ReadStrptrMaybe(atf_amc::VarlenK& k, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        u32 *i_tmp = new(ary_AllocN(*algo_lib::_db.varlenbuf, sizeof(u32)).elems) u32;
        retval = u32_ReadStrptrMaybe(*i_tmp, in_str);
    }
    (void)k;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.VarlenK..ReadFieldMaybe
bool atf_amc::VarlenK_ReadFieldMaybe(atf_amc::VarlenK& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_i: {
            retval = i_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.VarlenK..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::VarlenK from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::VarlenK_ReadStrptrMaybe(atf_amc::VarlenK &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.VarlenK");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && VarlenK_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.VarlenK..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.VarlenK.String  printfmt:Tuple
void atf_amc::VarlenK_Print(atf_amc::VarlenK& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.VarlenK";

    ind_beg(k_i_curs,i,row) {
        u32_Print(i, temp);
        tempstr name;
        name << "i.";
        name << ind_curs(i).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;
}

// --- atf_amc.VarlenMsg.base.CopyOut
// Copy fields out of row
void atf_amc::parent_CopyOut(atf_amc::VarlenMsg &row, atf_amc::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- atf_amc.VarlenMsg.k.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> atf_amc::k_Getary(atf_amc::VarlenMsg& parent) {
    return algo::aryptr<u8>(k_Addr(parent), k_N(parent));
}

// --- atf_amc.VarlenMsg.k.Addr
u8* atf_amc::k_Addr(atf_amc::VarlenMsg& parent) {
    return (u8*)((u8*)&parent + sizeof(atf_amc::VarlenMsg)); // address of varlen portion
}

// --- atf_amc.VarlenMsg.k.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf_amc::k_ReadStrptrMaybe(atf_amc::VarlenMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        atf_amc::VarlenK *k_tmp = new(ary_AllocN(*algo_lib::_db.varlenbuf, sizeof(atf_amc::VarlenK)).elems) atf_amc::VarlenK;
        retval = atf_amc::VarlenK_ReadStrptrMaybe(*k_tmp, in_str);
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- atf_amc.VarlenMsg.k.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool atf_amc::k_XrefMaybe(atf_amc::VarlenK &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- atf_amc.VarlenMsg..ReadFieldMaybe
bool atf_amc::VarlenMsg_ReadFieldMaybe(atf_amc::VarlenMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    atf_amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case atf_amc_FieldId_base: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_type: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_length: {
            retval = false;
            break;
        }
        case atf_amc_FieldId_k: {
            retval = k_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf_amc.VarlenMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::VarlenMsg from an ascii string.
// The format of the string is an ssim Tuple
bool atf_amc::VarlenMsg_ReadStrptrMaybe(atf_amc::VarlenMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf_amc.VarlenMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && VarlenMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf_amc.VarlenMsg..Print
// print string representation of ROW to string STR
// cfmt:atf_amc.VarlenMsg.String  printfmt:Tuple
void atf_amc::VarlenMsg_Print(atf_amc::VarlenMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "atf_amc.VarlenMsg";

    ind_beg(VarlenMsg_k_curs,k,row) {
        atf_amc::VarlenK_Print(k, temp);
        tempstr name;
        name << "k.";
        name << ind_curs(k).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;
}

// --- atf_amc...ForAllStrings
// Test string conversion
void atf_amc::ForAllStrings(void (*fcn)(algo::StringDesc&) ) {
    algo::StringDesc desc;
    // fill out descriptor for numstr:atf_amc.RnullStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(atf_amc::RnullStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(atf_amc::RnullStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(atf_amc::RnullStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const atf_amc::RnullStr6_U32&)>(ch_Getary));
        desc.smallstr    = "atf_amc.RnullStr6_U32.ch";
        desc.strtype     = "rightpad";
        desc.pad         = 0;
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:atf_amc.RpasU32Str6.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(atf_amc::RpasU32Str6&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(atf_amc::RpasU32Str6&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(atf_amc::RpasU32Str6&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const atf_amc::RpasU32Str6&)>(ch_Getary));
        desc.smallstr    = "atf_amc.RpasU32Str6.ch";
        desc.strtype     = "rpascal";
        desc.pad         = 0;
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
}

// --- atf_amc...SizeCheck
inline static void atf_amc::SizeCheck() {
}

// --- atf_amc...StaticCheck
void atf_amc::StaticCheck() {
    algo_assert(sizeof(atf_amc::amctest_step_hook) == 8); // csize:atf_amc.amctest_step_hook
    algo_assert(sizeof(atf_amc::listtype_step_hook) == 8); // csize:atf_amc.listtype_step_hook
    algo_assert(sizeof(atf_amc::parent_callback_hook) == 8); // csize:atf_amc.parent_callback_hook
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::BitfldType1*)0)->value)*8 >= 15);
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::BitfldType2*)0)->value)*8 >= 2);
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::BitfldU128*)0)->value)*8 >= 128);
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::BitfldU16*)0)->value)*8 >= 12);
    algo_assert(_offset_of(atf_amc::DispCase, value) + sizeof(((atf_amc::DispCase*)0)->value) == sizeof(atf_amc::DispCase));
    algo_assert(_offset_of(atf_amc::trace, step_cd_in_msg_cycles) + sizeof(((atf_amc::trace*)0)->step_cd_in_msg_cycles) == sizeof(atf_amc::trace));
    algo_assert(_offset_of(atf_amc::FieldId, value) + sizeof(((atf_amc::FieldId*)0)->value) == sizeof(atf_amc::FieldId));
    algo_assert(_offset_of(atf_amc::MsgHdrLTMsgsCase, value) + sizeof(((atf_amc::MsgHdrLTMsgsCase*)0)->value) == sizeof(atf_amc::MsgHdrLTMsgsCase));
    algo_assert(_offset_of(atf_amc::MsgHdrLT_curs, msglen) + sizeof(((atf_amc::MsgHdrLT_curs*)0)->msglen) == sizeof(atf_amc::MsgHdrLT_curs));
    algo_assert(_offset_of(atf_amc::MsgType, value) + sizeof(((atf_amc::MsgType*)0)->value) == sizeof(atf_amc::MsgType));
    algo_assert(_offset_of(atf_amc::MsgLength, value) + sizeof(((atf_amc::MsgLength*)0)->value) == sizeof(atf_amc::MsgLength));
    algo_assert(_offset_of(atf_amc::MsgHeader, length) == 2);
    algo_assert(_offset_of(atf_amc::MsgHeader_curs, msglen) + sizeof(((atf_amc::MsgHeader_curs*)0)->msglen) == sizeof(atf_amc::MsgHeader_curs));
    algo_assert(_offset_of(atf_amc::MsgLTA, a) + sizeof(((atf_amc::MsgLTA*)0)->a) == sizeof(atf_amc::MsgLTA));
    algo_assert(_offset_of(atf_amc::MsgLTB, b) + sizeof(((atf_amc::MsgLTB*)0)->b) == sizeof(atf_amc::MsgLTB));
    algo_assert(_offset_of(atf_amc::MsgsCase, value) + sizeof(((atf_amc::MsgsCase*)0)->value) == sizeof(atf_amc::MsgsCase));
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::NetBitfld1*)0)->value_be)*8 >= 12);
    algo_assert(_offset_of(atf_amc::OptAlloc_curs, msglen) + sizeof(((atf_amc::OptAlloc_curs*)0)->msglen) == sizeof(atf_amc::OptAlloc_curs));
    algo_assert(_offset_of(atf_amc::OptG_curs, msglen) + sizeof(((atf_amc::OptG_curs*)0)->msglen) == sizeof(atf_amc::OptG_curs));
    algo_assert(_offset_of(atf_amc::OptOptG_curs, msglen) + sizeof(((atf_amc::OptOptG_curs*)0)->msglen) == sizeof(atf_amc::OptOptG_curs));
    algo_assert(_offset_of(atf_amc::PmaskMultiple, value7) + sizeof(((atf_amc::PmaskMultiple*)0)->value7) == sizeof(atf_amc::PmaskMultiple));
    algo_assert(_offset_of(atf_amc::PmaskU128, value71) + sizeof(((atf_amc::PmaskU128*)0)->value71) == sizeof(atf_amc::PmaskU128));
    algo_assert(_offset_of(atf_amc::PmaskU32, value5) + sizeof(((atf_amc::PmaskU32*)0)->value5) == sizeof(atf_amc::PmaskU32));
    algo_assert(_offset_of(atf_amc::SsimfilesCase, value) + sizeof(((atf_amc::SsimfilesCase*)0)->value) == sizeof(atf_amc::SsimfilesCase));
    // check that bitfield fits width
    algo_assert(sizeof(((atf_amc::TypeBE64sf*)0)->value_be)*8 >= 64);
    algo_assert(_offset_of(atf_amc::VarlenAlloc_curs, msglen) + sizeof(((atf_amc::VarlenAlloc_curs*)0)->msglen) == sizeof(atf_amc::VarlenAlloc_curs));
    algo_assert(_offset_of(atf_amc::VarlenExtern_curs, msglen) + sizeof(((atf_amc::VarlenExtern_curs*)0)->msglen) == sizeof(atf_amc::VarlenExtern_curs));
    algo_assert(_offset_of(atf_amc::VarlenH_curs, msglen) + sizeof(((atf_amc::VarlenH_curs*)0)->msglen) == sizeof(atf_amc::VarlenH_curs));
    algo_assert(_offset_of(atf_amc::VarlenK_curs, msglen) + sizeof(((atf_amc::VarlenK_curs*)0)->msglen) == sizeof(atf_amc::VarlenK_curs));
}

// --- atf_amc.MsgHdrLTMsgs..Print
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool atf_amc::MsgHdrLTMsgs_Print(algo::cstring &str, atf_amc::MsgHdrLT &msg, u32 msg_len) {
    switch(msg.type) {
        case 'A': {
            if (sizeof(atf_amc::MsgLTA) > msg_len) { return false; }
            MsgLTA_Print((atf_amc::MsgLTA&)(msg), str);
            return true;
        }
        case 'B': {
            if (sizeof(atf_amc::MsgLTB) > msg_len) { return false; }
            MsgLTB_Print((atf_amc::MsgLTB&)(msg), str);
            return true;
        }
        case 'O': {
            if (sizeof(atf_amc::MsgLTO) > msg_len) { return false; }
            MsgLTO_Print((atf_amc::MsgLTO&)(msg), str);
            return true;
        }
        case 'V': {
            if (sizeof(atf_amc::MsgLTV) > msg_len) { return false; }
            MsgLTV_Print((atf_amc::MsgLTV&)(msg), str);
            return true;
        }
        default:

        return false;
    }
}

// --- atf_amc.MsgHeaderMsgs..Print
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool atf_amc::MsgHeaderMsgs_Print(algo::cstring &str, atf_amc::MsgHeader &msg, u32 msg_len) {
    switch(msg.type) {
        case 0x0905: {
            if (sizeof(atf_amc::Seqmsg) > msg_len) { return false; }
            Seqmsg_Print((atf_amc::Seqmsg&)(msg), str);
            return true;
        }
        case 0x0412: {
            if (sizeof(atf_amc::Text) > msg_len) { return false; }
            Text_Print((atf_amc::Text&)(msg), str);
            return true;
        }
        case 0x1000: {
            if (sizeof(atf_amc::VarlenMsg) > msg_len) { return false; }
            VarlenMsg_Print((atf_amc::VarlenMsg&)(msg), str);
            return true;
        }
        default:

        return false;
    }
}

// --- atf_amc.Msgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::MsgsCase atf_amc::Msgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    atf_amc::MsgsCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case atf_amc_MsgsCase_atf_amc_VarlenK: {
            int len = sizeof(atf_amc::VarlenK);
            atf_amc::VarlenK *ctype = new(ary_AllocN(buf, len).elems) atf_amc::VarlenK; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = VarlenK_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::VarlenK case

        default: break;
    }
    return ok ? msgtype : atf_amc::MsgsCase();
}

// --- atf_amc.Msgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool atf_amc::Msgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    atf_amc::MsgsCase msgtype = Msgs_ReadStrptr(str,buf);
    return !(msgtype == atf_amc::MsgsCase());
}

// --- atf_amc.Ssimfiles..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::SsimfilesCase atf_amc::Ssimfiles_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    atf_amc::SsimfilesCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case atf_amc_SsimfilesCase_dmmeta_Ctype: {
            int len = sizeof(dmmeta::Ctype);
            dmmeta::Ctype *ctype = new(ary_AllocN(buf, len).elems) dmmeta::Ctype; // default values
            ok = Ctype_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // dmmeta::Ctype case

        default: break;
    }
    return ok ? msgtype : atf_amc::SsimfilesCase();
}

// --- atf_amc.Ssimfiles..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool atf_amc::Ssimfiles_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    atf_amc::SsimfilesCase msgtype = Ssimfiles_ReadStrptr(str,buf);
    return !(msgtype == atf_amc::SsimfilesCase());
}

// --- atf_amc.MsgHdrLTMsgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::MsgHdrLTMsgsCase atf_amc::MsgHdrLTMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    atf_amc::MsgHdrLTMsgsCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTA: {
            int len = sizeof(atf_amc::MsgLTA);
            atf_amc::MsgLTA *ctype = new(ary_AllocN(buf, len).elems) atf_amc::MsgLTA; // default values
            ok = MsgLTA_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // atf_amc::MsgLTA case

        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTB: {
            int len = sizeof(atf_amc::MsgLTB);
            atf_amc::MsgLTB *ctype = new(ary_AllocN(buf, len).elems) atf_amc::MsgLTB; // default values
            ok = MsgLTB_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // atf_amc::MsgLTB case

        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTO: {
            int len = sizeof(atf_amc::MsgLTO);
            atf_amc::MsgLTO *ctype = new(ary_AllocN(buf, len).elems) atf_amc::MsgLTO; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = MsgLTO_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->len = u8(len-2);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::MsgLTO case

        case atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTV: {
            int len = sizeof(atf_amc::MsgLTV);
            atf_amc::MsgLTV *ctype = new(ary_AllocN(buf, len).elems) atf_amc::MsgLTV; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = MsgLTV_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->len = u8(len-2);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::MsgLTV case

        default: break;
    }
    return ok ? msgtype : atf_amc::MsgHdrLTMsgsCase();
}

// --- atf_amc.MsgHdrLTMsgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool atf_amc::MsgHdrLTMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    atf_amc::MsgHdrLTMsgsCase msgtype = MsgHdrLTMsgs_ReadStrptr(str,buf);
    return !(msgtype == atf_amc::MsgHdrLTMsgsCase());
}

// --- atf_amc.MsgHeaderMsgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::MsgType atf_amc::MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    atf_amc::MsgType msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case atf_amc_MsgType_atf_amc_Seqmsg: {
            int len = sizeof(atf_amc::Seqmsg);
            atf_amc::Seqmsg *ctype = new(ary_AllocN(buf, len).elems) atf_amc::Seqmsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Seqmsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = atf_amc::MsgLength(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::Seqmsg case

        case atf_amc_MsgType_atf_amc_Text: {
            int len = sizeof(atf_amc::Text);
            atf_amc::Text *ctype = new(ary_AllocN(buf, len).elems) atf_amc::Text; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Text_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = atf_amc::MsgLength(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::Text case

        case atf_amc_MsgType_atf_amc_VarlenMsg: {
            int len = sizeof(atf_amc::VarlenMsg);
            atf_amc::VarlenMsg *ctype = new(ary_AllocN(buf, len).elems) atf_amc::VarlenMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = VarlenMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = atf_amc::MsgLength(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // atf_amc::VarlenMsg case

        default: break;
    }
    return ok ? msgtype : atf_amc::MsgType();
}

// --- atf_amc.MsgHeaderMsgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool atf_amc::MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    atf_amc::MsgType msgtype = MsgHeaderMsgs_ReadStrptr(str,buf);
    return !(msgtype == atf_amc::MsgType());
}

// --- atf_amc...MsgLTO_FmtByteAry
// Construct a new atf_amc::MsgLTO in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::MsgLTO * atf_amc::MsgLTO_FmtByteAry(algo::ByteAry &buf, atf_amc::MsgHdrLT* o) {
    atf_amc::MsgLTO  *msg = NULL;
    size_t len = sizeof(atf_amc::MsgLTO);
    int opt_len = o ? i32(o[0].len + 2) : 0;
    len += opt_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::MsgLTO*)ary_AllocN(buf,len).elems;
    msg->len = u8(len + (-2));
    msg->type = char('O');
    if (o) {
        memcpy((u8*)msg + sizeof(atf_amc::MsgLTO), o, opt_len);
    }
    return msg;
}

// --- atf_amc...MsgLTV_FmtByteAry
// Construct a new atf_amc::MsgLTV in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::MsgLTV * atf_amc::MsgLTV_FmtByteAry(algo::ByteAry &buf, algo::memptr v) {
    atf_amc::MsgLTV  *msg = NULL;
    size_t len = sizeof(atf_amc::MsgLTV);
    u32 ary_len = elems_N(v) * sizeof(u8);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::MsgLTV*)ary_AllocN(buf,len).elems;
    msg->len = u8(len + (-2));
    msg->type = char('V');
    memcpy(v_Addr(*msg), v.elems, ary_len);
    return msg;
}

// --- atf_amc...OptG_FmtByteAry
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::OptG * atf_amc::OptG_FmtByteAry(algo::ByteAry &buf, atf_amc::TypeG* typeg, int opt_len) {
    atf_amc::OptG  *msg = NULL;
    size_t len = sizeof(atf_amc::OptG);
    len += opt_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::OptG*)ary_AllocN(buf,len).elems;
    msg->length = u32(len + (0));
    if (typeg) {
        memcpy((u8*)msg + sizeof(atf_amc::OptG), typeg, opt_len);
    }
    return msg;
}

// --- atf_amc...OptG_FmtMemptr
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::OptG * atf_amc::OptG_FmtMemptr(algo::memptr &buf, atf_amc::TypeG* typeg, int opt_len) {
    atf_amc::OptG  *msg = NULL;
    size_t len = sizeof(atf_amc::OptG);
    len += opt_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (atf_amc::OptG*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->length = u32(len + (0));
    if (typeg) {
        memcpy((u8*)msg + sizeof(atf_amc::OptG), typeg, opt_len);
    }
    return msg;
}

// --- atf_amc...OptOptG_FmtByteAry
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::OptOptG * atf_amc::OptOptG_FmtByteAry(algo::ByteAry &buf, atf_amc::OptG* optg) {
    atf_amc::OptOptG  *msg = NULL;
    size_t len = sizeof(atf_amc::OptOptG);
    int opt_len = optg ? i32(optg[0].length) : 0;
    len += opt_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::OptOptG*)ary_AllocN(buf,len).elems;
    msg->length = u32(len + (0));
    if (optg) {
        memcpy((u8*)msg + sizeof(atf_amc::OptOptG), optg, opt_len);
    }
    return msg;
}

// --- atf_amc...OptOptG_FmtMemptr
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::OptOptG * atf_amc::OptOptG_FmtMemptr(algo::memptr &buf, atf_amc::OptG* optg) {
    atf_amc::OptOptG  *msg = NULL;
    size_t len = sizeof(atf_amc::OptOptG);
    int opt_len = optg ? i32(optg[0].length) : 0;
    len += opt_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (atf_amc::OptOptG*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->length = u32(len + (0));
    if (optg) {
        memcpy((u8*)msg + sizeof(atf_amc::OptOptG), optg, opt_len);
    }
    return msg;
}

// --- atf_amc...Text_FmtByteAry
// Construct a new atf_amc::Text in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::Text * atf_amc::Text_FmtByteAry(algo::ByteAry &buf, algo::aryptr<char > text) {
    atf_amc::Text  *msg = NULL;
    size_t len = sizeof(atf_amc::Text);
    u32 ary_len = elems_N(text) * sizeof(char);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::Text*)ary_AllocN(buf,len).elems;
    msg->type = atf_amc::MsgType(0x0412);
    msg->length = atf_amc::MsgLength(len + (0));
    memcpy(text_Addr(*msg), text.elems, ary_len);
    return msg;
}

// --- atf_amc...VarlenK_FmtByteAry
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::VarlenK * atf_amc::VarlenK_FmtByteAry(algo::ByteAry &buf, algo::aryptr<u32 > i) {
    atf_amc::VarlenK  *msg = NULL;
    size_t len = sizeof(atf_amc::VarlenK);
    u32 ary_len = elems_N(i) * sizeof(u32);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (atf_amc::VarlenK*)ary_AllocN(buf,len).elems;
    msg->length = u32(len + (0));
    memcpy(i_Addr(*msg), i.elems, ary_len);
    return msg;
}

// --- atf_amc...VarlenK_FmtMemptr
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::VarlenK * atf_amc::VarlenK_FmtMemptr(algo::memptr &buf, algo::aryptr<u32 > i) {
    atf_amc::VarlenK  *msg = NULL;
    size_t len = sizeof(atf_amc::VarlenK);
    u32 ary_len = elems_N(i) * sizeof(u32);
    len += ary_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (atf_amc::VarlenK*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->length = u32(len + (0));
    memcpy(i_Addr(*msg), i.elems, ary_len);
    return msg;
}

// --- atf_amc...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        lib_exec::FDb_Init();
        atf_amc::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        atf_amc::ReadArgv(); // dmmeta.main:atf_amc
        atf_amc::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("atf_amc.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        atf_amc::FDb_Uninit();
        lib_exec::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- atf_amc...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
