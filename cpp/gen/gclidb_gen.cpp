//
// cpp/gen/gclidb_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/gclidb_gen.h"
#include "include/gen/gclidb_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
// compile-time string constants for gclidb.Gact.gact
const char *gclidb_Gact_gact_accept       = "accept";
const char *gclidb_Gact_gact_approve      = "approve";
const char *gclidb_Gact_gact_create       = "create";
const char *gclidb_Gact_gact_list         = "list";
const char *gclidb_Gact_gact_needs_work   = "needs_work";
const char *gclidb_Gact_gact_start        = "start";
const char *gclidb_Gact_gact_stop         = "stop";
const char *gclidb_Gact_gact_update       = "update";

// compile-time string constants for gclidb.Gclicmd.gclicmd
const char *gclidb_Gclicmd_gclicmd_graphql   = "graphql";

const char *gclidb_Gclicmd_gclicmd_issueadd      = "issueadd";
const char *gclidb_Gclicmd_gclicmd_issuelist     = "issuelist";
const char *gclidb_Gclicmd_gclicmd_issuemod      = "issuemod";
const char *gclidb_Gclicmd_gclicmd_issuenote     = "issuenote";
const char *gclidb_Gclicmd_gclicmd_issuesearch   = "issuesearch";
const char *gclidb_Gclicmd_gclicmd_mraccept      = "mraccept";

const char *gclidb_Gclicmd_gclicmd_mrlist       = "mrlist";
const char *gclidb_Gclicmd_gclicmd_mrlistdet    = "mrlistdet";
const char *gclidb_Gclicmd_gclicmd_mrmod        = "mrmod";
const char *gclidb_Gclicmd_gclicmd_mrnote       = "mrnote";
const char *gclidb_Gclicmd_gclicmd_mrnoteadd    = "mrnoteadd";
const char *gclidb_Gclicmd_gclicmd_mrnotemod    = "mrnotemod";
const char *gclidb_Gclicmd_gclicmd_mrreq        = "mrreq";
const char *gclidb_Gclicmd_gclicmd_mrreview     = "mrreview";
const char *gclidb_Gclicmd_gclicmd_mrreviewrm   = "mrreviewrm";
const char *gclidb_Gclicmd_gclicmd_mrsearch     = "mrsearch";
const char *gclidb_Gclicmd_gclicmd_mslist       = "mslist";
const char *gclidb_Gclicmd_gclicmd_noteadd      = "noteadd";

const char *gclidb_Gclicmd_gclicmd_notemod        = "notemod";
const char *gclidb_Gclicmd_gclicmd_repojob        = "repojob";
const char *gclidb_Gclicmd_gclicmd_repojobtrace   = "repojobtrace";
const char *gclidb_Gclicmd_gclicmd_token2repos    = "token2repos";
const char *gclidb_Gclicmd_gclicmd_user           = "user";
const char *gclidb_Gclicmd_gclicmd_userdet        = "userdet";
const char *gclidb_Gclicmd_gclicmd_userlist       = "userlist";

// compile-time string constants for gclidb.Gclienv.gclienv
const char *gclidb_Gclienv_gclienv_all    = "all";
const char *gclidb_Gclienv_gclienv_ghub   = "ghub";
const char *gclidb_Gclienv_gclienv_glab   = "glab";

// compile-time string constants for gclidb.Gclisub.gclisub
const char *gclidb_Gclisub_gclisub__GITDIR    = "$GITDIR";
const char *gclidb_Gclisub_gclisub__HOST      = "$HOST";
const char *gclidb_Gclisub_gclisub__ID_RSA    = "$ID_RSA";
const char *gclidb_Gclisub_gclisub__IN_AUTH   = "$IN_AUTH";
const char *gclidb_Gclisub_gclisub__ISSUE     = "$ISSUE";
const char *gclidb_Gclisub_gclisub__ISSUE_    = "$ISSUE#";
const char *gclidb_Gclisub_gclisub__MNOTE     = "$MNOTE";

const char *gclidb_Gclisub_gclisub__MR     = "$MR";
const char *gclidb_Gclisub_gclisub__MR_    = "$MR_";
const char *gclidb_Gclisub_gclisub__NOTE   = "$NOTE";

const char *gclidb_Gclisub_gclisub__REPO    = "$REPO";
const char *gclidb_Gclisub_gclisub__TOKEN   = "$TOKEN";
const char *gclidb_Gclisub_gclisub__USER    = "$USER";

// compile-time string constants for gclidb.Gfld.gfld
const char *gclidb_Gfld_gfld_action         = "action";
const char *gclidb_Gfld_gfld_assignee       = "assignee";
const char *gclidb_Gfld_gfld_author         = "author";
const char *gclidb_Gfld_gfld_default_repo   = "default_repo";
const char *gclidb_Gfld_gfld_description    = "description";
const char *gclidb_Gfld_gfld_host           = "host";
const char *gclidb_Gfld_gfld_labels         = "labels";
const char *gclidb_Gfld_gfld_milestone      = "milestone";
const char *gclidb_Gfld_gfld_name           = "name";
const char *gclidb_Gfld_gfld_note           = "note";

const char *gclidb_Gfld_gfld_repo       = "repo";
const char *gclidb_Gfld_gfld_reviewer   = "reviewer";
const char *gclidb_Gfld_gfld_state      = "state";
const char *gclidb_Gfld_gfld_title      = "title";
const char *gclidb_Gfld_gfld_token      = "token";
const char *gclidb_Gfld_gfld_user       = "user";

// compile-time string constants for gclidb.Gstate.gstate
const char *gclidb_Gstate_gstate_state_all          = "state_all";
const char *gclidb_Gstate_gstate_state_close        = "state_close";
const char *gclidb_Gstate_gstate_state_closed       = "state_closed";
const char *gclidb_Gstate_gstate_state_open         = "state_open";
const char *gclidb_Gstate_gstate_state_opened       = "state_opened";
const char *gclidb_Gstate_gstate_state_set_close    = "state_set_close";
const char *gclidb_Gstate_gstate_state_set_closed   = "state_set_closed";
const char *gclidb_Gstate_gstate_state_set_open     = "state_set_open";
const char *gclidb_Gstate_gstate_state_set_opened   = "state_set_opened";

// compile-time string constants for gclidb.Gtbl.gtbl
const char *gclidb_Gtbl_gtbl_gitconfig   = "gitconfig";

const char *gclidb_Gtbl_gtbl_help        = "help";
const char *gclidb_Gtbl_gtbl_issue       = "issue";
const char *gclidb_Gtbl_gtbl_issuenote   = "issuenote";
const char *gclidb_Gtbl_gtbl_milestone   = "milestone";
const char *gclidb_Gtbl_gtbl_mr          = "mr";
const char *gclidb_Gtbl_gtbl_mrjob       = "mrjob";

const char *gclidb_Gtbl_gtbl_mrnote       = "mrnote";
const char *gclidb_Gtbl_gtbl_repo         = "repo";
const char *gclidb_Gtbl_gtbl_reporemote   = "reporemote";
const char *gclidb_Gtbl_gtbl_user         = "user";

// compile-time string constants for gclidb.Gtblact.gtblact
const char *gclidb_Gtblact_gtblact_help_list          = "help_list";
const char *gclidb_Gtblact_gtblact_repo_create        = "repo_create";
const char *gclidb_Gtblact_gtblact_gitconfig_create   = "gitconfig_create";
const char *gclidb_Gtblact_gtblact_gitconfig_list     = "gitconfig_list";
const char *gclidb_Gtblact_gtblact_repo_update        = "repo_update";

const char *gclidb_Gtblact_gtblact_reporemote_list   = "reporemote_list";

const char *gclidb_Gtblact_gtblact_repo_list      = "repo_list";
const char *gclidb_Gtblact_gtblact_issue_create   = "issue_create";

const char *gclidb_Gtblact_gtblact_issue_update       = "issue_update";
const char *gclidb_Gtblact_gtblact_issue_start        = "issue_start";
const char *gclidb_Gtblact_gtblact_issue_list         = "issue_list";
const char *gclidb_Gtblact_gtblact_mrnote_create      = "mrnote_create";
const char *gclidb_Gtblact_gtblact_issuenote_create   = "issuenote_create";
const char *gclidb_Gtblact_gtblact_issuenote_list     = "issuenote_list";
const char *gclidb_Gtblact_gtblact_issuenote_update   = "issuenote_update";
const char *gclidb_Gtblact_gtblact_mrnote_update      = "mrnote_update";
const char *gclidb_Gtblact_gtblact_mrnote_list        = "mrnote_list";

const char *gclidb_Gtblact_gtblact_mr_list            = "mr_list";
const char *gclidb_Gtblact_gtblact_milestone_list     = "milestone_list";
const char *gclidb_Gtblact_gtblact_user_list          = "user_list";
const char *gclidb_Gtblact_gtblact_mr_create          = "mr_create";
const char *gclidb_Gtblact_gtblact_mr_start           = "mr_start";
const char *gclidb_Gtblact_gtblact_mr_approve         = "mr_approve";
const char *gclidb_Gtblact_gtblact_mr_accept          = "mr_accept";
const char *gclidb_Gtblact_gtblact_mr_update          = "mr_update";
const char *gclidb_Gtblact_gtblact_mr_needs_work      = "mr_needs_work";
const char *gclidb_Gtblact_gtblact_mr_stop            = "mr_stop";
const char *gclidb_Gtblact_gtblact_mrjob_list         = "mrjob_list";
const char *gclidb_Gtblact_gtblact_issue_needs_work   = "issue_needs_work";
const char *gclidb_Gtblact_gtblact_issue_stop         = "issue_stop";

// compile-time string constants for gclidb.Gtype.gtype
const char *gclidb_Gtype_gtype_ghp     = "ghp";
const char *gclidb_Gtype_gtype_glpat   = "glpat";

// compile-time string constants for gclidb.Label.label
const char *gclidb_Label_label_bug                = "bug";
const char *gclidb_Label_label_documentation      = "documentation";
const char *gclidb_Label_label_done               = "done";
const char *gclidb_Label_label_duplicate          = "duplicate";
const char *gclidb_Label_label_enhancement        = "enhancement";
const char *gclidb_Label_label_good_first_issue   = "good_first_issue";
const char *gclidb_Label_label_help_wanted        = "help_wanted";
const char *gclidb_Label_label_high_priority      = "high_priority";
const char *gclidb_Label_label_in_progress        = "in_progress";
const char *gclidb_Label_label_invalid            = "invalid";
const char *gclidb_Label_label_low_priority       = "low_priority";
const char *gclidb_Label_label_medium_priority    = "medium_priority";
const char *gclidb_Label_label_question           = "question";

const char *gclidb_Label_label_wontfix   = "wontfix";

namespace gclidb { // gen:ns_print_proto
    // func:gclidb...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- gclidb.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gclidb::value_ToCstr(const gclidb::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case gclidb_FieldId_gact           : ret = "gact";  break;
        case gclidb_FieldId_comment        : ret = "comment";  break;
        case gclidb_FieldId_gatv           : ret = "gatv";  break;
        case gclidb_FieldId_gclicmd        : ret = "gclicmd";  break;
        case gclidb_FieldId_gclicmdf2j     : ret = "gclicmdf2j";  break;
        case gclidb_FieldId_gclicmdf       : ret = "gclicmdf";  break;
        case gclidb_FieldId_field          : ret = "field";  break;
        case gclidb_FieldId_jkey           : ret = "jkey";  break;
        case gclidb_FieldId_dup            : ret = "dup";  break;
        case gclidb_FieldId_gclicmdt       : ret = "gclicmdt";  break;
        case gclidb_FieldId_gmethod        : ret = "gmethod";  break;
        case gclidb_FieldId_gtype          : ret = "gtype";  break;
        case gclidb_FieldId_uri            : ret = "uri";  break;
        case gclidb_FieldId_gclienv        : ret = "gclienv";  break;
        case gclidb_FieldId_addon          : ret = "addon";  break;
        case gclidb_FieldId_gclienvsub     : ret = "gclienvsub";  break;
        case gclidb_FieldId_sub            : ret = "sub";  break;
        case gclidb_FieldId_fwd            : ret = "fwd";  break;
        case gclidb_FieldId_rev            : ret = "rev";  break;
        case gclidb_FieldId_uval           : ret = "uval";  break;
        case gclidb_FieldId_gclisub        : ret = "gclisub";  break;
        case gclidb_FieldId_gfld           : ret = "gfld";  break;
        case gclidb_FieldId_val            : ret = "val";  break;
        case gclidb_FieldId_grepo          : ret = "grepo";  break;
        case gclidb_FieldId_host           : ret = "host";  break;
        case gclidb_FieldId_fname          : ret = "fname";  break;
        case gclidb_FieldId_name           : ret = "name";  break;
        case gclidb_FieldId_token          : ret = "token";  break;
        case gclidb_FieldId_default_branch : ret = "default_branch";  break;
        case gclidb_FieldId_keyid          : ret = "keyid";  break;
        case gclidb_FieldId_ssh_repo       : ret = "ssh_repo";  break;
        case gclidb_FieldId_web_url        : ret = "web_url";  break;
        case gclidb_FieldId_descr          : ret = "descr";  break;
        case gclidb_FieldId_active         : ret = "active";  break;
        case gclidb_FieldId_priv           : ret = "priv";  break;
        case gclidb_FieldId_gstate         : ret = "gstate";  break;
        case gclidb_FieldId_st             : ret = "st";  break;
        case gclidb_FieldId_state          : ret = "state";  break;
        case gclidb_FieldId_gstatet        : ret = "gstatet";  break;
        case gclidb_FieldId_gtbl           : ret = "gtbl";  break;
        case gclidb_FieldId_gtblact        : ret = "gtblact";  break;
        case gclidb_FieldId_t              : ret = "t";  break;
        case gclidb_FieldId_e              : ret = "e";  break;
        case gclidb_FieldId_auth           : ret = "auth";  break;
        case gclidb_FieldId_gtblactfld     : ret = "gtblactfld";  break;
        case gclidb_FieldId_dflt           : ret = "dflt";  break;
        case gclidb_FieldId_field_name_dflt: ret = "field_name_dflt";  break;
        case gclidb_FieldId_optional       : ret = "optional";  break;
        case gclidb_FieldId_regx           : ret = "regx";  break;
        case gclidb_FieldId_gtblacttst     : ret = "gtblacttst";  break;
        case gclidb_FieldId_working        : ret = "working";  break;
        case gclidb_FieldId_cmd            : ret = "cmd";  break;
        case gclidb_FieldId_gtblacttstout  : ret = "gtblacttstout";  break;
        case gclidb_FieldId_out            : ret = "out";  break;
        case gclidb_FieldId_text           : ret = "text";  break;
        case gclidb_FieldId_default_url    : ret = "default_url";  break;
        case gclidb_FieldId_gtypeh         : ret = "gtypeh";  break;
        case gclidb_FieldId_header         : ret = "header";  break;
        case gclidb_FieldId_gtypeprefix    : ret = "gtypeprefix";  break;
        case gclidb_FieldId_prefix         : ret = "prefix";  break;
        case gclidb_FieldId_issue          : ret = "issue";  break;
        case gclidb_FieldId_project        : ret = "project";  break;
        case gclidb_FieldId_iid            : ret = "iid";  break;
        case gclidb_FieldId_assignee       : ret = "assignee";  break;
        case gclidb_FieldId_labels         : ret = "labels";  break;
        case gclidb_FieldId_milestone_iid  : ret = "milestone_iid";  break;
        case gclidb_FieldId_milestone_num  : ret = "milestone_num";  break;
        case gclidb_FieldId_milestone      : ret = "milestone";  break;
        case gclidb_FieldId_title          : ret = "title";  break;
        case gclidb_FieldId_author         : ret = "author";  break;
        case gclidb_FieldId_mr             : ret = "mr";  break;
        case gclidb_FieldId_description    : ret = "description";  break;
        case gclidb_FieldId_issuenote      : ret = "issuenote";  break;
        case gclidb_FieldId_nid            : ret = "nid";  break;
        case gclidb_FieldId_note           : ret = "note";  break;
        case gclidb_FieldId_system         : ret = "system";  break;
        case gclidb_FieldId_issuepipeline  : ret = "issuepipeline";  break;
        case gclidb_FieldId_id             : ret = "id";  break;
        case gclidb_FieldId_id_in          : ret = "id_in";  break;
        case gclidb_FieldId_status         : ret = "status";  break;
        case gclidb_FieldId_label          : ret = "label";  break;
        case gclidb_FieldId_proj           : ret = "proj";  break;
        case gclidb_FieldId_source_branch  : ret = "source_branch";  break;
        case gclidb_FieldId_source_repo    : ret = "source_repo";  break;
        case gclidb_FieldId_reviewer       : ret = "reviewer";  break;
        case gclidb_FieldId_pipeline_status: ret = "pipeline_status";  break;
        case gclidb_FieldId_pipeline_id    : ret = "pipeline_id";  break;
        case gclidb_FieldId_draft          : ret = "draft";  break;
        case gclidb_FieldId_node_id        : ret = "node_id";  break;
        case gclidb_FieldId_mrjob          : ret = "mrjob";  break;
        case gclidb_FieldId_job            : ret = "job";  break;
        case gclidb_FieldId_ref            : ret = "ref";  break;
        case gclidb_FieldId_runner         : ret = "runner";  break;
        case gclidb_FieldId_mrnote         : ret = "mrnote";  break;
        case gclidb_FieldId_user           : ret = "user";  break;
        case gclidb_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- gclidb.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void gclidb::value_Print(const gclidb::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- gclidb.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gclidb::value_SetStrptrMaybe(gclidb::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'e': {
                    value_SetEnum(parent,gclidb_FieldId_e); ret = true; break;
                }
                case 't': {
                    value_SetEnum(parent,gclidb_FieldId_t); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('i','d'): {
                    value_SetEnum(parent,gclidb_FieldId_id); ret = true; break;
                }
                case LE_STR2('m','r'): {
                    value_SetEnum(parent,gclidb_FieldId_mr); ret = true; break;
                }
                case LE_STR2('s','t'): {
                    value_SetEnum(parent,gclidb_FieldId_st); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','m','d'): {
                    value_SetEnum(parent,gclidb_FieldId_cmd); ret = true; break;
                }
                case LE_STR3('d','u','p'): {
                    value_SetEnum(parent,gclidb_FieldId_dup); ret = true; break;
                }
                case LE_STR3('f','w','d'): {
                    value_SetEnum(parent,gclidb_FieldId_fwd); ret = true; break;
                }
                case LE_STR3('i','i','d'): {
                    value_SetEnum(parent,gclidb_FieldId_iid); ret = true; break;
                }
                case LE_STR3('j','o','b'): {
                    value_SetEnum(parent,gclidb_FieldId_job); ret = true; break;
                }
                case LE_STR3('n','i','d'): {
                    value_SetEnum(parent,gclidb_FieldId_nid); ret = true; break;
                }
                case LE_STR3('o','u','t'): {
                    value_SetEnum(parent,gclidb_FieldId_out); ret = true; break;
                }
                case LE_STR3('r','e','f'): {
                    value_SetEnum(parent,gclidb_FieldId_ref); ret = true; break;
                }
                case LE_STR3('r','e','v'): {
                    value_SetEnum(parent,gclidb_FieldId_rev); ret = true; break;
                }
                case LE_STR3('s','u','b'): {
                    value_SetEnum(parent,gclidb_FieldId_sub); ret = true; break;
                }
                case LE_STR3('u','r','i'): {
                    value_SetEnum(parent,gclidb_FieldId_uri); ret = true; break;
                }
                case LE_STR3('v','a','l'): {
                    value_SetEnum(parent,gclidb_FieldId_val); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','u','t','h'): {
                    value_SetEnum(parent,gclidb_FieldId_auth); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,gclidb_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('g','a','c','t'): {
                    value_SetEnum(parent,gclidb_FieldId_gact); ret = true; break;
                }
                case LE_STR4('g','a','t','v'): {
                    value_SetEnum(parent,gclidb_FieldId_gatv); ret = true; break;
                }
                case LE_STR4('g','f','l','d'): {
                    value_SetEnum(parent,gclidb_FieldId_gfld); ret = true; break;
                }
                case LE_STR4('g','t','b','l'): {
                    value_SetEnum(parent,gclidb_FieldId_gtbl); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,gclidb_FieldId_host); ret = true; break;
                }
                case LE_STR4('j','k','e','y'): {
                    value_SetEnum(parent,gclidb_FieldId_jkey); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,gclidb_FieldId_name); ret = true; break;
                }
                case LE_STR4('n','o','t','e'): {
                    value_SetEnum(parent,gclidb_FieldId_note); ret = true; break;
                }
                case LE_STR4('p','r','i','v'): {
                    value_SetEnum(parent,gclidb_FieldId_priv); ret = true; break;
                }
                case LE_STR4('p','r','o','j'): {
                    value_SetEnum(parent,gclidb_FieldId_proj); ret = true; break;
                }
                case LE_STR4('r','e','g','x'): {
                    value_SetEnum(parent,gclidb_FieldId_regx); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,gclidb_FieldId_text); ret = true; break;
                }
                case LE_STR4('u','s','e','r'): {
                    value_SetEnum(parent,gclidb_FieldId_user); ret = true; break;
                }
                case LE_STR4('u','v','a','l'): {
                    value_SetEnum(parent,gclidb_FieldId_uval); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','d','d','o','n'): {
                    value_SetEnum(parent,gclidb_FieldId_addon); ret = true; break;
                }
                case LE_STR5('d','e','s','c','r'): {
                    value_SetEnum(parent,gclidb_FieldId_descr); ret = true; break;
                }
                case LE_STR5('d','r','a','f','t'): {
                    value_SetEnum(parent,gclidb_FieldId_draft); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,gclidb_FieldId_field); ret = true; break;
                }
                case LE_STR5('f','n','a','m','e'): {
                    value_SetEnum(parent,gclidb_FieldId_fname); ret = true; break;
                }
                case LE_STR5('g','r','e','p','o'): {
                    value_SetEnum(parent,gclidb_FieldId_grepo); ret = true; break;
                }
                case LE_STR5('g','t','y','p','e'): {
                    value_SetEnum(parent,gclidb_FieldId_gtype); ret = true; break;
                }
                case LE_STR5('i','d','_','i','n'): {
                    value_SetEnum(parent,gclidb_FieldId_id_in); ret = true; break;
                }
                case LE_STR5('i','s','s','u','e'): {
                    value_SetEnum(parent,gclidb_FieldId_issue); ret = true; break;
                }
                case LE_STR5('k','e','y','i','d'): {
                    value_SetEnum(parent,gclidb_FieldId_keyid); ret = true; break;
                }
                case LE_STR5('l','a','b','e','l'): {
                    value_SetEnum(parent,gclidb_FieldId_label); ret = true; break;
                }
                case LE_STR5('m','r','j','o','b'): {
                    value_SetEnum(parent,gclidb_FieldId_mrjob); ret = true; break;
                }
                case LE_STR5('s','t','a','t','e'): {
                    value_SetEnum(parent,gclidb_FieldId_state); ret = true; break;
                }
                case LE_STR5('t','i','t','l','e'): {
                    value_SetEnum(parent,gclidb_FieldId_title); ret = true; break;
                }
                case LE_STR5('t','o','k','e','n'): {
                    value_SetEnum(parent,gclidb_FieldId_token); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,gclidb_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','c','t','i','v','e'): {
                    value_SetEnum(parent,gclidb_FieldId_active); ret = true; break;
                }
                case LE_STR6('a','u','t','h','o','r'): {
                    value_SetEnum(parent,gclidb_FieldId_author); ret = true; break;
                }
                case LE_STR6('g','s','t','a','t','e'): {
                    value_SetEnum(parent,gclidb_FieldId_gstate); ret = true; break;
                }
                case LE_STR6('g','t','y','p','e','h'): {
                    value_SetEnum(parent,gclidb_FieldId_gtypeh); ret = true; break;
                }
                case LE_STR6('h','e','a','d','e','r'): {
                    value_SetEnum(parent,gclidb_FieldId_header); ret = true; break;
                }
                case LE_STR6('l','a','b','e','l','s'): {
                    value_SetEnum(parent,gclidb_FieldId_labels); ret = true; break;
                }
                case LE_STR6('m','r','n','o','t','e'): {
                    value_SetEnum(parent,gclidb_FieldId_mrnote); ret = true; break;
                }
                case LE_STR6('p','r','e','f','i','x'): {
                    value_SetEnum(parent,gclidb_FieldId_prefix); ret = true; break;
                }
                case LE_STR6('r','u','n','n','e','r'): {
                    value_SetEnum(parent,gclidb_FieldId_runner); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,gclidb_FieldId_status); ret = true; break;
                }
                case LE_STR6('s','y','s','t','e','m'): {
                    value_SetEnum(parent,gclidb_FieldId_system); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,gclidb_FieldId_comment); ret = true; break;
                }
                case LE_STR7('g','c','l','i','c','m','d'): {
                    value_SetEnum(parent,gclidb_FieldId_gclicmd); ret = true; break;
                }
                case LE_STR7('g','c','l','i','e','n','v'): {
                    value_SetEnum(parent,gclidb_FieldId_gclienv); ret = true; break;
                }
                case LE_STR7('g','c','l','i','s','u','b'): {
                    value_SetEnum(parent,gclidb_FieldId_gclisub); ret = true; break;
                }
                case LE_STR7('g','m','e','t','h','o','d'): {
                    value_SetEnum(parent,gclidb_FieldId_gmethod); ret = true; break;
                }
                case LE_STR7('g','s','t','a','t','e','t'): {
                    value_SetEnum(parent,gclidb_FieldId_gstatet); ret = true; break;
                }
                case LE_STR7('g','t','b','l','a','c','t'): {
                    value_SetEnum(parent,gclidb_FieldId_gtblact); ret = true; break;
                }
                case LE_STR7('n','o','d','e','_','i','d'): {
                    value_SetEnum(parent,gclidb_FieldId_node_id); ret = true; break;
                }
                case LE_STR7('p','r','o','j','e','c','t'): {
                    value_SetEnum(parent,gclidb_FieldId_project); ret = true; break;
                }
                case LE_STR7('w','e','b','_','u','r','l'): {
                    value_SetEnum(parent,gclidb_FieldId_web_url); ret = true; break;
                }
                case LE_STR7('w','o','r','k','i','n','g'): {
                    value_SetEnum(parent,gclidb_FieldId_working); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','s','s','i','g','n','e','e'): {
                    value_SetEnum(parent,gclidb_FieldId_assignee); ret = true; break;
                }
                case LE_STR8('g','c','l','i','c','m','d','f'): {
                    value_SetEnum(parent,gclidb_FieldId_gclicmdf); ret = true; break;
                }
                case LE_STR8('g','c','l','i','c','m','d','t'): {
                    value_SetEnum(parent,gclidb_FieldId_gclicmdt); ret = true; break;
                }
                case LE_STR8('o','p','t','i','o','n','a','l'): {
                    value_SetEnum(parent,gclidb_FieldId_optional); ret = true; break;
                }
                case LE_STR8('r','e','v','i','e','w','e','r'): {
                    value_SetEnum(parent,gclidb_FieldId_reviewer); ret = true; break;
                }
                case LE_STR8('s','s','h','_','r','e','p','o'): {
                    value_SetEnum(parent,gclidb_FieldId_ssh_repo); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','s','s','u','e','n','o','t'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,gclidb_FieldId_issuenote); ret = true; break; }
                    break;
                }
                case LE_STR8('m','i','l','e','s','t','o','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,gclidb_FieldId_milestone); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','c','m','d','f'): {
                    if (memcmp(rhs.elems+8,"2j",2)==0) { value_SetEnum(parent,gclidb_FieldId_gclicmdf2j); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','e','n','v','s'): {
                    if (memcmp(rhs.elems+8,"ub",2)==0) { value_SetEnum(parent,gclidb_FieldId_gclienvsub); ret = true; break; }
                    break;
                }
                case LE_STR8('g','t','b','l','a','c','t','f'): {
                    if (memcmp(rhs.elems+8,"ld",2)==0) { value_SetEnum(parent,gclidb_FieldId_gtblactfld); ret = true; break; }
                    break;
                }
                case LE_STR8('g','t','b','l','a','c','t','t'): {
                    if (memcmp(rhs.elems+8,"st",2)==0) { value_SetEnum(parent,gclidb_FieldId_gtblacttst); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','f','a','u','l','t','_'): {
                    if (memcmp(rhs.elems+8,"url",3)==0) { value_SetEnum(parent,gclidb_FieldId_default_url); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','s','c','r','i','p','t'): {
                    if (memcmp(rhs.elems+8,"ion",3)==0) { value_SetEnum(parent,gclidb_FieldId_description); ret = true; break; }
                    break;
                }
                case LE_STR8('g','t','y','p','e','p','r','e'): {
                    if (memcmp(rhs.elems+8,"fix",3)==0) { value_SetEnum(parent,gclidb_FieldId_gtypeprefix); ret = true; break; }
                    break;
                }
                case LE_STR8('p','i','p','e','l','i','n','e'): {
                    if (memcmp(rhs.elems+8,"_id",3)==0) { value_SetEnum(parent,gclidb_FieldId_pipeline_id); ret = true; break; }
                    break;
                }
                case LE_STR8('s','o','u','r','c','e','_','r'): {
                    if (memcmp(rhs.elems+8,"epo",3)==0) { value_SetEnum(parent,gclidb_FieldId_source_repo); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','t','b','l','a','c','t','t'): {
                    if (memcmp(rhs.elems+8,"stout",5)==0) { value_SetEnum(parent,gclidb_FieldId_gtblacttstout); ret = true; break; }
                    break;
                }
                case LE_STR8('i','s','s','u','e','p','i','p'): {
                    if (memcmp(rhs.elems+8,"eline",5)==0) { value_SetEnum(parent,gclidb_FieldId_issuepipeline); ret = true; break; }
                    break;
                }
                case LE_STR8('m','i','l','e','s','t','o','n'): {
                    if (memcmp(rhs.elems+8,"e_iid",5)==0) { value_SetEnum(parent,gclidb_FieldId_milestone_iid); ret = true; break; }
                    if (memcmp(rhs.elems+8,"e_num",5)==0) { value_SetEnum(parent,gclidb_FieldId_milestone_num); ret = true; break; }
                    break;
                }
                case LE_STR8('s','o','u','r','c','e','_','b'): {
                    if (memcmp(rhs.elems+8,"ranch",5)==0) { value_SetEnum(parent,gclidb_FieldId_source_branch); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','f','a','u','l','t','_'): {
                    if (memcmp(rhs.elems+8,"branch",6)==0) { value_SetEnum(parent,gclidb_FieldId_default_branch); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','i','e','l','d','_','n','a'): {
                    if (memcmp(rhs.elems+8,"me_dflt",7)==0) { value_SetEnum(parent,gclidb_FieldId_field_name_dflt); ret = true; break; }
                    break;
                }
                case LE_STR8('p','i','p','e','l','i','n','e'): {
                    if (memcmp(rhs.elems+8,"_status",7)==0) { value_SetEnum(parent,gclidb_FieldId_pipeline_status); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gclidb.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gclidb::value_SetStrptr(gclidb::FieldId& parent, algo::strptr rhs, gclidb_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- gclidb.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool gclidb::value_ReadStrptrMaybe(gclidb::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- gclidb.FieldId..ReadStrptrMaybe
// Read fields of gclidb::FieldId from an ascii string.
// The format of the string is the format of the gclidb::FieldId's only field
bool gclidb::FieldId_ReadStrptrMaybe(gclidb::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- gclidb.FieldId..Print
// print string representation of ROW to string STR
// cfmt:gclidb.FieldId.String  printfmt:Raw
void gclidb::FieldId_Print(gclidb::FieldId& row, algo::cstring& str) {
    gclidb::value_Print(row, str);
}

// --- gclidb.Gact..ReadFieldMaybe
bool gclidb::Gact_ReadFieldMaybe(gclidb::Gact& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gact: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gact, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gact..ReadStrptrMaybe
// Read fields of gclidb::Gact from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gact_ReadStrptrMaybe(gclidb::Gact &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gact") || algo::StripTypeTag(in_str, "gclidb.Gact");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gact_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gact..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gact.String  printfmt:Tuple
void gclidb::Gact_Print(gclidb::Gact& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gact";

    algo::Smallstr50_Print(row.gact, temp);
    PrintAttrSpaceReset(str,"gact", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gatv..ReadFieldMaybe
bool gclidb::Gatv_ReadFieldMaybe(gclidb::Gatv& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gatv: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gatv, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gatv..ReadStrptrMaybe
// Read fields of gclidb::Gatv from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gatv_ReadStrptrMaybe(gclidb::Gatv &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gatv") || algo::StripTypeTag(in_str, "gclidb.Gatv");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gatv_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gatv..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gatv.String  printfmt:Tuple
void gclidb::Gatv_Print(gclidb::Gatv& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gatv";

    algo::Smallstr50_Print(row.gatv, temp);
    PrintAttrSpaceReset(str,"gatv", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gclicmd..ReadFieldMaybe
bool gclidb::Gclicmd_ReadFieldMaybe(gclidb::Gclicmd& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclicmd: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gclicmd, strval);
        } break;
        case gclidb_FieldId_gclicmdf2j: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gclicmdf2j, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclicmd..ReadStrptrMaybe
// Read fields of gclidb::Gclicmd from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclicmd_ReadStrptrMaybe(gclidb::Gclicmd &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclicmd") || algo::StripTypeTag(in_str, "gclidb.Gclicmd");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclicmd_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclicmd..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclicmd.String  printfmt:Tuple
void gclidb::Gclicmd_Print(gclidb::Gclicmd& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclicmd";

    algo::Smallstr250_Print(row.gclicmd, temp);
    PrintAttrSpaceReset(str,"gclicmd", temp);

    algo::Smallstr250_Print(row.gclicmdf2j, temp);
    PrintAttrSpaceReset(str,"gclicmdf2j", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gclicmdf2j.gclicmdf.Get
algo::cstring gclidb::gclicmdf_Get(gclidb::Gclicmdf2j& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gclicmdf2j, "@LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.gclicmdf.Get2
algo::cstring gclidb::Gclicmdf2j_gclicmdf_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.gclicmd.Get
algo::Smallstr250 gclidb::gclicmd_Get(gclidb::Gclicmdf2j& parent) {
    algo::Smallstr250 ret(algo::Pathcomp(parent.gclicmdf2j, "/LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.gclicmd.Get2
algo::Smallstr250 gclidb::Gclicmdf2j_gclicmd_Get(algo::strptr arg) {
    algo::Smallstr250 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.field.Get
algo::Smallstr100 gclidb::field_Get(gclidb::Gclicmdf2j& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.gclicmdf2j, "/LR@LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.field.Get2
algo::Smallstr100 gclidb::Gclicmdf2j_field_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR@LL"));
    return ret;
}

// --- gclidb.Gclicmdf2j.jkey.Get
algo::cstring gclidb::jkey_Get(gclidb::Gclicmdf2j& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gclicmdf2j, "/LR@LR"));
    return ret;
}

// --- gclidb.Gclicmdf2j.jkey.Get2
algo::cstring gclidb::Gclicmdf2j_jkey_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "/LR@LR"));
    return ret;
}

// --- gclidb.Gclicmdf2j..Concat_gclicmd_field_jkey
tempstr gclidb::Gclicmdf2j_Concat_gclicmd_field_jkey( const algo::strptr& gclicmd ,const algo::strptr& field ,const algo::strptr& jkey ) {
    return tempstr() << gclicmd <<'/'<< field <<'@'<< jkey ;
}

// --- gclidb.Gclicmdf2j..ReadFieldMaybe
bool gclidb::Gclicmdf2j_ReadFieldMaybe(gclidb::Gclicmdf2j& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclicmdf2j: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gclicmdf2j, strval);
        } break;
        case gclidb_FieldId_gclicmdf: {
            retval = false;
        } break;
        case gclidb_FieldId_gclicmd: {
            retval = false;
        } break;
        case gclidb_FieldId_field: {
            retval = false;
        } break;
        case gclidb_FieldId_jkey: {
            retval = false;
        } break;
        case gclidb_FieldId_dup: {
            retval = bool_ReadStrptrMaybe(parent.dup, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclicmdf2j..ReadStrptrMaybe
// Read fields of gclidb::Gclicmdf2j from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclicmdf2j_ReadStrptrMaybe(gclidb::Gclicmdf2j &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclicmdf2j") || algo::StripTypeTag(in_str, "gclidb.Gclicmdf2j");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclicmdf2j_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclicmdf2j..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclicmdf2j.String  printfmt:Tuple
void gclidb::Gclicmdf2j_Print(gclidb::Gclicmdf2j& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclicmdf2j";

    algo::Smallstr250_Print(row.gclicmdf2j, temp);
    PrintAttrSpaceReset(str,"gclicmdf2j", temp);

    bool_Print(row.dup, temp);
    PrintAttrSpaceReset(str,"dup", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gclicmdt.gclicmd.Get
algo::Smallstr250 gclidb::gclicmd_Get(gclidb::Gclicmdt& parent) {
    algo::Smallstr250 ret(algo::Pathcomp(parent.gclicmdt, ".RL"));
    return ret;
}

// --- gclidb.Gclicmdt.gclicmd.Get2
algo::Smallstr250 gclidb::Gclicmdt_gclicmd_Get(algo::strptr arg) {
    algo::Smallstr250 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gclicmdt.gtype.Get
algo::Smallstr50 gclidb::gtype_Get(gclidb::Gclicmdt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gclicmdt, ".RR"));
    return ret;
}

// --- gclidb.Gclicmdt.gtype.Get2
algo::Smallstr50 gclidb::Gclicmdt_gtype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gclicmdt..Concat_gclicmd_gtype
tempstr gclidb::Gclicmdt_Concat_gclicmd_gtype( const algo::strptr& gclicmd ,const algo::strptr& gtype ) {
    return tempstr() << gclicmd <<'.'<< gtype ;
}

// --- gclidb.Gclicmdt..ReadFieldMaybe
bool gclidb::Gclicmdt_ReadFieldMaybe(gclidb::Gclicmdt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclicmdt: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gclicmdt, strval);
        } break;
        case gclidb_FieldId_gmethod: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gmethod, strval);
        } break;
        case gclidb_FieldId_gclicmd: {
            retval = false;
        } break;
        case gclidb_FieldId_gtype: {
            retval = false;
        } break;
        case gclidb_FieldId_uri: {
            retval = algo::Comment_ReadStrptrMaybe(parent.uri, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclicmdt..ReadStrptrMaybe
// Read fields of gclidb::Gclicmdt from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclicmdt_ReadStrptrMaybe(gclidb::Gclicmdt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclicmdt") || algo::StripTypeTag(in_str, "gclidb.Gclicmdt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclicmdt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclicmdt..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclicmdt.String  printfmt:Tuple
void gclidb::Gclicmdt_Print(gclidb::Gclicmdt& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclicmdt";

    algo::Smallstr250_Print(row.gclicmdt, temp);
    PrintAttrSpaceReset(str,"gclicmdt", temp);

    algo::Smallstr50_Print(row.gmethod, temp);
    PrintAttrSpaceReset(str,"gmethod", temp);

    algo::Comment_Print(row.uri, temp);
    PrintAttrSpaceReset(str,"uri", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gclienv..ReadFieldMaybe
bool gclidb::Gclienv_ReadFieldMaybe(gclidb::Gclienv& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclienv: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gclienv, strval);
        } break;
        case gclidb_FieldId_addon: {
            retval = algo::cstring_ReadStrptrMaybe(parent.addon, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclienv..ReadStrptrMaybe
// Read fields of gclidb::Gclienv from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclienv_ReadStrptrMaybe(gclidb::Gclienv &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclienv") || algo::StripTypeTag(in_str, "gclidb.Gclienv");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclienv_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclienv..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclienv.String  printfmt:Tuple
void gclidb::Gclienv_Print(gclidb::Gclienv& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclienv";

    algo::Smallstr50_Print(row.gclienv, temp);
    PrintAttrSpaceReset(str,"gclienv", temp);

    algo::cstring_Print(row.addon, temp);
    PrintAttrSpaceReset(str,"addon", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gclienvsub.gclienv.Get
algo::Smallstr50 gclidb::gclienv_Get(gclidb::Gclienvsub& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gclienvsub, ".LL"));
    return ret;
}

// --- gclidb.Gclienvsub.gclienv.Get2
algo::Smallstr50 gclidb::Gclienvsub_gclienv_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- gclidb.Gclienvsub.sub.Get
algo::Smallstr50 gclidb::sub_Get(gclidb::Gclienvsub& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gclienvsub, ".LR"));
    return ret;
}

// --- gclidb.Gclienvsub.sub.Get2
algo::Smallstr50 gclidb::Gclienvsub_sub_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- gclidb.Gclienvsub..Concat_gclienv_sub
tempstr gclidb::Gclienvsub_Concat_gclienv_sub( const algo::strptr& gclienv ,const algo::strptr& sub ) {
    return tempstr() << gclienv <<'.'<< sub ;
}

// --- gclidb.Gclienvsub..ReadFieldMaybe
bool gclidb::Gclienvsub_ReadFieldMaybe(gclidb::Gclienvsub& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclienvsub: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gclienvsub, strval);
        } break;
        case gclidb_FieldId_gclienv: {
            retval = false;
        } break;
        case gclidb_FieldId_sub: {
            retval = false;
        } break;
        case gclidb_FieldId_fwd: {
            retval = bool_ReadStrptrMaybe(parent.fwd, strval);
        } break;
        case gclidb_FieldId_rev: {
            retval = bool_ReadStrptrMaybe(parent.rev, strval);
        } break;
        case gclidb_FieldId_uval: {
            retval = algo::cstring_ReadStrptrMaybe(parent.uval, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclienvsub..ReadStrptrMaybe
// Read fields of gclidb::Gclienvsub from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclienvsub_ReadStrptrMaybe(gclidb::Gclienvsub &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclienvsub") || algo::StripTypeTag(in_str, "gclidb.Gclienvsub");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclienvsub_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclienvsub..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclienvsub.String  printfmt:Tuple
void gclidb::Gclienvsub_Print(gclidb::Gclienvsub& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclienvsub";

    algo::Smallstr50_Print(row.gclienvsub, temp);
    PrintAttrSpaceReset(str,"gclienvsub", temp);

    bool_Print(row.fwd, temp);
    PrintAttrSpaceReset(str,"fwd", temp);

    bool_Print(row.rev, temp);
    PrintAttrSpaceReset(str,"rev", temp);

    algo::cstring_Print(row.uval, temp);
    PrintAttrSpaceReset(str,"uval", temp);
}

// --- gclidb.Gclisub..ReadFieldMaybe
bool gclidb::Gclisub_ReadFieldMaybe(gclidb::Gclisub& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gclisub: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gclisub, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gclisub..ReadStrptrMaybe
// Read fields of gclidb::Gclisub from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gclisub_ReadStrptrMaybe(gclidb::Gclisub &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gclisub") || algo::StripTypeTag(in_str, "gclidb.Gclisub");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gclisub_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gclisub..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gclisub.String  printfmt:Tuple
void gclidb::Gclisub_Print(gclidb::Gclisub& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gclisub";

    algo::Smallstr50_Print(row.gclisub, temp);
    PrintAttrSpaceReset(str,"gclisub", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gfld..ReadFieldMaybe
bool gclidb::Gfld_ReadFieldMaybe(gclidb::Gfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gfld: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gfld, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gfld..ReadStrptrMaybe
// Read fields of gclidb::Gfld from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gfld_ReadStrptrMaybe(gclidb::Gfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gfld") || algo::StripTypeTag(in_str, "gclidb.Gfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gfld..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gfld.String  printfmt:Tuple
void gclidb::Gfld_Print(gclidb::Gfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gfld";

    algo::Smallstr50_Print(row.gfld, temp);
    PrintAttrSpaceReset(str,"gfld", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Githost.git.Get
algo::cstring gclidb::git_Get(gclidb::Githost& parent) {
    algo::cstring ret(algo::Pathcomp(parent.githost, "@LL"));
    return ret;
}

// --- gclidb.Githost.git.Get2
algo::cstring gclidb::Githost_git_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LL"));
    return ret;
}

// --- gclidb.Githost.host.Get
algo::cstring gclidb::host_Get(gclidb::Githost& parent) {
    algo::cstring ret(algo::Pathcomp(parent.githost, "@LR:LL"));
    return ret;
}

// --- gclidb.Githost.host.Get2
algo::cstring gclidb::Githost_host_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LR:LL"));
    return ret;
}

// --- gclidb.Githost.gitrepo.Get
algo::cstring gclidb::gitrepo_Get(gclidb::Githost& parent) {
    algo::cstring ret(algo::Pathcomp(parent.githost, "@LR:LR"));
    return ret;
}

// --- gclidb.Githost.gitrepo.Get2
algo::cstring gclidb::Githost_gitrepo_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LR:LR"));
    return ret;
}

// --- gclidb.Githost..Concat_git_host_gitrepo
tempstr gclidb::Githost_Concat_git_host_gitrepo( const algo::strptr& git ,const algo::strptr& host ,const algo::strptr& gitrepo ) {
    return tempstr() << git <<'@'<< host <<':'<< gitrepo ;
}

// --- gclidb.Gmethod..ReadFieldMaybe
bool gclidb::Gmethod_ReadFieldMaybe(gclidb::Gmethod& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gmethod: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gmethod, strval);
        } break;
        case gclidb_FieldId_val: {
            retval = u32_ReadStrptrMaybe(parent.val, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gmethod..ReadStrptrMaybe
// Read fields of gclidb::Gmethod from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gmethod_ReadStrptrMaybe(gclidb::Gmethod &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gmethod") || algo::StripTypeTag(in_str, "gclidb.Gmethod");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gmethod_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gmethod..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gmethod.String  printfmt:Tuple
void gclidb::Gmethod_Print(gclidb::Gmethod& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gmethod";

    algo::Smallstr50_Print(row.gmethod, temp);
    PrintAttrSpaceReset(str,"gmethod", temp);

    u32_Print(row.val, temp);
    PrintAttrSpaceReset(str,"val", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Grepo.host.Get
algo::cstring gclidb::host_Get(gclidb::Grepo& parent) {
    algo::cstring ret(algo::Pathcomp(parent.grepo, "@LL"));
    return ret;
}

// --- gclidb.Grepo.host.Get2
algo::cstring gclidb::Grepo_host_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LL"));
    return ret;
}

// --- gclidb.Grepo.fname.Get
algo::cstring gclidb::fname_Get(gclidb::Grepo& parent) {
    algo::cstring ret(algo::Pathcomp(parent.grepo, "@LR"));
    return ret;
}

// --- gclidb.Grepo.fname.Get2
algo::cstring gclidb::Grepo_fname_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "@LR"));
    return ret;
}

// --- gclidb.Grepo..Concat_host_fname
tempstr gclidb::Grepo_Concat_host_fname( const algo::strptr& host ,const algo::strptr& fname ) {
    return tempstr() << host <<'@'<< fname ;
}

// --- gclidb.Grepo..ReadFieldMaybe
bool gclidb::Grepo_ReadFieldMaybe(gclidb::Grepo& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_grepo: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.grepo, strval);
        } break;
        case gclidb_FieldId_host: {
            retval = false;
        } break;
        case gclidb_FieldId_fname: {
            retval = false;
        } break;
        case gclidb_FieldId_name: {
            retval = algo::cstring_ReadStrptrMaybe(parent.name, strval);
        } break;
        case gclidb_FieldId_token: {
            retval = algo::cstring_ReadStrptrMaybe(parent.token, strval);
        } break;
        case gclidb_FieldId_default_branch: {
            retval = algo::cstring_ReadStrptrMaybe(parent.default_branch, strval);
        } break;
        case gclidb_FieldId_keyid: {
            retval = algo::cstring_ReadStrptrMaybe(parent.keyid, strval);
        } break;
        case gclidb_FieldId_ssh_repo: {
            retval = algo::cstring_ReadStrptrMaybe(parent.ssh_repo, strval);
        } break;
        case gclidb_FieldId_web_url: {
            retval = algo::cstring_ReadStrptrMaybe(parent.web_url, strval);
        } break;
        case gclidb_FieldId_descr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.descr, strval);
        } break;
        case gclidb_FieldId_active: {
            retval = bool_ReadStrptrMaybe(parent.active, strval);
        } break;
        case gclidb_FieldId_priv: {
            retval = algo::cstring_ReadStrptrMaybe(parent.priv, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Grepo..ReadStrptrMaybe
// Read fields of gclidb::Grepo from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Grepo_ReadStrptrMaybe(gclidb::Grepo &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.grepo") || algo::StripTypeTag(in_str, "gclidb.Grepo");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Grepo_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Grepo..Init
// Set all fields to initial values.
void gclidb::Grepo_Init(gclidb::Grepo& parent) {
    parent.default_branch = algo::strptr("origin");
    parent.active = bool(true);
}

// --- gclidb.Grepo..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Grepo.String  printfmt:Tuple
void gclidb::Grepo_Print(gclidb::Grepo& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.grepo";

    algo::Smallstr250_Print(row.grepo, temp);
    PrintAttrSpaceReset(str,"grepo", temp);

    algo::cstring_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);

    algo::cstring_Print(row.token, temp);
    PrintAttrSpaceReset(str,"token", temp);

    algo::cstring_Print(row.default_branch, temp);
    PrintAttrSpaceReset(str,"default_branch", temp);

    algo::cstring_Print(row.keyid, temp);
    PrintAttrSpaceReset(str,"keyid", temp);

    algo::cstring_Print(row.ssh_repo, temp);
    PrintAttrSpaceReset(str,"ssh_repo", temp);

    algo::cstring_Print(row.web_url, temp);
    PrintAttrSpaceReset(str,"web_url", temp);

    algo::cstring_Print(row.descr, temp);
    PrintAttrSpaceReset(str,"descr", temp);

    bool_Print(row.active, temp);
    PrintAttrSpaceReset(str,"active", temp);

    algo::cstring_Print(row.priv, temp);
    PrintAttrSpaceReset(str,"priv", temp);
}

// --- gclidb.Gstate.st.Get
algo::cstring gclidb::st_Get(gclidb::Gstate& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gstate, "_LL"));
    return ret;
}

// --- gclidb.Gstate.st.Get2
algo::cstring gclidb::Gstate_st_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "_LL"));
    return ret;
}

// --- gclidb.Gstate.state.Get
algo::cstring gclidb::state_Get(gclidb::Gstate& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gstate, "_LR"));
    return ret;
}

// --- gclidb.Gstate.state.Get2
algo::cstring gclidb::Gstate_state_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "_LR"));
    return ret;
}

// --- gclidb.Gstate..Concat_st_state
tempstr gclidb::Gstate_Concat_st_state( const algo::strptr& st ,const algo::strptr& state ) {
    return tempstr() << st <<'_'<< state ;
}

// --- gclidb.Gstate..ReadFieldMaybe
bool gclidb::Gstate_ReadFieldMaybe(gclidb::Gstate& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gstate: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gstate, strval);
        } break;
        case gclidb_FieldId_st: {
            retval = false;
        } break;
        case gclidb_FieldId_state: {
            retval = false;
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gstate..ReadStrptrMaybe
// Read fields of gclidb::Gstate from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gstate_ReadStrptrMaybe(gclidb::Gstate &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gstate") || algo::StripTypeTag(in_str, "gclidb.Gstate");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gstate_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gstate..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gstate.String  printfmt:Tuple
void gclidb::Gstate_Print(gclidb::Gstate& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gstate";

    algo::Smallstr50_Print(row.gstate, temp);
    PrintAttrSpaceReset(str,"gstate", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gstatet.gtype.Get
algo::Smallstr50 gclidb::gtype_Get(gclidb::Gstatet& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gstatet, ".RR"));
    return ret;
}

// --- gclidb.Gstatet.gtype.Get2
algo::Smallstr50 gclidb::Gstatet_gtype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gstatet.gstate.Get
algo::Smallstr50 gclidb::gstate_Get(gclidb::Gstatet& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gstatet, ".RL"));
    return ret;
}

// --- gclidb.Gstatet.gstate.Get2
algo::Smallstr50 gclidb::Gstatet_gstate_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gstatet..Concat_gstate_gtype
tempstr gclidb::Gstatet_Concat_gstate_gtype( const algo::strptr& gstate ,const algo::strptr& gtype ) {
    return tempstr() << gstate <<'.'<< gtype ;
}

// --- gclidb.Gstatet..ReadFieldMaybe
bool gclidb::Gstatet_ReadFieldMaybe(gclidb::Gstatet& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gstatet: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gstatet, strval);
        } break;
        case gclidb_FieldId_gtype: {
            retval = false;
        } break;
        case gclidb_FieldId_gstate: {
            retval = false;
        } break;
        case gclidb_FieldId_state: {
            retval = algo::cstring_ReadStrptrMaybe(parent.state, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gstatet..ReadStrptrMaybe
// Read fields of gclidb::Gstatet from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gstatet_ReadStrptrMaybe(gclidb::Gstatet &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gstatet") || algo::StripTypeTag(in_str, "gclidb.Gstatet");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gstatet_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gstatet..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gstatet.String  printfmt:Tuple
void gclidb::Gstatet_Print(gclidb::Gstatet& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gstatet";

    algo::Smallstr50_Print(row.gstatet, temp);
    PrintAttrSpaceReset(str,"gstatet", temp);

    algo::cstring_Print(row.state, temp);
    PrintAttrSpaceReset(str,"state", temp);
}

// --- gclidb.Gtbl..ReadFieldMaybe
bool gclidb::Gtbl_ReadFieldMaybe(gclidb::Gtbl& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtbl: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gtbl, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtbl..ReadStrptrMaybe
// Read fields of gclidb::Gtbl from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtbl_ReadStrptrMaybe(gclidb::Gtbl &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtbl") || algo::StripTypeTag(in_str, "gclidb.Gtbl");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtbl_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtbl..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtbl.String  printfmt:Tuple
void gclidb::Gtbl_Print(gclidb::Gtbl& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtbl";

    algo::Smallstr250_Print(row.gtbl, temp);
    PrintAttrSpaceReset(str,"gtbl", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gtblact.gtbl.Get
algo::Smallstr250 gclidb::gtbl_Get(gclidb::Gtblact& parent) {
    algo::Smallstr250 ret(algo::Pathcomp(parent.gtblact, "_LL"));
    return ret;
}

// --- gclidb.Gtblact.gtbl.Get2
algo::Smallstr250 gclidb::Gtblact_gtbl_Get(algo::strptr arg) {
    algo::Smallstr250 ret(algo::Pathcomp(arg, "_LL"));
    return ret;
}

// --- gclidb.Gtblact.gact.Get
algo::Smallstr50 gclidb::gact_Get(gclidb::Gtblact& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtblact, "_LR"));
    return ret;
}

// --- gclidb.Gtblact.gact.Get2
algo::Smallstr50 gclidb::Gtblact_gact_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "_LR"));
    return ret;
}

// --- gclidb.Gtblact..Concat_gtbl_gact
tempstr gclidb::Gtblact_Concat_gtbl_gact( const algo::strptr& gtbl ,const algo::strptr& gact ) {
    return tempstr() << gtbl <<'_'<< gact ;
}

// --- gclidb.Gtblact..ReadFieldMaybe
bool gclidb::Gtblact_ReadFieldMaybe(gclidb::Gtblact& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtblact: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gtblact, strval);
        } break;
        case gclidb_FieldId_gtbl: {
            retval = false;
        } break;
        case gclidb_FieldId_gact: {
            retval = false;
        } break;
        case gclidb_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
        } break;
        case gclidb_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
        } break;
        case gclidb_FieldId_auth: {
            retval = bool_ReadStrptrMaybe(parent.auth, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtblact..ReadStrptrMaybe
// Read fields of gclidb::Gtblact from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtblact_ReadStrptrMaybe(gclidb::Gtblact &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtblact") || algo::StripTypeTag(in_str, "gclidb.Gtblact");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtblact_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtblact..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtblact.String  printfmt:Tuple
void gclidb::Gtblact_Print(gclidb::Gtblact& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtblact";

    algo::Smallstr50_Print(row.gtblact, temp);
    PrintAttrSpaceReset(str,"gtblact", temp);

    bool_Print(row.t, temp);
    PrintAttrSpaceReset(str,"t", temp);

    bool_Print(row.e, temp);
    PrintAttrSpaceReset(str,"e", temp);

    bool_Print(row.auth, temp);
    PrintAttrSpaceReset(str,"auth", temp);
}

// --- gclidb.Gtblactfld.gtblact.Get
algo::Smallstr50 gclidb::gtblact_Get(gclidb::Gtblactfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtblactfld, ".RL"));
    return ret;
}

// --- gclidb.Gtblactfld.gtblact.Get2
algo::Smallstr50 gclidb::Gtblactfld_gtblact_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gtblactfld.field.Get
algo::Smallstr50 gclidb::field_Get(gclidb::Gtblactfld& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtblactfld, ".RR"));
    return ret;
}

// --- gclidb.Gtblactfld.field.Get2
algo::Smallstr50 gclidb::Gtblactfld_field_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gtblactfld..Concat_gtblact_field
tempstr gclidb::Gtblactfld_Concat_gtblact_field( const algo::strptr& gtblact ,const algo::strptr& field ) {
    return tempstr() << gtblact <<'.'<< field ;
}

// --- gclidb.Gtblactfld..ReadFieldMaybe
bool gclidb::Gtblactfld_ReadFieldMaybe(gclidb::Gtblactfld& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtblactfld: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gtblactfld, strval);
        } break;
        case gclidb_FieldId_gtblact: {
            retval = false;
        } break;
        case gclidb_FieldId_field: {
            retval = false;
        } break;
        case gclidb_FieldId_dflt: {
            retval = algo::cstring_ReadStrptrMaybe(parent.dflt, strval);
        } break;
        case gclidb_FieldId_field_name_dflt: {
            retval = bool_ReadStrptrMaybe(parent.field_name_dflt, strval);
        } break;
        case gclidb_FieldId_optional: {
            retval = bool_ReadStrptrMaybe(parent.optional, strval);
        } break;
        case gclidb_FieldId_regx: {
            retval = bool_ReadStrptrMaybe(parent.regx, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtblactfld..ReadStrptrMaybe
// Read fields of gclidb::Gtblactfld from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtblactfld_ReadStrptrMaybe(gclidb::Gtblactfld &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtblactfld") || algo::StripTypeTag(in_str, "gclidb.Gtblactfld");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtblactfld_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtblactfld..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtblactfld.String  printfmt:Tuple
void gclidb::Gtblactfld_Print(gclidb::Gtblactfld& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtblactfld";

    algo::Smallstr50_Print(row.gtblactfld, temp);
    PrintAttrSpaceReset(str,"gtblactfld", temp);

    algo::cstring_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    bool_Print(row.field_name_dflt, temp);
    PrintAttrSpaceReset(str,"field_name_dflt", temp);

    bool_Print(row.optional, temp);
    PrintAttrSpaceReset(str,"optional", temp);

    bool_Print(row.regx, temp);
    PrintAttrSpaceReset(str,"regx", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gtblacttst.gtblact.Get
algo::Smallstr50 gclidb::gtblact_Get(gclidb::Gtblacttst& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtblacttst, ".LL"));
    return ret;
}

// --- gclidb.Gtblacttst.gtblact.Get2
algo::Smallstr50 gclidb::Gtblacttst_gtblact_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- gclidb.Gtblacttst.gclienv.Get
algo::Smallstr50 gclidb::gclienv_Get(gclidb::Gtblacttst& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtblacttst, ".LR.LL"));
    return ret;
}

// --- gclidb.Gtblacttst.gclienv.Get2
algo::Smallstr50 gclidb::Gtblacttst_gclienv_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR.LL"));
    return ret;
}

// --- gclidb.Gtblacttst.t.Get
algo::cstring gclidb::t_Get(gclidb::Gtblacttst& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gtblacttst, ".RR"));
    return ret;
}

// --- gclidb.Gtblacttst.t.Get2
algo::cstring gclidb::Gtblacttst_t_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gtblacttst..ReadFieldMaybe
bool gclidb::Gtblacttst_ReadFieldMaybe(gclidb::Gtblacttst& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtblacttst: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gtblacttst, strval);
        } break;
        case gclidb_FieldId_gtblact: {
            retval = false;
        } break;
        case gclidb_FieldId_gclienv: {
            retval = false;
        } break;
        case gclidb_FieldId_working: {
            retval = bool_ReadStrptrMaybe(parent.working, strval);
        } break;
        case gclidb_FieldId_t: {
            retval = false;
        } break;
        case gclidb_FieldId_cmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtblacttst..ReadStrptrMaybe
// Read fields of gclidb::Gtblacttst from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtblacttst_ReadStrptrMaybe(gclidb::Gtblacttst &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtblacttst") || algo::StripTypeTag(in_str, "gclidb.Gtblacttst");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtblacttst_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtblacttst..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtblacttst.String  printfmt:Tuple
void gclidb::Gtblacttst_Print(gclidb::Gtblacttst& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtblacttst";

    algo::Smallstr250_Print(row.gtblacttst, temp);
    PrintAttrSpaceReset(str,"gtblacttst", temp);

    bool_Print(row.working, temp);
    PrintAttrSpaceReset(str,"working", temp);

    algo::cstring_Print(row.cmd, temp);
    PrintAttrSpaceReset(str,"cmd", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gtblacttstout.gtblacttst.Get
algo::Smallstr250 gclidb::gtblacttst_Get(gclidb::Gtblacttstout& parent) {
    algo::Smallstr250 ret(algo::Pathcomp(parent.gtblacttstout, ".RL"));
    return ret;
}

// --- gclidb.Gtblacttstout.gtblacttst.Get2
algo::Smallstr250 gclidb::Gtblacttstout_gtblacttst_Get(algo::strptr arg) {
    algo::Smallstr250 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gtblacttstout.out.Get
algo::cstring gclidb::out_Get(gclidb::Gtblacttstout& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gtblacttstout, ".RR"));
    return ret;
}

// --- gclidb.Gtblacttstout.out.Get2
algo::cstring gclidb::Gtblacttstout_out_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gtblacttstout..Concat_gtblacttst_out
tempstr gclidb::Gtblacttstout_Concat_gtblacttst_out( const algo::strptr& gtblacttst ,const algo::strptr& out ) {
    return tempstr() << gtblacttst <<'.'<< out ;
}

// --- gclidb.Gtblacttstout..ReadFieldMaybe
bool gclidb::Gtblacttstout_ReadFieldMaybe(gclidb::Gtblacttstout& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtblacttstout: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gtblacttstout, strval);
        } break;
        case gclidb_FieldId_gtblacttst: {
            retval = false;
        } break;
        case gclidb_FieldId_out: {
            retval = false;
        } break;
        case gclidb_FieldId_text: {
            retval = algo::cstring_ReadStrptrMaybe(parent.text, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtblacttstout..ReadStrptrMaybe
// Read fields of gclidb::Gtblacttstout from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtblacttstout_ReadStrptrMaybe(gclidb::Gtblacttstout &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtblacttstout") || algo::StripTypeTag(in_str, "gclidb.Gtblacttstout");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtblacttstout_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtblacttstout..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtblacttstout.String  printfmt:Tuple
void gclidb::Gtblacttstout_Print(gclidb::Gtblacttstout& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtblacttstout";

    algo::Smallstr250_Print(row.gtblacttstout, temp);
    PrintAttrSpaceReset(str,"gtblacttstout", temp);

    algo::cstring_Print(row.text, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- gclidb.Gtype..ReadFieldMaybe
bool gclidb::Gtype_ReadFieldMaybe(gclidb::Gtype& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gtype, strval);
        } break;
        case gclidb_FieldId_default_url: {
            retval = algo::cstring_ReadStrptrMaybe(parent.default_url, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtype..ReadStrptrMaybe
// Read fields of gclidb::Gtype from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtype_ReadStrptrMaybe(gclidb::Gtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtype") || algo::StripTypeTag(in_str, "gclidb.Gtype");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtype_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtype..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtype.String  printfmt:Tuple
void gclidb::Gtype_Print(gclidb::Gtype& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtype";

    algo::Smallstr50_Print(row.gtype, temp);
    PrintAttrSpaceReset(str,"gtype", temp);

    algo::cstring_Print(row.default_url, temp);
    PrintAttrSpaceReset(str,"default_url", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Gtypeh.gtype.Get
algo::Smallstr50 gclidb::gtype_Get(gclidb::Gtypeh& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtypeh, ".RL"));
    return ret;
}

// --- gclidb.Gtypeh.gtype.Get2
algo::Smallstr50 gclidb::Gtypeh_gtype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gtypeh.name.Get
algo::cstring gclidb::name_Get(gclidb::Gtypeh& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gtypeh, ".RR"));
    return ret;
}

// --- gclidb.Gtypeh.name.Get2
algo::cstring gclidb::Gtypeh_name_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gtypeh..Concat_gtype_name
tempstr gclidb::Gtypeh_Concat_gtype_name( const algo::strptr& gtype ,const algo::strptr& name ) {
    return tempstr() << gtype <<'.'<< name ;
}

// --- gclidb.Gtypeh..ReadFieldMaybe
bool gclidb::Gtypeh_ReadFieldMaybe(gclidb::Gtypeh& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtypeh: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.gtypeh, strval);
        } break;
        case gclidb_FieldId_gtype: {
            retval = false;
        } break;
        case gclidb_FieldId_name: {
            retval = false;
        } break;
        case gclidb_FieldId_header: {
            retval = algo::cstring_ReadStrptrMaybe(parent.header, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtypeh..ReadStrptrMaybe
// Read fields of gclidb::Gtypeh from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtypeh_ReadStrptrMaybe(gclidb::Gtypeh &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtypeh") || algo::StripTypeTag(in_str, "gclidb.Gtypeh");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtypeh_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtypeh..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtypeh.String  printfmt:Tuple
void gclidb::Gtypeh_Print(gclidb::Gtypeh& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtypeh";

    algo::Smallstr250_Print(row.gtypeh, temp);
    PrintAttrSpaceReset(str,"gtypeh", temp);

    algo::cstring_Print(row.header, temp);
    PrintAttrSpaceReset(str,"header", temp);
}

// --- gclidb.Gtypeprefix.gtype.Get
algo::Smallstr50 gclidb::gtype_Get(gclidb::Gtypeprefix& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gtypeprefix, ".RL"));
    return ret;
}

// --- gclidb.Gtypeprefix.gtype.Get2
algo::Smallstr50 gclidb::Gtypeprefix_gtype_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Gtypeprefix.prefix.Get
algo::cstring gclidb::prefix_Get(gclidb::Gtypeprefix& parent) {
    algo::cstring ret(algo::Pathcomp(parent.gtypeprefix, ".RR"));
    return ret;
}

// --- gclidb.Gtypeprefix.prefix.Get2
algo::cstring gclidb::Gtypeprefix_prefix_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Gtypeprefix..Concat_gtype_prefix
tempstr gclidb::Gtypeprefix_Concat_gtype_prefix( const algo::strptr& gtype ,const algo::strptr& prefix ) {
    return tempstr() << gtype <<'.'<< prefix ;
}

// --- gclidb.Gtypeprefix..ReadFieldMaybe
bool gclidb::Gtypeprefix_ReadFieldMaybe(gclidb::Gtypeprefix& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_gtypeprefix: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gtypeprefix, strval);
        } break;
        case gclidb_FieldId_gtype: {
            retval = false;
        } break;
        case gclidb_FieldId_prefix: {
            retval = false;
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Gtypeprefix..ReadStrptrMaybe
// Read fields of gclidb::Gtypeprefix from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Gtypeprefix_ReadStrptrMaybe(gclidb::Gtypeprefix &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.gtypeprefix") || algo::StripTypeTag(in_str, "gclidb.Gtypeprefix");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gtypeprefix_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Gtypeprefix..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Gtypeprefix.String  printfmt:Tuple
void gclidb::Gtypeprefix_Print(gclidb::Gtypeprefix& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.gtypeprefix";

    algo::Smallstr50_Print(row.gtypeprefix, temp);
    PrintAttrSpaceReset(str,"gtypeprefix", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Issue.project.Get
algo::Smallstr50 gclidb::project_Get(gclidb::Issue& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issue, ".RL"));
    return ret;
}

// --- gclidb.Issue.project.Get2
algo::Smallstr50 gclidb::Issue_project_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Issue.iid.Get
algo::cstring gclidb::iid_Get(gclidb::Issue& parent) {
    algo::cstring ret(algo::Pathcomp(parent.issue, ".RR"));
    return ret;
}

// --- gclidb.Issue.iid.Get2
algo::cstring gclidb::Issue_iid_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Issue..Concat_project_iid
tempstr gclidb::Issue_Concat_project_iid( const algo::strptr& project ,const algo::strptr& iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- gclidb.Issue..ReadFieldMaybe
bool gclidb::Issue_ReadFieldMaybe(gclidb::Issue& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_issue: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.issue, strval);
        } break;
        case gclidb_FieldId_project: {
            retval = false;
        } break;
        case gclidb_FieldId_iid: {
            retval = false;
        } break;
        case gclidb_FieldId_assignee: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.assignee, strval);
        } break;
        case gclidb_FieldId_labels: {
            retval = algo::cstring_ReadStrptrMaybe(parent.labels, strval);
        } break;
        case gclidb_FieldId_milestone_iid: {
            retval = algo::cstring_ReadStrptrMaybe(parent.milestone_iid, strval);
        } break;
        case gclidb_FieldId_milestone_num: {
            retval = algo::cstring_ReadStrptrMaybe(parent.milestone_num, strval);
        } break;
        case gclidb_FieldId_milestone: {
            retval = algo::cstring_ReadStrptrMaybe(parent.milestone, strval);
        } break;
        case gclidb_FieldId_title: {
            retval = algo::cstring_ReadStrptrMaybe(parent.title, strval);
        } break;
        case gclidb_FieldId_author: {
            retval = algo::cstring_ReadStrptrMaybe(parent.author, strval);
        } break;
        case gclidb_FieldId_state: {
            retval = algo::cstring_ReadStrptrMaybe(parent.state, strval);
        } break;
        case gclidb_FieldId_mr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.mr, strval);
        } break;
        case gclidb_FieldId_description: {
            retval = algo::cstring_ReadStrptrMaybe(parent.description, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Issue..ReadStrptrMaybe
// Read fields of gclidb::Issue from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Issue_ReadStrptrMaybe(gclidb::Issue &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.issue") || algo::StripTypeTag(in_str, "gclidb.Issue");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Issue_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Issue..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Issue.String  printfmt:Tuple
void gclidb::Issue_Print(gclidb::Issue& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.issue";

    algo::Smallstr50_Print(row.issue, temp);
    PrintAttrSpaceReset(str,"issue", temp);

    algo::Smallstr50_Print(row.assignee, temp);
    PrintAttrSpaceReset(str,"assignee", temp);

    algo::cstring_Print(row.labels, temp);
    PrintAttrSpaceReset(str,"labels", temp);

    algo::cstring_Print(row.milestone_iid, temp);
    PrintAttrSpaceReset(str,"milestone_iid", temp);

    algo::cstring_Print(row.milestone_num, temp);
    PrintAttrSpaceReset(str,"milestone_num", temp);

    algo::cstring_Print(row.milestone, temp);
    PrintAttrSpaceReset(str,"milestone", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::cstring_Print(row.state, temp);
    PrintAttrSpaceReset(str,"state", temp);

    algo::cstring_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);
}

// --- gclidb.Issuenote.issue.Get
algo::Smallstr50 gclidb::issue_Get(gclidb::Issuenote& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issuenote, ".RL"));
    return ret;
}

// --- gclidb.Issuenote.issue.Get2
algo::Smallstr50 gclidb::Issuenote_issue_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Issuenote.nid.Get
algo::cstring gclidb::nid_Get(gclidb::Issuenote& parent) {
    algo::cstring ret(algo::Pathcomp(parent.issuenote, ".RR"));
    return ret;
}

// --- gclidb.Issuenote.nid.Get2
algo::cstring gclidb::Issuenote_nid_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Issuenote..Concat_issue_nid
tempstr gclidb::Issuenote_Concat_issue_nid( const algo::strptr& issue ,const algo::strptr& nid ) {
    return tempstr() << issue <<'.'<< nid ;
}

// --- gclidb.Issuenote..ReadFieldMaybe
bool gclidb::Issuenote_ReadFieldMaybe(gclidb::Issuenote& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_issuenote: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.issuenote, strval);
        } break;
        case gclidb_FieldId_issue: {
            retval = false;
        } break;
        case gclidb_FieldId_nid: {
            retval = false;
        } break;
        case gclidb_FieldId_note: {
            retval = algo::cstring_ReadStrptrMaybe(parent.note, strval);
        } break;
        case gclidb_FieldId_system: {
            retval = algo::cstring_ReadStrptrMaybe(parent.system, strval);
        } break;
        case gclidb_FieldId_author: {
            retval = algo::cstring_ReadStrptrMaybe(parent.author, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Issuenote..ReadStrptrMaybe
// Read fields of gclidb::Issuenote from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Issuenote_ReadStrptrMaybe(gclidb::Issuenote &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.issuenote") || algo::StripTypeTag(in_str, "gclidb.Issuenote");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Issuenote_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Issuenote..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Issuenote.String  printfmt:Tuple
void gclidb::Issuenote_Print(gclidb::Issuenote& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.issuenote";

    algo::Smallstr250_Print(row.issuenote, temp);
    PrintAttrSpaceReset(str,"issuenote", temp);

    algo::cstring_Print(row.note, temp);
    PrintAttrSpaceReset(str,"note", temp);

    algo::cstring_Print(row.system, temp);
    PrintAttrSpaceReset(str,"system", temp);

    algo::cstring_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);
}

// --- gclidb.Issuepipeline.issue.Get
algo::Smallstr50 gclidb::issue_Get(gclidb::Issuepipeline& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issuepipeline, ".RL"));
    return ret;
}

// --- gclidb.Issuepipeline.issue.Get2
algo::Smallstr50 gclidb::Issuepipeline_issue_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Issuepipeline.id.Get
algo::cstring gclidb::id_Get(gclidb::Issuepipeline& parent) {
    algo::cstring ret(algo::Pathcomp(parent.issuepipeline, ".RR"));
    return ret;
}

// --- gclidb.Issuepipeline.id.Get2
algo::cstring gclidb::Issuepipeline_id_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Issuepipeline..Concat_issue_id
tempstr gclidb::Issuepipeline_Concat_issue_id( const algo::strptr& issue ,const algo::strptr& id ) {
    return tempstr() << issue <<'.'<< id ;
}

// --- gclidb.Issuepipeline..ReadFieldMaybe
bool gclidb::Issuepipeline_ReadFieldMaybe(gclidb::Issuepipeline& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_issuepipeline: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.issuepipeline, strval);
        } break;
        case gclidb_FieldId_issue: {
            retval = false;
        } break;
        case gclidb_FieldId_id: {
            retval = false;
        } break;
        case gclidb_FieldId_id_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.id_in, strval);
        } break;
        case gclidb_FieldId_status: {
            retval = algo::cstring_ReadStrptrMaybe(parent.status, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Issuepipeline..ReadStrptrMaybe
// Read fields of gclidb::Issuepipeline from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Issuepipeline_ReadStrptrMaybe(gclidb::Issuepipeline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.issuepipeline") || algo::StripTypeTag(in_str, "gclidb.Issuepipeline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Issuepipeline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Issuepipeline..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Issuepipeline.String  printfmt:Tuple
void gclidb::Issuepipeline_Print(gclidb::Issuepipeline& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.issuepipeline";

    algo::Smallstr250_Print(row.issuepipeline, temp);
    PrintAttrSpaceReset(str,"issuepipeline", temp);

    algo::cstring_Print(row.id_in, temp);
    PrintAttrSpaceReset(str,"id_in", temp);

    algo::cstring_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);
}

// --- gclidb.Label..ReadFieldMaybe
bool gclidb::Label_ReadFieldMaybe(gclidb::Label& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_label: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.label, strval);
        } break;
        case gclidb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Label..ReadStrptrMaybe
// Read fields of gclidb::Label from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Label_ReadStrptrMaybe(gclidb::Label &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.label") || algo::StripTypeTag(in_str, "gclidb.Label");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Label_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Label..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Label.String  printfmt:Tuple
void gclidb::Label_Print(gclidb::Label& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.label";

    algo::Smallstr50_Print(row.label, temp);
    PrintAttrSpaceReset(str,"label", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- gclidb.Milestone.project.Get
algo::Smallstr50 gclidb::project_Get(gclidb::Milestone& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.milestone, ".RL"));
    return ret;
}

// --- gclidb.Milestone.project.Get2
algo::Smallstr50 gclidb::Milestone_project_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Milestone.iid.Get
algo::cstring gclidb::iid_Get(gclidb::Milestone& parent) {
    algo::cstring ret(algo::Pathcomp(parent.milestone, ".RR"));
    return ret;
}

// --- gclidb.Milestone.iid.Get2
algo::cstring gclidb::Milestone_iid_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Milestone..Concat_project_iid
tempstr gclidb::Milestone_Concat_project_iid( const algo::strptr& project ,const algo::strptr& iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- gclidb.Milestone..ReadFieldMaybe
bool gclidb::Milestone_ReadFieldMaybe(gclidb::Milestone& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_milestone: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.milestone, strval);
        } break;
        case gclidb_FieldId_project: {
            retval = false;
        } break;
        case gclidb_FieldId_iid: {
            retval = false;
        } break;
        case gclidb_FieldId_description: {
            retval = algo::cstring_ReadStrptrMaybe(parent.description, strval);
        } break;
        case gclidb_FieldId_title: {
            retval = algo::cstring_ReadStrptrMaybe(parent.title, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Milestone..ReadStrptrMaybe
// Read fields of gclidb::Milestone from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Milestone_ReadStrptrMaybe(gclidb::Milestone &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.milestone") || algo::StripTypeTag(in_str, "gclidb.Milestone");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Milestone_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Milestone..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Milestone.String  printfmt:Tuple
void gclidb::Milestone_Print(gclidb::Milestone& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.milestone";

    algo::Smallstr200_Print(row.milestone, temp);
    PrintAttrSpaceReset(str,"milestone", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);
}

// --- gclidb.Mr.proj.Get
algo::Smallstr50 gclidb::proj_Get(gclidb::Mr& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.mr, ".RL"));
    return ret;
}

// --- gclidb.Mr.proj.Get2
algo::Smallstr50 gclidb::Mr_proj_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Mr.iid.Get
algo::cstring gclidb::iid_Get(gclidb::Mr& parent) {
    algo::cstring ret(algo::Pathcomp(parent.mr, ".RR"));
    return ret;
}

// --- gclidb.Mr.iid.Get2
algo::cstring gclidb::Mr_iid_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Mr..Concat_proj_iid
tempstr gclidb::Mr_Concat_proj_iid( const algo::strptr& proj ,const algo::strptr& iid ) {
    return tempstr() << proj <<'.'<< iid ;
}

// --- gclidb.Mr..ReadFieldMaybe
bool gclidb::Mr_ReadFieldMaybe(gclidb::Mr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_mr: {
            retval = algo::Smallstr150_ReadStrptrMaybe(parent.mr, strval);
        } break;
        case gclidb_FieldId_proj: {
            retval = false;
        } break;
        case gclidb_FieldId_iid: {
            retval = false;
        } break;
        case gclidb_FieldId_state: {
            retval = algo::cstring_ReadStrptrMaybe(parent.state, strval);
        } break;
        case gclidb_FieldId_title: {
            retval = algo::cstring_ReadStrptrMaybe(parent.title, strval);
        } break;
        case gclidb_FieldId_description: {
            retval = algo::cstring_ReadStrptrMaybe(parent.description, strval);
        } break;
        case gclidb_FieldId_source_branch: {
            retval = algo::cstring_ReadStrptrMaybe(parent.source_branch, strval);
        } break;
        case gclidb_FieldId_source_repo: {
            retval = algo::cstring_ReadStrptrMaybe(parent.source_repo, strval);
        } break;
        case gclidb_FieldId_reviewer: {
            retval = algo::cstring_ReadStrptrMaybe(parent.reviewer, strval);
        } break;
        case gclidb_FieldId_author: {
            retval = algo::cstring_ReadStrptrMaybe(parent.author, strval);
        } break;
        case gclidb_FieldId_pipeline_status: {
            retval = algo::Smallstr20_ReadStrptrMaybe(parent.pipeline_status, strval);
        } break;
        case gclidb_FieldId_pipeline_id: {
            retval = algo::cstring_ReadStrptrMaybe(parent.pipeline_id, strval);
        } break;
        case gclidb_FieldId_draft: {
            retval = algo::cstring_ReadStrptrMaybe(parent.draft, strval);
        } break;
        case gclidb_FieldId_node_id: {
            retval = algo::cstring_ReadStrptrMaybe(parent.node_id, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Mr..ReadStrptrMaybe
// Read fields of gclidb::Mr from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Mr_ReadStrptrMaybe(gclidb::Mr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.mr") || algo::StripTypeTag(in_str, "gclidb.Mr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Mr..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Mr.String  printfmt:Tuple
void gclidb::Mr_Print(gclidb::Mr& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.mr";

    algo::Smallstr150_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.state, temp);
    PrintAttrSpaceReset(str,"state", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);

    algo::cstring_Print(row.source_branch, temp);
    PrintAttrSpaceReset(str,"source_branch", temp);

    algo::cstring_Print(row.source_repo, temp);
    PrintAttrSpaceReset(str,"source_repo", temp);

    algo::cstring_Print(row.reviewer, temp);
    PrintAttrSpaceReset(str,"reviewer", temp);

    algo::cstring_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr20_Print(row.pipeline_status, temp);
    PrintAttrSpaceReset(str,"pipeline_status", temp);

    algo::cstring_Print(row.pipeline_id, temp);
    PrintAttrSpaceReset(str,"pipeline_id", temp);

    algo::cstring_Print(row.draft, temp);
    PrintAttrSpaceReset(str,"draft", temp);

    algo::cstring_Print(row.node_id, temp);
    PrintAttrSpaceReset(str,"node_id", temp);
}

// --- gclidb.Mrjob.mr.Get
algo::Smallstr150 gclidb::mr_Get(gclidb::Mrjob& parent) {
    algo::Smallstr150 ret(algo::Pathcomp(parent.mrjob, "/RL"));
    return ret;
}

// --- gclidb.Mrjob.mr.Get2
algo::Smallstr150 gclidb::Mrjob_mr_Get(algo::strptr arg) {
    algo::Smallstr150 ret(algo::Pathcomp(arg, "/RL"));
    return ret;
}

// --- gclidb.Mrjob.job.Get
algo::cstring gclidb::job_Get(gclidb::Mrjob& parent) {
    algo::cstring ret(algo::Pathcomp(parent.mrjob, "/RR"));
    return ret;
}

// --- gclidb.Mrjob.job.Get2
algo::cstring gclidb::Mrjob_job_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, "/RR"));
    return ret;
}

// --- gclidb.Mrjob..Concat_mr_job
tempstr gclidb::Mrjob_Concat_mr_job( const algo::strptr& mr ,const algo::strptr& job ) {
    return tempstr() << mr <<'/'<< job ;
}

// --- gclidb.Mrjob..ReadFieldMaybe
bool gclidb::Mrjob_ReadFieldMaybe(gclidb::Mrjob& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_mrjob: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.mrjob, strval);
        } break;
        case gclidb_FieldId_mr: {
            retval = false;
        } break;
        case gclidb_FieldId_job: {
            retval = false;
        } break;
        case gclidb_FieldId_ref: {
            retval = algo::Smallstr150_ReadStrptrMaybe(parent.ref, strval);
        } break;
        case gclidb_FieldId_id: {
            retval = algo::cstring_ReadStrptrMaybe(parent.id, strval);
        } break;
        case gclidb_FieldId_name: {
            retval = algo::cstring_ReadStrptrMaybe(parent.name, strval);
        } break;
        case gclidb_FieldId_pipeline_id: {
            retval = algo::cstring_ReadStrptrMaybe(parent.pipeline_id, strval);
        } break;
        case gclidb_FieldId_status: {
            retval = algo::cstring_ReadStrptrMaybe(parent.status, strval);
        } break;
        case gclidb_FieldId_runner: {
            retval = algo::cstring_ReadStrptrMaybe(parent.runner, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Mrjob..ReadStrptrMaybe
// Read fields of gclidb::Mrjob from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Mrjob_ReadStrptrMaybe(gclidb::Mrjob &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.mrjob") || algo::StripTypeTag(in_str, "gclidb.Mrjob");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mrjob_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Mrjob..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Mrjob.String  printfmt:Tuple
void gclidb::Mrjob_Print(gclidb::Mrjob& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.mrjob";

    algo::Smallstr250_Print(row.mrjob, temp);
    PrintAttrSpaceReset(str,"mrjob", temp);

    algo::Smallstr150_Print(row.ref, temp);
    PrintAttrSpaceReset(str,"ref", temp);

    algo::cstring_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    algo::cstring_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);

    algo::cstring_Print(row.pipeline_id, temp);
    PrintAttrSpaceReset(str,"pipeline_id", temp);

    algo::cstring_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    algo::cstring_Print(row.runner, temp);
    PrintAttrSpaceReset(str,"runner", temp);
}

// --- gclidb.Mrnote.nid.Get
algo::cstring gclidb::nid_Get(gclidb::Mrnote& parent) {
    algo::cstring ret(algo::Pathcomp(parent.mrnote, ".RR"));
    return ret;
}

// --- gclidb.Mrnote.nid.Get2
algo::cstring gclidb::Mrnote_nid_Get(algo::strptr arg) {
    algo::cstring ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- gclidb.Mrnote.mr.Get
algo::Smallstr150 gclidb::mr_Get(gclidb::Mrnote& parent) {
    algo::Smallstr150 ret(algo::Pathcomp(parent.mrnote, ".RL"));
    return ret;
}

// --- gclidb.Mrnote.mr.Get2
algo::Smallstr150 gclidb::Mrnote_mr_Get(algo::strptr arg) {
    algo::Smallstr150 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- gclidb.Mrnote..Concat_mr_nid
tempstr gclidb::Mrnote_Concat_mr_nid( const algo::strptr& mr ,const algo::strptr& nid ) {
    return tempstr() << mr <<'.'<< nid ;
}

// --- gclidb.Mrnote..ReadFieldMaybe
bool gclidb::Mrnote_ReadFieldMaybe(gclidb::Mrnote& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_system: {
            retval = algo::cstring_ReadStrptrMaybe(parent.system, strval);
        } break;
        case gclidb_FieldId_mrnote: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.mrnote, strval);
        } break;
        case gclidb_FieldId_nid: {
            retval = false;
        } break;
        case gclidb_FieldId_note: {
            retval = algo::cstring_ReadStrptrMaybe(parent.note, strval);
        } break;
        case gclidb_FieldId_author: {
            retval = algo::cstring_ReadStrptrMaybe(parent.author, strval);
        } break;
        case gclidb_FieldId_mr: {
            retval = false;
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.Mrnote..ReadStrptrMaybe
// Read fields of gclidb::Mrnote from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::Mrnote_ReadStrptrMaybe(gclidb::Mrnote &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.mrnote") || algo::StripTypeTag(in_str, "gclidb.Mrnote");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Mrnote_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.Mrnote..Print
// print string representation of ROW to string STR
// cfmt:gclidb.Mrnote.String  printfmt:Tuple
void gclidb::Mrnote_Print(gclidb::Mrnote& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.mrnote";

    algo::cstring_Print(row.system, temp);
    PrintAttrSpaceReset(str,"system", temp);

    algo::Smallstr250_Print(row.mrnote, temp);
    PrintAttrSpaceReset(str,"mrnote", temp);

    algo::cstring_Print(row.note, temp);
    PrintAttrSpaceReset(str,"note", temp);

    algo::cstring_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);
}

// --- gclidb.User..ReadFieldMaybe
bool gclidb::User_ReadFieldMaybe(gclidb::User& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    gclidb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case gclidb_FieldId_user: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.user, strval);
        } break;
        case gclidb_FieldId_id: {
            retval = u32_ReadStrptrMaybe(parent.id, strval);
        } break;
        case gclidb_FieldId_name: {
            retval = algo::cstring_ReadStrptrMaybe(parent.name, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- gclidb.User..ReadStrptrMaybe
// Read fields of gclidb::User from an ascii string.
// The format of the string is an ssim Tuple
bool gclidb::User_ReadStrptrMaybe(gclidb::User &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "gclidb.user") || algo::StripTypeTag(in_str, "gclidb.User");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && User_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- gclidb.User..Print
// print string representation of ROW to string STR
// cfmt:gclidb.User.String  printfmt:Tuple
void gclidb::User_Print(gclidb::User& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "gclidb.user";

    algo::Smallstr50_Print(row.user, temp);
    PrintAttrSpaceReset(str,"user", temp);

    u32_Print(row.id, temp);
    PrintAttrSpaceReset(str,"id", temp);

    algo::cstring_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);
}

// --- gclidb...SizeCheck
inline static void gclidb::SizeCheck() {
}
