//
// cpp/gen/lib_ams_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/lib_ams_gen.h"
#include "include/gen/lib_ams_gen.inl.h"
#include "include/gen/ams_gen.h"
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/amsdb_gen.h"
#include "include/gen/amsdb_gen.inl.h"
#include "include/gen/fm_gen.h"
#include "include/gen/fm_gen.inl.h"
#include "include/gen/ietf_gen.h"
#include "include/gen/ietf_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude
namespace lib_ams { // gen:ns_gsymbol
    const char* amsdb_proctype__0("0");
    const char* amsdb_proctype_amstest("amstest");
} // gen:ns_gsymbol
namespace lib_ams { // gen:ns_gsymbol
    const char* amsdb_streamtype__0("0");
    const char* amsdb_streamtype_ctl("ctl");
    const char* amsdb_streamtype_io("io");
    const char* amsdb_streamtype_out("out");
    const char* amsdb_streamtype_trace("trace");
} // gen:ns_gsymbol
namespace lib_ams { // gen:ns_print_proto
    // First element of index changed.
    static void          cd_fdin_eof_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          cd_fdin_eof_UpdateCycles() __attribute__((nothrow));
    static void          cd_fdin_eof_Call() __attribute__((nothrow));
    // First element of index changed.
    static void          cd_fdin_read_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          cd_fdin_read_UpdateCycles() __attribute__((nothrow));
    static void          cd_fdin_read_Call() __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    // Update cycles count from previous clock capture
    static void          zd_flush_UpdateCycles() __attribute__((nothrow));
    static void          zd_flush_Call() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          cd_stream_hb_UpdateCycles() __attribute__((nothrow));
    static void          cd_stream_hb_Call() __attribute__((nothrow));
    // First element of index changed.
    static void          cd_poll_read_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          cd_poll_read_UpdateCycles() __attribute__((nothrow));
    static void          cd_poll_read_Call() __attribute__((nothrow));
    static void          streamtype_LoadStatic() __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Internal function to scan for a message
    //
    static void          in_Scanmsg(lib_ams::FFdin& fdin) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    static void          in_Shift(lib_ams::FFdin& fdin) __attribute__((nothrow));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- lib_ams.CtlConnCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_ams::value_ToCstr(const lib_ams::CtlConnCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case lib_ams_CtlConnCase_ams_AlarmSyncMsg: ret = "ams.AlarmSyncMsg";  break;
        case lib_ams_CtlConnCase_ams_HeartbeatMsg: ret = "ams.HeartbeatMsg";  break;
        case lib_ams_CtlConnCase_fm_AlarmMsg: ret = "fm.AlarmMsg";  break;
    }
    return ret;
}

// --- lib_ams.CtlConnCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void lib_ams::value_Print(const lib_ams::CtlConnCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- lib_ams.CtlConnCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_ams::value_SetStrptrMaybe(lib_ams::CtlConnCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','m','.','A','l','a','r','m'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,lib_ams_CtlConnCase_fm_AlarmMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','A','l','a','r'): {
                    if (memcmp(rhs.elems+8,"mSyncMsg",8)==0) { value_SetEnum(parent,lib_ams_CtlConnCase_ams_AlarmSyncMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','H','e','a','r'): {
                    if (memcmp(rhs.elems+8,"tbeatMsg",8)==0) { value_SetEnum(parent,lib_ams_CtlConnCase_ams_HeartbeatMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_ams.CtlConnCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_ams::value_SetStrptr(lib_ams::CtlConnCase& parent, algo::strptr rhs, lib_ams_CtlConnCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- lib_ams.CtlConnCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool lib_ams::value_ReadStrptrMaybe(lib_ams::CtlConnCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- lib_ams.CtlConnCase..ReadStrptrMaybe
// Read fields of lib_ams::CtlConnCase from an ascii string.
// The format of the string is the format of the lib_ams::CtlConnCase's only field
bool lib_ams::CtlConnCase_ReadStrptrMaybe(lib_ams::CtlConnCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && lib_ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- lib_ams.CtlMsgCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_ams::value_ToCstr(const lib_ams::CtlMsgCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case lib_ams_CtlMsgCase_ams_DumpStreamTableMsg: ret = "ams.DumpStreamTableMsg";  break;
        case lib_ams_CtlMsgCase_ams_ProcAddMsg: ret = "ams.ProcAddMsg";  break;
        case lib_ams_CtlMsgCase_ams_ProcRemoveMsg: ret = "ams.ProcRemoveMsg";  break;
        case lib_ams_CtlMsgCase_ams_StreamHbMsg: ret = "ams.StreamHbMsg";  break;
    }
    return ret;
}

// --- lib_ams.CtlMsgCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void lib_ams::value_Print(const lib_ams::CtlMsgCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- lib_ams.CtlMsgCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_ams::value_SetStrptrMaybe(lib_ams::CtlMsgCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"AddMsg",6)==0) { value_SetEnum(parent,lib_ams_CtlMsgCase_ams_ProcAddMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','S','t','r','e'): {
                    if (memcmp(rhs.elems+8,"amHbMsg",7)==0) { value_SetEnum(parent,lib_ams_CtlMsgCase_ams_StreamHbMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"RemoveMsg",9)==0) { value_SetEnum(parent,lib_ams_CtlMsgCase_ams_ProcRemoveMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 22: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','D','u','m','p'): {
                    if (memcmp(rhs.elems+8,"StreamTableMsg",14)==0) { value_SetEnum(parent,lib_ams_CtlMsgCase_ams_DumpStreamTableMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_ams.CtlMsgCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_ams::value_SetStrptr(lib_ams::CtlMsgCase& parent, algo::strptr rhs, lib_ams_CtlMsgCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- lib_ams.CtlMsgCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool lib_ams::value_ReadStrptrMaybe(lib_ams::CtlMsgCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- lib_ams.CtlMsgCase..ReadStrptrMaybe
// Read fields of lib_ams::CtlMsgCase from an ascii string.
// The format of the string is the format of the lib_ams::CtlMsgCase's only field
bool lib_ams::CtlMsgCase_ReadStrptrMaybe(lib_ams::CtlMsgCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && lib_ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- lib_ams.trace..Print
// print string representation of lib_ams::trace to string LHS, no header -- cprint:lib_ams.trace.String
void lib_ams::trace_Print(lib_ams::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_ams.trace";

    u64_Print(row.n_fdin_drop_notgt, temp);
    PrintAttrSpaceReset(str,"n_fdin_drop_notgt", temp);

    u64_Print(row.n_fdin_posted, temp);
    PrintAttrSpaceReset(str,"n_fdin_posted", temp);

    u64_Print(row.n_fdin_pushback, temp);
    PrintAttrSpaceReset(str,"n_fdin_pushback", temp);

    u64_Print(row.n_write_block_spin, temp);
    PrintAttrSpaceReset(str,"n_write_block_spin", temp);
}

// --- lib_ams.FDb.fdin.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_ams::FFdin& lib_ams::fdin_Alloc() {
    lib_ams::FFdin* row = fdin_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_ams.out_of_mem  field:lib_ams.FDb.fdin  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_ams.FDb.fdin.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_ams::FFdin* lib_ams::fdin_AllocMaybe() {
    lib_ams::FFdin *row = (lib_ams::FFdin*)fdin_AllocMem();
    if (row) {
        new (row) lib_ams::FFdin; // call constructor
    }
    return row;
}

// --- lib_ams.FDb.fdin.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* lib_ams::fdin_AllocMem() {
    u64 new_nelems     = _db.fdin_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    lib_ams::FFdin*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fdin_lary[bsr];
        if (!lev) {
            lev=(lib_ams::FFdin*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FFdin) * (u64(1)<<bsr));
            _db.fdin_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fdin_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- lib_ams.FDb.fdin.RemoveAll
// Remove all elements from Lary
void lib_ams::fdin_RemoveAll() {
    for (u64 n = _db.fdin_n; n>0; ) {
        n--;
        fdin_qFind(u64(n)).~FFdin(); // destroy last element
        _db.fdin_n = i32(n);
    }
}

// --- lib_ams.FDb.fdin.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::fdin_RemoveLast() {
    u64 n = _db.fdin_n;
    if (n > 0) {
        n -= 1;
        fdin_qFind(u64(n)).~FFdin();
        _db.fdin_n = i32(n);
    }
}

// --- lib_ams.FDb.fdin.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::fdin_XrefMaybe(lib_ams::FFdin &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- lib_ams.FDb.cd_fdin_eof.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::cd_fdin_eof_Insert(lib_ams::FFdin& row) {
    if (!cd_fdin_eof_InLlistQ(row)) {
        if (_db.cd_fdin_eof_head) {
            row.cd_fdin_eof_next = _db.cd_fdin_eof_head;
            row.cd_fdin_eof_prev = _db.cd_fdin_eof_head->cd_fdin_eof_prev;
            row.cd_fdin_eof_prev->cd_fdin_eof_next = &row;
            row.cd_fdin_eof_next->cd_fdin_eof_prev = &row;
        } else {
            row.cd_fdin_eof_next = &row;
            row.cd_fdin_eof_prev = &row;
            _db.cd_fdin_eof_head = &row;
        }
        _db.cd_fdin_eof_n++;
        if (_db.cd_fdin_eof_head == &row) {
            cd_fdin_eof_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_fdin_eof.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::cd_fdin_eof_Remove(lib_ams::FFdin& row) {
    if (cd_fdin_eof_InLlistQ(row)) {
        lib_ams::FFdin* old_head       = _db.cd_fdin_eof_head;
        (void)old_head; // in case it's not used
        lib_ams::FFdin *oldnext = row.cd_fdin_eof_next;
        lib_ams::FFdin *oldprev = row.cd_fdin_eof_prev;
        oldnext->cd_fdin_eof_prev = oldprev; // remove element from list
        oldprev->cd_fdin_eof_next = oldnext;
        _db.cd_fdin_eof_n--;  // adjust count
        if (&row == _db.cd_fdin_eof_head) {
            _db.cd_fdin_eof_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_fdin_eof_next = (lib_ams::FFdin*)-1; // mark element as not-in-list);
        row.cd_fdin_eof_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_fdin_eof_head) {
            cd_fdin_eof_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_fdin_eof.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::cd_fdin_eof_RemoveAll() {
    lib_ams::FFdin* row = _db.cd_fdin_eof_head;
    lib_ams::FFdin* head = _db.cd_fdin_eof_head;
    _db.cd_fdin_eof_head = NULL;
    _db.cd_fdin_eof_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        lib_ams::FFdin* row_next = row->cd_fdin_eof_next;
        row->cd_fdin_eof_next  = (lib_ams::FFdin*)-1;
        row->cd_fdin_eof_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_fdin_eof_FirstChanged();
    }
}

// --- lib_ams.FDb.cd_fdin_eof.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
lib_ams::FFdin* lib_ams::cd_fdin_eof_RemoveFirst() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head;
    if (row) {
        bool hasmore = row!=row->cd_fdin_eof_next;
        _db.cd_fdin_eof_head = hasmore ? row->cd_fdin_eof_next : NULL;
        row->cd_fdin_eof_next->cd_fdin_eof_prev = row->cd_fdin_eof_prev;
        row->cd_fdin_eof_prev->cd_fdin_eof_next = row->cd_fdin_eof_next;
        row->cd_fdin_eof_prev = NULL;
        _db.cd_fdin_eof_n--;
        row->cd_fdin_eof_next = (lib_ams::FFdin*)-1; // mark as not-in-list
        cd_fdin_eof_FirstChanged();
    }
    return row;
}

// --- lib_ams.FDb.cd_fdin_eof.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
lib_ams::FFdin* lib_ams::cd_fdin_eof_RotateFirst() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head;
    if (row) {
        _db.cd_fdin_eof_head = row->cd_fdin_eof_next;
    }
    return row;
}

// --- lib_ams.FDb.cd_fdin_eof.FirstChanged
// First element of index changed.
static void lib_ams::cd_fdin_eof_FirstChanged() {
}

// --- lib_ams.FDb.cd_fdin_eof.UpdateCycles
// Update cycles count from previous clock capture
inline static void lib_ams::cd_fdin_eof_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- lib_ams.FDb.cd_fdin_eof.Call
inline static void lib_ams::cd_fdin_eof_Call() {
    if (!lib_ams::cd_fdin_eof_EmptyQ()) { // fstep:lib_ams.FDb.cd_fdin_eof
        lib_ams::cd_fdin_eof_Step(); // steptype:Inline: call function on every step
        cd_fdin_eof_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- lib_ams.FDb.cd_fdin_read.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::cd_fdin_read_Insert(lib_ams::FFdin& row) {
    if (!cd_fdin_read_InLlistQ(row)) {
        if (_db.cd_fdin_read_head) {
            row.cd_fdin_read_next = _db.cd_fdin_read_head;
            row.cd_fdin_read_prev = _db.cd_fdin_read_head->cd_fdin_read_prev;
            row.cd_fdin_read_prev->cd_fdin_read_next = &row;
            row.cd_fdin_read_next->cd_fdin_read_prev = &row;
        } else {
            row.cd_fdin_read_next = &row;
            row.cd_fdin_read_prev = &row;
            _db.cd_fdin_read_head = &row;
        }
        _db.cd_fdin_read_n++;
        if (_db.cd_fdin_read_head == &row) {
            cd_fdin_read_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_fdin_read.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::cd_fdin_read_Remove(lib_ams::FFdin& row) {
    if (cd_fdin_read_InLlistQ(row)) {
        lib_ams::FFdin* old_head       = _db.cd_fdin_read_head;
        (void)old_head; // in case it's not used
        lib_ams::FFdin *oldnext = row.cd_fdin_read_next;
        lib_ams::FFdin *oldprev = row.cd_fdin_read_prev;
        oldnext->cd_fdin_read_prev = oldprev; // remove element from list
        oldprev->cd_fdin_read_next = oldnext;
        _db.cd_fdin_read_n--;  // adjust count
        if (&row == _db.cd_fdin_read_head) {
            _db.cd_fdin_read_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_fdin_read_next = (lib_ams::FFdin*)-1; // mark element as not-in-list);
        row.cd_fdin_read_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_fdin_read_head) {
            cd_fdin_read_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_fdin_read.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::cd_fdin_read_RemoveAll() {
    lib_ams::FFdin* row = _db.cd_fdin_read_head;
    lib_ams::FFdin* head = _db.cd_fdin_read_head;
    _db.cd_fdin_read_head = NULL;
    _db.cd_fdin_read_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        lib_ams::FFdin* row_next = row->cd_fdin_read_next;
        row->cd_fdin_read_next  = (lib_ams::FFdin*)-1;
        row->cd_fdin_read_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_fdin_read_FirstChanged();
    }
}

// --- lib_ams.FDb.cd_fdin_read.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
lib_ams::FFdin* lib_ams::cd_fdin_read_RemoveFirst() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_read_head;
    if (row) {
        bool hasmore = row!=row->cd_fdin_read_next;
        _db.cd_fdin_read_head = hasmore ? row->cd_fdin_read_next : NULL;
        row->cd_fdin_read_next->cd_fdin_read_prev = row->cd_fdin_read_prev;
        row->cd_fdin_read_prev->cd_fdin_read_next = row->cd_fdin_read_next;
        row->cd_fdin_read_prev = NULL;
        _db.cd_fdin_read_n--;
        row->cd_fdin_read_next = (lib_ams::FFdin*)-1; // mark as not-in-list
        cd_fdin_read_FirstChanged();
    }
    return row;
}

// --- lib_ams.FDb.cd_fdin_read.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
lib_ams::FFdin* lib_ams::cd_fdin_read_RotateFirst() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_read_head;
    if (row) {
        _db.cd_fdin_read_head = row->cd_fdin_read_next;
    }
    return row;
}

// --- lib_ams.FDb.cd_fdin_read.FirstChanged
// First element of index changed.
static void lib_ams::cd_fdin_read_FirstChanged() {
}

// --- lib_ams.FDb.cd_fdin_read.UpdateCycles
// Update cycles count from previous clock capture
inline static void lib_ams::cd_fdin_read_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- lib_ams.FDb.cd_fdin_read.Call
inline static void lib_ams::cd_fdin_read_Call() {
    if (!lib_ams::cd_fdin_read_EmptyQ()) { // fstep:lib_ams.FDb.cd_fdin_read
        lib_ams::cd_fdin_read_Step(); // steptype:Inline: call function on every step
        cd_fdin_read_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- lib_ams.FDb._db.Step
// Main step
void lib_ams::Step() {
    cd_fdin_eof_Call();
    cd_fdin_read_Call();
    cd_stream_hb_Call();
    zd_flush_Call();
    cd_poll_read_Call();
}

// --- lib_ams.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void lib_ams::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("lib_ams", NULL, lib_ams::Step, NULL, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "lib_ams.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(lib_ams::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)lib_ams::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'lib_ams.CtlConn'  signature:'a97117f47887d9e386b0b46863db70bcc5ee1d43'");
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'lib_ams.CtlMsg'  signature:'90f280b1d0ea224349fab6afa67209c80742b8f4'");
}

// --- lib_ams.FDb._db.StaticCheck
void lib_ams::StaticCheck() {
    algo_assert(sizeof(lib_ams::stream_h_msg_hook) == 8); // csize:lib_ams.stream_h_msg_hook
    algo_assert(sizeof(lib_ams::stream_h_msg_orig_hook) == 8); // csize:lib_ams.stream_h_msg_orig_hook
    algo_assert(_offset_of(lib_ams::CtlConnCase, value) + sizeof(((lib_ams::CtlConnCase*)0)->value) == sizeof(lib_ams::CtlConnCase));
    algo_assert(_offset_of(lib_ams::CtlMsgCase, value) + sizeof(((lib_ams::CtlMsgCase*)0)->value) == sizeof(lib_ams::CtlMsgCase));
    algo_assert(_offset_of(lib_ams::trace, n_write_block_spin) + sizeof(((lib_ams::trace*)0)->n_write_block_spin) == sizeof(lib_ams::trace));
    algo_assert(_offset_of(lib_ams::FieldId, value) + sizeof(((lib_ams::FieldId*)0)->value) == sizeof(lib_ams::FieldId));
}

// --- lib_ams.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool lib_ams::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    (void)str;//only to avoid -Wunused-parameter
    return retval;
}

// --- lib_ams.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool lib_ams::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    (void)root;//only to avoid -Wunused-parameter
    return retval;
}

// --- lib_ams.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool lib_ams::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, lib_ams::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- lib_ams.FDb._db.Steps
// Calls Step function of dependencies
void lib_ams::Steps() {
    lib_ams::Step(); // dependent namespace specified via (dev.targdep)
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- lib_ams.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- lib_ams.FDb.writefile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::writefile_XrefMaybe(lib_ams::FWritefile &row) {
    bool retval = true;
    (void)row;
    // insert writefile into index zd_flush
    if (true) { // user-defined insert condition
        zd_flush_Insert(row);
    }
    return retval;
}

// --- lib_ams.FDb.zd_flush.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::zd_flush_Insert(lib_ams::FWritefile& row) {
    if (!zd_flush_InLlistQ(row)) {
        lib_ams::FWritefile* old_tail = _db.zd_flush_tail;
        row.zd_flush_next = NULL;
        row.zd_flush_prev = old_tail;
        _db.zd_flush_tail = &row;
        lib_ams::FWritefile **new_row_a = &old_tail->zd_flush_next;
        lib_ams::FWritefile **new_row_b = &_db.zd_flush_head;
        lib_ams::FWritefile **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_flush_n++;
        if (_db.zd_flush_head == &row) {
            zd_flush_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.zd_flush.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::zd_flush_Remove(lib_ams::FWritefile& row) {
    if (zd_flush_InLlistQ(row)) {
        lib_ams::FWritefile* old_head       = _db.zd_flush_head;
        (void)old_head; // in case it's not used
        lib_ams::FWritefile* prev = row.zd_flush_prev;
        lib_ams::FWritefile* next = row.zd_flush_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        lib_ams::FWritefile **new_next_a = &prev->zd_flush_next;
        lib_ams::FWritefile **new_next_b = &_db.zd_flush_head;
        lib_ams::FWritefile **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        lib_ams::FWritefile **new_prev_a = &next->zd_flush_prev;
        lib_ams::FWritefile **new_prev_b = &_db.zd_flush_tail;
        lib_ams::FWritefile **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_flush_n--;
        row.zd_flush_next=(lib_ams::FWritefile*)-1; // not-in-list
        if (old_head != _db.zd_flush_head) {
            zd_flush_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.zd_flush.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::zd_flush_RemoveAll() {
    lib_ams::FWritefile* row = _db.zd_flush_head;
    _db.zd_flush_head = NULL;
    _db.zd_flush_tail = NULL;
    _db.zd_flush_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        lib_ams::FWritefile* row_next = row->zd_flush_next;
        row->zd_flush_next  = (lib_ams::FWritefile*)-1;
        row->zd_flush_prev  = NULL;
        row = row_next;
    }
    if (do_fire) {
        zd_flush_FirstChanged();
    }
}

// --- lib_ams.FDb.zd_flush.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
lib_ams::FWritefile* lib_ams::zd_flush_RemoveFirst() {
    lib_ams::FWritefile *row = NULL;
    row = _db.zd_flush_head;
    if (row) {
        lib_ams::FWritefile *next = row->zd_flush_next;
        _db.zd_flush_head = next;
        lib_ams::FWritefile **new_end_a = &next->zd_flush_prev;
        lib_ams::FWritefile **new_end_b = &_db.zd_flush_tail;
        lib_ams::FWritefile **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_flush_n--;
        row->zd_flush_next = (lib_ams::FWritefile*)-1; // mark as not-in-list
        zd_flush_FirstChanged();
    }
    return row;
}

// --- lib_ams.FDb.zd_flush.FirstChanged
// First element of index changed.
void lib_ams::zd_flush_FirstChanged() {
}

// --- lib_ams.FDb.zd_flush.UpdateCycles
// Update cycles count from previous clock capture
inline static void lib_ams::zd_flush_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- lib_ams.FDb.zd_flush.Call
inline static void lib_ams::zd_flush_Call() {
    if (!lib_ams::zd_flush_EmptyQ()) { // fstep:lib_ams.FDb.zd_flush
        if (lib_ams::_db.zd_flush_next < algo_lib::_db.clock) {
            u64 effective_delay = lib_ams::_db.zd_flush_delay / u64_Max(1,lib_ams::zd_flush_N());
            lib_ams::_db.zd_flush_next = algo_lib::_db.clock + algo::SchedTime(effective_delay);
            lib_ams::zd_flush_Step(); // steptype:InlineRecur: call function every N clock cycles
            zd_flush_UpdateCycles();
        }
        algo_lib::_db.next_loop.value = u64_Min(lib_ams::_db.zd_flush_next, algo_lib::_db.next_loop);
    }
}

// --- lib_ams.FDb.zd_flush.SetDelay
// Set inter-step delay to specified value.
// The difference between new delay and current delay is added to the next scheduled time.
void lib_ams::zd_flush_SetDelay(algo::SchedTime delay) {
    i64 diff = delay.value - lib_ams::_db.zd_flush_delay.value;
    lib_ams::_db.zd_flush_delay = delay;
    if (diff > 0) {
        lib_ams::_db.zd_flush_next.value += diff;
    } else {
        lib_ams::_db.zd_flush_next.value = algo::u64_SubClip(lib_ams::_db.zd_flush_next.value,-diff);
    }
}

// --- lib_ams.FDb.stream.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_ams::FStream& lib_ams::stream_Alloc() {
    lib_ams::FStream* row = stream_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_ams.out_of_mem  field:lib_ams.FDb.stream  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_ams.FDb.stream.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_ams::FStream* lib_ams::stream_AllocMaybe() {
    lib_ams::FStream *row = (lib_ams::FStream*)stream_AllocMem();
    if (row) {
        new (row) lib_ams::FStream; // call constructor
    }
    return row;
}

// --- lib_ams.FDb.stream.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* lib_ams::stream_AllocMem() {
    u64 new_nelems     = _db.stream_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    lib_ams::FStream*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.stream_lary[bsr];
        if (!lev) {
            lev=(lib_ams::FStream*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStream) * (u64(1)<<bsr));
            _db.stream_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.stream_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- lib_ams.FDb.stream.RemoveAll
// Remove all elements from Lary
void lib_ams::stream_RemoveAll() {
    for (u64 n = _db.stream_n; n>0; ) {
        n--;
        stream_qFind(u64(n)).~FStream(); // destroy last element
        _db.stream_n = i32(n);
    }
}

// --- lib_ams.FDb.stream.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::stream_RemoveLast() {
    u64 n = _db.stream_n;
    if (n > 0) {
        n -= 1;
        stream_qFind(u64(n)).~FStream();
        _db.stream_n = i32(n);
    }
}

// --- lib_ams.FDb.stream.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::stream_XrefMaybe(lib_ams::FStream &row) {
    bool retval = true;
    (void)row;
    lib_ams::FStreamType* p_stream_type = lib_ams::ind_streamtype_Find(row.stream_id.stream_type);
    if (UNLIKELY(!p_stream_type)) {
        algo_lib::ResetErrtext() << "lib_ams.bad_xref  index:lib_ams.FDb.ind_streamtype" << Keyval("key", row.stream_id.stream_type);
        return false;
    }
    // stream: save pointer to stream_type
    if (true) { // user-defined insert condition
        row.p_streamtype = p_stream_type;
    }
    // insert stream into index ind_stream
    if (true) { // user-defined insert condition
        bool success = ind_stream_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "lib_ams.duplicate_key  xref:lib_ams.FDb.ind_stream"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_stream.Find
// Find row by key. Return NULL if not found.
lib_ams::FStream* lib_ams::ind_stream_Find(ams::StreamId key) {
    u32 index = ams::StreamId_Hash(0, key) & (_db.ind_stream_buckets_n - 1);
    lib_ams::FStream* *e = &_db.ind_stream_buckets_elems[index];
    lib_ams::FStream* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).stream_id == key;
        if (done) break;
        e         = &ret->ind_stream_next;
    } while (true);
    return ret;
}

// --- lib_ams.FDb.ind_stream.FindX
// Look up row by key and return reference. Throw exception if not found
lib_ams::FStream& lib_ams::ind_stream_FindX(ams::StreamId key) {
    lib_ams::FStream* ret = ind_stream_Find(key);
    vrfy(ret, tempstr() << "lib_ams.key_error  table:ind_stream  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- lib_ams.FDb.ind_stream.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool lib_ams::ind_stream_InsertMaybe(lib_ams::FStream& row) {
    ind_stream_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_stream_next == (lib_ams::FStream*)-1)) {// check if in hash already
        u32 index = ams::StreamId_Hash(0, row.stream_id) & (_db.ind_stream_buckets_n - 1);
        lib_ams::FStream* *prev = &_db.ind_stream_buckets_elems[index];
        do {
            lib_ams::FStream* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).stream_id == row.stream_id) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_stream_next;
        } while (true);
        if (retval) {
            row.ind_stream_next = *prev;
            _db.ind_stream_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_stream.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void lib_ams::ind_stream_Remove(lib_ams::FStream& row) {
    if (LIKELY(row.ind_stream_next != (lib_ams::FStream*)-1)) {// check if in hash already
        u32 index = ams::StreamId_Hash(0, row.stream_id) & (_db.ind_stream_buckets_n - 1);
        lib_ams::FStream* *prev = &_db.ind_stream_buckets_elems[index]; // addr of pointer to current element
        while (lib_ams::FStream *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_stream_next; // unlink (singly linked list)
                _db.ind_stream_n--;
                row.ind_stream_next = (lib_ams::FStream*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_stream_next;
        }
    }
}

// --- lib_ams.FDb.ind_stream.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void lib_ams::ind_stream_Reserve(int n) {
    u32 old_nbuckets = _db.ind_stream_buckets_n;
    u32 new_nelems   = _db.ind_stream_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(lib_ams::FStream*);
        u32 new_size = new_nbuckets * sizeof(lib_ams::FStream*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        lib_ams::FStream* *new_buckets = (lib_ams::FStream**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("lib_ams.out_of_memory  field:lib_ams.FDb.ind_stream");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_stream_buckets_n; i++) {
            lib_ams::FStream* elem = _db.ind_stream_buckets_elems[i];
            while (elem) {
                lib_ams::FStream &row        = *elem;
                lib_ams::FStream* next       = row.ind_stream_next;
                u32 index          = ams::StreamId_Hash(0, row.stream_id) & (new_nbuckets-1);
                row.ind_stream_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_stream_buckets_elems, old_size);
        _db.ind_stream_buckets_elems = new_buckets;
        _db.ind_stream_buckets_n = new_nbuckets;
    }
}

// --- lib_ams.FDb.cd_stream_hb.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::cd_stream_hb_Insert(lib_ams::FStream& row) {
    if (!cd_stream_hb_InLlistQ(row)) {
        if (_db.cd_stream_hb_head) {
            row.cd_stream_hb_next = _db.cd_stream_hb_head;
            row.cd_stream_hb_prev = _db.cd_stream_hb_head->cd_stream_hb_prev;
            row.cd_stream_hb_prev->cd_stream_hb_next = &row;
            row.cd_stream_hb_next->cd_stream_hb_prev = &row;
        } else {
            row.cd_stream_hb_next = &row;
            row.cd_stream_hb_prev = &row;
            _db.cd_stream_hb_head = &row;
        }
        _db.cd_stream_hb_n++;
        if (_db.cd_stream_hb_head == &row) {
            cd_stream_hb_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_stream_hb.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::cd_stream_hb_Remove(lib_ams::FStream& row) {
    if (cd_stream_hb_InLlistQ(row)) {
        lib_ams::FStream* old_head       = _db.cd_stream_hb_head;
        (void)old_head; // in case it's not used
        lib_ams::FStream *oldnext = row.cd_stream_hb_next;
        lib_ams::FStream *oldprev = row.cd_stream_hb_prev;
        oldnext->cd_stream_hb_prev = oldprev; // remove element from list
        oldprev->cd_stream_hb_next = oldnext;
        _db.cd_stream_hb_n--;  // adjust count
        if (&row == _db.cd_stream_hb_head) {
            _db.cd_stream_hb_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_stream_hb_next = (lib_ams::FStream*)-1; // mark element as not-in-list);
        row.cd_stream_hb_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_stream_hb_head) {
            cd_stream_hb_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_stream_hb.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::cd_stream_hb_RemoveAll() {
    lib_ams::FStream* row = _db.cd_stream_hb_head;
    lib_ams::FStream* head = _db.cd_stream_hb_head;
    _db.cd_stream_hb_head = NULL;
    _db.cd_stream_hb_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        lib_ams::FStream* row_next = row->cd_stream_hb_next;
        row->cd_stream_hb_next  = (lib_ams::FStream*)-1;
        row->cd_stream_hb_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_stream_hb_FirstChanged();
    }
}

// --- lib_ams.FDb.cd_stream_hb.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
lib_ams::FStream* lib_ams::cd_stream_hb_RemoveFirst() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_stream_hb_head;
    if (row) {
        bool hasmore = row!=row->cd_stream_hb_next;
        _db.cd_stream_hb_head = hasmore ? row->cd_stream_hb_next : NULL;
        row->cd_stream_hb_next->cd_stream_hb_prev = row->cd_stream_hb_prev;
        row->cd_stream_hb_prev->cd_stream_hb_next = row->cd_stream_hb_next;
        row->cd_stream_hb_prev = NULL;
        _db.cd_stream_hb_n--;
        row->cd_stream_hb_next = (lib_ams::FStream*)-1; // mark as not-in-list
        cd_stream_hb_FirstChanged();
    }
    return row;
}

// --- lib_ams.FDb.cd_stream_hb.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
lib_ams::FStream* lib_ams::cd_stream_hb_RotateFirst() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_stream_hb_head;
    if (row) {
        _db.cd_stream_hb_head = row->cd_stream_hb_next;
    }
    return row;
}

// --- lib_ams.FDb.cd_stream_hb.FirstChanged
// First element of index changed.
void lib_ams::cd_stream_hb_FirstChanged() {
}

// --- lib_ams.FDb.cd_stream_hb.UpdateCycles
// Update cycles count from previous clock capture
inline static void lib_ams::cd_stream_hb_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- lib_ams.FDb.cd_stream_hb.Call
inline static void lib_ams::cd_stream_hb_Call() {
    if (!lib_ams::cd_stream_hb_EmptyQ()) { // fstep:lib_ams.FDb.cd_stream_hb
        if (lib_ams::_db.cd_stream_hb_next < algo_lib::_db.clock) {
            u64 effective_delay = lib_ams::_db.cd_stream_hb_delay / u64_Max(1,lib_ams::cd_stream_hb_N());
            lib_ams::_db.cd_stream_hb_next = algo_lib::_db.clock + algo::SchedTime(effective_delay);
            lib_ams::cd_stream_hb_Step(); // steptype:InlineRecur: call function every N clock cycles
            cd_stream_hb_UpdateCycles();
        }
        algo_lib::_db.next_loop.value = u64_Min(lib_ams::_db.cd_stream_hb_next, algo_lib::_db.next_loop);
    }
}

// --- lib_ams.FDb.cd_stream_hb.SetDelay
// Set inter-step delay to specified value.
// The difference between new delay and current delay is added to the next scheduled time.
void lib_ams::cd_stream_hb_SetDelay(algo::SchedTime delay) {
    i64 diff = delay.value - lib_ams::_db.cd_stream_hb_delay.value;
    lib_ams::_db.cd_stream_hb_delay = delay;
    if (diff > 0) {
        lib_ams::_db.cd_stream_hb_next.value += diff;
    } else {
        lib_ams::_db.cd_stream_hb_next.value = algo::u64_SubClip(lib_ams::_db.cd_stream_hb_next.value,-diff);
    }
}

// --- lib_ams.FDb.cd_poll_read.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::cd_poll_read_Insert(lib_ams::FStream& row) {
    if (!cd_poll_read_InLlistQ(row)) {
        if (_db.cd_poll_read_head) {
            row.cd_poll_read_next = _db.cd_poll_read_head;
            row.cd_poll_read_prev = _db.cd_poll_read_head->cd_poll_read_prev;
            row.cd_poll_read_prev->cd_poll_read_next = &row;
            row.cd_poll_read_next->cd_poll_read_prev = &row;
        } else {
            row.cd_poll_read_next = &row;
            row.cd_poll_read_prev = &row;
            _db.cd_poll_read_head = &row;
        }
        _db.cd_poll_read_n++;
        if (_db.cd_poll_read_head == &row) {
            cd_poll_read_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_poll_read.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::cd_poll_read_Remove(lib_ams::FStream& row) {
    if (cd_poll_read_InLlistQ(row)) {
        lib_ams::FStream* old_head       = _db.cd_poll_read_head;
        (void)old_head; // in case it's not used
        lib_ams::FStream *oldnext = row.cd_poll_read_next;
        lib_ams::FStream *oldprev = row.cd_poll_read_prev;
        oldnext->cd_poll_read_prev = oldprev; // remove element from list
        oldprev->cd_poll_read_next = oldnext;
        _db.cd_poll_read_n--;  // adjust count
        if (&row == _db.cd_poll_read_head) {
            _db.cd_poll_read_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_poll_read_next = (lib_ams::FStream*)-1; // mark element as not-in-list);
        row.cd_poll_read_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_poll_read_head) {
            cd_poll_read_FirstChanged();
        }
    }
}

// --- lib_ams.FDb.cd_poll_read.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::cd_poll_read_RemoveAll() {
    lib_ams::FStream* row = _db.cd_poll_read_head;
    lib_ams::FStream* head = _db.cd_poll_read_head;
    _db.cd_poll_read_head = NULL;
    _db.cd_poll_read_n = 0;
    bool do_fire = (NULL != row);
    while (row) {
        lib_ams::FStream* row_next = row->cd_poll_read_next;
        row->cd_poll_read_next  = (lib_ams::FStream*)-1;
        row->cd_poll_read_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_poll_read_FirstChanged();
    }
}

// --- lib_ams.FDb.cd_poll_read.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
lib_ams::FStream* lib_ams::cd_poll_read_RemoveFirst() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_poll_read_head;
    if (row) {
        bool hasmore = row!=row->cd_poll_read_next;
        _db.cd_poll_read_head = hasmore ? row->cd_poll_read_next : NULL;
        row->cd_poll_read_next->cd_poll_read_prev = row->cd_poll_read_prev;
        row->cd_poll_read_prev->cd_poll_read_next = row->cd_poll_read_next;
        row->cd_poll_read_prev = NULL;
        _db.cd_poll_read_n--;
        row->cd_poll_read_next = (lib_ams::FStream*)-1; // mark as not-in-list
        cd_poll_read_FirstChanged();
    }
    return row;
}

// --- lib_ams.FDb.cd_poll_read.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
lib_ams::FStream* lib_ams::cd_poll_read_RotateFirst() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_poll_read_head;
    if (row) {
        _db.cd_poll_read_head = row->cd_poll_read_next;
    }
    return row;
}

// --- lib_ams.FDb.cd_poll_read.FirstChanged
// First element of index changed.
static void lib_ams::cd_poll_read_FirstChanged() {
}

// --- lib_ams.FDb.cd_poll_read.UpdateCycles
// Update cycles count from previous clock capture
inline static void lib_ams::cd_poll_read_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- lib_ams.FDb.cd_poll_read.Call
inline static void lib_ams::cd_poll_read_Call() {
    if (!lib_ams::cd_poll_read_EmptyQ()) { // fstep:lib_ams.FDb.cd_poll_read
        lib_ams::cd_poll_read_Step(); // steptype:Inline: call function on every step
        cd_poll_read_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- lib_ams.FDb.proc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_ams::FProc& lib_ams::proc_Alloc() {
    lib_ams::FProc* row = proc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_ams.out_of_mem  field:lib_ams.FDb.proc  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_ams.FDb.proc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_ams::FProc* lib_ams::proc_AllocMaybe() {
    lib_ams::FProc *row = (lib_ams::FProc*)proc_AllocMem();
    if (row) {
        new (row) lib_ams::FProc; // call constructor
    }
    return row;
}

// --- lib_ams.FDb.proc.Delete
// Remove row from all global and cross indices, then deallocate row
void lib_ams::proc_Delete(lib_ams::FProc &row) {
    row.~FProc();
    proc_FreeMem(row);
}

// --- lib_ams.FDb.proc.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* lib_ams::proc_AllocMem() {
    lib_ams::FProc *row = _db.proc_free;
    if (UNLIKELY(!row)) {
        proc_Reserve(1);
        row = _db.proc_free;
    }
    if (row) {
        _db.proc_free = row->proc_next;
    }
    return row;
}

// --- lib_ams.FDb.proc.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void lib_ams::proc_FreeMem(lib_ams::FProc &row) {
    if (UNLIKELY(row.proc_next != (lib_ams::FProc*)-1)) {
        FatalErrorExit("lib_ams.tpool_double_delete  pool:lib_ams.FDb.proc  comment:'double deletion caught'");
    }
    row.proc_next = _db.proc_free; // insert into free list
    _db.proc_free  = &row;
}

// --- lib_ams.FDb.proc.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 lib_ams::proc_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.proc_blocksize; // underlying allocator is probably Lpool
        u64 reserved = proc_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- lib_ams.FDb.proc.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 lib_ams::proc_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(lib_ams::FProc)) {
        lib_ams::FProc *mem = (lib_ams::FProc*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(lib_ams::FProc) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].proc_next = _db.proc_free;
            _db.proc_free = mem+i;
        }
    }
    return ret;
}

// --- lib_ams.FDb.proc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::proc_XrefMaybe(lib_ams::FProc &row) {
    bool retval = true;
    (void)row;
    // insert proc into index ind_proc
    if (true) { // user-defined insert condition
        bool success = ind_proc_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "lib_ams.duplicate_key  xref:lib_ams.FDb.ind_proc"; // check for duplicate key
            return false;
        }
    }
    // insert proc into index zd_proc
    if (true) { // user-defined insert condition
        zd_proc_Insert(row);
    }
    return retval;
}

// --- lib_ams.FDb.ind_proc.Find
// Find row by key. Return NULL if not found.
lib_ams::FProc* lib_ams::ind_proc_Find(ams::ProcId key) {
    u32 index = ams::ProcId_Hash(0, key) & (_db.ind_proc_buckets_n - 1);
    lib_ams::FProc* *e = &_db.ind_proc_buckets_elems[index];
    lib_ams::FProc* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).proc_id == key;
        if (done) break;
        e         = &ret->ind_proc_next;
    } while (true);
    return ret;
}

// --- lib_ams.FDb.ind_proc.FindX
// Look up row by key and return reference. Throw exception if not found
lib_ams::FProc& lib_ams::ind_proc_FindX(ams::ProcId key) {
    lib_ams::FProc* ret = ind_proc_Find(key);
    vrfy(ret, tempstr() << "lib_ams.key_error  table:ind_proc  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- lib_ams.FDb.ind_proc.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
lib_ams::FProc& lib_ams::ind_proc_GetOrCreate(ams::ProcId key) {
    lib_ams::FProc* ret = ind_proc_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &proc_Alloc();
        (*ret).proc_id = key;
        bool good = proc_XrefMaybe(*ret);
        if (!good) {
            proc_Delete(*ret); // delete offending row, any existin xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "lib_ams.create_error  table:ind_proc  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- lib_ams.FDb.ind_proc.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool lib_ams::ind_proc_InsertMaybe(lib_ams::FProc& row) {
    ind_proc_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_proc_next == (lib_ams::FProc*)-1)) {// check if in hash already
        u32 index = ams::ProcId_Hash(0, row.proc_id) & (_db.ind_proc_buckets_n - 1);
        lib_ams::FProc* *prev = &_db.ind_proc_buckets_elems[index];
        do {
            lib_ams::FProc* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).proc_id == row.proc_id) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_proc_next;
        } while (true);
        if (retval) {
            row.ind_proc_next = *prev;
            _db.ind_proc_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_proc.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void lib_ams::ind_proc_Remove(lib_ams::FProc& row) {
    if (LIKELY(row.ind_proc_next != (lib_ams::FProc*)-1)) {// check if in hash already
        u32 index = ams::ProcId_Hash(0, row.proc_id) & (_db.ind_proc_buckets_n - 1);
        lib_ams::FProc* *prev = &_db.ind_proc_buckets_elems[index]; // addr of pointer to current element
        while (lib_ams::FProc *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_proc_next; // unlink (singly linked list)
                _db.ind_proc_n--;
                row.ind_proc_next = (lib_ams::FProc*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_proc_next;
        }
    }
}

// --- lib_ams.FDb.ind_proc.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void lib_ams::ind_proc_Reserve(int n) {
    u32 old_nbuckets = _db.ind_proc_buckets_n;
    u32 new_nelems   = _db.ind_proc_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(lib_ams::FProc*);
        u32 new_size = new_nbuckets * sizeof(lib_ams::FProc*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        lib_ams::FProc* *new_buckets = (lib_ams::FProc**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("lib_ams.out_of_memory  field:lib_ams.FDb.ind_proc");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_proc_buckets_n; i++) {
            lib_ams::FProc* elem = _db.ind_proc_buckets_elems[i];
            while (elem) {
                lib_ams::FProc &row        = *elem;
                lib_ams::FProc* next       = row.ind_proc_next;
                u32 index          = ams::ProcId_Hash(0, row.proc_id) & (new_nbuckets-1);
                row.ind_proc_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_proc_buckets_elems, old_size);
        _db.ind_proc_buckets_elems = new_buckets;
        _db.ind_proc_buckets_n = new_nbuckets;
    }
}

// --- lib_ams.FDb.member.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_ams::FMember& lib_ams::member_Alloc() {
    lib_ams::FMember* row = member_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_ams.out_of_mem  field:lib_ams.FDb.member  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_ams.FDb.member.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_ams::FMember* lib_ams::member_AllocMaybe() {
    lib_ams::FMember *row = (lib_ams::FMember*)member_AllocMem();
    if (row) {
        new (row) lib_ams::FMember; // call constructor
    }
    return row;
}

// --- lib_ams.FDb.member.Delete
// Remove row from all global and cross indices, then deallocate row
void lib_ams::member_Delete(lib_ams::FMember &row) {
    row.~FMember();
    member_FreeMem(row);
}

// --- lib_ams.FDb.member.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* lib_ams::member_AllocMem() {
    lib_ams::FMember *row = _db.member_free;
    if (UNLIKELY(!row)) {
        member_Reserve(1);
        row = _db.member_free;
    }
    if (row) {
        _db.member_free = row->member_next;
    }
    return row;
}

// --- lib_ams.FDb.member.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void lib_ams::member_FreeMem(lib_ams::FMember &row) {
    if (UNLIKELY(row.member_next != (lib_ams::FMember*)-1)) {
        FatalErrorExit("lib_ams.tpool_double_delete  pool:lib_ams.FDb.member  comment:'double deletion caught'");
    }
    row.member_next = _db.member_free; // insert into free list
    _db.member_free  = &row;
}

// --- lib_ams.FDb.member.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 lib_ams::member_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.member_blocksize; // underlying allocator is probably Lpool
        u64 reserved = member_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- lib_ams.FDb.member.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 lib_ams::member_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(lib_ams::FMember)) {
        lib_ams::FMember *mem = (lib_ams::FMember*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(lib_ams::FMember) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].member_next = _db.member_free;
            _db.member_free = mem+i;
        }
    }
    return ret;
}

// --- lib_ams.FDb.member.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::member_XrefMaybe(lib_ams::FMember &row) {
    bool retval = true;
    (void)row;
    lib_ams::FStream* p_stream_id = lib_ams::ind_stream_Find(row.member.stream_id);
    if (UNLIKELY(!p_stream_id)) {
        algo_lib::ResetErrtext() << "lib_ams.bad_xref  index:lib_ams.FDb.ind_stream" << Keyval("key", row.member.stream_id);
        return false;
    }
    // member: save pointer to stream_id
    if (true) { // user-defined insert condition
        row.p_stream = p_stream_id;
    }
    lib_ams::FProc* p_proc_id = lib_ams::ind_proc_Find(row.member.proc_id);
    if (UNLIKELY(!p_proc_id)) {
        algo_lib::ResetErrtext() << "lib_ams.bad_xref  index:lib_ams.FDb.ind_proc" << Keyval("key", row.member.proc_id);
        return false;
    }
    // member: save pointer to proc_id
    if (true) { // user-defined insert condition
        row.p_proc = p_proc_id;
    }
    // insert member into index ind_member
    if (true) { // user-defined insert condition
        bool success = ind_member_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "lib_ams.duplicate_key  xref:lib_ams.FDb.ind_member"; // check for duplicate key
            return false;
        }
    }
    // insert member into index zd_member_bystream
    if (true) { // user-defined insert condition
        zd_member_bystream_Insert(*p_stream_id, row);
    }
    // insert member into index zd_member_byproc
    if (true) { // user-defined insert condition
        zd_member_byproc_Insert(*p_proc_id, row);
    }
    return retval;
}

// --- lib_ams.FDb.ind_member.Find
// Find row by key. Return NULL if not found.
lib_ams::FMember* lib_ams::ind_member_Find(ams::Member key) {
    u32 index = ams::Member_Hash(0, key) & (_db.ind_member_buckets_n - 1);
    lib_ams::FMember* *e = &_db.ind_member_buckets_elems[index];
    lib_ams::FMember* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).member == key;
        if (done) break;
        e         = &ret->ind_member_next;
    } while (true);
    return ret;
}

// --- lib_ams.FDb.ind_member.FindX
// Look up row by key and return reference. Throw exception if not found
lib_ams::FMember& lib_ams::ind_member_FindX(ams::Member key) {
    lib_ams::FMember* ret = ind_member_Find(key);
    vrfy(ret, tempstr() << "lib_ams.key_error  table:ind_member  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- lib_ams.FDb.ind_member.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool lib_ams::ind_member_InsertMaybe(lib_ams::FMember& row) {
    ind_member_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_member_next == (lib_ams::FMember*)-1)) {// check if in hash already
        u32 index = ams::Member_Hash(0, row.member) & (_db.ind_member_buckets_n - 1);
        lib_ams::FMember* *prev = &_db.ind_member_buckets_elems[index];
        do {
            lib_ams::FMember* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).member == row.member) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_member_next;
        } while (true);
        if (retval) {
            row.ind_member_next = *prev;
            _db.ind_member_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_member.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void lib_ams::ind_member_Remove(lib_ams::FMember& row) {
    if (LIKELY(row.ind_member_next != (lib_ams::FMember*)-1)) {// check if in hash already
        u32 index = ams::Member_Hash(0, row.member) & (_db.ind_member_buckets_n - 1);
        lib_ams::FMember* *prev = &_db.ind_member_buckets_elems[index]; // addr of pointer to current element
        while (lib_ams::FMember *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_member_next; // unlink (singly linked list)
                _db.ind_member_n--;
                row.ind_member_next = (lib_ams::FMember*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_member_next;
        }
    }
}

// --- lib_ams.FDb.ind_member.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void lib_ams::ind_member_Reserve(int n) {
    u32 old_nbuckets = _db.ind_member_buckets_n;
    u32 new_nelems   = _db.ind_member_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(lib_ams::FMember*);
        u32 new_size = new_nbuckets * sizeof(lib_ams::FMember*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        lib_ams::FMember* *new_buckets = (lib_ams::FMember**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("lib_ams.out_of_memory  field:lib_ams.FDb.ind_member");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_member_buckets_n; i++) {
            lib_ams::FMember* elem = _db.ind_member_buckets_elems[i];
            while (elem) {
                lib_ams::FMember &row        = *elem;
                lib_ams::FMember* next       = row.ind_member_next;
                u32 index          = ams::Member_Hash(0, row.member) & (new_nbuckets-1);
                row.ind_member_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_member_buckets_elems, old_size);
        _db.ind_member_buckets_elems = new_buckets;
        _db.ind_member_buckets_n = new_nbuckets;
    }
}

// --- lib_ams.FDb.streamtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_ams::FStreamType& lib_ams::streamtype_Alloc() {
    lib_ams::FStreamType* row = streamtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_ams.out_of_mem  field:lib_ams.FDb.streamtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_ams.FDb.streamtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_ams::FStreamType* lib_ams::streamtype_AllocMaybe() {
    lib_ams::FStreamType *row = (lib_ams::FStreamType*)streamtype_AllocMem();
    if (row) {
        new (row) lib_ams::FStreamType; // call constructor
    }
    return row;
}

// --- lib_ams.FDb.streamtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
lib_ams::FStreamType* lib_ams::streamtype_InsertMaybe(const amsdb::StreamType &value) {
    lib_ams::FStreamType *row = &streamtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    streamtype_CopyIn(*row,const_cast<amsdb::StreamType&>(value));
    bool ok = streamtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        streamtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- lib_ams.FDb.streamtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* lib_ams::streamtype_AllocMem() {
    u64 new_nelems     = _db.streamtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    lib_ams::FStreamType*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.streamtype_lary[bsr];
        if (!lev) {
            lev=(lib_ams::FStreamType*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStreamType) * (u64(1)<<bsr));
            _db.streamtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.streamtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- lib_ams.FDb.streamtype.RemoveAll
// Remove all elements from Lary
void lib_ams::streamtype_RemoveAll() {
    for (u64 n = _db.streamtype_n; n>0; ) {
        n--;
        streamtype_qFind(u64(n)).~FStreamType(); // destroy last element
        _db.streamtype_n = i32(n);
    }
}

// --- lib_ams.FDb.streamtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::streamtype_RemoveLast() {
    u64 n = _db.streamtype_n;
    if (n > 0) {
        n -= 1;
        streamtype_qFind(u64(n)).~FStreamType();
        _db.streamtype_n = i32(n);
    }
}

// --- lib_ams.FDb.streamtype.LoadStatic
static void lib_ams::streamtype_LoadStatic() {
    static struct _t {
        const char *s;
    } data[] = {
        { "amsdb.streamtype  streamtype:0  id:0  comment:\"No stream\"" }
        ,{ "amsdb.streamtype  streamtype:ctl  id:1  comment:\"AMS control messages\"" }
        ,{ "amsdb.streamtype  streamtype:io  id:5  comment:\"Messages intended for file output\"" }
        ,{ "amsdb.streamtype  streamtype:out  id:2  comment:\"Log messages, alarms\"" }
        ,{ "amsdb.streamtype  streamtype:trace  id:6  comment:\"Trace messages\"" }
        ,{NULL}
    };
    (void)data;
    amsdb::StreamType streamtype;
    for (int i=0; data[i].s; i++) {
        (void)amsdb::StreamType_ReadStrptrMaybe(streamtype, algo::strptr(data[i].s));
        lib_ams::FStreamType *elem = streamtype_InsertMaybe(streamtype);
        (void)elem;
    }
}

// --- lib_ams.FDb.streamtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_ams::streamtype_XrefMaybe(lib_ams::FStreamType &row) {
    bool retval = true;
    (void)row;
    // insert streamtype into index ind_streamtype
    if (true) { // user-defined insert condition
        bool success = ind_streamtype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "lib_ams.duplicate_key  xref:lib_ams.FDb.ind_streamtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_streamtype.Find
// Find row by key. Return NULL if not found.
lib_ams::FStreamType* lib_ams::ind_streamtype_Find(ams::StreamType key) {
    u32 index = ams::StreamType_Hash(0, key) & (_db.ind_streamtype_buckets_n - 1);
    lib_ams::FStreamType* *e = &_db.ind_streamtype_buckets_elems[index];
    lib_ams::FStreamType* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).id == key;
        if (done) break;
        e         = &ret->ind_streamtype_next;
    } while (true);
    return ret;
}

// --- lib_ams.FDb.ind_streamtype.FindX
// Look up row by key and return reference. Throw exception if not found
lib_ams::FStreamType& lib_ams::ind_streamtype_FindX(ams::StreamType key) {
    lib_ams::FStreamType* ret = ind_streamtype_Find(key);
    vrfy(ret, tempstr() << "lib_ams.key_error  table:ind_streamtype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- lib_ams.FDb.ind_streamtype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
lib_ams::FStreamType& lib_ams::ind_streamtype_GetOrCreate(ams::StreamType key) {
    lib_ams::FStreamType* ret = ind_streamtype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &streamtype_Alloc();
        (*ret).id = key;
        bool good = streamtype_XrefMaybe(*ret);
        if (!good) {
            streamtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "lib_ams.create_error  table:ind_streamtype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- lib_ams.FDb.ind_streamtype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool lib_ams::ind_streamtype_InsertMaybe(lib_ams::FStreamType& row) {
    ind_streamtype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_streamtype_next == (lib_ams::FStreamType*)-1)) {// check if in hash already
        u32 index = ams::StreamType_Hash(0, row.id) & (_db.ind_streamtype_buckets_n - 1);
        lib_ams::FStreamType* *prev = &_db.ind_streamtype_buckets_elems[index];
        if (retval) {
            row.ind_streamtype_next = *prev;
            _db.ind_streamtype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- lib_ams.FDb.ind_streamtype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void lib_ams::ind_streamtype_Remove(lib_ams::FStreamType& row) {
    if (LIKELY(row.ind_streamtype_next != (lib_ams::FStreamType*)-1)) {// check if in hash already
        u32 index = ams::StreamType_Hash(0, row.id) & (_db.ind_streamtype_buckets_n - 1);
        lib_ams::FStreamType* *prev = &_db.ind_streamtype_buckets_elems[index]; // addr of pointer to current element
        while (lib_ams::FStreamType *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_streamtype_next; // unlink (singly linked list)
                _db.ind_streamtype_n--;
                row.ind_streamtype_next = (lib_ams::FStreamType*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_streamtype_next;
        }
    }
}

// --- lib_ams.FDb.ind_streamtype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void lib_ams::ind_streamtype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_streamtype_buckets_n;
    u32 new_nelems   = _db.ind_streamtype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(lib_ams::FStreamType*);
        u32 new_size = new_nbuckets * sizeof(lib_ams::FStreamType*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        lib_ams::FStreamType* *new_buckets = (lib_ams::FStreamType**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("lib_ams.out_of_memory  field:lib_ams.FDb.ind_streamtype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_streamtype_buckets_n; i++) {
            lib_ams::FStreamType* elem = _db.ind_streamtype_buckets_elems[i];
            while (elem) {
                lib_ams::FStreamType &row        = *elem;
                lib_ams::FStreamType* next       = row.ind_streamtype_next;
                u32 index          = ams::StreamType_Hash(0, row.id) & (new_nbuckets-1);
                row.ind_streamtype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_streamtype_buckets_elems, old_size);
        _db.ind_streamtype_buckets_elems = new_buckets;
        _db.ind_streamtype_buckets_n = new_nbuckets;
    }
}

// --- lib_ams.FDb.zd_ctlin.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::zd_ctlin_Insert(lib_ams::FStream& row) {
    if (!zd_ctlin_InLlistQ(row)) {
        lib_ams::FStream* old_tail = _db.zd_ctlin_tail;
        row.zd_ctlin_next = NULL;
        row.zd_ctlin_prev = old_tail;
        _db.zd_ctlin_tail = &row;
        lib_ams::FStream **new_row_a = &old_tail->zd_ctlin_next;
        lib_ams::FStream **new_row_b = &_db.zd_ctlin_head;
        lib_ams::FStream **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_ctlin_n++;
    }
}

// --- lib_ams.FDb.zd_ctlin.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::zd_ctlin_Remove(lib_ams::FStream& row) {
    if (zd_ctlin_InLlistQ(row)) {
        lib_ams::FStream* old_head       = _db.zd_ctlin_head;
        (void)old_head; // in case it's not used
        lib_ams::FStream* prev = row.zd_ctlin_prev;
        lib_ams::FStream* next = row.zd_ctlin_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        lib_ams::FStream **new_next_a = &prev->zd_ctlin_next;
        lib_ams::FStream **new_next_b = &_db.zd_ctlin_head;
        lib_ams::FStream **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        lib_ams::FStream **new_prev_a = &next->zd_ctlin_prev;
        lib_ams::FStream **new_prev_b = &_db.zd_ctlin_tail;
        lib_ams::FStream **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_ctlin_n--;
        row.zd_ctlin_next=(lib_ams::FStream*)-1; // not-in-list
    }
}

// --- lib_ams.FDb.zd_ctlin.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::zd_ctlin_RemoveAll() {
    lib_ams::FStream* row = _db.zd_ctlin_head;
    _db.zd_ctlin_head = NULL;
    _db.zd_ctlin_tail = NULL;
    _db.zd_ctlin_n = 0;
    while (row) {
        lib_ams::FStream* row_next = row->zd_ctlin_next;
        row->zd_ctlin_next  = (lib_ams::FStream*)-1;
        row->zd_ctlin_prev  = NULL;
        row = row_next;
    }
}

// --- lib_ams.FDb.zd_ctlin.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
lib_ams::FStream* lib_ams::zd_ctlin_RemoveFirst() {
    lib_ams::FStream *row = NULL;
    row = _db.zd_ctlin_head;
    if (row) {
        lib_ams::FStream *next = row->zd_ctlin_next;
        _db.zd_ctlin_head = next;
        lib_ams::FStream **new_end_a = &next->zd_ctlin_prev;
        lib_ams::FStream **new_end_b = &_db.zd_ctlin_tail;
        lib_ams::FStream **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_ctlin_n--;
        row->zd_ctlin_next = (lib_ams::FStream*)-1; // mark as not-in-list
    }
    return row;
}

// --- lib_ams.FDb.zd_proc.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::zd_proc_Insert(lib_ams::FProc& row) {
    if (!zd_proc_InLlistQ(row)) {
        lib_ams::FProc* old_tail = _db.zd_proc_tail;
        row.zd_proc_next = NULL;
        row.zd_proc_prev = old_tail;
        _db.zd_proc_tail = &row;
        lib_ams::FProc **new_row_a = &old_tail->zd_proc_next;
        lib_ams::FProc **new_row_b = &_db.zd_proc_head;
        lib_ams::FProc **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_proc_n++;
    }
}

// --- lib_ams.FDb.zd_proc.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::zd_proc_Remove(lib_ams::FProc& row) {
    if (zd_proc_InLlistQ(row)) {
        lib_ams::FProc* old_head       = _db.zd_proc_head;
        (void)old_head; // in case it's not used
        lib_ams::FProc* prev = row.zd_proc_prev;
        lib_ams::FProc* next = row.zd_proc_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        lib_ams::FProc **new_next_a = &prev->zd_proc_next;
        lib_ams::FProc **new_next_b = &_db.zd_proc_head;
        lib_ams::FProc **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        lib_ams::FProc **new_prev_a = &next->zd_proc_prev;
        lib_ams::FProc **new_prev_b = &_db.zd_proc_tail;
        lib_ams::FProc **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_proc_n--;
        row.zd_proc_next=(lib_ams::FProc*)-1; // not-in-list
    }
}

// --- lib_ams.FDb.zd_proc.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::zd_proc_RemoveAll() {
    lib_ams::FProc* row = _db.zd_proc_head;
    _db.zd_proc_head = NULL;
    _db.zd_proc_tail = NULL;
    _db.zd_proc_n = 0;
    while (row) {
        lib_ams::FProc* row_next = row->zd_proc_next;
        row->zd_proc_next  = (lib_ams::FProc*)-1;
        row->zd_proc_prev  = NULL;
        row = row_next;
    }
}

// --- lib_ams.FDb.zd_proc.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
lib_ams::FProc* lib_ams::zd_proc_RemoveFirst() {
    lib_ams::FProc *row = NULL;
    row = _db.zd_proc_head;
    if (row) {
        lib_ams::FProc *next = row->zd_proc_next;
        _db.zd_proc_head = next;
        lib_ams::FProc **new_end_a = &next->zd_proc_prev;
        lib_ams::FProc **new_end_b = &_db.zd_proc_tail;
        lib_ams::FProc **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_proc_n--;
        row->zd_proc_next = (lib_ams::FProc*)-1; // mark as not-in-list
    }
    return row;
}

// --- lib_ams.FDb.regx_trace.Print
// Print back to string
void lib_ams::regx_trace_Print(algo::cstring &out) {
    Regx_Print(_db.regx_trace, out);
}

// --- lib_ams.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr lib_ams::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- lib_ams.FDb.trace.N
// Function return 1
inline static i32 lib_ams::trace_N() {
    return 1;
}

// --- lib_ams.FDb..Init
// Set all fields to initial values.
void lib_ams::FDb_Init() {
    // initialize LAry fdin (lib_ams.FDb.fdin)
    _db.fdin_n = 0;
    memset(_db.fdin_lary, 0, sizeof(_db.fdin_lary)); // zero out all level pointers
    lib_ams::FFdin* fdin_first = (lib_ams::FFdin*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FFdin) * (u64(1)<<4));
    if (!fdin_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fdin_lary[i]  = fdin_first;
        fdin_first    += 1ULL<<i;
    }
    _db.cd_fdin_eof_head = NULL; // (lib_ams.FDb.cd_fdin_eof)
    _db.cd_fdin_eof_n = 0; // (lib_ams.FDb.cd_fdin_eof)
    _db.cd_fdin_read_head = NULL; // (lib_ams.FDb.cd_fdin_read)
    _db.cd_fdin_read_n = 0; // (lib_ams.FDb.cd_fdin_read)
    _db.zd_flush_head = NULL; // (lib_ams.FDb.zd_flush)
    _db.zd_flush_n = 0; // (lib_ams.FDb.zd_flush)
    _db.zd_flush_tail = NULL; // (lib_ams.FDb.zd_flush)
    lib_ams::_db.zd_flush_delay = algo::ToSchedTime(0.1); // initialize fstep delay (lib_ams.FDb.zd_flush)
    // initialize LAry stream (lib_ams.FDb.stream)
    _db.stream_n = 0;
    memset(_db.stream_lary, 0, sizeof(_db.stream_lary)); // zero out all level pointers
    lib_ams::FStream* stream_first = (lib_ams::FStream*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStream) * (u64(1)<<4));
    if (!stream_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.stream_lary[i]  = stream_first;
        stream_first    += 1ULL<<i;
    }
    // initialize hash table for lib_ams::FStream;
    _db.ind_stream_n             	= 0; // (lib_ams.FDb.ind_stream)
    _db.ind_stream_buckets_n     	= 4; // (lib_ams.FDb.ind_stream)
    _db.ind_stream_buckets_elems 	= (lib_ams::FStream**)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStream*)*_db.ind_stream_buckets_n); // initial buckets (lib_ams.FDb.ind_stream)
    if (!_db.ind_stream_buckets_elems) {
        FatalErrorExit("out of memory"); // (lib_ams.FDb.ind_stream)
    }
    memset(_db.ind_stream_buckets_elems, 0, sizeof(lib_ams::FStream*)*_db.ind_stream_buckets_n); // (lib_ams.FDb.ind_stream)
    _db.cd_stream_hb_head = NULL; // (lib_ams.FDb.cd_stream_hb)
    _db.cd_stream_hb_n = 0; // (lib_ams.FDb.cd_stream_hb)
    lib_ams::_db.cd_stream_hb_delay = algo::ToSchedTime(1); // initialize fstep delay (lib_ams.FDb.cd_stream_hb)
    _db.shmem_size = i32(32768);
    _db.max_msg_size = i32(4096);
    _db.cd_poll_read_head = NULL; // (lib_ams.FDb.cd_poll_read)
    _db.cd_poll_read_n = 0; // (lib_ams.FDb.cd_poll_read)
    _db.file_prefix = algo::strptr("");
    // proc: initialize Tpool
    _db.proc_free      = NULL;
    _db.proc_blocksize = algo::BumpToPow2(64 * sizeof(lib_ams::FProc)); // allocate 64-127 elements at a time
    // initialize hash table for lib_ams::FProc;
    _db.ind_proc_n             	= 0; // (lib_ams.FDb.ind_proc)
    _db.ind_proc_buckets_n     	= 4; // (lib_ams.FDb.ind_proc)
    _db.ind_proc_buckets_elems 	= (lib_ams::FProc**)algo_lib::malloc_AllocMem(sizeof(lib_ams::FProc*)*_db.ind_proc_buckets_n); // initial buckets (lib_ams.FDb.ind_proc)
    if (!_db.ind_proc_buckets_elems) {
        FatalErrorExit("out of memory"); // (lib_ams.FDb.ind_proc)
    }
    memset(_db.ind_proc_buckets_elems, 0, sizeof(lib_ams::FProc*)*_db.ind_proc_buckets_n); // (lib_ams.FDb.ind_proc)
    // member: initialize Tpool
    _db.member_free      = NULL;
    _db.member_blocksize = algo::BumpToPow2(64 * sizeof(lib_ams::FMember)); // allocate 64-127 elements at a time
    // initialize hash table for lib_ams::FMember;
    _db.ind_member_n             	= 0; // (lib_ams.FDb.ind_member)
    _db.ind_member_buckets_n     	= 4; // (lib_ams.FDb.ind_member)
    _db.ind_member_buckets_elems 	= (lib_ams::FMember**)algo_lib::malloc_AllocMem(sizeof(lib_ams::FMember*)*_db.ind_member_buckets_n); // initial buckets (lib_ams.FDb.ind_member)
    if (!_db.ind_member_buckets_elems) {
        FatalErrorExit("out of memory"); // (lib_ams.FDb.ind_member)
    }
    memset(_db.ind_member_buckets_elems, 0, sizeof(lib_ams::FMember*)*_db.ind_member_buckets_n); // (lib_ams.FDb.ind_member)
    // initialize LAry streamtype (lib_ams.FDb.streamtype)
    _db.streamtype_n = 0;
    memset(_db.streamtype_lary, 0, sizeof(_db.streamtype_lary)); // zero out all level pointers
    lib_ams::FStreamType* streamtype_first = (lib_ams::FStreamType*)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStreamType) * (u64(1)<<4));
    if (!streamtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.streamtype_lary[i]  = streamtype_first;
        streamtype_first    += 1ULL<<i;
    }
    // initialize hash table for lib_ams::FStreamType;
    _db.ind_streamtype_n             	= 0; // (lib_ams.FDb.ind_streamtype)
    _db.ind_streamtype_buckets_n     	= 4; // (lib_ams.FDb.ind_streamtype)
    _db.ind_streamtype_buckets_elems 	= (lib_ams::FStreamType**)algo_lib::malloc_AllocMem(sizeof(lib_ams::FStreamType*)*_db.ind_streamtype_buckets_n); // initial buckets (lib_ams.FDb.ind_streamtype)
    if (!_db.ind_streamtype_buckets_elems) {
        FatalErrorExit("out of memory"); // (lib_ams.FDb.ind_streamtype)
    }
    memset(_db.ind_streamtype_buckets_elems, 0, sizeof(lib_ams::FStreamType*)*_db.ind_streamtype_buckets_n); // (lib_ams.FDb.ind_streamtype)
    _db.zd_ctlin_head = NULL; // (lib_ams.FDb.zd_ctlin)
    _db.zd_ctlin_n = 0; // (lib_ams.FDb.zd_ctlin)
    _db.zd_ctlin_tail = NULL; // (lib_ams.FDb.zd_ctlin)
    _db.stream_files_cleaned = bool(false);
    _db.shmem_mode = bool(false);
    _db.zd_proc_head = NULL; // (lib_ams.FDb.zd_proc)
    _db.zd_proc_n = 0; // (lib_ams.FDb.zd_proc)
    _db.zd_proc_tail = NULL; // (lib_ams.FDb.zd_proc)
    _db.c_stream_ctl = NULL;
    _db.expect_pos = i32(0);
    _db.expect_timeout = double(10.0);
    _db.c_stream_out = NULL;

    lib_ams::InitReflection();
    streamtype_LoadStatic(); // gen:ns_gstatic  gstatic:lib_ams.FDb.streamtype  load lib_ams.FStreamType records
}

// --- lib_ams.FDb..Uninit
void lib_ams::FDb_Uninit() {
    lib_ams::FDb &row = _db; (void)row;

    // lib_ams.FDb.ind_streamtype.Uninit (Thash)  //
    // skip destruction of ind_streamtype in global scope

    // lib_ams.FDb.streamtype.Uninit (Lary)  //
    // skip destruction in global scope

    // lib_ams.FDb.ind_member.Uninit (Thash)  //
    // skip destruction of ind_member in global scope

    // lib_ams.FDb.ind_proc.Uninit (Thash)  //
    // skip destruction of ind_proc in global scope

    // lib_ams.FDb.ind_stream.Uninit (Thash)  //Index of streams by stream id
    // skip destruction of ind_stream in global scope

    // lib_ams.FDb.stream.Uninit (Lary)  //Table of streams
    // skip destruction in global scope

    // lib_ams.FDb.fdin.Uninit (Lary)  //ams control messages on stdin
    // skip destruction in global scope
}

// --- lib_ams.FFdin.in.BeginRead
// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by lib_ams::FFdin.in via FIohook field.
// Whenever the file descriptor becomes readable, insert fdin into cd_fdin_read.
void lib_ams::in_BeginRead(lib_ams::FFdin& fdin, algo::Fildes fd) {
    callback_Set1(fdin.in_iohook, fdin, lib_ams::cd_fdin_read_Insert);
    fdin.in_iohook.fildes = fd;
    IOEvtFlags flags;
    read_Set(flags, true);
    if (fdin.in_epoll_enable) {
        algo_lib::IohookAdd(fdin.in_iohook, flags);
    } else {
        lib_ams::cd_fdin_read_Insert(fdin);
    }
}

// --- lib_ams.FFdin.in.EndRead
// Set EOF flag
void lib_ams::in_EndRead(lib_ams::FFdin& fdin) {
    if (ValidQ(fdin.in_iohook.fildes)) {
        fdin.in_eof = true;
        lib_ams::cd_fdin_read_Insert(fdin);
    }
}

// --- lib_ams.FFdin.in.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
// 
algo::aryptr<char> lib_ams::in_GetMsg(lib_ams::FFdin& fdin) {
    algo::aryptr<char> ret;
    if (!fdin.in_msgvalid) {
        in_Scanmsg(fdin);
        if (!fdin.in_msgvalid) {
            bool readable = in_Refill(fdin);
            if (readable) {
                in_Scanmsg(fdin);
            }
        }
    }
    char *hdr = (char*)(fdin.in_elems + fdin.in_start);
    if (fdin.in_msgvalid) {
        ret.elems = hdr;
        ret.n_elems = fdin.in_msglen;
    }
    if (!fdin.in_msgvalid && fdin.in_eof) { // all messages processed
        lib_ams::cd_fdin_eof_Insert(fdin);
    }
    return ret;
}

// --- lib_ams.FFdin.in.Refill
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
bool lib_ams::in_Refill(lib_ams::FFdin& fdin) {
    bool readable = ValidQ(fdin.in_iohook.fildes);
    if (readable) {
        int fd     = fdin.in_iohook.fildes.value;
        i32 max    = in_Max(fdin);
        i32 end    = fdin.in_end;
        i32 nbytes = end - fdin.in_start; // # bytes currently in buffer
        i32 nfree  = max - end; // bytes available at the end of buffer
        if (nbytes == 0 || nfree == 0) { // make more room for reading (or take advantage of free shift)
            in_Shift(fdin);
            end = fdin.in_end;
            nfree = max - end;
        }
        ssize_t ret         = read(fd, fdin.in_elems + end, nfree);
        readable            = !(ret < 0 && errno == EAGAIN);
        bool error          = ret < 0 && errno != EAGAIN; // detect permanent error on this fd
        bool eof            = error || (ret == 0 && nfree > 0);
        fdin.in_end += i32_Max(ret,0); // new end of bytes
        if (error) {
            fdin.in_err = algo::FromErrno(errno); // fetch errno
        }
        fdin.in_eof |= eof;
    }
    if (!readable && fdin.in_epoll_enable) {
        lib_ams::cd_fdin_read_Remove(fdin);
    }
    return readable;
}

// --- lib_ams.FFdin.in.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void lib_ams::in_RemoveAll(lib_ams::FFdin& fdin) {
    fdin.in_start    = 0;
    fdin.in_end      = 0;
    fdin.in_msgvalid = false;
    fdin.in_msglen   = 0; // reset message length -- important for delimited streams
}

// --- lib_ams.FFdin.in.Scanmsg
// Internal function to scan for a message
// 
static void lib_ams::in_Scanmsg(lib_ams::FFdin& fdin) {
    char *hdr = (char*)(fdin.in_elems + fdin.in_start);
    i32 avail = in_N(fdin);
    i32 msglen;
    bool found = false;
    // scan for delimiter starting from the previous place where we left off.
    // at the end, save offset back to fdin so we don't have to re-scan.
    // returned message length **does not include delimiter**.
    // a line that exceeds buffer length is not returned.
    for (msglen = fdin.in_msglen; msglen < avail; msglen += sizeof(char)) {
        if (hdr[msglen] == '\n') { // delimiter?
            found = true;
            break;
        }
    }
    if (!found && msglen >= in_Max(fdin)) {
        fdin.in_eof = true; // cause user to detect eof
        fdin.in_err = algo::FromErrno(E2BIG); // argument list too big -- closest error code
    }
    fdin.in_msglen = msglen;
    fdin.in_msgvalid = found;
}

// --- lib_ams.FFdin.in.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void lib_ams::in_Shift(lib_ams::FFdin& fdin) {
    i32 start = fdin.in_start;
    i32 bytes_n = fdin.in_end - start;
    if (bytes_n > 0) {
        memmove(fdin.in_elems, fdin.in_elems + start, bytes_n);
    }
    fdin.in_end = bytes_n;
    fdin.in_start = 0;
}

// --- lib_ams.FFdin.in.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void lib_ams::in_SkipBytes(lib_ams::FFdin& fdin, int n) {
    int avail = fdin.in_end - fdin.in_start;
    n = i32_Min(n,avail);
    fdin.in_start += n;
}

// --- lib_ams.FFdin.in.SkipMsg
// Skip current message, if any
// Skip current message, if any.
void lib_ams::in_SkipMsg(lib_ams::FFdin& fdin) {
    if (fdin.in_msgvalid) {
        int skip = fdin.in_msglen;
        skip += ssizeof(char); // delimiter
        i32 start = fdin.in_start;
        start += skip;
        fdin.in_start = start;
        fdin.in_msgvalid = false;
        fdin.in_msglen   = 0; // reset message length -- important for delimited streams
    }
}

// --- lib_ams.FFdin.in.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool lib_ams::in_WriteAll(lib_ams::FFdin& fdin, u8 *in, i32 in_n) {
    int max = in_Max(fdin);
    // check if message doesn't fit. if so, shift bytes over.
    if (fdin.in_end + in_n > max) {
        in_Shift(fdin);
    }
    // now try to write the message.
    i32 end = fdin.in_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(fdin.in_elems + end, in, in_n);
        fdin.in_end = end + in_n;
    }
    return fits;
}

// --- lib_ams.FFdin..Init
// Set all fields to initial values.
void lib_ams::FFdin_Init(lib_ams::FFdin& fdin) {
    fdin.in_end = 0; // in: initialize
    fdin.in_start = 0; // in: initialize
    fdin.in_eof = false; // in: initialize
    fdin.in_msgvalid = false; // in: initialize
    fdin.in_msglen = 0; // in: initialize
    fdin.in_epoll_enable = true; // in: initialize
    fdin.cd_fdin_eof_next = (lib_ams::FFdin*)-1; // (lib_ams.FDb.cd_fdin_eof) not-in-list
    fdin.cd_fdin_eof_prev = NULL; // (lib_ams.FDb.cd_fdin_eof)
    fdin.cd_fdin_read_next = (lib_ams::FFdin*)-1; // (lib_ams.FDb.cd_fdin_read) not-in-list
    fdin.cd_fdin_read_prev = NULL; // (lib_ams.FDb.cd_fdin_read)
}

// --- lib_ams.FFdin..Uninit
void lib_ams::FFdin_Uninit(lib_ams::FFdin& fdin) {
    lib_ams::FFdin &row = fdin; (void)row;
    cd_fdin_eof_Remove(row); // remove fdin from index cd_fdin_eof
    cd_fdin_read_Remove(row); // remove fdin from index cd_fdin_read
}

// --- lib_ams.FMember..Uninit
void lib_ams::FMember_Uninit(lib_ams::FMember& member) {
    lib_ams::FMember &row = member; (void)row;
    ind_member_Remove(row); // remove member from index ind_member
    lib_ams::FStream* p_stream_id = lib_ams::ind_stream_Find(row.member.stream_id);
    if (p_stream_id)  {
        zd_member_bystream_Remove(*p_stream_id, row);// remove member from index zd_member_bystream
    }
    lib_ams::FProc* p_proc_id = lib_ams::ind_proc_Find(row.member.proc_id);
    if (p_proc_id)  {
        zd_member_byproc_Remove(*p_proc_id, row);// remove member from index zd_member_byproc
    }
}

// --- lib_ams.FProc.zd_member_byproc.Cascdel
// Delete all elements in the linked list.
void lib_ams::zd_member_byproc_Cascdel(lib_ams::FProc& proc) {
    while (lib_ams::FMember *zd_member_byproc_first = zd_member_byproc_First(proc)) {
        member_Delete(*zd_member_byproc_first);
    }
}

// --- lib_ams.FProc.zd_member_byproc.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::zd_member_byproc_Insert(lib_ams::FProc& proc, lib_ams::FMember& row) {
    if (!zd_member_byproc_InLlistQ(row)) {
        lib_ams::FMember* old_tail = proc.zd_member_byproc_tail;
        row.zd_member_byproc_next = NULL;
        row.zd_member_byproc_prev = old_tail;
        proc.zd_member_byproc_tail = &row;
        lib_ams::FMember **new_row_a = &old_tail->zd_member_byproc_next;
        lib_ams::FMember **new_row_b = &proc.zd_member_byproc_head;
        lib_ams::FMember **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        proc.zd_member_byproc_n++;
    }
}

// --- lib_ams.FProc.zd_member_byproc.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::zd_member_byproc_Remove(lib_ams::FProc& proc, lib_ams::FMember& row) {
    if (zd_member_byproc_InLlistQ(row)) {
        lib_ams::FMember* old_head       = proc.zd_member_byproc_head;
        (void)old_head; // in case it's not used
        lib_ams::FMember* prev = row.zd_member_byproc_prev;
        lib_ams::FMember* next = row.zd_member_byproc_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        lib_ams::FMember **new_next_a = &prev->zd_member_byproc_next;
        lib_ams::FMember **new_next_b = &proc.zd_member_byproc_head;
        lib_ams::FMember **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        lib_ams::FMember **new_prev_a = &next->zd_member_byproc_prev;
        lib_ams::FMember **new_prev_b = &proc.zd_member_byproc_tail;
        lib_ams::FMember **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        proc.zd_member_byproc_n--;
        row.zd_member_byproc_next=(lib_ams::FMember*)-1; // not-in-list
    }
}

// --- lib_ams.FProc.zd_member_byproc.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::zd_member_byproc_RemoveAll(lib_ams::FProc& proc) {
    lib_ams::FMember* row = proc.zd_member_byproc_head;
    proc.zd_member_byproc_head = NULL;
    proc.zd_member_byproc_tail = NULL;
    proc.zd_member_byproc_n = 0;
    while (row) {
        lib_ams::FMember* row_next = row->zd_member_byproc_next;
        row->zd_member_byproc_next  = (lib_ams::FMember*)-1;
        row->zd_member_byproc_prev  = NULL;
        row = row_next;
    }
}

// --- lib_ams.FProc.zd_member_byproc.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
lib_ams::FMember* lib_ams::zd_member_byproc_RemoveFirst(lib_ams::FProc& proc) {
    lib_ams::FMember *row = NULL;
    row = proc.zd_member_byproc_head;
    if (row) {
        lib_ams::FMember *next = row->zd_member_byproc_next;
        proc.zd_member_byproc_head = next;
        lib_ams::FMember **new_end_a = &next->zd_member_byproc_prev;
        lib_ams::FMember **new_end_b = &proc.zd_member_byproc_tail;
        lib_ams::FMember **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        proc.zd_member_byproc_n--;
        row->zd_member_byproc_next = (lib_ams::FMember*)-1; // mark as not-in-list
    }
    return row;
}

// --- lib_ams.FProc..Uninit
void lib_ams::FProc_Uninit(lib_ams::FProc& proc) {
    lib_ams::FProc &row = proc; (void)row;
    zd_member_byproc_Cascdel(proc); // dmmeta.cascdel:lib_ams.FProc.zd_member_byproc
    ind_proc_Remove(row); // remove proc from index ind_proc
    zd_proc_Remove(row); // remove proc from index zd_proc
}

// --- lib_ams.FReadfile.buf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& lib_ams::buf_Alloc(lib_ams::FReadfile& parent) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    int at = n;
    u8 *elems = parent.buf_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.buf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& lib_ams::buf_AllocAt(lib_ams::FReadfile& parent, int at) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("lib_ams.bad_alloc_at  field:lib_ams.FReadfile.buf  comment:'index out of range'");
    }
    u8 *elems = parent.buf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.buf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::buf_AllocN(lib_ams::FReadfile& parent, int n_elems) {
    buf_Reserve(parent, n_elems);
    int old_n  = parent.buf_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.buf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.buf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile.buf.Remove
// Remove item by index. If index outside of range, do nothing.
void lib_ams::buf_Remove(lib_ams::FReadfile& parent, u32 i) {
    u32 lim = parent.buf_n;
    u8 *elems = parent.buf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        parent.buf_n = lim - 1;
    }
}

// --- lib_ams.FReadfile.buf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::buf_RemoveLast(lib_ams::FReadfile& parent) {
    u64 n = parent.buf_n;
    if (n > 0) {
        n -= 1;
        parent.buf_n = n;
    }
}

// --- lib_ams.FReadfile.buf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void lib_ams::buf_AbsReserve(lib_ams::FReadfile& parent, int n) {
    u32 old_max  = parent.buf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.buf_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_ams.tary_nomem  field:lib_ams.FReadfile.buf  comment:'out of memory'");
        }
        parent.buf_elems = (u8*)new_mem;
        parent.buf_max = new_max;
    }
}

// --- lib_ams.FReadfile.buf.Setary
// Copy contents of RHS to PARENT.
void lib_ams::buf_Setary(lib_ams::FReadfile& parent, lib_ams::FReadfile &rhs) {
    buf_RemoveAll(parent);
    int nnew = rhs.buf_n;
    buf_Reserve(parent, nnew); // reserve space
    memcpy(parent.buf_elems, rhs.buf_elems, nnew * sizeof(u8));
    parent.buf_n = nnew;
}

// --- lib_ams.FReadfile.buf.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::buf_AllocNVal(lib_ams::FReadfile& parent, int n_elems, const u8& val) {
    buf_Reserve(parent, n_elems);
    int old_n  = parent.buf_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.buf_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.buf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile.cbuf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& lib_ams::cbuf_Alloc(lib_ams::FReadfile& parent) {
    cbuf_Reserve(parent, 1);
    int n  = parent.cbuf_n;
    int at = n;
    u8 *elems = parent.cbuf_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    parent.cbuf_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.cbuf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& lib_ams::cbuf_AllocAt(lib_ams::FReadfile& parent, int at) {
    cbuf_Reserve(parent, 1);
    int n  = parent.cbuf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("lib_ams.bad_alloc_at  field:lib_ams.FReadfile.cbuf  comment:'index out of range'");
    }
    u8 *elems = parent.cbuf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    parent.cbuf_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.cbuf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::cbuf_AllocN(lib_ams::FReadfile& parent, int n_elems) {
    cbuf_Reserve(parent, n_elems);
    int old_n  = parent.cbuf_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.cbuf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.cbuf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile.cbuf.Remove
// Remove item by index. If index outside of range, do nothing.
void lib_ams::cbuf_Remove(lib_ams::FReadfile& parent, u32 i) {
    u32 lim = parent.cbuf_n;
    u8 *elems = parent.cbuf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        parent.cbuf_n = lim - 1;
    }
}

// --- lib_ams.FReadfile.cbuf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::cbuf_RemoveLast(lib_ams::FReadfile& parent) {
    u64 n = parent.cbuf_n;
    if (n > 0) {
        n -= 1;
        parent.cbuf_n = n;
    }
}

// --- lib_ams.FReadfile.cbuf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void lib_ams::cbuf_AbsReserve(lib_ams::FReadfile& parent, int n) {
    u32 old_max  = parent.cbuf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.cbuf_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_ams.tary_nomem  field:lib_ams.FReadfile.cbuf  comment:'out of memory'");
        }
        parent.cbuf_elems = (u8*)new_mem;
        parent.cbuf_max = new_max;
    }
}

// --- lib_ams.FReadfile.cbuf.Setary
// Copy contents of RHS to PARENT.
void lib_ams::cbuf_Setary(lib_ams::FReadfile& parent, lib_ams::FReadfile &rhs) {
    cbuf_RemoveAll(parent);
    int nnew = rhs.cbuf_n;
    cbuf_Reserve(parent, nnew); // reserve space
    memcpy(parent.cbuf_elems, rhs.cbuf_elems, nnew * sizeof(u8));
    parent.cbuf_n = nnew;
}

// --- lib_ams.FReadfile.cbuf.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::cbuf_AllocNVal(lib_ams::FReadfile& parent, int n_elems, const u8& val) {
    cbuf_Reserve(parent, n_elems);
    int old_n  = parent.cbuf_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.cbuf_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.cbuf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile.offset.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u32& lib_ams::offset_Alloc(lib_ams::FReadfile& parent) {
    offset_Reserve(parent, 1);
    int n  = parent.offset_n;
    int at = n;
    u32 *elems = parent.offset_elems;
    new (elems + at) u32(0); // construct new element, default initializer
    parent.offset_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.offset.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u32& lib_ams::offset_AllocAt(lib_ams::FReadfile& parent, int at) {
    offset_Reserve(parent, 1);
    int n  = parent.offset_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("lib_ams.bad_alloc_at  field:lib_ams.FReadfile.offset  comment:'index out of range'");
    }
    u32 *elems = parent.offset_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u32));
    new (elems + at) u32(0); // construct element, default initializer
    parent.offset_n = n+1;
    return elems[at];
}

// --- lib_ams.FReadfile.offset.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u32> lib_ams::offset_AllocN(lib_ams::FReadfile& parent, int n_elems) {
    offset_Reserve(parent, n_elems);
    int old_n  = parent.offset_n;
    int new_n = old_n + n_elems;
    u32 *elems = parent.offset_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u32(0); // construct new element, default initialize
    }
    parent.offset_n = new_n;
    return algo::aryptr<u32>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile.offset.Remove
// Remove item by index. If index outside of range, do nothing.
void lib_ams::offset_Remove(lib_ams::FReadfile& parent, u32 i) {
    u32 lim = parent.offset_n;
    u32 *elems = parent.offset_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u32) * (lim - (i + 1)));
        parent.offset_n = lim - 1;
    }
}

// --- lib_ams.FReadfile.offset.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::offset_RemoveLast(lib_ams::FReadfile& parent) {
    u64 n = parent.offset_n;
    if (n > 0) {
        n -= 1;
        parent.offset_n = n;
    }
}

// --- lib_ams.FReadfile.offset.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void lib_ams::offset_AbsReserve(lib_ams::FReadfile& parent, int n) {
    u32 old_max  = parent.offset_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.offset_elems, old_max * sizeof(u32), new_max * sizeof(u32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_ams.tary_nomem  field:lib_ams.FReadfile.offset  comment:'out of memory'");
        }
        parent.offset_elems = (u32*)new_mem;
        parent.offset_max = new_max;
    }
}

// --- lib_ams.FReadfile.offset.Setary
// Copy contents of RHS to PARENT.
void lib_ams::offset_Setary(lib_ams::FReadfile& parent, lib_ams::FReadfile &rhs) {
    offset_RemoveAll(parent);
    int nnew = rhs.offset_n;
    offset_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.offset_elems + i) u32(offset_qFind(rhs, i));
        parent.offset_n = i + 1;
    }
}

// --- lib_ams.FReadfile.offset.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u32> lib_ams::offset_AllocNVal(lib_ams::FReadfile& parent, int n_elems, const u32& val) {
    offset_Reserve(parent, n_elems);
    int old_n  = parent.offset_n;
    int new_n = old_n + n_elems;
    u32 *elems = parent.offset_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u32(val);
    }
    parent.offset_n = new_n;
    return algo::aryptr<u32>(elems + old_n, n_elems);
}

// --- lib_ams.FReadfile..Uninit
void lib_ams::FReadfile_Uninit(lib_ams::FReadfile& parent) {
    lib_ams::FReadfile &row = parent; (void)row;
    fd_Cleanup(parent); // dmmeta.fcleanup:lib_ams.FReadfile.fd

    // lib_ams.FReadfile.offset.Uninit (Tary)  //
    // remove all elements from lib_ams.FReadfile.offset
    offset_RemoveAll(parent);
    // free memory for Tary lib_ams.FReadfile.offset
    algo_lib::malloc_FreeMem(parent.offset_elems, sizeof(u32)*parent.offset_max); // (lib_ams.FReadfile.offset)

    // lib_ams.FReadfile.cbuf.Uninit (Tary)  //Compressed buffer
    // remove all elements from lib_ams.FReadfile.cbuf
    cbuf_RemoveAll(parent);
    // free memory for Tary lib_ams.FReadfile.cbuf
    algo_lib::malloc_FreeMem(parent.cbuf_elems, sizeof(u8)*parent.cbuf_max); // (lib_ams.FReadfile.cbuf)

    // lib_ams.FReadfile.buf.Uninit (Tary)  //Message buffer
    // remove all elements from lib_ams.FReadfile.buf
    buf_RemoveAll(parent);
    // free memory for Tary lib_ams.FReadfile.buf
    algo_lib::malloc_FreeMem(parent.buf_elems, sizeof(u8)*parent.buf_max); // (lib_ams.FReadfile.buf)
}

// --- lib_ams.FReadfile..Print
// print string representation of lib_ams::FReadfile to string LHS, no header -- cprint:lib_ams.FReadfile.String
void lib_ams::FReadfile_Print(lib_ams::FReadfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_ams.FReadfile";

    algo::cstring_Print(row.filename, temp);
    PrintAttrSpaceReset(str,"filename", temp);

    bool_Print(row.eof, temp);
    PrintAttrSpaceReset(str,"eof", temp);

    bool_Print(row.fail, temp);
    PrintAttrSpaceReset(str,"fail", temp);

    ams::MsgBlock_Print(row.block, temp);
    PrintAttrSpaceReset(str,"block", temp);
}

// --- lib_ams.FStream.zd_member_bystream.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void lib_ams::zd_member_bystream_Insert(lib_ams::FStream& stream, lib_ams::FMember& row) {
    if (!zd_member_bystream_InLlistQ(row)) {
        lib_ams::FMember* old_tail = stream.zd_member_bystream_tail;
        row.zd_member_bystream_next = NULL;
        row.zd_member_bystream_prev = old_tail;
        stream.zd_member_bystream_tail = &row;
        lib_ams::FMember **new_row_a = &old_tail->zd_member_bystream_next;
        lib_ams::FMember **new_row_b = &stream.zd_member_bystream_head;
        lib_ams::FMember **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        stream.zd_member_bystream_n++;
    }
}

// --- lib_ams.FStream.zd_member_bystream.Remove
// Remove element from index. If element is not in index, do nothing.
void lib_ams::zd_member_bystream_Remove(lib_ams::FStream& stream, lib_ams::FMember& row) {
    if (zd_member_bystream_InLlistQ(row)) {
        lib_ams::FMember* old_head       = stream.zd_member_bystream_head;
        (void)old_head; // in case it's not used
        lib_ams::FMember* prev = row.zd_member_bystream_prev;
        lib_ams::FMember* next = row.zd_member_bystream_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        lib_ams::FMember **new_next_a = &prev->zd_member_bystream_next;
        lib_ams::FMember **new_next_b = &stream.zd_member_bystream_head;
        lib_ams::FMember **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        lib_ams::FMember **new_prev_a = &next->zd_member_bystream_prev;
        lib_ams::FMember **new_prev_b = &stream.zd_member_bystream_tail;
        lib_ams::FMember **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        stream.zd_member_bystream_n--;
        row.zd_member_bystream_next=(lib_ams::FMember*)-1; // not-in-list
    }
}

// --- lib_ams.FStream.zd_member_bystream.RemoveAll
// Empty the index. (The rows are not deleted)
void lib_ams::zd_member_bystream_RemoveAll(lib_ams::FStream& stream) {
    lib_ams::FMember* row = stream.zd_member_bystream_head;
    stream.zd_member_bystream_head = NULL;
    stream.zd_member_bystream_tail = NULL;
    stream.zd_member_bystream_n = 0;
    while (row) {
        lib_ams::FMember* row_next = row->zd_member_bystream_next;
        row->zd_member_bystream_next  = (lib_ams::FMember*)-1;
        row->zd_member_bystream_prev  = NULL;
        row = row_next;
    }
}

// --- lib_ams.FStream.zd_member_bystream.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
lib_ams::FMember* lib_ams::zd_member_bystream_RemoveFirst(lib_ams::FStream& stream) {
    lib_ams::FMember *row = NULL;
    row = stream.zd_member_bystream_head;
    if (row) {
        lib_ams::FMember *next = row->zd_member_bystream_next;
        stream.zd_member_bystream_head = next;
        lib_ams::FMember **new_end_a = &next->zd_member_bystream_prev;
        lib_ams::FMember **new_end_b = &stream.zd_member_bystream_tail;
        lib_ams::FMember **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        stream.zd_member_bystream_n--;
        row->zd_member_bystream_next = (lib_ams::FMember*)-1; // mark as not-in-list
    }
    return row;
}

// --- lib_ams.FStream..Init
// Set all fields to initial values.
void lib_ams::FStream_Init(lib_ams::FStream& stream) {
    stream.shm_handle = NULL;
    stream.limit = u64(0);
    stream.offset_mask = u64(0);
    stream.cur_msg = NULL;
    stream.zd_member_bystream_head = NULL; // (lib_ams.FStream.zd_member_bystream)
    stream.zd_member_bystream_n = 0; // (lib_ams.FStream.zd_member_bystream)
    stream.zd_member_bystream_tail = NULL; // (lib_ams.FStream.zd_member_bystream)
    stream.next_ackoff = u64(1023);
    stream.p_streamtype = NULL;
    stream.n_write_block = u32(0);
    stream.burst = i32(20);
    stream.writer_error = bool(false);
    stream.ind_stream_next = (lib_ams::FStream*)-1; // (lib_ams.FDb.ind_stream) not-in-hash
    stream.cd_stream_hb_next = (lib_ams::FStream*)-1; // (lib_ams.FDb.cd_stream_hb) not-in-list
    stream.cd_stream_hb_prev = NULL; // (lib_ams.FDb.cd_stream_hb)
    stream.cd_poll_read_next = (lib_ams::FStream*)-1; // (lib_ams.FDb.cd_poll_read) not-in-list
    stream.cd_poll_read_prev = NULL; // (lib_ams.FDb.cd_poll_read)
    stream.zd_ctlin_next = (lib_ams::FStream*)-1; // (lib_ams.FDb.zd_ctlin) not-in-list
    stream.zd_ctlin_prev = NULL; // (lib_ams.FDb.zd_ctlin)
    stream.h_msg = NULL;
    stream.h_msg_ctx = 0;
    stream.h_msg_orig = NULL;
    stream.h_msg_orig_ctx = 0;
}

// --- lib_ams.FStream..Uninit
void lib_ams::FStream_Uninit(lib_ams::FStream& stream) {
    lib_ams::FStream &row = stream; (void)row;
    ind_stream_Remove(row); // remove stream from index ind_stream
    cd_stream_hb_Remove(row); // remove stream from index cd_stream_hb
    cd_poll_read_Remove(row); // remove stream from index cd_poll_read
    zd_ctlin_Remove(row); // remove stream from index zd_ctlin
    shm_handle_Cleanup(stream); // dmmeta.fcleanup:lib_ams.FStream.shm_handle
    shm_file_Cleanup(stream); // dmmeta.fcleanup:lib_ams.FStream.shm_file
}

// --- lib_ams.FStreamType.base.CopyOut
// Copy fields out of row
void lib_ams::streamtype_CopyOut(lib_ams::FStreamType &row, amsdb::StreamType &out) {
    out.streamtype = row.streamtype;
    out.id = row.id;
    out.comment = row.comment;
}

// --- lib_ams.FStreamType.base.CopyIn
// Copy fields in to row
void lib_ams::streamtype_CopyIn(lib_ams::FStreamType &row, amsdb::StreamType &in) {
    row.streamtype = in.streamtype;
    row.id = in.id;
    row.comment = in.comment;
}

// --- lib_ams.FStreamType..Uninit
void lib_ams::FStreamType_Uninit(lib_ams::FStreamType& streamtype) {
    lib_ams::FStreamType &row = streamtype; (void)row;
    ind_streamtype_Remove(row); // remove streamtype from index ind_streamtype
}

// --- lib_ams.FWritefile.buf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& lib_ams::buf_Alloc(lib_ams::FWritefile& writefile) {
    buf_Reserve(writefile, 1);
    int n  = writefile.buf_n;
    int at = n;
    u8 *elems = writefile.buf_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    writefile.buf_n = n+1;
    return elems[at];
}

// --- lib_ams.FWritefile.buf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& lib_ams::buf_AllocAt(lib_ams::FWritefile& writefile, int at) {
    buf_Reserve(writefile, 1);
    int n  = writefile.buf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("lib_ams.bad_alloc_at  field:lib_ams.FWritefile.buf  comment:'index out of range'");
    }
    u8 *elems = writefile.buf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    writefile.buf_n = n+1;
    return elems[at];
}

// --- lib_ams.FWritefile.buf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::buf_AllocN(lib_ams::FWritefile& writefile, int n_elems) {
    buf_Reserve(writefile, n_elems);
    int old_n  = writefile.buf_n;
    int new_n = old_n + n_elems;
    u8 *elems = writefile.buf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    writefile.buf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FWritefile.buf.Remove
// Remove item by index. If index outside of range, do nothing.
void lib_ams::buf_Remove(lib_ams::FWritefile& writefile, u32 i) {
    u32 lim = writefile.buf_n;
    u8 *elems = writefile.buf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        writefile.buf_n = lim - 1;
    }
}

// --- lib_ams.FWritefile.buf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::buf_RemoveLast(lib_ams::FWritefile& writefile) {
    u64 n = writefile.buf_n;
    if (n > 0) {
        n -= 1;
        writefile.buf_n = n;
    }
}

// --- lib_ams.FWritefile.buf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void lib_ams::buf_AbsReserve(lib_ams::FWritefile& writefile, int n) {
    u32 old_max  = writefile.buf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(writefile.buf_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_ams.tary_nomem  field:lib_ams.FWritefile.buf  comment:'out of memory'");
        }
        writefile.buf_elems = (u8*)new_mem;
        writefile.buf_max = new_max;
    }
}

// --- lib_ams.FWritefile.buf.Setary
// Copy contents of RHS to PARENT.
void lib_ams::buf_Setary(lib_ams::FWritefile& writefile, lib_ams::FWritefile &rhs) {
    buf_RemoveAll(writefile);
    int nnew = rhs.buf_n;
    buf_Reserve(writefile, nnew); // reserve space
    memcpy(writefile.buf_elems, rhs.buf_elems, nnew * sizeof(u8));
    writefile.buf_n = nnew;
}

// --- lib_ams.FWritefile.buf.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::buf_AllocNVal(lib_ams::FWritefile& writefile, int n_elems, const u8& val) {
    buf_Reserve(writefile, n_elems);
    int old_n  = writefile.buf_n;
    int new_n = old_n + n_elems;
    u8 *elems = writefile.buf_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    writefile.buf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FWritefile.cbuf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& lib_ams::cbuf_Alloc(lib_ams::FWritefile& writefile) {
    cbuf_Reserve(writefile, 1);
    int n  = writefile.cbuf_n;
    int at = n;
    u8 *elems = writefile.cbuf_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    writefile.cbuf_n = n+1;
    return elems[at];
}

// --- lib_ams.FWritefile.cbuf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& lib_ams::cbuf_AllocAt(lib_ams::FWritefile& writefile, int at) {
    cbuf_Reserve(writefile, 1);
    int n  = writefile.cbuf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("lib_ams.bad_alloc_at  field:lib_ams.FWritefile.cbuf  comment:'index out of range'");
    }
    u8 *elems = writefile.cbuf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    writefile.cbuf_n = n+1;
    return elems[at];
}

// --- lib_ams.FWritefile.cbuf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::cbuf_AllocN(lib_ams::FWritefile& writefile, int n_elems) {
    cbuf_Reserve(writefile, n_elems);
    int old_n  = writefile.cbuf_n;
    int new_n = old_n + n_elems;
    u8 *elems = writefile.cbuf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    writefile.cbuf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FWritefile.cbuf.Remove
// Remove item by index. If index outside of range, do nothing.
void lib_ams::cbuf_Remove(lib_ams::FWritefile& writefile, u32 i) {
    u32 lim = writefile.cbuf_n;
    u8 *elems = writefile.cbuf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        writefile.cbuf_n = lim - 1;
    }
}

// --- lib_ams.FWritefile.cbuf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void lib_ams::cbuf_RemoveLast(lib_ams::FWritefile& writefile) {
    u64 n = writefile.cbuf_n;
    if (n > 0) {
        n -= 1;
        writefile.cbuf_n = n;
    }
}

// --- lib_ams.FWritefile.cbuf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void lib_ams::cbuf_AbsReserve(lib_ams::FWritefile& writefile, int n) {
    u32 old_max  = writefile.cbuf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(writefile.cbuf_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_ams.tary_nomem  field:lib_ams.FWritefile.cbuf  comment:'out of memory'");
        }
        writefile.cbuf_elems = (u8*)new_mem;
        writefile.cbuf_max = new_max;
    }
}

// --- lib_ams.FWritefile.cbuf.Setary
// Copy contents of RHS to PARENT.
void lib_ams::cbuf_Setary(lib_ams::FWritefile& writefile, lib_ams::FWritefile &rhs) {
    cbuf_RemoveAll(writefile);
    int nnew = rhs.cbuf_n;
    cbuf_Reserve(writefile, nnew); // reserve space
    memcpy(writefile.cbuf_elems, rhs.cbuf_elems, nnew * sizeof(u8));
    writefile.cbuf_n = nnew;
}

// --- lib_ams.FWritefile.cbuf.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> lib_ams::cbuf_AllocNVal(lib_ams::FWritefile& writefile, int n_elems, const u8& val) {
    cbuf_Reserve(writefile, n_elems);
    int old_n  = writefile.cbuf_n;
    int new_n = old_n + n_elems;
    u8 *elems = writefile.cbuf_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    writefile.cbuf_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- lib_ams.FWritefile..Uninit
void lib_ams::FWritefile_Uninit(lib_ams::FWritefile& writefile) {
    lib_ams::FWritefile &row = writefile; (void)row;
    zd_flush_Remove(row); // remove writefile from index zd_flush
    fd_Cleanup(writefile); // dmmeta.fcleanup:lib_ams.FWritefile.fd

    // lib_ams.FWritefile.cbuf.Uninit (Tary)  //Compressed buffer
    // remove all elements from lib_ams.FWritefile.cbuf
    cbuf_RemoveAll(writefile);
    // free memory for Tary lib_ams.FWritefile.cbuf
    algo_lib::malloc_FreeMem(writefile.cbuf_elems, sizeof(u8)*writefile.cbuf_max); // (lib_ams.FWritefile.cbuf)

    // lib_ams.FWritefile.buf.Uninit (Tary)  //Message buffer
    // remove all elements from lib_ams.FWritefile.buf
    buf_RemoveAll(writefile);
    // free memory for Tary lib_ams.FWritefile.buf
    algo_lib::malloc_FreeMem(writefile.buf_elems, sizeof(u8)*writefile.buf_max); // (lib_ams.FWritefile.buf)
}

// --- lib_ams.FWritefile..Print
// print string representation of lib_ams::FWritefile to string LHS, no header -- cprint:lib_ams.FWritefile.String
void lib_ams::FWritefile_Print(lib_ams::FWritefile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_ams.FWritefile";

    algo::cstring_Print(row.filename, temp);
    PrintAttrSpaceReset(str,"filename", temp);

    bool_Print(row.fail, temp);
    PrintAttrSpaceReset(str,"fail", temp);

    u32_Print(row.buf_thr, temp);
    PrintAttrSpaceReset(str,"buf_thr", temp);

    ams::MsgBlock_Print(row.block, temp);
    PrintAttrSpaceReset(str,"block", temp);
}

// --- lib_ams.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_ams::value_ToCstr(const lib_ams::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case lib_ams_FieldId_value         : ret = "value";  break;
    }
    return ret;
}

// --- lib_ams.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void lib_ams::value_Print(const lib_ams::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- lib_ams.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_ams::value_SetStrptrMaybe(lib_ams::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,lib_ams_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_ams.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_ams::value_SetStrptr(lib_ams::FieldId& parent, algo::strptr rhs, lib_ams_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- lib_ams.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool lib_ams::value_ReadStrptrMaybe(lib_ams::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- lib_ams.FieldId..ReadStrptrMaybe
// Read fields of lib_ams::FieldId from an ascii string.
// The format of the string is the format of the lib_ams::FieldId's only field
bool lib_ams::FieldId_ReadStrptrMaybe(lib_ams::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && lib_ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- lib_ams.FieldId..Print
// print string representation of lib_ams::FieldId to string LHS, no header -- cprint:lib_ams.FieldId.String
void lib_ams::FieldId_Print(lib_ams::FieldId & row, algo::cstring &str) {
    lib_ams::value_Print(row, str);
}

// --- lib_ams...SizeCheck
inline static void lib_ams::SizeCheck() {
}

// --- lib_ams.CtlMsg..DispatchRaw
int lib_ams::CtlMsgDispatchRaw(lib_ams::CtlMsgCase type, u8 *msg, u32 len) {
    int ret = 0;
    switch(type) {
        case 12: if (sizeof(ams::DumpStreamTableMsg) <= len) {
            lib_ams::CtlMsg_DumpStreamTableMsg((ams::DumpStreamTableMsg&)*msg);
            ret = (int)sizeof(ams::DumpStreamTableMsg);
        } break;
        case 4: if (sizeof(ams::ProcAddMsg) <= len) {
            lib_ams::CtlMsg_ProcAddMsg((ams::ProcAddMsg&)*msg);
            ret = (int)sizeof(ams::ProcAddMsg);
        } break;
        case 5: if (sizeof(ams::ProcRemoveMsg) <= len) {
            lib_ams::CtlMsg_ProcRemoveMsg((ams::ProcRemoveMsg&)*msg);
            ret = (int)sizeof(ams::ProcRemoveMsg);
        } break;
        case 3: if (sizeof(ams::StreamHbMsg) <= len) {
            lib_ams::CtlMsg_StreamHbMsg((ams::StreamHbMsg&)*msg);
            ret = (int)sizeof(ams::StreamHbMsg);
        } break;
        default:
        break;
    }
    return ret;
}

// --- lib_ams.CtlMsg..Dispatch
int lib_ams::CtlMsgDispatch(ams::MsgHeader& msg) {
    return CtlMsgDispatchRaw(lib_ams::CtlMsgCase(msg.type), (u8*)&msg, i32(msg.length));
}

// --- lib_ams.CtlMsg..Dispatch2
// void rettype useful for hooks
void lib_ams::vCtlMsgDispatch(ams::MsgHeader& msg) {
    CtlMsgDispatch(msg);
}

// --- lib_ams...InputLineMsg_FmtByteAry
// Construct a new ams::InputLineMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::InputLineMsg * lib_ams::InputLineMsg_FmtByteAry(algo::ByteAry &buf, algo::aryptr<char > payload) {
    ams::InputLineMsg  *msg = NULL;
    size_t len = sizeof(ams::InputLineMsg);
    u32 ary_len = elems_N(payload) * sizeof(char);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::InputLineMsg*)ary_AllocN(buf,len).elems;
    msg->type = u32(22);
    msg->length = u32(len + (0));
    memcpy(payload_Addr(*msg), payload.elems, ary_len);
    return msg;
}

// --- lib_ams...LogMsg_FmtAmsStream
// Construct a new ams::LogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::LogMsg * lib_ams::LogMsg_FmtAmsStream(lib_ams::FStream &stream, const algo::strptr& logcat, algo::SchedTime tstamp, algo::aryptr<char > text) {
    ams::LogMsg  *msg = NULL;
    size_t len = sizeof(ams::LogMsg);
    u32 ary_len = elems_N(text) * sizeof(char);
    len += ary_len;
    msg = (ams::LogMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(6);
    msg->length = u32(len + (0));
    msg->logcat = logcat;
    msg->tstamp = tstamp;
    memcpy(text_Addr(*msg), text.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...MsgBlock_FmtAmsStream
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::MsgBlock * lib_ams::MsgBlock_FmtAmsStream(lib_ams::FStream &stream, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages) {
    ams::MsgBlock  *msg = NULL;
    size_t len = sizeof(ams::MsgBlock);
    u32 ary_len = elems_N(messages) * sizeof(u8);
    len += ary_len;
    msg = (ams::MsgBlock*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(1);
    msg->length = u32(len + (0));
    msg->first_seqno = first_seqno;
    msg->n_messages = n_messages;
    msg->original_length = original_length;
    memcpy(messages_Addr(*msg), messages.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...OpenMsg_FmtAmsStream
// Construct a new ams::OpenMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::OpenMsg * lib_ams::OpenMsg_FmtAmsStream(lib_ams::FStream &stream, ams::Member member, ams::StreamPos pos) {
    ams::OpenMsg  *msg = NULL;
    size_t len = sizeof(ams::OpenMsg);
    msg = (ams::OpenMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(7);
    msg->length = u32(len + (0));
    msg->member = member;
    msg->pos = pos;
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...PrlogMsg_FmtAmsStream
// Construct a new ams::PrlogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::PrlogMsg * lib_ams::PrlogMsg_FmtAmsStream(lib_ams::FStream &stream, const algo::strptr& logcat, algo::SchedTime tstamp, ams::MsgHeader* data) {
    ams::PrlogMsg  *msg = NULL;
    size_t len = sizeof(ams::PrlogMsg);
    int opt_len = data ? i32(data[0].length) : 0;
    len += opt_len;
    msg = (ams::PrlogMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(229);
    msg->length = u32(len + (0));
    msg->logcat = logcat;
    msg->tstamp = tstamp;
    if (data) {
        memcpy((u8*)msg + sizeof(ams::PrlogMsg), data, opt_len);
    }
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...ProcAddMsg_FmtAmsStream
// Construct a new ams::ProcAddMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::ProcAddMsg * lib_ams::ProcAddMsg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc_id) {
    ams::ProcAddMsg  *msg = NULL;
    size_t len = sizeof(ams::ProcAddMsg);
    msg = (ams::ProcAddMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(4);
    msg->length = u32(len + (0));
    msg->proc_id = proc_id;
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...ProcRemoveMsg_FmtAmsStream
// Construct a new ams::ProcRemoveMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::ProcRemoveMsg * lib_ams::ProcRemoveMsg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc_id) {
    ams::ProcRemoveMsg  *msg = NULL;
    size_t len = sizeof(ams::ProcRemoveMsg);
    msg = (ams::ProcRemoveMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(5);
    msg->length = u32(len + (0));
    msg->proc_id = proc_id;
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...StreamHbMsg_FmtAmsStream
// Construct a new ams::StreamHbMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::StreamHbMsg * lib_ams::StreamHbMsg_FmtAmsStream(lib_ams::FStream &stream, ams::Member member, ams::StreamPos pos, u32 wbudget) {
    ams::StreamHbMsg  *msg = NULL;
    size_t len = sizeof(ams::StreamHbMsg);
    msg = (ams::StreamHbMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(3);
    msg->length = u32(len + (0));
    msg->member = member;
    msg->pos = pos;
    msg->wbudget = wbudget;
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...Trace2Msg_FmtAmsStream
// Construct a new ams::Trace2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::Trace2Msg * lib_ams::Trace2Msg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc, u8 trace, algo::UnTime tstamp, algo::aryptr<u64 > data) {
    ams::Trace2Msg  *msg = NULL;
    size_t len = sizeof(ams::Trace2Msg);
    u32 ary_len = elems_N(data) * sizeof(u64);
    len += ary_len;
    msg = (ams::Trace2Msg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(108);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->trace = trace;
    msg->tstamp = tstamp;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...TraceInfo2Msg_FmtAmsStream
// Construct a new ams::TraceInfo2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceInfo2Msg * lib_ams::TraceInfo2Msg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc, u8 trace, algo::UnTime tstamp, u8 part, algo::aryptr<char > data) {
    ams::TraceInfo2Msg  *msg = NULL;
    size_t len = sizeof(ams::TraceInfo2Msg);
    u32 ary_len = elems_N(data) * sizeof(char);
    len += ary_len;
    msg = (ams::TraceInfo2Msg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(109);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->trace = trace;
    msg->tstamp = tstamp;
    msg->part = part;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...TraceInfoMsg_FmtAmsStream
// Construct a new ams::TraceInfoMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceInfoMsg * lib_ams::TraceInfoMsg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc, algo::UnTime tstamp, u8 part, algo::aryptr<char > data) {
    ams::TraceInfoMsg  *msg = NULL;
    size_t len = sizeof(ams::TraceInfoMsg);
    u32 ary_len = elems_N(data) * sizeof(char);
    len += ary_len;
    msg = (ams::TraceInfoMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(9);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->tstamp = tstamp;
    msg->part = part;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...TraceMsg_FmtAmsStream
// Construct a new ams::TraceMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceMsg * lib_ams::TraceMsg_FmtAmsStream(lib_ams::FStream &stream, ams::ProcId proc, algo::UnTime tstamp, algo::aryptr<u64 > data) {
    ams::TraceMsg  *msg = NULL;
    size_t len = sizeof(ams::TraceMsg);
    u32 ary_len = elems_N(data) * sizeof(u64);
    len += ary_len;
    msg = (ams::TraceMsg*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(8);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->tstamp = tstamp;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}

// --- lib_ams...UdpFrame_FmtAmsStream
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::UdpFrame * lib_ams::UdpFrame_FmtAmsStream(lib_ams::FStream &stream, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload) {
    ams::UdpFrame  *msg = NULL;
    size_t len = sizeof(ams::UdpFrame);
    u32 ary_len = elems_N(payload) * sizeof(u8);
    len += ary_len;
    msg = (ams::UdpFrame*)lib_ams::BeginWrite(stream,int(len));
    if (!msg) {
        return NULL; // no room.
    }
    msg->type = u32(2);
    msg->length = u32(len + (0));
    msg->timestamp = timestamp;
    msg->src_ip = src_ip;
    msg->dst_ip = dst_ip;
    msg->src_port = src_port;
    msg->dst_port = dst_port;
    memcpy(payload_Addr(*msg), payload.elems, ary_len);
    lib_ams::EndWrite(stream,msg,int(len));
    return msg;
}
