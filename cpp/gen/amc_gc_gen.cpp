//
// cpp/gen/amc_gc_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/amc_gc_gen.h"
#include "include/gen/amc_gc_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
amc_gc::FDb     amc_gc::_db;      // dependency found via dev.targdep

namespace amc_gc {
const char *amc_gc_help =
"amc_gc: Empirically eliminate unused records\n"
"Usage: amc_gc [options]\n"
"    -target   string  Target to test-build. default: \"%\"\n"
"    -key      string  ACR query selecting records to eliminate\n"
"    -include          Garbage collect includes for specified target. default: false\n"
"    -in       string  Input directory or filename, - for stdin. default: \"data\"\n"
"    -verbose          Enable verbose mode\n"
"    -debug            Enable debug mode\n"
"    -version          Show version information\n"
"    -sig              Print SHA1 signatures for dispatches\n"
"    -help             Print this screen and exit\n"
;


const char *amc_gc_syntax =
"-target:string=\"%\"\n"
" -key:string=\n"
" -include:flag\n"
" -in:string=\"data\"\n"
;
} // namespace amc_gc
namespace amc_gc {
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // end namespace amc_gc

// --- amc_gc.Acr.acr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int amc_gc::acr_Start(amc_gc::Acr& parent) {
    int retval = 0;
    if (parent.acr_pid == 0) {
        verblog(acr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.acr_path);
        tempstr cmdline(acr_ToCmdline(parent));
        parent.acr_pid = dospawn(Zeroterm(parent.acr_path),Zeroterm(cmdline),parent.acr_timeout,parent.acr_fstdin,parent.acr_fstdout,parent.acr_fstderr);
#else
        parent.acr_pid = fork();
        if (parent.acr_pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.acr_timeout > 0) {
                alarm(parent.acr_timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstderr, 2);
            if (retval==0) retval= acr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("amc_gc.acr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.acr_pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.acr_status = parent.acr_pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- amc_gc.Acr.acr.StartRead
// Start subprocess & Read output
algo::Fildes amc_gc::acr_StartRead(amc_gc::Acr& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.acr_fstdout  << ">&" << pipefd[1];
    acr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- amc_gc.Acr.acr.Kill
// Kill subprocess and wait
void amc_gc::acr_Kill(amc_gc::Acr& parent) {
    if (parent.acr_pid != 0) {
        kill(parent.acr_pid,9);
        acr_Wait(parent);
    }
}

// --- amc_gc.Acr.acr.Wait
// Wait for subprocess to return
void amc_gc::acr_Wait(amc_gc::Acr& parent) {
    if (parent.acr_pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.acr_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.acr_pid) {
            parent.acr_status = wait_status;
            parent.acr_pid = 0;
        }
    }
}

// --- amc_gc.Acr.acr.Exec
// Start + Wait
// Execute subprocess and return exit code
int amc_gc::acr_Exec(amc_gc::Acr& parent) {
    acr_Start(parent);
    acr_Wait(parent);
    return parent.acr_status;
}

// --- amc_gc.Acr.acr.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr.Argv
int amc_gc::acr_Execv(amc_gc::Acr& parent) {
    char **argv = (char**)alloca((68+2+algo_lib::_db.cmdline.verbose)*sizeof(char*)); // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.acr_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.acr_cmd.query != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-query:";
        cstring_Print(parent.acr_cmd.query, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.select != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-select:";
        bool_Print(parent.acr_cmd.select, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.del != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-del:";
        bool_Print(parent.acr_cmd.del, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.insert != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-insert:";
        bool_Print(parent.acr_cmd.insert, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.replace != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(parent.acr_cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.merge != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-merge:";
        bool_Print(parent.acr_cmd.merge, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.unused != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unused:";
        bool_Print(parent.acr_cmd.unused, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.trunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trunc:";
        bool_Print(parent.acr_cmd.trunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.check != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-check:";
        bool_Print(parent.acr_cmd.check, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.maxshow != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxshow:";
        i32_Print(parent.acr_cmd.maxshow, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.acr_cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.rename != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rename:";
        cstring_Print(parent.acr_cmd.rename, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.nup != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nup:";
        i32_Print(parent.acr_cmd.nup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.ndown != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ndown:";
        i32_Print(parent.acr_cmd.ndown, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(parent.acr_cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.fldfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fldfunc:";
        bool_Print(parent.acr_cmd.fldfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.maxgroup != 25) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxgroup:";
        i32_Print(parent.acr_cmd.maxgroup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.pretty != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pretty:";
        bool_Print(parent.acr_cmd.pretty, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.tree != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tree:";
        bool_Print(parent.acr_cmd.tree, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.loose != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-loose:";
        bool_Print(parent.acr_cmd.loose, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.my != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-my:";
        bool_Print(parent.acr_cmd.my, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.schema != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        cstring_Print(parent.acr_cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.acr_cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.b != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-b:";
        bool_Print(parent.acr_cmd.b, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.t != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-t:";
        bool_Print(parent.acr_cmd.t, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.rowid != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rowid:";
        bool_Print(parent.acr_cmd.rowid, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.acr_cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.cmt != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmt:";
        bool_Print(parent.acr_cmd.cmt, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.acr_cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.print != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-print:";
        bool_Print(parent.acr_cmd.print, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.cmd != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmd:";
        cstring_Print(parent.acr_cmd.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.field != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        cstring_Print(parent.acr_cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.regxof != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-regxof:";
        cstring_Print(parent.acr_cmd.regxof, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.meta != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-meta:";
        bool_Print(parent.acr_cmd.meta, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.acr_path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.acr_path);
    return execv(Zeroterm(parent.acr_path),argv);
}

// --- amc_gc.Acr.acr.ToCmdline
algo::tempstr amc_gc::acr_ToCmdline(amc_gc::Acr& parent) {
    algo::tempstr retval;
    retval << parent.acr_path << " ";
    command::acr_PrintArgv(parent.acr_cmd,retval);
    if (ch_N(parent.acr_fstdin)) {
        retval << " " << parent.acr_fstdin;
    }
    if (ch_N(parent.acr_fstdout)) {
        retval << " " << parent.acr_fstdout;
    }
    if (ch_N(parent.acr_fstderr)) {
        retval << " 2" << parent.acr_fstderr;
    }
    return retval;
}

// --- amc_gc.Acr..Uninit
void amc_gc::Acr_Uninit(amc_gc::Acr& parent) {
    amc_gc::Acr &row = parent; (void)row;

    // amc_gc.Acr.acr.Uninit (Exec)  //
    acr_Kill(parent); // kill child, ensure forward progress
}

// --- amc_gc.Check.acr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int amc_gc::acr_Start(amc_gc::Check& parent) {
    int retval = 0;
    if (parent.acr_pid == 0) {
        verblog(acr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.acr_path);
        tempstr cmdline(acr_ToCmdline(parent));
        parent.acr_pid = dospawn(Zeroterm(parent.acr_path),Zeroterm(cmdline),parent.acr_timeout,parent.acr_fstdin,parent.acr_fstdout,parent.acr_fstderr);
#else
        parent.acr_pid = fork();
        if (parent.acr_pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.acr_timeout > 0) {
                alarm(parent.acr_timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.acr_fstderr, 2);
            if (retval==0) retval= acr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("amc_gc.acr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.acr_pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.acr_status = parent.acr_pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- amc_gc.Check.acr.StartRead
// Start subprocess & Read output
algo::Fildes amc_gc::acr_StartRead(amc_gc::Check& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.acr_fstdout  << ">&" << pipefd[1];
    acr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- amc_gc.Check.acr.Kill
// Kill subprocess and wait
void amc_gc::acr_Kill(amc_gc::Check& parent) {
    if (parent.acr_pid != 0) {
        kill(parent.acr_pid,9);
        acr_Wait(parent);
    }
}

// --- amc_gc.Check.acr.Wait
// Wait for subprocess to return
void amc_gc::acr_Wait(amc_gc::Check& parent) {
    if (parent.acr_pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.acr_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.acr_pid) {
            parent.acr_status = wait_status;
            parent.acr_pid = 0;
        }
    }
}

// --- amc_gc.Check.acr.Exec
// Start + Wait
// Execute subprocess and return exit code
int amc_gc::acr_Exec(amc_gc::Check& parent) {
    acr_Start(parent);
    acr_Wait(parent);
    return parent.acr_status;
}

// --- amc_gc.Check.acr.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr.Argv
int amc_gc::acr_Execv(amc_gc::Check& parent) {
    char **argv = (char**)alloca((68+2+algo_lib::_db.cmdline.verbose)*sizeof(char*)); // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.acr_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.acr_cmd.query != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-query:";
        cstring_Print(parent.acr_cmd.query, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.select != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-select:";
        bool_Print(parent.acr_cmd.select, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.del != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-del:";
        bool_Print(parent.acr_cmd.del, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.insert != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-insert:";
        bool_Print(parent.acr_cmd.insert, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.replace != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(parent.acr_cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.merge != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-merge:";
        bool_Print(parent.acr_cmd.merge, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.unused != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unused:";
        bool_Print(parent.acr_cmd.unused, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.trunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trunc:";
        bool_Print(parent.acr_cmd.trunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.check != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-check:";
        bool_Print(parent.acr_cmd.check, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.maxshow != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxshow:";
        i32_Print(parent.acr_cmd.maxshow, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.acr_cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.rename != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rename:";
        cstring_Print(parent.acr_cmd.rename, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.nup != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nup:";
        i32_Print(parent.acr_cmd.nup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.ndown != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ndown:";
        i32_Print(parent.acr_cmd.ndown, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(parent.acr_cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.fldfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fldfunc:";
        bool_Print(parent.acr_cmd.fldfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.maxgroup != 25) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxgroup:";
        i32_Print(parent.acr_cmd.maxgroup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.pretty != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pretty:";
        bool_Print(parent.acr_cmd.pretty, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.tree != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tree:";
        bool_Print(parent.acr_cmd.tree, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.loose != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-loose:";
        bool_Print(parent.acr_cmd.loose, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.my != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-my:";
        bool_Print(parent.acr_cmd.my, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.schema != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        cstring_Print(parent.acr_cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.acr_cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.b != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-b:";
        bool_Print(parent.acr_cmd.b, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.t != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-t:";
        bool_Print(parent.acr_cmd.t, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.rowid != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rowid:";
        bool_Print(parent.acr_cmd.rowid, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.acr_cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.cmt != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmt:";
        bool_Print(parent.acr_cmd.cmt, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.acr_cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.print != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-print:";
        bool_Print(parent.acr_cmd.print, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.cmd != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmd:";
        cstring_Print(parent.acr_cmd.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.field != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        cstring_Print(parent.acr_cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.regxof != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-regxof:";
        cstring_Print(parent.acr_cmd.regxof, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.acr_cmd.meta != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-meta:";
        bool_Print(parent.acr_cmd.meta, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.acr_path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.acr_path);
    return execv(Zeroterm(parent.acr_path),argv);
}

// --- amc_gc.Check.acr.ToCmdline
algo::tempstr amc_gc::acr_ToCmdline(amc_gc::Check& parent) {
    algo::tempstr retval;
    retval << parent.acr_path << " ";
    command::acr_PrintArgv(parent.acr_cmd,retval);
    if (ch_N(parent.acr_fstdin)) {
        retval << " " << parent.acr_fstdin;
    }
    if (ch_N(parent.acr_fstdout)) {
        retval << " " << parent.acr_fstdout;
    }
    if (ch_N(parent.acr_fstderr)) {
        retval << " 2" << parent.acr_fstderr;
    }
    return retval;
}

// --- amc_gc.Check.amc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int amc_gc::amc_Start(amc_gc::Check& parent) {
    int retval = 0;
    if (parent.amc_pid == 0) {
        verblog(amc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.amc_path);
        tempstr cmdline(amc_ToCmdline(parent));
        parent.amc_pid = dospawn(Zeroterm(parent.amc_path),Zeroterm(cmdline),parent.amc_timeout,parent.amc_fstdin,parent.amc_fstdout,parent.amc_fstderr);
#else
        parent.amc_pid = fork();
        if (parent.amc_pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.amc_timeout > 0) {
                alarm(parent.amc_timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.amc_fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.amc_fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.amc_fstderr, 2);
            if (retval==0) retval= amc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("amc_gc.amc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.amc_pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.amc_status = parent.amc_pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- amc_gc.Check.amc.StartRead
// Start subprocess & Read output
algo::Fildes amc_gc::amc_StartRead(amc_gc::Check& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.amc_fstdout  << ">&" << pipefd[1];
    amc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- amc_gc.Check.amc.Kill
// Kill subprocess and wait
void amc_gc::amc_Kill(amc_gc::Check& parent) {
    if (parent.amc_pid != 0) {
        kill(parent.amc_pid,9);
        amc_Wait(parent);
    }
}

// --- amc_gc.Check.amc.Wait
// Wait for subprocess to return
void amc_gc::amc_Wait(amc_gc::Check& parent) {
    if (parent.amc_pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.amc_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.amc_pid) {
            parent.amc_status = wait_status;
            parent.amc_pid = 0;
        }
    }
}

// --- amc_gc.Check.amc.Exec
// Start + Wait
// Execute subprocess and return exit code
int amc_gc::amc_Exec(amc_gc::Check& parent) {
    amc_Start(parent);
    amc_Wait(parent);
    return parent.amc_status;
}

// --- amc_gc.Check.amc.Execv
// Call execv()
// Call execv with specified parameters -- cprint:amc.Argv
int amc_gc::amc_Execv(amc_gc::Check& parent) {
    char **argv = (char**)alloca((14+2+algo_lib::_db.cmdline.verbose)*sizeof(char*)); // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.amc_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.amc_cmd.in_dir != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in_dir:";
        cstring_Print(parent.amc_cmd.in_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.query != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-query:";
        cstring_Print(parent.amc_cmd.query, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.out_dir != ".") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-out_dir:";
        cstring_Print(parent.amc_cmd.out_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.proto != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-proto:";
        bool_Print(parent.amc_cmd.proto, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.amc_cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.amc_cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.amc_cmd.trace.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trace:";
        command::trace_Print(parent.amc_cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.amc_path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.amc_path);
    return execv(Zeroterm(parent.amc_path),argv);
}

// --- amc_gc.Check.amc.ToCmdline
algo::tempstr amc_gc::amc_ToCmdline(amc_gc::Check& parent) {
    algo::tempstr retval;
    retval << parent.amc_path << " ";
    command::amc_PrintArgv(parent.amc_cmd,retval);
    if (ch_N(parent.amc_fstdin)) {
        retval << " " << parent.amc_fstdin;
    }
    if (ch_N(parent.amc_fstdout)) {
        retval << " " << parent.amc_fstdout;
    }
    if (ch_N(parent.amc_fstderr)) {
        retval << " 2" << parent.amc_fstderr;
    }
    return retval;
}

// --- amc_gc.Check.abt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int amc_gc::abt_Start(amc_gc::Check& parent) {
    int retval = 0;
    if (parent.abt_pid == 0) {
        verblog(abt_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.abt_path);
        tempstr cmdline(abt_ToCmdline(parent));
        parent.abt_pid = dospawn(Zeroterm(parent.abt_path),Zeroterm(cmdline),parent.abt_timeout,parent.abt_fstdin,parent.abt_fstdout,parent.abt_fstderr);
#else
        parent.abt_pid = fork();
        if (parent.abt_pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.abt_timeout > 0) {
                alarm(parent.abt_timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.abt_fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.abt_fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.abt_fstderr, 2);
            if (retval==0) retval= abt_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("amc_gc.abt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.abt_pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.abt_status = parent.abt_pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- amc_gc.Check.abt.StartRead
// Start subprocess & Read output
algo::Fildes amc_gc::abt_StartRead(amc_gc::Check& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.abt_fstdout  << ">&" << pipefd[1];
    abt_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- amc_gc.Check.abt.Kill
// Kill subprocess and wait
void amc_gc::abt_Kill(amc_gc::Check& parent) {
    if (parent.abt_pid != 0) {
        kill(parent.abt_pid,9);
        abt_Wait(parent);
    }
}

// --- amc_gc.Check.abt.Wait
// Wait for subprocess to return
void amc_gc::abt_Wait(amc_gc::Check& parent) {
    if (parent.abt_pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.abt_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.abt_pid) {
            parent.abt_status = wait_status;
            parent.abt_pid = 0;
        }
    }
}

// --- amc_gc.Check.abt.Exec
// Start + Wait
// Execute subprocess and return exit code
int amc_gc::abt_Exec(amc_gc::Check& parent) {
    abt_Start(parent);
    abt_Wait(parent);
    return parent.abt_status;
}

// --- amc_gc.Check.abt.Execv
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int amc_gc::abt_Execv(amc_gc::Check& parent) {
    char **argv = (char**)alloca((48+2+algo_lib::_db.cmdline.verbose)*sizeof(char*)); // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.abt_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.abt_cmd.target.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        command::target_Print(parent.abt_cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.abt_cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.out_dir != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-out_dir:";
        cstring_Print(parent.abt_cmd.out_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.cfg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cfg:";
        Smallstr50_Print(parent.abt_cmd.cfg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.compiler != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-compiler:";
        Smallstr50_Print(parent.abt_cmd.compiler, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.uname != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-uname:";
        Smallstr50_Print(parent.abt_cmd.uname, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.arch != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arch:";
        Smallstr50_Print(parent.abt_cmd.arch, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.ood != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ood:";
        bool_Print(parent.abt_cmd.ood, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.list != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-list:";
        bool_Print(parent.abt_cmd.list, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.listincl != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-listincl:";
        bool_Print(parent.abt_cmd.listincl, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.build != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-build:";
        bool_Print(parent.abt_cmd.build, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.preproc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-preproc:";
        bool_Print(parent.abt_cmd.preproc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.clean != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-clean:";
        bool_Print(parent.abt_cmd.clean, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.dry_run != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dry_run:";
        bool_Print(parent.abt_cmd.dry_run, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.maxjobs != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxjobs:";
        i32_Print(parent.abt_cmd.maxjobs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.printcmd != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-printcmd:";
        bool_Print(parent.abt_cmd.printcmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.force != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-force:";
        bool_Print(parent.abt_cmd.force, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.install != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-install:";
        bool_Print(parent.abt_cmd.install, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.coverity != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-coverity:";
        bool_Print(parent.abt_cmd.coverity, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.package != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-package:";
        cstring_Print(parent.abt_cmd.package, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.maxerr != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxerr:";
        u32_Print(parent.abt_cmd.maxerr, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.disas.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-disas:";
        command::disas_Print(parent.abt_cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.abt_cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.abt_cmd.jcdb != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-jcdb:";
        cstring_Print(parent.abt_cmd.jcdb, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.abt_path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.abt_path);
    return execv(Zeroterm(parent.abt_path),argv);
}

// --- amc_gc.Check.abt.ToCmdline
algo::tempstr amc_gc::abt_ToCmdline(amc_gc::Check& parent) {
    algo::tempstr retval;
    retval << parent.abt_path << " ";
    command::abt_PrintArgv(parent.abt_cmd,retval);
    if (ch_N(parent.abt_fstdin)) {
        retval << " " << parent.abt_fstdin;
    }
    if (ch_N(parent.abt_fstdout)) {
        retval << " " << parent.abt_fstdout;
    }
    if (ch_N(parent.abt_fstderr)) {
        retval << " 2" << parent.abt_fstderr;
    }
    return retval;
}

// --- amc_gc.Check..Init
// Set all fields to initial values.
void amc_gc::Check_Init(amc_gc::Check& parent) {
    parent.acr_path = algo::strptr("bin/acr");
    parent.acr_pid = pid_t(0);
    parent.acr_timeout = i32(0);
    parent.acr_status = i32(0);
    parent.amc_path = algo::strptr("bin/amc");
    parent.amc_pid = pid_t(0);
    parent.amc_timeout = i32(0);
    parent.amc_status = i32(0);
    parent.abt_path = algo::strptr("bin/abt");
    parent.abt_pid = pid_t(0);
    parent.abt_timeout = i32(0);
    parent.abt_status = i32(0);
}

// --- amc_gc.Check..Uninit
void amc_gc::Check_Uninit(amc_gc::Check& parent) {
    amc_gc::Check &row = parent; (void)row;

    // amc_gc.Check.abt.Uninit (Exec)  //
    abt_Kill(parent); // kill child, ensure forward progress

    // amc_gc.Check.amc.Uninit (Exec)  //
    amc_Kill(parent); // kill child, ensure forward progress

    // amc_gc.Check.acr.Uninit (Exec)  //
    acr_Kill(parent); // kill child, ensure forward progress
}

// --- amc_gc.trace..Print
// print string representation of amc_gc::trace to string LHS, no header -- cprint:amc_gc.trace.String
void amc_gc::trace_Print(amc_gc::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "amc_gc.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- amc_gc.FDb._db.MainArgs
// Main function
void amc_gc::MainArgs(int argc, char **argv) {
    Argtuple argtuple;
    Argtuple_ReadArgv(argtuple, argc,argv,amc_gc_syntax, amc_gc_help);
    vrfy(amc_gc_ReadTupleMaybe(amc_gc::_db.cmdline, argtuple.tuple),"where:read_cmdline");
    vrfy(amc_gc::LoadTuplesMaybe(amc_gc::_db.cmdline.in)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
    amc_gc::Main(); // call through to user-defined main
}

// --- amc_gc.FDb._db.MainLoop
// Main loop.
void amc_gc::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        amc_gc::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- amc_gc.FDb._db.Step
// Main step
void amc_gc::Step() {
}

// --- amc_gc.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void amc_gc::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("amc_gc", NULL, NULL, amc_gc::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "amc_gc.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(amc_gc::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)amc_gc::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
}

// --- amc_gc.FDb._db.StaticCheck
void amc_gc::StaticCheck() {
    algo_assert(_offset_of(amc_gc::FieldId, value) + sizeof(((amc_gc::FieldId*)0)->value) == sizeof(amc_gc::FieldId));
}

// --- amc_gc.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool amc_gc::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    (void)str;//only to avoid -Wunused-parameter
    return retval;
}

// --- amc_gc.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool amc_gc::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    (void)root;//only to avoid -Wunused-parameter
    return retval;
}

// --- amc_gc.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool amc_gc::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, amc_gc::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- amc_gc.FDb._db.Steps
// Calls Step function of dependencies
void amc_gc::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- amc_gc.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc_gc::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- amc_gc.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr amc_gc::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- amc_gc.FDb.trace.N
// Function return 1
inline static i32 amc_gc::trace_N() {
    return 1;
}

// --- amc_gc.FDb..Init
// Set all fields to initial values.
void amc_gc::FDb_Init() {
    _db.n_cur = u32(1);
    _db.n_del = u32(0);
    _db.n_cppline = u32(0);
    _db.n_newcppline = u32(0);
    _db.buildlog = algo::strptr("temp/amc_gc.build");
    _db.n_total = u32(0);

    amc_gc::InitReflection();
}

// --- amc_gc.FDb..Uninit
void amc_gc::FDb_Uninit() {
    amc_gc::FDb &row = _db; (void)row;
}

// --- amc_gc.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* amc_gc::value_ToCstr(const amc_gc::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case amc_gc_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- amc_gc.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void amc_gc::value_Print(const amc_gc::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- amc_gc.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool amc_gc::value_SetStrptrMaybe(amc_gc::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,amc_gc_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- amc_gc.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void amc_gc::value_SetStrptr(amc_gc::FieldId& parent, algo::strptr rhs, amc_gc_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- amc_gc.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool amc_gc::value_ReadStrptrMaybe(amc_gc::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- amc_gc.FieldId..ReadStrptrMaybe
// Read fields of amc_gc::FieldId from an ascii string.
// The format of the string is the format of the amc_gc::FieldId's only field
bool amc_gc::FieldId_ReadStrptrMaybe(amc_gc::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && amc_gc::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- amc_gc.FieldId..Print
// print string representation of amc_gc::FieldId to string LHS, no header -- cprint:amc_gc.FieldId.String
void amc_gc::FieldId_Print(amc_gc::FieldId & row, algo::cstring &str) {
    amc_gc::value_Print(row, str);
}

// --- amc_gc...SizeCheck
inline static void amc_gc::SizeCheck() {
}

// --- amc_gc...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        amc_gc::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        amc_gc::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:amc_gc
    } catch(algo_lib::ErrorX &x) {
        prerr("amc_gc.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        amc_gc::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- amc_gc...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
