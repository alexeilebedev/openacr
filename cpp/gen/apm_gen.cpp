//
// cpp/gen/apm_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/apm_gen.h"
#include "include/gen/apm_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_amcdb_gen.h"
#include "include/gen/lib_amcdb_gen.inl.h"
#include "include/gen/lib_ctype_gen.h"
#include "include/gen/lib_ctype_gen.inl.h"
#include "include/gen/lib_git_gen.h"
#include "include/gen/lib_git_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb    lib_json::_db;     // dependency found via dev.targdep
algo_lib::FDb    algo_lib::_db;     // dependency found via dev.targdep
lib_ctype::FDb   lib_ctype::_db;    // dependency found via dev.targdep
lib_git::FDb     lib_git::_db;      // dependency found via dev.targdep
apm::FDb         apm::_db;          // dependency found via dev.targdep

namespace apm {
const char *apm_help =
"apm: Algo Package Manager\n"
"Usage: apm [[-package:]<regx>] [options]\n"
"    OPTION       TYPE    DFLT    COMMENT\n"
"    -in          string  \"data\"  Input directory or filename, - for stdin\n"
"    -pkgdata     string  \"\"      Load package definitions from here\n"
"    [package]    regx    \"\"      Regx of package\n"
"    -ns          regx    \"\"      Operate on specified namespace only\n"
"    -install                     Install new package (specify -origin)\n"
"    -update                      Update package (-origin)\n"
"    -list                        List installed packages\n"
"    -diff                        Diff package with respect to installed version\n"
"    -push                        Evaluate package diff and push it to origin\n"
"    -check                       Consistency check\n"
"    -remove                      Remove specified package\n"
"    -origin      string  \"\"      Upstream URL of new package\n"
"    -ref         string  \"\"      (with -create) Gitref or branch to fetch\n"
"    -dry_run                     Do not execute transaction\n"
"    -showrec                     Show records belonging to package\n"
"    -showfile                    List package files (gitfile records)\n"
"    -R                           reverse the diff direction\n"
"    -l                           Use local package definition on the remote side\n"
"    -reset                       Reset package baseref/origin to those provided by the command line\n"
"    -checkclean          Y       Ensure that changes are applied to a clean directory\n"
"    -t                           Select parent packages for operation\n"
"    -stat                        (with -diff) show stats\n"
"    -annotate    string  \"\"      Read file and annotate each input tuple with package(s) it belongs to\n"
"    -data_in     string  \"data\"  Dataset from which package records are loaded\n"
"    -e                           Open selected records in editor\n"
"    -binpath     string  \"bin\"   (internal use)\n"
"    -verbose     int             Verbosity level (0..255); alias -v; cumulative\n"
"    -debug       int             Debug level (0..255); alias -d; cumulative\n"
"    -help                        Print help and exit; alias -h\n"
"    -version                     Print version and exit\n"
"    -signature                   Show signatures and exit; alias -sig\n"
;


} // namespace apm
namespace apm { // gen:ns_gsymbol
    const algo::strptr dev_package_amc("amc");
    const algo::strptr dev_package_apm("apm");
    const algo::strptr dev_package_openacr("openacr");
} // gen:ns_gsymbol
namespace apm { // gen:ns_print_proto
    // Load statically available data into tables, register tables and database.
    // func:apm.FDb._db.InitReflection
    static void          InitReflection();
    // func:apm.FDb.package.InputMaybe
    static bool          package_InputMaybe(dev::Package &elem) __attribute__((nothrow));
    // func:apm.FDb.pkgkey.InputMaybe
    static bool          pkgkey_InputMaybe(dev::Pkgkey &elem) __attribute__((nothrow));
    // func:apm.FDb.pkgdep.InputMaybe
    static bool          pkgdep_InputMaybe(dev::Pkgdep &elem) __attribute__((nothrow));
    // func:apm.FDb.ctype.InputMaybe
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    // func:apm.FDb.field.InputMaybe
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    // func:apm.FDb.ssimfile.InputMaybe
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    // func:apm.FDb.substr.InputMaybe
    static bool          substr_InputMaybe(dmmeta::Substr &elem) __attribute__((nothrow));
    // func:apm.FDb.ssimreq.InputMaybe
    static bool          ssimreq_InputMaybe(dmmeta::Ssimreq &elem) __attribute__((nothrow));
    // func:apm.FDb.ns.InputMaybe
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    // func:apm.FDb.trace.RowidFind
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    // func:apm.FDb.trace.N
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // func:apm...SizeCheck
    static void          SizeCheck();
} // gen:ns_print_proto

// --- apm.FCtype.base.CopyOut
// Copy fields out of row
void apm::ctype_CopyOut(apm::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- apm.FCtype.base.CopyIn
// Copy fields in to row
void apm::ctype_CopyIn(apm::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- apm.FCtype.ns.Get
algo::Smallstr16 apm::ns_Get(apm::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- apm.FCtype.name.Get
algo::Smallstr100 apm::name_Get(apm::FCtype& ctype) {
    algo::Smallstr100 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- apm.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_field_Insert(apm::FCtype& ctype, apm::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,true)) {
        // reserve space
        c_field_Reserve(ctype, 1);
        u32 n  = ctype.c_field_n;
        u32 at = n;
        apm::FField* *elems = ctype.c_field_elems;
        elems[at] = &row;
        ctype.c_field_n = n+1;

    }
}

// --- apm.FCtype.c_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool apm::c_field_InsertMaybe(apm::FCtype& ctype, apm::FField& row) {
    bool retval = !row.ctype_c_field_in_ary;
    c_field_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- apm.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_field_Remove(apm::FCtype& ctype, apm::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,false)) {
        int lim = ctype.c_field_n;
        apm::FField* *elems = ctype.c_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            apm::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(apm::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- apm.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void apm::c_field_Reserve(apm::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FField*);
        u32 new_size = new_max * sizeof(apm::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FCtype.c_field");
        }
        ctype.c_field_elems = (apm::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- apm.FCtype.c_ssimreq.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_ssimreq_Insert(apm::FCtype& ctype, apm::FSsimreq& row) {
    if (bool_Update(row.ctype_c_ssimreq_in_ary,true)) {
        // reserve space
        c_ssimreq_Reserve(ctype, 1);
        u32 n  = ctype.c_ssimreq_n;
        u32 at = n;
        apm::FSsimreq* *elems = ctype.c_ssimreq_elems;
        elems[at] = &row;
        ctype.c_ssimreq_n = n+1;

    }
}

// --- apm.FCtype.c_ssimreq.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool apm::c_ssimreq_InsertMaybe(apm::FCtype& ctype, apm::FSsimreq& row) {
    bool retval = !row.ctype_c_ssimreq_in_ary;
    c_ssimreq_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- apm.FCtype.c_ssimreq.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_ssimreq_Remove(apm::FCtype& ctype, apm::FSsimreq& row) {
    if (bool_Update(row.ctype_c_ssimreq_in_ary,false)) {
        int lim = ctype.c_ssimreq_n;
        apm::FSsimreq* *elems = ctype.c_ssimreq_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            apm::FSsimreq* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(apm::FSsimreq*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_ssimreq_n = lim - 1;
                break;
            }
        }
    }
}

// --- apm.FCtype.c_ssimreq.Reserve
// Reserve space in index for N more elements;
void apm::c_ssimreq_Reserve(apm::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_ssimreq_max;
    if (UNLIKELY(ctype.c_ssimreq_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FSsimreq*);
        u32 new_size = new_max * sizeof(apm::FSsimreq*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_ssimreq_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FCtype.c_ssimreq");
        }
        ctype.c_ssimreq_elems = (apm::FSsimreq**)new_mem;
        ctype.c_ssimreq_max = new_max;
    }
}

// --- apm.FCtype..Uninit
void apm::FCtype_Uninit(apm::FCtype& ctype) {
    apm::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype

    // apm.FCtype.c_ssimreq.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_ssimreq_elems, sizeof(apm::FSsimreq*)*ctype.c_ssimreq_max); // (apm.FCtype.c_ssimreq)

    // apm.FCtype.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_field_elems, sizeof(apm::FField*)*ctype.c_field_max); // (apm.FCtype.c_field)
}

// --- apm.trace..Print
// print string representation of ROW to string STR
// cfmt:apm.trace.String  printfmt:Tuple
void apm::trace_Print(apm::trace& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "apm.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- apm.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     apm.FDb.cmdline
//     algo_lib.FDb.cmdline
void apm::ReadArgv() {
    command::apm &cmd = apm::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    int anonidx=0;
    algo::strptr nextanon = command::apm_GetAnon(cmd, anonidx);
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::apm_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"apm: unknown option "<<Keyval("value",arg)<<eol;
            } else {
                if (isanon) {
                    if (attrname == nextanon) { // treat named anon (positional) argument as unnamed
                        attrname = ""; // treat it as unnamed
                    } else if (nextanon != "") { // disallow out-of-order anon (positional) args
                        err<<"apm: error at "<<algo::strptr_ToSsim(arg)<<": must be preceded by [-"<<nextanon<<"]"<<eol;
                    }
                }
            }
        }
        // look up anon field name based on index
        // anon fields are only allowed in the leaf ns, never base
        if (ch_N(attrname) == 0) {
            attrname = nextanon;
            nextanon = command::apm_GetAnon(cmd, ++anonidx);
            command::FieldId_ReadStrptrMaybe(attrid,attrname);
            whichns=1;
        }
        if (ch_N(attrname) == 0) {
            err << "apm: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::apm_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"apm: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    // dmmeta.floadtuples:apm.FDb.cmdline
    if (!dohelp && err=="") {
        algo_lib::ResetErrtext();
        if (!apm::LoadTuplesMaybe(cmd.in,true)) {
            err << "apm.load_input  "<<algo_lib::DetachBadTags()<<eol;
        }
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(apm_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
}

// --- apm.FDb._db.MainLoop
// Main loop.
void apm::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        apm::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- apm.FDb._db.Step
// Main step
void apm::Step() {
}

// --- apm.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void apm::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("apm", apm::InsertStrptrMaybe, NULL, apm::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "apm.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(apm::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)apm::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'apm.Input'  signature:'6cd9ce149ee2dcf2150fc77eec6ace0504e98b5a'");
}

// --- apm.FDb._db.StaticCheck
void apm::StaticCheck() {
    algo_assert(_offset_of(apm::FieldId, value) + sizeof(((apm::FieldId*)0)->value) == sizeof(apm::FieldId));
}

// --- apm.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool apm::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    apm::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case apm_TableId_dev_Package: { // finput:apm.FDb.package
            dev::Package elem;
            retval = dev::Package_ReadStrptrMaybe(elem, str);
            retval = retval && package_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dev_Pkgkey: { // finput:apm.FDb.pkgkey
            dev::Pkgkey elem;
            retval = dev::Pkgkey_ReadStrptrMaybe(elem, str);
            retval = retval && pkgkey_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dev_Pkgdep: { // finput:apm.FDb.pkgdep
            dev::Pkgdep elem;
            retval = dev::Pkgdep_ReadStrptrMaybe(elem, str);
            retval = retval && pkgdep_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Ctype: { // finput:apm.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Field: { // finput:apm.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Ssimfile: { // finput:apm.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Substr: { // finput:apm.FDb.substr
            dmmeta::Substr elem;
            retval = dmmeta::Substr_ReadStrptrMaybe(elem, str);
            retval = retval && substr_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Ssimreq: { // finput:apm.FDb.ssimreq
            dmmeta::Ssimreq elem;
            retval = dmmeta::Ssimreq_ReadStrptrMaybe(elem, str);
            retval = retval && ssimreq_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        case apm_TableId_dmmeta_Ns: { // finput:apm.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            retval = true; // finput strict:N
            break;
        }
        default:
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- apm.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool apm::LoadTuplesMaybe(algo::strptr root, bool recursive) {
    bool retval = true;
    if (FileQ(root)) {
        retval = apm::LoadTuplesFile(root, recursive);
    } else if (root == "-") {
        retval = apm::LoadTuplesFd(algo::Fildes(0),"(stdin)",recursive);
    } else if (DirectoryQ(root)) {
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ns"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ctype"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.field"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.substr"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ssimfile"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ssimreq"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.ftuple"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.fconst"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.dispsigcheck"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.cppfunc"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.cfmt"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dmmeta.cdflt"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dev.unstablefld"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dev.package"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dev.pkgkey"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"dev.pkgdep"),recursive);
        retval = retval && apm::LoadTuplesFile(algo::SsimFname(root,"amcdb.bltin"),recursive);
    } else {
        algo_lib::SaveBadTag("path", root);
        algo_lib::SaveBadTag("comment", "Wrong working directory?");
        retval = false;
    }
    return retval;
}

// --- apm.FDb._db.LoadTuplesFile
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
bool apm::LoadTuplesFile(algo::strptr fname, bool recursive) {
    bool retval = true;
    algo_lib::FFildes fildes;
    // missing files are not an error
    fildes.fd = OpenRead(fname,algo::FileFlags());
    if (ValidQ(fildes.fd)) {
        retval = LoadTuplesFd(fildes.fd, fname, recursive);
    }
    return retval;
}

// --- apm.FDb._db.LoadTuplesFd
// Load all finputs from given file descriptor.
bool apm::LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) {
    bool retval = true;
    ind_beg(algo::FileLine_curs,line,fd) {
        if (recursive) {
            retval = retval && algo_lib::InsertStrptrMaybe(line);
            retval = retval && lib_ctype::InsertStrptrMaybe(line);
        }
        retval = retval && apm::InsertStrptrMaybe(line);
        if (!retval) {
            algo_lib::_db.errtext << eol
            << fname << ":"
            << (ind_curs(line).i+1)
            << ": " << line << eol;
            break;
        }
    }ind_end;
    return retval;
}

// --- apm.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool apm::LoadSsimfileMaybe(algo::strptr fname, bool recursive) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = apm::LoadTuplesFile(fname, recursive);
    }
    return retval;
}

// --- apm.FDb._db.Steps
// Calls Step function of dependencies
void apm::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- apm.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- apm.FDb.package.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FPackage& apm::package_Alloc() {
    apm::FPackage* row = package_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.package  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.package.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FPackage* apm::package_AllocMaybe() {
    apm::FPackage *row = (apm::FPackage*)package_AllocMem();
    if (row) {
        new (row) apm::FPackage; // call constructor
    }
    return row;
}

// --- apm.FDb.package.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FPackage* apm::package_InsertMaybe(const dev::Package &value) {
    apm::FPackage *row = &package_Alloc(); // if out of memory, process dies. if input error, return NULL.
    package_CopyIn(*row,const_cast<dev::Package&>(value));
    bool ok = package_XrefMaybe(*row); // this may return false
    if (!ok) {
        package_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.package.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::package_AllocMem() {
    u64 new_nelems     = _db.package_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FPackage*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.package_lary[bsr];
        if (!lev) {
            lev=(apm::FPackage*)algo_lib::malloc_AllocMem(sizeof(apm::FPackage) * (u64(1)<<bsr));
            _db.package_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.package_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.package.RemoveAll
// Remove all elements from Lary
void apm::package_RemoveAll() {
    for (u64 n = _db.package_n; n>0; ) {
        n--;
        package_qFind(u64(n)).~FPackage(); // destroy last element
        _db.package_n = i32(n);
    }
}

// --- apm.FDb.package.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::package_RemoveLast() {
    u64 n = _db.package_n;
    if (n > 0) {
        n -= 1;
        package_qFind(u64(n)).~FPackage();
        _db.package_n = i32(n);
    }
}

// --- apm.FDb.package.InputMaybe
static bool apm::package_InputMaybe(dev::Package &elem) {
    bool retval = true;
    retval = package_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.package.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::package_XrefMaybe(apm::FPackage &row) {
    bool retval = true;
    (void)row;
    // insert package into index ind_package
    if (true) { // user-defined insert condition
        bool success = ind_package_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_package"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.zd_sel_package.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_sel_package_Insert(apm::FPackage& row) {
    if (!zd_sel_package_InLlistQ(row)) {
        apm::FPackage* old_tail = _db.zd_sel_package_tail;
        row.zd_sel_package_next = NULL;
        row.zd_sel_package_prev = old_tail;
        _db.zd_sel_package_tail = &row;
        apm::FPackage **new_row_a = &old_tail->zd_sel_package_next;
        apm::FPackage **new_row_b = &_db.zd_sel_package_head;
        apm::FPackage **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_sel_package_n++;
    }
}

// --- apm.FDb.zd_sel_package.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_sel_package_Remove(apm::FPackage& row) {
    if (zd_sel_package_InLlistQ(row)) {
        apm::FPackage* old_head       = _db.zd_sel_package_head;
        (void)old_head; // in case it's not used
        apm::FPackage* prev = row.zd_sel_package_prev;
        apm::FPackage* next = row.zd_sel_package_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FPackage **new_next_a = &prev->zd_sel_package_next;
        apm::FPackage **new_next_b = &_db.zd_sel_package_head;
        apm::FPackage **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FPackage **new_prev_a = &next->zd_sel_package_prev;
        apm::FPackage **new_prev_b = &_db.zd_sel_package_tail;
        apm::FPackage **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_sel_package_n--;
        row.zd_sel_package_next=(apm::FPackage*)-1; // not-in-list
    }
}

// --- apm.FDb.zd_sel_package.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_sel_package_RemoveAll() {
    apm::FPackage* row = _db.zd_sel_package_head;
    _db.zd_sel_package_head = NULL;
    _db.zd_sel_package_tail = NULL;
    _db.zd_sel_package_n = 0;
    while (row) {
        apm::FPackage* row_next = row->zd_sel_package_next;
        row->zd_sel_package_next  = (apm::FPackage*)-1;
        row->zd_sel_package_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FDb.zd_sel_package.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FPackage* apm::zd_sel_package_RemoveFirst() {
    apm::FPackage *row = NULL;
    row = _db.zd_sel_package_head;
    if (row) {
        apm::FPackage *next = row->zd_sel_package_next;
        _db.zd_sel_package_head = next;
        apm::FPackage **new_end_a = &next->zd_sel_package_prev;
        apm::FPackage **new_end_b = &_db.zd_sel_package_tail;
        apm::FPackage **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_sel_package_n--;
        row->zd_sel_package_next = (apm::FPackage*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FDb.ind_package.Find
// Find row by key. Return NULL if not found.
apm::FPackage* apm::ind_package_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_package_buckets_n - 1);
    apm::FPackage* *e = &_db.ind_package_buckets_elems[index];
    apm::FPackage* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).package == key;
        if (done) break;
        e         = &ret->ind_package_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_package.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FPackage& apm::ind_package_FindX(const algo::strptr& key) {
    apm::FPackage* ret = ind_package_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_package  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_package.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
apm::FPackage& apm::ind_package_GetOrCreate(const algo::strptr& key) {
    apm::FPackage* ret = ind_package_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &package_Alloc();
        (*ret).package = key;
        bool good = package_XrefMaybe(*ret);
        if (!good) {
            package_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "apm.create_error  table:ind_package  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- apm.FDb.ind_package.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_package_InsertMaybe(apm::FPackage& row) {
    ind_package_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_package_next == (apm::FPackage*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.package) & (_db.ind_package_buckets_n - 1);
        apm::FPackage* *prev = &_db.ind_package_buckets_elems[index];
        do {
            apm::FPackage* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).package == row.package) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_package_next;
        } while (true);
        if (retval) {
            row.ind_package_next = *prev;
            _db.ind_package_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_package.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_package_Remove(apm::FPackage& row) {
    if (LIKELY(row.ind_package_next != (apm::FPackage*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.package) & (_db.ind_package_buckets_n - 1);
        apm::FPackage* *prev = &_db.ind_package_buckets_elems[index]; // addr of pointer to current element
        while (apm::FPackage *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_package_next; // unlink (singly linked list)
                _db.ind_package_n--;
                row.ind_package_next = (apm::FPackage*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_package_next;
        }
    }
}

// --- apm.FDb.ind_package.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_package_Reserve(int n) {
    u32 old_nbuckets = _db.ind_package_buckets_n;
    u32 new_nelems   = _db.ind_package_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FPackage*);
        u32 new_size = new_nbuckets * sizeof(apm::FPackage*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FPackage* *new_buckets = (apm::FPackage**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_package");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_package_buckets_n; i++) {
            apm::FPackage* elem = _db.ind_package_buckets_elems[i];
            while (elem) {
                apm::FPackage &row        = *elem;
                apm::FPackage* next       = row.ind_package_next;
                u32 index          = algo::Smallstr50_Hash(0, row.package) & (new_nbuckets-1);
                row.ind_package_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_package_buckets_elems, old_size);
        _db.ind_package_buckets_elems = new_buckets;
        _db.ind_package_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.pkgkey.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FPkgkey& apm::pkgkey_Alloc() {
    apm::FPkgkey* row = pkgkey_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.pkgkey  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.pkgkey.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FPkgkey* apm::pkgkey_AllocMaybe() {
    apm::FPkgkey *row = (apm::FPkgkey*)pkgkey_AllocMem();
    if (row) {
        new (row) apm::FPkgkey; // call constructor
    }
    return row;
}

// --- apm.FDb.pkgkey.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FPkgkey* apm::pkgkey_InsertMaybe(const dev::Pkgkey &value) {
    apm::FPkgkey *row = &pkgkey_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pkgkey_CopyIn(*row,const_cast<dev::Pkgkey&>(value));
    bool ok = pkgkey_XrefMaybe(*row); // this may return false
    if (!ok) {
        pkgkey_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.pkgkey.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::pkgkey_AllocMem() {
    u64 new_nelems     = _db.pkgkey_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FPkgkey*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pkgkey_lary[bsr];
        if (!lev) {
            lev=(apm::FPkgkey*)algo_lib::malloc_AllocMem(sizeof(apm::FPkgkey) * (u64(1)<<bsr));
            _db.pkgkey_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pkgkey_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.pkgkey.RemoveAll
// Remove all elements from Lary
void apm::pkgkey_RemoveAll() {
    for (u64 n = _db.pkgkey_n; n>0; ) {
        n--;
        pkgkey_qFind(u64(n)).~FPkgkey(); // destroy last element
        _db.pkgkey_n = i32(n);
    }
}

// --- apm.FDb.pkgkey.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::pkgkey_RemoveLast() {
    u64 n = _db.pkgkey_n;
    if (n > 0) {
        n -= 1;
        pkgkey_qFind(u64(n)).~FPkgkey();
        _db.pkgkey_n = i32(n);
    }
}

// --- apm.FDb.pkgkey.InputMaybe
static bool apm::pkgkey_InputMaybe(dev::Pkgkey &elem) {
    bool retval = true;
    retval = pkgkey_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.pkgkey.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::pkgkey_XrefMaybe(apm::FPkgkey &row) {
    bool retval = true;
    (void)row;
    apm::FPackage* p_package = apm::ind_package_Find(package_Get(row));
    if (UNLIKELY(!p_package)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_package" << Keyval("key", package_Get(row));
        return false;
    }
    // insert pkgkey into index zd_pkgkey
    if (true) { // user-defined insert condition
        zd_pkgkey_Insert(*p_package, row);
    }
    // insert pkgkey into index ind_pkgkey
    if (true) { // user-defined insert condition
        bool success = ind_pkgkey_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_pkgkey"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.pkgdep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FPkgdep& apm::pkgdep_Alloc() {
    apm::FPkgdep* row = pkgdep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.pkgdep  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.pkgdep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FPkgdep* apm::pkgdep_AllocMaybe() {
    apm::FPkgdep *row = (apm::FPkgdep*)pkgdep_AllocMem();
    if (row) {
        new (row) apm::FPkgdep; // call constructor
    }
    return row;
}

// --- apm.FDb.pkgdep.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FPkgdep* apm::pkgdep_InsertMaybe(const dev::Pkgdep &value) {
    apm::FPkgdep *row = &pkgdep_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pkgdep_CopyIn(*row,const_cast<dev::Pkgdep&>(value));
    bool ok = pkgdep_XrefMaybe(*row); // this may return false
    if (!ok) {
        pkgdep_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.pkgdep.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::pkgdep_AllocMem() {
    u64 new_nelems     = _db.pkgdep_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FPkgdep*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pkgdep_lary[bsr];
        if (!lev) {
            lev=(apm::FPkgdep*)algo_lib::malloc_AllocMem(sizeof(apm::FPkgdep) * (u64(1)<<bsr));
            _db.pkgdep_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pkgdep_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.pkgdep.RemoveAll
// Remove all elements from Lary
void apm::pkgdep_RemoveAll() {
    for (u64 n = _db.pkgdep_n; n>0; ) {
        n--;
        pkgdep_qFind(u64(n)).~FPkgdep(); // destroy last element
        _db.pkgdep_n = i32(n);
    }
}

// --- apm.FDb.pkgdep.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::pkgdep_RemoveLast() {
    u64 n = _db.pkgdep_n;
    if (n > 0) {
        n -= 1;
        pkgdep_qFind(u64(n)).~FPkgdep();
        _db.pkgdep_n = i32(n);
    }
}

// --- apm.FDb.pkgdep.InputMaybe
static bool apm::pkgdep_InputMaybe(dev::Pkgdep &elem) {
    bool retval = true;
    retval = pkgdep_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.pkgdep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::pkgdep_XrefMaybe(apm::FPkgdep &row) {
    bool retval = true;
    (void)row;
    apm::FPackage* p_parent = apm::ind_package_Find(parent_Get(row));
    if (UNLIKELY(!p_parent)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_package" << Keyval("key", parent_Get(row));
        return false;
    }
    // pkgdep: save pointer to parent
    if (true) { // user-defined insert condition
        row.p_parent = p_parent;
    }
    apm::FPackage* p_package = apm::ind_package_Find(package_Get(row));
    if (UNLIKELY(!p_package)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_package" << Keyval("key", package_Get(row));
        return false;
    }
    // pkgdep: save pointer to package
    if (true) { // user-defined insert condition
        row.p_package = p_package;
    }
    // insert pkgdep into index c_pkgdep
    if (true) { // user-defined insert condition
        c_pkgdep_Insert(*p_package, row);
    }
    // insert pkgdep into index c_pkgdep_parent
    if (true) { // user-defined insert condition
        c_pkgdep_parent_Insert(*p_parent, row);
    }
    return retval;
}

// --- apm.FDb.mergefile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FMergefile& apm::mergefile_Alloc() {
    apm::FMergefile* row = mergefile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.mergefile  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.mergefile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FMergefile* apm::mergefile_AllocMaybe() {
    apm::FMergefile *row = (apm::FMergefile*)mergefile_AllocMem();
    if (row) {
        new (row) apm::FMergefile; // call constructor
    }
    return row;
}

// --- apm.FDb.mergefile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::mergefile_AllocMem() {
    u64 new_nelems     = _db.mergefile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FMergefile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mergefile_lary[bsr];
        if (!lev) {
            lev=(apm::FMergefile*)algo_lib::malloc_AllocMem(sizeof(apm::FMergefile) * (u64(1)<<bsr));
            _db.mergefile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mergefile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.mergefile.RemoveAll
// Remove all elements from Lary
void apm::mergefile_RemoveAll() {
    for (u64 n = _db.mergefile_n; n>0; ) {
        n--;
        mergefile_qFind(u64(n)).~FMergefile(); // destroy last element
        _db.mergefile_n = i32(n);
    }
}

// --- apm.FDb.mergefile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::mergefile_RemoveLast() {
    u64 n = _db.mergefile_n;
    if (n > 0) {
        n -= 1;
        mergefile_qFind(u64(n)).~FMergefile();
        _db.mergefile_n = i32(n);
    }
}

// --- apm.FDb.mergefile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::mergefile_XrefMaybe(apm::FMergefile &row) {
    bool retval = true;
    (void)row;
    // insert mergefile into index ind_mergefile
    if (true) { // user-defined insert condition
        bool success = ind_mergefile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_mergefile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.ind_mergefile.Find
// Find row by key. Return NULL if not found.
apm::FMergefile* apm::ind_mergefile_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_mergefile_buckets_n - 1);
    apm::FMergefile* *e = &_db.ind_mergefile_buckets_elems[index];
    apm::FMergefile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mergefile == key;
        if (done) break;
        e         = &ret->ind_mergefile_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_mergefile.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FMergefile& apm::ind_mergefile_FindX(const algo::strptr& key) {
    apm::FMergefile* ret = ind_mergefile_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_mergefile  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_mergefile.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
apm::FMergefile& apm::ind_mergefile_GetOrCreate(const algo::strptr& key) {
    apm::FMergefile* ret = ind_mergefile_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &mergefile_Alloc();
        (*ret).mergefile = key;
        bool good = mergefile_XrefMaybe(*ret);
        if (!good) {
            mergefile_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "apm.create_error  table:ind_mergefile  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- apm.FDb.ind_mergefile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_mergefile_InsertMaybe(apm::FMergefile& row) {
    ind_mergefile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mergefile_next == (apm::FMergefile*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.mergefile) & (_db.ind_mergefile_buckets_n - 1);
        apm::FMergefile* *prev = &_db.ind_mergefile_buckets_elems[index];
        do {
            apm::FMergefile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mergefile == row.mergefile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mergefile_next;
        } while (true);
        if (retval) {
            row.ind_mergefile_next = *prev;
            _db.ind_mergefile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_mergefile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_mergefile_Remove(apm::FMergefile& row) {
    if (LIKELY(row.ind_mergefile_next != (apm::FMergefile*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.mergefile) & (_db.ind_mergefile_buckets_n - 1);
        apm::FMergefile* *prev = &_db.ind_mergefile_buckets_elems[index]; // addr of pointer to current element
        while (apm::FMergefile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mergefile_next; // unlink (singly linked list)
                _db.ind_mergefile_n--;
                row.ind_mergefile_next = (apm::FMergefile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mergefile_next;
        }
    }
}

// --- apm.FDb.ind_mergefile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_mergefile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mergefile_buckets_n;
    u32 new_nelems   = _db.ind_mergefile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FMergefile*);
        u32 new_size = new_nbuckets * sizeof(apm::FMergefile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FMergefile* *new_buckets = (apm::FMergefile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_mergefile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mergefile_buckets_n; i++) {
            apm::FMergefile* elem = _db.ind_mergefile_buckets_elems[i];
            while (elem) {
                apm::FMergefile &row        = *elem;
                apm::FMergefile* next       = row.ind_mergefile_next;
                u32 index          = algo::cstring_Hash(0, row.mergefile) & (new_nbuckets-1);
                row.ind_mergefile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mergefile_buckets_elems, old_size);
        _db.ind_mergefile_buckets_elems = new_buckets;
        _db.ind_mergefile_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.ind_pkgkey.Find
// Find row by key. Return NULL if not found.
apm::FPkgkey* apm::ind_pkgkey_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr150_Hash(0, key) & (_db.ind_pkgkey_buckets_n - 1);
    apm::FPkgkey* *e = &_db.ind_pkgkey_buckets_elems[index];
    apm::FPkgkey* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).pkgkey == key;
        if (done) break;
        e         = &ret->ind_pkgkey_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_pkgkey.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FPkgkey& apm::ind_pkgkey_FindX(const algo::strptr& key) {
    apm::FPkgkey* ret = ind_pkgkey_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_pkgkey  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_pkgkey.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_pkgkey_InsertMaybe(apm::FPkgkey& row) {
    ind_pkgkey_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_pkgkey_next == (apm::FPkgkey*)-1)) {// check if in hash already
        u32 index = algo::Smallstr150_Hash(0, row.pkgkey) & (_db.ind_pkgkey_buckets_n - 1);
        apm::FPkgkey* *prev = &_db.ind_pkgkey_buckets_elems[index];
        do {
            apm::FPkgkey* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).pkgkey == row.pkgkey) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_pkgkey_next;
        } while (true);
        if (retval) {
            row.ind_pkgkey_next = *prev;
            _db.ind_pkgkey_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_pkgkey.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_pkgkey_Remove(apm::FPkgkey& row) {
    if (LIKELY(row.ind_pkgkey_next != (apm::FPkgkey*)-1)) {// check if in hash already
        u32 index = algo::Smallstr150_Hash(0, row.pkgkey) & (_db.ind_pkgkey_buckets_n - 1);
        apm::FPkgkey* *prev = &_db.ind_pkgkey_buckets_elems[index]; // addr of pointer to current element
        while (apm::FPkgkey *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_pkgkey_next; // unlink (singly linked list)
                _db.ind_pkgkey_n--;
                row.ind_pkgkey_next = (apm::FPkgkey*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_pkgkey_next;
        }
    }
}

// --- apm.FDb.ind_pkgkey.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_pkgkey_Reserve(int n) {
    u32 old_nbuckets = _db.ind_pkgkey_buckets_n;
    u32 new_nelems   = _db.ind_pkgkey_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FPkgkey*);
        u32 new_size = new_nbuckets * sizeof(apm::FPkgkey*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FPkgkey* *new_buckets = (apm::FPkgkey**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_pkgkey");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_pkgkey_buckets_n; i++) {
            apm::FPkgkey* elem = _db.ind_pkgkey_buckets_elems[i];
            while (elem) {
                apm::FPkgkey &row        = *elem;
                apm::FPkgkey* next       = row.ind_pkgkey_next;
                u32 index          = algo::Smallstr150_Hash(0, row.pkgkey) & (new_nbuckets-1);
                row.ind_pkgkey_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_pkgkey_buckets_elems, old_size);
        _db.ind_pkgkey_buckets_elems = new_buckets;
        _db.ind_pkgkey_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FCtype& apm::ctype_Alloc() {
    apm::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FCtype* apm::ctype_AllocMaybe() {
    apm::FCtype *row = (apm::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) apm::FCtype; // call constructor
    }
    return row;
}

// --- apm.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FCtype* apm::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    apm::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(apm::FCtype*)algo_lib::malloc_AllocMem(sizeof(apm::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.ctype.RemoveAll
// Remove all elements from Lary
void apm::ctype_RemoveAll() {
    for (u64 n = _db.ctype_n; n>0; ) {
        n--;
        ctype_qFind(u64(n)).~FCtype(); // destroy last element
        _db.ctype_n = i32(n);
    }
}

// --- apm.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(u64(n)).~FCtype();
        _db.ctype_n = i32(n);
    }
}

// --- apm.FDb.ctype.InputMaybe
static bool apm::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::ctype_XrefMaybe(apm::FCtype &row) {
    bool retval = true;
    (void)row;
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
apm::FCtype* apm::ind_ctype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    apm::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    apm::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_ctype.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FCtype& apm::ind_ctype_FindX(const algo::strptr& key) {
    apm::FCtype* ret = ind_ctype_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_ctype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_ctype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
apm::FCtype& apm::ind_ctype_GetOrCreate(const algo::strptr& key) {
    apm::FCtype* ret = ind_ctype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ctype_Alloc();
        (*ret).ctype = key;
        bool good = ctype_XrefMaybe(*ret);
        if (!good) {
            ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "apm.create_error  table:ind_ctype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- apm.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_ctype_InsertMaybe(apm::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (apm::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        apm::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            apm::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_ctype_Remove(apm::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (apm::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        apm::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (apm::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (apm::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- apm.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FCtype*);
        u32 new_size = new_nbuckets * sizeof(apm::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FCtype* *new_buckets = (apm::FCtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            apm::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                apm::FCtype &row        = *elem;
                apm::FCtype* next       = row.ind_ctype_next;
                u32 index          = algo::Smallstr100_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FField& apm::field_Alloc() {
    apm::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FField* apm::field_AllocMaybe() {
    apm::FField *row = (apm::FField*)field_AllocMem();
    if (row) {
        new (row) apm::FField; // call constructor
    }
    return row;
}

// --- apm.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FField* apm::field_InsertMaybe(const dmmeta::Field &value) {
    apm::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(apm::FField*)algo_lib::malloc_AllocMem(sizeof(apm::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.field.RemoveAll
// Remove all elements from Lary
void apm::field_RemoveAll() {
    for (u64 n = _db.field_n; n>0; ) {
        n--;
        field_qFind(u64(n)).~FField(); // destroy last element
        _db.field_n = i32(n);
    }
}

// --- apm.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u64(n)).~FField();
        _db.field_n = i32(n);
    }
}

// --- apm.FDb.field.InputMaybe
static bool apm::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::field_XrefMaybe(apm::FField &row) {
    bool retval = true;
    (void)row;
    apm::FCtype* p_ctype = apm::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    apm::FCtype* p_arg = apm::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    return retval;
}

// --- apm.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
apm::FField* apm::ind_field_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    apm::FField* *e = &_db.ind_field_buckets_elems[index];
    apm::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_field.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FField& apm::ind_field_FindX(const algo::strptr& key) {
    apm::FField* ret = ind_field_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_field  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_field_InsertMaybe(apm::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (apm::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        apm::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            apm::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_field_Remove(apm::FField& row) {
    if (LIKELY(row.ind_field_next != (apm::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        apm::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (apm::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (apm::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- apm.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FField*);
        u32 new_size = new_nbuckets * sizeof(apm::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FField* *new_buckets = (apm::FField**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            apm::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                apm::FField &row        = *elem;
                apm::FField* next       = row.ind_field_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FSsimfile& apm::ssimfile_Alloc() {
    apm::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FSsimfile* apm::ssimfile_AllocMaybe() {
    apm::FSsimfile *row = (apm::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) apm::FSsimfile; // call constructor
    }
    return row;
}

// --- apm.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FSsimfile* apm::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    apm::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(apm::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(apm::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.ssimfile.RemoveAll
// Remove all elements from Lary
void apm::ssimfile_RemoveAll() {
    for (u64 n = _db.ssimfile_n; n>0; ) {
        n--;
        ssimfile_qFind(u64(n)).~FSsimfile(); // destroy last element
        _db.ssimfile_n = i32(n);
    }
}

// --- apm.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = i32(n);
    }
}

// --- apm.FDb.ssimfile.InputMaybe
static bool apm::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::ssimfile_XrefMaybe(apm::FSsimfile &row) {
    bool retval = true;
    (void)row;
    apm::FCtype* p_ctype = apm::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        bool success = c_ssimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FCtype.c_ssimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
apm::FSsimfile* apm::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    apm::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    apm::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_ssimfile.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FSsimfile& apm::ind_ssimfile_FindX(const algo::strptr& key) {
    apm::FSsimfile* ret = ind_ssimfile_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_ssimfile_InsertMaybe(apm::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (apm::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        apm::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            apm::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_ssimfile_Remove(apm::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (apm::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        apm::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (apm::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (apm::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- apm.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(apm::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FSsimfile* *new_buckets = (apm::FSsimfile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            apm::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                apm::FSsimfile &row        = *elem;
                apm::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.rec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FRec& apm::rec_Alloc() {
    apm::FRec* row = rec_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.rec  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.rec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FRec* apm::rec_AllocMaybe() {
    apm::FRec *row = (apm::FRec*)rec_AllocMem();
    if (row) {
        new (row) apm::FRec; // call constructor
    }
    return row;
}

// --- apm.FDb.rec.Delete
// Remove row from all global and cross indices, then deallocate row
void apm::rec_Delete(apm::FRec &row) {
    row.~FRec();
    rec_FreeMem(row);
}

// --- apm.FDb.rec.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* apm::rec_AllocMem() {
    apm::FRec *row = _db.rec_free;
    if (UNLIKELY(!row)) {
        rec_Reserve(1);
        row = _db.rec_free;
    }
    if (row) {
        _db.rec_free = row->rec_next;
    }
    return row;
}

// --- apm.FDb.rec.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void apm::rec_FreeMem(apm::FRec &row) {
    if (UNLIKELY(row.rec_next != (apm::FRec*)-1)) {
        FatalErrorExit("apm.tpool_double_delete  pool:apm.FDb.rec  comment:'double deletion caught'");
    }
    row.rec_next = _db.rec_free; // insert into free list
    _db.rec_free  = &row;
}

// --- apm.FDb.rec.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 apm::rec_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.rec_blocksize; // underlying allocator is probably Lpool
        u64 reserved = rec_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- apm.FDb.rec.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 apm::rec_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(apm::FRec)) {
        apm::FRec *mem = (apm::FRec*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(apm::FRec) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].rec_next = _db.rec_free;
            _db.rec_free = mem+i;
        }
    }
    return ret;
}

// --- apm.FDb.rec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::rec_XrefMaybe(apm::FRec &row) {
    bool retval = true;
    (void)row;
    // insert rec into index ind_rec
    if (true) { // user-defined insert condition
        bool success = ind_rec_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_rec"; // check for duplicate key
            return false;
        }
    }
    // insert rec into index zd_rec
    if (true) { // user-defined insert condition
        zd_rec_Insert(row);
    }
    apm::FSsimfile* p_p_ssimfile = row.p_ssimfile;
    if (UNLIKELY(!p_p_ssimfile)) {
        algo_lib::ResetErrtext() << "apm.null_ref  xref:apm.FSsimfile.zd_ssimfile_rec";
        return false;
    }
    // insert rec into index zd_ssimfile_rec
    if (true) { // user-defined insert condition
        zd_ssimfile_rec_Insert(*p_p_ssimfile, row);
    }
    return retval;
}

// --- apm.FDb.ind_rec.Find
// Find row by key. Return NULL if not found.
apm::FRec* apm::ind_rec_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_rec_buckets_n - 1);
    apm::FRec* *e = &_db.ind_rec_buckets_elems[index];
    apm::FRec* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).rec == key;
        if (done) break;
        e         = &ret->ind_rec_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_rec.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FRec& apm::ind_rec_FindX(const algo::strptr& key) {
    apm::FRec* ret = ind_rec_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_rec  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_rec.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_rec_InsertMaybe(apm::FRec& row) {
    ind_rec_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_rec_next == (apm::FRec*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.rec) & (_db.ind_rec_buckets_n - 1);
        apm::FRec* *prev = &_db.ind_rec_buckets_elems[index];
        do {
            apm::FRec* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).rec == row.rec) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_rec_next;
        } while (true);
        if (retval) {
            row.ind_rec_next = *prev;
            _db.ind_rec_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_rec.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_rec_Remove(apm::FRec& row) {
    if (LIKELY(row.ind_rec_next != (apm::FRec*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.rec) & (_db.ind_rec_buckets_n - 1);
        apm::FRec* *prev = &_db.ind_rec_buckets_elems[index]; // addr of pointer to current element
        while (apm::FRec *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_rec_next; // unlink (singly linked list)
                _db.ind_rec_n--;
                row.ind_rec_next = (apm::FRec*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_rec_next;
        }
    }
}

// --- apm.FDb.ind_rec.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_rec_Reserve(int n) {
    u32 old_nbuckets = _db.ind_rec_buckets_n;
    u32 new_nelems   = _db.ind_rec_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FRec*);
        u32 new_size = new_nbuckets * sizeof(apm::FRec*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FRec* *new_buckets = (apm::FRec**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_rec");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_rec_buckets_n; i++) {
            apm::FRec* elem = _db.ind_rec_buckets_elems[i];
            while (elem) {
                apm::FRec &row        = *elem;
                apm::FRec* next       = row.ind_rec_next;
                u32 index          = algo::cstring_Hash(0, row.rec) & (new_nbuckets-1);
                row.ind_rec_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_rec_buckets_elems, old_size);
        _db.ind_rec_buckets_elems = new_buckets;
        _db.ind_rec_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.zd_rec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_rec_Insert(apm::FRec& row) {
    if (!zd_rec_InLlistQ(row)) {
        apm::FRec* old_tail = _db.zd_rec_tail;
        row.zd_rec_next = NULL;
        row.zd_rec_prev = old_tail;
        _db.zd_rec_tail = &row;
        apm::FRec **new_row_a = &old_tail->zd_rec_next;
        apm::FRec **new_row_b = &_db.zd_rec_head;
        apm::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_rec_n++;
    }
}

// --- apm.FDb.zd_rec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_rec_Remove(apm::FRec& row) {
    if (zd_rec_InLlistQ(row)) {
        apm::FRec* old_head       = _db.zd_rec_head;
        (void)old_head; // in case it's not used
        apm::FRec* prev = row.zd_rec_prev;
        apm::FRec* next = row.zd_rec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FRec **new_next_a = &prev->zd_rec_next;
        apm::FRec **new_next_b = &_db.zd_rec_head;
        apm::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FRec **new_prev_a = &next->zd_rec_prev;
        apm::FRec **new_prev_b = &_db.zd_rec_tail;
        apm::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_rec_n--;
        row.zd_rec_next=(apm::FRec*)-1; // not-in-list
    }
}

// --- apm.FDb.zd_rec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_rec_RemoveAll() {
    apm::FRec* row = _db.zd_rec_head;
    _db.zd_rec_head = NULL;
    _db.zd_rec_tail = NULL;
    _db.zd_rec_n = 0;
    while (row) {
        apm::FRec* row_next = row->zd_rec_next;
        row->zd_rec_next  = (apm::FRec*)-1;
        row->zd_rec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FDb.zd_rec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FRec* apm::zd_rec_RemoveFirst() {
    apm::FRec *row = NULL;
    row = _db.zd_rec_head;
    if (row) {
        apm::FRec *next = row->zd_rec_next;
        _db.zd_rec_head = next;
        apm::FRec **new_end_a = &next->zd_rec_prev;
        apm::FRec **new_end_b = &_db.zd_rec_tail;
        apm::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_rec_n--;
        row->zd_rec_next = (apm::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FDb.zd_selrec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_selrec_Insert(apm::FRec& row) {
    if (!zd_selrec_InLlistQ(row)) {
        apm::FRec* old_tail = _db.zd_selrec_tail;
        row.zd_selrec_next = NULL;
        row.zd_selrec_prev = old_tail;
        _db.zd_selrec_tail = &row;
        apm::FRec **new_row_a = &old_tail->zd_selrec_next;
        apm::FRec **new_row_b = &_db.zd_selrec_head;
        apm::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_selrec_n++;
    }
}

// --- apm.FDb.zd_selrec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_selrec_Remove(apm::FRec& row) {
    if (zd_selrec_InLlistQ(row)) {
        apm::FRec* old_head       = _db.zd_selrec_head;
        (void)old_head; // in case it's not used
        apm::FRec* prev = row.zd_selrec_prev;
        apm::FRec* next = row.zd_selrec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FRec **new_next_a = &prev->zd_selrec_next;
        apm::FRec **new_next_b = &_db.zd_selrec_head;
        apm::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FRec **new_prev_a = &next->zd_selrec_prev;
        apm::FRec **new_prev_b = &_db.zd_selrec_tail;
        apm::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_selrec_n--;
        row.zd_selrec_next=(apm::FRec*)-1; // not-in-list
    }
}

// --- apm.FDb.zd_selrec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_selrec_RemoveAll() {
    apm::FRec* row = _db.zd_selrec_head;
    _db.zd_selrec_head = NULL;
    _db.zd_selrec_tail = NULL;
    _db.zd_selrec_n = 0;
    while (row) {
        apm::FRec* row_next = row->zd_selrec_next;
        row->zd_selrec_next  = (apm::FRec*)-1;
        row->zd_selrec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FDb.zd_selrec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FRec* apm::zd_selrec_RemoveFirst() {
    apm::FRec *row = NULL;
    row = _db.zd_selrec_head;
    if (row) {
        apm::FRec *next = row->zd_selrec_next;
        _db.zd_selrec_head = next;
        apm::FRec **new_end_a = &next->zd_selrec_prev;
        apm::FRec **new_end_b = &_db.zd_selrec_tail;
        apm::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_selrec_n--;
        row->zd_selrec_next = (apm::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FDb.zd_chooserec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_chooserec_Insert(apm::FRec& row) {
    if (!zd_chooserec_InLlistQ(row)) {
        apm::FRec* old_tail = _db.zd_chooserec_tail;
        row.zd_chooserec_next = NULL;
        row.zd_chooserec_prev = old_tail;
        _db.zd_chooserec_tail = &row;
        apm::FRec **new_row_a = &old_tail->zd_chooserec_next;
        apm::FRec **new_row_b = &_db.zd_chooserec_head;
        apm::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_chooserec_n++;
    }
}

// --- apm.FDb.zd_chooserec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_chooserec_Remove(apm::FRec& row) {
    if (zd_chooserec_InLlistQ(row)) {
        apm::FRec* old_head       = _db.zd_chooserec_head;
        (void)old_head; // in case it's not used
        apm::FRec* prev = row.zd_chooserec_prev;
        apm::FRec* next = row.zd_chooserec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FRec **new_next_a = &prev->zd_chooserec_next;
        apm::FRec **new_next_b = &_db.zd_chooserec_head;
        apm::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FRec **new_prev_a = &next->zd_chooserec_prev;
        apm::FRec **new_prev_b = &_db.zd_chooserec_tail;
        apm::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_chooserec_n--;
        row.zd_chooserec_next=(apm::FRec*)-1; // not-in-list
    }
}

// --- apm.FDb.zd_chooserec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_chooserec_RemoveAll() {
    apm::FRec* row = _db.zd_chooserec_head;
    _db.zd_chooserec_head = NULL;
    _db.zd_chooserec_tail = NULL;
    _db.zd_chooserec_n = 0;
    while (row) {
        apm::FRec* row_next = row->zd_chooserec_next;
        row->zd_chooserec_next  = (apm::FRec*)-1;
        row->zd_chooserec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FDb.zd_chooserec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FRec* apm::zd_chooserec_RemoveFirst() {
    apm::FRec *row = NULL;
    row = _db.zd_chooserec_head;
    if (row) {
        apm::FRec *next = row->zd_chooserec_next;
        _db.zd_chooserec_head = next;
        apm::FRec **new_end_a = &next->zd_chooserec_prev;
        apm::FRec **new_end_b = &_db.zd_chooserec_tail;
        apm::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_chooserec_n--;
        row->zd_chooserec_next = (apm::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FDb.substr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FSubstr& apm::substr_Alloc() {
    apm::FSubstr* row = substr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.substr  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.substr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FSubstr* apm::substr_AllocMaybe() {
    apm::FSubstr *row = (apm::FSubstr*)substr_AllocMem();
    if (row) {
        new (row) apm::FSubstr; // call constructor
    }
    return row;
}

// --- apm.FDb.substr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FSubstr* apm::substr_InsertMaybe(const dmmeta::Substr &value) {
    apm::FSubstr *row = &substr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    substr_CopyIn(*row,const_cast<dmmeta::Substr&>(value));
    bool ok = substr_XrefMaybe(*row); // this may return false
    if (!ok) {
        substr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.substr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::substr_AllocMem() {
    u64 new_nelems     = _db.substr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FSubstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.substr_lary[bsr];
        if (!lev) {
            lev=(apm::FSubstr*)algo_lib::malloc_AllocMem(sizeof(apm::FSubstr) * (u64(1)<<bsr));
            _db.substr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.substr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.substr.RemoveAll
// Remove all elements from Lary
void apm::substr_RemoveAll() {
    for (u64 n = _db.substr_n; n>0; ) {
        n--;
        substr_qFind(u64(n)).~FSubstr(); // destroy last element
        _db.substr_n = i32(n);
    }
}

// --- apm.FDb.substr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::substr_RemoveLast() {
    u64 n = _db.substr_n;
    if (n > 0) {
        n -= 1;
        substr_qFind(u64(n)).~FSubstr();
        _db.substr_n = i32(n);
    }
}

// --- apm.FDb.substr.InputMaybe
static bool apm::substr_InputMaybe(dmmeta::Substr &elem) {
    bool retval = true;
    retval = substr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.substr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::substr_XrefMaybe(apm::FSubstr &row) {
    bool retval = true;
    (void)row;
    apm::FField* p_srcfield = apm::ind_field_Find(row.srcfield);
    if (UNLIKELY(!p_srcfield)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_field" << Keyval("key", row.srcfield);
        return false;
    }
    // substr: save pointer to srcfield
    if (true) { // user-defined insert condition
        row.p_srcfield = p_srcfield;
    }
    apm::FField* p_field = apm::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert substr into index c_substr
    if (true) { // user-defined insert condition
        bool success = c_substr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FField.c_substr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.pkgrec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FPkgrec& apm::pkgrec_Alloc() {
    apm::FPkgrec* row = pkgrec_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.pkgrec  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.pkgrec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FPkgrec* apm::pkgrec_AllocMaybe() {
    apm::FPkgrec *row = (apm::FPkgrec*)pkgrec_AllocMem();
    if (row) {
        new (row) apm::FPkgrec; // call constructor
    }
    return row;
}

// --- apm.FDb.pkgrec.Delete
// Remove row from all global and cross indices, then deallocate row
void apm::pkgrec_Delete(apm::FPkgrec &row) {
    row.~FPkgrec();
    pkgrec_FreeMem(row);
}

// --- apm.FDb.pkgrec.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* apm::pkgrec_AllocMem() {
    apm::FPkgrec *row = _db.pkgrec_free;
    if (UNLIKELY(!row)) {
        pkgrec_Reserve(1);
        row = _db.pkgrec_free;
    }
    if (row) {
        _db.pkgrec_free = row->pkgrec_next;
    }
    return row;
}

// --- apm.FDb.pkgrec.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void apm::pkgrec_FreeMem(apm::FPkgrec &row) {
    if (UNLIKELY(row.pkgrec_next != (apm::FPkgrec*)-1)) {
        FatalErrorExit("apm.tpool_double_delete  pool:apm.FDb.pkgrec  comment:'double deletion caught'");
    }
    row.pkgrec_next = _db.pkgrec_free; // insert into free list
    _db.pkgrec_free  = &row;
}

// --- apm.FDb.pkgrec.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 apm::pkgrec_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.pkgrec_blocksize; // underlying allocator is probably Lpool
        u64 reserved = pkgrec_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- apm.FDb.pkgrec.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 apm::pkgrec_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(apm::FPkgrec)) {
        apm::FPkgrec *mem = (apm::FPkgrec*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(apm::FPkgrec) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].pkgrec_next = _db.pkgrec_free;
            _db.pkgrec_free = mem+i;
        }
    }
    return ret;
}

// --- apm.FDb.pkgrec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::pkgrec_XrefMaybe(apm::FPkgrec &row) {
    bool retval = true;
    (void)row;
    apm::FPackage* p_p_package = row.p_package;
    if (UNLIKELY(!p_p_package)) {
        algo_lib::ResetErrtext() << "apm.null_ref  xref:apm.FPackage.zd_pkgrec";
        return false;
    }
    // insert pkgrec into index zd_pkgrec
    if (true) { // user-defined insert condition
        zd_pkgrec_Insert(*p_p_package, row);
    }
    apm::FRec* p_p_rec = row.p_rec;
    if (UNLIKELY(!p_p_rec)) {
        algo_lib::ResetErrtext() << "apm.null_ref  xref:apm.FRec.zd_rec_pkgrec";
        return false;
    }
    // insert pkgrec into index zd_rec_pkgrec
    if (true) { // user-defined insert condition
        zd_rec_pkgrec_Insert(*p_p_rec, row);
    }
    apm::FPkgkey* p_p_pkgkey = row.p_pkgkey;
    if (UNLIKELY(!p_p_pkgkey)) {
        algo_lib::ResetErrtext() << "apm.null_ref  xref:apm.FPkgkey.c_pkgrec";
        return false;
    }
    // insert pkgrec into index c_pkgrec
    if (true) { // user-defined insert condition
        c_pkgrec_Insert(*p_p_pkgkey, row);
    }
    return retval;
}

// --- apm.FDb.zd_topo_package.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_topo_package_Insert(apm::FPackage& row) {
    if (!zd_topo_package_InLlistQ(row)) {
        apm::FPackage* old_tail = _db.zd_topo_package_tail;
        row.zd_topo_package_next = NULL;
        row.zd_topo_package_prev = old_tail;
        _db.zd_topo_package_tail = &row;
        apm::FPackage **new_row_a = &old_tail->zd_topo_package_next;
        apm::FPackage **new_row_b = &_db.zd_topo_package_head;
        apm::FPackage **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_topo_package_n++;
    }
}

// --- apm.FDb.zd_topo_package.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_topo_package_Remove(apm::FPackage& row) {
    if (zd_topo_package_InLlistQ(row)) {
        apm::FPackage* old_head       = _db.zd_topo_package_head;
        (void)old_head; // in case it's not used
        apm::FPackage* prev = row.zd_topo_package_prev;
        apm::FPackage* next = row.zd_topo_package_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FPackage **new_next_a = &prev->zd_topo_package_next;
        apm::FPackage **new_next_b = &_db.zd_topo_package_head;
        apm::FPackage **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FPackage **new_prev_a = &next->zd_topo_package_prev;
        apm::FPackage **new_prev_b = &_db.zd_topo_package_tail;
        apm::FPackage **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_topo_package_n--;
        row.zd_topo_package_next=(apm::FPackage*)-1; // not-in-list
    }
}

// --- apm.FDb.zd_topo_package.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_topo_package_RemoveAll() {
    apm::FPackage* row = _db.zd_topo_package_head;
    _db.zd_topo_package_head = NULL;
    _db.zd_topo_package_tail = NULL;
    _db.zd_topo_package_n = 0;
    while (row) {
        apm::FPackage* row_next = row->zd_topo_package_next;
        row->zd_topo_package_next  = (apm::FPackage*)-1;
        row->zd_topo_package_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FDb.zd_topo_package.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FPackage* apm::zd_topo_package_RemoveFirst() {
    apm::FPackage *row = NULL;
    row = _db.zd_topo_package_head;
    if (row) {
        apm::FPackage *next = row->zd_topo_package_next;
        _db.zd_topo_package_head = next;
        apm::FPackage **new_end_a = &next->zd_topo_package_prev;
        apm::FPackage **new_end_b = &_db.zd_topo_package_tail;
        apm::FPackage **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_topo_package_n--;
        row->zd_topo_package_next = (apm::FPackage*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FDb.ssimreq.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FSsimreq& apm::ssimreq_Alloc() {
    apm::FSsimreq* row = ssimreq_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.ssimreq  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.ssimreq.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FSsimreq* apm::ssimreq_AllocMaybe() {
    apm::FSsimreq *row = (apm::FSsimreq*)ssimreq_AllocMem();
    if (row) {
        new (row) apm::FSsimreq; // call constructor
    }
    return row;
}

// --- apm.FDb.ssimreq.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FSsimreq* apm::ssimreq_InsertMaybe(const dmmeta::Ssimreq &value) {
    apm::FSsimreq *row = &ssimreq_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimreq_CopyIn(*row,const_cast<dmmeta::Ssimreq&>(value));
    bool ok = ssimreq_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimreq_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.ssimreq.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::ssimreq_AllocMem() {
    u64 new_nelems     = _db.ssimreq_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FSsimreq*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimreq_lary[bsr];
        if (!lev) {
            lev=(apm::FSsimreq*)algo_lib::malloc_AllocMem(sizeof(apm::FSsimreq) * (u64(1)<<bsr));
            _db.ssimreq_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimreq_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.ssimreq.RemoveAll
// Remove all elements from Lary
void apm::ssimreq_RemoveAll() {
    for (u64 n = _db.ssimreq_n; n>0; ) {
        n--;
        ssimreq_qFind(u64(n)).~FSsimreq(); // destroy last element
        _db.ssimreq_n = i32(n);
    }
}

// --- apm.FDb.ssimreq.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::ssimreq_RemoveLast() {
    u64 n = _db.ssimreq_n;
    if (n > 0) {
        n -= 1;
        ssimreq_qFind(u64(n)).~FSsimreq();
        _db.ssimreq_n = i32(n);
    }
}

// --- apm.FDb.ssimreq.InputMaybe
static bool apm::ssimreq_InputMaybe(dmmeta::Ssimreq &elem) {
    bool retval = true;
    retval = ssimreq_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.ssimreq.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::ssimreq_XrefMaybe(apm::FSsimreq &row) {
    bool retval = true;
    (void)row;
    apm::FSsimfile* p_child_ssimfile = apm::ind_ssimfile_Find(child_ssimfile_Get(row));
    if (UNLIKELY(!p_child_ssimfile)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_ssimfile" << Keyval("key", child_ssimfile_Get(row));
        return false;
    }
    // ssimreq: save pointer to child_ssimfile
    if (true) { // user-defined insert condition
        row.p_child_ssimfile = p_child_ssimfile;
    }
    apm::FCtype* p_parent_ctype = apm::ind_ctype_Find(parent_ctype_Get(row));
    if (UNLIKELY(!p_parent_ctype)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_ctype" << Keyval("key", parent_ctype_Get(row));
        return false;
    }
    // ssimreq: save pointer to parent_ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_parent_ctype;
    }
    apm::FField* p_parent_field = apm::ind_field_Find(parent_field_Get(row));
    if (UNLIKELY(!p_parent_field)) {
        algo_lib::ResetErrtext() << "apm.bad_xref  index:apm.FDb.ind_field" << Keyval("key", parent_field_Get(row));
        return false;
    }
    // ssimreq: save pointer to parent_field
    if (true) { // user-defined insert condition
        row.p_field = p_parent_field;
    }
    // insert ssimreq into index c_ssimreq
    if (true) { // user-defined insert condition
        c_ssimreq_Insert(*p_parent_ctype, row);
    }
    return retval;
}

// --- apm.FDb.mkdir.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FMkdir& apm::mkdir_Alloc() {
    apm::FMkdir* row = mkdir_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.mkdir  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.mkdir.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FMkdir* apm::mkdir_AllocMaybe() {
    apm::FMkdir *row = (apm::FMkdir*)mkdir_AllocMem();
    if (row) {
        new (row) apm::FMkdir; // call constructor
    }
    return row;
}

// --- apm.FDb.mkdir.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::mkdir_AllocMem() {
    u64 new_nelems     = _db.mkdir_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FMkdir*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mkdir_lary[bsr];
        if (!lev) {
            lev=(apm::FMkdir*)algo_lib::malloc_AllocMem(sizeof(apm::FMkdir) * (u64(1)<<bsr));
            _db.mkdir_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mkdir_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.mkdir.RemoveAll
// Remove all elements from Lary
void apm::mkdir_RemoveAll() {
    for (u64 n = _db.mkdir_n; n>0; ) {
        n--;
        mkdir_qFind(u64(n)).~FMkdir(); // destroy last element
        _db.mkdir_n = i32(n);
    }
}

// --- apm.FDb.mkdir.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::mkdir_RemoveLast() {
    u64 n = _db.mkdir_n;
    if (n > 0) {
        n -= 1;
        mkdir_qFind(u64(n)).~FMkdir();
        _db.mkdir_n = i32(n);
    }
}

// --- apm.FDb.mkdir.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::mkdir_XrefMaybe(apm::FMkdir &row) {
    bool retval = true;
    (void)row;
    // insert mkdir into index ind_mkdir
    if (true) { // user-defined insert condition
        bool success = ind_mkdir_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "apm.duplicate_key  xref:apm.FDb.ind_mkdir"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- apm.FDb.ind_mkdir.Find
// Find row by key. Return NULL if not found.
apm::FMkdir* apm::ind_mkdir_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_mkdir_buckets_n - 1);
    apm::FMkdir* *e = &_db.ind_mkdir_buckets_elems[index];
    apm::FMkdir* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mkdir == key;
        if (done) break;
        e         = &ret->ind_mkdir_next;
    } while (true);
    return ret;
}

// --- apm.FDb.ind_mkdir.FindX
// Look up row by key and return reference. Throw exception if not found
apm::FMkdir& apm::ind_mkdir_FindX(const algo::strptr& key) {
    apm::FMkdir* ret = ind_mkdir_Find(key);
    vrfy(ret, tempstr() << "apm.key_error  table:ind_mkdir  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- apm.FDb.ind_mkdir.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
apm::FMkdir& apm::ind_mkdir_GetOrCreate(const algo::strptr& key) {
    apm::FMkdir* ret = ind_mkdir_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &mkdir_Alloc();
        (*ret).mkdir = key;
        bool good = mkdir_XrefMaybe(*ret);
        if (!good) {
            mkdir_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "apm.create_error  table:ind_mkdir  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- apm.FDb.ind_mkdir.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool apm::ind_mkdir_InsertMaybe(apm::FMkdir& row) {
    ind_mkdir_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mkdir_next == (apm::FMkdir*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.mkdir) & (_db.ind_mkdir_buckets_n - 1);
        apm::FMkdir* *prev = &_db.ind_mkdir_buckets_elems[index];
        do {
            apm::FMkdir* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mkdir == row.mkdir) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mkdir_next;
        } while (true);
        if (retval) {
            row.ind_mkdir_next = *prev;
            _db.ind_mkdir_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- apm.FDb.ind_mkdir.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void apm::ind_mkdir_Remove(apm::FMkdir& row) {
    if (LIKELY(row.ind_mkdir_next != (apm::FMkdir*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.mkdir) & (_db.ind_mkdir_buckets_n - 1);
        apm::FMkdir* *prev = &_db.ind_mkdir_buckets_elems[index]; // addr of pointer to current element
        while (apm::FMkdir *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mkdir_next; // unlink (singly linked list)
                _db.ind_mkdir_n--;
                row.ind_mkdir_next = (apm::FMkdir*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mkdir_next;
        }
    }
}

// --- apm.FDb.ind_mkdir.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void apm::ind_mkdir_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mkdir_buckets_n;
    u32 new_nelems   = _db.ind_mkdir_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(apm::FMkdir*);
        u32 new_size = new_nbuckets * sizeof(apm::FMkdir*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        apm::FMkdir* *new_buckets = (apm::FMkdir**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FDb.ind_mkdir");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mkdir_buckets_n; i++) {
            apm::FMkdir* elem = _db.ind_mkdir_buckets_elems[i];
            while (elem) {
                apm::FMkdir &row        = *elem;
                apm::FMkdir* next       = row.ind_mkdir_next;
                u32 index          = algo::cstring_Hash(0, row.mkdir) & (new_nbuckets-1);
                row.ind_mkdir_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mkdir_buckets_elems, old_size);
        _db.ind_mkdir_buckets_elems = new_buckets;
        _db.ind_mkdir_buckets_n = new_nbuckets;
    }
}

// --- apm.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
apm::FNs& apm::ns_Alloc() {
    apm::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("apm.out_of_mem  field:apm.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- apm.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
apm::FNs* apm::ns_AllocMaybe() {
    apm::FNs *row = (apm::FNs*)ns_AllocMem();
    if (row) {
        new (row) apm::FNs; // call constructor
    }
    return row;
}

// --- apm.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
apm::FNs* apm::ns_InsertMaybe(const dmmeta::Ns &value) {
    apm::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- apm.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* apm::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    apm::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(apm::FNs*)algo_lib::malloc_AllocMem(sizeof(apm::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- apm.FDb.ns.RemoveAll
// Remove all elements from Lary
void apm::ns_RemoveAll() {
    for (u64 n = _db.ns_n; n>0; ) {
        n--;
        ns_qFind(u64(n)).~FNs(); // destroy last element
        _db.ns_n = i32(n);
    }
}

// --- apm.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void apm::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = i32(n);
    }
}

// --- apm.FDb.ns.InputMaybe
static bool apm::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- apm.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool apm::ns_XrefMaybe(apm::FNs &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- apm.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr apm::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- apm.FDb.trace.N
// Function return 1
inline static i32 apm::trace_N() {
    return 1;
}

// --- apm.FDb..Init
// Set all fields to initial values.
void apm::FDb_Init() {
    // initialize LAry package (apm.FDb.package)
    _db.package_n = 0;
    memset(_db.package_lary, 0, sizeof(_db.package_lary)); // zero out all level pointers
    apm::FPackage* package_first = (apm::FPackage*)algo_lib::malloc_AllocMem(sizeof(apm::FPackage) * (u64(1)<<4));
    if (!package_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.package_lary[i]  = package_first;
        package_first    += 1ULL<<i;
    }
    _db.zd_sel_package_head = NULL; // (apm.FDb.zd_sel_package)
    _db.zd_sel_package_n = 0; // (apm.FDb.zd_sel_package)
    _db.zd_sel_package_tail = NULL; // (apm.FDb.zd_sel_package)
    // initialize hash table for apm::FPackage;
    _db.ind_package_n             	= 0; // (apm.FDb.ind_package)
    _db.ind_package_buckets_n     	= 4; // (apm.FDb.ind_package)
    _db.ind_package_buckets_elems 	= (apm::FPackage**)algo_lib::malloc_AllocMem(sizeof(apm::FPackage*)*_db.ind_package_buckets_n); // initial buckets (apm.FDb.ind_package)
    if (!_db.ind_package_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_package)
    }
    memset(_db.ind_package_buckets_elems, 0, sizeof(apm::FPackage*)*_db.ind_package_buckets_n); // (apm.FDb.ind_package)
    // initialize LAry pkgkey (apm.FDb.pkgkey)
    _db.pkgkey_n = 0;
    memset(_db.pkgkey_lary, 0, sizeof(_db.pkgkey_lary)); // zero out all level pointers
    apm::FPkgkey* pkgkey_first = (apm::FPkgkey*)algo_lib::malloc_AllocMem(sizeof(apm::FPkgkey) * (u64(1)<<4));
    if (!pkgkey_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pkgkey_lary[i]  = pkgkey_first;
        pkgkey_first    += 1ULL<<i;
    }
    // initialize LAry pkgdep (apm.FDb.pkgdep)
    _db.pkgdep_n = 0;
    memset(_db.pkgdep_lary, 0, sizeof(_db.pkgdep_lary)); // zero out all level pointers
    apm::FPkgdep* pkgdep_first = (apm::FPkgdep*)algo_lib::malloc_AllocMem(sizeof(apm::FPkgdep) * (u64(1)<<4));
    if (!pkgdep_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pkgdep_lary[i]  = pkgdep_first;
        pkgdep_first    += 1ULL<<i;
    }
    // initialize LAry mergefile (apm.FDb.mergefile)
    _db.mergefile_n = 0;
    memset(_db.mergefile_lary, 0, sizeof(_db.mergefile_lary)); // zero out all level pointers
    apm::FMergefile* mergefile_first = (apm::FMergefile*)algo_lib::malloc_AllocMem(sizeof(apm::FMergefile) * (u64(1)<<4));
    if (!mergefile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mergefile_lary[i]  = mergefile_first;
        mergefile_first    += 1ULL<<i;
    }
    // initialize hash table for apm::FMergefile;
    _db.ind_mergefile_n             	= 0; // (apm.FDb.ind_mergefile)
    _db.ind_mergefile_buckets_n     	= 4; // (apm.FDb.ind_mergefile)
    _db.ind_mergefile_buckets_elems 	= (apm::FMergefile**)algo_lib::malloc_AllocMem(sizeof(apm::FMergefile*)*_db.ind_mergefile_buckets_n); // initial buckets (apm.FDb.ind_mergefile)
    if (!_db.ind_mergefile_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_mergefile)
    }
    memset(_db.ind_mergefile_buckets_elems, 0, sizeof(apm::FMergefile*)*_db.ind_mergefile_buckets_n); // (apm.FDb.ind_mergefile)
    // initialize hash table for apm::FPkgkey;
    _db.ind_pkgkey_n             	= 0; // (apm.FDb.ind_pkgkey)
    _db.ind_pkgkey_buckets_n     	= 4; // (apm.FDb.ind_pkgkey)
    _db.ind_pkgkey_buckets_elems 	= (apm::FPkgkey**)algo_lib::malloc_AllocMem(sizeof(apm::FPkgkey*)*_db.ind_pkgkey_buckets_n); // initial buckets (apm.FDb.ind_pkgkey)
    if (!_db.ind_pkgkey_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_pkgkey)
    }
    memset(_db.ind_pkgkey_buckets_elems, 0, sizeof(apm::FPkgkey*)*_db.ind_pkgkey_buckets_n); // (apm.FDb.ind_pkgkey)
    // initialize LAry ctype (apm.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    apm::FCtype* ctype_first = (apm::FCtype*)algo_lib::malloc_AllocMem(sizeof(apm::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // initialize hash table for apm::FCtype;
    _db.ind_ctype_n             	= 0; // (apm.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (apm.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (apm::FCtype**)algo_lib::malloc_AllocMem(sizeof(apm::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (apm.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(apm::FCtype*)*_db.ind_ctype_buckets_n); // (apm.FDb.ind_ctype)
    // initialize LAry field (apm.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    apm::FField* field_first = (apm::FField*)algo_lib::malloc_AllocMem(sizeof(apm::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize hash table for apm::FField;
    _db.ind_field_n             	= 0; // (apm.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (apm.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (apm::FField**)algo_lib::malloc_AllocMem(sizeof(apm::FField*)*_db.ind_field_buckets_n); // initial buckets (apm.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(apm::FField*)*_db.ind_field_buckets_n); // (apm.FDb.ind_field)
    // initialize LAry ssimfile (apm.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    apm::FSsimfile* ssimfile_first = (apm::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(apm::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize hash table for apm::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (apm.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (apm.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (apm::FSsimfile**)algo_lib::malloc_AllocMem(sizeof(apm::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (apm.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(apm::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (apm.FDb.ind_ssimfile)
    // rec: initialize Tpool
    _db.rec_free      = NULL;
    _db.rec_blocksize = algo::BumpToPow2(64 * sizeof(apm::FRec)); // allocate 64-127 elements at a time
    // initialize hash table for apm::FRec;
    _db.ind_rec_n             	= 0; // (apm.FDb.ind_rec)
    _db.ind_rec_buckets_n     	= 4; // (apm.FDb.ind_rec)
    _db.ind_rec_buckets_elems 	= (apm::FRec**)algo_lib::malloc_AllocMem(sizeof(apm::FRec*)*_db.ind_rec_buckets_n); // initial buckets (apm.FDb.ind_rec)
    if (!_db.ind_rec_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_rec)
    }
    memset(_db.ind_rec_buckets_elems, 0, sizeof(apm::FRec*)*_db.ind_rec_buckets_n); // (apm.FDb.ind_rec)
    _db.zd_rec_head = NULL; // (apm.FDb.zd_rec)
    _db.zd_rec_n = 0; // (apm.FDb.zd_rec)
    _db.zd_rec_tail = NULL; // (apm.FDb.zd_rec)
    _db.zd_selrec_head = NULL; // (apm.FDb.zd_selrec)
    _db.zd_selrec_n = 0; // (apm.FDb.zd_selrec)
    _db.zd_selrec_tail = NULL; // (apm.FDb.zd_selrec)
    _db.zd_chooserec_head = NULL; // (apm.FDb.zd_chooserec)
    _db.zd_chooserec_n = 0; // (apm.FDb.zd_chooserec)
    _db.zd_chooserec_tail = NULL; // (apm.FDb.zd_chooserec)
    // initialize LAry substr (apm.FDb.substr)
    _db.substr_n = 0;
    memset(_db.substr_lary, 0, sizeof(_db.substr_lary)); // zero out all level pointers
    apm::FSubstr* substr_first = (apm::FSubstr*)algo_lib::malloc_AllocMem(sizeof(apm::FSubstr) * (u64(1)<<4));
    if (!substr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.substr_lary[i]  = substr_first;
        substr_first    += 1ULL<<i;
    }
    // pkgrec: initialize Tpool
    _db.pkgrec_free      = NULL;
    _db.pkgrec_blocksize = algo::BumpToPow2(64 * sizeof(apm::FPkgrec)); // allocate 64-127 elements at a time
    _db.zd_topo_package_head = NULL; // (apm.FDb.zd_topo_package)
    _db.zd_topo_package_n = 0; // (apm.FDb.zd_topo_package)
    _db.zd_topo_package_tail = NULL; // (apm.FDb.zd_topo_package)
    // initialize LAry ssimreq (apm.FDb.ssimreq)
    _db.ssimreq_n = 0;
    memset(_db.ssimreq_lary, 0, sizeof(_db.ssimreq_lary)); // zero out all level pointers
    apm::FSsimreq* ssimreq_first = (apm::FSsimreq*)algo_lib::malloc_AllocMem(sizeof(apm::FSsimreq) * (u64(1)<<4));
    if (!ssimreq_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimreq_lary[i]  = ssimreq_first;
        ssimreq_first    += 1ULL<<i;
    }
    // initialize LAry mkdir (apm.FDb.mkdir)
    _db.mkdir_n = 0;
    memset(_db.mkdir_lary, 0, sizeof(_db.mkdir_lary)); // zero out all level pointers
    apm::FMkdir* mkdir_first = (apm::FMkdir*)algo_lib::malloc_AllocMem(sizeof(apm::FMkdir) * (u64(1)<<4));
    if (!mkdir_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mkdir_lary[i]  = mkdir_first;
        mkdir_first    += 1ULL<<i;
    }
    // initialize hash table for apm::FMkdir;
    _db.ind_mkdir_n             	= 0; // (apm.FDb.ind_mkdir)
    _db.ind_mkdir_buckets_n     	= 4; // (apm.FDb.ind_mkdir)
    _db.ind_mkdir_buckets_elems 	= (apm::FMkdir**)algo_lib::malloc_AllocMem(sizeof(apm::FMkdir*)*_db.ind_mkdir_buckets_n); // initial buckets (apm.FDb.ind_mkdir)
    if (!_db.ind_mkdir_buckets_elems) {
        FatalErrorExit("out of memory"); // (apm.FDb.ind_mkdir)
    }
    memset(_db.ind_mkdir_buckets_elems, 0, sizeof(apm::FMkdir*)*_db.ind_mkdir_buckets_n); // (apm.FDb.ind_mkdir)
    // initialize LAry ns (apm.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    apm::FNs* ns_first = (apm::FNs*)algo_lib::malloc_AllocMem(sizeof(apm::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }

    apm::InitReflection();
}

// --- apm.FDb..Uninit
void apm::FDb_Uninit() {
    apm::FDb &row = _db; (void)row;

    // apm.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_mkdir.Uninit (Thash)  //
    // skip destruction of ind_mkdir in global scope

    // apm.FDb.mkdir.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ssimreq.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.substr.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_rec.Uninit (Thash)  //
    // skip destruction of ind_rec in global scope

    // apm.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // apm.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // apm.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // apm.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_pkgkey.Uninit (Thash)  //
    // skip destruction of ind_pkgkey in global scope

    // apm.FDb.ind_mergefile.Uninit (Thash)  //
    // skip destruction of ind_mergefile in global scope

    // apm.FDb.mergefile.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.pkgdep.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.pkgkey.Uninit (Lary)  //
    // skip destruction in global scope

    // apm.FDb.ind_package.Uninit (Thash)  //
    // skip destruction of ind_package in global scope

    // apm.FDb.package.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- apm.FField.base.CopyOut
// Copy fields out of row
void apm::field_CopyOut(apm::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- apm.FField.base.CopyIn
// Copy fields in to row
void apm::field_CopyIn(apm::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- apm.FField.ctype.Get
algo::Smallstr100 apm::ctype_Get(apm::FField& field) {
    algo::Smallstr100 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- apm.FField.ns.Get
algo::Smallstr16 apm::ns_Get(apm::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- apm.FField.name.Get
algo::Smallstr50 apm::name_Get(apm::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- apm.FField..Init
// Set all fields to initial values.
void apm::FField_Init(apm::FField& field) {
    field.reftype = algo::strptr("Val");
    field.p_ctype = NULL;
    field.c_substr = NULL;
    field.p_arg = NULL;
    field.ctype_c_field_in_ary = bool(false);
    field.ind_field_next = (apm::FField*)-1; // (apm.FDb.ind_field) not-in-hash
}

// --- apm.FField..Uninit
void apm::FField_Uninit(apm::FField& field) {
    apm::FField &row = field; (void)row;
    ind_field_Remove(row); // remove field from index ind_field
    apm::FCtype* p_ctype = apm::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
}

// --- apm.FMergefile..Uninit
void apm::FMergefile_Uninit(apm::FMergefile& mergefile) {
    apm::FMergefile &row = mergefile; (void)row;
    ind_mergefile_Remove(row); // remove mergefile from index ind_mergefile
}

// --- apm.FMergefile..Print
// print string representation of ROW to string STR
// cfmt:apm.FMergefile.String  printfmt:Tuple
void apm::FMergefile_Print(apm::FMergefile& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "apm.FMergefile";

    algo::cstring_Print(row.mergefile, temp);
    PrintAttrSpaceReset(str,"mergefile", temp);

    algo::cstring_Print(row.base_file, temp);
    PrintAttrSpaceReset(str,"base_file", temp);

    i32_Print(row.base_mode, temp);
    PrintAttrSpaceReset(str,"base_mode", temp);

    algo::cstring_Print(row.ours_file, temp);
    PrintAttrSpaceReset(str,"ours_file", temp);

    i32_Print(row.ours_mode, temp);
    PrintAttrSpaceReset(str,"ours_mode", temp);

    algo::cstring_Print(row.theirs_file, temp);
    PrintAttrSpaceReset(str,"theirs_file", temp);

    i32_Print(row.theirs_mode, temp);
    PrintAttrSpaceReset(str,"theirs_mode", temp);
}

// --- apm.FMkdir..Uninit
void apm::FMkdir_Uninit(apm::FMkdir& mkdir) {
    apm::FMkdir &row = mkdir; (void)row;
    ind_mkdir_Remove(row); // remove mkdir from index ind_mkdir
}

// --- apm.FNs.base.CopyOut
// Copy fields out of row
void apm::ns_CopyOut(apm::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.license = row.license;
    out.comment = row.comment;
}

// --- apm.FNs.base.CopyIn
// Copy fields in to row
void apm::ns_CopyIn(apm::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.license = in.license;
    row.comment = in.comment;
}

// --- apm.FPackage.base.CopyOut
// Copy fields out of row
void apm::package_CopyOut(apm::FPackage &row, dev::Package &out) {
    out.package = row.package;
    out.baseref = row.baseref;
    out.origin = row.origin;
    out.comment = row.comment;
}

// --- apm.FPackage.base.CopyIn
// Copy fields in to row
void apm::package_CopyIn(apm::FPackage &row, dev::Package &in) {
    row.package = in.package;
    row.baseref = in.baseref;
    row.origin = in.origin;
    row.comment = in.comment;
}

// --- apm.FPackage.zd_pkgkey.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_pkgkey_Insert(apm::FPackage& package, apm::FPkgkey& row) {
    if (!zd_pkgkey_InLlistQ(row)) {
        apm::FPkgkey* old_tail = package.zd_pkgkey_tail;
        row.zd_pkgkey_next = NULL;
        row.zd_pkgkey_prev = old_tail;
        package.zd_pkgkey_tail = &row;
        apm::FPkgkey **new_row_a = &old_tail->zd_pkgkey_next;
        apm::FPkgkey **new_row_b = &package.zd_pkgkey_head;
        apm::FPkgkey **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        package.zd_pkgkey_n++;
    }
}

// --- apm.FPackage.zd_pkgkey.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_pkgkey_Remove(apm::FPackage& package, apm::FPkgkey& row) {
    if (zd_pkgkey_InLlistQ(row)) {
        apm::FPkgkey* old_head       = package.zd_pkgkey_head;
        (void)old_head; // in case it's not used
        apm::FPkgkey* prev = row.zd_pkgkey_prev;
        apm::FPkgkey* next = row.zd_pkgkey_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FPkgkey **new_next_a = &prev->zd_pkgkey_next;
        apm::FPkgkey **new_next_b = &package.zd_pkgkey_head;
        apm::FPkgkey **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FPkgkey **new_prev_a = &next->zd_pkgkey_prev;
        apm::FPkgkey **new_prev_b = &package.zd_pkgkey_tail;
        apm::FPkgkey **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        package.zd_pkgkey_n--;
        row.zd_pkgkey_next=(apm::FPkgkey*)-1; // not-in-list
    }
}

// --- apm.FPackage.zd_pkgkey.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_pkgkey_RemoveAll(apm::FPackage& package) {
    apm::FPkgkey* row = package.zd_pkgkey_head;
    package.zd_pkgkey_head = NULL;
    package.zd_pkgkey_tail = NULL;
    package.zd_pkgkey_n = 0;
    while (row) {
        apm::FPkgkey* row_next = row->zd_pkgkey_next;
        row->zd_pkgkey_next  = (apm::FPkgkey*)-1;
        row->zd_pkgkey_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FPackage.zd_pkgkey.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FPkgkey* apm::zd_pkgkey_RemoveFirst(apm::FPackage& package) {
    apm::FPkgkey *row = NULL;
    row = package.zd_pkgkey_head;
    if (row) {
        apm::FPkgkey *next = row->zd_pkgkey_next;
        package.zd_pkgkey_head = next;
        apm::FPkgkey **new_end_a = &next->zd_pkgkey_prev;
        apm::FPkgkey **new_end_b = &package.zd_pkgkey_tail;
        apm::FPkgkey **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        package.zd_pkgkey_n--;
        row->zd_pkgkey_next = (apm::FPkgkey*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FPackage.c_pkgdep.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_pkgdep_Insert(apm::FPackage& package, apm::FPkgdep& row) {
    if (bool_Update(row.package_c_pkgdep_in_ary,true)) {
        // reserve space
        c_pkgdep_Reserve(package, 1);
        u32 n  = package.c_pkgdep_n;
        u32 at = n;
        apm::FPkgdep* *elems = package.c_pkgdep_elems;
        elems[at] = &row;
        package.c_pkgdep_n = n+1;

    }
}

// --- apm.FPackage.c_pkgdep.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool apm::c_pkgdep_InsertMaybe(apm::FPackage& package, apm::FPkgdep& row) {
    bool retval = !row.package_c_pkgdep_in_ary;
    c_pkgdep_Insert(package,row); // check is performed in _Insert again
    return retval;
}

// --- apm.FPackage.c_pkgdep.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_pkgdep_Remove(apm::FPackage& package, apm::FPkgdep& row) {
    if (bool_Update(row.package_c_pkgdep_in_ary,false)) {
        int lim = package.c_pkgdep_n;
        apm::FPkgdep* *elems = package.c_pkgdep_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            apm::FPkgdep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(apm::FPkgdep*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                package.c_pkgdep_n = lim - 1;
                break;
            }
        }
    }
}

// --- apm.FPackage.c_pkgdep.Reserve
// Reserve space in index for N more elements;
void apm::c_pkgdep_Reserve(apm::FPackage& package, u32 n) {
    u32 old_max = package.c_pkgdep_max;
    if (UNLIKELY(package.c_pkgdep_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FPkgdep*);
        u32 new_size = new_max * sizeof(apm::FPkgdep*);
        void *new_mem = algo_lib::malloc_ReallocMem(package.c_pkgdep_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FPackage.c_pkgdep");
        }
        package.c_pkgdep_elems = (apm::FPkgdep**)new_mem;
        package.c_pkgdep_max = new_max;
    }
}

// --- apm.FPackage.c_pkgdep_parent.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_pkgdep_parent_Insert(apm::FPackage& package, apm::FPkgdep& row) {
    if (bool_Update(row.package_c_pkgdep_parent_in_ary,true)) {
        // reserve space
        c_pkgdep_parent_Reserve(package, 1);
        u32 n  = package.c_pkgdep_parent_n;
        u32 at = n;
        apm::FPkgdep* *elems = package.c_pkgdep_parent_elems;
        elems[at] = &row;
        package.c_pkgdep_parent_n = n+1;

    }
}

// --- apm.FPackage.c_pkgdep_parent.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool apm::c_pkgdep_parent_InsertMaybe(apm::FPackage& package, apm::FPkgdep& row) {
    bool retval = !row.package_c_pkgdep_parent_in_ary;
    c_pkgdep_parent_Insert(package,row); // check is performed in _Insert again
    return retval;
}

// --- apm.FPackage.c_pkgdep_parent.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_pkgdep_parent_Remove(apm::FPackage& package, apm::FPkgdep& row) {
    if (bool_Update(row.package_c_pkgdep_parent_in_ary,false)) {
        int lim = package.c_pkgdep_parent_n;
        apm::FPkgdep* *elems = package.c_pkgdep_parent_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            apm::FPkgdep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(apm::FPkgdep*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                package.c_pkgdep_parent_n = lim - 1;
                break;
            }
        }
    }
}

// --- apm.FPackage.c_pkgdep_parent.Reserve
// Reserve space in index for N more elements;
void apm::c_pkgdep_parent_Reserve(apm::FPackage& package, u32 n) {
    u32 old_max = package.c_pkgdep_parent_max;
    if (UNLIKELY(package.c_pkgdep_parent_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FPkgdep*);
        u32 new_size = new_max * sizeof(apm::FPkgdep*);
        void *new_mem = algo_lib::malloc_ReallocMem(package.c_pkgdep_parent_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FPackage.c_pkgdep_parent");
        }
        package.c_pkgdep_parent_elems = (apm::FPkgdep**)new_mem;
        package.c_pkgdep_parent_max = new_max;
    }
}

// --- apm.FPackage.zd_pkgrec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_pkgrec_Insert(apm::FPackage& package, apm::FPkgrec& row) {
    if (!zd_pkgrec_InLlistQ(row)) {
        apm::FPkgrec* old_tail = package.zd_pkgrec_tail;
        row.zd_pkgrec_next = NULL;
        row.zd_pkgrec_prev = old_tail;
        package.zd_pkgrec_tail = &row;
        apm::FPkgrec **new_row_a = &old_tail->zd_pkgrec_next;
        apm::FPkgrec **new_row_b = &package.zd_pkgrec_head;
        apm::FPkgrec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        package.zd_pkgrec_n++;
    }
}

// --- apm.FPackage.zd_pkgrec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_pkgrec_Remove(apm::FPackage& package, apm::FPkgrec& row) {
    if (zd_pkgrec_InLlistQ(row)) {
        apm::FPkgrec* old_head       = package.zd_pkgrec_head;
        (void)old_head; // in case it's not used
        apm::FPkgrec* prev = row.zd_pkgrec_prev;
        apm::FPkgrec* next = row.zd_pkgrec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FPkgrec **new_next_a = &prev->zd_pkgrec_next;
        apm::FPkgrec **new_next_b = &package.zd_pkgrec_head;
        apm::FPkgrec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FPkgrec **new_prev_a = &next->zd_pkgrec_prev;
        apm::FPkgrec **new_prev_b = &package.zd_pkgrec_tail;
        apm::FPkgrec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        package.zd_pkgrec_n--;
        row.zd_pkgrec_next=(apm::FPkgrec*)-1; // not-in-list
    }
}

// --- apm.FPackage.zd_pkgrec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_pkgrec_RemoveAll(apm::FPackage& package) {
    apm::FPkgrec* row = package.zd_pkgrec_head;
    package.zd_pkgrec_head = NULL;
    package.zd_pkgrec_tail = NULL;
    package.zd_pkgrec_n = 0;
    while (row) {
        apm::FPkgrec* row_next = row->zd_pkgrec_next;
        row->zd_pkgrec_next  = (apm::FPkgrec*)-1;
        row->zd_pkgrec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FPackage.zd_pkgrec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FPkgrec* apm::zd_pkgrec_RemoveFirst(apm::FPackage& package) {
    apm::FPkgrec *row = NULL;
    row = package.zd_pkgrec_head;
    if (row) {
        apm::FPkgrec *next = row->zd_pkgrec_next;
        package.zd_pkgrec_head = next;
        apm::FPkgrec **new_end_a = &next->zd_pkgrec_prev;
        apm::FPkgrec **new_end_b = &package.zd_pkgrec_tail;
        apm::FPkgrec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        package.zd_pkgrec_n--;
        row->zd_pkgrec_next = (apm::FPkgrec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FPackage..Uninit
void apm::FPackage_Uninit(apm::FPackage& package) {
    apm::FPackage &row = package; (void)row;
    zd_sel_package_Remove(row); // remove package from index zd_sel_package
    ind_package_Remove(row); // remove package from index ind_package
    zd_topo_package_Remove(row); // remove package from index zd_topo_package

    // apm.FPackage.c_pkgdep_parent.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(package.c_pkgdep_parent_elems, sizeof(apm::FPkgdep*)*package.c_pkgdep_parent_max); // (apm.FPackage.c_pkgdep_parent)

    // apm.FPackage.c_pkgdep.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(package.c_pkgdep_elems, sizeof(apm::FPkgdep*)*package.c_pkgdep_max); // (apm.FPackage.c_pkgdep)
}

// --- apm.FPkgdep.base.CopyOut
// Copy fields out of row
void apm::pkgdep_CopyOut(apm::FPkgdep &row, dev::Pkgdep &out) {
    out.pkgdep = row.pkgdep;
    out.soft = row.soft;
    out.comment = row.comment;
}

// --- apm.FPkgdep.base.CopyIn
// Copy fields in to row
void apm::pkgdep_CopyIn(apm::FPkgdep &row, dev::Pkgdep &in) {
    row.pkgdep = in.pkgdep;
    row.soft = in.soft;
    row.comment = in.comment;
}

// --- apm.FPkgdep.package.Get
algo::Smallstr50 apm::package_Get(apm::FPkgdep& pkgdep) {
    algo::Smallstr50 ret(algo::Pathcomp(pkgdep.pkgdep, ".RL"));
    return ret;
}

// --- apm.FPkgdep.parent.Get
algo::Smallstr50 apm::parent_Get(apm::FPkgdep& pkgdep) {
    algo::Smallstr50 ret(algo::Pathcomp(pkgdep.pkgdep, ".RR"));
    return ret;
}

// --- apm.FPkgdep..Uninit
void apm::FPkgdep_Uninit(apm::FPkgdep& pkgdep) {
    apm::FPkgdep &row = pkgdep; (void)row;
    apm::FPackage* p_package = apm::ind_package_Find(package_Get(row));
    if (p_package)  {
        c_pkgdep_Remove(*p_package, row);// remove pkgdep from index c_pkgdep
    }
    apm::FPackage* p_parent = apm::ind_package_Find(parent_Get(row));
    if (p_parent)  {
        c_pkgdep_parent_Remove(*p_parent, row);// remove pkgdep from index c_pkgdep_parent
    }
}

// --- apm.FPkgkey.base.CopyOut
// Copy fields out of row
void apm::pkgkey_CopyOut(apm::FPkgkey &row, dev::Pkgkey &out) {
    out.pkgkey = row.pkgkey;
    out.comment = row.comment;
}

// --- apm.FPkgkey.base.CopyIn
// Copy fields in to row
void apm::pkgkey_CopyIn(apm::FPkgkey &row, dev::Pkgkey &in) {
    row.pkgkey = in.pkgkey;
    row.comment = in.comment;
}

// --- apm.FPkgkey.package.Get
algo::Smallstr50 apm::package_Get(apm::FPkgkey& pkgkey) {
    algo::Smallstr50 ret(algo::Pathcomp(pkgkey.pkgkey, "/LL"));
    return ret;
}

// --- apm.FPkgkey.key.Get
algo::Smallstr150 apm::key_Get(apm::FPkgkey& pkgkey) {
    algo::Smallstr150 ret(algo::Pathcomp(pkgkey.pkgkey, "/LR"));
    return ret;
}

// --- apm.FPkgkey.c_pkgrec.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_pkgrec_Insert(apm::FPkgkey& pkgkey, apm::FPkgrec& row) {
    if (bool_Update(row.pkgkey_c_pkgrec_in_ary,true)) {
        // reserve space
        c_pkgrec_Reserve(pkgkey, 1);
        u32 n  = pkgkey.c_pkgrec_n;
        u32 at = n;
        apm::FPkgrec* *elems = pkgkey.c_pkgrec_elems;
        elems[at] = &row;
        pkgkey.c_pkgrec_n = n+1;

    }
}

// --- apm.FPkgkey.c_pkgrec.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool apm::c_pkgrec_InsertMaybe(apm::FPkgkey& pkgkey, apm::FPkgrec& row) {
    bool retval = !row.pkgkey_c_pkgrec_in_ary;
    c_pkgrec_Insert(pkgkey,row); // check is performed in _Insert again
    return retval;
}

// --- apm.FPkgkey.c_pkgrec.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_pkgrec_Remove(apm::FPkgkey& pkgkey, apm::FPkgrec& row) {
    if (bool_Update(row.pkgkey_c_pkgrec_in_ary,false)) {
        int lim = pkgkey.c_pkgrec_n;
        apm::FPkgrec* *elems = pkgkey.c_pkgrec_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            apm::FPkgrec* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(apm::FPkgrec*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                pkgkey.c_pkgrec_n = lim - 1;
                break;
            }
        }
    }
}

// --- apm.FPkgkey.c_pkgrec.Reserve
// Reserve space in index for N more elements;
void apm::c_pkgrec_Reserve(apm::FPkgkey& pkgkey, u32 n) {
    u32 old_max = pkgkey.c_pkgrec_max;
    if (UNLIKELY(pkgkey.c_pkgrec_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FPkgrec*);
        u32 new_size = new_max * sizeof(apm::FPkgrec*);
        void *new_mem = algo_lib::malloc_ReallocMem(pkgkey.c_pkgrec_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FPkgkey.c_pkgrec");
        }
        pkgkey.c_pkgrec_elems = (apm::FPkgrec**)new_mem;
        pkgkey.c_pkgrec_max = new_max;
    }
}

// --- apm.FPkgkey..Uninit
void apm::FPkgkey_Uninit(apm::FPkgkey& pkgkey) {
    apm::FPkgkey &row = pkgkey; (void)row;
    apm::FPackage* p_package = apm::ind_package_Find(package_Get(row));
    if (p_package)  {
        zd_pkgkey_Remove(*p_package, row);// remove pkgkey from index zd_pkgkey
    }
    ind_pkgkey_Remove(row); // remove pkgkey from index ind_pkgkey

    // apm.FPkgkey.c_pkgrec.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(pkgkey.c_pkgrec_elems, sizeof(apm::FPkgrec*)*pkgkey.c_pkgrec_max); // (apm.FPkgkey.c_pkgrec)
}

// --- apm.FPkgrec..Uninit
void apm::FPkgrec_Uninit(apm::FPkgrec& pkgrec) {
    apm::FPkgrec &row = pkgrec; (void)row;
    apm::FPackage* p_p_package = row.p_package;
    if (p_p_package)  {
        zd_pkgrec_Remove(*p_p_package, row);// remove pkgrec from index zd_pkgrec
    }
    apm::FRec* p_p_rec = row.p_rec;
    if (p_p_rec)  {
        zd_rec_pkgrec_Remove(*p_p_rec, row);// remove pkgrec from index zd_rec_pkgrec
    }
    apm::FPkgkey* p_p_pkgkey = row.p_pkgkey;
    if (p_p_pkgkey)  {
        c_pkgrec_Remove(*p_p_pkgkey, row);// remove pkgrec from index c_pkgrec
    }
}

// --- apm.FRec.c_child.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void apm::c_child_Insert(apm::FRec& rec, apm::FRec& row) {
    // reserve space
    c_child_Reserve(rec, 1);
    u32 n  = rec.c_child_n;
    u32 at = n;
    apm::FRec* *elems = rec.c_child_elems;
    elems[at] = &row;
    rec.c_child_n = n+1;

}

// --- apm.FRec.c_child.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool apm::c_child_ScanInsertMaybe(apm::FRec& rec, apm::FRec& row) {
    bool retval = true;
    u32 n  = rec.c_child_n;
    for (u32 i = 0; i < n; i++) {
        if (rec.c_child_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_child_Reserve(rec, 1);
        rec.c_child_elems[n] = &row;
        rec.c_child_n = n+1;
    }
    return retval;
}

// --- apm.FRec.c_child.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void apm::c_child_Remove(apm::FRec& rec, apm::FRec& row) {
    int lim = rec.c_child_n;
    apm::FRec* *elems = rec.c_child_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        apm::FRec* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(apm::FRec*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            rec.c_child_n = lim - 1;
            break;
        }
    }
}

// --- apm.FRec.c_child.Reserve
// Reserve space in index for N more elements;
void apm::c_child_Reserve(apm::FRec& rec, u32 n) {
    u32 old_max = rec.c_child_max;
    if (UNLIKELY(rec.c_child_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(apm::FRec*);
        u32 new_size = new_max * sizeof(apm::FRec*);
        void *new_mem = algo_lib::malloc_ReallocMem(rec.c_child_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("apm.out_of_memory  field:apm.FRec.c_child");
        }
        rec.c_child_elems = (apm::FRec**)new_mem;
        rec.c_child_max = new_max;
    }
}

// --- apm.FRec.zd_rec_pkgrec.Cascdel
// Delete all elements in the linked list.
void apm::zd_rec_pkgrec_Cascdel(apm::FRec& rec) {
    while (apm::FPkgrec *zd_rec_pkgrec_first = zd_rec_pkgrec_First(rec)) {
        pkgrec_Delete(*zd_rec_pkgrec_first);
    }
}

// --- apm.FRec.zd_rec_pkgrec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_rec_pkgrec_Insert(apm::FRec& rec, apm::FPkgrec& row) {
    if (!zd_rec_pkgrec_InLlistQ(row)) {
        apm::FPkgrec* old_tail = rec.zd_rec_pkgrec_tail;
        row.zd_rec_pkgrec_next = NULL;
        row.zd_rec_pkgrec_prev = old_tail;
        rec.zd_rec_pkgrec_tail = &row;
        apm::FPkgrec **new_row_a = &old_tail->zd_rec_pkgrec_next;
        apm::FPkgrec **new_row_b = &rec.zd_rec_pkgrec_head;
        apm::FPkgrec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        rec.zd_rec_pkgrec_n++;
    }
}

// --- apm.FRec.zd_rec_pkgrec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_rec_pkgrec_Remove(apm::FRec& rec, apm::FPkgrec& row) {
    if (zd_rec_pkgrec_InLlistQ(row)) {
        apm::FPkgrec* old_head       = rec.zd_rec_pkgrec_head;
        (void)old_head; // in case it's not used
        apm::FPkgrec* prev = row.zd_rec_pkgrec_prev;
        apm::FPkgrec* next = row.zd_rec_pkgrec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FPkgrec **new_next_a = &prev->zd_rec_pkgrec_next;
        apm::FPkgrec **new_next_b = &rec.zd_rec_pkgrec_head;
        apm::FPkgrec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FPkgrec **new_prev_a = &next->zd_rec_pkgrec_prev;
        apm::FPkgrec **new_prev_b = &rec.zd_rec_pkgrec_tail;
        apm::FPkgrec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        rec.zd_rec_pkgrec_n--;
        row.zd_rec_pkgrec_next=(apm::FPkgrec*)-1; // not-in-list
    }
}

// --- apm.FRec.zd_rec_pkgrec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_rec_pkgrec_RemoveAll(apm::FRec& rec) {
    apm::FPkgrec* row = rec.zd_rec_pkgrec_head;
    rec.zd_rec_pkgrec_head = NULL;
    rec.zd_rec_pkgrec_tail = NULL;
    rec.zd_rec_pkgrec_n = 0;
    while (row) {
        apm::FPkgrec* row_next = row->zd_rec_pkgrec_next;
        row->zd_rec_pkgrec_next  = (apm::FPkgrec*)-1;
        row->zd_rec_pkgrec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FRec.zd_rec_pkgrec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FPkgrec* apm::zd_rec_pkgrec_RemoveFirst(apm::FRec& rec) {
    apm::FPkgrec *row = NULL;
    row = rec.zd_rec_pkgrec_head;
    if (row) {
        apm::FPkgrec *next = row->zd_rec_pkgrec_next;
        rec.zd_rec_pkgrec_head = next;
        apm::FPkgrec **new_end_a = &next->zd_rec_pkgrec_prev;
        apm::FPkgrec **new_end_b = &rec.zd_rec_pkgrec_tail;
        apm::FPkgrec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        rec.zd_rec_pkgrec_n--;
        row->zd_rec_pkgrec_next = (apm::FPkgrec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FRec..Uninit
void apm::FRec_Uninit(apm::FRec& rec) {
    apm::FRec &row = rec; (void)row;
    zd_rec_pkgrec_Cascdel(rec); // dmmeta.cascdel:apm.FRec.zd_rec_pkgrec
    ind_rec_Remove(row); // remove rec from index ind_rec
    zd_rec_Remove(row); // remove rec from index zd_rec
    apm::FSsimfile* p_p_ssimfile = row.p_ssimfile;
    if (p_p_ssimfile)  {
        zd_ssimfile_rec_Remove(*p_p_ssimfile, row);// remove rec from index zd_ssimfile_rec
    }
    zd_selrec_Remove(row); // remove rec from index zd_selrec
    zd_chooserec_Remove(row); // remove rec from index zd_chooserec

    // apm.FRec.c_child.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(rec.c_child_elems, sizeof(apm::FRec*)*rec.c_child_max); // (apm.FRec.c_child)
}

// --- apm.FSsimfile.base.CopyOut
// Copy fields out of row
void apm::ssimfile_CopyOut(apm::FSsimfile &row, dmmeta::Ssimfile &out) {
    out.ssimfile = row.ssimfile;
    out.ctype = row.ctype;
}

// --- apm.FSsimfile.base.CopyIn
// Copy fields in to row
void apm::ssimfile_CopyIn(apm::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- apm.FSsimfile.ssimns.Get
algo::Smallstr16 apm::ssimns_Get(apm::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- apm.FSsimfile.ns.Get
algo::Smallstr16 apm::ns_Get(apm::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- apm.FSsimfile.name.Get
algo::Smallstr50 apm::name_Get(apm::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- apm.FSsimfile.zd_ssimfile_rec.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void apm::zd_ssimfile_rec_Insert(apm::FSsimfile& ssimfile, apm::FRec& row) {
    if (!zd_ssimfile_rec_InLlistQ(row)) {
        apm::FRec* old_tail = ssimfile.zd_ssimfile_rec_tail;
        row.zd_ssimfile_rec_next = NULL;
        row.zd_ssimfile_rec_prev = old_tail;
        ssimfile.zd_ssimfile_rec_tail = &row;
        apm::FRec **new_row_a = &old_tail->zd_ssimfile_rec_next;
        apm::FRec **new_row_b = &ssimfile.zd_ssimfile_rec_head;
        apm::FRec **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ssimfile.zd_ssimfile_rec_n++;
    }
}

// --- apm.FSsimfile.zd_ssimfile_rec.Remove
// Remove element from index. If element is not in index, do nothing.
void apm::zd_ssimfile_rec_Remove(apm::FSsimfile& ssimfile, apm::FRec& row) {
    if (zd_ssimfile_rec_InLlistQ(row)) {
        apm::FRec* old_head       = ssimfile.zd_ssimfile_rec_head;
        (void)old_head; // in case it's not used
        apm::FRec* prev = row.zd_ssimfile_rec_prev;
        apm::FRec* next = row.zd_ssimfile_rec_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        apm::FRec **new_next_a = &prev->zd_ssimfile_rec_next;
        apm::FRec **new_next_b = &ssimfile.zd_ssimfile_rec_head;
        apm::FRec **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        apm::FRec **new_prev_a = &next->zd_ssimfile_rec_prev;
        apm::FRec **new_prev_b = &ssimfile.zd_ssimfile_rec_tail;
        apm::FRec **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        ssimfile.zd_ssimfile_rec_n--;
        row.zd_ssimfile_rec_next=(apm::FRec*)-1; // not-in-list
    }
}

// --- apm.FSsimfile.zd_ssimfile_rec.RemoveAll
// Empty the index. (The rows are not deleted)
void apm::zd_ssimfile_rec_RemoveAll(apm::FSsimfile& ssimfile) {
    apm::FRec* row = ssimfile.zd_ssimfile_rec_head;
    ssimfile.zd_ssimfile_rec_head = NULL;
    ssimfile.zd_ssimfile_rec_tail = NULL;
    ssimfile.zd_ssimfile_rec_n = 0;
    while (row) {
        apm::FRec* row_next = row->zd_ssimfile_rec_next;
        row->zd_ssimfile_rec_next  = (apm::FRec*)-1;
        row->zd_ssimfile_rec_prev  = NULL;
        row = row_next;
    }
}

// --- apm.FSsimfile.zd_ssimfile_rec.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
apm::FRec* apm::zd_ssimfile_rec_RemoveFirst(apm::FSsimfile& ssimfile) {
    apm::FRec *row = NULL;
    row = ssimfile.zd_ssimfile_rec_head;
    if (row) {
        apm::FRec *next = row->zd_ssimfile_rec_next;
        ssimfile.zd_ssimfile_rec_head = next;
        apm::FRec **new_end_a = &next->zd_ssimfile_rec_prev;
        apm::FRec **new_end_b = &ssimfile.zd_ssimfile_rec_tail;
        apm::FRec **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        ssimfile.zd_ssimfile_rec_n--;
        row->zd_ssimfile_rec_next = (apm::FRec*)-1; // mark as not-in-list
    }
    return row;
}

// --- apm.FSsimfile..Uninit
void apm::FSsimfile_Uninit(apm::FSsimfile& ssimfile) {
    apm::FSsimfile &row = ssimfile; (void)row;
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
    apm::FCtype* p_ctype = apm::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ssimfile_Remove(*p_ctype, row);// remove ssimfile from index c_ssimfile
    }
}

// --- apm.FSsimreq.base.CopyOut
// Copy fields out of row
void apm::ssimreq_CopyOut(apm::FSsimreq &row, dmmeta::Ssimreq &out) {
    out.ssimreq = row.ssimreq;
    out.parent = row.parent;
    out.reqchild = row.reqchild;
    out.bidir = row.bidir;
    out.comment = row.comment;
}

// --- apm.FSsimreq.base.CopyIn
// Copy fields in to row
void apm::ssimreq_CopyIn(apm::FSsimreq &row, dmmeta::Ssimreq &in) {
    row.ssimreq = in.ssimreq;
    row.parent = in.parent;
    row.reqchild = in.reqchild;
    row.bidir = in.bidir;
    row.comment = in.comment;
}

// --- apm.FSsimreq.parent_field.Get
algo::Smallstr100 apm::parent_field_Get(apm::FSsimreq& ssimreq) {
    algo::Smallstr100 ret(algo::Pathcomp(ssimreq.parent, ":LL"));
    return ret;
}

// --- apm.FSsimreq.parent_ctype.Get
algo::Smallstr100 apm::parent_ctype_Get(apm::FSsimreq& ssimreq) {
    algo::Smallstr100 ret(algo::Pathcomp(ssimreq.parent, ":LL.RL"));
    return ret;
}

// --- apm.FSsimreq.value.Get
algo::Smallstr100 apm::value_Get(apm::FSsimreq& ssimreq) {
    algo::Smallstr100 ret(algo::Pathcomp(ssimreq.parent, ":LR"));
    return ret;
}

// --- apm.FSsimreq.child_ssimfile.Get
algo::Smallstr50 apm::child_ssimfile_Get(apm::FSsimreq& ssimreq) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimreq.ssimreq, ":LL"));
    return ret;
}

// --- apm.FSsimreq.child_key.Get
algo::Smallstr100 apm::child_key_Get(apm::FSsimreq& ssimreq) {
    algo::Smallstr100 ret(algo::Pathcomp(ssimreq.ssimreq, ":RR"));
    return ret;
}

// --- apm.FSsimreq..Init
// Set all fields to initial values.
void apm::FSsimreq_Init(apm::FSsimreq& ssimreq) {
    ssimreq.reqchild = bool(false);
    ssimreq.bidir = bool(false);
    ssimreq.p_child_ssimfile = NULL;
    ssimreq.p_ctype = NULL;
    ssimreq.p_field = NULL;
    ssimreq.exclude = bool(false);
    ssimreq.ctype_c_ssimreq_in_ary = bool(false);
}

// --- apm.FSsimreq..Uninit
void apm::FSsimreq_Uninit(apm::FSsimreq& ssimreq) {
    apm::FSsimreq &row = ssimreq; (void)row;
    apm::FCtype* p_parent_ctype = apm::ind_ctype_Find(parent_ctype_Get(row));
    if (p_parent_ctype)  {
        c_ssimreq_Remove(*p_parent_ctype, row);// remove ssimreq from index c_ssimreq
    }
}

// --- apm.FSubstr.base.CopyOut
// Copy fields out of row
void apm::substr_CopyOut(apm::FSubstr &row, dmmeta::Substr &out) {
    out.field = row.field;
    out.expr = row.expr;
    out.srcfield = row.srcfield;
}

// --- apm.FSubstr.base.CopyIn
// Copy fields in to row
void apm::substr_CopyIn(apm::FSubstr &row, dmmeta::Substr &in) {
    row.field = in.field;
    row.expr = in.expr;
    row.srcfield = in.srcfield;
}

// --- apm.FSubstr..Uninit
void apm::FSubstr_Uninit(apm::FSubstr& substr) {
    apm::FSubstr &row = substr; (void)row;
    apm::FField* p_field = apm::ind_field_Find(row.field);
    if (p_field)  {
        c_substr_Remove(*p_field, row);// remove substr from index c_substr
    }
}

// --- apm.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* apm::value_ToCstr(const apm::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case apm_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- apm.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void apm::value_Print(const apm::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- apm.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool apm::value_SetStrptrMaybe(apm::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,apm_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- apm.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void apm::value_SetStrptr(apm::FieldId& parent, algo::strptr rhs, apm_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- apm.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool apm::value_ReadStrptrMaybe(apm::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- apm.FieldId..ReadStrptrMaybe
// Read fields of apm::FieldId from an ascii string.
// The format of the string is the format of the apm::FieldId's only field
bool apm::FieldId_ReadStrptrMaybe(apm::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- apm.FieldId..Print
// print string representation of ROW to string STR
// cfmt:apm.FieldId.String  printfmt:Raw
void apm::FieldId_Print(apm::FieldId& row, algo::cstring& str) {
    apm::value_Print(row, str);
}

// --- apm.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* apm::value_ToCstr(const apm::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case apm_TableId_dmmeta_Ctype      : ret = "dmmeta.Ctype";  break;
        case apm_TableId_dmmeta_Field      : ret = "dmmeta.Field";  break;
        case apm_TableId_dmmeta_Ns         : ret = "dmmeta.Ns";  break;
        case apm_TableId_dev_Package       : ret = "dev.Package";  break;
        case apm_TableId_dev_Pkgdep        : ret = "dev.Pkgdep";  break;
        case apm_TableId_dev_Pkgkey        : ret = "dev.Pkgkey";  break;
        case apm_TableId_dmmeta_Ssimfile   : ret = "dmmeta.Ssimfile";  break;
        case apm_TableId_dmmeta_Ssimreq    : ret = "dmmeta.Ssimreq";  break;
        case apm_TableId_dmmeta_Substr     : ret = "dmmeta.Substr";  break;
    }
    return ret;
}

// --- apm.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void apm::value_Print(const apm::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- apm.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool apm::value_SetStrptrMaybe(apm::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,apm_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','P','k','g','d'): {
                    if (memcmp(rhs.elems+8,"ep",2)==0) { value_SetEnum(parent,apm_TableId_dev_Pkgdep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','P','k','g','k'): {
                    if (memcmp(rhs.elems+8,"ey",2)==0) { value_SetEnum(parent,apm_TableId_dev_Pkgkey); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','p','k','g','d'): {
                    if (memcmp(rhs.elems+8,"ep",2)==0) { value_SetEnum(parent,apm_TableId_dev_pkgdep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','p','k','g','k'): {
                    if (memcmp(rhs.elems+8,"ey",2)==0) { value_SetEnum(parent,apm_TableId_dev_pkgkey); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','P','a','c','k'): {
                    if (memcmp(rhs.elems+8,"age",3)==0) { value_SetEnum(parent,apm_TableId_dev_Package); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','p','a','c','k'): {
                    if (memcmp(rhs.elems+8,"age",3)==0) { value_SetEnum(parent,apm_TableId_dev_package); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Field); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,apm_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,apm_TableId_dmmeta_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Substr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,apm_TableId_dmmeta_substr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simreq",6)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Ssimreq); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simreq",6)==0) { value_SetEnum(parent,apm_TableId_dmmeta_ssimreq); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,apm_TableId_dmmeta_Ssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,apm_TableId_dmmeta_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- apm.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void apm::value_SetStrptr(apm::TableId& parent, algo::strptr rhs, apm_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- apm.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool apm::value_ReadStrptrMaybe(apm::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- apm.TableId..ReadStrptrMaybe
// Read fields of apm::TableId from an ascii string.
// The format of the string is the format of the apm::TableId's only field
bool apm::TableId_ReadStrptrMaybe(apm::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- apm.TableId..Print
// print string representation of ROW to string STR
// cfmt:apm.TableId.String  printfmt:Raw
void apm::TableId_Print(apm::TableId& row, algo::cstring& str) {
    apm::value_Print(row, str);
}

// --- apm...SizeCheck
inline static void apm::SizeCheck() {
}

// --- apm...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        lib_ctype::FDb_Init();
        lib_git::FDb_Init();
        apm::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        apm::ReadArgv(); // dmmeta.main:apm
        apm::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("apm.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        apm::FDb_Uninit();
        lib_git::FDb_Uninit();
        lib_ctype::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- apm...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
