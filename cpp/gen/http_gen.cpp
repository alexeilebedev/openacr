//
// cpp/gen/http_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/http_gen.h"
#include "include/gen/http_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace http { // gen:ns_gsymbol
    const algo::strptr httpdb_version_HTTP_0_9("HTTP/0.9");
    const algo::strptr httpdb_version_HTTP_1_0("HTTP/1.0");
    const algo::strptr httpdb_version_HTTP_1_1("HTTP/1.1");
    const algo::strptr httpdb_version_HTTP_2_0("HTTP/2.0");
    const algo::strptr httpdb_version_HTTP_3_0("HTTP/3.0");
} // gen:ns_gsymbol
namespace http { // gen:ns_print_proto
    // func:http...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- http.ExtensionHeader..ReadFieldMaybe
bool http::ExtensionHeader_ReadFieldMaybe(http::ExtensionHeader& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    http::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case http_FieldId_name: {
            retval = algo::cstring_ReadStrptrMaybe(parent.name, strval);
        } break;
        case http_FieldId_value: {
            retval = algo::cstring_ReadStrptrMaybe(parent.value, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- http.ExtensionHeader..ReadStrptrMaybe
// Read fields of http::ExtensionHeader from an ascii string.
// The format of the string is an ssim Tuple
bool http::ExtensionHeader_ReadStrptrMaybe(http::ExtensionHeader &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "http.ExtensionHeader");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ExtensionHeader_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- http.ExtensionHeader..Print
// print string representation of ROW to string STR
// cfmt:http.ExtensionHeader.String  printfmt:Tuple
void http::ExtensionHeader_Print(http::ExtensionHeader& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "http.ExtensionHeader";

    algo::cstring_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);

    algo::cstring_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);
}

// --- http.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* http::value_ToCstr(const http::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case http_FieldId_name             : ret = "name";  break;
        case http_FieldId_value            : ret = "value";  break;
        case http_FieldId_method           : ret = "method";  break;
        case http_FieldId_extension_method : ret = "extension_method";  break;
        case http_FieldId_uri              : ret = "uri";  break;
        case http_FieldId_version          : ret = "version";  break;
        case http_FieldId_cache_control    : ret = "cache_control";  break;
        case http_FieldId_connection       : ret = "connection";  break;
        case http_FieldId_date             : ret = "date";  break;
        case http_FieldId_pragma           : ret = "pragma";  break;
        case http_FieldId_trailer          : ret = "trailer";  break;
        case http_FieldId_transfer_encoding: ret = "transfer_encoding";  break;
        case http_FieldId_upgrade          : ret = "upgrade";  break;
        case http_FieldId_via              : ret = "via";  break;
        case http_FieldId_warning          : ret = "warning";  break;
        case http_FieldId_accept           : ret = "accept";  break;
        case http_FieldId_accept_charset   : ret = "accept_charset";  break;
        case http_FieldId_accept_encoding  : ret = "accept_encoding";  break;
        case http_FieldId_accept_language  : ret = "accept_language";  break;
        case http_FieldId_authorization    : ret = "authorization";  break;
        case http_FieldId_expect           : ret = "expect";  break;
        case http_FieldId_from             : ret = "from";  break;
        case http_FieldId_host             : ret = "host";  break;
        case http_FieldId_if_match         : ret = "if_match";  break;
        case http_FieldId_if_modified_since: ret = "if_modified_since";  break;
        case http_FieldId_if_none_match    : ret = "if_none_match";  break;
        case http_FieldId_if_range         : ret = "if_range";  break;
        case http_FieldId_if_unmodified_since: ret = "if_unmodified_since";  break;
        case http_FieldId_max_forwards     : ret = "max_forwards";  break;
        case http_FieldId_proxy_authorization: ret = "proxy_authorization";  break;
        case http_FieldId_range            : ret = "range";  break;
        case http_FieldId_referer          : ret = "referer";  break;
        case http_FieldId_te               : ret = "te";  break;
        case http_FieldId_user_agent       : ret = "user_agent";  break;
        case http_FieldId_allow            : ret = "allow";  break;
        case http_FieldId_content_encoding : ret = "content_encoding";  break;
        case http_FieldId_content_language : ret = "content_language";  break;
        case http_FieldId_content_length   : ret = "content_length";  break;
        case http_FieldId_content_location : ret = "content_location";  break;
        case http_FieldId_content_md5      : ret = "content_md5";  break;
        case http_FieldId_content_range    : ret = "content_range";  break;
        case http_FieldId_content_type     : ret = "content_type";  break;
        case http_FieldId_expires          : ret = "expires";  break;
        case http_FieldId_last_modified    : ret = "last_modified";  break;
        case http_FieldId_sec_websocket_key: ret = "sec_websocket_key";  break;
        case http_FieldId_sec_websocket_extensions: ret = "sec_websocket_extensions";  break;
        case http_FieldId_sec_websocket_protocol: ret = "sec_websocket_protocol";  break;
        case http_FieldId_sec_websocket_version: ret = "sec_websocket_version";  break;
        case http_FieldId_extension_header : ret = "extension_header";  break;
        case http_FieldId_body             : ret = "body";  break;
        case http_FieldId_status           : ret = "status";  break;
        case http_FieldId_accept_ranges    : ret = "accept_ranges";  break;
        case http_FieldId_age              : ret = "age";  break;
        case http_FieldId_etag             : ret = "etag";  break;
        case http_FieldId_location         : ret = "location";  break;
        case http_FieldId_proxy_authenticate: ret = "proxy_authenticate";  break;
        case http_FieldId_retry_after      : ret = "retry_after";  break;
        case http_FieldId_server           : ret = "server";  break;
        case http_FieldId_vary             : ret = "vary";  break;
        case http_FieldId_www_authenticate : ret = "www_authenticate";  break;
        case http_FieldId_sec_websocket_accept: ret = "sec_websocket_accept";  break;
    }
    return ret;
}

// --- http.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void http::value_Print(const http::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- http.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool http::value_SetStrptrMaybe(http::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('t','e'): {
                    value_SetEnum(parent,http_FieldId_te); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','g','e'): {
                    value_SetEnum(parent,http_FieldId_age); ret = true; break;
                }
                case LE_STR3('u','r','i'): {
                    value_SetEnum(parent,http_FieldId_uri); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,http_FieldId_via); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','o','d','y'): {
                    value_SetEnum(parent,http_FieldId_body); ret = true; break;
                }
                case LE_STR4('d','a','t','e'): {
                    value_SetEnum(parent,http_FieldId_date); ret = true; break;
                }
                case LE_STR4('e','t','a','g'): {
                    value_SetEnum(parent,http_FieldId_etag); ret = true; break;
                }
                case LE_STR4('f','r','o','m'): {
                    value_SetEnum(parent,http_FieldId_from); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,http_FieldId_host); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,http_FieldId_name); ret = true; break;
                }
                case LE_STR4('v','a','r','y'): {
                    value_SetEnum(parent,http_FieldId_vary); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','l','l','o','w'): {
                    value_SetEnum(parent,http_FieldId_allow); ret = true; break;
                }
                case LE_STR5('r','a','n','g','e'): {
                    value_SetEnum(parent,http_FieldId_range); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,http_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','c','c','e','p','t'): {
                    value_SetEnum(parent,http_FieldId_accept); ret = true; break;
                }
                case LE_STR6('e','x','p','e','c','t'): {
                    value_SetEnum(parent,http_FieldId_expect); ret = true; break;
                }
                case LE_STR6('m','e','t','h','o','d'): {
                    value_SetEnum(parent,http_FieldId_method); ret = true; break;
                }
                case LE_STR6('p','r','a','g','m','a'): {
                    value_SetEnum(parent,http_FieldId_pragma); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,http_FieldId_server); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,http_FieldId_status); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('e','x','p','i','r','e','s'): {
                    value_SetEnum(parent,http_FieldId_expires); ret = true; break;
                }
                case LE_STR7('r','e','f','e','r','e','r'): {
                    value_SetEnum(parent,http_FieldId_referer); ret = true; break;
                }
                case LE_STR7('t','r','a','i','l','e','r'): {
                    value_SetEnum(parent,http_FieldId_trailer); ret = true; break;
                }
                case LE_STR7('u','p','g','r','a','d','e'): {
                    value_SetEnum(parent,http_FieldId_upgrade); ret = true; break;
                }
                case LE_STR7('v','e','r','s','i','o','n'): {
                    value_SetEnum(parent,http_FieldId_version); ret = true; break;
                }
                case LE_STR7('w','a','r','n','i','n','g'): {
                    value_SetEnum(parent,http_FieldId_warning); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','_','m','a','t','c','h'): {
                    value_SetEnum(parent,http_FieldId_if_match); ret = true; break;
                }
                case LE_STR8('i','f','_','r','a','n','g','e'): {
                    value_SetEnum(parent,http_FieldId_if_range); ret = true; break;
                }
                case LE_STR8('l','o','c','a','t','i','o','n'): {
                    value_SetEnum(parent,http_FieldId_location); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','n','e','c','t','i'): {
                    if (memcmp(rhs.elems+8,"on",2)==0) { value_SetEnum(parent,http_FieldId_connection); ret = true; break; }
                    break;
                }
                case LE_STR8('u','s','e','r','_','a','g','e'): {
                    if (memcmp(rhs.elems+8,"nt",2)==0) { value_SetEnum(parent,http_FieldId_user_agent); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','_'): {
                    if (memcmp(rhs.elems+8,"md5",3)==0) { value_SetEnum(parent,http_FieldId_content_md5); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','t','r','y','_','a','f'): {
                    if (memcmp(rhs.elems+8,"ter",3)==0) { value_SetEnum(parent,http_FieldId_retry_after); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','_'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,http_FieldId_content_type); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','x','_','f','o','r','w'): {
                    if (memcmp(rhs.elems+8,"ards",4)==0) { value_SetEnum(parent,http_FieldId_max_forwards); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','_','r'): {
                    if (memcmp(rhs.elems+8,"anges",5)==0) { value_SetEnum(parent,http_FieldId_accept_ranges); ret = true; break; }
                    break;
                }
                case LE_STR8('a','u','t','h','o','r','i','z'): {
                    if (memcmp(rhs.elems+8,"ation",5)==0) { value_SetEnum(parent,http_FieldId_authorization); ret = true; break; }
                    break;
                }
                case LE_STR8('c','a','c','h','e','_','c','o'): {
                    if (memcmp(rhs.elems+8,"ntrol",5)==0) { value_SetEnum(parent,http_FieldId_cache_control); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','n','t','e','n','t','_'): {
                    if (memcmp(rhs.elems+8,"range",5)==0) { value_SetEnum(parent,http_FieldId_content_range); ret = true; break; }
                    break;
                }
                case LE_STR8('i','f','_','n','o','n','e','_'): {
                    if (memcmp(rhs.elems+8,"match",5)==0) { value_SetEnum(parent,http_FieldId_if_none_match); ret = true; break; }
                    break;
                }
                case LE_STR8('l','a','s','t','_','m','o','d'): {
                    if (memcmp(rhs.elems+8,"ified",5)==0) { value_SetEnum(parent,http_FieldId_last_modified); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','_','c'): {
                    if (memcmp(rhs.elems+8,"harset",6)==0) { value_SetEnum(parent,http_FieldId_accept_charset); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','n','t','e','n','t','_'): {
                    if (memcmp(rhs.elems+8,"length",6)==0) { value_SetEnum(parent,http_FieldId_content_length); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','_','e'): {
                    if (memcmp(rhs.elems+8,"ncoding",7)==0) { value_SetEnum(parent,http_FieldId_accept_encoding); ret = true; break; }
                    break;
                }
                case LE_STR8('a','c','c','e','p','t','_','l'): {
                    if (memcmp(rhs.elems+8,"anguage",7)==0) { value_SetEnum(parent,http_FieldId_accept_language); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','_'): {
                    if (memcmp(rhs.elems+8,"encoding",8)==0) { value_SetEnum(parent,http_FieldId_content_encoding); ret = true; break; }
                    if (memcmp(rhs.elems+8,"language",8)==0) { value_SetEnum(parent,http_FieldId_content_language); ret = true; break; }
                    if (memcmp(rhs.elems+8,"location",8)==0) { value_SetEnum(parent,http_FieldId_content_location); ret = true; break; }
                    break;
                }
                case LE_STR8('e','x','t','e','n','s','i','o'): {
                    if (memcmp(rhs.elems+8,"n_method",8)==0) { value_SetEnum(parent,http_FieldId_extension_method); ret = true; break; }
                    if (memcmp(rhs.elems+8,"n_header",8)==0) { value_SetEnum(parent,http_FieldId_extension_header); ret = true; break; }
                    break;
                }
                case LE_STR8('w','w','w','_','a','u','t','h'): {
                    if (memcmp(rhs.elems+8,"enticate",8)==0) { value_SetEnum(parent,http_FieldId_www_authenticate); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','_','m','o','d','i','f'): {
                    if (memcmp(rhs.elems+8,"ied_since",9)==0) { value_SetEnum(parent,http_FieldId_if_modified_since); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','c','_','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket_key",9)==0) { value_SetEnum(parent,http_FieldId_sec_websocket_key); ret = true; break; }
                    break;
                }
                case LE_STR8('t','r','a','n','s','f','e','r'): {
                    if (memcmp(rhs.elems+8,"_encoding",9)==0) { value_SetEnum(parent,http_FieldId_transfer_encoding); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','r','o','x','y','_','a','u'): {
                    if (memcmp(rhs.elems+8,"thenticate",10)==0) { value_SetEnum(parent,http_FieldId_proxy_authenticate); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','_','u','n','m','o','d'): {
                    if (memcmp(rhs.elems+8,"ified_since",11)==0) { value_SetEnum(parent,http_FieldId_if_unmodified_since); ret = true; break; }
                    break;
                }
                case LE_STR8('p','r','o','x','y','_','a','u'): {
                    if (memcmp(rhs.elems+8,"thorization",11)==0) { value_SetEnum(parent,http_FieldId_proxy_authorization); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 20: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','_','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket_accept",12)==0) { value_SetEnum(parent,http_FieldId_sec_websocket_accept); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 21: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','_','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket_version",13)==0) { value_SetEnum(parent,http_FieldId_sec_websocket_version); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 22: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','_','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket_protocol",14)==0) { value_SetEnum(parent,http_FieldId_sec_websocket_protocol); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 24: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','_','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket_extensions",16)==0) { value_SetEnum(parent,http_FieldId_sec_websocket_extensions); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- http.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void http::value_SetStrptr(http::FieldId& parent, algo::strptr rhs, http_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- http.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool http::value_ReadStrptrMaybe(http::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- http.FieldId..ReadStrptrMaybe
// Read fields of http::FieldId from an ascii string.
// The format of the string is the format of the http::FieldId's only field
bool http::FieldId_ReadStrptrMaybe(http::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- http.FieldId..Print
// print string representation of ROW to string STR
// cfmt:http.FieldId.String  printfmt:Raw
void http::FieldId_Print(http::FieldId& row, algo::cstring& str) {
    http::value_Print(row, str);
}

// --- http.HeaderType.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* http::value_ToCstr(const http::HeaderType& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case http_HeaderType_accept        : ret = "accept";  break;
        case http_HeaderType_accept_charset: ret = "accept-charset";  break;
        case http_HeaderType_accept_encoding: ret = "accept-encoding";  break;
        case http_HeaderType_accept_language: ret = "accept-language";  break;
        case http_HeaderType_accept_ranges : ret = "accept-ranges";  break;
        case http_HeaderType_age           : ret = "age";  break;
        case http_HeaderType_allow         : ret = "allow";  break;
        case http_HeaderType_authorization : ret = "authorization";  break;
        case http_HeaderType_cache_control : ret = "cache-control";  break;
        case http_HeaderType_connection    : ret = "connection";  break;
        case http_HeaderType_content_encoding: ret = "content-encoding";  break;
        case http_HeaderType_content_language: ret = "content-language";  break;
        case http_HeaderType_content_length: ret = "content-length";  break;
        case http_HeaderType_content_location: ret = "content-location";  break;
        case http_HeaderType_content_md5   : ret = "content-md5";  break;
        case http_HeaderType_content_range : ret = "content-range";  break;
        case http_HeaderType_content_type  : ret = "content-type";  break;
        case http_HeaderType_date          : ret = "date";  break;
        case http_HeaderType_etag          : ret = "etag";  break;
        case http_HeaderType_expect        : ret = "expect";  break;
        case http_HeaderType_expires       : ret = "expires";  break;
        case http_HeaderType_from          : ret = "from";  break;
        case http_HeaderType_host          : ret = "host";  break;
        case http_HeaderType_if_match      : ret = "if-match";  break;
        case http_HeaderType_if_modified_since: ret = "if-modified-since";  break;
        case http_HeaderType_if_none_match : ret = "if-none-match";  break;
        case http_HeaderType_if_range      : ret = "if-range";  break;
        case http_HeaderType_if_unmodified_since: ret = "if-unmodified-since";  break;
        case http_HeaderType_last_modified : ret = "last-modified";  break;
        case http_HeaderType_location      : ret = "location";  break;
        case http_HeaderType_max_forwards  : ret = "max-forwards";  break;
        case http_HeaderType_pragma        : ret = "pragma";  break;
        case http_HeaderType_proxy_authenticate: ret = "proxy-authenticate";  break;
        case http_HeaderType_proxy_authorization: ret = "proxy-authorization";  break;
        case http_HeaderType_range         : ret = "range";  break;
        case http_HeaderType_referer       : ret = "referer";  break;
        case http_HeaderType_retry_after   : ret = "retry-after";  break;
        case http_HeaderType_sec_websocket_accept: ret = "sec-websocket-accept";  break;
        case http_HeaderType_sec_websocket_extensions: ret = "sec-websocket-extensions";  break;
        case http_HeaderType_sec_websocket_key: ret = "sec-websocket-key";  break;
        case http_HeaderType_sec_websocket_protocol: ret = "sec-websocket-protocol";  break;
        case http_HeaderType_sec_websocket_version: ret = "sec-websocket-version";  break;
        case http_HeaderType_server        : ret = "server";  break;
        case http_HeaderType_te            : ret = "te";  break;
        case http_HeaderType_trailer       : ret = "trailer";  break;
        case http_HeaderType_transfer_encoding: ret = "transfer-encoding";  break;
        case http_HeaderType_upgrade       : ret = "upgrade";  break;
        case http_HeaderType_user_agent    : ret = "user-agent";  break;
        case http_HeaderType_vary          : ret = "vary";  break;
        case http_HeaderType_via           : ret = "via";  break;
        case http_HeaderType_warning       : ret = "warning";  break;
        case http_HeaderType_www_authenticate: ret = "www-authenticate";  break;
    }
    return ret;
}

// --- http.HeaderType.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void http::value_Print(const http::HeaderType& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- http.HeaderType.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool http::value_SetStrptrMaybe(http::HeaderType& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('t','e'): {
                    value_SetEnum(parent,http_HeaderType_te); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','g','e'): {
                    value_SetEnum(parent,http_HeaderType_age); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,http_HeaderType_via); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('d','a','t','e'): {
                    value_SetEnum(parent,http_HeaderType_date); ret = true; break;
                }
                case LE_STR4('e','t','a','g'): {
                    value_SetEnum(parent,http_HeaderType_etag); ret = true; break;
                }
                case LE_STR4('f','r','o','m'): {
                    value_SetEnum(parent,http_HeaderType_from); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,http_HeaderType_host); ret = true; break;
                }
                case LE_STR4('v','a','r','y'): {
                    value_SetEnum(parent,http_HeaderType_vary); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','l','l','o','w'): {
                    value_SetEnum(parent,http_HeaderType_allow); ret = true; break;
                }
                case LE_STR5('r','a','n','g','e'): {
                    value_SetEnum(parent,http_HeaderType_range); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','c','c','e','p','t'): {
                    value_SetEnum(parent,http_HeaderType_accept); ret = true; break;
                }
                case LE_STR6('e','x','p','e','c','t'): {
                    value_SetEnum(parent,http_HeaderType_expect); ret = true; break;
                }
                case LE_STR6('p','r','a','g','m','a'): {
                    value_SetEnum(parent,http_HeaderType_pragma); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,http_HeaderType_server); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('e','x','p','i','r','e','s'): {
                    value_SetEnum(parent,http_HeaderType_expires); ret = true; break;
                }
                case LE_STR7('r','e','f','e','r','e','r'): {
                    value_SetEnum(parent,http_HeaderType_referer); ret = true; break;
                }
                case LE_STR7('t','r','a','i','l','e','r'): {
                    value_SetEnum(parent,http_HeaderType_trailer); ret = true; break;
                }
                case LE_STR7('u','p','g','r','a','d','e'): {
                    value_SetEnum(parent,http_HeaderType_upgrade); ret = true; break;
                }
                case LE_STR7('w','a','r','n','i','n','g'): {
                    value_SetEnum(parent,http_HeaderType_warning); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','-','m','a','t','c','h'): {
                    value_SetEnum(parent,http_HeaderType_if_match); ret = true; break;
                }
                case LE_STR8('i','f','-','r','a','n','g','e'): {
                    value_SetEnum(parent,http_HeaderType_if_range); ret = true; break;
                }
                case LE_STR8('l','o','c','a','t','i','o','n'): {
                    value_SetEnum(parent,http_HeaderType_location); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','n','e','c','t','i'): {
                    if (memcmp(rhs.elems+8,"on",2)==0) { value_SetEnum(parent,http_HeaderType_connection); ret = true; break; }
                    break;
                }
                case LE_STR8('u','s','e','r','-','a','g','e'): {
                    if (memcmp(rhs.elems+8,"nt",2)==0) { value_SetEnum(parent,http_HeaderType_user_agent); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','-'): {
                    if (memcmp(rhs.elems+8,"md5",3)==0) { value_SetEnum(parent,http_HeaderType_content_md5); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','t','r','y','-','a','f'): {
                    if (memcmp(rhs.elems+8,"ter",3)==0) { value_SetEnum(parent,http_HeaderType_retry_after); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','-'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,http_HeaderType_content_type); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','x','-','f','o','r','w'): {
                    if (memcmp(rhs.elems+8,"ards",4)==0) { value_SetEnum(parent,http_HeaderType_max_forwards); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','-','r'): {
                    if (memcmp(rhs.elems+8,"anges",5)==0) { value_SetEnum(parent,http_HeaderType_accept_ranges); ret = true; break; }
                    break;
                }
                case LE_STR8('a','u','t','h','o','r','i','z'): {
                    if (memcmp(rhs.elems+8,"ation",5)==0) { value_SetEnum(parent,http_HeaderType_authorization); ret = true; break; }
                    break;
                }
                case LE_STR8('c','a','c','h','e','-','c','o'): {
                    if (memcmp(rhs.elems+8,"ntrol",5)==0) { value_SetEnum(parent,http_HeaderType_cache_control); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','n','t','e','n','t','-'): {
                    if (memcmp(rhs.elems+8,"range",5)==0) { value_SetEnum(parent,http_HeaderType_content_range); ret = true; break; }
                    break;
                }
                case LE_STR8('i','f','-','n','o','n','e','-'): {
                    if (memcmp(rhs.elems+8,"match",5)==0) { value_SetEnum(parent,http_HeaderType_if_none_match); ret = true; break; }
                    break;
                }
                case LE_STR8('l','a','s','t','-','m','o','d'): {
                    if (memcmp(rhs.elems+8,"ified",5)==0) { value_SetEnum(parent,http_HeaderType_last_modified); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','-','c'): {
                    if (memcmp(rhs.elems+8,"harset",6)==0) { value_SetEnum(parent,http_HeaderType_accept_charset); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','n','t','e','n','t','-'): {
                    if (memcmp(rhs.elems+8,"length",6)==0) { value_SetEnum(parent,http_HeaderType_content_length); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','-','e'): {
                    if (memcmp(rhs.elems+8,"ncoding",7)==0) { value_SetEnum(parent,http_HeaderType_accept_encoding); ret = true; break; }
                    break;
                }
                case LE_STR8('a','c','c','e','p','t','-','l'): {
                    if (memcmp(rhs.elems+8,"anguage",7)==0) { value_SetEnum(parent,http_HeaderType_accept_language); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','t','e','n','t','-'): {
                    if (memcmp(rhs.elems+8,"encoding",8)==0) { value_SetEnum(parent,http_HeaderType_content_encoding); ret = true; break; }
                    if (memcmp(rhs.elems+8,"language",8)==0) { value_SetEnum(parent,http_HeaderType_content_language); ret = true; break; }
                    if (memcmp(rhs.elems+8,"location",8)==0) { value_SetEnum(parent,http_HeaderType_content_location); ret = true; break; }
                    break;
                }
                case LE_STR8('w','w','w','-','a','u','t','h'): {
                    if (memcmp(rhs.elems+8,"enticate",8)==0) { value_SetEnum(parent,http_HeaderType_www_authenticate); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','-','m','o','d','i','f'): {
                    if (memcmp(rhs.elems+8,"ied-since",9)==0) { value_SetEnum(parent,http_HeaderType_if_modified_since); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','c','-','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket-key",9)==0) { value_SetEnum(parent,http_HeaderType_sec_websocket_key); ret = true; break; }
                    break;
                }
                case LE_STR8('t','r','a','n','s','f','e','r'): {
                    if (memcmp(rhs.elems+8,"-encoding",9)==0) { value_SetEnum(parent,http_HeaderType_transfer_encoding); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','r','o','x','y','-','a','u'): {
                    if (memcmp(rhs.elems+8,"thenticate",10)==0) { value_SetEnum(parent,http_HeaderType_proxy_authenticate); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('i','f','-','u','n','m','o','d'): {
                    if (memcmp(rhs.elems+8,"ified-since",11)==0) { value_SetEnum(parent,http_HeaderType_if_unmodified_since); ret = true; break; }
                    break;
                }
                case LE_STR8('p','r','o','x','y','-','a','u'): {
                    if (memcmp(rhs.elems+8,"thorization",11)==0) { value_SetEnum(parent,http_HeaderType_proxy_authorization); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 20: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','-','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket-accept",12)==0) { value_SetEnum(parent,http_HeaderType_sec_websocket_accept); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 21: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','-','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket-version",13)==0) { value_SetEnum(parent,http_HeaderType_sec_websocket_version); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 22: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','-','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket-protocol",14)==0) { value_SetEnum(parent,http_HeaderType_sec_websocket_protocol); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 24: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','-','w','e','b','s'): {
                    if (memcmp(rhs.elems+8,"ocket-extensions",16)==0) { value_SetEnum(parent,http_HeaderType_sec_websocket_extensions); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- http.HeaderType.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void http::value_SetStrptr(http::HeaderType& parent, algo::strptr rhs, http_HeaderTypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- http.HeaderType.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool http::value_ReadStrptrMaybe(http::HeaderType& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u16_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- http.HeaderType..ReadStrptrMaybe
// Read fields of http::HeaderType from an ascii string.
// The format of the string is the format of the http::HeaderType's only field
bool http::HeaderType_ReadStrptrMaybe(http::HeaderType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- http.HeaderType..Print
// print string representation of ROW to string STR
// cfmt:http.HeaderType.String  printfmt:Raw
void http::HeaderType_Print(http::HeaderType& row, algo::cstring& str) {
    http::value_Print(row, str);
}

// --- http.Method.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* http::value_ToCstr(const http::Method& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case http_Method_extension_method  : ret = "extension_method";  break;
        case http_Method_GET               : ret = "GET";  break;
        case http_Method_HEAD              : ret = "HEAD";  break;
        case http_Method_POST              : ret = "POST";  break;
        case http_Method_PUT               : ret = "PUT";  break;
        case http_Method_DELETE            : ret = "DELETE";  break;
        case http_Method_CONNECT           : ret = "CONNECT";  break;
        case http_Method_OPTIONS           : ret = "OPTIONS";  break;
        case http_Method_TRACE             : ret = "TRACE";  break;
    }
    return ret;
}

// --- http.Method.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void http::value_Print(const http::Method& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- http.Method.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool http::value_SetStrptrMaybe(http::Method& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('G','E','T'): {
                    value_SetEnum(parent,http_Method_GET); ret = true; break;
                }
                case LE_STR3('P','U','T'): {
                    value_SetEnum(parent,http_Method_PUT); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('H','E','A','D'): {
                    value_SetEnum(parent,http_Method_HEAD); ret = true; break;
                }
                case LE_STR4('P','O','S','T'): {
                    value_SetEnum(parent,http_Method_POST); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('T','R','A','C','E'): {
                    value_SetEnum(parent,http_Method_TRACE); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('D','E','L','E','T','E'): {
                    value_SetEnum(parent,http_Method_DELETE); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('C','O','N','N','E','C','T'): {
                    value_SetEnum(parent,http_Method_CONNECT); ret = true; break;
                }
                case LE_STR7('O','P','T','I','O','N','S'): {
                    value_SetEnum(parent,http_Method_OPTIONS); ret = true; break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('e','x','t','e','n','s','i','o'): {
                    if (memcmp(rhs.elems+8,"n_method",8)==0) { value_SetEnum(parent,http_Method_extension_method); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- http.Method.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void http::value_SetStrptr(http::Method& parent, algo::strptr rhs, http_MethodEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- http.Method.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool http::value_ReadStrptrMaybe(http::Method& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- http.Method..ReadStrptrMaybe
// Read fields of http::Method from an ascii string.
// The format of the string is the format of the http::Method's only field
bool http::Method_ReadStrptrMaybe(http::Method &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- http.Method..Print
// print string representation of ROW to string STR
// cfmt:http.Method.String  printfmt:Raw
void http::Method_Print(http::Method& row, algo::cstring& str) {
    http::value_Print(row, str);
}

// --- http.Request.extension_header.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<http::ExtensionHeader> http::extension_header_Addary(http::Request& parent, algo::aryptr<http::ExtensionHeader> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.extension_header_elems && rhs.elems < parent.extension_header_elems + parent.extension_header_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("http.tary_alias  field:http.Request.extension_header  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    extension_header_Reserve(parent, nnew); // reserve space
    int at = parent.extension_header_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.extension_header_elems + at + i) http::ExtensionHeader(rhs[i]);
        parent.extension_header_n++;
    }
    return algo::aryptr<http::ExtensionHeader>(parent.extension_header_elems + at, nnew);
}

// --- http.Request.extension_header.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
http::ExtensionHeader& http::extension_header_Alloc(http::Request& parent) {
    extension_header_Reserve(parent, 1);
    int n  = parent.extension_header_n;
    int at = n;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    new (elems + at) http::ExtensionHeader(); // construct new element, default initializer
    parent.extension_header_n = n+1;
    return elems[at];
}

// --- http.Request.extension_header.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
http::ExtensionHeader& http::extension_header_AllocAt(http::Request& parent, int at) {
    extension_header_Reserve(parent, 1);
    int n  = parent.extension_header_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("http.bad_alloc_at  field:http.Request.extension_header  comment:'index out of range'");
    }
    http::ExtensionHeader *elems = parent.extension_header_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(http::ExtensionHeader));
    new (elems + at) http::ExtensionHeader(); // construct element, default initializer
    parent.extension_header_n = n+1;
    return elems[at];
}

// --- http.Request.extension_header.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocN(http::Request& parent, int n_elems) {
    extension_header_Reserve(parent, n_elems);
    int old_n  = parent.extension_header_n;
    int new_n = old_n + n_elems;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) http::ExtensionHeader(); // construct new element, default initialize
    }
    parent.extension_header_n = new_n;
    return algo::aryptr<http::ExtensionHeader>(elems + old_n, n_elems);
}

// --- http.Request.extension_header.AllocNAt
// Reserve space. Insert N elements at the given position of the array, return pointer to inserted elements
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocNAt(http::Request& parent, int n_elems, int at) {
    extension_header_Reserve(parent, n_elems);
    int n  = parent.extension_header_n;
    if (UNLIKELY(u64(at) > u64(n))) {
        FatalErrorExit("http.bad_alloc_n_at  field:http.Request.extension_header  comment:'index out of range'");
    }
    http::ExtensionHeader *elems = parent.extension_header_elems;
    memmove(elems + at + n_elems, elems + at, (n - at) * sizeof(http::ExtensionHeader));
    for (int i = 0; i < n_elems; i++) {
        new (elems + at + i) http::ExtensionHeader(); // construct new element, default initialize
    }
    parent.extension_header_n = n+n_elems;
    return algo::aryptr<http::ExtensionHeader>(elems+at,n_elems);
}

// --- http.Request.extension_header.Remove
// Remove item by index. If index outside of range, do nothing.
void http::extension_header_Remove(http::Request& parent, u32 i) {
    u32 lim = parent.extension_header_n;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    if (i < lim) {
        elems[i].~ExtensionHeader(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(http::ExtensionHeader) * (lim - (i + 1)));
        parent.extension_header_n = lim - 1;
    }
}

// --- http.Request.extension_header.RemoveAll
void http::extension_header_RemoveAll(http::Request& parent) {
    u32 n = parent.extension_header_n;
    while (n > 0) {
        n -= 1;
        parent.extension_header_elems[n].~ExtensionHeader();
        parent.extension_header_n = n;
    }
}

// --- http.Request.extension_header.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void http::extension_header_RemoveLast(http::Request& parent) {
    u64 n = parent.extension_header_n;
    if (n > 0) {
        n -= 1;
        extension_header_qFind(parent, u64(n)).~ExtensionHeader();
        parent.extension_header_n = n;
    }
}

// --- http.Request.extension_header.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void http::extension_header_AbsReserve(http::Request& parent, int n) {
    u32 old_max  = parent.extension_header_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.extension_header_elems, old_max * sizeof(http::ExtensionHeader), new_max * sizeof(http::ExtensionHeader));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("http.tary_nomem  field:http.Request.extension_header  comment:'out of memory'");
        }
        parent.extension_header_elems = (http::ExtensionHeader*)new_mem;
        parent.extension_header_max = new_max;
    }
}

// --- http.Request.extension_header.Setary
// Copy contents of RHS to PARENT.
void http::extension_header_Setary(http::Request& parent, http::Request &rhs) {
    extension_header_RemoveAll(parent);
    int nnew = rhs.extension_header_n;
    extension_header_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.extension_header_elems + i) http::ExtensionHeader(extension_header_qFind(rhs, i));
        parent.extension_header_n = i + 1;
    }
}

// --- http.Request.extension_header.Setary2
// Copy specified array into extension_header, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void http::extension_header_Setary(http::Request& parent, const algo::aryptr<http::ExtensionHeader> &rhs) {
    extension_header_RemoveAll(parent);
    extension_header_Addary(parent, rhs);
}

// --- http.Request.extension_header.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocNVal(http::Request& parent, int n_elems, const http::ExtensionHeader& val) {
    extension_header_Reserve(parent, n_elems);
    int old_n  = parent.extension_header_n;
    int new_n = old_n + n_elems;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) http::ExtensionHeader(val);
    }
    parent.extension_header_n = new_n;
    return algo::aryptr<http::ExtensionHeader>(elems + old_n, n_elems);
}

// --- http.Request.extension_header.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool http::extension_header_ReadStrptrMaybe(http::Request& parent, algo::strptr in_str) {
    bool retval = true;
    http::ExtensionHeader &elem = extension_header_Alloc(parent);
    retval = http::ExtensionHeader_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        extension_header_RemoveLast(parent);
    }
    return retval;
}

// --- http.Request.extension_header.Insary
// Insert array at specific position
// Insert N elements at specified index. Index must be in range or a fatal error occurs.Reserve space, and move existing elements to end.If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
void http::extension_header_Insary(http::Request& parent, algo::aryptr<http::ExtensionHeader> rhs, int at) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.extension_header_elems && rhs.elems < parent.extension_header_elems + parent.extension_header_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("http.tary_alias  field:http.Request.extension_header  comment:'alias error: sub-array is being appended to the whole'");
    }
    if (UNLIKELY(u64(at) >= u64(parent.extension_header_elems+1))) {
        FatalErrorExit("http.bad_insary  field:http.Request.extension_header  comment:'index out of range'");
    }
    int nnew = rhs.n_elems;
    int nmove = parent.extension_header_n - at;
    extension_header_Reserve(parent, nnew); // reserve space
    for (int i = nmove-1; i >=0 ; --i) {
        new (parent.extension_header_elems + at + nnew + i) http::ExtensionHeader(parent.extension_header_elems[at + i]);
        parent.extension_header_elems[at + i].~ExtensionHeader(); // destroy element
    }
    for (int i = 0; i < nnew; ++i) {
        new (parent.extension_header_elems + at + i) http::ExtensionHeader(rhs[i]);
    }
    parent.extension_header_n += nnew;
}

// --- http.Request..ReadFieldMaybe
bool http::Request_ReadFieldMaybe(http::Request& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    http::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case http_FieldId_method: {
            retval = http::Method_ReadStrptrMaybe(parent.method, strval);
        } break;
        case http_FieldId_extension_method: {
            retval = algo::cstring_ReadStrptrMaybe(parent.extension_method, strval);
        } break;
        case http_FieldId_uri: {
            retval = algo::cstring_ReadStrptrMaybe(parent.uri, strval);
        } break;
        case http_FieldId_version: {
            retval = algo::cstring_ReadStrptrMaybe(parent.version, strval);
        } break;
        case http_FieldId_cache_control: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cache_control, strval);
        } break;
        case http_FieldId_connection: {
            retval = algo::cstring_ReadStrptrMaybe(parent.connection, strval);
        } break;
        case http_FieldId_date: {
            retval = algo::cstring_ReadStrptrMaybe(parent.date, strval);
        } break;
        case http_FieldId_pragma: {
            retval = algo::cstring_ReadStrptrMaybe(parent.pragma, strval);
        } break;
        case http_FieldId_trailer: {
            retval = algo::cstring_ReadStrptrMaybe(parent.trailer, strval);
        } break;
        case http_FieldId_transfer_encoding: {
            retval = algo::cstring_ReadStrptrMaybe(parent.transfer_encoding, strval);
        } break;
        case http_FieldId_upgrade: {
            retval = algo::cstring_ReadStrptrMaybe(parent.upgrade, strval);
        } break;
        case http_FieldId_via: {
            retval = algo::cstring_ReadStrptrMaybe(parent.via, strval);
        } break;
        case http_FieldId_warning: {
            retval = algo::cstring_ReadStrptrMaybe(parent.warning, strval);
        } break;
        case http_FieldId_accept: {
            retval = algo::cstring_ReadStrptrMaybe(parent.accept, strval);
        } break;
        case http_FieldId_accept_charset: {
            retval = algo::cstring_ReadStrptrMaybe(parent.accept_charset, strval);
        } break;
        case http_FieldId_accept_encoding: {
            retval = algo::cstring_ReadStrptrMaybe(parent.accept_encoding, strval);
        } break;
        case http_FieldId_accept_language: {
            retval = algo::cstring_ReadStrptrMaybe(parent.accept_language, strval);
        } break;
        case http_FieldId_authorization: {
            retval = algo::cstring_ReadStrptrMaybe(parent.authorization, strval);
        } break;
        case http_FieldId_expect: {
            retval = algo::cstring_ReadStrptrMaybe(parent.expect, strval);
        } break;
        case http_FieldId_from: {
            retval = algo::cstring_ReadStrptrMaybe(parent.from, strval);
        } break;
        case http_FieldId_host: {
            retval = algo::cstring_ReadStrptrMaybe(parent.host, strval);
        } break;
        case http_FieldId_if_match: {
            retval = algo::cstring_ReadStrptrMaybe(parent.if_match, strval);
        } break;
        case http_FieldId_if_modified_since: {
            retval = algo::cstring_ReadStrptrMaybe(parent.if_modified_since, strval);
        } break;
        case http_FieldId_if_none_match: {
            retval = algo::cstring_ReadStrptrMaybe(parent.if_none_match, strval);
        } break;
        case http_FieldId_if_range: {
            retval = algo::cstring_ReadStrptrMaybe(parent.if_range, strval);
        } break;
        case http_FieldId_if_unmodified_since: {
            retval = algo::cstring_ReadStrptrMaybe(parent.if_unmodified_since, strval);
        } break;
        case http_FieldId_max_forwards: {
            retval = algo::cstring_ReadStrptrMaybe(parent.max_forwards, strval);
        } break;
        case http_FieldId_proxy_authorization: {
            retval = algo::cstring_ReadStrptrMaybe(parent.proxy_authorization, strval);
        } break;
        case http_FieldId_range: {
            retval = algo::cstring_ReadStrptrMaybe(parent.range, strval);
        } break;
        case http_FieldId_referer: {
            retval = algo::cstring_ReadStrptrMaybe(parent.referer, strval);
        } break;
        case http_FieldId_te: {
            retval = algo::cstring_ReadStrptrMaybe(parent.te, strval);
        } break;
        case http_FieldId_user_agent: {
            retval = algo::cstring_ReadStrptrMaybe(parent.user_agent, strval);
        } break;
        case http_FieldId_allow: {
            retval = algo::cstring_ReadStrptrMaybe(parent.allow, strval);
        } break;
        case http_FieldId_content_encoding: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_encoding, strval);
        } break;
        case http_FieldId_content_language: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_language, strval);
        } break;
        case http_FieldId_content_length: {
            retval = i32_ReadStrptrMaybe(parent.content_length, strval);
        } break;
        case http_FieldId_content_location: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_location, strval);
        } break;
        case http_FieldId_content_md5: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_md5, strval);
        } break;
        case http_FieldId_content_range: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_range, strval);
        } break;
        case http_FieldId_content_type: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_type, strval);
        } break;
        case http_FieldId_expires: {
            retval = algo::cstring_ReadStrptrMaybe(parent.expires, strval);
        } break;
        case http_FieldId_last_modified: {
            retval = algo::cstring_ReadStrptrMaybe(parent.last_modified, strval);
        } break;
        case http_FieldId_sec_websocket_key: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_key, strval);
        } break;
        case http_FieldId_sec_websocket_extensions: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_extensions, strval);
        } break;
        case http_FieldId_sec_websocket_protocol: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_protocol, strval);
        } break;
        case http_FieldId_sec_websocket_version: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_version, strval);
        } break;
        case http_FieldId_extension_header: {
            retval = extension_header_ReadStrptrMaybe(parent, strval);
        } break;
        case http_FieldId_body: {
            retval = algo::cstring_ReadStrptrMaybe(parent.body, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- http.Request..ReadStrptrMaybe
// Read fields of http::Request from an ascii string.
// The format of the string is an ssim Tuple
bool http::Request_ReadStrptrMaybe(http::Request &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "http.Request");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Request_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- http.Request..Init
// Set all fields to initial values.
void http::Request_Init(http::Request& parent) {
    parent.content_length = i32(0);
    parent.extension_header_elems 	= 0; // (http.Request.extension_header)
    parent.extension_header_n     	= 0; // (http.Request.extension_header)
    parent.extension_header_max   	= 0; // (http.Request.extension_header)
}

// --- http.Request..Uninit
void http::Request_Uninit(http::Request& parent) {
    http::Request &row = parent; (void)row;

    // http.Request.extension_header.Uninit (Tary)  //
    // remove all elements from http.Request.extension_header
    extension_header_RemoveAll(parent);
    // free memory for Tary http.Request.extension_header
    algo_lib::malloc_FreeMem(parent.extension_header_elems, sizeof(http::ExtensionHeader)*parent.extension_header_max); // (http.Request.extension_header)
}

// --- http.Request..Print
// print string representation of ROW to string STR
// cfmt:http.Request.String  printfmt:Tuple
void http::Request_Print(http::Request& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "http.Request";

    http::Method_Print(row.method, temp);
    PrintAttrSpaceReset(str,"method", temp);

    algo::cstring_Print(row.extension_method, temp);
    PrintAttrSpaceReset(str,"extension_method", temp);

    algo::cstring_Print(row.uri, temp);
    PrintAttrSpaceReset(str,"uri", temp);

    algo::cstring_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    algo::cstring_Print(row.cache_control, temp);
    PrintAttrSpaceReset(str,"cache_control", temp);

    algo::cstring_Print(row.connection, temp);
    PrintAttrSpaceReset(str,"connection", temp);

    algo::cstring_Print(row.date, temp);
    PrintAttrSpaceReset(str,"date", temp);

    algo::cstring_Print(row.pragma, temp);
    PrintAttrSpaceReset(str,"pragma", temp);

    algo::cstring_Print(row.trailer, temp);
    PrintAttrSpaceReset(str,"trailer", temp);

    algo::cstring_Print(row.transfer_encoding, temp);
    PrintAttrSpaceReset(str,"transfer_encoding", temp);

    algo::cstring_Print(row.upgrade, temp);
    PrintAttrSpaceReset(str,"upgrade", temp);

    algo::cstring_Print(row.via, temp);
    PrintAttrSpaceReset(str,"via", temp);

    algo::cstring_Print(row.warning, temp);
    PrintAttrSpaceReset(str,"warning", temp);

    algo::cstring_Print(row.accept, temp);
    PrintAttrSpaceReset(str,"accept", temp);

    algo::cstring_Print(row.accept_charset, temp);
    PrintAttrSpaceReset(str,"accept_charset", temp);

    algo::cstring_Print(row.accept_encoding, temp);
    PrintAttrSpaceReset(str,"accept_encoding", temp);

    algo::cstring_Print(row.accept_language, temp);
    PrintAttrSpaceReset(str,"accept_language", temp);

    algo::cstring_Print(row.authorization, temp);
    PrintAttrSpaceReset(str,"authorization", temp);

    algo::cstring_Print(row.expect, temp);
    PrintAttrSpaceReset(str,"expect", temp);

    algo::cstring_Print(row.from, temp);
    PrintAttrSpaceReset(str,"from", temp);

    algo::cstring_Print(row.host, temp);
    PrintAttrSpaceReset(str,"host", temp);

    algo::cstring_Print(row.if_match, temp);
    PrintAttrSpaceReset(str,"if_match", temp);

    algo::cstring_Print(row.if_modified_since, temp);
    PrintAttrSpaceReset(str,"if_modified_since", temp);

    algo::cstring_Print(row.if_none_match, temp);
    PrintAttrSpaceReset(str,"if_none_match", temp);

    algo::cstring_Print(row.if_range, temp);
    PrintAttrSpaceReset(str,"if_range", temp);

    algo::cstring_Print(row.if_unmodified_since, temp);
    PrintAttrSpaceReset(str,"if_unmodified_since", temp);

    algo::cstring_Print(row.max_forwards, temp);
    PrintAttrSpaceReset(str,"max_forwards", temp);

    algo::cstring_Print(row.proxy_authorization, temp);
    PrintAttrSpaceReset(str,"proxy_authorization", temp);

    algo::cstring_Print(row.range, temp);
    PrintAttrSpaceReset(str,"range", temp);

    algo::cstring_Print(row.referer, temp);
    PrintAttrSpaceReset(str,"referer", temp);

    algo::cstring_Print(row.te, temp);
    PrintAttrSpaceReset(str,"te", temp);

    algo::cstring_Print(row.user_agent, temp);
    PrintAttrSpaceReset(str,"user_agent", temp);

    algo::cstring_Print(row.allow, temp);
    PrintAttrSpaceReset(str,"allow", temp);

    algo::cstring_Print(row.content_encoding, temp);
    PrintAttrSpaceReset(str,"content_encoding", temp);

    algo::cstring_Print(row.content_language, temp);
    PrintAttrSpaceReset(str,"content_language", temp);

    i32_Print(row.content_length, temp);
    PrintAttrSpaceReset(str,"content_length", temp);

    algo::cstring_Print(row.content_location, temp);
    PrintAttrSpaceReset(str,"content_location", temp);

    algo::cstring_Print(row.content_md5, temp);
    PrintAttrSpaceReset(str,"content_md5", temp);

    algo::cstring_Print(row.content_range, temp);
    PrintAttrSpaceReset(str,"content_range", temp);

    algo::cstring_Print(row.content_type, temp);
    PrintAttrSpaceReset(str,"content_type", temp);

    algo::cstring_Print(row.expires, temp);
    PrintAttrSpaceReset(str,"expires", temp);

    algo::cstring_Print(row.last_modified, temp);
    PrintAttrSpaceReset(str,"last_modified", temp);

    algo::cstring_Print(row.sec_websocket_key, temp);
    PrintAttrSpaceReset(str,"sec_websocket_key", temp);

    algo::cstring_Print(row.sec_websocket_extensions, temp);
    PrintAttrSpaceReset(str,"sec_websocket_extensions", temp);

    algo::cstring_Print(row.sec_websocket_protocol, temp);
    PrintAttrSpaceReset(str,"sec_websocket_protocol", temp);

    algo::cstring_Print(row.sec_websocket_version, temp);
    PrintAttrSpaceReset(str,"sec_websocket_version", temp);

    ind_beg(Request_extension_header_curs,extension_header,row) {
        http::ExtensionHeader_Print(extension_header, temp);
        tempstr name;
        name << "extension_header.";
        name << ind_curs(extension_header).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);
}

// --- http.Request..AssignOp
http::Request& http::Request::operator =(const http::Request &rhs) {
    method = rhs.method;
    extension_method = rhs.extension_method;
    uri = rhs.uri;
    version = rhs.version;
    cache_control = rhs.cache_control;
    connection = rhs.connection;
    date = rhs.date;
    pragma = rhs.pragma;
    trailer = rhs.trailer;
    transfer_encoding = rhs.transfer_encoding;
    upgrade = rhs.upgrade;
    via = rhs.via;
    warning = rhs.warning;
    accept = rhs.accept;
    accept_charset = rhs.accept_charset;
    accept_encoding = rhs.accept_encoding;
    accept_language = rhs.accept_language;
    authorization = rhs.authorization;
    expect = rhs.expect;
    from = rhs.from;
    host = rhs.host;
    if_match = rhs.if_match;
    if_modified_since = rhs.if_modified_since;
    if_none_match = rhs.if_none_match;
    if_range = rhs.if_range;
    if_unmodified_since = rhs.if_unmodified_since;
    max_forwards = rhs.max_forwards;
    proxy_authorization = rhs.proxy_authorization;
    range = rhs.range;
    referer = rhs.referer;
    te = rhs.te;
    user_agent = rhs.user_agent;
    allow = rhs.allow;
    content_encoding = rhs.content_encoding;
    content_language = rhs.content_language;
    content_length = rhs.content_length;
    content_location = rhs.content_location;
    content_md5 = rhs.content_md5;
    content_range = rhs.content_range;
    content_type = rhs.content_type;
    expires = rhs.expires;
    last_modified = rhs.last_modified;
    sec_websocket_key = rhs.sec_websocket_key;
    sec_websocket_extensions = rhs.sec_websocket_extensions;
    sec_websocket_protocol = rhs.sec_websocket_protocol;
    sec_websocket_version = rhs.sec_websocket_version;
    extension_header_Setary(*this, extension_header_Getary(const_cast<http::Request&>(rhs)));
    body = rhs.body;
    return *this;
}

// --- http.Request..CopyCtor
 http::Request::Request(const http::Request &rhs)
    : method(rhs.method)
    , extension_method(rhs.extension_method)
    , uri(rhs.uri)
    , version(rhs.version)
    , cache_control(rhs.cache_control)
    , connection(rhs.connection)
    , date(rhs.date)
    , pragma(rhs.pragma)
    , trailer(rhs.trailer)
    , transfer_encoding(rhs.transfer_encoding)
    , upgrade(rhs.upgrade)
    , via(rhs.via)
    , warning(rhs.warning)
    , accept(rhs.accept)
    , accept_charset(rhs.accept_charset)
    , accept_encoding(rhs.accept_encoding)
    , accept_language(rhs.accept_language)
    , authorization(rhs.authorization)
    , expect(rhs.expect)
    , from(rhs.from)
    , host(rhs.host)
    , if_match(rhs.if_match)
    , if_modified_since(rhs.if_modified_since)
    , if_none_match(rhs.if_none_match)
    , if_range(rhs.if_range)
    , if_unmodified_since(rhs.if_unmodified_since)
    , max_forwards(rhs.max_forwards)
    , proxy_authorization(rhs.proxy_authorization)
    , range(rhs.range)
    , referer(rhs.referer)
    , te(rhs.te)
    , user_agent(rhs.user_agent)
    , allow(rhs.allow)
    , content_encoding(rhs.content_encoding)
    , content_language(rhs.content_language)
    , content_length(rhs.content_length)
    , content_location(rhs.content_location)
    , content_md5(rhs.content_md5)
    , content_range(rhs.content_range)
    , content_type(rhs.content_type)
    , expires(rhs.expires)
    , last_modified(rhs.last_modified)
    , sec_websocket_key(rhs.sec_websocket_key)
    , sec_websocket_extensions(rhs.sec_websocket_extensions)
    , sec_websocket_protocol(rhs.sec_websocket_protocol)
    , sec_websocket_version(rhs.sec_websocket_version)
    , body(rhs.body)
 {
    extension_header_elems 	= 0; // (http.Request.extension_header)
    extension_header_n     	= 0; // (http.Request.extension_header)
    extension_header_max   	= 0; // (http.Request.extension_header)
    extension_header_Setary(*this, extension_header_Getary(const_cast<http::Request&>(rhs)));
}

// --- http.Response.extension_header.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<http::ExtensionHeader> http::extension_header_Addary(http::Response& parent, algo::aryptr<http::ExtensionHeader> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.extension_header_elems && rhs.elems < parent.extension_header_elems + parent.extension_header_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("http.tary_alias  field:http.Response.extension_header  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    extension_header_Reserve(parent, nnew); // reserve space
    int at = parent.extension_header_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.extension_header_elems + at + i) http::ExtensionHeader(rhs[i]);
        parent.extension_header_n++;
    }
    return algo::aryptr<http::ExtensionHeader>(parent.extension_header_elems + at, nnew);
}

// --- http.Response.extension_header.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
http::ExtensionHeader& http::extension_header_Alloc(http::Response& parent) {
    extension_header_Reserve(parent, 1);
    int n  = parent.extension_header_n;
    int at = n;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    new (elems + at) http::ExtensionHeader(); // construct new element, default initializer
    parent.extension_header_n = n+1;
    return elems[at];
}

// --- http.Response.extension_header.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
http::ExtensionHeader& http::extension_header_AllocAt(http::Response& parent, int at) {
    extension_header_Reserve(parent, 1);
    int n  = parent.extension_header_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("http.bad_alloc_at  field:http.Response.extension_header  comment:'index out of range'");
    }
    http::ExtensionHeader *elems = parent.extension_header_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(http::ExtensionHeader));
    new (elems + at) http::ExtensionHeader(); // construct element, default initializer
    parent.extension_header_n = n+1;
    return elems[at];
}

// --- http.Response.extension_header.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocN(http::Response& parent, int n_elems) {
    extension_header_Reserve(parent, n_elems);
    int old_n  = parent.extension_header_n;
    int new_n = old_n + n_elems;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) http::ExtensionHeader(); // construct new element, default initialize
    }
    parent.extension_header_n = new_n;
    return algo::aryptr<http::ExtensionHeader>(elems + old_n, n_elems);
}

// --- http.Response.extension_header.AllocNAt
// Reserve space. Insert N elements at the given position of the array, return pointer to inserted elements
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocNAt(http::Response& parent, int n_elems, int at) {
    extension_header_Reserve(parent, n_elems);
    int n  = parent.extension_header_n;
    if (UNLIKELY(u64(at) > u64(n))) {
        FatalErrorExit("http.bad_alloc_n_at  field:http.Response.extension_header  comment:'index out of range'");
    }
    http::ExtensionHeader *elems = parent.extension_header_elems;
    memmove(elems + at + n_elems, elems + at, (n - at) * sizeof(http::ExtensionHeader));
    for (int i = 0; i < n_elems; i++) {
        new (elems + at + i) http::ExtensionHeader(); // construct new element, default initialize
    }
    parent.extension_header_n = n+n_elems;
    return algo::aryptr<http::ExtensionHeader>(elems+at,n_elems);
}

// --- http.Response.extension_header.Remove
// Remove item by index. If index outside of range, do nothing.
void http::extension_header_Remove(http::Response& parent, u32 i) {
    u32 lim = parent.extension_header_n;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    if (i < lim) {
        elems[i].~ExtensionHeader(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(http::ExtensionHeader) * (lim - (i + 1)));
        parent.extension_header_n = lim - 1;
    }
}

// --- http.Response.extension_header.RemoveAll
void http::extension_header_RemoveAll(http::Response& parent) {
    u32 n = parent.extension_header_n;
    while (n > 0) {
        n -= 1;
        parent.extension_header_elems[n].~ExtensionHeader();
        parent.extension_header_n = n;
    }
}

// --- http.Response.extension_header.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void http::extension_header_RemoveLast(http::Response& parent) {
    u64 n = parent.extension_header_n;
    if (n > 0) {
        n -= 1;
        extension_header_qFind(parent, u64(n)).~ExtensionHeader();
        parent.extension_header_n = n;
    }
}

// --- http.Response.extension_header.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void http::extension_header_AbsReserve(http::Response& parent, int n) {
    u32 old_max  = parent.extension_header_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.extension_header_elems, old_max * sizeof(http::ExtensionHeader), new_max * sizeof(http::ExtensionHeader));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("http.tary_nomem  field:http.Response.extension_header  comment:'out of memory'");
        }
        parent.extension_header_elems = (http::ExtensionHeader*)new_mem;
        parent.extension_header_max = new_max;
    }
}

// --- http.Response.extension_header.Setary
// Copy contents of RHS to PARENT.
void http::extension_header_Setary(http::Response& parent, http::Response &rhs) {
    extension_header_RemoveAll(parent);
    int nnew = rhs.extension_header_n;
    extension_header_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.extension_header_elems + i) http::ExtensionHeader(extension_header_qFind(rhs, i));
        parent.extension_header_n = i + 1;
    }
}

// --- http.Response.extension_header.Setary2
// Copy specified array into extension_header, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void http::extension_header_Setary(http::Response& parent, const algo::aryptr<http::ExtensionHeader> &rhs) {
    extension_header_RemoveAll(parent);
    extension_header_Addary(parent, rhs);
}

// --- http.Response.extension_header.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<http::ExtensionHeader> http::extension_header_AllocNVal(http::Response& parent, int n_elems, const http::ExtensionHeader& val) {
    extension_header_Reserve(parent, n_elems);
    int old_n  = parent.extension_header_n;
    int new_n = old_n + n_elems;
    http::ExtensionHeader *elems = parent.extension_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) http::ExtensionHeader(val);
    }
    parent.extension_header_n = new_n;
    return algo::aryptr<http::ExtensionHeader>(elems + old_n, n_elems);
}

// --- http.Response.extension_header.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool http::extension_header_ReadStrptrMaybe(http::Response& parent, algo::strptr in_str) {
    bool retval = true;
    http::ExtensionHeader &elem = extension_header_Alloc(parent);
    retval = http::ExtensionHeader_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        extension_header_RemoveLast(parent);
    }
    return retval;
}

// --- http.Response.extension_header.Insary
// Insert array at specific position
// Insert N elements at specified index. Index must be in range or a fatal error occurs.Reserve space, and move existing elements to end.If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
void http::extension_header_Insary(http::Response& parent, algo::aryptr<http::ExtensionHeader> rhs, int at) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.extension_header_elems && rhs.elems < parent.extension_header_elems + parent.extension_header_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("http.tary_alias  field:http.Response.extension_header  comment:'alias error: sub-array is being appended to the whole'");
    }
    if (UNLIKELY(u64(at) >= u64(parent.extension_header_elems+1))) {
        FatalErrorExit("http.bad_insary  field:http.Response.extension_header  comment:'index out of range'");
    }
    int nnew = rhs.n_elems;
    int nmove = parent.extension_header_n - at;
    extension_header_Reserve(parent, nnew); // reserve space
    for (int i = nmove-1; i >=0 ; --i) {
        new (parent.extension_header_elems + at + nnew + i) http::ExtensionHeader(parent.extension_header_elems[at + i]);
        parent.extension_header_elems[at + i].~ExtensionHeader(); // destroy element
    }
    for (int i = 0; i < nnew; ++i) {
        new (parent.extension_header_elems + at + i) http::ExtensionHeader(rhs[i]);
    }
    parent.extension_header_n += nnew;
}

// --- http.Response..ReadFieldMaybe
bool http::Response_ReadFieldMaybe(http::Response& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    http::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case http_FieldId_version: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.version, strval);
        } break;
        case http_FieldId_status: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.status, strval);
        } break;
        case http_FieldId_cache_control: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cache_control, strval);
        } break;
        case http_FieldId_connection: {
            retval = algo::cstring_ReadStrptrMaybe(parent.connection, strval);
        } break;
        case http_FieldId_date: {
            retval = algo::cstring_ReadStrptrMaybe(parent.date, strval);
        } break;
        case http_FieldId_pragma: {
            retval = algo::cstring_ReadStrptrMaybe(parent.pragma, strval);
        } break;
        case http_FieldId_trailer: {
            retval = algo::cstring_ReadStrptrMaybe(parent.trailer, strval);
        } break;
        case http_FieldId_transfer_encoding: {
            retval = algo::cstring_ReadStrptrMaybe(parent.transfer_encoding, strval);
        } break;
        case http_FieldId_upgrade: {
            retval = algo::cstring_ReadStrptrMaybe(parent.upgrade, strval);
        } break;
        case http_FieldId_via: {
            retval = algo::cstring_ReadStrptrMaybe(parent.via, strval);
        } break;
        case http_FieldId_warning: {
            retval = algo::cstring_ReadStrptrMaybe(parent.warning, strval);
        } break;
        case http_FieldId_accept_ranges: {
            retval = algo::cstring_ReadStrptrMaybe(parent.accept_ranges, strval);
        } break;
        case http_FieldId_age: {
            retval = algo::cstring_ReadStrptrMaybe(parent.age, strval);
        } break;
        case http_FieldId_etag: {
            retval = algo::cstring_ReadStrptrMaybe(parent.etag, strval);
        } break;
        case http_FieldId_location: {
            retval = algo::cstring_ReadStrptrMaybe(parent.location, strval);
        } break;
        case http_FieldId_proxy_authenticate: {
            retval = algo::cstring_ReadStrptrMaybe(parent.proxy_authenticate, strval);
        } break;
        case http_FieldId_retry_after: {
            retval = algo::cstring_ReadStrptrMaybe(parent.retry_after, strval);
        } break;
        case http_FieldId_server: {
            retval = algo::cstring_ReadStrptrMaybe(parent.server, strval);
        } break;
        case http_FieldId_vary: {
            retval = algo::cstring_ReadStrptrMaybe(parent.vary, strval);
        } break;
        case http_FieldId_www_authenticate: {
            retval = algo::cstring_ReadStrptrMaybe(parent.www_authenticate, strval);
        } break;
        case http_FieldId_allow: {
            retval = algo::cstring_ReadStrptrMaybe(parent.allow, strval);
        } break;
        case http_FieldId_content_encoding: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_encoding, strval);
        } break;
        case http_FieldId_content_language: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_language, strval);
        } break;
        case http_FieldId_content_length: {
            retval = i32_ReadStrptrMaybe(parent.content_length, strval);
        } break;
        case http_FieldId_content_location: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_location, strval);
        } break;
        case http_FieldId_content_md5: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_md5, strval);
        } break;
        case http_FieldId_content_range: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_range, strval);
        } break;
        case http_FieldId_content_type: {
            retval = algo::cstring_ReadStrptrMaybe(parent.content_type, strval);
        } break;
        case http_FieldId_expires: {
            retval = algo::cstring_ReadStrptrMaybe(parent.expires, strval);
        } break;
        case http_FieldId_last_modified: {
            retval = algo::cstring_ReadStrptrMaybe(parent.last_modified, strval);
        } break;
        case http_FieldId_sec_websocket_accept: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_accept, strval);
        } break;
        case http_FieldId_sec_websocket_extensions: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_extensions, strval);
        } break;
        case http_FieldId_sec_websocket_protocol: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_protocol, strval);
        } break;
        case http_FieldId_sec_websocket_version: {
            retval = algo::cstring_ReadStrptrMaybe(parent.sec_websocket_version, strval);
        } break;
        case http_FieldId_extension_header: {
            retval = extension_header_ReadStrptrMaybe(parent, strval);
        } break;
        case http_FieldId_body: {
            retval = algo::cstring_ReadStrptrMaybe(parent.body, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- http.Response..ReadStrptrMaybe
// Read fields of http::Response from an ascii string.
// The format of the string is an ssim Tuple
bool http::Response_ReadStrptrMaybe(http::Response &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "http.Response");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Response_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- http.Response..Init
// Set all fields to initial values.
void http::Response_Init(http::Response& parent) {
    parent.version = algo::strptr("HTTP/1.0");
    parent.status = algo::strptr("200 OK");
    parent.content_length = i32(0);
    parent.extension_header_elems 	= 0; // (http.Response.extension_header)
    parent.extension_header_n     	= 0; // (http.Response.extension_header)
    parent.extension_header_max   	= 0; // (http.Response.extension_header)
}

// --- http.Response..Uninit
void http::Response_Uninit(http::Response& parent) {
    http::Response &row = parent; (void)row;

    // http.Response.extension_header.Uninit (Tary)  //
    // remove all elements from http.Response.extension_header
    extension_header_RemoveAll(parent);
    // free memory for Tary http.Response.extension_header
    algo_lib::malloc_FreeMem(parent.extension_header_elems, sizeof(http::ExtensionHeader)*parent.extension_header_max); // (http.Response.extension_header)
}

// --- http.Response..Print
// print string representation of ROW to string STR
// cfmt:http.Response.String  printfmt:Tuple
void http::Response_Print(http::Response& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "http.Response";

    algo::Smallstr50_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    algo::Smallstr50_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    algo::cstring_Print(row.cache_control, temp);
    PrintAttrSpaceReset(str,"cache_control", temp);

    algo::cstring_Print(row.connection, temp);
    PrintAttrSpaceReset(str,"connection", temp);

    algo::cstring_Print(row.date, temp);
    PrintAttrSpaceReset(str,"date", temp);

    algo::cstring_Print(row.pragma, temp);
    PrintAttrSpaceReset(str,"pragma", temp);

    algo::cstring_Print(row.trailer, temp);
    PrintAttrSpaceReset(str,"trailer", temp);

    algo::cstring_Print(row.transfer_encoding, temp);
    PrintAttrSpaceReset(str,"transfer_encoding", temp);

    algo::cstring_Print(row.upgrade, temp);
    PrintAttrSpaceReset(str,"upgrade", temp);

    algo::cstring_Print(row.via, temp);
    PrintAttrSpaceReset(str,"via", temp);

    algo::cstring_Print(row.warning, temp);
    PrintAttrSpaceReset(str,"warning", temp);

    algo::cstring_Print(row.accept_ranges, temp);
    PrintAttrSpaceReset(str,"accept_ranges", temp);

    algo::cstring_Print(row.age, temp);
    PrintAttrSpaceReset(str,"age", temp);

    algo::cstring_Print(row.etag, temp);
    PrintAttrSpaceReset(str,"etag", temp);

    algo::cstring_Print(row.location, temp);
    PrintAttrSpaceReset(str,"location", temp);

    algo::cstring_Print(row.proxy_authenticate, temp);
    PrintAttrSpaceReset(str,"proxy_authenticate", temp);

    algo::cstring_Print(row.retry_after, temp);
    PrintAttrSpaceReset(str,"retry_after", temp);

    algo::cstring_Print(row.server, temp);
    PrintAttrSpaceReset(str,"server", temp);

    algo::cstring_Print(row.vary, temp);
    PrintAttrSpaceReset(str,"vary", temp);

    algo::cstring_Print(row.www_authenticate, temp);
    PrintAttrSpaceReset(str,"www_authenticate", temp);

    algo::cstring_Print(row.allow, temp);
    PrintAttrSpaceReset(str,"allow", temp);

    algo::cstring_Print(row.content_encoding, temp);
    PrintAttrSpaceReset(str,"content_encoding", temp);

    algo::cstring_Print(row.content_language, temp);
    PrintAttrSpaceReset(str,"content_language", temp);

    i32_Print(row.content_length, temp);
    PrintAttrSpaceReset(str,"content_length", temp);

    algo::cstring_Print(row.content_location, temp);
    PrintAttrSpaceReset(str,"content_location", temp);

    algo::cstring_Print(row.content_md5, temp);
    PrintAttrSpaceReset(str,"content_md5", temp);

    algo::cstring_Print(row.content_range, temp);
    PrintAttrSpaceReset(str,"content_range", temp);

    algo::cstring_Print(row.content_type, temp);
    PrintAttrSpaceReset(str,"content_type", temp);

    algo::cstring_Print(row.expires, temp);
    PrintAttrSpaceReset(str,"expires", temp);

    algo::cstring_Print(row.last_modified, temp);
    PrintAttrSpaceReset(str,"last_modified", temp);

    algo::cstring_Print(row.sec_websocket_accept, temp);
    PrintAttrSpaceReset(str,"sec_websocket_accept", temp);

    algo::cstring_Print(row.sec_websocket_extensions, temp);
    PrintAttrSpaceReset(str,"sec_websocket_extensions", temp);

    algo::cstring_Print(row.sec_websocket_protocol, temp);
    PrintAttrSpaceReset(str,"sec_websocket_protocol", temp);

    algo::cstring_Print(row.sec_websocket_version, temp);
    PrintAttrSpaceReset(str,"sec_websocket_version", temp);

    ind_beg(Response_extension_header_curs,extension_header,row) {
        http::ExtensionHeader_Print(extension_header, temp);
        tempstr name;
        name << "extension_header.";
        name << ind_curs(extension_header).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);
}

// --- http.Response..AssignOp
http::Response& http::Response::operator =(const http::Response &rhs) {
    version = rhs.version;
    status = rhs.status;
    cache_control = rhs.cache_control;
    connection = rhs.connection;
    date = rhs.date;
    pragma = rhs.pragma;
    trailer = rhs.trailer;
    transfer_encoding = rhs.transfer_encoding;
    upgrade = rhs.upgrade;
    via = rhs.via;
    warning = rhs.warning;
    accept_ranges = rhs.accept_ranges;
    age = rhs.age;
    etag = rhs.etag;
    location = rhs.location;
    proxy_authenticate = rhs.proxy_authenticate;
    retry_after = rhs.retry_after;
    server = rhs.server;
    vary = rhs.vary;
    www_authenticate = rhs.www_authenticate;
    allow = rhs.allow;
    content_encoding = rhs.content_encoding;
    content_language = rhs.content_language;
    content_length = rhs.content_length;
    content_location = rhs.content_location;
    content_md5 = rhs.content_md5;
    content_range = rhs.content_range;
    content_type = rhs.content_type;
    expires = rhs.expires;
    last_modified = rhs.last_modified;
    sec_websocket_accept = rhs.sec_websocket_accept;
    sec_websocket_extensions = rhs.sec_websocket_extensions;
    sec_websocket_protocol = rhs.sec_websocket_protocol;
    sec_websocket_version = rhs.sec_websocket_version;
    extension_header_Setary(*this, extension_header_Getary(const_cast<http::Response&>(rhs)));
    body = rhs.body;
    return *this;
}

// --- http.Response..CopyCtor
 http::Response::Response(const http::Response &rhs)
    : version(rhs.version)
    , status(rhs.status)
    , cache_control(rhs.cache_control)
    , connection(rhs.connection)
    , date(rhs.date)
    , pragma(rhs.pragma)
    , trailer(rhs.trailer)
    , transfer_encoding(rhs.transfer_encoding)
    , upgrade(rhs.upgrade)
    , via(rhs.via)
    , warning(rhs.warning)
    , accept_ranges(rhs.accept_ranges)
    , age(rhs.age)
    , etag(rhs.etag)
    , location(rhs.location)
    , proxy_authenticate(rhs.proxy_authenticate)
    , retry_after(rhs.retry_after)
    , server(rhs.server)
    , vary(rhs.vary)
    , www_authenticate(rhs.www_authenticate)
    , allow(rhs.allow)
    , content_encoding(rhs.content_encoding)
    , content_language(rhs.content_language)
    , content_length(rhs.content_length)
    , content_location(rhs.content_location)
    , content_md5(rhs.content_md5)
    , content_range(rhs.content_range)
    , content_type(rhs.content_type)
    , expires(rhs.expires)
    , last_modified(rhs.last_modified)
    , sec_websocket_accept(rhs.sec_websocket_accept)
    , sec_websocket_extensions(rhs.sec_websocket_extensions)
    , sec_websocket_protocol(rhs.sec_websocket_protocol)
    , sec_websocket_version(rhs.sec_websocket_version)
    , body(rhs.body)
 {
    extension_header_elems 	= 0; // (http.Response.extension_header)
    extension_header_n     	= 0; // (http.Response.extension_header)
    extension_header_max   	= 0; // (http.Response.extension_header)
    extension_header_Setary(*this, extension_header_Getary(const_cast<http::Response&>(rhs)));
}

// --- http...SizeCheck
inline static void http::SizeCheck() {
}

// --- http...StaticCheck
void http::StaticCheck() {
    algo_assert(_offset_of(http::FieldId, value) + sizeof(((http::FieldId*)0)->value) == sizeof(http::FieldId));
}
