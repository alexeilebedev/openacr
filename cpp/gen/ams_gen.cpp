//
// cpp/gen/ams_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/ams_gen.h"
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/ietf_gen.h"
#include "include/gen/ietf_gen.inl.h"
#include "include/gen/fm_gen.h"
#include "include/gen/fm_gen.inl.h"
#include "include/gen/ws_gen.h"
#include "include/gen/ws_gen.inl.h"
//#pragma endinclude
namespace ams { // gen:ns_print_proto
    // func:ams.ProcId.proctype.ReadStrptrMaybe
    inline static bool   proctype_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ProcId.nodeidx.ReadStrptrMaybe
    inline static bool   nodeidx_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ProcId.procidx.ReadStrptrMaybe
    inline static bool   procidx_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmFlags.write.ReadStrptrMaybe
    inline static bool   write_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmFlags.read.ReadStrptrMaybe
    inline static bool   read_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmFlags.nonblock.ReadStrptrMaybe
    inline static bool   nonblock_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmFlags.write_err.ReadStrptrMaybe
    inline static bool   write_err_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmemberFlags.r.ReadStrptrMaybe
    inline static bool   r_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams.ShmemberFlags.w.ReadStrptrMaybe
    inline static bool   w_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:ams...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- ams.ExpectMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ExpectMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ExpectMsg.text.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::text_Getary(ams::ExpectMsg& parent) {
    return algo::aryptr<char>(text_Addr(parent), text_N(parent));
}

// --- ams.ExpectMsg.text.Addr
char* ams::text_Addr(ams::ExpectMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::ExpectMsg)); // address of varlen portion
}

// --- ams.ExpectMsg.text.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::text_ReadStrptrMaybe(ams::ExpectMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.ExpectMsg.text.Print
// Convert text to a string.
// Array is printed as a regular string.
void ams::text_Print(ams::ExpectMsg& parent, algo::cstring &rhs) {
    rhs << text_Getary(parent);
}

// --- ams.ExpectMsg..ReadFieldMaybe
bool ams::ExpectMsg_ReadFieldMaybe(ams::ExpectMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_text: {
            retval = text_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ExpectMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ExpectMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ExpectMsg_ReadStrptrMaybe(ams::ExpectMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ExpectMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ExpectMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ExpectMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ExpectMsg.String  printfmt:Tuple
void ams::ExpectMsg_Print(ams::ExpectMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ExpectMsg";

    ams::text_Print(row, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- ams.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_FieldId_base              : ret = "base";  break;
        case ams_FieldId_type              : ret = "type";  break;
        case ams_FieldId_length            : ret = "length";  break;
        case ams_FieldId_text              : ret = "text";  break;
        case ams_FieldId_proc_id           : ret = "proc_id";  break;
        case ams_FieldId_payload           : ret = "payload";  break;
        case ams_FieldId_tstamp            : ret = "tstamp";  break;
        case ams_FieldId_logcat            : ret = "logcat";  break;
        case ams_FieldId_proc              : ret = "proc";  break;
        case ams_FieldId_value             : ret = "value";  break;
        case ams_FieldId_proctype          : ret = "proctype";  break;
        case ams_FieldId_nodeidx           : ret = "nodeidx";  break;
        case ams_FieldId_procidx           : ret = "procidx";  break;
        case ams_FieldId_signal            : ret = "signal";  break;
        case ams_FieldId_until             : ret = "until";  break;
        case ams_FieldId_pty               : ret = "pty";  break;
        case ams_FieldId_cmd               : ret = "cmd";  break;
        case ams_FieldId_status            : ret = "status";  break;
        case ams_FieldId_remove_topmost    : ret = "remove_topmost";  break;
        case ams_FieldId_pathname          : ret = "pathname";  break;
        case ams_FieldId_write             : ret = "write";  break;
        case ams_FieldId_read              : ret = "read";  break;
        case ams_FieldId_nonblock          : ret = "nonblock";  break;
        case ams_FieldId_write_err         : ret = "write_err";  break;
        case ams_FieldId_shmember          : ret = "shmember";  break;
        case ams_FieldId_off               : ret = "off";  break;
        case ams_FieldId_wbudget           : ret = "wbudget";  break;
        case ams_FieldId_shmtype           : ret = "shmtype";  break;
        case ams_FieldId_index             : ret = "index";  break;
        case ams_FieldId_r                 : ret = "r";  break;
        case ams_FieldId_w                 : ret = "w";  break;
        case ams_FieldId_shm_id            : ret = "shm_id";  break;
        case ams_FieldId_flags             : ret = "flags";  break;
    }
    return ret;
}

// --- ams.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'r': {
                    value_SetEnum(parent,ams_FieldId_r); ret = true; break;
                }
                case 'w': {
                    value_SetEnum(parent,ams_FieldId_w); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','m','d'): {
                    value_SetEnum(parent,ams_FieldId_cmd); ret = true; break;
                }
                case LE_STR3('o','f','f'): {
                    value_SetEnum(parent,ams_FieldId_off); ret = true; break;
                }
                case LE_STR3('p','t','y'): {
                    value_SetEnum(parent,ams_FieldId_pty); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,ams_FieldId_base); ret = true; break;
                }
                case LE_STR4('p','r','o','c'): {
                    value_SetEnum(parent,ams_FieldId_proc); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,ams_FieldId_read); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,ams_FieldId_text); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,ams_FieldId_type); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','l','a','g','s'): {
                    value_SetEnum(parent,ams_FieldId_flags); ret = true; break;
                }
                case LE_STR5('i','n','d','e','x'): {
                    value_SetEnum(parent,ams_FieldId_index); ret = true; break;
                }
                case LE_STR5('u','n','t','i','l'): {
                    value_SetEnum(parent,ams_FieldId_until); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,ams_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,ams_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,ams_FieldId_length); ret = true; break;
                }
                case LE_STR6('l','o','g','c','a','t'): {
                    value_SetEnum(parent,ams_FieldId_logcat); ret = true; break;
                }
                case LE_STR6('s','h','m','_','i','d'): {
                    value_SetEnum(parent,ams_FieldId_shm_id); ret = true; break;
                }
                case LE_STR6('s','i','g','n','a','l'): {
                    value_SetEnum(parent,ams_FieldId_signal); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,ams_FieldId_status); ret = true; break;
                }
                case LE_STR6('t','s','t','a','m','p'): {
                    value_SetEnum(parent,ams_FieldId_tstamp); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('n','o','d','e','i','d','x'): {
                    value_SetEnum(parent,ams_FieldId_nodeidx); ret = true; break;
                }
                case LE_STR7('p','a','y','l','o','a','d'): {
                    value_SetEnum(parent,ams_FieldId_payload); ret = true; break;
                }
                case LE_STR7('p','r','o','c','_','i','d'): {
                    value_SetEnum(parent,ams_FieldId_proc_id); ret = true; break;
                }
                case LE_STR7('p','r','o','c','i','d','x'): {
                    value_SetEnum(parent,ams_FieldId_procidx); ret = true; break;
                }
                case LE_STR7('s','h','m','t','y','p','e'): {
                    value_SetEnum(parent,ams_FieldId_shmtype); ret = true; break;
                }
                case LE_STR7('w','b','u','d','g','e','t'): {
                    value_SetEnum(parent,ams_FieldId_wbudget); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('n','o','n','b','l','o','c','k'): {
                    value_SetEnum(parent,ams_FieldId_nonblock); ret = true; break;
                }
                case LE_STR8('p','a','t','h','n','a','m','e'): {
                    value_SetEnum(parent,ams_FieldId_pathname); ret = true; break;
                }
                case LE_STR8('p','r','o','c','t','y','p','e'): {
                    value_SetEnum(parent,ams_FieldId_proctype); ret = true; break;
                }
                case LE_STR8('s','h','m','e','m','b','e','r'): {
                    value_SetEnum(parent,ams_FieldId_shmember); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('w','r','i','t','e','_','e','r'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,ams_FieldId_write_err); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('r','e','m','o','v','e','_','t'): {
                    if (memcmp(rhs.elems+8,"opmost",6)==0) { value_SetEnum(parent,ams_FieldId_remove_topmost); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::FieldId& parent, algo::strptr rhs, ams_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.FieldId..ReadStrptrMaybe
// Read fields of ams::FieldId from an ascii string.
// The format of the string is the format of the ams::FieldId's only field
bool ams::FieldId_ReadStrptrMaybe(ams::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.FieldId..Print
// print string representation of ROW to string STR
// cfmt:ams.FieldId.String  printfmt:Raw
void ams::FieldId_Print(ams::FieldId& row, algo::cstring& str) {
    ams::value_Print(row, str);
}

// --- ams.Proctype.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::Proctype& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_Proctype_                 : ret = "";  break;
        case ams_Proctype_ams_sendtest     : ret = "ams_sendtest";  break;
    }
    return ret;
}

// --- ams.Proctype.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::Proctype& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.Proctype.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::Proctype& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 0: {
            value_SetEnum(parent,ams_Proctype_);
            ret = true;
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','_','s','e','n','d'): {
                    if (memcmp(rhs.elems+8,"test",4)==0) { value_SetEnum(parent,ams_Proctype_ams_sendtest); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.Proctype.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::Proctype& parent, algo::strptr rhs, ams_ProctypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.Proctype.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::Proctype& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.Proctype..ReadStrptrMaybe
// Read fields of ams::Proctype from an ascii string.
// The format of the string is the format of the ams::Proctype's only field
bool ams::Proctype_ReadStrptrMaybe(ams::Proctype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.Proctype..Print
// print string representation of ROW to string STR
// cfmt:ams.Proctype.String  printfmt:Raw
void ams::Proctype_Print(ams::Proctype row, algo::cstring& str) {
    ams::value_Print(row, str);
}

// --- ams.ProcId.proctype.ReadStrptrMaybe
inline static bool ams::proctype_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) {
    bool retval = true;
    ams::Proctype proctype_tmp;
    retval = ams::Proctype_ReadStrptrMaybe(proctype_tmp, in_str);
    if (retval) {
        proctype_Set(parent, proctype_tmp);
    }
    return retval;
}

// --- ams.ProcId.nodeidx.ReadStrptrMaybe
inline static bool ams::nodeidx_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) {
    bool retval = true;
    u8 nodeidx_tmp;
    retval = u8_ReadStrptrMaybe(nodeidx_tmp, in_str);
    if (retval) {
        nodeidx_Set(parent, nodeidx_tmp);
    }
    return retval;
}

// --- ams.ProcId.procidx.ReadStrptrMaybe
inline static bool ams::procidx_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) {
    bool retval = true;
    u8 procidx_tmp;
    retval = u8_ReadStrptrMaybe(procidx_tmp, in_str);
    if (retval) {
        procidx_Set(parent, procidx_tmp);
    }
    return retval;
}

// --- ams.ProcId..ReadFieldMaybe
bool ams::ProcId_ReadFieldMaybe(ams::ProcId& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_value: {
            retval = u32_ReadStrptrMaybe(parent.value, strval);
        } break;
        case ams_FieldId_proctype: {
            retval = proctype_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_nodeidx: {
            retval = nodeidx_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_procidx: {
            retval = procidx_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcId..ReadStrptrMaybe
// Read fields of ams::ProcId from an ascii string.
// The format of the string is a string with separated values
bool ams::ProcId_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '-', value);
    retval = retval && proctype_ReadStrptrMaybe(parent, value);

    algo::NextSep(in_str, '-', value);
    retval = retval && nodeidx_ReadStrptrMaybe(parent, value);

    value = in_str;
    retval = retval && procidx_ReadStrptrMaybe(parent, value);
    return retval;
}

// --- ams.ProcId..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcId.String  printfmt:Sep
void ams::ProcId_Print(ams::ProcId row, algo::cstring& str) {
    ams::Proctype_Print(proctype_Get(row), str);
    str << '-';
    u8_Print(nodeidx_Get(row), str);
    str << '-';
    u8_Print(procidx_Get(row), str);
}

// --- ams.InputLineMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::InputLineMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.InputLineMsg.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::payload_Getary(ams::InputLineMsg& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ams.InputLineMsg.payload.Addr
char* ams::payload_Addr(ams::InputLineMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::InputLineMsg)); // address of varlen portion
}

// --- ams.InputLineMsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::InputLineMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.InputLineMsg.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ams::payload_Print(ams::InputLineMsg& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ams.InputLineMsg..ReadFieldMaybe
bool ams::InputLineMsg_ReadFieldMaybe(ams::InputLineMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc_id: {
            retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval);
        } break;
        case ams_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.InputLineMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::InputLineMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::InputLineMsg_ReadStrptrMaybe(ams::InputLineMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.InputLineMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && InputLineMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.InputLineMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.InputLineMsg.String  printfmt:Tuple
void ams::InputLineMsg_Print(ams::InputLineMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.InputLineMsg";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);

    ams::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ams.LogMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::LogMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.LogMsg.logcat.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::logcat_Getary(ams::LogMsg& parent) {
    return algo::aryptr<char>(logcat_Addr(parent), logcat_N(parent));
}

// --- ams.LogMsg.logcat.Addr
char* ams::logcat_Addr(ams::LogMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::LogMsg)); // address of varlen portion
}

// --- ams.LogMsg.logcat.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::logcat_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Insary(*algo_lib::_db.varlenbuf,strptr_ToMemptr(in_str),parent.logcat_end);
        u32 incr = ch_N(in_str);
        parent.logcat_end = u32(parent.logcat_end + incr);
    }
    return retval;
}

// --- ams.LogMsg.logcat.Print
// Convert logcat to a string.
// Array is printed as a regular string.
void ams::logcat_Print(ams::LogMsg& parent, algo::cstring &rhs) {
    rhs << logcat_Getary(parent);
}

// --- ams.LogMsg.text.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::text_Getary(ams::LogMsg& parent) {
    return algo::aryptr<char>(text_Addr(parent), text_N(parent));
}

// --- ams.LogMsg.text.Addr
char* ams::text_Addr(ams::LogMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::LogMsg) + parent.logcat_end); // address of varlen portion
}

// --- ams.LogMsg.text.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::text_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.LogMsg.text.Print
// Convert text to a string.
// Array is printed as a regular string.
void ams::text_Print(ams::LogMsg& parent, algo::cstring &rhs) {
    rhs << text_Getary(parent);
}

// --- ams.LogMsg..ReadFieldMaybe
bool ams::LogMsg_ReadFieldMaybe(ams::LogMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc_id: {
            retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval);
        } break;
        case ams_FieldId_tstamp: {
            retval = algo::SchedTime_ReadStrptrMaybe(parent.tstamp, strval);
        } break;
        case ams_FieldId_logcat: {
            retval = logcat_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_text: {
            retval = text_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.LogMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::LogMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::LogMsg_ReadStrptrMaybe(ams::LogMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.LogMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && LogMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.LogMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.LogMsg.String  printfmt:Tuple
void ams::LogMsg_Print(ams::LogMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.LogMsg";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);

    algo::SchedTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    ams::logcat_Print(row, temp);
    PrintAttrSpaceReset(str,"logcat", temp);

    ams::text_Print(row, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- ams.MsgBlock.header.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::MsgBlock &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.MsgBlock.messages.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> ams::messages_Getary(ams::MsgBlock& parent) {
    return algo::aryptr<u8>(messages_Addr(parent), messages_N(parent));
}

// --- ams.MsgBlock.messages.Addr
u8* ams::messages_Addr(ams::MsgBlock& parent) {
    return (u8*)((u8*)&parent + sizeof(ams::MsgBlock)); // address of varlen portion
}

// --- ams.MsgBlock.messages.Print
// Convert messages to a string.
// Array is printed as a regular string.
void ams::messages_Print(ams::MsgBlock& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(messages_Getary(parent));
}

// --- ams.MsgBlock..Print
// print string representation of ROW to string STR
// cfmt:ams.MsgBlock.String  printfmt:Tuple
void ams::MsgBlock_Print(ams::MsgBlock& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.MsgBlock";

    u64_Print(row.first_seqno, temp);
    PrintAttrSpaceReset(str,"first_seqno", temp);

    u32_Print(row.n_messages, temp);
    PrintAttrSpaceReset(str,"n_messages", temp);

    u32_Print(row.original_length, temp);
    PrintAttrSpaceReset(str,"original_length", temp);

    ams::messages_Print(row, temp);
    PrintAttrSpaceReset(str,"messages", temp);
}

// --- ams.MsgHeader.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::type_ToCstr(const ams::MsgHeader& payload) {
    const char *ret = NULL;
    switch(type_GetEnum(payload)) {
        case ams_MsgHeader_type_ams_ExpectMsg: ret = "ams.ExpectMsg";  break;
        case ams_MsgHeader_type_ams_InputLineMsg: ret = "ams.InputLineMsg";  break;
        case ams_MsgHeader_type_ams_LogMsg : ret = "ams.LogMsg";  break;
        case ams_MsgHeader_type_ams_MsgBlock: ret = "ams.MsgBlock";  break;
        case ams_MsgHeader_type_ams_ProcEofMsg: ret = "ams.ProcEofMsg";  break;
        case ams_MsgHeader_type_ams_ProcKillMsg: ret = "ams.ProcKillMsg";  break;
        case ams_MsgHeader_type_ams_ProcMsg: ret = "ams.ProcMsg";  break;
        case ams_MsgHeader_type_ams_ProcReadMsg: ret = "ams.ProcReadMsg";  break;
        case ams_MsgHeader_type_ams_ProcStartMsg: ret = "ams.ProcStartMsg";  break;
        case ams_MsgHeader_type_ams_ProcStatusMsg: ret = "ams.ProcStatusMsg";  break;
        case ams_MsgHeader_type_ams_RemDirRecurseMsg: ret = "ams.RemDirRecurseMsg";  break;
        case ams_MsgHeader_type_ams_ShmHbMsg: ret = "ams.ShmHbMsg";  break;
        case ams_MsgHeader_type_ams_Shmmsg : ret = "ams.Shmmsg";  break;
        case ams_MsgHeader_type_ams_TerminateMsg: ret = "ams.TerminateMsg";  break;
        case ams_MsgHeader_type_ams_UdpFrame: ret = "ams.UdpFrame";  break;
        case ams_MsgHeader_type_fm_AlarmMsg: ret = "fm.AlarmMsg";  break;
        case ams_MsgHeader_type_ws_CloseMsg: ret = "ws.CloseMsg";  break;
        case ams_MsgHeader_type_ws_ConnectMsg: ret = "ws.ConnectMsg";  break;
        case ams_MsgHeader_type_ws_DataMsg : ret = "ws.DataMsg";  break;
        case ams_MsgHeader_type_ws_ServerStartMsg: ret = "ws.ServerStartMsg";  break;
        case ams_MsgHeader_type_ws_ServerStopMsg: ret = "ws.ServerStopMsg";  break;
    }
    return ret;
}

// --- ams.MsgHeader.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void ams::type_Print(const ams::MsgHeader& payload, algo::cstring &lhs) {
    const char *strval = type_ToCstr(payload);
    if (strval) {
        lhs << strval;
    } else {
        lhs << payload.type;
    }
}

// --- ams.MsgHeader.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::type_SetStrptrMaybe(ams::MsgHeader& payload, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','L','o','g','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_LogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','h','m','m'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_Shmmsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','D','a','t','a','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { type_SetEnum(payload,ams_MsgHeader_type_ws_DataMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('f','m','.','A','l','a','r','m'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { type_SetEnum(payload,ams_MsgHeader_type_fm_AlarmMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','C','l','o','s','e'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { type_SetEnum(payload,ams_MsgHeader_type_ws_CloseMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','M','s','g','B'): {
                    if (memcmp(rhs.elems+8,"lock",4)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_MsgBlock); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','h','m','H'): {
                    if (memcmp(rhs.elems+8,"bMsg",4)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ShmHbMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','U','d','p','F'): {
                    if (memcmp(rhs.elems+8,"rame",4)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_UdpFrame); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','E','x','p','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ExpectMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','C','o','n','n','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { type_SetEnum(payload,ams_MsgHeader_type_ws_ConnectMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"EofMsg",6)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcEofMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"KillMsg",7)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcKillMsg); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ReadMsg",7)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcReadMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','I','n','p','u'): {
                    if (memcmp(rhs.elems+8,"tLineMsg",8)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_InputLineMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"StartMsg",8)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcStartMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','e','r','m'): {
                    if (memcmp(rhs.elems+8,"inateMsg",8)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_TerminateMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','S','e','r','v','e'): {
                    if (memcmp(rhs.elems+8,"rStopMsg",8)==0) { type_SetEnum(payload,ams_MsgHeader_type_ws_ServerStopMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"StatusMsg",9)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_ProcStatusMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','S','e','r','v','e'): {
                    if (memcmp(rhs.elems+8,"rStartMsg",9)==0) { type_SetEnum(payload,ams_MsgHeader_type_ws_ServerStartMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 20: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','R','e','m','D'): {
                    if (memcmp(rhs.elems+8,"irRecurseMsg",12)==0) { type_SetEnum(payload,ams_MsgHeader_type_ams_RemDirRecurseMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.MsgHeader.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::type_SetStrptr(ams::MsgHeader& payload, algo::strptr rhs, ams_MsgHeader_type_Enum dflt) {
    if (!type_SetStrptrMaybe(payload,rhs)) type_SetEnum(payload,dflt);
}

// --- ams.MsgHeader.type.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::type_ReadStrptrMaybe(ams::MsgHeader& payload, algo::strptr rhs) {
    bool retval = false;
    retval = type_SetStrptrMaybe(payload,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(payload.type,rhs);
    }
    return retval;
}

// --- ams.MsgHeader..ReadFieldMaybe
bool ams::MsgHeader_ReadFieldMaybe(ams::MsgHeader& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_type: {
            retval = type_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.MsgHeader..ReadStrptrMaybe
// Read fields of ams::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
bool ams::MsgHeader_ReadStrptrMaybe(ams::MsgHeader &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.MsgHeader");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgHeader_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.MsgHeader..Print
// print string representation of ROW to string STR
// cfmt:ams.MsgHeader.String  printfmt:Tuple
void ams::MsgHeader_Print(ams::MsgHeader& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.MsgHeader";
    (void)row;//only to avoid -Wunused-parameter
}

// --- ams.MsgHeaderMsgsCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::MsgHeaderMsgsCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_MsgHeaderMsgsCase_ams_ExpectMsg: ret = "ams.ExpectMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_InputLineMsg: ret = "ams.InputLineMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_LogMsg: ret = "ams.LogMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_MsgBlock: ret = "ams.MsgBlock";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcEofMsg: ret = "ams.ProcEofMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcKillMsg: ret = "ams.ProcKillMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcMsg: ret = "ams.ProcMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcReadMsg: ret = "ams.ProcReadMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcStartMsg: ret = "ams.ProcStartMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcStatusMsg: ret = "ams.ProcStatusMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_RemDirRecurseMsg: ret = "ams.RemDirRecurseMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ShmHbMsg: ret = "ams.ShmHbMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_Shmmsg: ret = "ams.Shmmsg";  break;
        case ams_MsgHeaderMsgsCase_ams_TerminateMsg: ret = "ams.TerminateMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_UdpFrame: ret = "ams.UdpFrame";  break;
        case ams_MsgHeaderMsgsCase_fm_AlarmMsg: ret = "fm.AlarmMsg";  break;
        case ams_MsgHeaderMsgsCase_ws_CloseMsg: ret = "ws.CloseMsg";  break;
        case ams_MsgHeaderMsgsCase_ws_ConnectMsg: ret = "ws.ConnectMsg";  break;
        case ams_MsgHeaderMsgsCase_ws_DataMsg: ret = "ws.DataMsg";  break;
        case ams_MsgHeaderMsgsCase_ws_ServerStartMsg: ret = "ws.ServerStartMsg";  break;
        case ams_MsgHeaderMsgsCase_ws_ServerStopMsg: ret = "ws.ServerStopMsg";  break;
    }
    return ret;
}

// --- ams.MsgHeaderMsgsCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::MsgHeaderMsgsCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.MsgHeaderMsgsCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','L','o','g','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_LogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','h','m','m'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_Shmmsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','D','a','t','a','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ws_DataMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('f','m','.','A','l','a','r','m'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_fm_AlarmMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','C','l','o','s','e'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ws_CloseMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','M','s','g','B'): {
                    if (memcmp(rhs.elems+8,"lock",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_MsgBlock); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','h','m','H'): {
                    if (memcmp(rhs.elems+8,"bMsg",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ShmHbMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','U','d','p','F'): {
                    if (memcmp(rhs.elems+8,"rame",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_UdpFrame); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','E','x','p','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ExpectMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','C','o','n','n','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ws_ConnectMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"EofMsg",6)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcEofMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"KillMsg",7)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcKillMsg); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ReadMsg",7)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcReadMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','I','n','p','u'): {
                    if (memcmp(rhs.elems+8,"tLineMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_InputLineMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"StartMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcStartMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','e','r','m'): {
                    if (memcmp(rhs.elems+8,"inateMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_TerminateMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','S','e','r','v','e'): {
                    if (memcmp(rhs.elems+8,"rStopMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ws_ServerStopMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"StatusMsg",9)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcStatusMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('w','s','.','S','e','r','v','e'): {
                    if (memcmp(rhs.elems+8,"rStartMsg",9)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ws_ServerStartMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 20: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','R','e','m','D'): {
                    if (memcmp(rhs.elems+8,"irRecurseMsg",12)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_RemDirRecurseMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.MsgHeaderMsgsCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs, ams_MsgHeaderMsgsCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.MsgHeaderMsgsCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.MsgHeaderMsgsCase..ReadStrptrMaybe
// Read fields of ams::MsgHeaderMsgsCase from an ascii string.
// The format of the string is the format of the ams::MsgHeaderMsgsCase's only field
bool ams::MsgHeaderMsgsCase_ReadStrptrMaybe(ams::MsgHeaderMsgsCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.ProcEofMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcEofMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcEofMsg..ReadFieldMaybe
bool ams::ProcEofMsg_ReadFieldMaybe(ams::ProcEofMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcEofMsg..ReadStrptrMaybe
// Read fields of ams::ProcEofMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcEofMsg_ReadStrptrMaybe(ams::ProcEofMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcEofMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcEofMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcEofMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcEofMsg.String  printfmt:Tuple
void ams::ProcEofMsg_Print(ams::ProcEofMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcEofMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);
}

// --- ams.ProcKillMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcKillMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcKillMsg..ReadFieldMaybe
bool ams::ProcKillMsg_ReadFieldMaybe(ams::ProcKillMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        case ams_FieldId_signal: {
            retval = i32_ReadStrptrMaybe(parent.signal, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcKillMsg..ReadStrptrMaybe
// Read fields of ams::ProcKillMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcKillMsg_ReadStrptrMaybe(ams::ProcKillMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcKillMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcKillMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcKillMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcKillMsg.String  printfmt:Tuple
void ams::ProcKillMsg_Print(ams::ProcKillMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcKillMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    i32_Print(row.signal, temp);
    PrintAttrSpaceReset(str,"signal", temp);
}

// --- ams.ProcMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcMsg.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::payload_Getary(ams::ProcMsg& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ams.ProcMsg.payload.Addr
char* ams::payload_Addr(ams::ProcMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::ProcMsg)); // address of varlen portion
}

// --- ams.ProcMsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::ProcMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.ProcMsg.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ams::payload_Print(ams::ProcMsg& parent, algo::cstring &rhs) {
    rhs << payload_Getary(parent);
}

// --- ams.ProcMsg..ReadFieldMaybe
bool ams::ProcMsg_ReadFieldMaybe(ams::ProcMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        case ams_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcMsg_ReadStrptrMaybe(ams::ProcMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcMsg.String  printfmt:Tuple
void ams::ProcMsg_Print(ams::ProcMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    ams::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ams.ProcReadMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcReadMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcReadMsg.until.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::until_Getary(ams::ProcReadMsg& parent) {
    return algo::aryptr<char>(until_Addr(parent), until_N(parent));
}

// --- ams.ProcReadMsg.until.Addr
char* ams::until_Addr(ams::ProcReadMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::ProcReadMsg)); // address of varlen portion
}

// --- ams.ProcReadMsg.until.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::until_ReadStrptrMaybe(ams::ProcReadMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.ProcReadMsg.until.Print
// Convert until to a string.
// Array is printed as a regular string.
void ams::until_Print(ams::ProcReadMsg& parent, algo::cstring &rhs) {
    rhs << until_Getary(parent);
}

// --- ams.ProcReadMsg..ReadFieldMaybe
bool ams::ProcReadMsg_ReadFieldMaybe(ams::ProcReadMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        case ams_FieldId_until: {
            retval = until_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcReadMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcReadMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcReadMsg_ReadStrptrMaybe(ams::ProcReadMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcReadMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcReadMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcReadMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcReadMsg.String  printfmt:Tuple
void ams::ProcReadMsg_Print(ams::ProcReadMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcReadMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    ams::until_Print(row, temp);
    PrintAttrSpaceReset(str,"until", temp);
}

// --- ams.ProcStartMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcStartMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcStartMsg.cmd.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::cmd_Getary(ams::ProcStartMsg& parent) {
    return algo::aryptr<char>(cmd_Addr(parent), cmd_N(parent));
}

// --- ams.ProcStartMsg.cmd.Addr
char* ams::cmd_Addr(ams::ProcStartMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::ProcStartMsg)); // address of varlen portion
}

// --- ams.ProcStartMsg.cmd.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::cmd_ReadStrptrMaybe(ams::ProcStartMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.ProcStartMsg.cmd.Print
// Convert cmd to a string.
// Array is printed as a regular string.
void ams::cmd_Print(ams::ProcStartMsg& parent, algo::cstring &rhs) {
    rhs << cmd_Getary(parent);
}

// --- ams.ProcStartMsg..ReadFieldMaybe
bool ams::ProcStartMsg_ReadFieldMaybe(ams::ProcStartMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        case ams_FieldId_pty: {
            retval = bool_ReadStrptrMaybe(parent.pty, strval);
        } break;
        case ams_FieldId_cmd: {
            retval = cmd_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcStartMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcStartMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcStartMsg_ReadStrptrMaybe(ams::ProcStartMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcStartMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcStartMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcStartMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcStartMsg.String  printfmt:Tuple
void ams::ProcStartMsg_Print(ams::ProcStartMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcStartMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    bool_Print(row.pty, temp);
    PrintAttrSpaceReset(str,"pty", temp);

    ams::cmd_Print(row, temp);
    PrintAttrSpaceReset(str,"cmd", temp);
}

// --- ams.ProcStatusMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ProcStatusMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ProcStatusMsg..ReadFieldMaybe
bool ams::ProcStatusMsg_ReadFieldMaybe(ams::ProcStatusMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_proc: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.proc, strval);
        } break;
        case ams_FieldId_status: {
            retval = algo::RnullStr50_ReadStrptrMaybe(parent.status, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcStatusMsg..ReadStrptrMaybe
// Read fields of ams::ProcStatusMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcStatusMsg_ReadStrptrMaybe(ams::ProcStatusMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcStatusMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcStatusMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcStatusMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ProcStatusMsg.String  printfmt:Tuple
void ams::ProcStatusMsg_Print(ams::ProcStatusMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ProcStatusMsg";

    algo::RnullStr50_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    algo::RnullStr50_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);
}

// --- ams.RemDirRecurseMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::RemDirRecurseMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.RemDirRecurseMsg.pathname.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::pathname_Getary(ams::RemDirRecurseMsg& parent) {
    return algo::aryptr<char>(pathname_Addr(parent), pathname_N(parent));
}

// --- ams.RemDirRecurseMsg.pathname.Addr
char* ams::pathname_Addr(ams::RemDirRecurseMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::RemDirRecurseMsg)); // address of varlen portion
}

// --- ams.RemDirRecurseMsg.pathname.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::pathname_ReadStrptrMaybe(ams::RemDirRecurseMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.RemDirRecurseMsg.pathname.Print
// Convert pathname to a string.
// Array is printed as a regular string.
void ams::pathname_Print(ams::RemDirRecurseMsg& parent, algo::cstring &rhs) {
    rhs << pathname_Getary(parent);
}

// --- ams.RemDirRecurseMsg..ReadFieldMaybe
bool ams::RemDirRecurseMsg_ReadFieldMaybe(ams::RemDirRecurseMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_remove_topmost: {
            retval = bool_ReadStrptrMaybe(parent.remove_topmost, strval);
        } break;
        case ams_FieldId_pathname: {
            retval = pathname_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.RemDirRecurseMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::RemDirRecurseMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::RemDirRecurseMsg_ReadStrptrMaybe(ams::RemDirRecurseMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.RemDirRecurseMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && RemDirRecurseMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.RemDirRecurseMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.RemDirRecurseMsg.String  printfmt:Tuple
void ams::RemDirRecurseMsg_Print(ams::RemDirRecurseMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.RemDirRecurseMsg";

    bool_Print(row.remove_topmost, temp);
    PrintAttrSpaceReset(str,"remove_topmost", temp);

    ams::pathname_Print(row, temp);
    PrintAttrSpaceReset(str,"pathname", temp);
}

// --- ams.ShmFlags.write.ReadStrptrMaybe
inline static bool ams::write_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- ams.ShmFlags.read.ReadStrptrMaybe
inline static bool ams::read_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- ams.ShmFlags.nonblock.ReadStrptrMaybe
inline static bool ams::nonblock_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool nonblock_tmp;
    retval = bool_ReadStrptrMaybe(nonblock_tmp, in_str);
    if (retval) {
        nonblock_Set(parent, nonblock_tmp);
    }
    return retval;
}

// --- ams.ShmFlags.write_err.ReadStrptrMaybe
inline static bool ams::write_err_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_err_tmp;
    retval = bool_ReadStrptrMaybe(write_err_tmp, in_str);
    if (retval) {
        write_err_Set(parent, write_err_tmp);
    }
    return retval;
}

// --- ams.ShmFlags..ReadFieldMaybe
bool ams::ShmFlags_ReadFieldMaybe(ams::ShmFlags& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_value: {
            retval = u8_ReadStrptrMaybe(parent.value, strval);
        } break;
        case ams_FieldId_write: {
            retval = write_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_read: {
            retval = read_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_nonblock: {
            retval = nonblock_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_write_err: {
            retval = write_err_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ShmFlags..ReadStrptrMaybe
// Read fields of ams::ShmFlags from an ascii string.
bool ams::ShmFlags_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    write_Set(parent, false);
    read_Set(parent, false);
    nonblock_Set(parent, false);
    write_err_Set(parent, false);
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            ams::FieldId field_id;
            bool ok = ams::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case ams_FieldId_write: {
                        write_Set(parent, true);
                    } break;
                    case ams_FieldId_read: {
                        read_Set(parent, true);
                    } break;
                    case ams_FieldId_nonblock: {
                        nonblock_Set(parent, true);
                    } break;
                    case ams_FieldId_write_err: {
                        write_err_Set(parent, true);
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- ams.ShmFlags..Print
// print string representation of ROW to string STR
// cfmt:ams.ShmFlags.String  printfmt:Bitset
void ams::ShmFlags_Print(ams::ShmFlags row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (nonblock_Get(row)) {
        str << ls << "nonblock";
    }
    if (write_err_Get(row)) {
        str << ls << "write_err";
    }
}

// --- ams.ShmFlags..GetAnon
algo::strptr ams::ShmFlags_GetAnon(ams::ShmFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- ams.Shmtype.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::Shmtype& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_Shmtype_ctl               : ret = "ctl";  break;
        case ams_Shmtype_log               : ret = "log";  break;
        case ams_Shmtype_out               : ret = "out";  break;
    }
    return ret;
}

// --- ams.Shmtype.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::Shmtype& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.Shmtype.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::Shmtype& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','t','l'): {
                    value_SetEnum(parent,ams_Shmtype_ctl); ret = true; break;
                }
                case LE_STR3('l','o','g'): {
                    value_SetEnum(parent,ams_Shmtype_log); ret = true; break;
                }
                case LE_STR3('o','u','t'): {
                    value_SetEnum(parent,ams_Shmtype_out); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.Shmtype.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::Shmtype& parent, algo::strptr rhs, ams_ShmtypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.Shmtype.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::Shmtype& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.Shmtype..ReadStrptrMaybe
// Read fields of ams::Shmtype from an ascii string.
// The format of the string is the format of the ams::Shmtype's only field
bool ams::Shmtype_ReadStrptrMaybe(ams::Shmtype &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.Shmtype..Print
// print string representation of ROW to string STR
// cfmt:ams.Shmtype.String  printfmt:Raw
void ams::Shmtype_Print(ams::Shmtype row, algo::cstring& str) {
    ams::value_Print(row, str);
}

// --- ams.ShmId..ReadFieldMaybe
bool ams::ShmId_ReadFieldMaybe(ams::ShmId& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_proc_id: {
            retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval);
        } break;
        case ams_FieldId_shmtype: {
            retval = ams::Shmtype_ReadStrptrMaybe(parent.shmtype, strval);
        } break;
        case ams_FieldId_index: {
            retval = u8_ReadStrptrMaybe(parent.index, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ShmId..ReadStrptrMaybe
// Read fields of ams::ShmId from an ascii string.
// The format of the string is a string with separated values
bool ams::ShmId_ReadStrptrMaybe(ams::ShmId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '.', value);
    retval = retval && ams::ProcId_ReadStrptrMaybe(parent.proc_id, value);

    algo::NextSep(in_str, '-', value);
    retval = retval && ams::Shmtype_ReadStrptrMaybe(parent.shmtype, value);

    value = in_str;
    retval = retval && u8_ReadStrptrMaybe(parent.index, value);
    return retval;
}

// --- ams.ShmId..Print
// print string representation of ROW to string STR
// cfmt:ams.ShmId.String  printfmt:Sep
void ams::ShmId_Print(ams::ShmId row, algo::cstring& str) {
    ams::ProcId_Print(row.proc_id, str);
    str << '.';
    ams::Shmtype_Print(row.shmtype, str);
    str << '-';
    u8_Print(row.index, str);
}

// --- ams.ShmemberFlags.r.ReadStrptrMaybe
inline static bool ams::r_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool r_tmp;
    retval = bool_ReadStrptrMaybe(r_tmp, in_str);
    if (retval) {
        r_Set(parent, r_tmp);
    }
    return retval;
}

// --- ams.ShmemberFlags.w.ReadStrptrMaybe
inline static bool ams::w_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool w_tmp;
    retval = bool_ReadStrptrMaybe(w_tmp, in_str);
    if (retval) {
        w_Set(parent, w_tmp);
    }
    return retval;
}

// --- ams.ShmemberFlags..ReadFieldMaybe
bool ams::ShmemberFlags_ReadFieldMaybe(ams::ShmemberFlags& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_value: {
            retval = u16_ReadStrptrMaybe(parent.value, strval);
        } break;
        case ams_FieldId_r: {
            retval = r_ReadStrptrMaybe(parent, strval);
        } break;
        case ams_FieldId_w: {
            retval = w_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ShmemberFlags..ReadStrptrMaybe
// Read fields of ams::ShmemberFlags from an ascii string.
bool ams::ShmemberFlags_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    r_Set(parent, false);
    w_Set(parent, false);
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            ams::FieldId field_id;
            bool ok = ams::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case ams_FieldId_r: {
                        r_Set(parent, true);
                    } break;
                    case ams_FieldId_w: {
                        w_Set(parent, true);
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- ams.ShmemberFlags..Print
// print string representation of ROW to string STR
// cfmt:ams.ShmemberFlags.String  printfmt:Bitset
void ams::ShmemberFlags_Print(ams::ShmemberFlags row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (r_Get(row)) {
        str << ls << "r";
    }
    if (w_Get(row)) {
        str << ls << "w";
    }
}

// --- ams.ShmemberFlags..GetAnon
algo::strptr ams::ShmemberFlags_GetAnon(ams::ShmemberFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- ams.ShmemberId..ReadFieldMaybe
bool ams::ShmemberId_ReadFieldMaybe(ams::ShmemberId& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_shm_id: {
            retval = ams::ShmId_ReadStrptrMaybe(parent.shm_id, strval);
        } break;
        case ams_FieldId_proc_id: {
            retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval);
        } break;
        case ams_FieldId_flags: {
            retval = ams::ShmemberFlags_ReadStrptrMaybe(parent.flags, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ShmemberId..ReadStrptrMaybe
// Read fields of ams::ShmemberId from an ascii string.
// The format of the string is a string with separated values
bool ams::ShmemberId_ReadStrptrMaybe(ams::ShmemberId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '/', value);
    retval = retval && ams::ShmId_ReadStrptrMaybe(parent.shm_id, value);

    algo::NextSep(in_str, ',', value);
    retval = retval && ams::ProcId_ReadStrptrMaybe(parent.proc_id, value);

    value = in_str;
    retval = retval && ams::ShmemberFlags_ReadStrptrMaybe(parent.flags, value);
    return retval;
}

// --- ams.ShmemberId..Print
// print string representation of ROW to string STR
// cfmt:ams.ShmemberId.String  printfmt:Sep
void ams::ShmemberId_Print(ams::ShmemberId row, algo::cstring& str) {
    ams::ShmId_Print(row.shm_id, str);
    str << '/';
    ams::ProcId_Print(row.proc_id, str);
    str << ',';
    ams::ShmemberFlags_Print(row.flags, str);
}

// --- ams.ShmHbMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::ShmHbMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.ShmHbMsg..ReadFieldMaybe
bool ams::ShmHbMsg_ReadFieldMaybe(ams::ShmHbMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_shmember: {
            retval = ams::ShmemberId_ReadStrptrMaybe(parent.shmember, strval);
        } break;
        case ams_FieldId_off: {
            retval = u64_ReadStrptrMaybe(parent.off, strval);
        } break;
        case ams_FieldId_wbudget: {
            retval = u32_ReadStrptrMaybe(parent.wbudget, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ShmHbMsg..ReadStrptrMaybe
// Read fields of ams::ShmHbMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ShmHbMsg_ReadStrptrMaybe(ams::ShmHbMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ShmHbMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ShmHbMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ShmHbMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.ShmHbMsg.String  printfmt:Tuple
void ams::ShmHbMsg_Print(ams::ShmHbMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.ShmHbMsg";

    ams::ShmemberId_Print(row.shmember, temp);
    PrintAttrSpaceReset(str,"shmember", temp);

    u64_Print(row.off, temp);
    PrintAttrSpaceReset(str,"off", temp);

    u32_Print(row.wbudget, temp);
    PrintAttrSpaceReset(str,"wbudget", temp);
}

// --- ams.Shmmsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::Shmmsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.Shmmsg.payload.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> ams::payload_Getary(ams::Shmmsg& parent) {
    u8 *end = (u8*)&parent + sizeof(ams::Shmmsg);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(ams::Shmmsg));
}

// --- ams.Shmmsg.payload.Print
void ams::payload_Print(ams::Shmmsg& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (ams::MsgHeader *payload = payload_Get(parent)) {
        ams::MsgHeaderMsgs_Print(out, *payload, INT_MAX);
    }
}

// --- ams.Shmmsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::Shmmsg &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = ams::MsgHeaderMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.Shmmsg..ReadFieldMaybe
bool ams::Shmmsg_ReadFieldMaybe(ams::Shmmsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        case ams_FieldId_shm_id: {
            retval = ams::ShmId_ReadStrptrMaybe(parent.shm_id, strval);
        } break;
        case ams_FieldId_off: {
            retval = u64_ReadStrptrMaybe(parent.off, strval);
        } break;
        case ams_FieldId_tstamp: {
            retval = u64_ReadStrptrMaybe(parent.tstamp, strval);
        } break;
        case ams_FieldId_payload: {
            retval = payload_ReadStrptrMaybe(parent, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.Shmmsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Shmmsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::Shmmsg_ReadStrptrMaybe(ams::Shmmsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.Shmmsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Shmmsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.Shmmsg..Print
// print string representation of ROW to string STR
// cfmt:ams.Shmmsg.String  printfmt:Tuple
void ams::Shmmsg_Print(ams::Shmmsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.Shmmsg";

    ams::ShmId_Print(row.shm_id, temp);
    PrintAttrSpaceReset(str,"shm_id", temp);

    u64_Print(row.off, temp);
    PrintAttrSpaceReset(str,"off", temp);

    u64_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    if (payload_Get(row)) {
        ams::payload_Print(row, temp);
        PrintAttrSpaceReset(str,"payload", temp);
    }
}

// --- ams.TerminateMsg.base.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::TerminateMsg &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.TerminateMsg..ReadFieldMaybe
bool ams::TerminateMsg_ReadFieldMaybe(ams::TerminateMsg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case ams_FieldId_base: {
            retval = false;
        } break;
        case ams_FieldId_type: {
            retval = false;
        } break;
        case ams_FieldId_length: {
            retval = false;
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    (void)parent;//only to avoid -Wunused-parameter
    (void)strval;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.TerminateMsg..ReadStrptrMaybe
// Read fields of ams::TerminateMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::TerminateMsg_ReadStrptrMaybe(ams::TerminateMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.TerminateMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TerminateMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.TerminateMsg..Print
// print string representation of ROW to string STR
// cfmt:ams.TerminateMsg.String  printfmt:Tuple
void ams::TerminateMsg_Print(ams::TerminateMsg& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.TerminateMsg";
    (void)row;//only to avoid -Wunused-parameter
}

// --- ams.UdpFrame.header.CopyOut
// Copy fields out of row
void ams::parent_CopyOut(ams::UdpFrame &row, ams::MsgHeader &out) {
    // type: field value is computed
    // length: field value is computed
    (void)row;//only to avoid -Wunused-parameter
    (void)out;//only to avoid -Wunused-parameter
}

// --- ams.UdpFrame.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> ams::payload_Getary(ams::UdpFrame& parent) {
    return algo::aryptr<u8>(payload_Addr(parent), payload_N(parent));
}

// --- ams.UdpFrame.payload.Addr
u8* ams::payload_Addr(ams::UdpFrame& parent) {
    return (u8*)((u8*)&parent + sizeof(ams::UdpFrame)); // address of varlen portion
}

// --- ams.UdpFrame.payload.Print
// Convert payload to a string.
// Array is printed as a regular string.
void ams::payload_Print(ams::UdpFrame& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(payload_Getary(parent));
}

// --- ams.UdpFrame..Print
// print string representation of ROW to string STR
// cfmt:ams.UdpFrame.String  printfmt:Tuple
void ams::UdpFrame_Print(ams::UdpFrame& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "ams.UdpFrame";

    algo::UnTime_Print(row.timestamp, temp);
    PrintAttrSpaceReset(str,"timestamp", temp);

    ietf::Ipv4_Print(row.src_ip, temp);
    PrintAttrSpaceReset(str,"src_ip", temp);

    ietf::Ipv4_Print(row.dst_ip, temp);
    PrintAttrSpaceReset(str,"dst_ip", temp);

    u16_Print(row.src_port, temp);
    PrintAttrSpaceReset(str,"src_port", temp);

    u16_Print(row.dst_port, temp);
    PrintAttrSpaceReset(str,"dst_port", temp);

    ams::payload_Print(row, temp);
    PrintAttrSpaceReset(str,"payload", temp);
}

// --- ams...SizeCheck
inline static void ams::SizeCheck() {
}

// --- ams...StaticCheck
void ams::StaticCheck() {
    algo_assert(_offset_of(ams::FieldId, value) + sizeof(((ams::FieldId*)0)->value) == sizeof(ams::FieldId));
    algo_assert(_offset_of(ams::Proctype, value) + sizeof(((ams::Proctype*)0)->value) == sizeof(ams::Proctype));
    // check that bitfield fits width
    algo_assert(sizeof(((ams::ProcId*)0)->value)*8 >= 32);
    algo_assert(_offset_of(ams::ProcId, value) + sizeof(((ams::ProcId*)0)->value) == sizeof(ams::ProcId));
    algo_assert(_offset_of(ams::MsgHeaderMsgsCase, value) + sizeof(((ams::MsgHeaderMsgsCase*)0)->value) == sizeof(ams::MsgHeaderMsgsCase));
    algo_assert(_offset_of(ams::MsgHeader_curs, msglen) + sizeof(((ams::MsgHeader_curs*)0)->msglen) == sizeof(ams::MsgHeader_curs));
    algo_assert(_offset_of(ams::ProcEofMsg, proc) + sizeof(((ams::ProcEofMsg*)0)->proc) == sizeof(ams::ProcEofMsg));
    algo_assert(_offset_of(ams::ProcKillMsg, signal) + sizeof(((ams::ProcKillMsg*)0)->signal) == sizeof(ams::ProcKillMsg));
    algo_assert(_offset_of(ams::ProcStatusMsg, status) + sizeof(((ams::ProcStatusMsg*)0)->status) == sizeof(ams::ProcStatusMsg));
    // check that bitfield fits width
    algo_assert(sizeof(((ams::ShmFlags*)0)->value)*8 >= 7);
    algo_assert(_offset_of(ams::ShmFlags, value) + sizeof(((ams::ShmFlags*)0)->value) == sizeof(ams::ShmFlags));
    algo_assert(_offset_of(ams::Shmtype, value) + sizeof(((ams::Shmtype*)0)->value) == sizeof(ams::Shmtype));
    algo_assert(_offset_of(ams::ShmId, index) + sizeof(((ams::ShmId*)0)->index) == sizeof(ams::ShmId));
    // check that bitfield fits width
    algo_assert(sizeof(((ams::ShmemberFlags*)0)->value)*8 >= 2);
    algo_assert(_offset_of(ams::ShmemberFlags, value) + sizeof(((ams::ShmemberFlags*)0)->value) == sizeof(ams::ShmemberFlags));
    algo_assert(_offset_of(ams::ShmemberId, flags) + sizeof(((ams::ShmemberId*)0)->flags) == sizeof(ams::ShmemberId));
    algo_assert(_offset_of(ams::ShmHbMsg, wbudget) + sizeof(((ams::ShmHbMsg*)0)->wbudget) == sizeof(ams::ShmHbMsg));
    algo_assert(_offset_of(ams::TerminateMsg, length) + sizeof(((ams::TerminateMsg*)0)->length) == sizeof(ams::TerminateMsg));
}

// --- ams.MsgHeaderMsgs..Print
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool ams::MsgHeaderMsgs_Print(algo::cstring &str, ams::MsgHeader &msg, u32 msg_len) {
    switch(msg.type) {
        case 395: {
            if (sizeof(ams::ExpectMsg) > msg_len) { return false; }
            ExpectMsg_Print((ams::ExpectMsg&)(msg), str);
            return true;
        }
        case 22: {
            if (sizeof(ams::InputLineMsg) > msg_len) { return false; }
            InputLineMsg_Print((ams::InputLineMsg&)(msg), str);
            return true;
        }
        case 6: {
            if (sizeof(ams::LogMsg) > msg_len) { return false; }
            LogMsg_Print((ams::LogMsg&)(msg), str);
            return true;
        }
        case 1: {
            if (sizeof(ams::MsgBlock) > msg_len) { return false; }
            MsgBlock_Print((ams::MsgBlock&)(msg), str);
            return true;
        }
        case 703: {
            if (sizeof(ams::ProcEofMsg) > msg_len) { return false; }
            ProcEofMsg_Print((ams::ProcEofMsg&)(msg), str);
            return true;
        }
        case 704: {
            if (sizeof(ams::ProcKillMsg) > msg_len) { return false; }
            ProcKillMsg_Print((ams::ProcKillMsg&)(msg), str);
            return true;
        }
        case 701: {
            if (sizeof(ams::ProcMsg) > msg_len) { return false; }
            ProcMsg_Print((ams::ProcMsg&)(msg), str);
            return true;
        }
        case 702: {
            if (sizeof(ams::ProcReadMsg) > msg_len) { return false; }
            ProcReadMsg_Print((ams::ProcReadMsg&)(msg), str);
            return true;
        }
        case 700: {
            if (sizeof(ams::ProcStartMsg) > msg_len) { return false; }
            ProcStartMsg_Print((ams::ProcStartMsg&)(msg), str);
            return true;
        }
        case 705: {
            if (sizeof(ams::ProcStatusMsg) > msg_len) { return false; }
            ProcStatusMsg_Print((ams::ProcStatusMsg&)(msg), str);
            return true;
        }
        case 633: {
            if (sizeof(ams::RemDirRecurseMsg) > msg_len) { return false; }
            RemDirRecurseMsg_Print((ams::RemDirRecurseMsg&)(msg), str);
            return true;
        }
        case 3: {
            if (sizeof(ams::ShmHbMsg) > msg_len) { return false; }
            ShmHbMsg_Print((ams::ShmHbMsg&)(msg), str);
            return true;
        }
        case 10: {
            if (sizeof(ams::Shmmsg) > msg_len) { return false; }
            Shmmsg_Print((ams::Shmmsg&)(msg), str);
            return true;
        }
        case 352: {
            if (sizeof(ams::TerminateMsg) > msg_len) { return false; }
            TerminateMsg_Print((ams::TerminateMsg&)(msg), str);
            return true;
        }
        case 2: {
            if (sizeof(ams::UdpFrame) > msg_len) { return false; }
            UdpFrame_Print((ams::UdpFrame&)(msg), str);
            return true;
        }
        case 17: {
            if (sizeof(fm::AlarmMsg) > msg_len) { return false; }
            AlarmMsg_Print((fm::AlarmMsg&)(msg), str);
            return true;
        }
        case 504: {
            if (sizeof(ws::CloseMsg) > msg_len) { return false; }
            CloseMsg_Print((ws::CloseMsg&)(msg), str);
            return true;
        }
        case 502: {
            if (sizeof(ws::ConnectMsg) > msg_len) { return false; }
            ConnectMsg_Print((ws::ConnectMsg&)(msg), str);
            return true;
        }
        case 503: {
            if (sizeof(ws::DataMsg) > msg_len) { return false; }
            DataMsg_Print((ws::DataMsg&)(msg), str);
            return true;
        }
        case 500: {
            if (sizeof(ws::ServerStartMsg) > msg_len) { return false; }
            ServerStartMsg_Print((ws::ServerStartMsg&)(msg), str);
            return true;
        }
        case 501: {
            if (sizeof(ws::ServerStopMsg) > msg_len) { return false; }
            ServerStopMsg_Print((ws::ServerStopMsg&)(msg), str);
            return true;
        }
        default:

        return false;
    }
}

// --- ams.MsgHeaderMsgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
ams::MsgHeaderMsgsCase ams::MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    ams::MsgHeaderMsgsCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case ams_MsgHeaderMsgsCase_ams_ExpectMsg: {
            int len = sizeof(ams::ExpectMsg);
            ams::ExpectMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ExpectMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = ExpectMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::ExpectMsg case

        case ams_MsgHeaderMsgsCase_ams_InputLineMsg: {
            int len = sizeof(ams::InputLineMsg);
            ams::InputLineMsg *ctype = new(ary_AllocN(buf, len).elems) ams::InputLineMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = InputLineMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::InputLineMsg case

        case ams_MsgHeaderMsgsCase_ams_LogMsg: {
            int len = sizeof(ams::LogMsg);
            ams::LogMsg *ctype = new(ary_AllocN(buf, len).elems) ams::LogMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = LogMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::LogMsg case

        case ams_MsgHeaderMsgsCase_ams_MsgBlock: {
            // no cfmt read:Y found -- cannot read
        } break; // ams::MsgBlock case

        case ams_MsgHeaderMsgsCase_ams_ProcEofMsg: {
            int len = sizeof(ams::ProcEofMsg);
            ams::ProcEofMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcEofMsg; // default values
            ok = ProcEofMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ProcEofMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcKillMsg: {
            int len = sizeof(ams::ProcKillMsg);
            ams::ProcKillMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcKillMsg; // default values
            ok = ProcKillMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ProcKillMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcMsg: {
            int len = sizeof(ams::ProcMsg);
            ams::ProcMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = ProcMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::ProcMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcReadMsg: {
            int len = sizeof(ams::ProcReadMsg);
            ams::ProcReadMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcReadMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = ProcReadMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::ProcReadMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcStartMsg: {
            int len = sizeof(ams::ProcStartMsg);
            ams::ProcStartMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcStartMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = ProcStartMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::ProcStartMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcStatusMsg: {
            int len = sizeof(ams::ProcStatusMsg);
            ams::ProcStatusMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcStatusMsg; // default values
            ok = ProcStatusMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ProcStatusMsg case

        case ams_MsgHeaderMsgsCase_ams_RemDirRecurseMsg: {
            int len = sizeof(ams::RemDirRecurseMsg);
            ams::RemDirRecurseMsg *ctype = new(ary_AllocN(buf, len).elems) ams::RemDirRecurseMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = RemDirRecurseMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::RemDirRecurseMsg case

        case ams_MsgHeaderMsgsCase_ams_ShmHbMsg: {
            int len = sizeof(ams::ShmHbMsg);
            ams::ShmHbMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ShmHbMsg; // default values
            ok = ShmHbMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ShmHbMsg case

        case ams_MsgHeaderMsgsCase_ams_Shmmsg: {
            int len = sizeof(ams::Shmmsg);
            ams::Shmmsg *ctype = new(ary_AllocN(buf, len).elems) ams::Shmmsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Shmmsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::Shmmsg case

        case ams_MsgHeaderMsgsCase_ams_TerminateMsg: {
            int len = sizeof(ams::TerminateMsg);
            ams::TerminateMsg *ctype = new(ary_AllocN(buf, len).elems) ams::TerminateMsg; // default values
            ok = TerminateMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::TerminateMsg case

        case ams_MsgHeaderMsgsCase_ams_UdpFrame: {
            // no cfmt read:Y found -- cannot read
        } break; // ams::UdpFrame case

        case ams_MsgHeaderMsgsCase_fm_AlarmMsg: {
            int len = sizeof(fm::AlarmMsg);
            fm::AlarmMsg *ctype = new(ary_AllocN(buf, len).elems) fm::AlarmMsg; // default values
            ok = AlarmMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // fm::AlarmMsg case

        case ams_MsgHeaderMsgsCase_ws_CloseMsg: {
            int len = sizeof(ws::CloseMsg);
            ws::CloseMsg *ctype = new(ary_AllocN(buf, len).elems) ws::CloseMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = CloseMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::CloseMsg case

        case ams_MsgHeaderMsgsCase_ws_ConnectMsg: {
            int len = sizeof(ws::ConnectMsg);
            ws::ConnectMsg *ctype = new(ary_AllocN(buf, len).elems) ws::ConnectMsg; // default values
            ok = ConnectMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ws::ConnectMsg case

        case ams_MsgHeaderMsgsCase_ws_DataMsg: {
            int len = sizeof(ws::DataMsg);
            ws::DataMsg *ctype = new(ary_AllocN(buf, len).elems) ws::DataMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = DataMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ws::DataMsg case

        case ams_MsgHeaderMsgsCase_ws_ServerStartMsg: {
            int len = sizeof(ws::ServerStartMsg);
            ws::ServerStartMsg *ctype = new(ary_AllocN(buf, len).elems) ws::ServerStartMsg; // default values
            ok = ServerStartMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ws::ServerStartMsg case

        case ams_MsgHeaderMsgsCase_ws_ServerStopMsg: {
            int len = sizeof(ws::ServerStopMsg);
            ws::ServerStopMsg *ctype = new(ary_AllocN(buf, len).elems) ws::ServerStopMsg; // default values
            ok = ServerStopMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ws::ServerStopMsg case

        default: break;
    }
    return ok ? msgtype : ams::MsgHeaderMsgsCase();
}

// --- ams.MsgHeaderMsgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool ams::MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    ams::MsgHeaderMsgsCase msgtype = MsgHeaderMsgs_ReadStrptr(str,buf);
    return !(msgtype == ams::MsgHeaderMsgsCase());
}

// --- ams...LogMsg_FmtByteAry
// Construct a new ams::LogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::LogMsg * ams::LogMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc_id, algo::SchedTime tstamp, algo::aryptr<char > logcat, algo::aryptr<char > text) {
    ams::LogMsg  *msg = NULL;
    size_t len = sizeof(ams::LogMsg);
    u32 logcat_ary_len = elems_N(logcat) * sizeof(char);
    len += logcat_ary_len;
    u32 text_ary_len = elems_N(text) * sizeof(char);
    len += text_ary_len;
    ary_RemoveAll(buf);
    msg = (ams::LogMsg*)ary_AllocN(buf,len).elems;
    msg->type = u32(6);
    msg->length = u32(len + (0));
    msg->proc_id = proc_id;
    msg->tstamp = tstamp;
    memcpy(logcat_Addr(*msg), logcat.elems, logcat_ary_len);
    (*msg).logcat_end = u32(logcat_ary_len);
    memcpy(text_Addr(*msg), text.elems, text_ary_len);
    return msg;
}

// --- ams...MsgBlock_FmtByteAry
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::MsgBlock * ams::MsgBlock_FmtByteAry(algo::ByteAry &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages) {
    ams::MsgBlock  *msg = NULL;
    size_t len = sizeof(ams::MsgBlock);
    u32 messages_ary_len = elems_N(messages) * sizeof(u8);
    len += messages_ary_len;
    ary_RemoveAll(buf);
    msg = (ams::MsgBlock*)ary_AllocN(buf,len).elems;
    msg->type = u32(1);
    msg->length = u32(len + (0));
    msg->first_seqno = first_seqno;
    msg->n_messages = n_messages;
    msg->original_length = original_length;
    memcpy(messages_Addr(*msg), messages.elems, messages_ary_len);
    return msg;
}

// --- ams...MsgBlock_FmtMemptr
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
ams::MsgBlock * ams::MsgBlock_FmtMemptr(algo::memptr &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages) {
    ams::MsgBlock  *msg = NULL;
    size_t len = sizeof(ams::MsgBlock);
    u32 messages_ary_len = elems_N(messages) * sizeof(u8);
    len += messages_ary_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (ams::MsgBlock*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->type = u32(1);
    msg->length = u32(len + (0));
    msg->first_seqno = first_seqno;
    msg->n_messages = n_messages;
    msg->original_length = original_length;
    memcpy(messages_Addr(*msg), messages.elems, messages_ary_len);
    return msg;
}

// --- ams...UdpFrame_FmtByteAry
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::UdpFrame * ams::UdpFrame_FmtByteAry(algo::ByteAry &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload) {
    ams::UdpFrame  *msg = NULL;
    size_t len = sizeof(ams::UdpFrame);
    u32 payload_ary_len = elems_N(payload) * sizeof(u8);
    len += payload_ary_len;
    ary_RemoveAll(buf);
    msg = (ams::UdpFrame*)ary_AllocN(buf,len).elems;
    msg->type = u32(2);
    msg->length = u32(len + (0));
    msg->timestamp = timestamp;
    msg->src_ip = src_ip;
    msg->dst_ip = dst_ip;
    msg->src_port = src_port;
    msg->dst_port = dst_port;
    memcpy(payload_Addr(*msg), payload.elems, payload_ary_len);
    return msg;
}

// --- ams...UdpFrame_FmtMemptr
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
ams::UdpFrame * ams::UdpFrame_FmtMemptr(algo::memptr &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload) {
    ams::UdpFrame  *msg = NULL;
    size_t len = sizeof(ams::UdpFrame);
    u32 payload_ary_len = elems_N(payload) * sizeof(u8);
    len += payload_ary_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (ams::UdpFrame*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->type = u32(2);
    msg->length = u32(len + (0));
    msg->timestamp = timestamp;
    msg->src_ip = src_ip;
    msg->dst_ip = dst_ip;
    msg->src_port = src_port;
    msg->dst_port = dst_port;
    memcpy(payload_Addr(*msg), payload.elems, payload_ary_len);
    return msg;
}
