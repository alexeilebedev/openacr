//
// cpp/gen/ams_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/ams_gen.h"
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/ietf_gen.h"
#include "include/gen/ietf_gen.inl.h"
#include "include/gen/fm_gen.h"
#include "include/gen/fm_gen.inl.h"
//#pragma endinclude
namespace ams { // gen:ns_print_proto
    static bool          write_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          read_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          nonblock_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          trace_read_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          trace_write_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          write_err_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          trace_text_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- ams.AlarmSyncMsg..ReadFieldMaybe
bool ams::AlarmSyncMsg_ReadFieldMaybe(ams::AlarmSyncMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_updated_after: retval = algo::UnTime_ReadStrptrMaybe(parent.updated_after, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.AlarmSyncMsg..ReadStrptrMaybe
// Read fields of ams::AlarmSyncMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::AlarmSyncMsg_ReadStrptrMaybe(ams::AlarmSyncMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.AlarmSyncMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && AlarmSyncMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.AlarmSyncMsg..Print
// print string representation of ams::AlarmSyncMsg to string LHS, no header -- cprint:ams.AlarmSyncMsg.String
void ams::AlarmSyncMsg_Print(ams::AlarmSyncMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.AlarmSyncMsg";

    algo::UnTime_Print(row.updated_after, temp);
    PrintAttrSpaceReset(str,"updated_after", temp);
}

// --- ams.ProcType.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::ProcType& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_ProcType_0                : ret = "0";  break;
        case ams_ProcType_amstest          : ret = "amstest";  break;
    }
    return ret;
}

// --- ams.ProcType.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::ProcType& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.ProcType.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::ProcType& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case '0': {
                    value_SetEnum(parent,ams_ProcType_0); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','m','s','t','e','s','t'): {
                    value_SetEnum(parent,ams_ProcType_amstest); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.ProcType.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::ProcType& parent, algo::strptr rhs, ams_ProcTypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.ProcType.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::ProcType& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.ProcType..ReadStrptrMaybe
// Read fields of ams::ProcType from an ascii string.
// The format of the string is the format of the ams::ProcType's only field
bool ams::ProcType_ReadStrptrMaybe(ams::ProcType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.ProcType..Print
// print string representation of ams::ProcType to string LHS, no header -- cprint:ams.ProcType.String
void ams::ProcType_Print(ams::ProcType row, algo::cstring &str) {
    ams::value_Print(row, str);
}

// --- ams.ProcId..ReadFieldMaybe
bool ams::ProcId_ReadFieldMaybe(ams::ProcId &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_type: retval = ams::ProcType_ReadStrptrMaybe(parent.proc_type, strval); break;
        case ams_FieldId_procidx: retval = u8_ReadStrptrMaybe(parent.procidx, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcId..ReadStrptrMaybe
// Read fields of ams::ProcId from an ascii string.
// The format of the string is a string with separated values
bool ams::ProcId_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '-', value);
    retval = retval && ams::ProcType_ReadStrptrMaybe(parent.proc_type, value);

    value = in_str;
    retval = retval && u8_ReadStrptrMaybe(parent.procidx, value);
    return retval;
}

// --- ams.ProcId..Print
// print string representation of ams::ProcId to string LHS, no header -- cprint:ams.ProcId.String
void ams::ProcId_Print(ams::ProcId row, algo::cstring &str) {
    ams::ProcType_Print(row.proc_type, str);
    str << '-';
    u8_Print(row.procidx, str);
}

// --- ams.StreamType.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::StreamType& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_StreamType_0              : ret = "0";  break;
        case ams_StreamType_ctl            : ret = "ctl";  break;
        case ams_StreamType_io             : ret = "io";  break;
        case ams_StreamType_out            : ret = "out";  break;
        case ams_StreamType_trace          : ret = "trace";  break;
    }
    return ret;
}

// --- ams.StreamType.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::StreamType& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.StreamType.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::StreamType& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case '0': {
                    value_SetEnum(parent,ams_StreamType_0); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('i','o'): {
                    value_SetEnum(parent,ams_StreamType_io); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','t','l'): {
                    value_SetEnum(parent,ams_StreamType_ctl); ret = true; break;
                }
                case LE_STR3('o','u','t'): {
                    value_SetEnum(parent,ams_StreamType_out); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('t','r','a','c','e'): {
                    value_SetEnum(parent,ams_StreamType_trace); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.StreamType.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::StreamType& parent, algo::strptr rhs, ams_StreamTypeEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.StreamType.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::StreamType& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.StreamType..ReadStrptrMaybe
// Read fields of ams::StreamType from an ascii string.
// The format of the string is the format of the ams::StreamType's only field
bool ams::StreamType_ReadStrptrMaybe(ams::StreamType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.StreamType..Print
// print string representation of ams::StreamType to string LHS, no header -- cprint:ams.StreamType.String
void ams::StreamType_Print(ams::StreamType row, algo::cstring &str) {
    ams::value_Print(row, str);
}

// --- ams.StreamId..ReadFieldMaybe
bool ams::StreamId_ReadFieldMaybe(ams::StreamId &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        case ams_FieldId_stream_type: retval = ams::StreamType_ReadStrptrMaybe(parent.stream_type, strval); break;
        case ams_FieldId_streamidx: retval = u8_ReadStrptrMaybe(parent.streamidx, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.StreamId..ReadStrptrMaybe
// Read fields of ams::StreamId from an ascii string.
// The format of the string is a string with separated values
bool ams::StreamId_ReadStrptrMaybe(ams::StreamId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '.', value);
    retval = retval && ams::ProcId_ReadStrptrMaybe(parent.proc_id, value);

    algo::NextSep(in_str, '-', value);
    retval = retval && ams::StreamType_ReadStrptrMaybe(parent.stream_type, value);

    value = in_str;
    retval = retval && u8_ReadStrptrMaybe(parent.streamidx, value);
    return retval;
}

// --- ams.StreamId..Print
// print string representation of ams::StreamId to string LHS, no header -- cprint:ams.StreamId.String
void ams::StreamId_Print(ams::StreamId row, algo::cstring &str) {
    ams::ProcId_Print(row.proc_id, str);
    str << '.';
    ams::StreamType_Print(row.stream_type, str);
    str << '-';
    u8_Print(row.streamidx, str);
}

// --- ams.DfltStream..ReadFieldMaybe
bool ams::DfltStream_ReadFieldMaybe(ams::DfltStream &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_stream_id: retval = ams::StreamId_ReadStrptrMaybe(parent.stream_id, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.DfltStream..ReadStrptrMaybe
// Read fields of ams::DfltStream from an ascii string.
// The format of the string is an ssim Tuple
bool ams::DfltStream_ReadStrptrMaybe(ams::DfltStream &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.DfltStream");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DfltStream_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.DfltStream..Print
// print string representation of ams::DfltStream to string LHS, no header -- cprint:ams.DfltStream.String
void ams::DfltStream_Print(ams::DfltStream & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.DfltStream";

    ams::StreamId_Print(row.stream_id, temp);
    PrintAttrSpaceReset(str,"stream_id", temp);
}

// --- ams.DumpStreamTableMsg..ReadFieldMaybe
bool ams::DumpStreamTableMsg_ReadFieldMaybe(ams::DumpStreamTableMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.DumpStreamTableMsg..ReadStrptrMaybe
// Read fields of ams::DumpStreamTableMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::DumpStreamTableMsg_ReadStrptrMaybe(ams::DumpStreamTableMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.DumpStreamTableMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && DumpStreamTableMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.DumpStreamTableMsg..Print
// print string representation of ams::DumpStreamTableMsg to string LHS, no header -- cprint:ams.DumpStreamTableMsg.String
void ams::DumpStreamTableMsg_Print(ams::DumpStreamTableMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.DumpStreamTableMsg";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);
}

// --- ams.ExpectMsg.text.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::text_Getary(ams::ExpectMsg& parent) {
    return algo::aryptr<char>(text_Addr(parent), text_N(parent));
}

// --- ams.ExpectMsg.text.Addr
char* ams::text_Addr(ams::ExpectMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::ExpectMsg)); // address of varlen portion
}

// --- ams.ExpectMsg.text.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::text_ReadStrptrMaybe(ams::ExpectMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.ExpectMsg..ReadFieldMaybe
bool ams::ExpectMsg_ReadFieldMaybe(ams::ExpectMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_text: retval = text_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ExpectMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ExpectMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ExpectMsg_ReadStrptrMaybe(ams::ExpectMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ExpectMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ExpectMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ExpectMsg..Print
// print string representation of ams::ExpectMsg to string LHS, no header -- cprint:ams.ExpectMsg.String
void ams::ExpectMsg_Print(ams::ExpectMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.ExpectMsg";

    algo::aryptr<char> text_ary = text_Getary(row);
    PrintAttrSpace(str, "text", text_ary); // print field ams.ExpectMsg.text
}

// --- ams.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_FieldId_base              : ret = "base";  break;
        case ams_FieldId_type              : ret = "type";  break;
        case ams_FieldId_length            : ret = "length";  break;
        case ams_FieldId_updated_after     : ret = "updated_after";  break;
        case ams_FieldId_stream_id         : ret = "stream_id";  break;
        case ams_FieldId_proc_id           : ret = "proc_id";  break;
        case ams_FieldId_text              : ret = "text";  break;
        case ams_FieldId_time              : ret = "time";  break;
        case ams_FieldId_payload           : ret = "payload";  break;
        case ams_FieldId_logcat            : ret = "logcat";  break;
        case ams_FieldId_tstamp            : ret = "tstamp";  break;
        case ams_FieldId_mode              : ret = "mode";  break;
        case ams_FieldId_member            : ret = "member";  break;
        case ams_FieldId_pos               : ret = "pos";  break;
        case ams_FieldId_data              : ret = "data";  break;
        case ams_FieldId_proc_type         : ret = "proc_type";  break;
        case ams_FieldId_procidx           : ret = "procidx";  break;
        case ams_FieldId_value             : ret = "value";  break;
        case ams_FieldId_seqmsg_id         : ret = "seqmsg_id";  break;
        case ams_FieldId_tsc               : ret = "tsc";  break;
        case ams_FieldId_seq               : ret = "seq";  break;
        case ams_FieldId_off               : ret = "off";  break;
        case ams_FieldId_write             : ret = "write";  break;
        case ams_FieldId_read              : ret = "read";  break;
        case ams_FieldId_nonblock          : ret = "nonblock";  break;
        case ams_FieldId_trace_read        : ret = "trace_read";  break;
        case ams_FieldId_trace_write       : ret = "trace_write";  break;
        case ams_FieldId_write_err         : ret = "write_err";  break;
        case ams_FieldId_trace_text        : ret = "trace_text";  break;
        case ams_FieldId_wbudget           : ret = "wbudget";  break;
        case ams_FieldId_stream_type       : ret = "stream_type";  break;
        case ams_FieldId_streamidx         : ret = "streamidx";  break;
        case ams_FieldId_proc              : ret = "proc";  break;
        case ams_FieldId_trace             : ret = "trace";  break;
        case ams_FieldId_part              : ret = "part";  break;
    }
    return ret;
}

// --- ams.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('o','f','f'): {
                    value_SetEnum(parent,ams_FieldId_off); ret = true; break;
                }
                case LE_STR3('p','o','s'): {
                    value_SetEnum(parent,ams_FieldId_pos); ret = true; break;
                }
                case LE_STR3('s','e','q'): {
                    value_SetEnum(parent,ams_FieldId_seq); ret = true; break;
                }
                case LE_STR3('t','s','c'): {
                    value_SetEnum(parent,ams_FieldId_tsc); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','a','s','e'): {
                    value_SetEnum(parent,ams_FieldId_base); ret = true; break;
                }
                case LE_STR4('d','a','t','a'): {
                    value_SetEnum(parent,ams_FieldId_data); ret = true; break;
                }
                case LE_STR4('m','o','d','e'): {
                    value_SetEnum(parent,ams_FieldId_mode); ret = true; break;
                }
                case LE_STR4('p','a','r','t'): {
                    value_SetEnum(parent,ams_FieldId_part); ret = true; break;
                }
                case LE_STR4('p','r','o','c'): {
                    value_SetEnum(parent,ams_FieldId_proc); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,ams_FieldId_read); ret = true; break;
                }
                case LE_STR4('t','e','x','t'): {
                    value_SetEnum(parent,ams_FieldId_text); ret = true; break;
                }
                case LE_STR4('t','i','m','e'): {
                    value_SetEnum(parent,ams_FieldId_time); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,ams_FieldId_type); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('t','r','a','c','e'): {
                    value_SetEnum(parent,ams_FieldId_trace); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,ams_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,ams_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('l','e','n','g','t','h'): {
                    value_SetEnum(parent,ams_FieldId_length); ret = true; break;
                }
                case LE_STR6('l','o','g','c','a','t'): {
                    value_SetEnum(parent,ams_FieldId_logcat); ret = true; break;
                }
                case LE_STR6('m','e','m','b','e','r'): {
                    value_SetEnum(parent,ams_FieldId_member); ret = true; break;
                }
                case LE_STR6('t','s','t','a','m','p'): {
                    value_SetEnum(parent,ams_FieldId_tstamp); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('p','a','y','l','o','a','d'): {
                    value_SetEnum(parent,ams_FieldId_payload); ret = true; break;
                }
                case LE_STR7('p','r','o','c','_','i','d'): {
                    value_SetEnum(parent,ams_FieldId_proc_id); ret = true; break;
                }
                case LE_STR7('p','r','o','c','i','d','x'): {
                    value_SetEnum(parent,ams_FieldId_procidx); ret = true; break;
                }
                case LE_STR7('w','b','u','d','g','e','t'): {
                    value_SetEnum(parent,ams_FieldId_wbudget); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('n','o','n','b','l','o','c','k'): {
                    value_SetEnum(parent,ams_FieldId_nonblock); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','r','o','c','_','t','y','p'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,ams_FieldId_proc_type); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','q','m','s','g','_','i'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,ams_FieldId_seqmsg_id); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','e','a','m','_','i'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,ams_FieldId_stream_id); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','e','a','m','i','d'): {
                    if (memcmp(rhs.elems+8,"x",1)==0) { value_SetEnum(parent,ams_FieldId_streamidx); ret = true; break; }
                    break;
                }
                case LE_STR8('w','r','i','t','e','_','e','r'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,ams_FieldId_write_err); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('t','r','a','c','e','_','r','e'): {
                    if (memcmp(rhs.elems+8,"ad",2)==0) { value_SetEnum(parent,ams_FieldId_trace_read); ret = true; break; }
                    break;
                }
                case LE_STR8('t','r','a','c','e','_','t','e'): {
                    if (memcmp(rhs.elems+8,"xt",2)==0) { value_SetEnum(parent,ams_FieldId_trace_text); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','r','e','a','m','_','t'): {
                    if (memcmp(rhs.elems+8,"ype",3)==0) { value_SetEnum(parent,ams_FieldId_stream_type); ret = true; break; }
                    break;
                }
                case LE_STR8('t','r','a','c','e','_','w','r'): {
                    if (memcmp(rhs.elems+8,"ite",3)==0) { value_SetEnum(parent,ams_FieldId_trace_write); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('u','p','d','a','t','e','d','_'): {
                    if (memcmp(rhs.elems+8,"after",5)==0) { value_SetEnum(parent,ams_FieldId_updated_after); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::FieldId& parent, algo::strptr rhs, ams_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.FieldId..ReadStrptrMaybe
// Read fields of ams::FieldId from an ascii string.
// The format of the string is the format of the ams::FieldId's only field
bool ams::FieldId_ReadStrptrMaybe(ams::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.FieldId..Print
// print string representation of ams::FieldId to string LHS, no header -- cprint:ams.FieldId.String
void ams::FieldId_Print(ams::FieldId & row, algo::cstring &str) {
    ams::value_Print(row, str);
}

// --- ams.HeartbeatMsg..ReadFieldMaybe
bool ams::HeartbeatMsg_ReadFieldMaybe(ams::HeartbeatMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_time: retval = algo::UnTime_ReadStrptrMaybe(parent.time, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.HeartbeatMsg..ReadStrptrMaybe
// Read fields of ams::HeartbeatMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::HeartbeatMsg_ReadStrptrMaybe(ams::HeartbeatMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.HeartbeatMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && HeartbeatMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.HeartbeatMsg..Print
// print string representation of ams::HeartbeatMsg to string LHS, no header -- cprint:ams.HeartbeatMsg.String
void ams::HeartbeatMsg_Print(ams::HeartbeatMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.HeartbeatMsg";

    algo::UnTime_Print(row.time, temp);
    PrintAttrSpaceReset(str,"time", temp);
}

// --- ams.InputLineMsg.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::payload_Getary(ams::InputLineMsg& parent) {
    return algo::aryptr<char>(payload_Addr(parent), payload_N(parent));
}

// --- ams.InputLineMsg.payload.Addr
char* ams::payload_Addr(ams::InputLineMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::InputLineMsg)); // address of varlen portion
}

// --- ams.InputLineMsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::InputLineMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.InputLineMsg..ReadFieldMaybe
bool ams::InputLineMsg_ReadFieldMaybe(ams::InputLineMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_payload: retval = payload_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.InputLineMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::InputLineMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::InputLineMsg_ReadStrptrMaybe(ams::InputLineMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.InputLineMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && InputLineMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.InputLineMsg..Print
// print string representation of ams::InputLineMsg to string LHS, no header -- cprint:ams.InputLineMsg.String
void ams::InputLineMsg_Print(ams::InputLineMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.InputLineMsg";

    algo::aryptr<char> payload_ary = payload_Getary(row);
    PrintAttrSpace(str, "payload", payload_ary); // print field ams.InputLineMsg.payload
}

// --- ams.LogMsg.text.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::text_Getary(ams::LogMsg& parent) {
    return algo::aryptr<char>(text_Addr(parent), text_N(parent));
}

// --- ams.LogMsg.text.Addr
char* ams::text_Addr(ams::LogMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::LogMsg)); // address of varlen portion
}

// --- ams.LogMsg.text.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::text_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.LogMsg..ReadFieldMaybe
bool ams::LogMsg_ReadFieldMaybe(ams::LogMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_logcat: retval = algo::RnullStr50_ReadStrptrMaybe(parent.logcat, strval); break;
        case ams_FieldId_tstamp: retval = algo::SchedTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_text: retval = text_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.LogMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::LogMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::LogMsg_ReadStrptrMaybe(ams::LogMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.LogMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && LogMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.LogMsg..Print
// print string representation of ams::LogMsg to string LHS, no header -- cprint:ams.LogMsg.String
void ams::LogMsg_Print(ams::LogMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.LogMsg";

    algo::RnullStr50_Print(row.logcat, temp);
    PrintAttrSpaceReset(str,"logcat", temp);

    algo::SchedTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    algo::aryptr<char> text_ary = text_Getary(row);
    PrintAttrSpace(str, "text", text_ary); // print field ams.LogMsg.text
}

// --- ams.Member.mode.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::mode_ToCstr(const ams::Member& parent) {
    const char *ret = NULL;
    switch(mode_GetEnum(parent)) {
        case ams_Member_mode_r             : ret = "r";  break;
        case ams_Member_mode_w             : ret = "w";  break;
    }
    return ret;
}

// --- ams.Member.mode.Print
// Convert mode to a string. First, attempt conversion to a known string.
// If no string matches, print mode as a numeric value.
void ams::mode_Print(const ams::Member& parent, algo::cstring &lhs) {
    const char *strval = mode_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.mode;
    }
}

// --- ams.Member.mode.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::mode_SetStrptrMaybe(ams::Member& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'r': {
                    mode_SetEnum(parent,ams_Member_mode_r); ret = true; break;
                }
                case 'w': {
                    mode_SetEnum(parent,ams_Member_mode_w); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.Member.mode.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::mode_SetStrptr(ams::Member& parent, algo::strptr rhs, ams_Member_mode_Enum dflt) {
    if (!mode_SetStrptrMaybe(parent,rhs)) mode_SetEnum(parent,dflt);
}

// --- ams.Member.mode.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::mode_ReadStrptrMaybe(ams::Member& parent, algo::strptr rhs) {
    bool retval = false;
    retval = mode_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.mode,rhs);
    }
    return retval;
}

// --- ams.Member..ReadFieldMaybe
bool ams::Member_ReadFieldMaybe(ams::Member &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        case ams_FieldId_stream_id: retval = ams::StreamId_ReadStrptrMaybe(parent.stream_id, strval); break;
        case ams_FieldId_mode: retval = mode_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.Member..ReadStrptrMaybe
// Read fields of ams::Member from an ascii string.
// The format of the string is a string with separated values
bool ams::Member_ReadStrptrMaybe(ams::Member &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '/', value);
    retval = retval && ams::ProcId_ReadStrptrMaybe(parent.proc_id, value);

    algo::NextSep(in_str, ',', value);
    retval = retval && ams::StreamId_ReadStrptrMaybe(parent.stream_id, value);

    value = in_str;
    retval = retval && mode_ReadStrptrMaybe(parent, value);
    return retval;
}

// --- ams.Member..Print
// print string representation of ams::Member to string LHS, no header -- cprint:ams.Member.String
void ams::Member_Print(ams::Member row, algo::cstring &str) {
    ams::ProcId_Print(row.proc_id, str);
    str << '/';
    ams::StreamId_Print(row.stream_id, str);
    str << ',';
    ams::mode_Print(row, str);
}

// --- ams.MsgBlock.messages.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> ams::messages_Getary(ams::MsgBlock& parent) {
    return algo::aryptr<u8>(messages_Addr(parent), messages_N(parent));
}

// --- ams.MsgBlock.messages.Addr
u8* ams::messages_Addr(ams::MsgBlock& parent) {
    return (u8*)((u8*)&parent + sizeof(ams::MsgBlock)); // address of varlen portion
}

// --- ams.MsgBlock..Print
// print string representation of ams::MsgBlock to string LHS, no header -- cprint:ams.MsgBlock.String
void ams::MsgBlock_Print(ams::MsgBlock & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.MsgBlock";

    u64_Print(row.first_seqno, temp);
    PrintAttrSpaceReset(str,"first_seqno", temp);

    u32_Print(row.n_messages, temp);
    PrintAttrSpaceReset(str,"n_messages", temp);

    u32_Print(row.original_length, temp);
    PrintAttrSpaceReset(str,"original_length", temp);

    algo::aryptr<u8> messages_ary = messages_Getary(row);
    PrintAttrSpace(str, "messages", algo::strptr((char*)messages_ary.elems, messages_ary.n_elems)); // print field ams.MsgBlock.messages
}

// --- ams.MsgHeader.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::type_ToCstr(const ams::MsgHeader& data) {
    const char *ret = NULL;
    switch(type_GetEnum(data)) {
        case ams_MsgHeader_type_ams_AlarmSyncMsg: ret = "ams.AlarmSyncMsg";  break;
        case ams_MsgHeader_type_ams_DfltStream: ret = "ams.DfltStream";  break;
        case ams_MsgHeader_type_ams_DumpStreamTableMsg: ret = "ams.DumpStreamTableMsg";  break;
        case ams_MsgHeader_type_ams_ExpectMsg: ret = "ams.ExpectMsg";  break;
        case ams_MsgHeader_type_ams_HeartbeatMsg: ret = "ams.HeartbeatMsg";  break;
        case ams_MsgHeader_type_ams_InputLineMsg: ret = "ams.InputLineMsg";  break;
        case ams_MsgHeader_type_ams_LogMsg : ret = "ams.LogMsg";  break;
        case ams_MsgHeader_type_ams_MsgBlock: ret = "ams.MsgBlock";  break;
        case ams_MsgHeader_type_ams_OpenMsg: ret = "ams.OpenMsg";  break;
        case ams_MsgHeader_type_ams_PrlogMsg: ret = "ams.PrlogMsg";  break;
        case ams_MsgHeader_type_ams_ProcAddMsg: ret = "ams.ProcAddMsg";  break;
        case ams_MsgHeader_type_ams_ProcRemoveMsg: ret = "ams.ProcRemoveMsg";  break;
        case ams_MsgHeader_type_ams_Seqmsg : ret = "ams.Seqmsg";  break;
        case ams_MsgHeader_type_ams_SeqmsgTrace: ret = "ams.SeqmsgTrace";  break;
        case ams_MsgHeader_type_ams_StreamHbMsg: ret = "ams.StreamHbMsg";  break;
        case ams_MsgHeader_type_ams_TerminateMsg: ret = "ams.TerminateMsg";  break;
        case ams_MsgHeader_type_ams_Trace2Msg: ret = "ams.Trace2Msg";  break;
        case ams_MsgHeader_type_ams_TraceInfo2Msg: ret = "ams.TraceInfo2Msg";  break;
        case ams_MsgHeader_type_ams_TraceInfoMsg: ret = "ams.TraceInfoMsg";  break;
        case ams_MsgHeader_type_ams_TraceMsg: ret = "ams.TraceMsg";  break;
        case ams_MsgHeader_type_ams_UdpFrame: ret = "ams.UdpFrame";  break;
        case ams_MsgHeader_type_fm_AlarmMsg: ret = "fm.AlarmMsg";  break;
    }
    return ret;
}

// --- ams.MsgHeader.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void ams::type_Print(const ams::MsgHeader& data, algo::cstring &lhs) {
    const char *strval = type_ToCstr(data);
    if (strval) {
        lhs << strval;
    } else {
        lhs << data.type;
    }
}

// --- ams.MsgHeader.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::type_SetStrptrMaybe(ams::MsgHeader& data, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','L','o','g','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_LogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','e','q','m'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_Seqmsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','O','p','e','n'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_OpenMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('f','m','.','A','l','a','r','m'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { type_SetEnum(data,ams_MsgHeader_type_fm_AlarmMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','M','s','g','B'): {
                    if (memcmp(rhs.elems+8,"lock",4)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_MsgBlock); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','l','o'): {
                    if (memcmp(rhs.elems+8,"gMsg",4)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_PrlogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eMsg",4)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_TraceMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','U','d','p','F'): {
                    if (memcmp(rhs.elems+8,"rame",4)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_UdpFrame); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','E','x','p','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_ExpectMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"e2Msg",5)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_Trace2Msg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','D','f','l','t'): {
                    if (memcmp(rhs.elems+8,"Stream",6)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_DfltStream); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"AddMsg",6)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_ProcAddMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','S','e','q','m'): {
                    if (memcmp(rhs.elems+8,"sgTrace",7)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_SeqmsgTrace); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','t','r','e'): {
                    if (memcmp(rhs.elems+8,"amHbMsg",7)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_StreamHbMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','A','l','a','r'): {
                    if (memcmp(rhs.elems+8,"mSyncMsg",8)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_AlarmSyncMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','H','e','a','r'): {
                    if (memcmp(rhs.elems+8,"tbeatMsg",8)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_HeartbeatMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','I','n','p','u'): {
                    if (memcmp(rhs.elems+8,"tLineMsg",8)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_InputLineMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','e','r','m'): {
                    if (memcmp(rhs.elems+8,"inateMsg",8)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_TerminateMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eInfoMsg",8)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_TraceInfoMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"RemoveMsg",9)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_ProcRemoveMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eInfo2Msg",9)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_TraceInfo2Msg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 22: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','D','u','m','p'): {
                    if (memcmp(rhs.elems+8,"StreamTableMsg",14)==0) { type_SetEnum(data,ams_MsgHeader_type_ams_DumpStreamTableMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.MsgHeader.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::type_SetStrptr(ams::MsgHeader& data, algo::strptr rhs, ams_MsgHeader_type_Enum dflt) {
    if (!type_SetStrptrMaybe(data,rhs)) type_SetEnum(data,dflt);
}

// --- ams.MsgHeader.type.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::type_ReadStrptrMaybe(ams::MsgHeader& data, algo::strptr rhs) {
    bool retval = false;
    retval = type_SetStrptrMaybe(data,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(data.type,rhs);
    }
    return retval;
}

// --- ams.MsgHeader..ReadFieldMaybe
bool ams::MsgHeader_ReadFieldMaybe(ams::MsgHeader &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_type: retval = type_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.MsgHeader..ReadStrptrMaybe
// Read fields of ams::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
bool ams::MsgHeader_ReadStrptrMaybe(ams::MsgHeader &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.MsgHeader");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && MsgHeader_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.MsgHeader..Print
// print string representation of ams::MsgHeader to string LHS, no header -- cprint:ams.MsgHeader.String
void ams::MsgHeader_Print(ams::MsgHeader & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.MsgHeader";
    (void)row;//only to avoid -Wunused-parameter
}

// --- ams.MsgHeaderMsgsCase.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::value_ToCstr(const ams::MsgHeaderMsgsCase& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ams_MsgHeaderMsgsCase_ams_AlarmSyncMsg: ret = "ams.AlarmSyncMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_DfltStream: ret = "ams.DfltStream";  break;
        case ams_MsgHeaderMsgsCase_ams_DumpStreamTableMsg: ret = "ams.DumpStreamTableMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ExpectMsg: ret = "ams.ExpectMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_HeartbeatMsg: ret = "ams.HeartbeatMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_InputLineMsg: ret = "ams.InputLineMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_LogMsg: ret = "ams.LogMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_MsgBlock: ret = "ams.MsgBlock";  break;
        case ams_MsgHeaderMsgsCase_ams_OpenMsg: ret = "ams.OpenMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_PrlogMsg: ret = "ams.PrlogMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcAddMsg: ret = "ams.ProcAddMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_ProcRemoveMsg: ret = "ams.ProcRemoveMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_Seqmsg: ret = "ams.Seqmsg";  break;
        case ams_MsgHeaderMsgsCase_ams_SeqmsgTrace: ret = "ams.SeqmsgTrace";  break;
        case ams_MsgHeaderMsgsCase_ams_StreamHbMsg: ret = "ams.StreamHbMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_TerminateMsg: ret = "ams.TerminateMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_Trace2Msg: ret = "ams.Trace2Msg";  break;
        case ams_MsgHeaderMsgsCase_ams_TraceInfo2Msg: ret = "ams.TraceInfo2Msg";  break;
        case ams_MsgHeaderMsgsCase_ams_TraceInfoMsg: ret = "ams.TraceInfoMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_TraceMsg: ret = "ams.TraceMsg";  break;
        case ams_MsgHeaderMsgsCase_ams_UdpFrame: ret = "ams.UdpFrame";  break;
        case ams_MsgHeaderMsgsCase_fm_AlarmMsg: ret = "fm.AlarmMsg";  break;
    }
    return ret;
}

// --- ams.MsgHeaderMsgsCase.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ams::value_Print(const ams::MsgHeaderMsgsCase& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ams.MsgHeaderMsgsCase.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::value_SetStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','L','o','g','M'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_LogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','e','q','m'): {
                    if (memcmp(rhs.elems+8,"sg",2)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_Seqmsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','O','p','e','n'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_OpenMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('f','m','.','A','l','a','r','m'): {
                    if (memcmp(rhs.elems+8,"Msg",3)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_fm_AlarmMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','M','s','g','B'): {
                    if (memcmp(rhs.elems+8,"lock",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_MsgBlock); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','l','o'): {
                    if (memcmp(rhs.elems+8,"gMsg",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_PrlogMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eMsg",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_TraceMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','U','d','p','F'): {
                    if (memcmp(rhs.elems+8,"rame",4)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_UdpFrame); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','E','x','p','e'): {
                    if (memcmp(rhs.elems+8,"ctMsg",5)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ExpectMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"e2Msg",5)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_Trace2Msg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','D','f','l','t'): {
                    if (memcmp(rhs.elems+8,"Stream",6)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_DfltStream); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"AddMsg",6)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcAddMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','S','e','q','m'): {
                    if (memcmp(rhs.elems+8,"sgTrace",7)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_SeqmsgTrace); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','S','t','r','e'): {
                    if (memcmp(rhs.elems+8,"amHbMsg",7)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_StreamHbMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','A','l','a','r'): {
                    if (memcmp(rhs.elems+8,"mSyncMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_AlarmSyncMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','H','e','a','r'): {
                    if (memcmp(rhs.elems+8,"tbeatMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_HeartbeatMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','I','n','p','u'): {
                    if (memcmp(rhs.elems+8,"tLineMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_InputLineMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','e','r','m'): {
                    if (memcmp(rhs.elems+8,"inateMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_TerminateMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eInfoMsg",8)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_TraceInfoMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','P','r','o','c'): {
                    if (memcmp(rhs.elems+8,"RemoveMsg",9)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_ProcRemoveMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','s','.','T','r','a','c'): {
                    if (memcmp(rhs.elems+8,"eInfo2Msg",9)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_TraceInfo2Msg); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 22: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','s','.','D','u','m','p'): {
                    if (memcmp(rhs.elems+8,"StreamTableMsg",14)==0) { value_SetEnum(parent,ams_MsgHeaderMsgsCase_ams_DumpStreamTableMsg); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.MsgHeaderMsgsCase.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::value_SetStrptr(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs, ams_MsgHeaderMsgsCaseEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ams.MsgHeaderMsgsCase.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::value_ReadStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ams.MsgHeaderMsgsCase..ReadStrptrMaybe
// Read fields of ams::MsgHeaderMsgsCase from an ascii string.
// The format of the string is the format of the ams::MsgHeaderMsgsCase's only field
bool ams::MsgHeaderMsgsCase_ReadStrptrMaybe(ams::MsgHeaderMsgsCase &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ams::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ams.StreamPos..ReadFieldMaybe
bool ams::StreamPos_ReadFieldMaybe(ams::StreamPos &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_seq: retval = u64_ReadStrptrMaybe(parent.seq, strval); break;
        case ams_FieldId_off: retval = u64_ReadStrptrMaybe(parent.off, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.StreamPos..ReadStrptrMaybe
// Read fields of ams::StreamPos from an ascii string.
// The format of the string is a string with separated values
bool ams::StreamPos_ReadStrptrMaybe(ams::StreamPos &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, ',', value);
    retval = retval && u64_ReadStrptrMaybe(parent.seq, value);

    value = in_str;
    retval = retval && u64_ReadStrptrMaybe(parent.off, value);
    return retval;
}

// --- ams.StreamPos..Print
// print string representation of ams::StreamPos to string LHS, no header -- cprint:ams.StreamPos.String
void ams::StreamPos_Print(ams::StreamPos row, algo::cstring &str) {
    u64_Print(row.seq, str);
    str << ',';
    u64_Print(row.off, str);
}

// --- ams.OpenMsg..ReadFieldMaybe
bool ams::OpenMsg_ReadFieldMaybe(ams::OpenMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_member: retval = ams::Member_ReadStrptrMaybe(parent.member, strval); break;
        case ams_FieldId_pos: retval = ams::StreamPos_ReadStrptrMaybe(parent.pos, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.OpenMsg..ReadStrptrMaybe
// Read fields of ams::OpenMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::OpenMsg_ReadStrptrMaybe(ams::OpenMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.OpenMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OpenMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.OpenMsg..Print
// print string representation of ams::OpenMsg to string LHS, no header -- cprint:ams.OpenMsg.String
void ams::OpenMsg_Print(ams::OpenMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.OpenMsg";

    ams::Member_Print(row.member, temp);
    PrintAttrSpaceReset(str,"member", temp);

    ams::StreamPos_Print(row.pos, temp);
    PrintAttrSpaceReset(str,"pos", temp);
}

// --- ams.PrlogMsg.data.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> ams::data_Getary(ams::PrlogMsg& parent) {
    u8 *end = (u8*)&parent + sizeof(ams::PrlogMsg);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(ams::PrlogMsg));
}

// --- ams.PrlogMsg.data.Print
void ams::data_Print(ams::PrlogMsg& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (ams::MsgHeader *data = data_Get(parent)) {
        ams::MsgHeaderMsgs_Print(out, *data, INT_MAX);
    }
}

// --- ams.PrlogMsg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::data_ReadStrptrMaybe(ams::PrlogMsg &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = ams::MsgHeaderMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.PrlogMsg..ReadFieldMaybe
bool ams::PrlogMsg_ReadFieldMaybe(ams::PrlogMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_logcat: retval = algo::RnullStr50_ReadStrptrMaybe(parent.logcat, strval); break;
        case ams_FieldId_tstamp: retval = algo::SchedTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_data: retval = data_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.PrlogMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::PrlogMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::PrlogMsg_ReadStrptrMaybe(ams::PrlogMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.PrlogMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && PrlogMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.PrlogMsg..Print
// print string representation of ams::PrlogMsg to string LHS, no header -- cprint:ams.PrlogMsg.String
void ams::PrlogMsg_Print(ams::PrlogMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.PrlogMsg";

    algo::RnullStr50_Print(row.logcat, temp);
    PrintAttrSpaceReset(str,"logcat", temp);

    algo::SchedTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    if (data_Get(row) != NULL) {
        ams::data_Print(row, temp);
        PrintAttrSpaceReset(str,"data", temp);
    }
}

// --- ams.ProcAddMsg..ReadFieldMaybe
bool ams::ProcAddMsg_ReadFieldMaybe(ams::ProcAddMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcAddMsg..ReadStrptrMaybe
// Read fields of ams::ProcAddMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcAddMsg_ReadStrptrMaybe(ams::ProcAddMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcAddMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcAddMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcAddMsg..Print
// print string representation of ams::ProcAddMsg to string LHS, no header -- cprint:ams.ProcAddMsg.String
void ams::ProcAddMsg_Print(ams::ProcAddMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.ProcAddMsg";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);
}

// --- ams.ProcRemoveMsg..ReadFieldMaybe
bool ams::ProcRemoveMsg_ReadFieldMaybe(ams::ProcRemoveMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.ProcRemoveMsg..ReadStrptrMaybe
// Read fields of ams::ProcRemoveMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::ProcRemoveMsg_ReadStrptrMaybe(ams::ProcRemoveMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.ProcRemoveMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ProcRemoveMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.ProcRemoveMsg..Print
// print string representation of ams::ProcRemoveMsg to string LHS, no header -- cprint:ams.ProcRemoveMsg.String
void ams::ProcRemoveMsg_Print(ams::ProcRemoveMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.ProcRemoveMsg";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);
}

// --- ams.Protocol.proto.StaticCheck
void ams::StaticCheck() {
    algo_assert(_offset_of(ams::AlarmSyncMsg, updated_after) + sizeof(((ams::AlarmSyncMsg*)0)->updated_after) == sizeof(ams::AlarmSyncMsg));
    algo_assert(_offset_of(ams::ProcType, value) + sizeof(((ams::ProcType*)0)->value) == sizeof(ams::ProcType));
    algo_assert(_offset_of(ams::ProcId, procidx) + sizeof(((ams::ProcId*)0)->procidx) == sizeof(ams::ProcId));
    algo_assert(_offset_of(ams::StreamType, value) + sizeof(((ams::StreamType*)0)->value) == sizeof(ams::StreamType));
    algo_assert(_offset_of(ams::StreamId, streamidx) + sizeof(((ams::StreamId*)0)->streamidx) == sizeof(ams::StreamId));
    algo_assert(_offset_of(ams::DfltStream, stream_id) + sizeof(((ams::DfltStream*)0)->stream_id) == sizeof(ams::DfltStream));
    algo_assert(_offset_of(ams::DumpStreamTableMsg, proc_id) + sizeof(((ams::DumpStreamTableMsg*)0)->proc_id) == sizeof(ams::DumpStreamTableMsg));
    algo_assert(_offset_of(ams::FieldId, value) + sizeof(((ams::FieldId*)0)->value) == sizeof(ams::FieldId));
    algo_assert(_offset_of(ams::HeartbeatMsg, time) + sizeof(((ams::HeartbeatMsg*)0)->time) == sizeof(ams::HeartbeatMsg));
    algo_assert(_offset_of(ams::Member, mode) + sizeof(((ams::Member*)0)->mode) == sizeof(ams::Member));
    algo_assert(_offset_of(ams::MsgHeaderMsgsCase, value) + sizeof(((ams::MsgHeaderMsgsCase*)0)->value) == sizeof(ams::MsgHeaderMsgsCase));
    algo_assert(_offset_of(ams::MsgHeader_curs, msglen) + sizeof(((ams::MsgHeader_curs*)0)->msglen) == sizeof(ams::MsgHeader_curs));
    algo_assert(_offset_of(ams::StreamPos, off) + sizeof(((ams::StreamPos*)0)->off) == sizeof(ams::StreamPos));
    algo_assert(_offset_of(ams::OpenMsg, pos) + sizeof(((ams::OpenMsg*)0)->pos) == sizeof(ams::OpenMsg));
    algo_assert(_offset_of(ams::ProcAddMsg, proc_id) + sizeof(((ams::ProcAddMsg*)0)->proc_id) == sizeof(ams::ProcAddMsg));
    algo_assert(_offset_of(ams::ProcRemoveMsg, proc_id) + sizeof(((ams::ProcRemoveMsg*)0)->proc_id) == sizeof(ams::ProcRemoveMsg));
    algo_assert(_offset_of(ams::SeqmsgId, off) + sizeof(((ams::SeqmsgId*)0)->off) == sizeof(ams::SeqmsgId));
    // check that bitfield fits width
    algo_assert(sizeof(((ams::StreamFlags*)0)->value)*8 >= 8);
    algo_assert(_offset_of(ams::StreamFlags, value) + sizeof(((ams::StreamFlags*)0)->value) == sizeof(ams::StreamFlags));
    algo_assert(_offset_of(ams::StreamHbMsg, wbudget) + sizeof(((ams::StreamHbMsg*)0)->wbudget) == sizeof(ams::StreamHbMsg));
    algo_assert(_offset_of(ams::TerminateMsg, length) + sizeof(((ams::TerminateMsg*)0)->length) == sizeof(ams::TerminateMsg));
}

// --- ams.SeqmsgId..ReadFieldMaybe
bool ams::SeqmsgId_ReadFieldMaybe(ams::SeqmsgId &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_stream_id: retval = ams::StreamId_ReadStrptrMaybe(parent.stream_id, strval); break;
        case ams_FieldId_seq: retval = u64_ReadStrptrMaybe(parent.seq, strval); break;
        case ams_FieldId_off: retval = u32_ReadStrptrMaybe(parent.off, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.SeqmsgId..ReadStrptrMaybe
// Read fields of ams::SeqmsgId from an ascii string.
// The format of the string is a string with separated values
bool ams::SeqmsgId_ReadStrptrMaybe(ams::SeqmsgId &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, '@', value);
    retval = retval && ams::StreamId_ReadStrptrMaybe(parent.stream_id, value);

    algo::NextSep(in_str, ',', value);
    retval = retval && u64_ReadStrptrMaybe(parent.seq, value);

    value = in_str;
    retval = retval && u32_ReadStrptrMaybe(parent.off, value);
    return retval;
}

// --- ams.SeqmsgId..Print
// print string representation of ams::SeqmsgId to string LHS, no header -- cprint:ams.SeqmsgId.String
void ams::SeqmsgId_Print(ams::SeqmsgId row, algo::cstring &str) {
    ams::StreamId_Print(row.stream_id, str);
    str << '@';
    u64_Print(row.seq, str);
    str << ',';
    u32_Print(row.off, str);
}

// --- ams.Seqmsg.payload.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> ams::payload_Getary(ams::Seqmsg& parent) {
    u8 *end = (u8*)&parent + sizeof(ams::Seqmsg);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(ams::Seqmsg));
}

// --- ams.Seqmsg.payload.Print
void ams::payload_Print(ams::Seqmsg& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (ams::MsgHeader *payload = payload_Get(parent)) {
        ams::MsgHeaderMsgs_Print(out, *payload, INT_MAX);
    }
}

// --- ams.Seqmsg.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::Seqmsg &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = ams::MsgHeaderMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.Seqmsg..ReadFieldMaybe
bool ams::Seqmsg_ReadFieldMaybe(ams::Seqmsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_seqmsg_id: retval = ams::SeqmsgId_ReadStrptrMaybe(parent.seqmsg_id, strval); break;
        case ams_FieldId_tsc: retval = u64_ReadStrptrMaybe(parent.tsc, strval); break;
        case ams_FieldId_payload: retval = payload_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.Seqmsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Seqmsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::Seqmsg_ReadStrptrMaybe(ams::Seqmsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.Seqmsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Seqmsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.Seqmsg..Print
// print string representation of ams::Seqmsg to string LHS, no header -- cprint:ams.Seqmsg.String
void ams::Seqmsg_Print(ams::Seqmsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.Seqmsg";

    ams::SeqmsgId_Print(row.seqmsg_id, temp);
    PrintAttrSpaceReset(str,"seqmsg_id", temp);

    u64_Print(row.tsc, temp);
    PrintAttrSpaceReset(str,"tsc", temp);

    if (payload_Get(row) != NULL) {
        ams::payload_Print(row, temp);
        PrintAttrSpaceReset(str,"payload", temp);
    }
}

// --- ams.SeqmsgTrace.mode.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ams::mode_ToCstr(const ams::SeqmsgTrace& parent) {
    const char *ret = NULL;
    switch(mode_GetEnum(parent)) {
        case ams_SeqmsgTrace_mode_r        : ret = "r";  break;
        case ams_SeqmsgTrace_mode_w        : ret = "w";  break;
    }
    return ret;
}

// --- ams.SeqmsgTrace.mode.Print
// Convert mode to a string. First, attempt conversion to a known string.
// If no string matches, print mode as a numeric value.
void ams::mode_Print(const ams::SeqmsgTrace& parent, algo::cstring &lhs) {
    const char *strval = mode_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.mode;
    }
}

// --- ams.SeqmsgTrace.mode.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ams::mode_SetStrptrMaybe(ams::SeqmsgTrace& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'r': {
                    mode_SetEnum(parent,ams_SeqmsgTrace_mode_r); ret = true; break;
                }
                case 'w': {
                    mode_SetEnum(parent,ams_SeqmsgTrace_mode_w); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ams.SeqmsgTrace.mode.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ams::mode_SetStrptr(ams::SeqmsgTrace& parent, algo::strptr rhs, ams_SeqmsgTrace_mode_Enum dflt) {
    if (!mode_SetStrptrMaybe(parent,rhs)) mode_SetEnum(parent,dflt);
}

// --- ams.SeqmsgTrace.mode.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::mode_ReadStrptrMaybe(ams::SeqmsgTrace& parent, algo::strptr rhs) {
    bool retval = false;
    retval = mode_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.mode,rhs);
    }
    return retval;
}

// --- ams.SeqmsgTrace.payload.Getary
// Access optional portion as an array of bytes
algo::aryptr<u8> ams::payload_Getary(ams::SeqmsgTrace& parent) {
    u8 *end = (u8*)&parent + sizeof(ams::SeqmsgTrace);
    return algo::aryptr<u8>(end, i32(parent.length) - ssizeof(ams::SeqmsgTrace));
}

// --- ams.SeqmsgTrace.payload.Print
void ams::payload_Print(ams::SeqmsgTrace& parent, cstring &out) {
    (void)out;
    (void)parent;
    if (ams::MsgHeader *payload = payload_Get(parent)) {
        ams::MsgHeaderMsgs_Print(out, *payload, INT_MAX);
    }
}

// --- ams.SeqmsgTrace.payload.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::payload_ReadStrptrMaybe(ams::SeqmsgTrace &parent, algo::strptr in_str) {
    bool retval = false;
    if (algo_lib::_db.varlenbuf) {
        algo::ByteAry temp;
        retval = ams::MsgHeaderMsgs_ReadStrptrMaybe(in_str, temp); // read any of several message types here
        ary_Setary(*algo_lib::_db.varlenbuf, ary_Getary(temp)); // return it
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.SeqmsgTrace..ReadFieldMaybe
bool ams::SeqmsgTrace_ReadFieldMaybe(ams::SeqmsgTrace &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc_id: retval = ams::ProcId_ReadStrptrMaybe(parent.proc_id, strval); break;
        case ams_FieldId_mode: retval = mode_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_seqmsg_id: retval = ams::SeqmsgId_ReadStrptrMaybe(parent.seqmsg_id, strval); break;
        case ams_FieldId_tsc: retval = u64_ReadStrptrMaybe(parent.tsc, strval); break;
        case ams_FieldId_payload: retval = payload_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.SeqmsgTrace..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::SeqmsgTrace from an ascii string.
// The format of the string is an ssim Tuple
bool ams::SeqmsgTrace_ReadStrptrMaybe(ams::SeqmsgTrace &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.SeqmsgTrace");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && SeqmsgTrace_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.SeqmsgTrace..Print
// print string representation of ams::SeqmsgTrace to string LHS, no header -- cprint:ams.SeqmsgTrace.String
void ams::SeqmsgTrace_Print(ams::SeqmsgTrace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.SeqmsgTrace";

    ams::ProcId_Print(row.proc_id, temp);
    PrintAttrSpaceReset(str,"proc_id", temp);

    ams::mode_Print(row, temp);
    PrintAttrSpaceReset(str,"mode", temp);

    ams::SeqmsgId_Print(row.seqmsg_id, temp);
    PrintAttrSpaceReset(str,"seqmsg_id", temp);

    u64_Print(row.tsc, temp);
    PrintAttrSpaceReset(str,"tsc", temp);

    if (payload_Get(row) != NULL) {
        ams::payload_Print(row, temp);
        PrintAttrSpaceReset(str,"payload", temp);
    }
}

// --- ams.StreamFlags.write.ReadStrptrMaybe
inline static bool ams::write_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.read.ReadStrptrMaybe
inline static bool ams::read_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.nonblock.ReadStrptrMaybe
inline static bool ams::nonblock_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool nonblock_tmp;
    retval = bool_ReadStrptrMaybe(nonblock_tmp, in_str);
    if (retval) {
        nonblock_Set(parent, nonblock_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.trace_read.ReadStrptrMaybe
inline static bool ams::trace_read_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool trace_read_tmp;
    retval = bool_ReadStrptrMaybe(trace_read_tmp, in_str);
    if (retval) {
        trace_read_Set(parent, trace_read_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.trace_write.ReadStrptrMaybe
inline static bool ams::trace_write_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool trace_write_tmp;
    retval = bool_ReadStrptrMaybe(trace_write_tmp, in_str);
    if (retval) {
        trace_write_Set(parent, trace_write_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.write_err.ReadStrptrMaybe
inline static bool ams::write_err_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_err_tmp;
    retval = bool_ReadStrptrMaybe(write_err_tmp, in_str);
    if (retval) {
        write_err_Set(parent, write_err_tmp);
    }
    return retval;
}

// --- ams.StreamFlags.trace_text.ReadStrptrMaybe
inline static bool ams::trace_text_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool trace_text_tmp;
    retval = bool_ReadStrptrMaybe(trace_text_tmp, in_str);
    if (retval) {
        trace_text_Set(parent, trace_text_tmp);
    }
    return retval;
}

// --- ams.StreamFlags..ReadFieldMaybe
bool ams::StreamFlags_ReadFieldMaybe(ams::StreamFlags &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_value: retval = u8_ReadStrptrMaybe(parent.value, strval); break;
        case ams_FieldId_write: retval = write_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_read: retval = read_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_nonblock: retval = nonblock_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_trace_read: retval = trace_read_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_trace_write: retval = trace_write_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_write_err: retval = write_err_ReadStrptrMaybe(parent, strval); break;
        case ams_FieldId_trace_text: retval = trace_text_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.StreamFlags..ReadStrptrMaybe
// Read fields of ams::StreamFlags from an ascii string.
bool ams::StreamFlags_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) {
    bool retval = true;
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            ams::FieldId field_id;
            bool ok = ams::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case ams_FieldId_write: write_Set(parent,true); break;
                    case ams_FieldId_read: read_Set(parent,true); break;
                    case ams_FieldId_nonblock: nonblock_Set(parent,true); break;
                    case ams_FieldId_trace_read: trace_read_Set(parent,true); break;
                    case ams_FieldId_trace_write: trace_write_Set(parent,true); break;
                    case ams_FieldId_write_err: write_err_Set(parent,true); break;
                    case ams_FieldId_trace_text: trace_text_Set(parent,true); break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- ams.StreamFlags..Print
// print string representation of ams::StreamFlags to string LHS, no header -- cprint:ams.StreamFlags.String
void ams::StreamFlags_Print(ams::StreamFlags row, algo::cstring &str) {
    algo::ListSep ls(",");
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (nonblock_Get(row)) {
        str << ls << "nonblock";
    }
    if (trace_read_Get(row)) {
        str << ls << "trace_read";
    }
    if (trace_write_Get(row)) {
        str << ls << "trace_write";
    }
    if (write_err_Get(row)) {
        str << ls << "write_err";
    }
    if (trace_text_Get(row)) {
        str << ls << "trace_text";
    }
}

// --- ams.StreamFlags..GetAnon
algo::strptr ams::StreamFlags_GetAnon(ams::StreamFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- ams.StreamHbMsg..ReadFieldMaybe
bool ams::StreamHbMsg_ReadFieldMaybe(ams::StreamHbMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_member: retval = ams::Member_ReadStrptrMaybe(parent.member, strval); break;
        case ams_FieldId_pos: retval = ams::StreamPos_ReadStrptrMaybe(parent.pos, strval); break;
        case ams_FieldId_wbudget: retval = u32_ReadStrptrMaybe(parent.wbudget, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.StreamHbMsg..ReadStrptrMaybe
// Read fields of ams::StreamHbMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::StreamHbMsg_ReadStrptrMaybe(ams::StreamHbMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.StreamHbMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && StreamHbMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.StreamHbMsg..Print
// print string representation of ams::StreamHbMsg to string LHS, no header -- cprint:ams.StreamHbMsg.String
void ams::StreamHbMsg_Print(ams::StreamHbMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.StreamHbMsg";

    ams::Member_Print(row.member, temp);
    PrintAttrSpaceReset(str,"member", temp);

    ams::StreamPos_Print(row.pos, temp);
    PrintAttrSpaceReset(str,"pos", temp);

    u32_Print(row.wbudget, temp);
    PrintAttrSpaceReset(str,"wbudget", temp);
}

// --- ams.TerminateMsg..ReadFieldMaybe
bool ams::TerminateMsg_ReadFieldMaybe(ams::TerminateMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        default: break;
    }
    (void)parent;//only to avoid -Wunused-parameter
    (void)strval;//only to avoid -Wunused-parameter
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.TerminateMsg..ReadStrptrMaybe
// Read fields of ams::TerminateMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::TerminateMsg_ReadStrptrMaybe(ams::TerminateMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.TerminateMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TerminateMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.TerminateMsg..Print
// print string representation of ams::TerminateMsg to string LHS, no header -- cprint:ams.TerminateMsg.String
void ams::TerminateMsg_Print(ams::TerminateMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.TerminateMsg";
    (void)row;//only to avoid -Wunused-parameter
}

// --- ams.Trace2Msg.data.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u64> ams::data_Getary(ams::Trace2Msg& parent) {
    return algo::aryptr<u64>(data_Addr(parent), data_N(parent));
}

// --- ams.Trace2Msg.data.Addr
u64* ams::data_Addr(ams::Trace2Msg& parent) {
    return (u64*)((u8*)&parent + sizeof(ams::Trace2Msg)); // address of varlen portion
}

// --- ams.Trace2Msg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::data_ReadStrptrMaybe(ams::Trace2Msg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        u64 *data_tmp = new(ary_AllocN(*algo_lib::_db.varlenbuf, sizeof(u64)).elems) u64;
        retval = u64_ReadStrptrMaybe(*data_tmp, in_str);
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.Trace2Msg..ReadFieldMaybe
bool ams::Trace2Msg_ReadFieldMaybe(ams::Trace2Msg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc: retval = ams::ProcId_ReadStrptrMaybe(parent.proc, strval); break;
        case ams_FieldId_trace: retval = u8_ReadStrptrMaybe(parent.trace, strval); break;
        case ams_FieldId_tstamp: retval = algo::UnTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_data: retval = data_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.Trace2Msg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Trace2Msg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::Trace2Msg_ReadStrptrMaybe(ams::Trace2Msg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.Trace2Msg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Trace2Msg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.Trace2Msg..Print
// print string representation of ams::Trace2Msg to string LHS, no header -- cprint:ams.Trace2Msg.String
void ams::Trace2Msg_Print(ams::Trace2Msg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.Trace2Msg";

    ams::ProcId_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    u8_Print(row.trace, temp);
    PrintAttrSpaceReset(str,"trace", temp);

    algo::UnTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    ind_beg(Trace2Msg_data_curs,data,row) {
        u64_Print(data, temp);
        tempstr name;
        name << "data.";
        name << ind_curs(data).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;
}

// --- ams.TraceInfo2Msg.data.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::data_Getary(ams::TraceInfo2Msg& parent) {
    return algo::aryptr<char>(data_Addr(parent), data_N(parent));
}

// --- ams.TraceInfo2Msg.data.Addr
char* ams::data_Addr(ams::TraceInfo2Msg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::TraceInfo2Msg)); // address of varlen portion
}

// --- ams.TraceInfo2Msg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::data_ReadStrptrMaybe(ams::TraceInfo2Msg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.TraceInfo2Msg..ReadFieldMaybe
bool ams::TraceInfo2Msg_ReadFieldMaybe(ams::TraceInfo2Msg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc: retval = ams::ProcId_ReadStrptrMaybe(parent.proc, strval); break;
        case ams_FieldId_trace: retval = u8_ReadStrptrMaybe(parent.trace, strval); break;
        case ams_FieldId_tstamp: retval = algo::UnTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_part: retval = u8_ReadStrptrMaybe(parent.part, strval); break;
        case ams_FieldId_data: retval = data_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.TraceInfo2Msg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceInfo2Msg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::TraceInfo2Msg_ReadStrptrMaybe(ams::TraceInfo2Msg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.TraceInfo2Msg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TraceInfo2Msg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.TraceInfo2Msg..Print
// print string representation of ams::TraceInfo2Msg to string LHS, no header -- cprint:ams.TraceInfo2Msg.String
void ams::TraceInfo2Msg_Print(ams::TraceInfo2Msg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.TraceInfo2Msg";

    ams::ProcId_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    u8_Print(row.trace, temp);
    PrintAttrSpaceReset(str,"trace", temp);

    algo::UnTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    u8_Print(row.part, temp);
    PrintAttrSpaceReset(str,"part", temp);

    algo::aryptr<char> data_ary = data_Getary(row);
    PrintAttrSpace(str, "data", data_ary); // print field ams.TraceInfo2Msg.data
}

// --- ams.TraceInfoMsg.data.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char> ams::data_Getary(ams::TraceInfoMsg& parent) {
    return algo::aryptr<char>(data_Addr(parent), data_N(parent));
}

// --- ams.TraceInfoMsg.data.Addr
char* ams::data_Addr(ams::TraceInfoMsg& parent) {
    return (char*)((u8*)&parent + sizeof(ams::TraceInfoMsg)); // address of varlen portion
}

// --- ams.TraceInfoMsg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::data_ReadStrptrMaybe(ams::TraceInfoMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        ary_Addary(*algo_lib::_db.varlenbuf, strptr_ToMemptr(in_str));
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.TraceInfoMsg..ReadFieldMaybe
bool ams::TraceInfoMsg_ReadFieldMaybe(ams::TraceInfoMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc: retval = ams::ProcId_ReadStrptrMaybe(parent.proc, strval); break;
        case ams_FieldId_tstamp: retval = algo::UnTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_part: retval = u8_ReadStrptrMaybe(parent.part, strval); break;
        case ams_FieldId_data: retval = data_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.TraceInfoMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceInfoMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::TraceInfoMsg_ReadStrptrMaybe(ams::TraceInfoMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.TraceInfoMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TraceInfoMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.TraceInfoMsg..Print
// print string representation of ams::TraceInfoMsg to string LHS, no header -- cprint:ams.TraceInfoMsg.String
void ams::TraceInfoMsg_Print(ams::TraceInfoMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.TraceInfoMsg";

    ams::ProcId_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    algo::UnTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    u8_Print(row.part, temp);
    PrintAttrSpaceReset(str,"part", temp);

    algo::aryptr<char> data_ary = data_Getary(row);
    PrintAttrSpace(str, "data", data_ary); // print field ams.TraceInfoMsg.data
}

// --- ams.TraceMsg.data.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u64> ams::data_Getary(ams::TraceMsg& parent) {
    return algo::aryptr<u64>(data_Addr(parent), data_N(parent));
}

// --- ams.TraceMsg.data.Addr
u64* ams::data_Addr(ams::TraceMsg& parent) {
    return (u64*)((u8*)&parent + sizeof(ams::TraceMsg)); // address of varlen portion
}

// --- ams.TraceMsg.data.ReadStrptrMaybe
// Convert string to field. Return success value
bool ams::data_ReadStrptrMaybe(ams::TraceMsg& parent, algo::strptr in_str) {
    bool retval = true;
    if (algo_lib::_db.varlenbuf) {
        u64 *data_tmp = new(ary_AllocN(*algo_lib::_db.varlenbuf, sizeof(u64)).elems) u64;
        retval = u64_ReadStrptrMaybe(*data_tmp, in_str);
    }
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- ams.TraceMsg..ReadFieldMaybe
bool ams::TraceMsg_ReadFieldMaybe(ams::TraceMsg &parent, algo::strptr field, algo::strptr strval) {
    ams::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    bool retval = true; // default is no error
    switch(field_id) {
        case ams_FieldId_proc: retval = ams::ProcId_ReadStrptrMaybe(parent.proc, strval); break;
        case ams_FieldId_tstamp: retval = algo::UnTime_ReadStrptrMaybe(parent.tstamp, strval); break;
        case ams_FieldId_data: retval = data_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- ams.TraceMsg..ReadStrptrMaybe
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceMsg from an ascii string.
// The format of the string is an ssim Tuple
bool ams::TraceMsg_ReadStrptrMaybe(ams::TraceMsg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "ams.TraceMsg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && TraceMsg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- ams.TraceMsg..Print
// print string representation of ams::TraceMsg to string LHS, no header -- cprint:ams.TraceMsg.String
void ams::TraceMsg_Print(ams::TraceMsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.TraceMsg";

    ams::ProcId_Print(row.proc, temp);
    PrintAttrSpaceReset(str,"proc", temp);

    algo::UnTime_Print(row.tstamp, temp);
    PrintAttrSpaceReset(str,"tstamp", temp);

    ind_beg(TraceMsg_data_curs,data,row) {
        u64_Print(data, temp);
        tempstr name;
        name << "data.";
        name << ind_curs(data).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;
}

// --- ams.UdpFrame.payload.Getary
// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u8> ams::payload_Getary(ams::UdpFrame& parent) {
    return algo::aryptr<u8>(payload_Addr(parent), payload_N(parent));
}

// --- ams.UdpFrame.payload.Addr
u8* ams::payload_Addr(ams::UdpFrame& parent) {
    return (u8*)((u8*)&parent + sizeof(ams::UdpFrame)); // address of varlen portion
}

// --- ams.UdpFrame..Print
// print string representation of ams::UdpFrame to string LHS, no header -- cprint:ams.UdpFrame.String
void ams::UdpFrame_Print(ams::UdpFrame & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ams.UdpFrame";

    algo::UnTime_Print(row.timestamp, temp);
    PrintAttrSpaceReset(str,"timestamp", temp);

    ietf::Ipv4_Print(row.src_ip, temp);
    PrintAttrSpaceReset(str,"src_ip", temp);

    ietf::Ipv4_Print(row.dst_ip, temp);
    PrintAttrSpaceReset(str,"dst_ip", temp);

    u16_Print(row.src_port, temp);
    PrintAttrSpaceReset(str,"src_port", temp);

    u16_Print(row.dst_port, temp);
    PrintAttrSpaceReset(str,"dst_port", temp);

    algo::aryptr<u8> payload_ary = payload_Getary(row);
    PrintAttrSpace(str, "payload", algo::strptr((char*)payload_ary.elems, payload_ary.n_elems)); // print field ams.UdpFrame.payload
}

// --- ams...SizeCheck
inline static void ams::SizeCheck() {
}

// --- ams.MsgHeaderMsgs..Print
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool ams::MsgHeaderMsgs_Print(algo::cstring &str, ams::MsgHeader &msg, u32 msg_len) {
    switch(msg.type) {
        case 18: {
            if (sizeof(ams::AlarmSyncMsg) > msg_len) { return false; }
            AlarmSyncMsg_Print((ams::AlarmSyncMsg&)(msg), str);
            return true;
        }
        case 21: {
            if (sizeof(ams::DfltStream) > msg_len) { return false; }
            DfltStream_Print((ams::DfltStream&)(msg), str);
            return true;
        }
        case 12: {
            if (sizeof(ams::DumpStreamTableMsg) > msg_len) { return false; }
            DumpStreamTableMsg_Print((ams::DumpStreamTableMsg&)(msg), str);
            return true;
        }
        case 395: {
            if (sizeof(ams::ExpectMsg) > msg_len) { return false; }
            ExpectMsg_Print((ams::ExpectMsg&)(msg), str);
            return true;
        }
        case 16: {
            if (sizeof(ams::HeartbeatMsg) > msg_len) { return false; }
            HeartbeatMsg_Print((ams::HeartbeatMsg&)(msg), str);
            return true;
        }
        case 22: {
            if (sizeof(ams::InputLineMsg) > msg_len) { return false; }
            InputLineMsg_Print((ams::InputLineMsg&)(msg), str);
            return true;
        }
        case 6: {
            if (sizeof(ams::LogMsg) > msg_len) { return false; }
            LogMsg_Print((ams::LogMsg&)(msg), str);
            return true;
        }
        case 1: {
            if (sizeof(ams::MsgBlock) > msg_len) { return false; }
            MsgBlock_Print((ams::MsgBlock&)(msg), str);
            return true;
        }
        case 7: {
            if (sizeof(ams::OpenMsg) > msg_len) { return false; }
            OpenMsg_Print((ams::OpenMsg&)(msg), str);
            return true;
        }
        case 229: {
            if (sizeof(ams::PrlogMsg) > msg_len) { return false; }
            PrlogMsg_Print((ams::PrlogMsg&)(msg), str);
            return true;
        }
        case 4: {
            if (sizeof(ams::ProcAddMsg) > msg_len) { return false; }
            ProcAddMsg_Print((ams::ProcAddMsg&)(msg), str);
            return true;
        }
        case 5: {
            if (sizeof(ams::ProcRemoveMsg) > msg_len) { return false; }
            ProcRemoveMsg_Print((ams::ProcRemoveMsg&)(msg), str);
            return true;
        }
        case 10: {
            if (sizeof(ams::Seqmsg) > msg_len) { return false; }
            Seqmsg_Print((ams::Seqmsg&)(msg), str);
            return true;
        }
        case 11: {
            if (sizeof(ams::SeqmsgTrace) > msg_len) { return false; }
            SeqmsgTrace_Print((ams::SeqmsgTrace&)(msg), str);
            return true;
        }
        case 3: {
            if (sizeof(ams::StreamHbMsg) > msg_len) { return false; }
            StreamHbMsg_Print((ams::StreamHbMsg&)(msg), str);
            return true;
        }
        case 352: {
            if (sizeof(ams::TerminateMsg) > msg_len) { return false; }
            TerminateMsg_Print((ams::TerminateMsg&)(msg), str);
            return true;
        }
        case 108: {
            if (sizeof(ams::Trace2Msg) > msg_len) { return false; }
            Trace2Msg_Print((ams::Trace2Msg&)(msg), str);
            return true;
        }
        case 109: {
            if (sizeof(ams::TraceInfo2Msg) > msg_len) { return false; }
            TraceInfo2Msg_Print((ams::TraceInfo2Msg&)(msg), str);
            return true;
        }
        case 9: {
            if (sizeof(ams::TraceInfoMsg) > msg_len) { return false; }
            TraceInfoMsg_Print((ams::TraceInfoMsg&)(msg), str);
            return true;
        }
        case 8: {
            if (sizeof(ams::TraceMsg) > msg_len) { return false; }
            TraceMsg_Print((ams::TraceMsg&)(msg), str);
            return true;
        }
        case 2: {
            if (sizeof(ams::UdpFrame) > msg_len) { return false; }
            UdpFrame_Print((ams::UdpFrame&)(msg), str);
            return true;
        }
        case 17: {
            if (sizeof(fm::AlarmMsg) > msg_len) { return false; }
            AlarmMsg_Print((fm::AlarmMsg&)(msg), str);
            return true;
        }
        default:

        return false;
    }
}

// --- ams.MsgHeaderMsgs..ReadStrptr
// Parse ascii representation of message into binary, appending new data to BUF.
ams::MsgHeaderMsgsCase ams::MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf) {
    bool ok = false;
    tempstr msgtype_str;
    algo::StringIter iter(str);
    cstring_ReadCmdarg(msgtype_str, iter, false); // read first word
    ams::MsgHeaderMsgsCase msgtype;
    value_SetStrptrMaybe(msgtype, msgtype_str); // map string -> enum
    switch (value_GetEnum(msgtype)) { // what message is it?
        case ams_MsgHeaderMsgsCase_ams_AlarmSyncMsg: {
            int len = sizeof(ams::AlarmSyncMsg);
            ams::AlarmSyncMsg *ctype = new(ary_AllocN(buf, len).elems) ams::AlarmSyncMsg; // default values
            ok = AlarmSyncMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::AlarmSyncMsg case

        case ams_MsgHeaderMsgsCase_ams_DfltStream: {
            int len = sizeof(ams::DfltStream);
            ams::DfltStream *ctype = new(ary_AllocN(buf, len).elems) ams::DfltStream; // default values
            ok = DfltStream_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::DfltStream case

        case ams_MsgHeaderMsgsCase_ams_DumpStreamTableMsg: {
            int len = sizeof(ams::DumpStreamTableMsg);
            ams::DumpStreamTableMsg *ctype = new(ary_AllocN(buf, len).elems) ams::DumpStreamTableMsg; // default values
            ok = DumpStreamTableMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::DumpStreamTableMsg case

        case ams_MsgHeaderMsgsCase_ams_ExpectMsg: {
            int len = sizeof(ams::ExpectMsg);
            ams::ExpectMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ExpectMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = ExpectMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::ExpectMsg case

        case ams_MsgHeaderMsgsCase_ams_HeartbeatMsg: {
            int len = sizeof(ams::HeartbeatMsg);
            ams::HeartbeatMsg *ctype = new(ary_AllocN(buf, len).elems) ams::HeartbeatMsg; // default values
            ok = HeartbeatMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::HeartbeatMsg case

        case ams_MsgHeaderMsgsCase_ams_InputLineMsg: {
            int len = sizeof(ams::InputLineMsg);
            ams::InputLineMsg *ctype = new(ary_AllocN(buf, len).elems) ams::InputLineMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = InputLineMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::InputLineMsg case

        case ams_MsgHeaderMsgsCase_ams_LogMsg: {
            int len = sizeof(ams::LogMsg);
            ams::LogMsg *ctype = new(ary_AllocN(buf, len).elems) ams::LogMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = LogMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::LogMsg case

        case ams_MsgHeaderMsgsCase_ams_MsgBlock: {
            // no cfmt read:Y found -- cannot read
        } break; // ams::MsgBlock case

        case ams_MsgHeaderMsgsCase_ams_OpenMsg: {
            int len = sizeof(ams::OpenMsg);
            ams::OpenMsg *ctype = new(ary_AllocN(buf, len).elems) ams::OpenMsg; // default values
            ok = OpenMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::OpenMsg case

        case ams_MsgHeaderMsgsCase_ams_PrlogMsg: {
            int len = sizeof(ams::PrlogMsg);
            ams::PrlogMsg *ctype = new(ary_AllocN(buf, len).elems) ams::PrlogMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = PrlogMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::PrlogMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcAddMsg: {
            int len = sizeof(ams::ProcAddMsg);
            ams::ProcAddMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcAddMsg; // default values
            ok = ProcAddMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ProcAddMsg case

        case ams_MsgHeaderMsgsCase_ams_ProcRemoveMsg: {
            int len = sizeof(ams::ProcRemoveMsg);
            ams::ProcRemoveMsg *ctype = new(ary_AllocN(buf, len).elems) ams::ProcRemoveMsg; // default values
            ok = ProcRemoveMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::ProcRemoveMsg case

        case ams_MsgHeaderMsgsCase_ams_Seqmsg: {
            int len = sizeof(ams::Seqmsg);
            ams::Seqmsg *ctype = new(ary_AllocN(buf, len).elems) ams::Seqmsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Seqmsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::Seqmsg case

        case ams_MsgHeaderMsgsCase_ams_SeqmsgTrace: {
            int len = sizeof(ams::SeqmsgTrace);
            ams::SeqmsgTrace *ctype = new(ary_AllocN(buf, len).elems) ams::SeqmsgTrace; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = SeqmsgTrace_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::SeqmsgTrace case

        case ams_MsgHeaderMsgsCase_ams_StreamHbMsg: {
            int len = sizeof(ams::StreamHbMsg);
            ams::StreamHbMsg *ctype = new(ary_AllocN(buf, len).elems) ams::StreamHbMsg; // default values
            ok = StreamHbMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::StreamHbMsg case

        case ams_MsgHeaderMsgsCase_ams_TerminateMsg: {
            int len = sizeof(ams::TerminateMsg);
            ams::TerminateMsg *ctype = new(ary_AllocN(buf, len).elems) ams::TerminateMsg; // default values
            ok = TerminateMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // ams::TerminateMsg case

        case ams_MsgHeaderMsgsCase_ams_Trace2Msg: {
            int len = sizeof(ams::Trace2Msg);
            ams::Trace2Msg *ctype = new(ary_AllocN(buf, len).elems) ams::Trace2Msg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = Trace2Msg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::Trace2Msg case

        case ams_MsgHeaderMsgsCase_ams_TraceInfo2Msg: {
            int len = sizeof(ams::TraceInfo2Msg);
            ams::TraceInfo2Msg *ctype = new(ary_AllocN(buf, len).elems) ams::TraceInfo2Msg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = TraceInfo2Msg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::TraceInfo2Msg case

        case ams_MsgHeaderMsgsCase_ams_TraceInfoMsg: {
            int len = sizeof(ams::TraceInfoMsg);
            ams::TraceInfoMsg *ctype = new(ary_AllocN(buf, len).elems) ams::TraceInfoMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = TraceInfoMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::TraceInfoMsg case

        case ams_MsgHeaderMsgsCase_ams_TraceMsg: {
            int len = sizeof(ams::TraceMsg);
            ams::TraceMsg *ctype = new(ary_AllocN(buf, len).elems) ams::TraceMsg; // default values
            algo::ByteAry varlenbuf;
            algo::ByteAry *varlenbuf_save = algo_lib::_db.varlenbuf;
            algo_lib::_db.varlenbuf = &varlenbuf;
            ok = TraceMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
            len += ary_N(varlenbuf);
            ctype->length = u32(len);
            ary_Addary(buf, ary_Getary(varlenbuf));
            algo_lib::_db.varlenbuf = varlenbuf_save;
        } break; // ams::TraceMsg case

        case ams_MsgHeaderMsgsCase_ams_UdpFrame: {
            // no cfmt read:Y found -- cannot read
        } break; // ams::UdpFrame case

        case ams_MsgHeaderMsgsCase_fm_AlarmMsg: {
            int len = sizeof(fm::AlarmMsg);
            fm::AlarmMsg *ctype = new(ary_AllocN(buf, len).elems) fm::AlarmMsg; // default values
            ok = AlarmMsg_ReadStrptrMaybe(*ctype, str); // now read attributes
        } break; // fm::AlarmMsg case

        default: break;
    }
    return ok ? msgtype : ams::MsgHeaderMsgsCase();
}

// --- ams.MsgHeaderMsgs..ReadStrptrMaybe
// Parse ascii representation of message into binary, appending new data to BUF.
bool ams::MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf) {
    ams::MsgHeaderMsgsCase msgtype = MsgHeaderMsgs_ReadStrptr(str,buf);
    return !(msgtype == ams::MsgHeaderMsgsCase());
}

// --- ams...LogMsg_FmtByteAry
// Construct a new ams::LogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::LogMsg * ams::LogMsg_FmtByteAry(algo::ByteAry &buf, const algo::strptr& logcat, algo::SchedTime tstamp, algo::aryptr<char > text) {
    ams::LogMsg  *msg = NULL;
    size_t len = sizeof(ams::LogMsg);
    u32 ary_len = elems_N(text) * sizeof(char);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::LogMsg*)ary_AllocN(buf,len).elems;
    msg->type = u32(6);
    msg->length = u32(len + (0));
    msg->logcat = logcat;
    msg->tstamp = tstamp;
    memcpy(text_Addr(*msg), text.elems, ary_len);
    return msg;
}

// --- ams...MsgBlock_FmtByteAry
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::MsgBlock * ams::MsgBlock_FmtByteAry(algo::ByteAry &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages) {
    ams::MsgBlock  *msg = NULL;
    size_t len = sizeof(ams::MsgBlock);
    u32 ary_len = elems_N(messages) * sizeof(u8);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::MsgBlock*)ary_AllocN(buf,len).elems;
    msg->type = u32(1);
    msg->length = u32(len + (0));
    msg->first_seqno = first_seqno;
    msg->n_messages = n_messages;
    msg->original_length = original_length;
    memcpy(messages_Addr(*msg), messages.elems, ary_len);
    return msg;
}

// --- ams...MsgBlock_FmtMemptr
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
ams::MsgBlock * ams::MsgBlock_FmtMemptr(algo::memptr &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages) {
    ams::MsgBlock  *msg = NULL;
    size_t len = sizeof(ams::MsgBlock);
    u32 ary_len = elems_N(messages) * sizeof(u8);
    len += ary_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (ams::MsgBlock*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->type = u32(1);
    msg->length = u32(len + (0));
    msg->first_seqno = first_seqno;
    msg->n_messages = n_messages;
    msg->original_length = original_length;
    memcpy(messages_Addr(*msg), messages.elems, ary_len);
    return msg;
}

// --- ams...SeqmsgTrace_FmtByteAry
// Construct a new ams::SeqmsgTrace in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::SeqmsgTrace * ams::SeqmsgTrace_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc_id, u8 mode, ams::SeqmsgId seqmsg_id, u64 tsc, ams::MsgHeader* payload) {
    ams::SeqmsgTrace  *msg = NULL;
    size_t len = sizeof(ams::SeqmsgTrace);
    int opt_len = payload ? i32(payload[0].length) : 0;
    len += opt_len;
    ary_RemoveAll(buf);
    msg = (ams::SeqmsgTrace*)ary_AllocN(buf,len).elems;
    msg->type = u32(11);
    msg->length = u32(len + (0));
    msg->proc_id = proc_id;
    msg->mode = mode;
    msg->seqmsg_id = seqmsg_id;
    msg->tsc = tsc;
    if (payload) {
        memcpy((u8*)msg + sizeof(ams::SeqmsgTrace), payload, opt_len);
    }
    return msg;
}

// --- ams...Trace2Msg_FmtByteAry
// Construct a new ams::Trace2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::Trace2Msg * ams::Trace2Msg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, u8 trace, algo::UnTime tstamp, algo::aryptr<u64 > data) {
    ams::Trace2Msg  *msg = NULL;
    size_t len = sizeof(ams::Trace2Msg);
    u32 ary_len = elems_N(data) * sizeof(u64);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::Trace2Msg*)ary_AllocN(buf,len).elems;
    msg->type = u32(108);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->trace = trace;
    msg->tstamp = tstamp;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    return msg;
}

// --- ams...TraceInfo2Msg_FmtByteAry
// Construct a new ams::TraceInfo2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceInfo2Msg * ams::TraceInfo2Msg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, u8 trace, algo::UnTime tstamp, u8 part, algo::aryptr<char > data) {
    ams::TraceInfo2Msg  *msg = NULL;
    size_t len = sizeof(ams::TraceInfo2Msg);
    u32 ary_len = elems_N(data) * sizeof(char);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::TraceInfo2Msg*)ary_AllocN(buf,len).elems;
    msg->type = u32(109);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->trace = trace;
    msg->tstamp = tstamp;
    msg->part = part;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    return msg;
}

// --- ams...TraceInfoMsg_FmtByteAry
// Construct a new ams::TraceInfoMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceInfoMsg * ams::TraceInfoMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, algo::UnTime tstamp, u8 part, algo::aryptr<char > data) {
    ams::TraceInfoMsg  *msg = NULL;
    size_t len = sizeof(ams::TraceInfoMsg);
    u32 ary_len = elems_N(data) * sizeof(char);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::TraceInfoMsg*)ary_AllocN(buf,len).elems;
    msg->type = u32(9);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->tstamp = tstamp;
    msg->part = part;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    return msg;
}

// --- ams...TraceMsg_FmtByteAry
// Construct a new ams::TraceMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::TraceMsg * ams::TraceMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, algo::UnTime tstamp, algo::aryptr<u64 > data) {
    ams::TraceMsg  *msg = NULL;
    size_t len = sizeof(ams::TraceMsg);
    u32 ary_len = elems_N(data) * sizeof(u64);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::TraceMsg*)ary_AllocN(buf,len).elems;
    msg->type = u32(8);
    msg->length = u32(len + (0));
    msg->proc = proc;
    msg->tstamp = tstamp;
    memcpy(data_Addr(*msg), data.elems, ary_len);
    return msg;
}

// --- ams...UdpFrame_FmtByteAry
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
ams::UdpFrame * ams::UdpFrame_FmtByteAry(algo::ByteAry &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload) {
    ams::UdpFrame  *msg = NULL;
    size_t len = sizeof(ams::UdpFrame);
    u32 ary_len = elems_N(payload) * sizeof(u8);
    len += ary_len;
    ary_RemoveAll(buf);
    msg = (ams::UdpFrame*)ary_AllocN(buf,len).elems;
    msg->type = u32(2);
    msg->length = u32(len + (0));
    msg->timestamp = timestamp;
    msg->src_ip = src_ip;
    msg->dst_ip = dst_ip;
    msg->src_port = src_port;
    msg->dst_port = dst_port;
    memcpy(payload_Addr(*msg), payload.elems, ary_len);
    return msg;
}

// --- ams...UdpFrame_FmtMemptr
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
ams::UdpFrame * ams::UdpFrame_FmtMemptr(algo::memptr &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload) {
    ams::UdpFrame  *msg = NULL;
    size_t len = sizeof(ams::UdpFrame);
    u32 ary_len = elems_N(payload) * sizeof(u8);
    len += ary_len;
    if (len > u32(elems_N(buf))) {
        return NULL; // no room.
    }
    msg = (ams::UdpFrame*)buf.elems;
    buf        = RestFrom(buf,len);
    msg->type = u32(2);
    msg->length = u32(len + (0));
    msg->timestamp = timestamp;
    msg->src_ip = src_ip;
    msg->dst_ip = dst_ip;
    msg->src_port = src_port;
    msg->dst_port = dst_port;
    memcpy(payload_Addr(*msg), payload.elems, ary_len);
    return msg;
}
