//
// cpp/gen/sampdb_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/sampdb_gen.h"
#include "include/gen/sampdb_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace sampdb { // gen:ns_print_proto
    // func:sampdb...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- sampdb.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* sampdb::value_ToCstr(const sampdb::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case sampdb_FieldId_gitfile        : ret = "gitfile";  break;
        case sampdb_FieldId_comment        : ret = "comment";  break;
        case sampdb_FieldId_targdep        : ret = "targdep";  break;
        case sampdb_FieldId_target         : ret = "target";  break;
        case sampdb_FieldId_parent         : ret = "parent";  break;
        case sampdb_FieldId_rec            : ret = "rec";  break;
        case sampdb_FieldId_pre            : ret = "pre";  break;
        case sampdb_FieldId_dflt           : ret = "dflt";  break;
        case sampdb_FieldId_recipe         : ret = "recipe";  break;
        case sampdb_FieldId_targsrc        : ret = "targsrc";  break;
        case sampdb_FieldId_src            : ret = "src";  break;
        case sampdb_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- sampdb.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void sampdb::value_Print(const sampdb::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- sampdb.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool sampdb::value_SetStrptrMaybe(sampdb::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('p','r','e'): {
                    value_SetEnum(parent,sampdb_FieldId_pre); ret = true; break;
                }
                case LE_STR3('r','e','c'): {
                    value_SetEnum(parent,sampdb_FieldId_rec); ret = true; break;
                }
                case LE_STR3('s','r','c'): {
                    value_SetEnum(parent,sampdb_FieldId_src); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,sampdb_FieldId_dflt); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,sampdb_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,sampdb_FieldId_parent); ret = true; break;
                }
                case LE_STR6('r','e','c','i','p','e'): {
                    value_SetEnum(parent,sampdb_FieldId_recipe); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,sampdb_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,sampdb_FieldId_comment); ret = true; break;
                }
                case LE_STR7('g','i','t','f','i','l','e'): {
                    value_SetEnum(parent,sampdb_FieldId_gitfile); ret = true; break;
                }
                case LE_STR7('t','a','r','g','d','e','p'): {
                    value_SetEnum(parent,sampdb_FieldId_targdep); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,sampdb_FieldId_targsrc); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- sampdb.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void sampdb::value_SetStrptr(sampdb::FieldId& parent, algo::strptr rhs, sampdb_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- sampdb.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool sampdb::value_ReadStrptrMaybe(sampdb::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- sampdb.FieldId..ReadStrptrMaybe
// Read fields of sampdb::FieldId from an ascii string.
// The format of the string is the format of the sampdb::FieldId's only field
bool sampdb::FieldId_ReadStrptrMaybe(sampdb::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- sampdb.FieldId..Print
// print string representation of ROW to string STR
// cfmt:sampdb.FieldId.String  printfmt:Raw
void sampdb::FieldId_Print(sampdb::FieldId& row, algo::cstring& str) {
    sampdb::value_Print(row, str);
}

// --- sampdb.Gitfile..ReadFieldMaybe
bool sampdb::Gitfile_ReadFieldMaybe(sampdb::Gitfile& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    sampdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case sampdb_FieldId_gitfile: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.gitfile, strval);
        } break;
        case sampdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- sampdb.Gitfile..ReadStrptrMaybe
// Read fields of sampdb::Gitfile from an ascii string.
// The format of the string is an ssim Tuple
bool sampdb::Gitfile_ReadStrptrMaybe(sampdb::Gitfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "sampdb.gitfile") || algo::StripTypeTag(in_str, "sampdb.Gitfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- sampdb.Gitfile..Print
// print string representation of ROW to string STR
// cfmt:sampdb.Gitfile.String  printfmt:Tuple
void sampdb::Gitfile_Print(sampdb::Gitfile& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "sampdb.gitfile";

    algo::Smallstr50_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- sampdb.Targdep.target.Get
algo::Smallstr50 sampdb::target_Get(sampdb::Targdep& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targdep, ".LL"));
    return ret;
}

// --- sampdb.Targdep.target.Get2
algo::Smallstr50 sampdb::Targdep_target_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- sampdb.Targdep.parent.Get
algo::Smallstr50 sampdb::parent_Get(sampdb::Targdep& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targdep, ".LR"));
    return ret;
}

// --- sampdb.Targdep.parent.Get2
algo::Smallstr50 sampdb::Targdep_parent_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR"));
    return ret;
}

// --- sampdb.Targdep..Concat_target_parent
tempstr sampdb::Targdep_Concat_target_parent( const algo::strptr& target ,const algo::strptr& parent ) {
    return tempstr() << target <<'.'<< parent ;
}

// --- sampdb.Targdep..ReadFieldMaybe
bool sampdb::Targdep_ReadFieldMaybe(sampdb::Targdep& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    sampdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case sampdb_FieldId_targdep: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.targdep, strval);
        } break;
        case sampdb_FieldId_target: {
            retval = false;
        } break;
        case sampdb_FieldId_parent: {
            retval = false;
        } break;
        case sampdb_FieldId_rec: {
            retval = bool_ReadStrptrMaybe(parent.rec, strval);
        } break;
        case sampdb_FieldId_pre: {
            retval = bool_ReadStrptrMaybe(parent.pre, strval);
        } break;
        case sampdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- sampdb.Targdep..ReadStrptrMaybe
// Read fields of sampdb::Targdep from an ascii string.
// The format of the string is an ssim Tuple
bool sampdb::Targdep_ReadStrptrMaybe(sampdb::Targdep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "sampdb.targdep") || algo::StripTypeTag(in_str, "sampdb.Targdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- sampdb.Targdep..Print
// print string representation of ROW to string STR
// cfmt:sampdb.Targdep.String  printfmt:Tuple
void sampdb::Targdep_Print(sampdb::Targdep& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "sampdb.targdep";

    algo::Smallstr50_Print(row.targdep, temp);
    PrintAttrSpaceReset(str,"targdep", temp);

    bool_Print(row.rec, temp);
    PrintAttrSpaceReset(str,"rec", temp);

    bool_Print(row.pre, temp);
    PrintAttrSpaceReset(str,"pre", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- sampdb.Target..ReadFieldMaybe
bool sampdb::Target_ReadFieldMaybe(sampdb::Target& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    sampdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case sampdb_FieldId_target: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.target, strval);
        } break;
        case sampdb_FieldId_dflt: {
            retval = bool_ReadStrptrMaybe(parent.dflt, strval);
        } break;
        case sampdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- sampdb.Target..ReadStrptrMaybe
// Read fields of sampdb::Target from an ascii string.
// The format of the string is an ssim Tuple
bool sampdb::Target_ReadStrptrMaybe(sampdb::Target &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "sampdb.target") || algo::StripTypeTag(in_str, "sampdb.Target");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Target_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- sampdb.Target..Print
// print string representation of ROW to string STR
// cfmt:sampdb.Target.String  printfmt:Tuple
void sampdb::Target_Print(sampdb::Target& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "sampdb.target";

    algo::Smallstr50_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    bool_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- sampdb.Targrec..ReadFieldMaybe
bool sampdb::Targrec_ReadFieldMaybe(sampdb::Targrec& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    sampdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case sampdb_FieldId_target: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.target, strval);
        } break;
        case sampdb_FieldId_recipe: {
            retval = algo::cstring_ReadStrptrMaybe(parent.recipe, strval);
        } break;
        case sampdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- sampdb.Targrec..ReadStrptrMaybe
// Read fields of sampdb::Targrec from an ascii string.
// The format of the string is an ssim Tuple
bool sampdb::Targrec_ReadStrptrMaybe(sampdb::Targrec &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "sampdb.targrec") || algo::StripTypeTag(in_str, "sampdb.Targrec");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targrec_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- sampdb.Targrec..Print
// print string representation of ROW to string STR
// cfmt:sampdb.Targrec.String  printfmt:Tuple
void sampdb::Targrec_Print(sampdb::Targrec& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "sampdb.targrec";

    algo::Smallstr50_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::cstring_Print(row.recipe, temp);
    PrintAttrSpaceReset(str,"recipe", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- sampdb.Targsrc.target.Get
algo::Smallstr50 sampdb::target_Get(sampdb::Targsrc& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsrc, "/LL"));
    return ret;
}

// --- sampdb.Targsrc.target.Get2
algo::Smallstr50 sampdb::Targsrc_target_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- sampdb.Targsrc.src.Get
algo::Smallstr50 sampdb::src_Get(sampdb::Targsrc& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsrc, "/LR"));
    return ret;
}

// --- sampdb.Targsrc.src.Get2
algo::Smallstr50 sampdb::Targsrc_src_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- sampdb.Targsrc..Concat_target_src
tempstr sampdb::Targsrc_Concat_target_src( const algo::strptr& target ,const algo::strptr& src ) {
    return tempstr() << target <<'/'<< src ;
}

// --- sampdb.Targsrc..ReadFieldMaybe
bool sampdb::Targsrc_ReadFieldMaybe(sampdb::Targsrc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    sampdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case sampdb_FieldId_targsrc: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsrc, strval);
        } break;
        case sampdb_FieldId_pre: {
            retval = bool_ReadStrptrMaybe(parent.pre, strval);
        } break;
        case sampdb_FieldId_target: {
            retval = false;
        } break;
        case sampdb_FieldId_src: {
            retval = false;
        } break;
        case sampdb_FieldId_rec: {
            retval = bool_ReadStrptrMaybe(parent.rec, strval);
        } break;
        case sampdb_FieldId_comment: {
            retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval);
        } break;
        default: {
            retval = false;
            algo_lib::AppendErrtext("comment", "unrecognized attr");
        } break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- sampdb.Targsrc..ReadStrptrMaybe
// Read fields of sampdb::Targsrc from an ascii string.
// The format of the string is an ssim Tuple
bool sampdb::Targsrc_ReadStrptrMaybe(sampdb::Targsrc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "sampdb.targsrc") || algo::StripTypeTag(in_str, "sampdb.Targsrc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsrc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- sampdb.Targsrc..Print
// print string representation of ROW to string STR
// cfmt:sampdb.Targsrc.String  printfmt:Tuple
void sampdb::Targsrc_Print(sampdb::Targsrc& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "sampdb.targsrc";

    algo::Smallstr50_Print(row.targsrc, temp);
    PrintAttrSpaceReset(str,"targsrc", temp);

    bool_Print(row.pre, temp);
    PrintAttrSpaceReset(str,"pre", temp);

    bool_Print(row.rec, temp);
    PrintAttrSpaceReset(str,"rec", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- sampdb...SizeCheck
inline static void sampdb::SizeCheck() {
}
