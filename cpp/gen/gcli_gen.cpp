//
// cpp/gen/gcli_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/gcli_gen.h"
#include "include/gen/gcli_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/gclidb_gen.h"
#include "include/gen/gclidb_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
gcli::FDb       gcli::_db;        // dependency found via dev.targdep

namespace gcli {
const char *gcli_help =
"gcli: Gcli - gitlab/github command-line client\n"
"Usage: gcli [[-selector:]<string>] [[-fields:]<string>] [options]\n"
"    OPTION                     TYPE    DFLT       COMMENT\n"
"    -in                        string  \"data\"     Input directory or filename, - for stdin\n"
"    [selector]                 string  \"issue:%\"  table:key, where table is issue,repo,mr, etc. and key is a regex.\n"
"    [fields]...                string             additional key:value pairs for use with -create, -list, -update\n"
"    -accept                                       (action) accept a slected merge request\n"
"    -start                                        (action) start working on a selected issue\n"
"    -list                                         (action) show selected table\n"
"    -create                                       (action) create a table record(s)\n"
"    -update                                       (action) update fields of a selected issue or mergereq\n"
"    -approve                                      (action) remove draft desiognation from mergereq\n"
"    -needs_work                                   (action) reopen an issue or put a draft designation on mergereq\n"
"    -stop                                         (action) closes an issue, or remove mr branch after review\n"
"    -t                                            Tree view: expand issue description\n"
"    -e                                            edit the input\n"
"    -authdir                   string  \".ssim\"    (setup) Input directory for auth data\n"
"    -dry_run                                      Print actions, do not perform\n"
"    -gitdir                    string  \"\"         (setup) Change directory of git repository\n"
"    -show_gitlab_system_notes                     (misc) Show issue and mr notes created by gitlab\n"
"    -verbose                   int                Verbosity level (0..255); alias -v; cumulative\n"
"    -debug                     int                Debug level (0..255); alias -d; cumulative\n"
"    -help                                         Print help and exit; alias -h\n"
"    -version                                      Print version and exit\n"
"    -signature                                    Show signatures and exit; alias -sig\n"
;


} // namespace gcli
namespace gcli { // gen:ns_print_proto
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          gtype_InputMaybe(gclidb::Gtype &elem) __attribute__((nothrow));
    static bool          grepossh_InputMaybe(gclidb::Grepossh &elem) __attribute__((nothrow));
    static bool          grepogitport_InputMaybe(gclidb::Grepogitport &elem) __attribute__((nothrow));
    static bool          gstatet_InputMaybe(gclidb::Gstatet &elem) __attribute__((nothrow));
    static bool          gmethod_InputMaybe(gclidb::Gmethod &elem) __attribute__((nothrow));
    static bool          gclicmdt_InputMaybe(gclidb::Gclicmdt &elem) __attribute__((nothrow));
    static bool          gclicmdf2j_InputMaybe(gclidb::Gclicmdf2j &elem) __attribute__((nothrow));
    static void          gclicmd_LoadStatic() __attribute__((nothrow));
    static bool          gtypeh_InputMaybe(gclidb::Gtypeh &elem) __attribute__((nothrow));
    static bool          grepo_InputMaybe(gclidb::Grepo &elem) __attribute__((nothrow));
    static bool          gtypeprefix_InputMaybe(gclidb::Gtypeprefix &elem) __attribute__((nothrow));
    static void          gtblact_LoadStatic() __attribute__((nothrow));
    static bool          gtblactfld_InputMaybe(gclidb::Gtblactfld &elem) __attribute__((nothrow));
    static bool          gfld_InputMaybe(gclidb::Gfld &elem) __attribute__((nothrow));
    static bool          gtbl_InputMaybe(gclidb::Gtbl &elem) __attribute__((nothrow));
    static bool          gact_InputMaybe(gclidb::Gact &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- gcli.trace..Print
// print string representation of gcli::trace to string LHS, no header -- cprint:gcli.trace.String
void gcli::trace_Print(gcli::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gcli.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- gcli.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     gcli.FDb.cmdline
//     algo_lib.FDb.cmdline
void gcli::ReadArgv() {
    command::gcli &cmd = gcli::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    int anonidx=0;
    algo::strptr nextanon = command::gcli_GetAnon(cmd, anonidx);
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::gcli_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"gcli: unknown option "<<Keyval("value",arg)<<eol;
            } else {
                if (isanon) {
                    if (attrname == nextanon) { // treat named anon (positional) argument as unnamed
                        attrname = ""; // treat it as unnamed
                    } else if (nextanon != "") { // disallow out-of-order anon (positional) args
                        err<<"gcli: error at "<<algo::strptr_ToSsim(arg)<<": must be preceded by [-"<<nextanon<<"]"<<eol;
                    }
                }
            }
        }
        // look up anon field name based on index
        // anon fields are only allowed in the leaf ns, never base
        if (ch_N(attrname) == 0) {
            attrname = nextanon;
            nextanon = command::gcli_GetAnon(cmd, ++anonidx);
            command::FieldId_ReadStrptrMaybe(attrid,attrname);
            whichns=1;
        }
        if (ch_N(attrname) == 0) {
            err << "gcli: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::gcli_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"gcli: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(gcli_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
    vrfy(gcli::LoadTuplesMaybe(cmd.in,true)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
}

// --- gcli.FDb._db.MainLoop
// Main loop.
void gcli::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        gcli::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- gcli.FDb._db.Step
// Main step
void gcli::Step() {
}

// --- gcli.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void gcli::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("gcli", gcli::InsertStrptrMaybe, NULL, gcli::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "gcli.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(gcli::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)gcli::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'gcli.Input'  signature:'11a9aa9a5e538f546927ef1802bd464c4e5842b9'");
}

// --- gcli.FDb._db.StaticCheck
void gcli::StaticCheck() {
    algo_assert(sizeof(gcli::gclicmd_step_hook) == 8); // csize:gcli.gclicmd_step_hook
    algo_assert(sizeof(gcli::gtblact_step_hook) == 8); // csize:gcli.gtblact_step_hook
    algo_assert(_offset_of(gcli::FieldId, value) + sizeof(((gcli::FieldId*)0)->value) == sizeof(gcli::FieldId));
}

// --- gcli.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool gcli::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    gcli::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case gcli_TableId_gclidb_Gtype: { // finput:gcli.FDb.gtype
            gclidb::Gtype elem;
            retval = gclidb::Gtype_ReadStrptrMaybe(elem, str);
            retval = retval && gtype_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Grepossh: { // finput:gcli.FDb.grepossh
            gclidb::Grepossh elem;
            retval = gclidb::Grepossh_ReadStrptrMaybe(elem, str);
            retval = retval && grepossh_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Grepogitport: { // finput:gcli.FDb.grepogitport
            gclidb::Grepogitport elem;
            retval = gclidb::Grepogitport_ReadStrptrMaybe(elem, str);
            retval = retval && grepogitport_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gstatet: { // finput:gcli.FDb.gstatet
            gclidb::Gstatet elem;
            retval = gclidb::Gstatet_ReadStrptrMaybe(elem, str);
            retval = retval && gstatet_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gmethod: { // finput:gcli.FDb.gmethod
            gclidb::Gmethod elem;
            retval = gclidb::Gmethod_ReadStrptrMaybe(elem, str);
            retval = retval && gmethod_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gclicmdt: { // finput:gcli.FDb.gclicmdt
            gclidb::Gclicmdt elem;
            retval = gclidb::Gclicmdt_ReadStrptrMaybe(elem, str);
            retval = retval && gclicmdt_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gclicmdf2j: { // finput:gcli.FDb.gclicmdf2j
            gclidb::Gclicmdf2j elem;
            retval = gclidb::Gclicmdf2j_ReadStrptrMaybe(elem, str);
            retval = retval && gclicmdf2j_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gtypeh: { // finput:gcli.FDb.gtypeh
            gclidb::Gtypeh elem;
            retval = gclidb::Gtypeh_ReadStrptrMaybe(elem, str);
            retval = retval && gtypeh_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Grepo: { // finput:gcli.FDb.grepo
            gclidb::Grepo elem;
            retval = gclidb::Grepo_ReadStrptrMaybe(elem, str);
            retval = retval && grepo_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gtypeprefix: { // finput:gcli.FDb.gtypeprefix
            gclidb::Gtypeprefix elem;
            retval = gclidb::Gtypeprefix_ReadStrptrMaybe(elem, str);
            retval = retval && gtypeprefix_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gtblactfld: { // finput:gcli.FDb.gtblactfld
            gclidb::Gtblactfld elem;
            retval = gclidb::Gtblactfld_ReadStrptrMaybe(elem, str);
            retval = retval && gtblactfld_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gfld: { // finput:gcli.FDb.gfld
            gclidb::Gfld elem;
            retval = gclidb::Gfld_ReadStrptrMaybe(elem, str);
            retval = retval && gfld_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gtbl: { // finput:gcli.FDb.gtbl
            gclidb::Gtbl elem;
            retval = gclidb::Gtbl_ReadStrptrMaybe(elem, str);
            retval = retval && gtbl_InputMaybe(elem);
            break;
        }
        case gcli_TableId_gclidb_Gact: { // finput:gcli.FDb.gact
            gclidb::Gact elem;
            retval = gclidb::Gact_ReadStrptrMaybe(elem, str);
            retval = retval && gact_InputMaybe(elem);
            break;
        }
        default:
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- gcli.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool gcli::LoadTuplesMaybe(algo::strptr root, bool recursive) {
    bool retval = true;
    if (FileQ(root)) {
        retval = gcli::LoadTuplesFile(root, recursive);
    } else if (root == "-") {
        retval = gcli::LoadTuplesFd(algo::Fildes(0),"(stdin)",recursive);
    } else if (DirectoryQ(root)) {
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gtype"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gtypeprefix"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gtypeh"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gfld"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gact"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gtbl"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gtblactfld"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gstatet"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.grepossh"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.grepogitport"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.grepo"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gmethod"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gclicmdt"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"gclidb.gclicmdf2j"),recursive);
        retval = retval && gcli::LoadTuplesFile(algo::SsimFname(root,"dmmeta.dispsigcheck"),recursive);
    } else {
        algo_lib::SaveBadTag("path", root);
        algo_lib::SaveBadTag("comment", "Wrong working directory?");
        retval = false;
    }
    return retval;
}

// --- gcli.FDb._db.LoadTuplesFile
// Load all finputs from given file.
bool gcli::LoadTuplesFile(algo::strptr fname, bool recursive) {
    bool retval = true;
    algo_lib::FFildes fildes;
    fildes.fd = OpenRead(fname,algo_FileFlags__throw);
    retval = LoadTuplesFd(fildes.fd, fname, recursive);
    return retval;
}

// --- gcli.FDb._db.LoadTuplesFd
// Load all finputs from given file descriptor.
bool gcli::LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) {
    bool retval = true;
    ind_beg(algo::FileLine_curs,line,fd) {
        if (recursive) {
            retval = retval && algo_lib::InsertStrptrMaybe(line);
        }
        retval = retval && gcli::InsertStrptrMaybe(line);
        if (!retval) {
            algo_lib::_db.errtext << eol
            << fname << ":"
            << (ind_curs(line).i+1)
            << ": " << line << eol;
            break;
        }
    }ind_end;
    return retval;
}

// --- gcli.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool gcli::LoadSsimfileMaybe(algo::strptr fname, bool recursive) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = gcli::LoadTuplesFile(fname, recursive);
    }
    return retval;
}

// --- gcli.FDb._db.Steps
// Calls Step function of dependencies
void gcli::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- gcli.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- gcli.FDb.gtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtype& gcli::gtype_Alloc() {
    gcli::FGtype* row = gtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtype* gcli::gtype_AllocMaybe() {
    gcli::FGtype *row = (gcli::FGtype*)gtype_AllocMem();
    if (row) {
        new (row) gcli::FGtype; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtype* gcli::gtype_InsertMaybe(const gclidb::Gtype &value) {
    gcli::FGtype *row = &gtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtype_CopyIn(*row,const_cast<gclidb::Gtype&>(value));
    bool ok = gtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtype_AllocMem() {
    u64 new_nelems     = _db.gtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtype_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtype*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtype) * (u64(1)<<bsr));
            _db.gtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtype.RemoveAll
// Remove all elements from Lary
void gcli::gtype_RemoveAll() {
    for (u64 n = _db.gtype_n; n>0; ) {
        n--;
        gtype_qFind(u64(n)).~FGtype(); // destroy last element
        _db.gtype_n = i32(n);
    }
}

// --- gcli.FDb.gtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtype_RemoveLast() {
    u64 n = _db.gtype_n;
    if (n > 0) {
        n -= 1;
        gtype_qFind(u64(n)).~FGtype();
        _db.gtype_n = i32(n);
    }
}

// --- gcli.FDb.gtype.InputMaybe
static bool gcli::gtype_InputMaybe(gclidb::Gtype &elem) {
    bool retval = true;
    retval = gtype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtype_XrefMaybe(gcli::FGtype &row) {
    bool retval = true;
    (void)row;
    // insert gtype into index ind_gtype
    if (true) { // user-defined insert condition
        bool success = ind_gtype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.grepossh.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepossh& gcli::grepossh_Alloc() {
    gcli::FGrepossh* row = grepossh_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.grepossh  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.grepossh.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepossh* gcli::grepossh_AllocMaybe() {
    gcli::FGrepossh *row = (gcli::FGrepossh*)grepossh_AllocMem();
    if (row) {
        new (row) gcli::FGrepossh; // call constructor
    }
    return row;
}

// --- gcli.FDb.grepossh.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepossh* gcli::grepossh_InsertMaybe(const gclidb::Grepossh &value) {
    gcli::FGrepossh *row = &grepossh_Alloc(); // if out of memory, process dies. if input error, return NULL.
    grepossh_CopyIn(*row,const_cast<gclidb::Grepossh&>(value));
    bool ok = grepossh_XrefMaybe(*row); // this may return false
    if (!ok) {
        grepossh_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.grepossh.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::grepossh_AllocMem() {
    u64 new_nelems     = _db.grepossh_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGrepossh*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.grepossh_lary[bsr];
        if (!lev) {
            lev=(gcli::FGrepossh*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepossh) * (u64(1)<<bsr));
            _db.grepossh_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.grepossh_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.grepossh.RemoveAll
// Remove all elements from Lary
void gcli::grepossh_RemoveAll() {
    for (u64 n = _db.grepossh_n; n>0; ) {
        n--;
        grepossh_qFind(u64(n)).~FGrepossh(); // destroy last element
        _db.grepossh_n = i32(n);
    }
}

// --- gcli.FDb.grepossh.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::grepossh_RemoveLast() {
    u64 n = _db.grepossh_n;
    if (n > 0) {
        n -= 1;
        grepossh_qFind(u64(n)).~FGrepossh();
        _db.grepossh_n = i32(n);
    }
}

// --- gcli.FDb.grepossh.InputMaybe
static bool gcli::grepossh_InputMaybe(gclidb::Grepossh &elem) {
    bool retval = true;
    retval = grepossh_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.grepossh.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::grepossh_XrefMaybe(gcli::FGrepossh &row) {
    bool retval = true;
    (void)row;
    // insert grepossh into index ind_grepossh
    if (true) { // user-defined insert condition
        bool success = ind_grepossh_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_grepossh"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.grepogitport.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepogitport& gcli::grepogitport_Alloc() {
    gcli::FGrepogitport* row = grepogitport_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.grepogitport  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.grepogitport.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepogitport* gcli::grepogitport_AllocMaybe() {
    gcli::FGrepogitport *row = (gcli::FGrepogitport*)grepogitport_AllocMem();
    if (row) {
        new (row) gcli::FGrepogitport; // call constructor
    }
    return row;
}

// --- gcli.FDb.grepogitport.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepogitport* gcli::grepogitport_InsertMaybe(const gclidb::Grepogitport &value) {
    gcli::FGrepogitport *row = &grepogitport_Alloc(); // if out of memory, process dies. if input error, return NULL.
    grepogitport_CopyIn(*row,const_cast<gclidb::Grepogitport&>(value));
    bool ok = grepogitport_XrefMaybe(*row); // this may return false
    if (!ok) {
        grepogitport_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.grepogitport.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::grepogitport_AllocMem() {
    u64 new_nelems     = _db.grepogitport_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGrepogitport*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.grepogitport_lary[bsr];
        if (!lev) {
            lev=(gcli::FGrepogitport*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepogitport) * (u64(1)<<bsr));
            _db.grepogitport_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.grepogitport_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.grepogitport.RemoveAll
// Remove all elements from Lary
void gcli::grepogitport_RemoveAll() {
    for (u64 n = _db.grepogitport_n; n>0; ) {
        n--;
        grepogitport_qFind(u64(n)).~FGrepogitport(); // destroy last element
        _db.grepogitport_n = i32(n);
    }
}

// --- gcli.FDb.grepogitport.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::grepogitport_RemoveLast() {
    u64 n = _db.grepogitport_n;
    if (n > 0) {
        n -= 1;
        grepogitport_qFind(u64(n)).~FGrepogitport();
        _db.grepogitport_n = i32(n);
    }
}

// --- gcli.FDb.grepogitport.InputMaybe
static bool gcli::grepogitport_InputMaybe(gclidb::Grepogitport &elem) {
    bool retval = true;
    retval = grepogitport_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.grepogitport.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::grepogitport_XrefMaybe(gcli::FGrepogitport &row) {
    bool retval = true;
    (void)row;
    // insert grepogitport into index ind_grepogitport
    if (true) { // user-defined insert condition
        bool success = ind_grepogitport_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_grepogitport"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.githost.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGithost& gcli::githost_Alloc() {
    gcli::FGithost* row = githost_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.githost  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.githost.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGithost* gcli::githost_AllocMaybe() {
    gcli::FGithost *row = (gcli::FGithost*)githost_AllocMem();
    if (row) {
        new (row) gcli::FGithost; // call constructor
    }
    return row;
}

// --- gcli.FDb.githost.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::githost_AllocMem() {
    u64 new_nelems     = _db.githost_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGithost*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.githost_lary[bsr];
        if (!lev) {
            lev=(gcli::FGithost*)algo_lib::malloc_AllocMem(sizeof(gcli::FGithost) * (u64(1)<<bsr));
            _db.githost_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.githost_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.githost.RemoveAll
// Remove all elements from Lary
void gcli::githost_RemoveAll() {
    for (u64 n = _db.githost_n; n>0; ) {
        n--;
        githost_qFind(u64(n)).~FGithost(); // destroy last element
        _db.githost_n = i32(n);
    }
}

// --- gcli.FDb.githost.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::githost_RemoveLast() {
    u64 n = _db.githost_n;
    if (n > 0) {
        n -= 1;
        githost_qFind(u64(n)).~FGithost();
        _db.githost_n = i32(n);
    }
}

// --- gcli.FDb.githost.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::githost_XrefMaybe(gcli::FGithost &row) {
    bool retval = true;
    (void)row;
    // insert githost into index ind_githost
    if (true) { // user-defined insert condition
        bool success = ind_githost_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_githost"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gstatet.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGstatet& gcli::gstatet_Alloc() {
    gcli::FGstatet* row = gstatet_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gstatet  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gstatet.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGstatet* gcli::gstatet_AllocMaybe() {
    gcli::FGstatet *row = (gcli::FGstatet*)gstatet_AllocMem();
    if (row) {
        new (row) gcli::FGstatet; // call constructor
    }
    return row;
}

// --- gcli.FDb.gstatet.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGstatet* gcli::gstatet_InsertMaybe(const gclidb::Gstatet &value) {
    gcli::FGstatet *row = &gstatet_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gstatet_CopyIn(*row,const_cast<gclidb::Gstatet&>(value));
    bool ok = gstatet_XrefMaybe(*row); // this may return false
    if (!ok) {
        gstatet_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gstatet.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gstatet_AllocMem() {
    u64 new_nelems     = _db.gstatet_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGstatet*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gstatet_lary[bsr];
        if (!lev) {
            lev=(gcli::FGstatet*)algo_lib::malloc_AllocMem(sizeof(gcli::FGstatet) * (u64(1)<<bsr));
            _db.gstatet_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gstatet_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gstatet.RemoveAll
// Remove all elements from Lary
void gcli::gstatet_RemoveAll() {
    for (u64 n = _db.gstatet_n; n>0; ) {
        n--;
        gstatet_qFind(u64(n)).~FGstatet(); // destroy last element
        _db.gstatet_n = i32(n);
    }
}

// --- gcli.FDb.gstatet.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gstatet_RemoveLast() {
    u64 n = _db.gstatet_n;
    if (n > 0) {
        n -= 1;
        gstatet_qFind(u64(n)).~FGstatet();
        _db.gstatet_n = i32(n);
    }
}

// --- gcli.FDb.gstatet.InputMaybe
static bool gcli::gstatet_InputMaybe(gclidb::Gstatet &elem) {
    bool retval = true;
    retval = gstatet_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gstatet.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gstatet_XrefMaybe(gcli::FGstatet &row) {
    bool retval = true;
    (void)row;
    // insert gstatet into index ind_gstatet
    if (true) { // user-defined insert condition
        bool success = ind_gstatet_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gstatet"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gmethod.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGmethod& gcli::gmethod_Alloc() {
    gcli::FGmethod* row = gmethod_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gmethod  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gmethod.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGmethod* gcli::gmethod_AllocMaybe() {
    gcli::FGmethod *row = (gcli::FGmethod*)gmethod_AllocMem();
    if (row) {
        new (row) gcli::FGmethod; // call constructor
    }
    return row;
}

// --- gcli.FDb.gmethod.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGmethod* gcli::gmethod_InsertMaybe(const gclidb::Gmethod &value) {
    gcli::FGmethod *row = &gmethod_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gmethod_CopyIn(*row,const_cast<gclidb::Gmethod&>(value));
    bool ok = gmethod_XrefMaybe(*row); // this may return false
    if (!ok) {
        gmethod_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gmethod.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gmethod_AllocMem() {
    u64 new_nelems     = _db.gmethod_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGmethod*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gmethod_lary[bsr];
        if (!lev) {
            lev=(gcli::FGmethod*)algo_lib::malloc_AllocMem(sizeof(gcli::FGmethod) * (u64(1)<<bsr));
            _db.gmethod_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gmethod_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gmethod.RemoveAll
// Remove all elements from Lary
void gcli::gmethod_RemoveAll() {
    for (u64 n = _db.gmethod_n; n>0; ) {
        n--;
        gmethod_qFind(u64(n)).~FGmethod(); // destroy last element
        _db.gmethod_n = i32(n);
    }
}

// --- gcli.FDb.gmethod.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gmethod_RemoveLast() {
    u64 n = _db.gmethod_n;
    if (n > 0) {
        n -= 1;
        gmethod_qFind(u64(n)).~FGmethod();
        _db.gmethod_n = i32(n);
    }
}

// --- gcli.FDb.gmethod.InputMaybe
static bool gcli::gmethod_InputMaybe(gclidb::Gmethod &elem) {
    bool retval = true;
    retval = gmethod_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gmethod.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gmethod_XrefMaybe(gcli::FGmethod &row) {
    bool retval = true;
    (void)row;
    // insert gmethod into index ind_gmethod
    if (true) { // user-defined insert condition
        bool success = ind_gmethod_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gmethod"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gclicmdt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdt& gcli::gclicmdt_Alloc() {
    gcli::FGclicmdt* row = gclicmdt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdt  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdt* gcli::gclicmdt_AllocMaybe() {
    gcli::FGclicmdt *row = (gcli::FGclicmdt*)gclicmdt_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdt; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmdt* gcli::gclicmdt_InsertMaybe(const gclidb::Gclicmdt &value) {
    gcli::FGclicmdt *row = &gclicmdt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gclicmdt_CopyIn(*row,const_cast<gclidb::Gclicmdt&>(value));
    bool ok = gclicmdt_XrefMaybe(*row); // this may return false
    if (!ok) {
        gclicmdt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gclicmdt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdt_AllocMem() {
    u64 new_nelems     = _db.gclicmdt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdt_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdt*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdt) * (u64(1)<<bsr));
            _db.gclicmdt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdt.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdt_RemoveAll() {
    for (u64 n = _db.gclicmdt_n; n>0; ) {
        n--;
        gclicmdt_qFind(u64(n)).~FGclicmdt(); // destroy last element
        _db.gclicmdt_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdt_RemoveLast() {
    u64 n = _db.gclicmdt_n;
    if (n > 0) {
        n -= 1;
        gclicmdt_qFind(u64(n)).~FGclicmdt();
        _db.gclicmdt_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdt.InputMaybe
static bool gcli::gclicmdt_InputMaybe(gclidb::Gclicmdt &elem) {
    bool retval = true;
    retval = gclicmdt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gclicmdt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdt_XrefMaybe(gcli::FGclicmdt &row) {
    bool retval = true;
    (void)row;
    gcli::FGclicmd* p_gclicmd = gcli::ind_gclicmd_Find(gclicmd_Get(row));
    if (UNLIKELY(!p_gclicmd)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gclicmd" << Keyval("key", gclicmd_Get(row));
        return false;
    }
    // gclicmdt: save pointer to gclicmd
    if (true) { // user-defined insert condition
        row.p_gclicmd = p_gclicmd;
    }
    gcli::FGtype* p_gtype = gcli::ind_gtype_Find(gtype_Get(row));
    if (UNLIKELY(!p_gtype)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gtype" << Keyval("key", gtype_Get(row));
        return false;
    }
    // gclicmdt: save pointer to gtype
    if (true) { // user-defined insert condition
        row.p_gtype = p_gtype;
    }
    // insert gclicmdt into index ind_gclicmdt
    if (true) { // user-defined insert condition
        bool success = ind_gclicmdt_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmdt"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gclicmdf.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdf& gcli::gclicmdf_Alloc() {
    gcli::FGclicmdf* row = gclicmdf_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdf  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdf.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdf* gcli::gclicmdf_AllocMaybe() {
    gcli::FGclicmdf *row = (gcli::FGclicmdf*)gclicmdf_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdf; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdf.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdf_AllocMem() {
    u64 new_nelems     = _db.gclicmdf_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdf*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdf_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdf*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdf) * (u64(1)<<bsr));
            _db.gclicmdf_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdf_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdf.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdf_RemoveAll() {
    for (u64 n = _db.gclicmdf_n; n>0; ) {
        n--;
        gclicmdf_qFind(u64(n)).~FGclicmdf(); // destroy last element
        _db.gclicmdf_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdf_RemoveLast() {
    u64 n = _db.gclicmdf_n;
    if (n > 0) {
        n -= 1;
        gclicmdf_qFind(u64(n)).~FGclicmdf();
        _db.gclicmdf_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdf.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdf_XrefMaybe(gcli::FGclicmdf &row) {
    bool retval = true;
    (void)row;
    // insert gclicmdf into index ind_gclicmdf
    if (true) { // user-defined insert condition
        bool success = ind_gclicmdf_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmdf"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gclicmdf2j.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdf2j& gcli::gclicmdf2j_Alloc() {
    gcli::FGclicmdf2j* row = gclicmdf2j_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdf2j  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdf2j.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdf2j* gcli::gclicmdf2j_AllocMaybe() {
    gcli::FGclicmdf2j *row = (gcli::FGclicmdf2j*)gclicmdf2j_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdf2j; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdf2j.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmdf2j* gcli::gclicmdf2j_InsertMaybe(const gclidb::Gclicmdf2j &value) {
    gcli::FGclicmdf2j *row = &gclicmdf2j_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gclicmdf2j_CopyIn(*row,const_cast<gclidb::Gclicmdf2j&>(value));
    bool ok = gclicmdf2j_XrefMaybe(*row); // this may return false
    if (!ok) {
        gclicmdf2j_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gclicmdf2j.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdf2j_AllocMem() {
    u64 new_nelems     = _db.gclicmdf2j_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdf2j*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdf2j_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdf2j*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdf2j) * (u64(1)<<bsr));
            _db.gclicmdf2j_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdf2j_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdf2j.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdf2j_RemoveAll() {
    for (u64 n = _db.gclicmdf2j_n; n>0; ) {
        n--;
        gclicmdf2j_qFind(u64(n)).~FGclicmdf2j(); // destroy last element
        _db.gclicmdf2j_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdf2j.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdf2j_RemoveLast() {
    u64 n = _db.gclicmdf2j_n;
    if (n > 0) {
        n -= 1;
        gclicmdf2j_qFind(u64(n)).~FGclicmdf2j();
        _db.gclicmdf2j_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdf2j.InputMaybe
static bool gcli::gclicmdf2j_InputMaybe(gclidb::Gclicmdf2j &elem) {
    bool retval = true;
    retval = gclicmdf2j_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gclicmdf2j.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdf2j_XrefMaybe(gcli::FGclicmdf2j &row) {
    bool retval = true;
    (void)row;
    gcli::FGclicmd* p_gclicmd = gcli::ind_gclicmd_Find(gclicmd_Get(row));
    if (UNLIKELY(!p_gclicmd)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gclicmd" << Keyval("key", gclicmd_Get(row));
        return false;
    }
    // gclicmdf2j: save pointer to gclicmd
    if (true) { // user-defined insert condition
        row.p_gclicmd = p_gclicmd;
    }
    // insert gclicmdf2j into index c_gclicmdf2j
    if (true) { // user-defined insert condition
        c_gclicmdf2j_Insert(*p_gclicmd, row);
    }
    return retval;
}

// --- gcli.FDb.gclicmd.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmd& gcli::gclicmd_Alloc() {
    gcli::FGclicmd* row = gclicmd_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmd  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmd.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmd* gcli::gclicmd_AllocMaybe() {
    gcli::FGclicmd *row = (gcli::FGclicmd*)gclicmd_AllocMem();
    if (row) {
        new (row) gcli::FGclicmd; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmd.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmd* gcli::gclicmd_InsertMaybe(const gclidb::Gclicmd &value) {
    gcli::FGclicmd *row = &gclicmd_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gclicmd_CopyIn(*row,const_cast<gclidb::Gclicmd&>(value));
    bool ok = gclicmd_XrefMaybe(*row); // this may return false
    if (!ok) {
        gclicmd_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gclicmd.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmd_AllocMem() {
    u64 new_nelems     = _db.gclicmd_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmd*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmd_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmd*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmd) * (u64(1)<<bsr));
            _db.gclicmd_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmd_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmd.RemoveAll
// Remove all elements from Lary
void gcli::gclicmd_RemoveAll() {
    for (u64 n = _db.gclicmd_n; n>0; ) {
        n--;
        gclicmd_qFind(u64(n)).~FGclicmd(); // destroy last element
        _db.gclicmd_n = i32(n);
    }
}

// --- gcli.FDb.gclicmd.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmd_RemoveLast() {
    u64 n = _db.gclicmd_n;
    if (n > 0) {
        n -= 1;
        gclicmd_qFind(u64(n)).~FGclicmd();
        _db.gclicmd_n = i32(n);
    }
}

// --- gcli.FDb.gclicmd.LoadStatic
static void gcli::gclicmd_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)(gcli::FGclicmd&);
    } data[] = {
        { "gclidb.gclicmd  gclicmd:graphql  gclicmdf2j:graphql  comment:\"act via graphql\"", gcli::gclicmd_graphql }
        ,{ "gclidb.gclicmd  gclicmd:issueadd  gclicmdf2j:issuelist  comment:\"add new issue\"", gcli::gclicmd_issueadd }
        ,{ "gclidb.gclicmd  gclicmd:issuelist  gclicmdf2j:issuelist  comment:\"display the list of issues\"", gcli::gclicmd_issuelist }
        ,{ "gclidb.gclicmd  gclicmd:issuemod  gclicmdf2j:issuelist  comment:\"modify an issue\"", gcli::gclicmd_issuemod }
        ,{ "gclidb.gclicmd  gclicmd:issuenote  gclicmdf2j:issuenote  comment:\"display the list of an issue notes\"", gcli::gclicmd_issuenote }
        ,{ "gclidb.gclicmd  gclicmd:issuesearch  gclicmdf2j:issuesearch  comment:\"display the list of issues\"", gcli::gclicmd_issuesearch }
        ,{ "gclidb.gclicmd  gclicmd:mraccept  gclicmdf2j:mrlist  comment:\"accept merge request\"", gcli::gclicmd_mraccept }
        ,{ "gclidb.gclicmd  gclicmd:mrlist  gclicmdf2j:mrlist  comment:\"display the list of merge requests\"", gcli::gclicmd_mrlist }
        ,{ "gclidb.gclicmd  gclicmd:mrlistdet  gclicmdf2j:mrlist  comment:\"get merge request details\"", gcli::gclicmd_mrlistdet }
        ,{ "gclidb.gclicmd  gclicmd:mrmod  gclicmdf2j:mrlist  comment:\"update merge request\"", gcli::gclicmd_mrmod }
        ,{ "gclidb.gclicmd  gclicmd:mrnote  gclicmdf2j:mrnote  comment:\"display the list of an mr notes\"", gcli::gclicmd_mrnote }
        ,{ "gclidb.gclicmd  gclicmd:mrnoteadd  gclicmdf2j:mrnoteadd  comment:\"add mr note\"", gcli::gclicmd_mrnoteadd }
        ,{ "gclidb.gclicmd  gclicmd:mrnotemod  gclicmdf2j:mrnotemod  comment:\"modify mr note\"", gcli::gclicmd_mrnotemod }
        ,{ "gclidb.gclicmd  gclicmd:mrreq  gclicmdf2j:mrlist  comment:\"submit merge request\"", gcli::gclicmd_mrreq }
        ,{ "gclidb.gclicmd  gclicmd:mrreview  gclicmdf2j:mrlist  comment:\"add a single reviewer\"", gcli::gclicmd_mrreview }
        ,{ "gclidb.gclicmd  gclicmd:mrreviewrm  gclicmdf2j:mrlist  comment:\"remove a single reviewer\"", gcli::gclicmd_mrreviewrm }
        ,{ "gclidb.gclicmd  gclicmd:mrsearch  gclicmdf2j:mrsearch  comment:\"display the list of merge requests\"", gcli::gclicmd_mrsearch }
        ,{ "gclidb.gclicmd  gclicmd:mslist  gclicmdf2j:mslist  comment:\"display the list of milestones\"", gcli::gclicmd_mslist }
        ,{ "gclidb.gclicmd  gclicmd:noteadd  gclicmdf2j:noteadd  comment:\"add issue note\"", gcli::gclicmd_noteadd }
        ,{ "gclidb.gclicmd  gclicmd:notemod  gclicmdf2j:notemod  comment:\"modify issue notes\"", gcli::gclicmd_notemod }
        ,{ "gclidb.gclicmd  gclicmd:repojob  gclicmdf2j:repojob  comment:\"jobs list\"", gcli::gclicmd_repojob }
        ,{ "gclidb.gclicmd  gclicmd:repojobtrace  gclicmdf2j:repojobtrace  comment:\"job trace\"", gcli::gclicmd_repojobtrace }
        ,{ "gclidb.gclicmd  gclicmd:token2repos  gclicmdf2j:token2repos  comment:\"init token etc info based on auth_token and host\"", gcli::gclicmd_token2repos }
        ,{ "gclidb.gclicmd  gclicmd:user  gclicmdf2j:userlist  comment:\"get the current logged in user\"", gcli::gclicmd_user }
        ,{ "gclidb.gclicmd  gclicmd:userdet  gclicmdf2j:userlist  comment:\"display user details (name)\"", gcli::gclicmd_userdet }
        ,{ "gclidb.gclicmd  gclicmd:userlist  gclicmdf2j:userlist  comment:\"display the list of users\"", gcli::gclicmd_userlist }
        ,{NULL, NULL}
    };
    (void)data;
    gclidb::Gclicmd gclicmd;
    for (int i=0; data[i].s; i++) {
        (void)gclidb::Gclicmd_ReadStrptrMaybe(gclicmd, algo::strptr(data[i].s));
        gcli::FGclicmd *elem = gclicmd_InsertMaybe(gclicmd);
        vrfy(elem, tempstr("gcli.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- gcli.FDb.gclicmd.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmd_XrefMaybe(gcli::FGclicmd &row) {
    bool retval = true;
    (void)row;
    // insert gclicmd into index ind_gclicmd
    if (true) { // user-defined insert condition
        bool success = ind_gclicmd_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmd"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gtypeh.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtypeh& gcli::gtypeh_Alloc() {
    gcli::FGtypeh* row = gtypeh_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtypeh  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtypeh.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtypeh* gcli::gtypeh_AllocMaybe() {
    gcli::FGtypeh *row = (gcli::FGtypeh*)gtypeh_AllocMem();
    if (row) {
        new (row) gcli::FGtypeh; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtypeh.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtypeh* gcli::gtypeh_InsertMaybe(const gclidb::Gtypeh &value) {
    gcli::FGtypeh *row = &gtypeh_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtypeh_CopyIn(*row,const_cast<gclidb::Gtypeh&>(value));
    bool ok = gtypeh_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtypeh_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtypeh.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtypeh_AllocMem() {
    u64 new_nelems     = _db.gtypeh_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtypeh*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtypeh_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtypeh*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtypeh) * (u64(1)<<bsr));
            _db.gtypeh_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtypeh_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtypeh.RemoveAll
// Remove all elements from Lary
void gcli::gtypeh_RemoveAll() {
    for (u64 n = _db.gtypeh_n; n>0; ) {
        n--;
        gtypeh_qFind(u64(n)).~FGtypeh(); // destroy last element
        _db.gtypeh_n = i32(n);
    }
}

// --- gcli.FDb.gtypeh.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtypeh_RemoveLast() {
    u64 n = _db.gtypeh_n;
    if (n > 0) {
        n -= 1;
        gtypeh_qFind(u64(n)).~FGtypeh();
        _db.gtypeh_n = i32(n);
    }
}

// --- gcli.FDb.gtypeh.InputMaybe
static bool gcli::gtypeh_InputMaybe(gclidb::Gtypeh &elem) {
    bool retval = true;
    retval = gtypeh_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gtypeh.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtypeh_XrefMaybe(gcli::FGtypeh &row) {
    bool retval = true;
    (void)row;
    gcli::FGtype* p_gtype = gcli::ind_gtype_Find(gtype_Get(row));
    if (UNLIKELY(!p_gtype)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gtype" << Keyval("key", gtype_Get(row));
        return false;
    }
    // insert gtypeh into index c_gtypeh
    if (true) { // user-defined insert condition
        c_gtypeh_Insert(*p_gtype, row);
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmd.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmd* gcli::ind_gclicmd_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmd_buckets_n - 1);
    gcli::FGclicmd* *e = &_db.ind_gclicmd_buckets_elems[index];
    gcli::FGclicmd* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmd == key;
        if (done) break;
        e         = &ret->ind_gclicmd_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmd.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmd& gcli::ind_gclicmd_FindX(const algo::strptr& key) {
    gcli::FGclicmd* ret = ind_gclicmd_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmd  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmd.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmd& gcli::ind_gclicmd_GetOrCreate(const algo::strptr& key) {
    gcli::FGclicmd* ret = ind_gclicmd_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gclicmd_Alloc();
        (*ret).gclicmd = key;
        bool good = gclicmd_XrefMaybe(*ret);
        if (!good) {
            gclicmd_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gclicmd  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmd.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmd_InsertMaybe(gcli::FGclicmd& row) {
    ind_gclicmd_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmd_next == (gcli::FGclicmd*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmd) & (_db.ind_gclicmd_buckets_n - 1);
        gcli::FGclicmd* *prev = &_db.ind_gclicmd_buckets_elems[index];
        do {
            gcli::FGclicmd* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmd == row.gclicmd) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmd_next;
        } while (true);
        if (retval) {
            row.ind_gclicmd_next = *prev;
            _db.ind_gclicmd_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmd.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmd_Remove(gcli::FGclicmd& row) {
    if (LIKELY(row.ind_gclicmd_next != (gcli::FGclicmd*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmd) & (_db.ind_gclicmd_buckets_n - 1);
        gcli::FGclicmd* *prev = &_db.ind_gclicmd_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmd *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmd_next; // unlink (singly linked list)
                _db.ind_gclicmd_n--;
                row.ind_gclicmd_next = (gcli::FGclicmd*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmd_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmd.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmd_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmd_buckets_n;
    u32 new_nelems   = _db.ind_gclicmd_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmd*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmd*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmd* *new_buckets = (gcli::FGclicmd**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmd");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmd_buckets_n; i++) {
            gcli::FGclicmd* elem = _db.ind_gclicmd_buckets_elems[i];
            while (elem) {
                gcli::FGclicmd &row        = *elem;
                gcli::FGclicmd* next       = row.ind_gclicmd_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmd) & (new_nbuckets-1);
                row.ind_gclicmd_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmd_buckets_elems, old_size);
        _db.ind_gclicmd_buckets_elems = new_buckets;
        _db.ind_gclicmd_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gclicmdf.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmdf* gcli::ind_gclicmdf_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmdf_buckets_n - 1);
    gcli::FGclicmdf* *e = &_db.ind_gclicmdf_buckets_elems[index];
    gcli::FGclicmdf* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmdf == key;
        if (done) break;
        e         = &ret->ind_gclicmdf_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmdf.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdf& gcli::ind_gclicmdf_FindX(const algo::strptr& key) {
    gcli::FGclicmdf* ret = ind_gclicmdf_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmdf  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdf.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdf& gcli::ind_gclicmdf_GetOrCreate(const algo::strptr& key) {
    gcli::FGclicmdf* ret = ind_gclicmdf_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gclicmdf_Alloc();
        (*ret).gclicmdf = key;
        bool good = gclicmdf_XrefMaybe(*ret);
        if (!good) {
            gclicmdf_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gclicmdf  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdf.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmdf_InsertMaybe(gcli::FGclicmdf& row) {
    ind_gclicmdf_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmdf_next == (gcli::FGclicmdf*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdf) & (_db.ind_gclicmdf_buckets_n - 1);
        gcli::FGclicmdf* *prev = &_db.ind_gclicmdf_buckets_elems[index];
        do {
            gcli::FGclicmdf* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmdf == row.gclicmdf) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmdf_next;
        } while (true);
        if (retval) {
            row.ind_gclicmdf_next = *prev;
            _db.ind_gclicmdf_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdf.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmdf_Remove(gcli::FGclicmdf& row) {
    if (LIKELY(row.ind_gclicmdf_next != (gcli::FGclicmdf*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdf) & (_db.ind_gclicmdf_buckets_n - 1);
        gcli::FGclicmdf* *prev = &_db.ind_gclicmdf_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmdf *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmdf_next; // unlink (singly linked list)
                _db.ind_gclicmdf_n--;
                row.ind_gclicmdf_next = (gcli::FGclicmdf*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmdf_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmdf.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmdf_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmdf_buckets_n;
    u32 new_nelems   = _db.ind_gclicmdf_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmdf*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmdf*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmdf* *new_buckets = (gcli::FGclicmdf**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmdf");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmdf_buckets_n; i++) {
            gcli::FGclicmdf* elem = _db.ind_gclicmdf_buckets_elems[i];
            while (elem) {
                gcli::FGclicmdf &row        = *elem;
                gcli::FGclicmdf* next       = row.ind_gclicmdf_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmdf) & (new_nbuckets-1);
                row.ind_gclicmdf_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmdf_buckets_elems, old_size);
        _db.ind_gclicmdf_buckets_elems = new_buckets;
        _db.ind_gclicmdf_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gclicmdt.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmdt* gcli::ind_gclicmdt_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmdt_buckets_n - 1);
    gcli::FGclicmdt* *e = &_db.ind_gclicmdt_buckets_elems[index];
    gcli::FGclicmdt* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmdt == key;
        if (done) break;
        e         = &ret->ind_gclicmdt_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmdt.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdt& gcli::ind_gclicmdt_FindX(const algo::strptr& key) {
    gcli::FGclicmdt* ret = ind_gclicmdt_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmdt  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdt.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmdt_InsertMaybe(gcli::FGclicmdt& row) {
    ind_gclicmdt_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmdt_next == (gcli::FGclicmdt*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdt) & (_db.ind_gclicmdt_buckets_n - 1);
        gcli::FGclicmdt* *prev = &_db.ind_gclicmdt_buckets_elems[index];
        do {
            gcli::FGclicmdt* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmdt == row.gclicmdt) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmdt_next;
        } while (true);
        if (retval) {
            row.ind_gclicmdt_next = *prev;
            _db.ind_gclicmdt_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdt.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmdt_Remove(gcli::FGclicmdt& row) {
    if (LIKELY(row.ind_gclicmdt_next != (gcli::FGclicmdt*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdt) & (_db.ind_gclicmdt_buckets_n - 1);
        gcli::FGclicmdt* *prev = &_db.ind_gclicmdt_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmdt *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmdt_next; // unlink (singly linked list)
                _db.ind_gclicmdt_n--;
                row.ind_gclicmdt_next = (gcli::FGclicmdt*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmdt_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmdt.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmdt_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmdt_buckets_n;
    u32 new_nelems   = _db.ind_gclicmdt_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmdt*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmdt*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmdt* *new_buckets = (gcli::FGclicmdt**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmdt");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmdt_buckets_n; i++) {
            gcli::FGclicmdt* elem = _db.ind_gclicmdt_buckets_elems[i];
            while (elem) {
                gcli::FGclicmdt &row        = *elem;
                gcli::FGclicmdt* next       = row.ind_gclicmdt_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmdt) & (new_nbuckets-1);
                row.ind_gclicmdt_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmdt_buckets_elems, old_size);
        _db.ind_gclicmdt_buckets_elems = new_buckets;
        _db.ind_gclicmdt_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gmethod.Find
// Find row by key. Return NULL if not found.
gcli::FGmethod* gcli::ind_gmethod_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gmethod_buckets_n - 1);
    gcli::FGmethod* *e = &_db.ind_gmethod_buckets_elems[index];
    gcli::FGmethod* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gmethod == key;
        if (done) break;
        e         = &ret->ind_gmethod_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gmethod.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGmethod& gcli::ind_gmethod_FindX(const algo::strptr& key) {
    gcli::FGmethod* ret = ind_gmethod_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gmethod  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gmethod.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGmethod& gcli::ind_gmethod_GetOrCreate(const algo::strptr& key) {
    gcli::FGmethod* ret = ind_gmethod_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gmethod_Alloc();
        (*ret).gmethod = key;
        bool good = gmethod_XrefMaybe(*ret);
        if (!good) {
            gmethod_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gmethod  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gmethod.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gmethod_InsertMaybe(gcli::FGmethod& row) {
    ind_gmethod_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gmethod_next == (gcli::FGmethod*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gmethod) & (_db.ind_gmethod_buckets_n - 1);
        gcli::FGmethod* *prev = &_db.ind_gmethod_buckets_elems[index];
        do {
            gcli::FGmethod* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gmethod == row.gmethod) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gmethod_next;
        } while (true);
        if (retval) {
            row.ind_gmethod_next = *prev;
            _db.ind_gmethod_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gmethod.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gmethod_Remove(gcli::FGmethod& row) {
    if (LIKELY(row.ind_gmethod_next != (gcli::FGmethod*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gmethod) & (_db.ind_gmethod_buckets_n - 1);
        gcli::FGmethod* *prev = &_db.ind_gmethod_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGmethod *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gmethod_next; // unlink (singly linked list)
                _db.ind_gmethod_n--;
                row.ind_gmethod_next = (gcli::FGmethod*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gmethod_next;
        }
    }
}

// --- gcli.FDb.ind_gmethod.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gmethod_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gmethod_buckets_n;
    u32 new_nelems   = _db.ind_gmethod_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGmethod*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGmethod*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGmethod* *new_buckets = (gcli::FGmethod**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gmethod");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gmethod_buckets_n; i++) {
            gcli::FGmethod* elem = _db.ind_gmethod_buckets_elems[i];
            while (elem) {
                gcli::FGmethod &row        = *elem;
                gcli::FGmethod* next       = row.ind_gmethod_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gmethod) & (new_nbuckets-1);
                row.ind_gmethod_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gmethod_buckets_elems, old_size);
        _db.ind_gmethod_buckets_elems = new_buckets;
        _db.ind_gmethod_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_grepo.Find
// Find row by key. Return NULL if not found.
gcli::FGrepo* gcli::ind_grepo_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_grepo_buckets_n - 1);
    gcli::FGrepo* *e = &_db.ind_grepo_buckets_elems[index];
    gcli::FGrepo* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).grepo == key;
        if (done) break;
        e         = &ret->ind_grepo_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_grepo.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepo& gcli::ind_grepo_FindX(const algo::strptr& key) {
    gcli::FGrepo* ret = ind_grepo_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_grepo  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_grepo.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepo& gcli::ind_grepo_GetOrCreate(const algo::strptr& key) {
    gcli::FGrepo* ret = ind_grepo_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &grepo_Alloc();
        (*ret).grepo = key;
        bool good = grepo_XrefMaybe(*ret);
        if (!good) {
            grepo_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_grepo  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_grepo.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_grepo_InsertMaybe(gcli::FGrepo& row) {
    ind_grepo_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_grepo_next == (gcli::FGrepo*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.grepo) & (_db.ind_grepo_buckets_n - 1);
        gcli::FGrepo* *prev = &_db.ind_grepo_buckets_elems[index];
        do {
            gcli::FGrepo* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).grepo == row.grepo) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_grepo_next;
        } while (true);
        if (retval) {
            row.ind_grepo_next = *prev;
            _db.ind_grepo_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_grepo.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_grepo_Remove(gcli::FGrepo& row) {
    if (LIKELY(row.ind_grepo_next != (gcli::FGrepo*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.grepo) & (_db.ind_grepo_buckets_n - 1);
        gcli::FGrepo* *prev = &_db.ind_grepo_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGrepo *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_grepo_next; // unlink (singly linked list)
                _db.ind_grepo_n--;
                row.ind_grepo_next = (gcli::FGrepo*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_grepo_next;
        }
    }
}

// --- gcli.FDb.ind_grepo.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_grepo_Reserve(int n) {
    u32 old_nbuckets = _db.ind_grepo_buckets_n;
    u32 new_nelems   = _db.ind_grepo_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGrepo*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGrepo*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGrepo* *new_buckets = (gcli::FGrepo**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_grepo");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_grepo_buckets_n; i++) {
            gcli::FGrepo* elem = _db.ind_grepo_buckets_elems[i];
            while (elem) {
                gcli::FGrepo &row        = *elem;
                gcli::FGrepo* next       = row.ind_grepo_next;
                u32 index          = algo::Smallstr250_Hash(0, row.grepo) & (new_nbuckets-1);
                row.ind_grepo_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_grepo_buckets_elems, old_size);
        _db.ind_grepo_buckets_elems = new_buckets;
        _db.ind_grepo_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_issue.Find
// Find row by key. Return NULL if not found.
gcli::FIssue* gcli::ind_issue_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_issue_buckets_n - 1);
    gcli::FIssue* *e = &_db.ind_issue_buckets_elems[index];
    gcli::FIssue* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).issue == key;
        if (done) break;
        e         = &ret->ind_issue_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_issue.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FIssue& gcli::ind_issue_FindX(const algo::strptr& key) {
    gcli::FIssue* ret = ind_issue_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_issue  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_issue.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FIssue& gcli::ind_issue_GetOrCreate(const algo::strptr& key) {
    gcli::FIssue* ret = ind_issue_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &issue_Alloc();
        (*ret).issue = key;
        bool good = issue_XrefMaybe(*ret);
        if (!good) {
            issue_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_issue  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_issue.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_issue_InsertMaybe(gcli::FIssue& row) {
    ind_issue_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_issue_next == (gcli::FIssue*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
        gcli::FIssue* *prev = &_db.ind_issue_buckets_elems[index];
        do {
            gcli::FIssue* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).issue == row.issue) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_issue_next;
        } while (true);
        if (retval) {
            row.ind_issue_next = *prev;
            _db.ind_issue_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_issue.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_issue_Remove(gcli::FIssue& row) {
    if (LIKELY(row.ind_issue_next != (gcli::FIssue*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
        gcli::FIssue* *prev = &_db.ind_issue_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FIssue *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_issue_next; // unlink (singly linked list)
                _db.ind_issue_n--;
                row.ind_issue_next = (gcli::FIssue*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_issue_next;
        }
    }
}

// --- gcli.FDb.ind_issue.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_issue_Reserve(int n) {
    u32 old_nbuckets = _db.ind_issue_buckets_n;
    u32 new_nelems   = _db.ind_issue_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FIssue*);
        u32 new_size = new_nbuckets * sizeof(gcli::FIssue*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FIssue* *new_buckets = (gcli::FIssue**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_issue");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_issue_buckets_n; i++) {
            gcli::FIssue* elem = _db.ind_issue_buckets_elems[i];
            while (elem) {
                gcli::FIssue &row        = *elem;
                gcli::FIssue* next       = row.ind_issue_next;
                u32 index          = algo::Smallstr50_Hash(0, row.issue) & (new_nbuckets-1);
                row.ind_issue_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_issue_buckets_elems, old_size);
        _db.ind_issue_buckets_elems = new_buckets;
        _db.ind_issue_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.regx_repo.Print
// Print back to string
void gcli::regx_repo_Print(algo::cstring &out) {
    Regx_Print(_db.regx_repo, out);
}

// --- gcli.FDb.ind_gstatet.Find
// Find row by key. Return NULL if not found.
gcli::FGstatet* gcli::ind_gstatet_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gstatet_buckets_n - 1);
    gcli::FGstatet* *e = &_db.ind_gstatet_buckets_elems[index];
    gcli::FGstatet* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gstatet == key;
        if (done) break;
        e         = &ret->ind_gstatet_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gstatet.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGstatet& gcli::ind_gstatet_FindX(const algo::strptr& key) {
    gcli::FGstatet* ret = ind_gstatet_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gstatet  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gstatet.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGstatet& gcli::ind_gstatet_GetOrCreate(const algo::strptr& key) {
    gcli::FGstatet* ret = ind_gstatet_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gstatet_Alloc();
        (*ret).gstatet = key;
        bool good = gstatet_XrefMaybe(*ret);
        if (!good) {
            gstatet_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gstatet  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gstatet.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gstatet_InsertMaybe(gcli::FGstatet& row) {
    ind_gstatet_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gstatet_next == (gcli::FGstatet*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gstatet) & (_db.ind_gstatet_buckets_n - 1);
        gcli::FGstatet* *prev = &_db.ind_gstatet_buckets_elems[index];
        do {
            gcli::FGstatet* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gstatet == row.gstatet) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gstatet_next;
        } while (true);
        if (retval) {
            row.ind_gstatet_next = *prev;
            _db.ind_gstatet_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gstatet.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gstatet_Remove(gcli::FGstatet& row) {
    if (LIKELY(row.ind_gstatet_next != (gcli::FGstatet*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gstatet) & (_db.ind_gstatet_buckets_n - 1);
        gcli::FGstatet* *prev = &_db.ind_gstatet_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGstatet *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gstatet_next; // unlink (singly linked list)
                _db.ind_gstatet_n--;
                row.ind_gstatet_next = (gcli::FGstatet*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gstatet_next;
        }
    }
}

// --- gcli.FDb.ind_gstatet.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gstatet_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gstatet_buckets_n;
    u32 new_nelems   = _db.ind_gstatet_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGstatet*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGstatet*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGstatet* *new_buckets = (gcli::FGstatet**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gstatet");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gstatet_buckets_n; i++) {
            gcli::FGstatet* elem = _db.ind_gstatet_buckets_elems[i];
            while (elem) {
                gcli::FGstatet &row        = *elem;
                gcli::FGstatet* next       = row.ind_gstatet_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gstatet) & (new_nbuckets-1);
                row.ind_gstatet_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gstatet_buckets_elems, old_size);
        _db.ind_gstatet_buckets_elems = new_buckets;
        _db.ind_gstatet_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_githost.Find
// Find row by key. Return NULL if not found.
gcli::FGithost* gcli::ind_githost_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_githost_buckets_n - 1);
    gcli::FGithost* *e = &_db.ind_githost_buckets_elems[index];
    gcli::FGithost* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).githost == key;
        if (done) break;
        e         = &ret->ind_githost_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_githost.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGithost& gcli::ind_githost_FindX(const algo::strptr& key) {
    gcli::FGithost* ret = ind_githost_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_githost  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_githost.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGithost& gcli::ind_githost_GetOrCreate(const algo::strptr& key) {
    gcli::FGithost* ret = ind_githost_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &githost_Alloc();
        (*ret).githost = key;
        bool good = githost_XrefMaybe(*ret);
        if (!good) {
            githost_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_githost  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_githost.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_githost_InsertMaybe(gcli::FGithost& row) {
    ind_githost_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_githost_next == (gcli::FGithost*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.githost) & (_db.ind_githost_buckets_n - 1);
        gcli::FGithost* *prev = &_db.ind_githost_buckets_elems[index];
        do {
            gcli::FGithost* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).githost == row.githost) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_githost_next;
        } while (true);
        if (retval) {
            row.ind_githost_next = *prev;
            _db.ind_githost_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_githost.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_githost_Remove(gcli::FGithost& row) {
    if (LIKELY(row.ind_githost_next != (gcli::FGithost*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.githost) & (_db.ind_githost_buckets_n - 1);
        gcli::FGithost* *prev = &_db.ind_githost_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGithost *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_githost_next; // unlink (singly linked list)
                _db.ind_githost_n--;
                row.ind_githost_next = (gcli::FGithost*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_githost_next;
        }
    }
}

// --- gcli.FDb.ind_githost.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_githost_Reserve(int n) {
    u32 old_nbuckets = _db.ind_githost_buckets_n;
    u32 new_nelems   = _db.ind_githost_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGithost*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGithost*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGithost* *new_buckets = (gcli::FGithost**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_githost");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_githost_buckets_n; i++) {
            gcli::FGithost* elem = _db.ind_githost_buckets_elems[i];
            while (elem) {
                gcli::FGithost &row        = *elem;
                gcli::FGithost* next       = row.ind_githost_next;
                u32 index          = algo::Smallstr250_Hash(0, row.githost) & (new_nbuckets-1);
                row.ind_githost_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_githost_buckets_elems, old_size);
        _db.ind_githost_buckets_elems = new_buckets;
        _db.ind_githost_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_grepogitport.Find
// Find row by key. Return NULL if not found.
gcli::FGrepogitport* gcli::ind_grepogitport_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_grepogitport_buckets_n - 1);
    gcli::FGrepogitport* *e = &_db.ind_grepogitport_buckets_elems[index];
    gcli::FGrepogitport* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).grepogitport == key;
        if (done) break;
        e         = &ret->ind_grepogitport_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_grepogitport.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepogitport& gcli::ind_grepogitport_FindX(const algo::strptr& key) {
    gcli::FGrepogitport* ret = ind_grepogitport_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_grepogitport  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_grepogitport.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepogitport& gcli::ind_grepogitport_GetOrCreate(const algo::strptr& key) {
    gcli::FGrepogitport* ret = ind_grepogitport_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &grepogitport_Alloc();
        (*ret).grepogitport = key;
        bool good = grepogitport_XrefMaybe(*ret);
        if (!good) {
            grepogitport_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_grepogitport  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_grepogitport.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_grepogitport_InsertMaybe(gcli::FGrepogitport& row) {
    ind_grepogitport_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_grepogitport_next == (gcli::FGrepogitport*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.grepogitport) & (_db.ind_grepogitport_buckets_n - 1);
        gcli::FGrepogitport* *prev = &_db.ind_grepogitport_buckets_elems[index];
        do {
            gcli::FGrepogitport* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).grepogitport == row.grepogitport) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_grepogitport_next;
        } while (true);
        if (retval) {
            row.ind_grepogitport_next = *prev;
            _db.ind_grepogitport_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_grepogitport.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_grepogitport_Remove(gcli::FGrepogitport& row) {
    if (LIKELY(row.ind_grepogitport_next != (gcli::FGrepogitport*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.grepogitport) & (_db.ind_grepogitport_buckets_n - 1);
        gcli::FGrepogitport* *prev = &_db.ind_grepogitport_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGrepogitport *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_grepogitport_next; // unlink (singly linked list)
                _db.ind_grepogitport_n--;
                row.ind_grepogitport_next = (gcli::FGrepogitport*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_grepogitport_next;
        }
    }
}

// --- gcli.FDb.ind_grepogitport.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_grepogitport_Reserve(int n) {
    u32 old_nbuckets = _db.ind_grepogitport_buckets_n;
    u32 new_nelems   = _db.ind_grepogitport_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGrepogitport*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGrepogitport*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGrepogitport* *new_buckets = (gcli::FGrepogitport**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_grepogitport");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_grepogitport_buckets_n; i++) {
            gcli::FGrepogitport* elem = _db.ind_grepogitport_buckets_elems[i];
            while (elem) {
                gcli::FGrepogitport &row        = *elem;
                gcli::FGrepogitport* next       = row.ind_grepogitport_next;
                u32 index          = algo::Smallstr50_Hash(0, row.grepogitport) & (new_nbuckets-1);
                row.ind_grepogitport_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_grepogitport_buckets_elems, old_size);
        _db.ind_grepogitport_buckets_elems = new_buckets;
        _db.ind_grepogitport_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_grepossh.Find
// Find row by key. Return NULL if not found.
gcli::FGrepossh* gcli::ind_grepossh_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_grepossh_buckets_n - 1);
    gcli::FGrepossh* *e = &_db.ind_grepossh_buckets_elems[index];
    gcli::FGrepossh* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).grepossh == key;
        if (done) break;
        e         = &ret->ind_grepossh_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_grepossh.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepossh& gcli::ind_grepossh_FindX(const algo::strptr& key) {
    gcli::FGrepossh* ret = ind_grepossh_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_grepossh  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_grepossh.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepossh& gcli::ind_grepossh_GetOrCreate(const algo::strptr& key) {
    gcli::FGrepossh* ret = ind_grepossh_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &grepossh_Alloc();
        (*ret).grepossh = key;
        bool good = grepossh_XrefMaybe(*ret);
        if (!good) {
            grepossh_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_grepossh  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_grepossh.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_grepossh_InsertMaybe(gcli::FGrepossh& row) {
    ind_grepossh_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_grepossh_next == (gcli::FGrepossh*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.grepossh) & (_db.ind_grepossh_buckets_n - 1);
        gcli::FGrepossh* *prev = &_db.ind_grepossh_buckets_elems[index];
        do {
            gcli::FGrepossh* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).grepossh == row.grepossh) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_grepossh_next;
        } while (true);
        if (retval) {
            row.ind_grepossh_next = *prev;
            _db.ind_grepossh_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_grepossh.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_grepossh_Remove(gcli::FGrepossh& row) {
    if (LIKELY(row.ind_grepossh_next != (gcli::FGrepossh*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.grepossh) & (_db.ind_grepossh_buckets_n - 1);
        gcli::FGrepossh* *prev = &_db.ind_grepossh_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGrepossh *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_grepossh_next; // unlink (singly linked list)
                _db.ind_grepossh_n--;
                row.ind_grepossh_next = (gcli::FGrepossh*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_grepossh_next;
        }
    }
}

// --- gcli.FDb.ind_grepossh.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_grepossh_Reserve(int n) {
    u32 old_nbuckets = _db.ind_grepossh_buckets_n;
    u32 new_nelems   = _db.ind_grepossh_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGrepossh*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGrepossh*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGrepossh* *new_buckets = (gcli::FGrepossh**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_grepossh");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_grepossh_buckets_n; i++) {
            gcli::FGrepossh* elem = _db.ind_grepossh_buckets_elems[i];
            while (elem) {
                gcli::FGrepossh &row        = *elem;
                gcli::FGrepossh* next       = row.ind_grepossh_next;
                u32 index          = algo::Smallstr50_Hash(0, row.grepossh) & (new_nbuckets-1);
                row.ind_grepossh_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_grepossh_buckets_elems, old_size);
        _db.ind_grepossh_buckets_elems = new_buckets;
        _db.ind_grepossh_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gtype.Find
// Find row by key. Return NULL if not found.
gcli::FGtype* gcli::ind_gtype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gtype_buckets_n - 1);
    gcli::FGtype* *e = &_db.ind_gtype_buckets_elems[index];
    gcli::FGtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gtype == key;
        if (done) break;
        e         = &ret->ind_gtype_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gtype.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGtype& gcli::ind_gtype_FindX(const algo::strptr& key) {
    gcli::FGtype* ret = ind_gtype_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gtype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gtype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtype& gcli::ind_gtype_GetOrCreate(const algo::strptr& key) {
    gcli::FGtype* ret = ind_gtype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gtype_Alloc();
        (*ret).gtype = key;
        bool good = gtype_XrefMaybe(*ret);
        if (!good) {
            gtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gtype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gtype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gtype_InsertMaybe(gcli::FGtype& row) {
    ind_gtype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gtype_next == (gcli::FGtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtype) & (_db.ind_gtype_buckets_n - 1);
        gcli::FGtype* *prev = &_db.ind_gtype_buckets_elems[index];
        do {
            gcli::FGtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gtype == row.gtype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gtype_next;
        } while (true);
        if (retval) {
            row.ind_gtype_next = *prev;
            _db.ind_gtype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gtype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gtype_Remove(gcli::FGtype& row) {
    if (LIKELY(row.ind_gtype_next != (gcli::FGtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtype) & (_db.ind_gtype_buckets_n - 1);
        gcli::FGtype* *prev = &_db.ind_gtype_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gtype_next; // unlink (singly linked list)
                _db.ind_gtype_n--;
                row.ind_gtype_next = (gcli::FGtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gtype_next;
        }
    }
}

// --- gcli.FDb.ind_gtype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gtype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gtype_buckets_n;
    u32 new_nelems   = _db.ind_gtype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGtype*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGtype* *new_buckets = (gcli::FGtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gtype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gtype_buckets_n; i++) {
            gcli::FGtype* elem = _db.ind_gtype_buckets_elems[i];
            while (elem) {
                gcli::FGtype &row        = *elem;
                gcli::FGtype* next       = row.ind_gtype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gtype) & (new_nbuckets-1);
                row.ind_gtype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gtype_buckets_elems, old_size);
        _db.ind_gtype_buckets_elems = new_buckets;
        _db.ind_gtype_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.c_gclicmd.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmd_Insert(gcli::FGclicmd& row) {
    if (bool_Update(row._db_c_gclicmd_in_ary,true)) {
        // reserve space
        c_gclicmd_Reserve(1);
        u32 n  = _db.c_gclicmd_n;
        u32 at = n;
        gcli::FGclicmd* *elems = _db.c_gclicmd_elems;
        elems[at] = &row;
        _db.c_gclicmd_n = n+1;

    }
}

// --- gcli.FDb.c_gclicmd.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmd_InsertMaybe(gcli::FGclicmd& row) {
    bool retval = !row._db_c_gclicmd_in_ary;
    c_gclicmd_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FDb.c_gclicmd.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmd_Remove(gcli::FGclicmd& row) {
    if (bool_Update(row._db_c_gclicmd_in_ary,false)) {
        int lim = _db.c_gclicmd_n;
        gcli::FGclicmd* *elems = _db.c_gclicmd_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGclicmd* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGclicmd*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_gclicmd_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FDb.c_gclicmd.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmd_Reserve(u32 n) {
    u32 old_max = _db.c_gclicmd_max;
    if (UNLIKELY(_db.c_gclicmd_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmd*);
        u32 new_size = new_max * sizeof(gcli::FGclicmd*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.c_gclicmd_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.c_gclicmd");
        }
        _db.c_gclicmd_elems = (gcli::FGclicmd**)new_mem;
        _db.c_gclicmd_max = new_max;
    }
}

// --- gcli.FDb.gclicmdj2f.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdj2f& gcli::gclicmdj2f_Alloc() {
    gcli::FGclicmdj2f* row = gclicmdj2f_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdj2f  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdj2f.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdj2f* gcli::gclicmdj2f_AllocMaybe() {
    gcli::FGclicmdj2f *row = (gcli::FGclicmdj2f*)gclicmdj2f_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdj2f; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdj2f.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdj2f_AllocMem() {
    u64 new_nelems     = _db.gclicmdj2f_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdj2f*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdj2f_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdj2f*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdj2f) * (u64(1)<<bsr));
            _db.gclicmdj2f_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdj2f_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdj2f.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdj2f_RemoveAll() {
    for (u64 n = _db.gclicmdj2f_n; n>0; ) {
        n--;
        gclicmdj2f_qFind(u64(n)).~FGclicmdj2f(); // destroy last element
        _db.gclicmdj2f_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdj2f.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdj2f_RemoveLast() {
    u64 n = _db.gclicmdj2f_n;
    if (n > 0) {
        n -= 1;
        gclicmdj2f_qFind(u64(n)).~FGclicmdj2f();
        _db.gclicmdj2f_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdj2f.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdj2f_XrefMaybe(gcli::FGclicmdj2f &row) {
    bool retval = true;
    (void)row;
    // insert gclicmdj2f into index ind_gclicmdj2f
    if (true) { // user-defined insert condition
        bool success = ind_gclicmdj2f_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmdj2f"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gclicmdc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdc& gcli::gclicmdc_Alloc() {
    gcli::FGclicmdc* row = gclicmdc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdc  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdc* gcli::gclicmdc_AllocMaybe() {
    gcli::FGclicmdc *row = (gcli::FGclicmdc*)gclicmdc_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdc; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdc_AllocMem() {
    u64 new_nelems     = _db.gclicmdc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdc_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdc*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdc) * (u64(1)<<bsr));
            _db.gclicmdc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdc.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdc_RemoveAll() {
    for (u64 n = _db.gclicmdc_n; n>0; ) {
        n--;
        gclicmdc_qFind(u64(n)).~FGclicmdc(); // destroy last element
        _db.gclicmdc_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdc_RemoveLast() {
    u64 n = _db.gclicmdc_n;
    if (n > 0) {
        n -= 1;
        gclicmdc_qFind(u64(n)).~FGclicmdc();
        _db.gclicmdc_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdc_XrefMaybe(gcli::FGclicmdc &row) {
    bool retval = true;
    (void)row;
    // insert gclicmdc into index ind_gclicmdc
    if (true) { // user-defined insert condition
        bool success = ind_gclicmdc_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmdc"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gclicmdarg.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdarg& gcli::gclicmdarg_Alloc() {
    gcli::FGclicmdarg* row = gclicmdarg_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gclicmdarg  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gclicmdarg.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdarg* gcli::gclicmdarg_AllocMaybe() {
    gcli::FGclicmdarg *row = (gcli::FGclicmdarg*)gclicmdarg_AllocMem();
    if (row) {
        new (row) gcli::FGclicmdarg; // call constructor
    }
    return row;
}

// --- gcli.FDb.gclicmdarg.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gclicmdarg_AllocMem() {
    u64 new_nelems     = _db.gclicmdarg_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGclicmdarg*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gclicmdarg_lary[bsr];
        if (!lev) {
            lev=(gcli::FGclicmdarg*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdarg) * (u64(1)<<bsr));
            _db.gclicmdarg_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gclicmdarg_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gclicmdarg.RemoveAll
// Remove all elements from Lary
void gcli::gclicmdarg_RemoveAll() {
    for (u64 n = _db.gclicmdarg_n; n>0; ) {
        n--;
        gclicmdarg_qFind(u64(n)).~FGclicmdarg(); // destroy last element
        _db.gclicmdarg_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdarg.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gclicmdarg_RemoveLast() {
    u64 n = _db.gclicmdarg_n;
    if (n > 0) {
        n -= 1;
        gclicmdarg_qFind(u64(n)).~FGclicmdarg();
        _db.gclicmdarg_n = i32(n);
    }
}

// --- gcli.FDb.gclicmdarg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gclicmdarg_XrefMaybe(gcli::FGclicmdarg &row) {
    bool retval = true;
    (void)row;
    // insert gclicmdarg into index ind_gclicmdarg
    if (true) { // user-defined insert condition
        bool success = ind_gclicmdarg_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gclicmdarg"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdj2f.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmdj2f* gcli::ind_gclicmdj2f_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmdj2f_buckets_n - 1);
    gcli::FGclicmdj2f* *e = &_db.ind_gclicmdj2f_buckets_elems[index];
    gcli::FGclicmdj2f* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmdj2f == key;
        if (done) break;
        e         = &ret->ind_gclicmdj2f_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmdj2f.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdj2f& gcli::ind_gclicmdj2f_FindX(const algo::strptr& key) {
    gcli::FGclicmdj2f* ret = ind_gclicmdj2f_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmdj2f  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdj2f.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdj2f& gcli::ind_gclicmdj2f_GetOrCreate(const algo::strptr& key) {
    gcli::FGclicmdj2f* ret = ind_gclicmdj2f_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gclicmdj2f_Alloc();
        (*ret).gclicmdj2f = key;
        bool good = gclicmdj2f_XrefMaybe(*ret);
        if (!good) {
            gclicmdj2f_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gclicmdj2f  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdj2f.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmdj2f_InsertMaybe(gcli::FGclicmdj2f& row) {
    ind_gclicmdj2f_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmdj2f_next == (gcli::FGclicmdj2f*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdj2f) & (_db.ind_gclicmdj2f_buckets_n - 1);
        gcli::FGclicmdj2f* *prev = &_db.ind_gclicmdj2f_buckets_elems[index];
        do {
            gcli::FGclicmdj2f* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmdj2f == row.gclicmdj2f) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmdj2f_next;
        } while (true);
        if (retval) {
            row.ind_gclicmdj2f_next = *prev;
            _db.ind_gclicmdj2f_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdj2f.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmdj2f_Remove(gcli::FGclicmdj2f& row) {
    if (LIKELY(row.ind_gclicmdj2f_next != (gcli::FGclicmdj2f*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdj2f) & (_db.ind_gclicmdj2f_buckets_n - 1);
        gcli::FGclicmdj2f* *prev = &_db.ind_gclicmdj2f_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmdj2f *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmdj2f_next; // unlink (singly linked list)
                _db.ind_gclicmdj2f_n--;
                row.ind_gclicmdj2f_next = (gcli::FGclicmdj2f*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmdj2f_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmdj2f.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmdj2f_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmdj2f_buckets_n;
    u32 new_nelems   = _db.ind_gclicmdj2f_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmdj2f*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmdj2f*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmdj2f* *new_buckets = (gcli::FGclicmdj2f**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmdj2f");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmdj2f_buckets_n; i++) {
            gcli::FGclicmdj2f* elem = _db.ind_gclicmdj2f_buckets_elems[i];
            while (elem) {
                gcli::FGclicmdj2f &row        = *elem;
                gcli::FGclicmdj2f* next       = row.ind_gclicmdj2f_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmdj2f) & (new_nbuckets-1);
                row.ind_gclicmdj2f_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmdj2f_buckets_elems, old_size);
        _db.ind_gclicmdj2f_buckets_elems = new_buckets;
        _db.ind_gclicmdj2f_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gclicmdarg.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmdarg* gcli::ind_gclicmdarg_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmdarg_buckets_n - 1);
    gcli::FGclicmdarg* *e = &_db.ind_gclicmdarg_buckets_elems[index];
    gcli::FGclicmdarg* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmdarg == key;
        if (done) break;
        e         = &ret->ind_gclicmdarg_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmdarg.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdarg& gcli::ind_gclicmdarg_FindX(const algo::strptr& key) {
    gcli::FGclicmdarg* ret = ind_gclicmdarg_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmdarg  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdarg.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdarg& gcli::ind_gclicmdarg_GetOrCreate(const algo::strptr& key) {
    gcli::FGclicmdarg* ret = ind_gclicmdarg_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gclicmdarg_Alloc();
        (*ret).gclicmdarg = key;
        bool good = gclicmdarg_XrefMaybe(*ret);
        if (!good) {
            gclicmdarg_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gclicmdarg  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdarg.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmdarg_InsertMaybe(gcli::FGclicmdarg& row) {
    ind_gclicmdarg_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmdarg_next == (gcli::FGclicmdarg*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdarg) & (_db.ind_gclicmdarg_buckets_n - 1);
        gcli::FGclicmdarg* *prev = &_db.ind_gclicmdarg_buckets_elems[index];
        do {
            gcli::FGclicmdarg* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmdarg == row.gclicmdarg) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmdarg_next;
        } while (true);
        if (retval) {
            row.ind_gclicmdarg_next = *prev;
            _db.ind_gclicmdarg_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdarg.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmdarg_Remove(gcli::FGclicmdarg& row) {
    if (LIKELY(row.ind_gclicmdarg_next != (gcli::FGclicmdarg*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdarg) & (_db.ind_gclicmdarg_buckets_n - 1);
        gcli::FGclicmdarg* *prev = &_db.ind_gclicmdarg_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmdarg *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmdarg_next; // unlink (singly linked list)
                _db.ind_gclicmdarg_n--;
                row.ind_gclicmdarg_next = (gcli::FGclicmdarg*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmdarg_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmdarg.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmdarg_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmdarg_buckets_n;
    u32 new_nelems   = _db.ind_gclicmdarg_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmdarg*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmdarg*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmdarg* *new_buckets = (gcli::FGclicmdarg**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmdarg");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmdarg_buckets_n; i++) {
            gcli::FGclicmdarg* elem = _db.ind_gclicmdarg_buckets_elems[i];
            while (elem) {
                gcli::FGclicmdarg &row        = *elem;
                gcli::FGclicmdarg* next       = row.ind_gclicmdarg_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmdarg) & (new_nbuckets-1);
                row.ind_gclicmdarg_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmdarg_buckets_elems, old_size);
        _db.ind_gclicmdarg_buckets_elems = new_buckets;
        _db.ind_gclicmdarg_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_gclicmdc.Find
// Find row by key. Return NULL if not found.
gcli::FGclicmdc* gcli::ind_gclicmdc_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gclicmdc_buckets_n - 1);
    gcli::FGclicmdc* *e = &_db.ind_gclicmdc_buckets_elems[index];
    gcli::FGclicmdc* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gclicmdc == key;
        if (done) break;
        e         = &ret->ind_gclicmdc_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gclicmdc.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdc& gcli::ind_gclicmdc_FindX(const algo::strptr& key) {
    gcli::FGclicmdc* ret = ind_gclicmdc_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gclicmdc  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdc.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdc& gcli::ind_gclicmdc_GetOrCreate(const algo::strptr& key) {
    gcli::FGclicmdc* ret = ind_gclicmdc_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gclicmdc_Alloc();
        (*ret).gclicmdc = key;
        bool good = gclicmdc_XrefMaybe(*ret);
        if (!good) {
            gclicmdc_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gclicmdc  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gclicmdc.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gclicmdc_InsertMaybe(gcli::FGclicmdc& row) {
    ind_gclicmdc_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gclicmdc_next == (gcli::FGclicmdc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdc) & (_db.ind_gclicmdc_buckets_n - 1);
        gcli::FGclicmdc* *prev = &_db.ind_gclicmdc_buckets_elems[index];
        do {
            gcli::FGclicmdc* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gclicmdc == row.gclicmdc) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gclicmdc_next;
        } while (true);
        if (retval) {
            row.ind_gclicmdc_next = *prev;
            _db.ind_gclicmdc_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gclicmdc.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gclicmdc_Remove(gcli::FGclicmdc& row) {
    if (LIKELY(row.ind_gclicmdc_next != (gcli::FGclicmdc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gclicmdc) & (_db.ind_gclicmdc_buckets_n - 1);
        gcli::FGclicmdc* *prev = &_db.ind_gclicmdc_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGclicmdc *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gclicmdc_next; // unlink (singly linked list)
                _db.ind_gclicmdc_n--;
                row.ind_gclicmdc_next = (gcli::FGclicmdc*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gclicmdc_next;
        }
    }
}

// --- gcli.FDb.ind_gclicmdc.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gclicmdc_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gclicmdc_buckets_n;
    u32 new_nelems   = _db.ind_gclicmdc_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGclicmdc*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGclicmdc*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGclicmdc* *new_buckets = (gcli::FGclicmdc**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gclicmdc");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gclicmdc_buckets_n; i++) {
            gcli::FGclicmdc* elem = _db.ind_gclicmdc_buckets_elems[i];
            while (elem) {
                gcli::FGclicmdc &row        = *elem;
                gcli::FGclicmdc* next       = row.ind_gclicmdc_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gclicmdc) & (new_nbuckets-1);
                row.ind_gclicmdc_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gclicmdc_buckets_elems, old_size);
        _db.ind_gclicmdc_buckets_elems = new_buckets;
        _db.ind_gclicmdc_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.issue.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FIssue& gcli::issue_Alloc() {
    gcli::FIssue* row = issue_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.issue  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.issue.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FIssue* gcli::issue_AllocMaybe() {
    gcli::FIssue *row = (gcli::FIssue*)issue_AllocMem();
    if (row) {
        new (row) gcli::FIssue; // call constructor
    }
    return row;
}

// --- gcli.FDb.issue.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FIssue* gcli::issue_InsertMaybe(const gclidb::Issue &value) {
    gcli::FIssue *row = &issue_Alloc(); // if out of memory, process dies. if input error, return NULL.
    issue_CopyIn(*row,const_cast<gclidb::Issue&>(value));
    bool ok = issue_XrefMaybe(*row); // this may return false
    if (!ok) {
        issue_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.issue.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::issue_AllocMem() {
    u64 new_nelems     = _db.issue_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FIssue*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.issue_lary[bsr];
        if (!lev) {
            lev=(gcli::FIssue*)algo_lib::malloc_AllocMem(sizeof(gcli::FIssue) * (u64(1)<<bsr));
            _db.issue_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.issue_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.issue.RemoveAll
// Remove all elements from Lary
void gcli::issue_RemoveAll() {
    for (u64 n = _db.issue_n; n>0; ) {
        n--;
        issue_qFind(u64(n)).~FIssue(); // destroy last element
        _db.issue_n = i32(n);
    }
}

// --- gcli.FDb.issue.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::issue_RemoveLast() {
    u64 n = _db.issue_n;
    if (n > 0) {
        n -= 1;
        issue_qFind(u64(n)).~FIssue();
        _db.issue_n = i32(n);
    }
}

// --- gcli.FDb.issue.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::issue_XrefMaybe(gcli::FIssue &row) {
    bool retval = true;
    (void)row;
    // insert issue into index ind_issue
    if (true) { // user-defined insert condition
        bool success = ind_issue_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_issue"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.grepo.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepo& gcli::grepo_Alloc() {
    gcli::FGrepo* row = grepo_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.grepo  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.grepo.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepo* gcli::grepo_AllocMaybe() {
    gcli::FGrepo *row = (gcli::FGrepo*)grepo_AllocMem();
    if (row) {
        new (row) gcli::FGrepo; // call constructor
    }
    return row;
}

// --- gcli.FDb.grepo.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepo* gcli::grepo_InsertMaybe(const gclidb::Grepo &value) {
    gcli::FGrepo *row = &grepo_Alloc(); // if out of memory, process dies. if input error, return NULL.
    grepo_CopyIn(*row,const_cast<gclidb::Grepo&>(value));
    bool ok = grepo_XrefMaybe(*row); // this may return false
    if (!ok) {
        grepo_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.grepo.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::grepo_AllocMem() {
    u64 new_nelems     = _db.grepo_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGrepo*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.grepo_lary[bsr];
        if (!lev) {
            lev=(gcli::FGrepo*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepo) * (u64(1)<<bsr));
            _db.grepo_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.grepo_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.grepo.RemoveAll
// Remove all elements from Lary
void gcli::grepo_RemoveAll() {
    for (u64 n = _db.grepo_n; n>0; ) {
        n--;
        grepo_qFind(u64(n)).~FGrepo(); // destroy last element
        _db.grepo_n = i32(n);
    }
}

// --- gcli.FDb.grepo.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::grepo_RemoveLast() {
    u64 n = _db.grepo_n;
    if (n > 0) {
        n -= 1;
        grepo_qFind(u64(n)).~FGrepo();
        _db.grepo_n = i32(n);
    }
}

// --- gcli.FDb.grepo.InputMaybe
static bool gcli::grepo_InputMaybe(gclidb::Grepo &elem) {
    bool retval = true;
    retval = grepo_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.grepo.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::grepo_XrefMaybe(gcli::FGrepo &row) {
    bool retval = true;
    (void)row;
    // insert grepo into index ind_grepo
    if (true) { // user-defined insert condition
        bool success = ind_grepo_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_grepo"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.tuples.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FTuples& gcli::tuples_Alloc() {
    gcli::FTuples* row = tuples_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.tuples  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.tuples.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FTuples* gcli::tuples_AllocMaybe() {
    gcli::FTuples *row = (gcli::FTuples*)tuples_AllocMem();
    if (row) {
        new (row) gcli::FTuples; // call constructor
    }
    return row;
}

// --- gcli.FDb.tuples.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::tuples_AllocMem() {
    u64 new_nelems     = _db.tuples_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FTuples*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tuples_lary[bsr];
        if (!lev) {
            lev=(gcli::FTuples*)algo_lib::malloc_AllocMem(sizeof(gcli::FTuples) * (u64(1)<<bsr));
            _db.tuples_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tuples_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.tuples.RemoveAll
// Remove all elements from Lary
void gcli::tuples_RemoveAll() {
    for (u64 n = _db.tuples_n; n>0; ) {
        n--;
        tuples_qFind(u64(n)).~FTuples(); // destroy last element
        _db.tuples_n = i32(n);
    }
}

// --- gcli.FDb.tuples.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::tuples_RemoveLast() {
    u64 n = _db.tuples_n;
    if (n > 0) {
        n -= 1;
        tuples_qFind(u64(n)).~FTuples();
        _db.tuples_n = i32(n);
    }
}

// --- gcli.FDb.tuples.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::tuples_XrefMaybe(gcli::FTuples &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- gcli.FDb.issuenote.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FIssuenote& gcli::issuenote_Alloc() {
    gcli::FIssuenote* row = issuenote_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.issuenote  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.issuenote.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FIssuenote* gcli::issuenote_AllocMaybe() {
    gcli::FIssuenote *row = (gcli::FIssuenote*)issuenote_AllocMem();
    if (row) {
        new (row) gcli::FIssuenote; // call constructor
    }
    return row;
}

// --- gcli.FDb.issuenote.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FIssuenote* gcli::issuenote_InsertMaybe(const gclidb::Issuenote &value) {
    gcli::FIssuenote *row = &issuenote_Alloc(); // if out of memory, process dies. if input error, return NULL.
    issuenote_CopyIn(*row,const_cast<gclidb::Issuenote&>(value));
    bool ok = issuenote_XrefMaybe(*row); // this may return false
    if (!ok) {
        issuenote_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.issuenote.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::issuenote_AllocMem() {
    u64 new_nelems     = _db.issuenote_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FIssuenote*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.issuenote_lary[bsr];
        if (!lev) {
            lev=(gcli::FIssuenote*)algo_lib::malloc_AllocMem(sizeof(gcli::FIssuenote) * (u64(1)<<bsr));
            _db.issuenote_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.issuenote_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.issuenote.RemoveAll
// Remove all elements from Lary
void gcli::issuenote_RemoveAll() {
    for (u64 n = _db.issuenote_n; n>0; ) {
        n--;
        issuenote_qFind(u64(n)).~FIssuenote(); // destroy last element
        _db.issuenote_n = i32(n);
    }
}

// --- gcli.FDb.issuenote.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::issuenote_RemoveLast() {
    u64 n = _db.issuenote_n;
    if (n > 0) {
        n -= 1;
        issuenote_qFind(u64(n)).~FIssuenote();
        _db.issuenote_n = i32(n);
    }
}

// --- gcli.FDb.issuenote.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::issuenote_XrefMaybe(gcli::FIssuenote &row) {
    bool retval = true;
    (void)row;
    // insert issuenote into index ind_issuenote
    if (true) { // user-defined insert condition
        bool success = ind_issuenote_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_issuenote"; // check for duplicate key
            return false;
        }
    }
    gcli::FIssue* p_issue = gcli::ind_issue_Find(issue_Get(row));
    if (UNLIKELY(!p_issue)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_issue" << Keyval("key", issue_Get(row));
        return false;
    }
    // insert issuenote into index c_issuenote
    if (true) { // user-defined insert condition
        c_issuenote_Insert(*p_issue, row);
    }
    return retval;
}

// --- gcli.FDb.mrjob.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMrjob& gcli::mrjob_Alloc() {
    gcli::FMrjob* row = mrjob_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.mrjob  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.mrjob.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMrjob* gcli::mrjob_AllocMaybe() {
    gcli::FMrjob *row = (gcli::FMrjob*)mrjob_AllocMem();
    if (row) {
        new (row) gcli::FMrjob; // call constructor
    }
    return row;
}

// --- gcli.FDb.mrjob.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMrjob* gcli::mrjob_InsertMaybe(const gclidb::Mrjob &value) {
    gcli::FMrjob *row = &mrjob_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mrjob_CopyIn(*row,const_cast<gclidb::Mrjob&>(value));
    bool ok = mrjob_XrefMaybe(*row); // this may return false
    if (!ok) {
        mrjob_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.mrjob.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::mrjob_AllocMem() {
    u64 new_nelems     = _db.mrjob_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FMrjob*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mrjob_lary[bsr];
        if (!lev) {
            lev=(gcli::FMrjob*)algo_lib::malloc_AllocMem(sizeof(gcli::FMrjob) * (u64(1)<<bsr));
            _db.mrjob_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mrjob_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.mrjob.RemoveAll
// Remove all elements from Lary
void gcli::mrjob_RemoveAll() {
    for (u64 n = _db.mrjob_n; n>0; ) {
        n--;
        mrjob_qFind(u64(n)).~FMrjob(); // destroy last element
        _db.mrjob_n = i32(n);
    }
}

// --- gcli.FDb.mrjob.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::mrjob_RemoveLast() {
    u64 n = _db.mrjob_n;
    if (n > 0) {
        n -= 1;
        mrjob_qFind(u64(n)).~FMrjob();
        _db.mrjob_n = i32(n);
    }
}

// --- gcli.FDb.mrjob.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::mrjob_XrefMaybe(gcli::FMrjob &row) {
    bool retval = true;
    (void)row;
    // insert mrjob into index ind_mrjob
    if (true) { // user-defined insert condition
        bool success = ind_mrjob_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_mrjob"; // check for duplicate key
            return false;
        }
    }
    gcli::FMr* p_mr = gcli::ind_mr_Find(mr_Get(row));
    if (UNLIKELY(!p_mr)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_mr" << Keyval("key", mr_Get(row));
        return false;
    }
    // insert mrjob into index c_mrjob
    if (true) { // user-defined insert condition
        c_mrjob_Insert(*p_mr, row);
    }
    return retval;
}

// --- gcli.FDb.mrnote.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMrnote& gcli::mrnote_Alloc() {
    gcli::FMrnote* row = mrnote_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.mrnote  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.mrnote.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMrnote* gcli::mrnote_AllocMaybe() {
    gcli::FMrnote *row = (gcli::FMrnote*)mrnote_AllocMem();
    if (row) {
        new (row) gcli::FMrnote; // call constructor
    }
    return row;
}

// --- gcli.FDb.mrnote.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMrnote* gcli::mrnote_InsertMaybe(const gclidb::Mrnote &value) {
    gcli::FMrnote *row = &mrnote_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mrnote_CopyIn(*row,const_cast<gclidb::Mrnote&>(value));
    bool ok = mrnote_XrefMaybe(*row); // this may return false
    if (!ok) {
        mrnote_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.mrnote.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::mrnote_AllocMem() {
    u64 new_nelems     = _db.mrnote_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FMrnote*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mrnote_lary[bsr];
        if (!lev) {
            lev=(gcli::FMrnote*)algo_lib::malloc_AllocMem(sizeof(gcli::FMrnote) * (u64(1)<<bsr));
            _db.mrnote_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mrnote_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.mrnote.RemoveAll
// Remove all elements from Lary
void gcli::mrnote_RemoveAll() {
    for (u64 n = _db.mrnote_n; n>0; ) {
        n--;
        mrnote_qFind(u64(n)).~FMrnote(); // destroy last element
        _db.mrnote_n = i32(n);
    }
}

// --- gcli.FDb.mrnote.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::mrnote_RemoveLast() {
    u64 n = _db.mrnote_n;
    if (n > 0) {
        n -= 1;
        mrnote_qFind(u64(n)).~FMrnote();
        _db.mrnote_n = i32(n);
    }
}

// --- gcli.FDb.mrnote.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::mrnote_XrefMaybe(gcli::FMrnote &row) {
    bool retval = true;
    (void)row;
    // insert mrnote into index ind_mrnote
    if (true) { // user-defined insert condition
        bool success = ind_mrnote_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_mrnote"; // check for duplicate key
            return false;
        }
    }
    gcli::FMr* p_mr = gcli::ind_mr_Find(mr_Get(row));
    if (UNLIKELY(!p_mr)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_mr" << Keyval("key", mr_Get(row));
        return false;
    }
    // insert mrnote into index c_mrnote
    if (true) { // user-defined insert condition
        c_mrnote_Insert(*p_mr, row);
    }
    return retval;
}

// --- gcli.FDb.ind_mrnote.Find
// Find row by key. Return NULL if not found.
gcli::FMrnote* gcli::ind_mrnote_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_mrnote_buckets_n - 1);
    gcli::FMrnote* *e = &_db.ind_mrnote_buckets_elems[index];
    gcli::FMrnote* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mrnote == key;
        if (done) break;
        e         = &ret->ind_mrnote_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_mrnote.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FMrnote& gcli::ind_mrnote_FindX(const algo::strptr& key) {
    gcli::FMrnote* ret = ind_mrnote_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_mrnote  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_mrnote.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_mrnote_InsertMaybe(gcli::FMrnote& row) {
    ind_mrnote_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mrnote_next == (gcli::FMrnote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.mrnote) & (_db.ind_mrnote_buckets_n - 1);
        gcli::FMrnote* *prev = &_db.ind_mrnote_buckets_elems[index];
        do {
            gcli::FMrnote* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mrnote == row.mrnote) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mrnote_next;
        } while (true);
        if (retval) {
            row.ind_mrnote_next = *prev;
            _db.ind_mrnote_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_mrnote.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_mrnote_Remove(gcli::FMrnote& row) {
    if (LIKELY(row.ind_mrnote_next != (gcli::FMrnote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.mrnote) & (_db.ind_mrnote_buckets_n - 1);
        gcli::FMrnote* *prev = &_db.ind_mrnote_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FMrnote *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mrnote_next; // unlink (singly linked list)
                _db.ind_mrnote_n--;
                row.ind_mrnote_next = (gcli::FMrnote*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mrnote_next;
        }
    }
}

// --- gcli.FDb.ind_mrnote.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_mrnote_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mrnote_buckets_n;
    u32 new_nelems   = _db.ind_mrnote_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FMrnote*);
        u32 new_size = new_nbuckets * sizeof(gcli::FMrnote*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FMrnote* *new_buckets = (gcli::FMrnote**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_mrnote");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mrnote_buckets_n; i++) {
            gcli::FMrnote* elem = _db.ind_mrnote_buckets_elems[i];
            while (elem) {
                gcli::FMrnote &row        = *elem;
                gcli::FMrnote* next       = row.ind_mrnote_next;
                u32 index          = algo::Smallstr250_Hash(0, row.mrnote) & (new_nbuckets-1);
                row.ind_mrnote_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mrnote_buckets_elems, old_size);
        _db.ind_mrnote_buckets_elems = new_buckets;
        _db.ind_mrnote_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_issuenote.Find
// Find row by key. Return NULL if not found.
gcli::FIssuenote* gcli::ind_issuenote_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_issuenote_buckets_n - 1);
    gcli::FIssuenote* *e = &_db.ind_issuenote_buckets_elems[index];
    gcli::FIssuenote* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).issuenote == key;
        if (done) break;
        e         = &ret->ind_issuenote_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_issuenote.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FIssuenote& gcli::ind_issuenote_FindX(const algo::strptr& key) {
    gcli::FIssuenote* ret = ind_issuenote_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_issuenote  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_issuenote.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_issuenote_InsertMaybe(gcli::FIssuenote& row) {
    ind_issuenote_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_issuenote_next == (gcli::FIssuenote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.issuenote) & (_db.ind_issuenote_buckets_n - 1);
        gcli::FIssuenote* *prev = &_db.ind_issuenote_buckets_elems[index];
        do {
            gcli::FIssuenote* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).issuenote == row.issuenote) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_issuenote_next;
        } while (true);
        if (retval) {
            row.ind_issuenote_next = *prev;
            _db.ind_issuenote_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_issuenote.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_issuenote_Remove(gcli::FIssuenote& row) {
    if (LIKELY(row.ind_issuenote_next != (gcli::FIssuenote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.issuenote) & (_db.ind_issuenote_buckets_n - 1);
        gcli::FIssuenote* *prev = &_db.ind_issuenote_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FIssuenote *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_issuenote_next; // unlink (singly linked list)
                _db.ind_issuenote_n--;
                row.ind_issuenote_next = (gcli::FIssuenote*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_issuenote_next;
        }
    }
}

// --- gcli.FDb.ind_issuenote.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_issuenote_Reserve(int n) {
    u32 old_nbuckets = _db.ind_issuenote_buckets_n;
    u32 new_nelems   = _db.ind_issuenote_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FIssuenote*);
        u32 new_size = new_nbuckets * sizeof(gcli::FIssuenote*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FIssuenote* *new_buckets = (gcli::FIssuenote**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_issuenote");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_issuenote_buckets_n; i++) {
            gcli::FIssuenote* elem = _db.ind_issuenote_buckets_elems[i];
            while (elem) {
                gcli::FIssuenote &row        = *elem;
                gcli::FIssuenote* next       = row.ind_issuenote_next;
                u32 index          = algo::Smallstr250_Hash(0, row.issuenote) & (new_nbuckets-1);
                row.ind_issuenote_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_issuenote_buckets_elems, old_size);
        _db.ind_issuenote_buckets_elems = new_buckets;
        _db.ind_issuenote_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_mrjob.Find
// Find row by key. Return NULL if not found.
gcli::FMrjob* gcli::ind_mrjob_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_mrjob_buckets_n - 1);
    gcli::FMrjob* *e = &_db.ind_mrjob_buckets_elems[index];
    gcli::FMrjob* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mrjob == key;
        if (done) break;
        e         = &ret->ind_mrjob_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_mrjob.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FMrjob& gcli::ind_mrjob_FindX(const algo::strptr& key) {
    gcli::FMrjob* ret = ind_mrjob_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_mrjob  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_mrjob.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_mrjob_InsertMaybe(gcli::FMrjob& row) {
    ind_mrjob_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mrjob_next == (gcli::FMrjob*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.mrjob) & (_db.ind_mrjob_buckets_n - 1);
        gcli::FMrjob* *prev = &_db.ind_mrjob_buckets_elems[index];
        do {
            gcli::FMrjob* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mrjob == row.mrjob) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mrjob_next;
        } while (true);
        if (retval) {
            row.ind_mrjob_next = *prev;
            _db.ind_mrjob_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_mrjob.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_mrjob_Remove(gcli::FMrjob& row) {
    if (LIKELY(row.ind_mrjob_next != (gcli::FMrjob*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.mrjob) & (_db.ind_mrjob_buckets_n - 1);
        gcli::FMrjob* *prev = &_db.ind_mrjob_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FMrjob *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mrjob_next; // unlink (singly linked list)
                _db.ind_mrjob_n--;
                row.ind_mrjob_next = (gcli::FMrjob*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mrjob_next;
        }
    }
}

// --- gcli.FDb.ind_mrjob.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_mrjob_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mrjob_buckets_n;
    u32 new_nelems   = _db.ind_mrjob_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FMrjob*);
        u32 new_size = new_nbuckets * sizeof(gcli::FMrjob*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FMrjob* *new_buckets = (gcli::FMrjob**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_mrjob");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mrjob_buckets_n; i++) {
            gcli::FMrjob* elem = _db.ind_mrjob_buckets_elems[i];
            while (elem) {
                gcli::FMrjob &row        = *elem;
                gcli::FMrjob* next       = row.ind_mrjob_next;
                u32 index          = algo::Smallstr250_Hash(0, row.mrjob) & (new_nbuckets-1);
                row.ind_mrjob_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mrjob_buckets_elems, old_size);
        _db.ind_mrjob_buckets_elems = new_buckets;
        _db.ind_mrjob_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.user.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FUser& gcli::user_Alloc() {
    gcli::FUser* row = user_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.user  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.user.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FUser* gcli::user_AllocMaybe() {
    gcli::FUser *row = (gcli::FUser*)user_AllocMem();
    if (row) {
        new (row) gcli::FUser; // call constructor
    }
    return row;
}

// --- gcli.FDb.user.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FUser* gcli::user_InsertMaybe(const gclidb::User &value) {
    gcli::FUser *row = &user_Alloc(); // if out of memory, process dies. if input error, return NULL.
    user_CopyIn(*row,const_cast<gclidb::User&>(value));
    bool ok = user_XrefMaybe(*row); // this may return false
    if (!ok) {
        user_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.user.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::user_AllocMem() {
    u64 new_nelems     = _db.user_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FUser*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.user_lary[bsr];
        if (!lev) {
            lev=(gcli::FUser*)algo_lib::malloc_AllocMem(sizeof(gcli::FUser) * (u64(1)<<bsr));
            _db.user_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.user_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.user.RemoveAll
// Remove all elements from Lary
void gcli::user_RemoveAll() {
    for (u64 n = _db.user_n; n>0; ) {
        n--;
        user_qFind(u64(n)).~FUser(); // destroy last element
        _db.user_n = i32(n);
    }
}

// --- gcli.FDb.user.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::user_RemoveLast() {
    u64 n = _db.user_n;
    if (n > 0) {
        n -= 1;
        user_qFind(u64(n)).~FUser();
        _db.user_n = i32(n);
    }
}

// --- gcli.FDb.user.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::user_XrefMaybe(gcli::FUser &row) {
    bool retval = true;
    (void)row;
    // insert user into index ind_user
    if (true) { // user-defined insert condition
        bool success = ind_user_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_user"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_user.Find
// Find row by key. Return NULL if not found.
gcli::FUser* gcli::ind_user_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_user_buckets_n - 1);
    gcli::FUser* *e = &_db.ind_user_buckets_elems[index];
    gcli::FUser* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).user == key;
        if (done) break;
        e         = &ret->ind_user_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_user.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FUser& gcli::ind_user_FindX(const algo::strptr& key) {
    gcli::FUser* ret = ind_user_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_user  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_user.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FUser& gcli::ind_user_GetOrCreate(const algo::strptr& key) {
    gcli::FUser* ret = ind_user_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &user_Alloc();
        (*ret).user = key;
        bool good = user_XrefMaybe(*ret);
        if (!good) {
            user_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_user  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_user.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_user_InsertMaybe(gcli::FUser& row) {
    ind_user_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_user_next == (gcli::FUser*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
        gcli::FUser* *prev = &_db.ind_user_buckets_elems[index];
        do {
            gcli::FUser* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).user == row.user) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_user_next;
        } while (true);
        if (retval) {
            row.ind_user_next = *prev;
            _db.ind_user_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_user.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_user_Remove(gcli::FUser& row) {
    if (LIKELY(row.ind_user_next != (gcli::FUser*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
        gcli::FUser* *prev = &_db.ind_user_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FUser *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_user_next; // unlink (singly linked list)
                _db.ind_user_n--;
                row.ind_user_next = (gcli::FUser*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_user_next;
        }
    }
}

// --- gcli.FDb.ind_user.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_user_Reserve(int n) {
    u32 old_nbuckets = _db.ind_user_buckets_n;
    u32 new_nelems   = _db.ind_user_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FUser*);
        u32 new_size = new_nbuckets * sizeof(gcli::FUser*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FUser* *new_buckets = (gcli::FUser**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_user");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_user_buckets_n; i++) {
            gcli::FUser* elem = _db.ind_user_buckets_elems[i];
            while (elem) {
                gcli::FUser &row        = *elem;
                gcli::FUser* next       = row.ind_user_next;
                u32 index          = algo::Smallstr50_Hash(0, row.user) & (new_nbuckets-1);
                row.ind_user_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_user_buckets_elems, old_size);
        _db.ind_user_buckets_elems = new_buckets;
        _db.ind_user_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_mr.Find
// Find row by key. Return NULL if not found.
gcli::FMr* gcli::ind_mr_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr150_Hash(0, key) & (_db.ind_mr_buckets_n - 1);
    gcli::FMr* *e = &_db.ind_mr_buckets_elems[index];
    gcli::FMr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mr == key;
        if (done) break;
        e         = &ret->ind_mr_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_mr.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FMr& gcli::ind_mr_FindX(const algo::strptr& key) {
    gcli::FMr* ret = ind_mr_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_mr  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_mr.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FMr& gcli::ind_mr_GetOrCreate(const algo::strptr& key) {
    gcli::FMr* ret = ind_mr_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &mr_Alloc();
        (*ret).mr = key;
        bool good = mr_XrefMaybe(*ret);
        if (!good) {
            mr_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_mr  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_mr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_mr_InsertMaybe(gcli::FMr& row) {
    ind_mr_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mr_next == (gcli::FMr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr150_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
        gcli::FMr* *prev = &_db.ind_mr_buckets_elems[index];
        do {
            gcli::FMr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mr == row.mr) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mr_next;
        } while (true);
        if (retval) {
            row.ind_mr_next = *prev;
            _db.ind_mr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_mr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_mr_Remove(gcli::FMr& row) {
    if (LIKELY(row.ind_mr_next != (gcli::FMr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr150_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
        gcli::FMr* *prev = &_db.ind_mr_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FMr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mr_next; // unlink (singly linked list)
                _db.ind_mr_n--;
                row.ind_mr_next = (gcli::FMr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mr_next;
        }
    }
}

// --- gcli.FDb.ind_mr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_mr_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mr_buckets_n;
    u32 new_nelems   = _db.ind_mr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FMr*);
        u32 new_size = new_nbuckets * sizeof(gcli::FMr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FMr* *new_buckets = (gcli::FMr**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_mr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mr_buckets_n; i++) {
            gcli::FMr* elem = _db.ind_mr_buckets_elems[i];
            while (elem) {
                gcli::FMr &row        = *elem;
                gcli::FMr* next       = row.ind_mr_next;
                u32 index          = algo::Smallstr150_Hash(0, row.mr) & (new_nbuckets-1);
                row.ind_mr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mr_buckets_elems, old_size);
        _db.ind_mr_buckets_elems = new_buckets;
        _db.ind_mr_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.ind_milestone.Find
// Find row by key. Return NULL if not found.
gcli::FMilestone* gcli::ind_milestone_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr200_Hash(0, key) & (_db.ind_milestone_buckets_n - 1);
    gcli::FMilestone* *e = &_db.ind_milestone_buckets_elems[index];
    gcli::FMilestone* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).milestone == key;
        if (done) break;
        e         = &ret->ind_milestone_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_milestone.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FMilestone& gcli::ind_milestone_FindX(const algo::strptr& key) {
    gcli::FMilestone* ret = ind_milestone_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_milestone  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_milestone.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FMilestone& gcli::ind_milestone_GetOrCreate(const algo::strptr& key) {
    gcli::FMilestone* ret = ind_milestone_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &milestone_Alloc();
        (*ret).milestone = key;
        bool good = milestone_XrefMaybe(*ret);
        if (!good) {
            milestone_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_milestone  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_milestone.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_milestone_InsertMaybe(gcli::FMilestone& row) {
    ind_milestone_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_milestone_next == (gcli::FMilestone*)-1)) {// check if in hash already
        u32 index = algo::Smallstr200_Hash(0, row.milestone) & (_db.ind_milestone_buckets_n - 1);
        gcli::FMilestone* *prev = &_db.ind_milestone_buckets_elems[index];
        do {
            gcli::FMilestone* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).milestone == row.milestone) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_milestone_next;
        } while (true);
        if (retval) {
            row.ind_milestone_next = *prev;
            _db.ind_milestone_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_milestone.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_milestone_Remove(gcli::FMilestone& row) {
    if (LIKELY(row.ind_milestone_next != (gcli::FMilestone*)-1)) {// check if in hash already
        u32 index = algo::Smallstr200_Hash(0, row.milestone) & (_db.ind_milestone_buckets_n - 1);
        gcli::FMilestone* *prev = &_db.ind_milestone_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FMilestone *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_milestone_next; // unlink (singly linked list)
                _db.ind_milestone_n--;
                row.ind_milestone_next = (gcli::FMilestone*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_milestone_next;
        }
    }
}

// --- gcli.FDb.ind_milestone.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_milestone_Reserve(int n) {
    u32 old_nbuckets = _db.ind_milestone_buckets_n;
    u32 new_nelems   = _db.ind_milestone_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FMilestone*);
        u32 new_size = new_nbuckets * sizeof(gcli::FMilestone*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FMilestone* *new_buckets = (gcli::FMilestone**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_milestone");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_milestone_buckets_n; i++) {
            gcli::FMilestone* elem = _db.ind_milestone_buckets_elems[i];
            while (elem) {
                gcli::FMilestone &row        = *elem;
                gcli::FMilestone* next       = row.ind_milestone_next;
                u32 index          = algo::Smallstr200_Hash(0, row.milestone) & (new_nbuckets-1);
                row.ind_milestone_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_milestone_buckets_elems, old_size);
        _db.ind_milestone_buckets_elems = new_buckets;
        _db.ind_milestone_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.milestone.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMilestone& gcli::milestone_Alloc() {
    gcli::FMilestone* row = milestone_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.milestone  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.milestone.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMilestone* gcli::milestone_AllocMaybe() {
    gcli::FMilestone *row = (gcli::FMilestone*)milestone_AllocMem();
    if (row) {
        new (row) gcli::FMilestone; // call constructor
    }
    return row;
}

// --- gcli.FDb.milestone.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMilestone* gcli::milestone_InsertMaybe(const gclidb::Milestone &value) {
    gcli::FMilestone *row = &milestone_Alloc(); // if out of memory, process dies. if input error, return NULL.
    milestone_CopyIn(*row,const_cast<gclidb::Milestone&>(value));
    bool ok = milestone_XrefMaybe(*row); // this may return false
    if (!ok) {
        milestone_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.milestone.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::milestone_AllocMem() {
    u64 new_nelems     = _db.milestone_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FMilestone*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.milestone_lary[bsr];
        if (!lev) {
            lev=(gcli::FMilestone*)algo_lib::malloc_AllocMem(sizeof(gcli::FMilestone) * (u64(1)<<bsr));
            _db.milestone_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.milestone_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.milestone.RemoveAll
// Remove all elements from Lary
void gcli::milestone_RemoveAll() {
    for (u64 n = _db.milestone_n; n>0; ) {
        n--;
        milestone_qFind(u64(n)).~FMilestone(); // destroy last element
        _db.milestone_n = i32(n);
    }
}

// --- gcli.FDb.milestone.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::milestone_RemoveLast() {
    u64 n = _db.milestone_n;
    if (n > 0) {
        n -= 1;
        milestone_qFind(u64(n)).~FMilestone();
        _db.milestone_n = i32(n);
    }
}

// --- gcli.FDb.milestone.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::milestone_XrefMaybe(gcli::FMilestone &row) {
    bool retval = true;
    (void)row;
    // insert milestone into index ind_milestone
    if (true) { // user-defined insert condition
        bool success = ind_milestone_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_milestone"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.mr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMr& gcli::mr_Alloc() {
    gcli::FMr* row = mr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.mr  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.mr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMr* gcli::mr_AllocMaybe() {
    gcli::FMr *row = (gcli::FMr*)mr_AllocMem();
    if (row) {
        new (row) gcli::FMr; // call constructor
    }
    return row;
}

// --- gcli.FDb.mr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMr* gcli::mr_InsertMaybe(const gclidb::Mr &value) {
    gcli::FMr *row = &mr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mr_CopyIn(*row,const_cast<gclidb::Mr&>(value));
    bool ok = mr_XrefMaybe(*row); // this may return false
    if (!ok) {
        mr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.mr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::mr_AllocMem() {
    u64 new_nelems     = _db.mr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FMr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mr_lary[bsr];
        if (!lev) {
            lev=(gcli::FMr*)algo_lib::malloc_AllocMem(sizeof(gcli::FMr) * (u64(1)<<bsr));
            _db.mr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.mr.RemoveAll
// Remove all elements from Lary
void gcli::mr_RemoveAll() {
    for (u64 n = _db.mr_n; n>0; ) {
        n--;
        mr_qFind(u64(n)).~FMr(); // destroy last element
        _db.mr_n = i32(n);
    }
}

// --- gcli.FDb.mr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::mr_RemoveLast() {
    u64 n = _db.mr_n;
    if (n > 0) {
        n -= 1;
        mr_qFind(u64(n)).~FMr();
        _db.mr_n = i32(n);
    }
}

// --- gcli.FDb.mr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::mr_XrefMaybe(gcli::FMr &row) {
    bool retval = true;
    (void)row;
    // insert mr into index ind_mr
    if (true) { // user-defined insert condition
        bool success = ind_mr_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_mr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gtypeprefix.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtypeprefix& gcli::gtypeprefix_Alloc() {
    gcli::FGtypeprefix* row = gtypeprefix_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtypeprefix  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtypeprefix.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtypeprefix* gcli::gtypeprefix_AllocMaybe() {
    gcli::FGtypeprefix *row = (gcli::FGtypeprefix*)gtypeprefix_AllocMem();
    if (row) {
        new (row) gcli::FGtypeprefix; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtypeprefix.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtypeprefix* gcli::gtypeprefix_InsertMaybe(const gclidb::Gtypeprefix &value) {
    gcli::FGtypeprefix *row = &gtypeprefix_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtypeprefix_CopyIn(*row,const_cast<gclidb::Gtypeprefix&>(value));
    bool ok = gtypeprefix_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtypeprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtypeprefix.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtypeprefix_AllocMem() {
    u64 new_nelems     = _db.gtypeprefix_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtypeprefix*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtypeprefix_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtypeprefix*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtypeprefix) * (u64(1)<<bsr));
            _db.gtypeprefix_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtypeprefix_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtypeprefix.RemoveAll
// Remove all elements from Lary
void gcli::gtypeprefix_RemoveAll() {
    for (u64 n = _db.gtypeprefix_n; n>0; ) {
        n--;
        gtypeprefix_qFind(u64(n)).~FGtypeprefix(); // destroy last element
        _db.gtypeprefix_n = i32(n);
    }
}

// --- gcli.FDb.gtypeprefix.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtypeprefix_RemoveLast() {
    u64 n = _db.gtypeprefix_n;
    if (n > 0) {
        n -= 1;
        gtypeprefix_qFind(u64(n)).~FGtypeprefix();
        _db.gtypeprefix_n = i32(n);
    }
}

// --- gcli.FDb.gtypeprefix.InputMaybe
static bool gcli::gtypeprefix_InputMaybe(gclidb::Gtypeprefix &elem) {
    bool retval = true;
    retval = gtypeprefix_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gtypeprefix.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtypeprefix_XrefMaybe(gcli::FGtypeprefix &row) {
    bool retval = true;
    (void)row;
    gcli::FGtype* p_gtype = gcli::ind_gtype_Find(gtype_Get(row));
    if (UNLIKELY(!p_gtype)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gtype" << Keyval("key", gtype_Get(row));
        return false;
    }
    // gtypeprefix: save pointer to gtype
    if (true) { // user-defined insert condition
        row.p_gtype = p_gtype;
    }
    // insert gtypeprefix into index c_gtypeprefix
    if (true) { // user-defined insert condition
        c_gtypeprefix_Insert(*p_gtype, row);
    }
    return retval;
}

// --- gcli.FDb.gtblact.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtblact& gcli::gtblact_Alloc() {
    gcli::FGtblact* row = gtblact_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtblact  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtblact.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtblact* gcli::gtblact_AllocMaybe() {
    gcli::FGtblact *row = (gcli::FGtblact*)gtblact_AllocMem();
    if (row) {
        new (row) gcli::FGtblact; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtblact.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtblact* gcli::gtblact_InsertMaybe(const gclidb::Gtblact &value) {
    gcli::FGtblact *row = &gtblact_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtblact_CopyIn(*row,const_cast<gclidb::Gtblact&>(value));
    bool ok = gtblact_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtblact_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtblact.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtblact_AllocMem() {
    u64 new_nelems     = _db.gtblact_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtblact*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtblact_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtblact*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblact) * (u64(1)<<bsr));
            _db.gtblact_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtblact_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtblact.RemoveAll
// Remove all elements from Lary
void gcli::gtblact_RemoveAll() {
    for (u64 n = _db.gtblact_n; n>0; ) {
        n--;
        gtblact_qFind(u64(n)).~FGtblact(); // destroy last element
        _db.gtblact_n = i32(n);
    }
}

// --- gcli.FDb.gtblact.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtblact_RemoveLast() {
    u64 n = _db.gtblact_n;
    if (n > 0) {
        n -= 1;
        gtblact_qFind(u64(n)).~FGtblact();
        _db.gtblact_n = i32(n);
    }
}

// --- gcli.FDb.gtblact.LoadStatic
static void gcli::gtblact_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)(gcli::FGtblact&);
    } data[] = {
        { "gclidb.gtblact  gtblact:help_list  t:Y  e:N  auth:N", gcli::gtblact_help_list }
        ,{ "gclidb.gtblact  gtblact:repo_create  t:N  e:N  auth:N", gcli::gtblact_repo_create }
        ,{ "gclidb.gtblact  gtblact:gitconfig_create  t:N  e:N  auth:N", gcli::gtblact_gitconfig_create }
        ,{ "gclidb.gtblact  gtblact:gitconfig_list  t:N  e:N  auth:N", gcli::gtblact_gitconfig_list }
        ,{ "gclidb.gtblact  gtblact:repo_update  t:N  e:Y  auth:N", gcli::gtblact_repo_update }
        ,{ "gclidb.gtblact  gtblact:reporemote_list  t:N  e:N  auth:N", gcli::gtblact_reporemote_list }
        ,{ "gclidb.gtblact  gtblact:repo_list  t:N  e:N  auth:N", gcli::gtblact_repo_list }
        ,{ "gclidb.gtblact  gtblact:issue_create  t:N  e:Y  auth:Y", gcli::gtblact_issue_create }
        ,{ "gclidb.gtblact  gtblact:issue_update  t:Y  e:Y  auth:Y", gcli::gtblact_issue_update }
        ,{ "gclidb.gtblact  gtblact:issue_start  t:N  e:N  auth:Y", gcli::gtblact_issue_start }
        ,{ "gclidb.gtblact  gtblact:issue_list  t:Y  e:N  auth:Y", gcli::gtblact_issue_list }
        ,{ "gclidb.gtblact  gtblact:mrnote_create  t:Y  e:Y  auth:Y", gcli::gtblact_mrnote_create }
        ,{ "gclidb.gtblact  gtblact:issuenote_create  t:Y  e:Y  auth:Y", gcli::gtblact_issuenote_create }
        ,{ "gclidb.gtblact  gtblact:issuenote_list  t:Y  e:N  auth:Y", gcli::gtblact_issuenote_list }
        ,{ "gclidb.gtblact  gtblact:issuenote_update  t:Y  e:Y  auth:Y", gcli::gtblact_issuenote_update }
        ,{ "gclidb.gtblact  gtblact:mrnote_update  t:Y  e:Y  auth:Y", gcli::gtblact_mrnote_update }
        ,{ "gclidb.gtblact  gtblact:mrnote_list  t:Y  e:N  auth:Y", gcli::gtblact_mrnote_list }
        ,{ "gclidb.gtblact  gtblact:mr_list  t:Y  e:N  auth:Y", gcli::gtblact_mr_list }
        ,{ "gclidb.gtblact  gtblact:milestone_list  t:N  e:N  auth:Y", gcli::gtblact_milestone_list }
        ,{ "gclidb.gtblact  gtblact:user_list  t:Y  e:N  auth:Y", gcli::gtblact_user_list }
        ,{ "gclidb.gtblact  gtblact:mr_create  t:Y  e:N  auth:Y", gcli::gtblact_mr_create }
        ,{ "gclidb.gtblact  gtblact:mr_start  t:N  e:N  auth:Y", gcli::gtblact_mr_start }
        ,{ "gclidb.gtblact  gtblact:mr_approve  t:N  e:N  auth:Y", gcli::gtblact_mr_approve }
        ,{ "gclidb.gtblact  gtblact:mr_accept  t:N  e:N  auth:Y", gcli::gtblact_mr_accept }
        ,{ "gclidb.gtblact  gtblact:mr_update  t:Y  e:Y  auth:Y", gcli::gtblact_mr_update }
        ,{ "gclidb.gtblact  gtblact:mr_needs_work  t:N  e:N  auth:Y", gcli::gtblact_mr_needs_work }
        ,{ "gclidb.gtblact  gtblact:mr_stop  t:N  e:N  auth:Y", gcli::gtblact_mr_stop }
        ,{ "gclidb.gtblact  gtblact:mrjob_list  t:Y  e:N  auth:Y", gcli::gtblact_mrjob_list }
        ,{ "gclidb.gtblact  gtblact:issue_needs_work  t:N  e:N  auth:Y", gcli::gtblact_issue_needs_work }
        ,{ "gclidb.gtblact  gtblact:issue_stop  t:N  e:N  auth:Y", gcli::gtblact_issue_stop }
        ,{NULL, NULL}
    };
    (void)data;
    gclidb::Gtblact gtblact;
    for (int i=0; data[i].s; i++) {
        (void)gclidb::Gtblact_ReadStrptrMaybe(gtblact, algo::strptr(data[i].s));
        gcli::FGtblact *elem = gtblact_InsertMaybe(gtblact);
        vrfy(elem, tempstr("gcli.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- gcli.FDb.gtblact.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtblact_XrefMaybe(gcli::FGtblact &row) {
    bool retval = true;
    (void)row;
    // insert gtblact into index ind_gtblact
    if (true) { // user-defined insert condition
        bool success = ind_gtblact_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gtblact"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.gtblactfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtblactfld& gcli::gtblactfld_Alloc() {
    gcli::FGtblactfld* row = gtblactfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtblactfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtblactfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtblactfld* gcli::gtblactfld_AllocMaybe() {
    gcli::FGtblactfld *row = (gcli::FGtblactfld*)gtblactfld_AllocMem();
    if (row) {
        new (row) gcli::FGtblactfld; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtblactfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtblactfld* gcli::gtblactfld_InsertMaybe(const gclidb::Gtblactfld &value) {
    gcli::FGtblactfld *row = &gtblactfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtblactfld_CopyIn(*row,const_cast<gclidb::Gtblactfld&>(value));
    bool ok = gtblactfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtblactfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtblactfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtblactfld_AllocMem() {
    u64 new_nelems     = _db.gtblactfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtblactfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtblactfld_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtblactfld*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblactfld) * (u64(1)<<bsr));
            _db.gtblactfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtblactfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtblactfld.RemoveAll
// Remove all elements from Lary
void gcli::gtblactfld_RemoveAll() {
    for (u64 n = _db.gtblactfld_n; n>0; ) {
        n--;
        gtblactfld_qFind(u64(n)).~FGtblactfld(); // destroy last element
        _db.gtblactfld_n = i32(n);
    }
}

// --- gcli.FDb.gtblactfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtblactfld_RemoveLast() {
    u64 n = _db.gtblactfld_n;
    if (n > 0) {
        n -= 1;
        gtblactfld_qFind(u64(n)).~FGtblactfld();
        _db.gtblactfld_n = i32(n);
    }
}

// --- gcli.FDb.gtblactfld.InputMaybe
static bool gcli::gtblactfld_InputMaybe(gclidb::Gtblactfld &elem) {
    bool retval = true;
    retval = gtblactfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gtblactfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtblactfld_XrefMaybe(gcli::FGtblactfld &row) {
    bool retval = true;
    (void)row;
    gcli::FGfld* p_field = gcli::ind_gfld_Find(field_Get(row));
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gfld" << Keyval("key", field_Get(row));
        return false;
    }
    // gtblactfld: save pointer to field
    if (true) { // user-defined insert condition
        row.p_gfld = p_field;
    }
    gcli::FGtblact* p_gtblact = gcli::ind_gtblact_Find(gtblact_Get(row));
    if (UNLIKELY(!p_gtblact)) {
        algo_lib::ResetErrtext() << "gcli.bad_xref  index:gcli.FDb.ind_gtblact" << Keyval("key", gtblact_Get(row));
        return false;
    }
    // insert gtblactfld into index c_gtblactfld
    if (true) { // user-defined insert condition
        c_gtblactfld_Insert(*p_gtblact, row);
    }
    // insert gtblactfld into index ind_gtblactfld
    if (true) { // user-defined insert condition
        bool success = ind_gtblactfld_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gtblactfld"; // check for duplicate key
            return false;
        }
    }
    // insert gtblactfld into index c_gtblactfld
    if (true) { // user-defined insert condition
        c_gtblactfld_Insert(*p_field, row);
    }
    return retval;
}

// --- gcli.FDb.ind_gtblact.Find
// Find row by key. Return NULL if not found.
gcli::FGtblact* gcli::ind_gtblact_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gtblact_buckets_n - 1);
    gcli::FGtblact* *e = &_db.ind_gtblact_buckets_elems[index];
    gcli::FGtblact* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gtblact == key;
        if (done) break;
        e         = &ret->ind_gtblact_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gtblact.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGtblact& gcli::ind_gtblact_FindX(const algo::strptr& key) {
    gcli::FGtblact* ret = ind_gtblact_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gtblact  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gtblact.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtblact& gcli::ind_gtblact_GetOrCreate(const algo::strptr& key) {
    gcli::FGtblact* ret = ind_gtblact_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gtblact_Alloc();
        (*ret).gtblact = key;
        bool good = gtblact_XrefMaybe(*ret);
        if (!good) {
            gtblact_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gtblact  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gtblact.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gtblact_InsertMaybe(gcli::FGtblact& row) {
    ind_gtblact_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gtblact_next == (gcli::FGtblact*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtblact) & (_db.ind_gtblact_buckets_n - 1);
        gcli::FGtblact* *prev = &_db.ind_gtblact_buckets_elems[index];
        do {
            gcli::FGtblact* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gtblact == row.gtblact) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gtblact_next;
        } while (true);
        if (retval) {
            row.ind_gtblact_next = *prev;
            _db.ind_gtblact_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gtblact.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gtblact_Remove(gcli::FGtblact& row) {
    if (LIKELY(row.ind_gtblact_next != (gcli::FGtblact*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtblact) & (_db.ind_gtblact_buckets_n - 1);
        gcli::FGtblact* *prev = &_db.ind_gtblact_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGtblact *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gtblact_next; // unlink (singly linked list)
                _db.ind_gtblact_n--;
                row.ind_gtblact_next = (gcli::FGtblact*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gtblact_next;
        }
    }
}

// --- gcli.FDb.ind_gtblact.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gtblact_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gtblact_buckets_n;
    u32 new_nelems   = _db.ind_gtblact_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGtblact*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGtblact*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGtblact* *new_buckets = (gcli::FGtblact**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gtblact");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gtblact_buckets_n; i++) {
            gcli::FGtblact* elem = _db.ind_gtblact_buckets_elems[i];
            while (elem) {
                gcli::FGtblact &row        = *elem;
                gcli::FGtblact* next       = row.ind_gtblact_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gtblact) & (new_nbuckets-1);
                row.ind_gtblact_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gtblact_buckets_elems, old_size);
        _db.ind_gtblact_buckets_elems = new_buckets;
        _db.ind_gtblact_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.zd_gtblact.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void gcli::zd_gtblact_Insert(gcli::FGtblact& row) {
    if (!zd_gtblact_InLlistQ(row)) {
        gcli::FGtblact* old_tail = _db.zd_gtblact_tail;
        row.zd_gtblact_next = NULL;
        row.zd_gtblact_prev = old_tail;
        _db.zd_gtblact_tail = &row;
        gcli::FGtblact **new_row_a = &old_tail->zd_gtblact_next;
        gcli::FGtblact **new_row_b = &_db.zd_gtblact_head;
        gcli::FGtblact **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_gtblact_n++;
    }
}

// --- gcli.FDb.zd_gtblact.Remove
// Remove element from index. If element is not in index, do nothing.
void gcli::zd_gtblact_Remove(gcli::FGtblact& row) {
    if (zd_gtblact_InLlistQ(row)) {
        gcli::FGtblact* old_head       = _db.zd_gtblact_head;
        (void)old_head; // in case it's not used
        gcli::FGtblact* prev = row.zd_gtblact_prev;
        gcli::FGtblact* next = row.zd_gtblact_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        gcli::FGtblact **new_next_a = &prev->zd_gtblact_next;
        gcli::FGtblact **new_next_b = &_db.zd_gtblact_head;
        gcli::FGtblact **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        gcli::FGtblact **new_prev_a = &next->zd_gtblact_prev;
        gcli::FGtblact **new_prev_b = &_db.zd_gtblact_tail;
        gcli::FGtblact **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_gtblact_n--;
        row.zd_gtblact_next=(gcli::FGtblact*)-1; // not-in-list
    }
}

// --- gcli.FDb.zd_gtblact.RemoveAll
// Empty the index. (The rows are not deleted)
void gcli::zd_gtblact_RemoveAll() {
    gcli::FGtblact* row = _db.zd_gtblact_head;
    _db.zd_gtblact_head = NULL;
    _db.zd_gtblact_tail = NULL;
    _db.zd_gtblact_n = 0;
    while (row) {
        gcli::FGtblact* row_next = row->zd_gtblact_next;
        row->zd_gtblact_next  = (gcli::FGtblact*)-1;
        row->zd_gtblact_prev  = NULL;
        row = row_next;
    }
}

// --- gcli.FDb.zd_gtblact.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
gcli::FGtblact* gcli::zd_gtblact_RemoveFirst() {
    gcli::FGtblact *row = NULL;
    row = _db.zd_gtblact_head;
    if (row) {
        gcli::FGtblact *next = row->zd_gtblact_next;
        _db.zd_gtblact_head = next;
        gcli::FGtblact **new_end_a = &next->zd_gtblact_prev;
        gcli::FGtblact **new_end_b = &_db.zd_gtblact_tail;
        gcli::FGtblact **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_gtblact_n--;
        row->zd_gtblact_next = (gcli::FGtblact*)-1; // mark as not-in-list
    }
    return row;
}

// --- gcli.FDb.ind_gtblactfld.Find
// Find row by key. Return NULL if not found.
gcli::FGtblactfld* gcli::ind_gtblactfld_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gtblactfld_buckets_n - 1);
    gcli::FGtblactfld* *e = &_db.ind_gtblactfld_buckets_elems[index];
    gcli::FGtblactfld* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gtblactfld == key;
        if (done) break;
        e         = &ret->ind_gtblactfld_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gtblactfld.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGtblactfld& gcli::ind_gtblactfld_FindX(const algo::strptr& key) {
    gcli::FGtblactfld* ret = ind_gtblactfld_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gtblactfld  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gtblactfld.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gtblactfld_InsertMaybe(gcli::FGtblactfld& row) {
    ind_gtblactfld_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gtblactfld_next == (gcli::FGtblactfld*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtblactfld) & (_db.ind_gtblactfld_buckets_n - 1);
        gcli::FGtblactfld* *prev = &_db.ind_gtblactfld_buckets_elems[index];
        do {
            gcli::FGtblactfld* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gtblactfld == row.gtblactfld) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gtblactfld_next;
        } while (true);
        if (retval) {
            row.ind_gtblactfld_next = *prev;
            _db.ind_gtblactfld_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gtblactfld.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gtblactfld_Remove(gcli::FGtblactfld& row) {
    if (LIKELY(row.ind_gtblactfld_next != (gcli::FGtblactfld*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gtblactfld) & (_db.ind_gtblactfld_buckets_n - 1);
        gcli::FGtblactfld* *prev = &_db.ind_gtblactfld_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGtblactfld *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gtblactfld_next; // unlink (singly linked list)
                _db.ind_gtblactfld_n--;
                row.ind_gtblactfld_next = (gcli::FGtblactfld*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gtblactfld_next;
        }
    }
}

// --- gcli.FDb.ind_gtblactfld.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gtblactfld_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gtblactfld_buckets_n;
    u32 new_nelems   = _db.ind_gtblactfld_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGtblactfld*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGtblactfld*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGtblactfld* *new_buckets = (gcli::FGtblactfld**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gtblactfld");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gtblactfld_buckets_n; i++) {
            gcli::FGtblactfld* elem = _db.ind_gtblactfld_buckets_elems[i];
            while (elem) {
                gcli::FGtblactfld &row        = *elem;
                gcli::FGtblactfld* next       = row.ind_gtblactfld_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gtblactfld) & (new_nbuckets-1);
                row.ind_gtblactfld_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gtblactfld_buckets_elems, old_size);
        _db.ind_gtblactfld_buckets_elems = new_buckets;
        _db.ind_gtblactfld_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.gfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGfld& gcli::gfld_Alloc() {
    gcli::FGfld* row = gfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGfld* gcli::gfld_AllocMaybe() {
    gcli::FGfld *row = (gcli::FGfld*)gfld_AllocMem();
    if (row) {
        new (row) gcli::FGfld; // call constructor
    }
    return row;
}

// --- gcli.FDb.gfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGfld* gcli::gfld_InsertMaybe(const gclidb::Gfld &value) {
    gcli::FGfld *row = &gfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gfld_CopyIn(*row,const_cast<gclidb::Gfld&>(value));
    bool ok = gfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        gfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gfld_AllocMem() {
    u64 new_nelems     = _db.gfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gfld_lary[bsr];
        if (!lev) {
            lev=(gcli::FGfld*)algo_lib::malloc_AllocMem(sizeof(gcli::FGfld) * (u64(1)<<bsr));
            _db.gfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gfld.RemoveAll
// Remove all elements from Lary
void gcli::gfld_RemoveAll() {
    for (u64 n = _db.gfld_n; n>0; ) {
        n--;
        gfld_qFind(u64(n)).~FGfld(); // destroy last element
        _db.gfld_n = i32(n);
    }
}

// --- gcli.FDb.gfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gfld_RemoveLast() {
    u64 n = _db.gfld_n;
    if (n > 0) {
        n -= 1;
        gfld_qFind(u64(n)).~FGfld();
        _db.gfld_n = i32(n);
    }
}

// --- gcli.FDb.gfld.InputMaybe
static bool gcli::gfld_InputMaybe(gclidb::Gfld &elem) {
    bool retval = true;
    retval = gfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gfld_XrefMaybe(gcli::FGfld &row) {
    bool retval = true;
    (void)row;
    // insert gfld into index ind_gfld
    if (true) { // user-defined insert condition
        bool success = ind_gfld_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gfld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gfld.Find
// Find row by key. Return NULL if not found.
gcli::FGfld* gcli::ind_gfld_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gfld_buckets_n - 1);
    gcli::FGfld* *e = &_db.ind_gfld_buckets_elems[index];
    gcli::FGfld* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gfld == key;
        if (done) break;
        e         = &ret->ind_gfld_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gfld.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGfld& gcli::ind_gfld_FindX(const algo::strptr& key) {
    gcli::FGfld* ret = ind_gfld_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gfld  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gfld.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGfld& gcli::ind_gfld_GetOrCreate(const algo::strptr& key) {
    gcli::FGfld* ret = ind_gfld_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gfld_Alloc();
        (*ret).gfld = key;
        bool good = gfld_XrefMaybe(*ret);
        if (!good) {
            gfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gfld  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gfld.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gfld_InsertMaybe(gcli::FGfld& row) {
    ind_gfld_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gfld_next == (gcli::FGfld*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gfld) & (_db.ind_gfld_buckets_n - 1);
        gcli::FGfld* *prev = &_db.ind_gfld_buckets_elems[index];
        do {
            gcli::FGfld* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gfld == row.gfld) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gfld_next;
        } while (true);
        if (retval) {
            row.ind_gfld_next = *prev;
            _db.ind_gfld_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gfld.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gfld_Remove(gcli::FGfld& row) {
    if (LIKELY(row.ind_gfld_next != (gcli::FGfld*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gfld) & (_db.ind_gfld_buckets_n - 1);
        gcli::FGfld* *prev = &_db.ind_gfld_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGfld *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gfld_next; // unlink (singly linked list)
                _db.ind_gfld_n--;
                row.ind_gfld_next = (gcli::FGfld*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gfld_next;
        }
    }
}

// --- gcli.FDb.ind_gfld.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gfld_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gfld_buckets_n;
    u32 new_nelems   = _db.ind_gfld_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGfld*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGfld*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGfld* *new_buckets = (gcli::FGfld**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gfld");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gfld_buckets_n; i++) {
            gcli::FGfld* elem = _db.ind_gfld_buckets_elems[i];
            while (elem) {
                gcli::FGfld &row        = *elem;
                gcli::FGfld* next       = row.ind_gfld_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gfld) & (new_nbuckets-1);
                row.ind_gfld_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gfld_buckets_elems, old_size);
        _db.ind_gfld_buckets_elems = new_buckets;
        _db.ind_gfld_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.c_gfld.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gfld_Insert(gcli::FGfld& row) {
    if (bool_Update(row._db_c_gfld_in_ary,true)) {
        // reserve space
        c_gfld_Reserve(1);
        u32 n  = _db.c_gfld_n;
        u32 at = n;
        gcli::FGfld* *elems = _db.c_gfld_elems;
        elems[at] = &row;
        _db.c_gfld_n = n+1;

    }
}

// --- gcli.FDb.c_gfld.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gfld_InsertMaybe(gcli::FGfld& row) {
    bool retval = !row._db_c_gfld_in_ary;
    c_gfld_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FDb.c_gfld.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gfld_Remove(gcli::FGfld& row) {
    if (bool_Update(row._db_c_gfld_in_ary,false)) {
        int lim = _db.c_gfld_n;
        gcli::FGfld* *elems = _db.c_gfld_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGfld* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGfld*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_gfld_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FDb.c_gfld.Reserve
// Reserve space in index for N more elements;
void gcli::c_gfld_Reserve(u32 n) {
    u32 old_max = _db.c_gfld_max;
    if (UNLIKELY(_db.c_gfld_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGfld*);
        u32 new_size = new_max * sizeof(gcli::FGfld*);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.c_gfld_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.c_gfld");
        }
        _db.c_gfld_elems = (gcli::FGfld**)new_mem;
        _db.c_gfld_max = new_max;
    }
}

// --- gcli.FDb.gtbl.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtbl& gcli::gtbl_Alloc() {
    gcli::FGtbl* row = gtbl_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gtbl  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gtbl.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtbl* gcli::gtbl_AllocMaybe() {
    gcli::FGtbl *row = (gcli::FGtbl*)gtbl_AllocMem();
    if (row) {
        new (row) gcli::FGtbl; // call constructor
    }
    return row;
}

// --- gcli.FDb.gtbl.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtbl* gcli::gtbl_InsertMaybe(const gclidb::Gtbl &value) {
    gcli::FGtbl *row = &gtbl_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gtbl_CopyIn(*row,const_cast<gclidb::Gtbl&>(value));
    bool ok = gtbl_XrefMaybe(*row); // this may return false
    if (!ok) {
        gtbl_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gtbl.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gtbl_AllocMem() {
    u64 new_nelems     = _db.gtbl_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGtbl*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gtbl_lary[bsr];
        if (!lev) {
            lev=(gcli::FGtbl*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtbl) * (u64(1)<<bsr));
            _db.gtbl_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gtbl_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gtbl.RemoveAll
// Remove all elements from Lary
void gcli::gtbl_RemoveAll() {
    for (u64 n = _db.gtbl_n; n>0; ) {
        n--;
        gtbl_qFind(u64(n)).~FGtbl(); // destroy last element
        _db.gtbl_n = i32(n);
    }
}

// --- gcli.FDb.gtbl.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gtbl_RemoveLast() {
    u64 n = _db.gtbl_n;
    if (n > 0) {
        n -= 1;
        gtbl_qFind(u64(n)).~FGtbl();
        _db.gtbl_n = i32(n);
    }
}

// --- gcli.FDb.gtbl.InputMaybe
static bool gcli::gtbl_InputMaybe(gclidb::Gtbl &elem) {
    bool retval = true;
    retval = gtbl_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gtbl.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gtbl_XrefMaybe(gcli::FGtbl &row) {
    bool retval = true;
    (void)row;
    // insert gtbl into index ind_gtbl
    if (true) { // user-defined insert condition
        bool success = ind_gtbl_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gtbl"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gtbl.Find
// Find row by key. Return NULL if not found.
gcli::FGtbl* gcli::ind_gtbl_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_gtbl_buckets_n - 1);
    gcli::FGtbl* *e = &_db.ind_gtbl_buckets_elems[index];
    gcli::FGtbl* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gtbl == key;
        if (done) break;
        e         = &ret->ind_gtbl_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gtbl.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGtbl& gcli::ind_gtbl_FindX(const algo::strptr& key) {
    gcli::FGtbl* ret = ind_gtbl_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gtbl  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gtbl.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtbl& gcli::ind_gtbl_GetOrCreate(const algo::strptr& key) {
    gcli::FGtbl* ret = ind_gtbl_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gtbl_Alloc();
        (*ret).gtbl = key;
        bool good = gtbl_XrefMaybe(*ret);
        if (!good) {
            gtbl_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gtbl  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gtbl.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gtbl_InsertMaybe(gcli::FGtbl& row) {
    ind_gtbl_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gtbl_next == (gcli::FGtbl*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gtbl) & (_db.ind_gtbl_buckets_n - 1);
        gcli::FGtbl* *prev = &_db.ind_gtbl_buckets_elems[index];
        do {
            gcli::FGtbl* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gtbl == row.gtbl) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gtbl_next;
        } while (true);
        if (retval) {
            row.ind_gtbl_next = *prev;
            _db.ind_gtbl_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gtbl.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gtbl_Remove(gcli::FGtbl& row) {
    if (LIKELY(row.ind_gtbl_next != (gcli::FGtbl*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.gtbl) & (_db.ind_gtbl_buckets_n - 1);
        gcli::FGtbl* *prev = &_db.ind_gtbl_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGtbl *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gtbl_next; // unlink (singly linked list)
                _db.ind_gtbl_n--;
                row.ind_gtbl_next = (gcli::FGtbl*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gtbl_next;
        }
    }
}

// --- gcli.FDb.ind_gtbl.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gtbl_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gtbl_buckets_n;
    u32 new_nelems   = _db.ind_gtbl_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGtbl*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGtbl*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGtbl* *new_buckets = (gcli::FGtbl**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gtbl");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gtbl_buckets_n; i++) {
            gcli::FGtbl* elem = _db.ind_gtbl_buckets_elems[i];
            while (elem) {
                gcli::FGtbl &row        = *elem;
                gcli::FGtbl* next       = row.ind_gtbl_next;
                u32 index          = algo::Smallstr250_Hash(0, row.gtbl) & (new_nbuckets-1);
                row.ind_gtbl_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gtbl_buckets_elems, old_size);
        _db.ind_gtbl_buckets_elems = new_buckets;
        _db.ind_gtbl_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.gact.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGact& gcli::gact_Alloc() {
    gcli::FGact* row = gact_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gcli.out_of_mem  field:gcli.FDb.gact  comment:'Alloc failed'");
    }
    return *row;
}

// --- gcli.FDb.gact.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGact* gcli::gact_AllocMaybe() {
    gcli::FGact *row = (gcli::FGact*)gact_AllocMem();
    if (row) {
        new (row) gcli::FGact; // call constructor
    }
    return row;
}

// --- gcli.FDb.gact.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGact* gcli::gact_InsertMaybe(const gclidb::Gact &value) {
    gcli::FGact *row = &gact_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gact_CopyIn(*row,const_cast<gclidb::Gact&>(value));
    bool ok = gact_XrefMaybe(*row); // this may return false
    if (!ok) {
        gact_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gcli.FDb.gact.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gcli::gact_AllocMem() {
    u64 new_nelems     = _db.gact_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gcli::FGact*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gact_lary[bsr];
        if (!lev) {
            lev=(gcli::FGact*)algo_lib::malloc_AllocMem(sizeof(gcli::FGact) * (u64(1)<<bsr));
            _db.gact_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gact_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- gcli.FDb.gact.RemoveAll
// Remove all elements from Lary
void gcli::gact_RemoveAll() {
    for (u64 n = _db.gact_n; n>0; ) {
        n--;
        gact_qFind(u64(n)).~FGact(); // destroy last element
        _db.gact_n = i32(n);
    }
}

// --- gcli.FDb.gact.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::gact_RemoveLast() {
    u64 n = _db.gact_n;
    if (n > 0) {
        n -= 1;
        gact_qFind(u64(n)).~FGact();
        _db.gact_n = i32(n);
    }
}

// --- gcli.FDb.gact.InputMaybe
static bool gcli::gact_InputMaybe(gclidb::Gact &elem) {
    bool retval = true;
    retval = gact_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- gcli.FDb.gact.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gcli::gact_XrefMaybe(gcli::FGact &row) {
    bool retval = true;
    (void)row;
    // insert gact into index ind_gact
    if (true) { // user-defined insert condition
        bool success = ind_gact_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gcli.duplicate_key  xref:gcli.FDb.ind_gact"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gact.Find
// Find row by key. Return NULL if not found.
gcli::FGact* gcli::ind_gact_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_gact_buckets_n - 1);
    gcli::FGact* *e = &_db.ind_gact_buckets_elems[index];
    gcli::FGact* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gact == key;
        if (done) break;
        e         = &ret->ind_gact_next;
    } while (true);
    return ret;
}

// --- gcli.FDb.ind_gact.FindX
// Look up row by key and return reference. Throw exception if not found
gcli::FGact& gcli::ind_gact_FindX(const algo::strptr& key) {
    gcli::FGact* ret = ind_gact_Find(key);
    vrfy(ret, tempstr() << "gcli.key_error  table:ind_gact  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gcli.FDb.ind_gact.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGact& gcli::ind_gact_GetOrCreate(const algo::strptr& key) {
    gcli::FGact* ret = ind_gact_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &gact_Alloc();
        (*ret).gact = key;
        bool good = gact_XrefMaybe(*ret);
        if (!good) {
            gact_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "gcli.create_error  table:ind_gact  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- gcli.FDb.ind_gact.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gcli::ind_gact_InsertMaybe(gcli::FGact& row) {
    ind_gact_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_gact_next == (gcli::FGact*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gact) & (_db.ind_gact_buckets_n - 1);
        gcli::FGact* *prev = &_db.ind_gact_buckets_elems[index];
        do {
            gcli::FGact* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gact == row.gact) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_gact_next;
        } while (true);
        if (retval) {
            row.ind_gact_next = *prev;
            _db.ind_gact_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gcli.FDb.ind_gact.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gcli::ind_gact_Remove(gcli::FGact& row) {
    if (LIKELY(row.ind_gact_next != (gcli::FGact*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gact) & (_db.ind_gact_buckets_n - 1);
        gcli::FGact* *prev = &_db.ind_gact_buckets_elems[index]; // addr of pointer to current element
        while (gcli::FGact *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_gact_next; // unlink (singly linked list)
                _db.ind_gact_n--;
                row.ind_gact_next = (gcli::FGact*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_gact_next;
        }
    }
}

// --- gcli.FDb.ind_gact.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gcli::ind_gact_Reserve(int n) {
    u32 old_nbuckets = _db.ind_gact_buckets_n;
    u32 new_nelems   = _db.ind_gact_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gcli::FGact*);
        u32 new_size = new_nbuckets * sizeof(gcli::FGact*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gcli::FGact* *new_buckets = (gcli::FGact**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FDb.ind_gact");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_gact_buckets_n; i++) {
            gcli::FGact* elem = _db.ind_gact_buckets_elems[i];
            while (elem) {
                gcli::FGact &row        = *elem;
                gcli::FGact* next       = row.ind_gact_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gact) & (new_nbuckets-1);
                row.ind_gact_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_gact_buckets_elems, old_size);
        _db.ind_gact_buckets_elems = new_buckets;
        _db.ind_gact_buckets_n = new_nbuckets;
    }
}

// --- gcli.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr gcli::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- gcli.FDb.trace.N
// Function return 1
inline static i32 gcli::trace_N() {
    return 1;
}

// --- gcli.FDb..Init
// Set all fields to initial values.
void gcli::FDb_Init() {
    // initialize LAry gtype (gcli.FDb.gtype)
    _db.gtype_n = 0;
    memset(_db.gtype_lary, 0, sizeof(_db.gtype_lary)); // zero out all level pointers
    gcli::FGtype* gtype_first = (gcli::FGtype*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtype) * (u64(1)<<4));
    if (!gtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtype_lary[i]  = gtype_first;
        gtype_first    += 1ULL<<i;
    }
    // initialize LAry grepossh (gcli.FDb.grepossh)
    _db.grepossh_n = 0;
    memset(_db.grepossh_lary, 0, sizeof(_db.grepossh_lary)); // zero out all level pointers
    gcli::FGrepossh* grepossh_first = (gcli::FGrepossh*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepossh) * (u64(1)<<4));
    if (!grepossh_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.grepossh_lary[i]  = grepossh_first;
        grepossh_first    += 1ULL<<i;
    }
    // initialize LAry grepogitport (gcli.FDb.grepogitport)
    _db.grepogitport_n = 0;
    memset(_db.grepogitport_lary, 0, sizeof(_db.grepogitport_lary)); // zero out all level pointers
    gcli::FGrepogitport* grepogitport_first = (gcli::FGrepogitport*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepogitport) * (u64(1)<<4));
    if (!grepogitport_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.grepogitport_lary[i]  = grepogitport_first;
        grepogitport_first    += 1ULL<<i;
    }
    // initialize LAry githost (gcli.FDb.githost)
    _db.githost_n = 0;
    memset(_db.githost_lary, 0, sizeof(_db.githost_lary)); // zero out all level pointers
    gcli::FGithost* githost_first = (gcli::FGithost*)algo_lib::malloc_AllocMem(sizeof(gcli::FGithost) * (u64(1)<<4));
    if (!githost_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.githost_lary[i]  = githost_first;
        githost_first    += 1ULL<<i;
    }
    _db.need_auth = bool(false);
    // initialize LAry gstatet (gcli.FDb.gstatet)
    _db.gstatet_n = 0;
    memset(_db.gstatet_lary, 0, sizeof(_db.gstatet_lary)); // zero out all level pointers
    gcli::FGstatet* gstatet_first = (gcli::FGstatet*)algo_lib::malloc_AllocMem(sizeof(gcli::FGstatet) * (u64(1)<<4));
    if (!gstatet_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gstatet_lary[i]  = gstatet_first;
        gstatet_first    += 1ULL<<i;
    }
    // initialize LAry gmethod (gcli.FDb.gmethod)
    _db.gmethod_n = 0;
    memset(_db.gmethod_lary, 0, sizeof(_db.gmethod_lary)); // zero out all level pointers
    gcli::FGmethod* gmethod_first = (gcli::FGmethod*)algo_lib::malloc_AllocMem(sizeof(gcli::FGmethod) * (u64(1)<<4));
    if (!gmethod_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gmethod_lary[i]  = gmethod_first;
        gmethod_first    += 1ULL<<i;
    }
    // initialize LAry gclicmdt (gcli.FDb.gclicmdt)
    _db.gclicmdt_n = 0;
    memset(_db.gclicmdt_lary, 0, sizeof(_db.gclicmdt_lary)); // zero out all level pointers
    gcli::FGclicmdt* gclicmdt_first = (gcli::FGclicmdt*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdt) * (u64(1)<<4));
    if (!gclicmdt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdt_lary[i]  = gclicmdt_first;
        gclicmdt_first    += 1ULL<<i;
    }
    // initialize LAry gclicmdf (gcli.FDb.gclicmdf)
    _db.gclicmdf_n = 0;
    memset(_db.gclicmdf_lary, 0, sizeof(_db.gclicmdf_lary)); // zero out all level pointers
    gcli::FGclicmdf* gclicmdf_first = (gcli::FGclicmdf*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdf) * (u64(1)<<4));
    if (!gclicmdf_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdf_lary[i]  = gclicmdf_first;
        gclicmdf_first    += 1ULL<<i;
    }
    // initialize LAry gclicmdf2j (gcli.FDb.gclicmdf2j)
    _db.gclicmdf2j_n = 0;
    memset(_db.gclicmdf2j_lary, 0, sizeof(_db.gclicmdf2j_lary)); // zero out all level pointers
    gcli::FGclicmdf2j* gclicmdf2j_first = (gcli::FGclicmdf2j*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdf2j) * (u64(1)<<4));
    if (!gclicmdf2j_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdf2j_lary[i]  = gclicmdf2j_first;
        gclicmdf2j_first    += 1ULL<<i;
    }
    // initialize LAry gclicmd (gcli.FDb.gclicmd)
    _db.gclicmd_n = 0;
    memset(_db.gclicmd_lary, 0, sizeof(_db.gclicmd_lary)); // zero out all level pointers
    gcli::FGclicmd* gclicmd_first = (gcli::FGclicmd*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmd) * (u64(1)<<4));
    if (!gclicmd_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmd_lary[i]  = gclicmd_first;
        gclicmd_first    += 1ULL<<i;
    }
    // initialize LAry gtypeh (gcli.FDb.gtypeh)
    _db.gtypeh_n = 0;
    memset(_db.gtypeh_lary, 0, sizeof(_db.gtypeh_lary)); // zero out all level pointers
    gcli::FGtypeh* gtypeh_first = (gcli::FGtypeh*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtypeh) * (u64(1)<<4));
    if (!gtypeh_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtypeh_lary[i]  = gtypeh_first;
        gtypeh_first    += 1ULL<<i;
    }
    _db.p_gtype = NULL;
    _db.p_gtbl = NULL;
    // initialize hash table for gcli::FGclicmd;
    _db.ind_gclicmd_n             	= 0; // (gcli.FDb.ind_gclicmd)
    _db.ind_gclicmd_buckets_n     	= 4; // (gcli.FDb.ind_gclicmd)
    _db.ind_gclicmd_buckets_elems 	= (gcli::FGclicmd**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmd*)*_db.ind_gclicmd_buckets_n); // initial buckets (gcli.FDb.ind_gclicmd)
    if (!_db.ind_gclicmd_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmd)
    }
    memset(_db.ind_gclicmd_buckets_elems, 0, sizeof(gcli::FGclicmd*)*_db.ind_gclicmd_buckets_n); // (gcli.FDb.ind_gclicmd)
    // initialize hash table for gcli::FGclicmdf;
    _db.ind_gclicmdf_n             	= 0; // (gcli.FDb.ind_gclicmdf)
    _db.ind_gclicmdf_buckets_n     	= 4; // (gcli.FDb.ind_gclicmdf)
    _db.ind_gclicmdf_buckets_elems 	= (gcli::FGclicmdf**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdf*)*_db.ind_gclicmdf_buckets_n); // initial buckets (gcli.FDb.ind_gclicmdf)
    if (!_db.ind_gclicmdf_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmdf)
    }
    memset(_db.ind_gclicmdf_buckets_elems, 0, sizeof(gcli::FGclicmdf*)*_db.ind_gclicmdf_buckets_n); // (gcli.FDb.ind_gclicmdf)
    // initialize hash table for gcli::FGclicmdt;
    _db.ind_gclicmdt_n             	= 0; // (gcli.FDb.ind_gclicmdt)
    _db.ind_gclicmdt_buckets_n     	= 4; // (gcli.FDb.ind_gclicmdt)
    _db.ind_gclicmdt_buckets_elems 	= (gcli::FGclicmdt**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdt*)*_db.ind_gclicmdt_buckets_n); // initial buckets (gcli.FDb.ind_gclicmdt)
    if (!_db.ind_gclicmdt_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmdt)
    }
    memset(_db.ind_gclicmdt_buckets_elems, 0, sizeof(gcli::FGclicmdt*)*_db.ind_gclicmdt_buckets_n); // (gcli.FDb.ind_gclicmdt)
    // initialize hash table for gcli::FGmethod;
    _db.ind_gmethod_n             	= 0; // (gcli.FDb.ind_gmethod)
    _db.ind_gmethod_buckets_n     	= 4; // (gcli.FDb.ind_gmethod)
    _db.ind_gmethod_buckets_elems 	= (gcli::FGmethod**)algo_lib::malloc_AllocMem(sizeof(gcli::FGmethod*)*_db.ind_gmethod_buckets_n); // initial buckets (gcli.FDb.ind_gmethod)
    if (!_db.ind_gmethod_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gmethod)
    }
    memset(_db.ind_gmethod_buckets_elems, 0, sizeof(gcli::FGmethod*)*_db.ind_gmethod_buckets_n); // (gcli.FDb.ind_gmethod)
    // initialize hash table for gcli::FGrepo;
    _db.ind_grepo_n             	= 0; // (gcli.FDb.ind_grepo)
    _db.ind_grepo_buckets_n     	= 4; // (gcli.FDb.ind_grepo)
    _db.ind_grepo_buckets_elems 	= (gcli::FGrepo**)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepo*)*_db.ind_grepo_buckets_n); // initial buckets (gcli.FDb.ind_grepo)
    if (!_db.ind_grepo_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_grepo)
    }
    memset(_db.ind_grepo_buckets_elems, 0, sizeof(gcli::FGrepo*)*_db.ind_grepo_buckets_n); // (gcli.FDb.ind_grepo)
    // initialize hash table for gcli::FIssue;
    _db.ind_issue_n             	= 0; // (gcli.FDb.ind_issue)
    _db.ind_issue_buckets_n     	= 4; // (gcli.FDb.ind_issue)
    _db.ind_issue_buckets_elems 	= (gcli::FIssue**)algo_lib::malloc_AllocMem(sizeof(gcli::FIssue*)*_db.ind_issue_buckets_n); // initial buckets (gcli.FDb.ind_issue)
    if (!_db.ind_issue_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_issue)
    }
    memset(_db.ind_issue_buckets_elems, 0, sizeof(gcli::FIssue*)*_db.ind_issue_buckets_n); // (gcli.FDb.ind_issue)
    Regx_ReadSql(_db.regx_repo, "%", true);
    // initialize hash table for gcli::FGstatet;
    _db.ind_gstatet_n             	= 0; // (gcli.FDb.ind_gstatet)
    _db.ind_gstatet_buckets_n     	= 4; // (gcli.FDb.ind_gstatet)
    _db.ind_gstatet_buckets_elems 	= (gcli::FGstatet**)algo_lib::malloc_AllocMem(sizeof(gcli::FGstatet*)*_db.ind_gstatet_buckets_n); // initial buckets (gcli.FDb.ind_gstatet)
    if (!_db.ind_gstatet_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gstatet)
    }
    memset(_db.ind_gstatet_buckets_elems, 0, sizeof(gcli::FGstatet*)*_db.ind_gstatet_buckets_n); // (gcli.FDb.ind_gstatet)
    // initialize hash table for gcli::FGithost;
    _db.ind_githost_n             	= 0; // (gcli.FDb.ind_githost)
    _db.ind_githost_buckets_n     	= 4; // (gcli.FDb.ind_githost)
    _db.ind_githost_buckets_elems 	= (gcli::FGithost**)algo_lib::malloc_AllocMem(sizeof(gcli::FGithost*)*_db.ind_githost_buckets_n); // initial buckets (gcli.FDb.ind_githost)
    if (!_db.ind_githost_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_githost)
    }
    memset(_db.ind_githost_buckets_elems, 0, sizeof(gcli::FGithost*)*_db.ind_githost_buckets_n); // (gcli.FDb.ind_githost)
    // initialize hash table for gcli::FGrepogitport;
    _db.ind_grepogitport_n             	= 0; // (gcli.FDb.ind_grepogitport)
    _db.ind_grepogitport_buckets_n     	= 4; // (gcli.FDb.ind_grepogitport)
    _db.ind_grepogitport_buckets_elems 	= (gcli::FGrepogitport**)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepogitport*)*_db.ind_grepogitport_buckets_n); // initial buckets (gcli.FDb.ind_grepogitport)
    if (!_db.ind_grepogitport_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_grepogitport)
    }
    memset(_db.ind_grepogitport_buckets_elems, 0, sizeof(gcli::FGrepogitport*)*_db.ind_grepogitport_buckets_n); // (gcli.FDb.ind_grepogitport)
    // initialize hash table for gcli::FGrepossh;
    _db.ind_grepossh_n             	= 0; // (gcli.FDb.ind_grepossh)
    _db.ind_grepossh_buckets_n     	= 4; // (gcli.FDb.ind_grepossh)
    _db.ind_grepossh_buckets_elems 	= (gcli::FGrepossh**)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepossh*)*_db.ind_grepossh_buckets_n); // initial buckets (gcli.FDb.ind_grepossh)
    if (!_db.ind_grepossh_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_grepossh)
    }
    memset(_db.ind_grepossh_buckets_elems, 0, sizeof(gcli::FGrepossh*)*_db.ind_grepossh_buckets_n); // (gcli.FDb.ind_grepossh)
    // initialize hash table for gcli::FGtype;
    _db.ind_gtype_n             	= 0; // (gcli.FDb.ind_gtype)
    _db.ind_gtype_buckets_n     	= 4; // (gcli.FDb.ind_gtype)
    _db.ind_gtype_buckets_elems 	= (gcli::FGtype**)algo_lib::malloc_AllocMem(sizeof(gcli::FGtype*)*_db.ind_gtype_buckets_n); // initial buckets (gcli.FDb.ind_gtype)
    if (!_db.ind_gtype_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gtype)
    }
    memset(_db.ind_gtype_buckets_elems, 0, sizeof(gcli::FGtype*)*_db.ind_gtype_buckets_n); // (gcli.FDb.ind_gtype)
    _db.c_gclicmd_elems = NULL; // (gcli.FDb.c_gclicmd)
    _db.c_gclicmd_n = 0; // (gcli.FDb.c_gclicmd)
    _db.c_gclicmd_max = 0; // (gcli.FDb.c_gclicmd)
    // initialize LAry gclicmdj2f (gcli.FDb.gclicmdj2f)
    _db.gclicmdj2f_n = 0;
    memset(_db.gclicmdj2f_lary, 0, sizeof(_db.gclicmdj2f_lary)); // zero out all level pointers
    gcli::FGclicmdj2f* gclicmdj2f_first = (gcli::FGclicmdj2f*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdj2f) * (u64(1)<<4));
    if (!gclicmdj2f_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdj2f_lary[i]  = gclicmdj2f_first;
        gclicmdj2f_first    += 1ULL<<i;
    }
    // initialize LAry gclicmdc (gcli.FDb.gclicmdc)
    _db.gclicmdc_n = 0;
    memset(_db.gclicmdc_lary, 0, sizeof(_db.gclicmdc_lary)); // zero out all level pointers
    gcli::FGclicmdc* gclicmdc_first = (gcli::FGclicmdc*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdc) * (u64(1)<<4));
    if (!gclicmdc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdc_lary[i]  = gclicmdc_first;
        gclicmdc_first    += 1ULL<<i;
    }
    // initialize LAry gclicmdarg (gcli.FDb.gclicmdarg)
    _db.gclicmdarg_n = 0;
    memset(_db.gclicmdarg_lary, 0, sizeof(_db.gclicmdarg_lary)); // zero out all level pointers
    gcli::FGclicmdarg* gclicmdarg_first = (gcli::FGclicmdarg*)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdarg) * (u64(1)<<4));
    if (!gclicmdarg_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gclicmdarg_lary[i]  = gclicmdarg_first;
        gclicmdarg_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FGclicmdj2f;
    _db.ind_gclicmdj2f_n             	= 0; // (gcli.FDb.ind_gclicmdj2f)
    _db.ind_gclicmdj2f_buckets_n     	= 4; // (gcli.FDb.ind_gclicmdj2f)
    _db.ind_gclicmdj2f_buckets_elems 	= (gcli::FGclicmdj2f**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdj2f*)*_db.ind_gclicmdj2f_buckets_n); // initial buckets (gcli.FDb.ind_gclicmdj2f)
    if (!_db.ind_gclicmdj2f_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmdj2f)
    }
    memset(_db.ind_gclicmdj2f_buckets_elems, 0, sizeof(gcli::FGclicmdj2f*)*_db.ind_gclicmdj2f_buckets_n); // (gcli.FDb.ind_gclicmdj2f)
    // initialize hash table for gcli::FGclicmdarg;
    _db.ind_gclicmdarg_n             	= 0; // (gcli.FDb.ind_gclicmdarg)
    _db.ind_gclicmdarg_buckets_n     	= 4; // (gcli.FDb.ind_gclicmdarg)
    _db.ind_gclicmdarg_buckets_elems 	= (gcli::FGclicmdarg**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdarg*)*_db.ind_gclicmdarg_buckets_n); // initial buckets (gcli.FDb.ind_gclicmdarg)
    if (!_db.ind_gclicmdarg_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmdarg)
    }
    memset(_db.ind_gclicmdarg_buckets_elems, 0, sizeof(gcli::FGclicmdarg*)*_db.ind_gclicmdarg_buckets_n); // (gcli.FDb.ind_gclicmdarg)
    // initialize hash table for gcli::FGclicmdc;
    _db.ind_gclicmdc_n             	= 0; // (gcli.FDb.ind_gclicmdc)
    _db.ind_gclicmdc_buckets_n     	= 4; // (gcli.FDb.ind_gclicmdc)
    _db.ind_gclicmdc_buckets_elems 	= (gcli::FGclicmdc**)algo_lib::malloc_AllocMem(sizeof(gcli::FGclicmdc*)*_db.ind_gclicmdc_buckets_n); // initial buckets (gcli.FDb.ind_gclicmdc)
    if (!_db.ind_gclicmdc_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gclicmdc)
    }
    memset(_db.ind_gclicmdc_buckets_elems, 0, sizeof(gcli::FGclicmdc*)*_db.ind_gclicmdc_buckets_n); // (gcli.FDb.ind_gclicmdc)
    // initialize LAry issue (gcli.FDb.issue)
    _db.issue_n = 0;
    memset(_db.issue_lary, 0, sizeof(_db.issue_lary)); // zero out all level pointers
    gcli::FIssue* issue_first = (gcli::FIssue*)algo_lib::malloc_AllocMem(sizeof(gcli::FIssue) * (u64(1)<<4));
    if (!issue_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.issue_lary[i]  = issue_first;
        issue_first    += 1ULL<<i;
    }
    // initialize LAry grepo (gcli.FDb.grepo)
    _db.grepo_n = 0;
    memset(_db.grepo_lary, 0, sizeof(_db.grepo_lary)); // zero out all level pointers
    gcli::FGrepo* grepo_first = (gcli::FGrepo*)algo_lib::malloc_AllocMem(sizeof(gcli::FGrepo) * (u64(1)<<4));
    if (!grepo_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.grepo_lary[i]  = grepo_first;
        grepo_first    += 1ULL<<i;
    }
    // initialize LAry tuples (gcli.FDb.tuples)
    _db.tuples_n = 0;
    memset(_db.tuples_lary, 0, sizeof(_db.tuples_lary)); // zero out all level pointers
    gcli::FTuples* tuples_first = (gcli::FTuples*)algo_lib::malloc_AllocMem(sizeof(gcli::FTuples) * (u64(1)<<4));
    if (!tuples_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tuples_lary[i]  = tuples_first;
        tuples_first    += 1ULL<<i;
    }
    // initialize LAry issuenote (gcli.FDb.issuenote)
    _db.issuenote_n = 0;
    memset(_db.issuenote_lary, 0, sizeof(_db.issuenote_lary)); // zero out all level pointers
    gcli::FIssuenote* issuenote_first = (gcli::FIssuenote*)algo_lib::malloc_AllocMem(sizeof(gcli::FIssuenote) * (u64(1)<<4));
    if (!issuenote_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.issuenote_lary[i]  = issuenote_first;
        issuenote_first    += 1ULL<<i;
    }
    // initialize LAry mrjob (gcli.FDb.mrjob)
    _db.mrjob_n = 0;
    memset(_db.mrjob_lary, 0, sizeof(_db.mrjob_lary)); // zero out all level pointers
    gcli::FMrjob* mrjob_first = (gcli::FMrjob*)algo_lib::malloc_AllocMem(sizeof(gcli::FMrjob) * (u64(1)<<4));
    if (!mrjob_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mrjob_lary[i]  = mrjob_first;
        mrjob_first    += 1ULL<<i;
    }
    // initialize LAry mrnote (gcli.FDb.mrnote)
    _db.mrnote_n = 0;
    memset(_db.mrnote_lary, 0, sizeof(_db.mrnote_lary)); // zero out all level pointers
    gcli::FMrnote* mrnote_first = (gcli::FMrnote*)algo_lib::malloc_AllocMem(sizeof(gcli::FMrnote) * (u64(1)<<4));
    if (!mrnote_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mrnote_lary[i]  = mrnote_first;
        mrnote_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FMrnote;
    _db.ind_mrnote_n             	= 0; // (gcli.FDb.ind_mrnote)
    _db.ind_mrnote_buckets_n     	= 4; // (gcli.FDb.ind_mrnote)
    _db.ind_mrnote_buckets_elems 	= (gcli::FMrnote**)algo_lib::malloc_AllocMem(sizeof(gcli::FMrnote*)*_db.ind_mrnote_buckets_n); // initial buckets (gcli.FDb.ind_mrnote)
    if (!_db.ind_mrnote_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_mrnote)
    }
    memset(_db.ind_mrnote_buckets_elems, 0, sizeof(gcli::FMrnote*)*_db.ind_mrnote_buckets_n); // (gcli.FDb.ind_mrnote)
    // initialize hash table for gcli::FIssuenote;
    _db.ind_issuenote_n             	= 0; // (gcli.FDb.ind_issuenote)
    _db.ind_issuenote_buckets_n     	= 4; // (gcli.FDb.ind_issuenote)
    _db.ind_issuenote_buckets_elems 	= (gcli::FIssuenote**)algo_lib::malloc_AllocMem(sizeof(gcli::FIssuenote*)*_db.ind_issuenote_buckets_n); // initial buckets (gcli.FDb.ind_issuenote)
    if (!_db.ind_issuenote_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_issuenote)
    }
    memset(_db.ind_issuenote_buckets_elems, 0, sizeof(gcli::FIssuenote*)*_db.ind_issuenote_buckets_n); // (gcli.FDb.ind_issuenote)
    // initialize hash table for gcli::FMrjob;
    _db.ind_mrjob_n             	= 0; // (gcli.FDb.ind_mrjob)
    _db.ind_mrjob_buckets_n     	= 4; // (gcli.FDb.ind_mrjob)
    _db.ind_mrjob_buckets_elems 	= (gcli::FMrjob**)algo_lib::malloc_AllocMem(sizeof(gcli::FMrjob*)*_db.ind_mrjob_buckets_n); // initial buckets (gcli.FDb.ind_mrjob)
    if (!_db.ind_mrjob_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_mrjob)
    }
    memset(_db.ind_mrjob_buckets_elems, 0, sizeof(gcli::FMrjob*)*_db.ind_mrjob_buckets_n); // (gcli.FDb.ind_mrjob)
    // initialize LAry user (gcli.FDb.user)
    _db.user_n = 0;
    memset(_db.user_lary, 0, sizeof(_db.user_lary)); // zero out all level pointers
    gcli::FUser* user_first = (gcli::FUser*)algo_lib::malloc_AllocMem(sizeof(gcli::FUser) * (u64(1)<<4));
    if (!user_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.user_lary[i]  = user_first;
        user_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FUser;
    _db.ind_user_n             	= 0; // (gcli.FDb.ind_user)
    _db.ind_user_buckets_n     	= 4; // (gcli.FDb.ind_user)
    _db.ind_user_buckets_elems 	= (gcli::FUser**)algo_lib::malloc_AllocMem(sizeof(gcli::FUser*)*_db.ind_user_buckets_n); // initial buckets (gcli.FDb.ind_user)
    if (!_db.ind_user_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_user)
    }
    memset(_db.ind_user_buckets_elems, 0, sizeof(gcli::FUser*)*_db.ind_user_buckets_n); // (gcli.FDb.ind_user)
    // initialize hash table for gcli::FMr;
    _db.ind_mr_n             	= 0; // (gcli.FDb.ind_mr)
    _db.ind_mr_buckets_n     	= 4; // (gcli.FDb.ind_mr)
    _db.ind_mr_buckets_elems 	= (gcli::FMr**)algo_lib::malloc_AllocMem(sizeof(gcli::FMr*)*_db.ind_mr_buckets_n); // initial buckets (gcli.FDb.ind_mr)
    if (!_db.ind_mr_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_mr)
    }
    memset(_db.ind_mr_buckets_elems, 0, sizeof(gcli::FMr*)*_db.ind_mr_buckets_n); // (gcli.FDb.ind_mr)
    // initialize hash table for gcli::FMilestone;
    _db.ind_milestone_n             	= 0; // (gcli.FDb.ind_milestone)
    _db.ind_milestone_buckets_n     	= 4; // (gcli.FDb.ind_milestone)
    _db.ind_milestone_buckets_elems 	= (gcli::FMilestone**)algo_lib::malloc_AllocMem(sizeof(gcli::FMilestone*)*_db.ind_milestone_buckets_n); // initial buckets (gcli.FDb.ind_milestone)
    if (!_db.ind_milestone_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_milestone)
    }
    memset(_db.ind_milestone_buckets_elems, 0, sizeof(gcli::FMilestone*)*_db.ind_milestone_buckets_n); // (gcli.FDb.ind_milestone)
    // initialize LAry milestone (gcli.FDb.milestone)
    _db.milestone_n = 0;
    memset(_db.milestone_lary, 0, sizeof(_db.milestone_lary)); // zero out all level pointers
    gcli::FMilestone* milestone_first = (gcli::FMilestone*)algo_lib::malloc_AllocMem(sizeof(gcli::FMilestone) * (u64(1)<<4));
    if (!milestone_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.milestone_lary[i]  = milestone_first;
        milestone_first    += 1ULL<<i;
    }
    // initialize LAry mr (gcli.FDb.mr)
    _db.mr_n = 0;
    memset(_db.mr_lary, 0, sizeof(_db.mr_lary)); // zero out all level pointers
    gcli::FMr* mr_first = (gcli::FMr*)algo_lib::malloc_AllocMem(sizeof(gcli::FMr) * (u64(1)<<4));
    if (!mr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mr_lary[i]  = mr_first;
        mr_first    += 1ULL<<i;
    }
    // initialize LAry gtypeprefix (gcli.FDb.gtypeprefix)
    _db.gtypeprefix_n = 0;
    memset(_db.gtypeprefix_lary, 0, sizeof(_db.gtypeprefix_lary)); // zero out all level pointers
    gcli::FGtypeprefix* gtypeprefix_first = (gcli::FGtypeprefix*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtypeprefix) * (u64(1)<<4));
    if (!gtypeprefix_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtypeprefix_lary[i]  = gtypeprefix_first;
        gtypeprefix_first    += 1ULL<<i;
    }
    // initialize LAry gtblact (gcli.FDb.gtblact)
    _db.gtblact_n = 0;
    memset(_db.gtblact_lary, 0, sizeof(_db.gtblact_lary)); // zero out all level pointers
    gcli::FGtblact* gtblact_first = (gcli::FGtblact*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblact) * (u64(1)<<4));
    if (!gtblact_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtblact_lary[i]  = gtblact_first;
        gtblact_first    += 1ULL<<i;
    }
    // initialize LAry gtblactfld (gcli.FDb.gtblactfld)
    _db.gtblactfld_n = 0;
    memset(_db.gtblactfld_lary, 0, sizeof(_db.gtblactfld_lary)); // zero out all level pointers
    gcli::FGtblactfld* gtblactfld_first = (gcli::FGtblactfld*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblactfld) * (u64(1)<<4));
    if (!gtblactfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtblactfld_lary[i]  = gtblactfld_first;
        gtblactfld_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FGtblact;
    _db.ind_gtblact_n             	= 0; // (gcli.FDb.ind_gtblact)
    _db.ind_gtblact_buckets_n     	= 4; // (gcli.FDb.ind_gtblact)
    _db.ind_gtblact_buckets_elems 	= (gcli::FGtblact**)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblact*)*_db.ind_gtblact_buckets_n); // initial buckets (gcli.FDb.ind_gtblact)
    if (!_db.ind_gtblact_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gtblact)
    }
    memset(_db.ind_gtblact_buckets_elems, 0, sizeof(gcli::FGtblact*)*_db.ind_gtblact_buckets_n); // (gcli.FDb.ind_gtblact)
    _db.zd_gtblact_head = NULL; // (gcli.FDb.zd_gtblact)
    _db.zd_gtblact_n = 0; // (gcli.FDb.zd_gtblact)
    _db.zd_gtblact_tail = NULL; // (gcli.FDb.zd_gtblact)
    // initialize hash table for gcli::FGtblactfld;
    _db.ind_gtblactfld_n             	= 0; // (gcli.FDb.ind_gtblactfld)
    _db.ind_gtblactfld_buckets_n     	= 4; // (gcli.FDb.ind_gtblactfld)
    _db.ind_gtblactfld_buckets_elems 	= (gcli::FGtblactfld**)algo_lib::malloc_AllocMem(sizeof(gcli::FGtblactfld*)*_db.ind_gtblactfld_buckets_n); // initial buckets (gcli.FDb.ind_gtblactfld)
    if (!_db.ind_gtblactfld_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gtblactfld)
    }
    memset(_db.ind_gtblactfld_buckets_elems, 0, sizeof(gcli::FGtblactfld*)*_db.ind_gtblactfld_buckets_n); // (gcli.FDb.ind_gtblactfld)
    // initialize LAry gfld (gcli.FDb.gfld)
    _db.gfld_n = 0;
    memset(_db.gfld_lary, 0, sizeof(_db.gfld_lary)); // zero out all level pointers
    gcli::FGfld* gfld_first = (gcli::FGfld*)algo_lib::malloc_AllocMem(sizeof(gcli::FGfld) * (u64(1)<<4));
    if (!gfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gfld_lary[i]  = gfld_first;
        gfld_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FGfld;
    _db.ind_gfld_n             	= 0; // (gcli.FDb.ind_gfld)
    _db.ind_gfld_buckets_n     	= 4; // (gcli.FDb.ind_gfld)
    _db.ind_gfld_buckets_elems 	= (gcli::FGfld**)algo_lib::malloc_AllocMem(sizeof(gcli::FGfld*)*_db.ind_gfld_buckets_n); // initial buckets (gcli.FDb.ind_gfld)
    if (!_db.ind_gfld_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gfld)
    }
    memset(_db.ind_gfld_buckets_elems, 0, sizeof(gcli::FGfld*)*_db.ind_gfld_buckets_n); // (gcli.FDb.ind_gfld)
    _db.c_gfld_elems = NULL; // (gcli.FDb.c_gfld)
    _db.c_gfld_n = 0; // (gcli.FDb.c_gfld)
    _db.c_gfld_max = 0; // (gcli.FDb.c_gfld)
    // initialize LAry gtbl (gcli.FDb.gtbl)
    _db.gtbl_n = 0;
    memset(_db.gtbl_lary, 0, sizeof(_db.gtbl_lary)); // zero out all level pointers
    gcli::FGtbl* gtbl_first = (gcli::FGtbl*)algo_lib::malloc_AllocMem(sizeof(gcli::FGtbl) * (u64(1)<<4));
    if (!gtbl_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gtbl_lary[i]  = gtbl_first;
        gtbl_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FGtbl;
    _db.ind_gtbl_n             	= 0; // (gcli.FDb.ind_gtbl)
    _db.ind_gtbl_buckets_n     	= 4; // (gcli.FDb.ind_gtbl)
    _db.ind_gtbl_buckets_elems 	= (gcli::FGtbl**)algo_lib::malloc_AllocMem(sizeof(gcli::FGtbl*)*_db.ind_gtbl_buckets_n); // initial buckets (gcli.FDb.ind_gtbl)
    if (!_db.ind_gtbl_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gtbl)
    }
    memset(_db.ind_gtbl_buckets_elems, 0, sizeof(gcli::FGtbl*)*_db.ind_gtbl_buckets_n); // (gcli.FDb.ind_gtbl)
    // initialize LAry gact (gcli.FDb.gact)
    _db.gact_n = 0;
    memset(_db.gact_lary, 0, sizeof(_db.gact_lary)); // zero out all level pointers
    gcli::FGact* gact_first = (gcli::FGact*)algo_lib::malloc_AllocMem(sizeof(gcli::FGact) * (u64(1)<<4));
    if (!gact_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gact_lary[i]  = gact_first;
        gact_first    += 1ULL<<i;
    }
    // initialize hash table for gcli::FGact;
    _db.ind_gact_n             	= 0; // (gcli.FDb.ind_gact)
    _db.ind_gact_buckets_n     	= 4; // (gcli.FDb.ind_gact)
    _db.ind_gact_buckets_elems 	= (gcli::FGact**)algo_lib::malloc_AllocMem(sizeof(gcli::FGact*)*_db.ind_gact_buckets_n); // initial buckets (gcli.FDb.ind_gact)
    if (!_db.ind_gact_buckets_elems) {
        FatalErrorExit("out of memory"); // (gcli.FDb.ind_gact)
    }
    memset(_db.ind_gact_buckets_elems, 0, sizeof(gcli::FGact*)*_db.ind_gact_buckets_n); // (gcli.FDb.ind_gact)

    gcli::InitReflection();
    gclicmd_LoadStatic(); // gen:ns_gstatic  gstatic:gcli.FDb.gclicmd  load gcli.FGclicmd records
    gtblact_LoadStatic(); // gen:ns_gstatic  gstatic:gcli.FDb.gtblact  load gcli.FGtblact records
}

// --- gcli.FDb..Uninit
void gcli::FDb_Uninit() {
    gcli::FDb &row = _db; (void)row;

    // gcli.FDb.ind_gact.Uninit (Thash)  //
    // skip destruction of ind_gact in global scope

    // gcli.FDb.gact.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.ind_gtbl.Uninit (Thash)  //
    // skip destruction of ind_gtbl in global scope

    // gcli.FDb.gtbl.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.c_gfld.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(_db.c_gfld_elems, sizeof(gcli::FGfld*)*_db.c_gfld_max); // (gcli.FDb.c_gfld)

    // gcli.FDb.ind_gfld.Uninit (Thash)  //
    // skip destruction of ind_gfld in global scope

    // gcli.FDb.gfld.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.ind_gtblactfld.Uninit (Thash)  //
    // skip destruction of ind_gtblactfld in global scope

    // gcli.FDb.ind_gtblact.Uninit (Thash)  //
    // skip destruction of ind_gtblact in global scope

    // gcli.FDb.gtblactfld.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gtblact.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gtypeprefix.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.mr.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.milestone.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.ind_milestone.Uninit (Thash)  //
    // skip destruction of ind_milestone in global scope

    // gcli.FDb.ind_mr.Uninit (Thash)  //
    // skip destruction of ind_mr in global scope

    // gcli.FDb.ind_user.Uninit (Thash)  //
    // skip destruction of ind_user in global scope

    // gcli.FDb.user.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.ind_mrjob.Uninit (Thash)  //
    // skip destruction of ind_mrjob in global scope

    // gcli.FDb.ind_issuenote.Uninit (Thash)  //
    // skip destruction of ind_issuenote in global scope

    // gcli.FDb.ind_mrnote.Uninit (Thash)  //
    // skip destruction of ind_mrnote in global scope

    // gcli.FDb.mrnote.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.mrjob.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.issuenote.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.tuples.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.grepo.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.issue.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.ind_gclicmdc.Uninit (Thash)  //
    // skip destruction of ind_gclicmdc in global scope

    // gcli.FDb.ind_gclicmdarg.Uninit (Thash)  //
    // skip destruction of ind_gclicmdarg in global scope

    // gcli.FDb.ind_gclicmdj2f.Uninit (Thash)  //
    // skip destruction of ind_gclicmdj2f in global scope

    // gcli.FDb.gclicmdarg.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmdc.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmdj2f.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.c_gclicmd.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(_db.c_gclicmd_elems, sizeof(gcli::FGclicmd*)*_db.c_gclicmd_max); // (gcli.FDb.c_gclicmd)

    // gcli.FDb.ind_gtype.Uninit (Thash)  //
    // skip destruction of ind_gtype in global scope

    // gcli.FDb.ind_grepossh.Uninit (Thash)  //
    // skip destruction of ind_grepossh in global scope

    // gcli.FDb.ind_grepogitport.Uninit (Thash)  //
    // skip destruction of ind_grepogitport in global scope

    // gcli.FDb.ind_githost.Uninit (Thash)  //
    // skip destruction of ind_githost in global scope

    // gcli.FDb.ind_gstatet.Uninit (Thash)  //
    // skip destruction of ind_gstatet in global scope

    // gcli.FDb.ind_issue.Uninit (Thash)  //
    // skip destruction of ind_issue in global scope

    // gcli.FDb.ind_grepo.Uninit (Thash)  //
    // skip destruction of ind_grepo in global scope

    // gcli.FDb.ind_gmethod.Uninit (Thash)  //
    // skip destruction of ind_gmethod in global scope

    // gcli.FDb.ind_gclicmdt.Uninit (Thash)  //
    // skip destruction of ind_gclicmdt in global scope

    // gcli.FDb.ind_gclicmdf.Uninit (Thash)  //
    // skip destruction of ind_gclicmdf in global scope

    // gcli.FDb.ind_gclicmd.Uninit (Thash)  //
    // skip destruction of ind_gclicmd in global scope

    // gcli.FDb.gtypeh.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmd.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmdf2j.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmdf.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gclicmdt.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gmethod.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gstatet.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.githost.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.grepogitport.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.grepossh.Uninit (Lary)  //
    // skip destruction in global scope

    // gcli.FDb.gtype.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- gcli.FGact.base.CopyOut
// Copy fields out of row
void gcli::gact_CopyOut(gcli::FGact &row, gclidb::Gact &out) {
    out.gact = row.gact;
    out.comment = row.comment;
}

// --- gcli.FGact.base.CopyIn
// Copy fields in to row
void gcli::gact_CopyIn(gcli::FGact &row, gclidb::Gact &in) {
    row.gact = in.gact;
    row.comment = in.comment;
}

// --- gcli.FGact..Uninit
void gcli::FGact_Uninit(gcli::FGact& gact) {
    gcli::FGact &row = gact; (void)row;
    ind_gact_Remove(row); // remove gact from index ind_gact
}

// --- gcli.FGclicmd.base.CopyOut
// Copy fields out of row
void gcli::gclicmd_CopyOut(gcli::FGclicmd &row, gclidb::Gclicmd &out) {
    out.gclicmd = row.gclicmd;
    out.gclicmdf2j = row.gclicmdf2j;
    out.comment = row.comment;
}

// --- gcli.FGclicmd.base.CopyIn
// Copy fields in to row
void gcli::gclicmd_CopyIn(gcli::FGclicmd &row, gclidb::Gclicmd &in) {
    row.gclicmd = in.gclicmd;
    row.gclicmdf2j = in.gclicmdf2j;
    row.comment = in.comment;
}

// --- gcli.FGclicmd.c_tuples.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_tuples_Insert(gcli::FGclicmd& gclicmd, gcli::FTuples& row) {
    // reserve space
    c_tuples_Reserve(gclicmd, 1);
    u32 n  = gclicmd.c_tuples_n;
    u32 at = n;
    gcli::FTuples* *elems = gclicmd.c_tuples_elems;
    elems[at] = &row;
    gclicmd.c_tuples_n = n+1;

}

// --- gcli.FGclicmd.c_tuples.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool gcli::c_tuples_ScanInsertMaybe(gcli::FGclicmd& gclicmd, gcli::FTuples& row) {
    bool retval = true;
    u32 n  = gclicmd.c_tuples_n;
    for (u32 i = 0; i < n; i++) {
        if (gclicmd.c_tuples_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_tuples_Reserve(gclicmd, 1);
        gclicmd.c_tuples_elems[n] = &row;
        gclicmd.c_tuples_n = n+1;
    }
    return retval;
}

// --- gcli.FGclicmd.c_tuples.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_tuples_Remove(gcli::FGclicmd& gclicmd, gcli::FTuples& row) {
    int lim = gclicmd.c_tuples_n;
    gcli::FTuples* *elems = gclicmd.c_tuples_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        gcli::FTuples* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(gcli::FTuples*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            gclicmd.c_tuples_n = lim - 1;
            break;
        }
    }
}

// --- gcli.FGclicmd.c_tuples.Reserve
// Reserve space in index for N more elements;
void gcli::c_tuples_Reserve(gcli::FGclicmd& gclicmd, u32 n) {
    u32 old_max = gclicmd.c_tuples_max;
    if (UNLIKELY(gclicmd.c_tuples_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FTuples*);
        u32 new_size = new_max * sizeof(gcli::FTuples*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmd.c_tuples_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmd.c_tuples");
        }
        gclicmd.c_tuples_elems = (gcli::FTuples**)new_mem;
        gclicmd.c_tuples_max = new_max;
    }
}

// --- gcli.FGclicmd.c_gclicmdarg.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmdarg_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) {
    if (bool_Update(row.gclicmd_c_gclicmdarg_in_ary,true)) {
        // reserve space
        c_gclicmdarg_Reserve(gclicmd, 1);
        u32 n  = gclicmd.c_gclicmdarg_n;
        u32 at = n;
        gcli::FGclicmdarg* *elems = gclicmd.c_gclicmdarg_elems;
        elems[at] = &row;
        gclicmd.c_gclicmdarg_n = n+1;

    }
}

// --- gcli.FGclicmd.c_gclicmdarg.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmdarg_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) {
    bool retval = !row.gclicmd_c_gclicmdarg_in_ary;
    c_gclicmdarg_Insert(gclicmd,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGclicmd.c_gclicmdarg.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmdarg_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) {
    if (bool_Update(row.gclicmd_c_gclicmdarg_in_ary,false)) {
        int lim = gclicmd.c_gclicmdarg_n;
        gcli::FGclicmdarg* *elems = gclicmd.c_gclicmdarg_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGclicmdarg* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGclicmdarg*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gclicmd.c_gclicmdarg_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGclicmd.c_gclicmdarg.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmdarg_Reserve(gcli::FGclicmd& gclicmd, u32 n) {
    u32 old_max = gclicmd.c_gclicmdarg_max;
    if (UNLIKELY(gclicmd.c_gclicmdarg_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmdarg*);
        u32 new_size = new_max * sizeof(gcli::FGclicmdarg*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmd.c_gclicmdarg_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmd.c_gclicmdarg");
        }
        gclicmd.c_gclicmdarg_elems = (gcli::FGclicmdarg**)new_mem;
        gclicmd.c_gclicmdarg_max = new_max;
    }
}

// --- gcli.FGclicmd.c_gclicmdc.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmdc_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) {
    if (bool_Update(row.gclicmd_c_gclicmdc_in_ary,true)) {
        // reserve space
        c_gclicmdc_Reserve(gclicmd, 1);
        u32 n  = gclicmd.c_gclicmdc_n;
        u32 at = n;
        gcli::FGclicmdc* *elems = gclicmd.c_gclicmdc_elems;
        elems[at] = &row;
        gclicmd.c_gclicmdc_n = n+1;

    }
}

// --- gcli.FGclicmd.c_gclicmdc.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmdc_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) {
    bool retval = !row.gclicmd_c_gclicmdc_in_ary;
    c_gclicmdc_Insert(gclicmd,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGclicmd.c_gclicmdc.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmdc_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) {
    if (bool_Update(row.gclicmd_c_gclicmdc_in_ary,false)) {
        int lim = gclicmd.c_gclicmdc_n;
        gcli::FGclicmdc* *elems = gclicmd.c_gclicmdc_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGclicmdc* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGclicmdc*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gclicmd.c_gclicmdc_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGclicmd.c_gclicmdc.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmdc_Reserve(gcli::FGclicmd& gclicmd, u32 n) {
    u32 old_max = gclicmd.c_gclicmdc_max;
    if (UNLIKELY(gclicmd.c_gclicmdc_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmdc*);
        u32 new_size = new_max * sizeof(gcli::FGclicmdc*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmd.c_gclicmdc_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmd.c_gclicmdc");
        }
        gclicmd.c_gclicmdc_elems = (gcli::FGclicmdc**)new_mem;
        gclicmd.c_gclicmdc_max = new_max;
    }
}

// --- gcli.FGclicmd.c_gclicmdf2j.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmdf2j_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) {
    if (bool_Update(row.gclicmd_c_gclicmdf2j_in_ary,true)) {
        // reserve space
        c_gclicmdf2j_Reserve(gclicmd, 1);
        u32 n  = gclicmd.c_gclicmdf2j_n;
        u32 at = n;
        gcli::FGclicmdf2j* *elems = gclicmd.c_gclicmdf2j_elems;
        elems[at] = &row;
        gclicmd.c_gclicmdf2j_n = n+1;

    }
}

// --- gcli.FGclicmd.c_gclicmdf2j.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmdf2j_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) {
    bool retval = !row.gclicmd_c_gclicmdf2j_in_ary;
    c_gclicmdf2j_Insert(gclicmd,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGclicmd.c_gclicmdf2j.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmdf2j_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) {
    if (bool_Update(row.gclicmd_c_gclicmdf2j_in_ary,false)) {
        int lim = gclicmd.c_gclicmdf2j_n;
        gcli::FGclicmdf2j* *elems = gclicmd.c_gclicmdf2j_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGclicmdf2j* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGclicmdf2j*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gclicmd.c_gclicmdf2j_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGclicmd.c_gclicmdf2j.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmdf2j_Reserve(gcli::FGclicmd& gclicmd, u32 n) {
    u32 old_max = gclicmd.c_gclicmdf2j_max;
    if (UNLIKELY(gclicmd.c_gclicmdf2j_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmdf2j*);
        u32 new_size = new_max * sizeof(gcli::FGclicmdf2j*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmd.c_gclicmdf2j_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmd.c_gclicmdf2j");
        }
        gclicmd.c_gclicmdf2j_elems = (gcli::FGclicmdf2j**)new_mem;
        gclicmd.c_gclicmdf2j_max = new_max;
    }
}

// --- gcli.FGclicmd..Init
// Set all fields to initial values.
void gcli::FGclicmd_Init(gcli::FGclicmd& gclicmd) {
    gclicmd.select = bool(false);
    gclicmd.write_auth = bool(false);
    gclicmd.finish = bool(false);
    gclicmd.method = u32(0);
    gclicmd.p_issue = NULL;
    gclicmd.p_mr = NULL;
    gclicmd.c_tuples_elems = NULL; // (gcli.FGclicmd.c_tuples)
    gclicmd.c_tuples_n = 0; // (gcli.FGclicmd.c_tuples)
    gclicmd.c_tuples_max = 0; // (gcli.FGclicmd.c_tuples)
    gclicmd.c_gclicmdarg_elems = NULL; // (gcli.FGclicmd.c_gclicmdarg)
    gclicmd.c_gclicmdarg_n = 0; // (gcli.FGclicmd.c_gclicmdarg)
    gclicmd.c_gclicmdarg_max = 0; // (gcli.FGclicmd.c_gclicmdarg)
    gclicmd.c_gclicmdc_elems = NULL; // (gcli.FGclicmd.c_gclicmdc)
    gclicmd.c_gclicmdc_n = 0; // (gcli.FGclicmd.c_gclicmdc)
    gclicmd.c_gclicmdc_max = 0; // (gcli.FGclicmd.c_gclicmdc)
    gclicmd.c_gclicmdf2j_elems = NULL; // (gcli.FGclicmd.c_gclicmdf2j)
    gclicmd.c_gclicmdf2j_n = 0; // (gcli.FGclicmd.c_gclicmdf2j)
    gclicmd.c_gclicmdf2j_max = 0; // (gcli.FGclicmd.c_gclicmdf2j)
    gclicmd.p_gclicmd = NULL;
    gclicmd._db_c_gclicmd_in_ary = bool(false);
    gclicmd.ind_gclicmd_next = (gcli::FGclicmd*)-1; // (gcli.FDb.ind_gclicmd) not-in-hash
    gclicmd.step = NULL;
}

// --- gcli.FGclicmd..Uninit
void gcli::FGclicmd_Uninit(gcli::FGclicmd& gclicmd) {
    gcli::FGclicmd &row = gclicmd; (void)row;
    ind_gclicmd_Remove(row); // remove gclicmd from index ind_gclicmd

    // gcli.FGclicmd.c_gclicmdf2j.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmd.c_gclicmdf2j_elems, sizeof(gcli::FGclicmdf2j*)*gclicmd.c_gclicmdf2j_max); // (gcli.FGclicmd.c_gclicmdf2j)

    // gcli.FGclicmd.c_gclicmdc.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmd.c_gclicmdc_elems, sizeof(gcli::FGclicmdc*)*gclicmd.c_gclicmdc_max); // (gcli.FGclicmd.c_gclicmdc)

    // gcli.FGclicmd.c_gclicmdarg.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmd.c_gclicmdarg_elems, sizeof(gcli::FGclicmdarg*)*gclicmd.c_gclicmdarg_max); // (gcli.FGclicmd.c_gclicmdarg)

    // gcli.FGclicmd.c_tuples.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmd.c_tuples_elems, sizeof(gcli::FTuples*)*gclicmd.c_tuples_max); // (gcli.FGclicmd.c_tuples)
}

// --- gcli.FGclicmdarg.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdarg& gclicmdarg) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdarg.gclicmdarg, "@LL"));
    return ret;
}

// --- gcli.FGclicmdarg.arg.Get
algo::cstring gcli::arg_Get(gcli::FGclicmdarg& gclicmdarg) {
    algo::cstring ret(algo::Pathcomp(gclicmdarg.gclicmdarg, "@LR"));
    return ret;
}

// --- gcli.FGclicmdarg..Concat_gclicmd_arg
tempstr gcli::FGclicmdarg_Concat_gclicmd_arg( const algo::strptr& gclicmd ,const algo::strptr& arg ) {
    return tempstr() << gclicmd <<'@'<< arg ;
}

// --- gcli.FGclicmdarg..Uninit
void gcli::FGclicmdarg_Uninit(gcli::FGclicmdarg& gclicmdarg) {
    gcli::FGclicmdarg &row = gclicmdarg; (void)row;
    ind_gclicmdarg_Remove(row); // remove gclicmdarg from index ind_gclicmdarg
}

// --- gcli.FGclicmdc.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdc& gclicmdc) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdc.gclicmdc, "/LL"));
    return ret;
}

// --- gcli.FGclicmdc.ctype.Get
algo::cstring gcli::ctype_Get(gcli::FGclicmdc& gclicmdc) {
    algo::cstring ret(algo::Pathcomp(gclicmdc.gclicmdc, "/LR"));
    return ret;
}

// --- gcli.FGclicmdc.c_gclicmdf.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmdf_Insert(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) {
    if (bool_Update(row.gclicmdc_c_gclicmdf_in_ary,true)) {
        // reserve space
        c_gclicmdf_Reserve(gclicmdc, 1);
        u32 n  = gclicmdc.c_gclicmdf_n;
        u32 at = n;
        gcli::FGclicmdf* *elems = gclicmdc.c_gclicmdf_elems;
        elems[at] = &row;
        gclicmdc.c_gclicmdf_n = n+1;

    }
}

// --- gcli.FGclicmdc.c_gclicmdf.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmdf_InsertMaybe(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) {
    bool retval = !row.gclicmdc_c_gclicmdf_in_ary;
    c_gclicmdf_Insert(gclicmdc,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGclicmdc.c_gclicmdf.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmdf_Remove(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) {
    if (bool_Update(row.gclicmdc_c_gclicmdf_in_ary,false)) {
        int lim = gclicmdc.c_gclicmdf_n;
        gcli::FGclicmdf* *elems = gclicmdc.c_gclicmdf_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGclicmdf* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGclicmdf*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gclicmdc.c_gclicmdf_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGclicmdc.c_gclicmdf.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmdf_Reserve(gcli::FGclicmdc& gclicmdc, u32 n) {
    u32 old_max = gclicmdc.c_gclicmdf_max;
    if (UNLIKELY(gclicmdc.c_gclicmdf_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmdf*);
        u32 new_size = new_max * sizeof(gcli::FGclicmdf*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmdc.c_gclicmdf_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmdc.c_gclicmdf");
        }
        gclicmdc.c_gclicmdf_elems = (gcli::FGclicmdf**)new_mem;
        gclicmdc.c_gclicmdf_max = new_max;
    }
}

// --- gcli.FGclicmdc..Concat_gclicmd_ctype
tempstr gcli::FGclicmdc_Concat_gclicmd_ctype( const algo::strptr& gclicmd ,const algo::strptr& ctype ) {
    return tempstr() << gclicmd <<'/'<< ctype ;
}

// --- gcli.FGclicmdc..Uninit
void gcli::FGclicmdc_Uninit(gcli::FGclicmdc& gclicmdc) {
    gcli::FGclicmdc &row = gclicmdc; (void)row;
    ind_gclicmdc_Remove(row); // remove gclicmdc from index ind_gclicmdc

    // gcli.FGclicmdc.c_gclicmdf.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmdc.c_gclicmdf_elems, sizeof(gcli::FGclicmdf*)*gclicmdc.c_gclicmdf_max); // (gcli.FGclicmdc.c_gclicmdf)
}

// --- gcli.FGclicmdf.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdf& gclicmdf) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdf.gclicmdf, "/RL"));
    return ret;
}

// --- gcli.FGclicmdf.field.Get
algo::Smallstr100 gcli::field_Get(gcli::FGclicmdf& gclicmdf) {
    algo::Smallstr100 ret(algo::Pathcomp(gclicmdf.gclicmdf, "/RR"));
    return ret;
}

// --- gcli.FGclicmdf.name.Get
algo::cstring gcli::name_Get(gcli::FGclicmdf& gclicmdf) {
    algo::cstring ret(algo::Pathcomp(gclicmdf.gclicmdf, ".RR"));
    return ret;
}

// --- gcli.FGclicmdf.gclicmdc.Get
algo::cstring gcli::gclicmdc_Get(gcli::FGclicmdf& gclicmdf) {
    algo::cstring ret(algo::Pathcomp(gclicmdf.gclicmdf, ".RL"));
    return ret;
}

// --- gcli.FGclicmdf..Concat_gclicmd_field
tempstr gcli::FGclicmdf_Concat_gclicmd_field( const algo::strptr& gclicmd ,const algo::strptr& field ) {
    return tempstr() << gclicmd <<'/'<< field ;
}

// --- gcli.FGclicmdf..Concat_gclicmdc_name
tempstr gcli::FGclicmdf_Concat_gclicmdc_name( const algo::strptr& gclicmdc ,const algo::strptr& name ) {
    return tempstr() << gclicmdc <<'.'<< name ;
}

// --- gcli.FGclicmdf..Uninit
void gcli::FGclicmdf_Uninit(gcli::FGclicmdf& gclicmdf) {
    gcli::FGclicmdf &row = gclicmdf; (void)row;
    ind_gclicmdf_Remove(row); // remove gclicmdf from index ind_gclicmdf
}

// --- gcli.FGclicmdf2j.base.CopyOut
// Copy fields out of row
void gcli::gclicmdf2j_CopyOut(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &out) {
    out.gclicmdf2j = row.gclicmdf2j;
    out.dup = row.dup;
    out.comment = row.comment;
}

// --- gcli.FGclicmdf2j.base.CopyIn
// Copy fields in to row
void gcli::gclicmdf2j_CopyIn(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &in) {
    row.gclicmdf2j = in.gclicmdf2j;
    row.dup = in.dup;
    row.comment = in.comment;
}

// --- gcli.FGclicmdf2j.gclicmdf.Get
algo::cstring gcli::gclicmdf_Get(gcli::FGclicmdf2j& gclicmdf2j) {
    algo::cstring ret(algo::Pathcomp(gclicmdf2j.gclicmdf2j, "@LL"));
    return ret;
}

// --- gcli.FGclicmdf2j.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdf2j& gclicmdf2j) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdf2j.gclicmdf2j, "/LL"));
    return ret;
}

// --- gcli.FGclicmdf2j.field.Get
algo::Smallstr100 gcli::field_Get(gcli::FGclicmdf2j& gclicmdf2j) {
    algo::Smallstr100 ret(algo::Pathcomp(gclicmdf2j.gclicmdf2j, "/LR@LL"));
    return ret;
}

// --- gcli.FGclicmdf2j.jkey.Get
algo::cstring gcli::jkey_Get(gcli::FGclicmdf2j& gclicmdf2j) {
    algo::cstring ret(algo::Pathcomp(gclicmdf2j.gclicmdf2j, "/LR@LR"));
    return ret;
}

// --- gcli.FGclicmdf2j..Uninit
void gcli::FGclicmdf2j_Uninit(gcli::FGclicmdf2j& gclicmdf2j) {
    gcli::FGclicmdf2j &row = gclicmdf2j; (void)row;
    gcli::FGclicmd* p_gclicmd = gcli::ind_gclicmd_Find(gclicmd_Get(row));
    if (p_gclicmd)  {
        c_gclicmdf2j_Remove(*p_gclicmd, row);// remove gclicmdf2j from index c_gclicmdf2j
    }
}

// --- gcli.FGclicmdj2f.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdj2f& gclicmdj2f) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdj2f.gclicmdj2f, "/LL"));
    return ret;
}

// --- gcli.FGclicmdj2f.jkey.Get
algo::cstring gcli::jkey_Get(gcli::FGclicmdj2f& gclicmdj2f) {
    algo::cstring ret(algo::Pathcomp(gclicmdj2f.gclicmdj2f, "/LR"));
    return ret;
}

// --- gcli.FGclicmdj2f.c_gclicmdf.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gclicmdf_Insert(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) {
    // reserve space
    c_gclicmdf_Reserve(gclicmdj2f, 1);
    u32 n  = gclicmdj2f.c_gclicmdf_n;
    u32 at = n;
    gcli::FGclicmdf* *elems = gclicmdj2f.c_gclicmdf_elems;
    elems[at] = &row;
    gclicmdj2f.c_gclicmdf_n = n+1;

}

// --- gcli.FGclicmdj2f.c_gclicmdf.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool gcli::c_gclicmdf_ScanInsertMaybe(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) {
    bool retval = true;
    u32 n  = gclicmdj2f.c_gclicmdf_n;
    for (u32 i = 0; i < n; i++) {
        if (gclicmdj2f.c_gclicmdf_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_gclicmdf_Reserve(gclicmdj2f, 1);
        gclicmdj2f.c_gclicmdf_elems[n] = &row;
        gclicmdj2f.c_gclicmdf_n = n+1;
    }
    return retval;
}

// --- gcli.FGclicmdj2f.c_gclicmdf.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gclicmdf_Remove(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) {
    int lim = gclicmdj2f.c_gclicmdf_n;
    gcli::FGclicmdf* *elems = gclicmdj2f.c_gclicmdf_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        gcli::FGclicmdf* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(gcli::FGclicmdf*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            gclicmdj2f.c_gclicmdf_n = lim - 1;
            break;
        }
    }
}

// --- gcli.FGclicmdj2f.c_gclicmdf.Reserve
// Reserve space in index for N more elements;
void gcli::c_gclicmdf_Reserve(gcli::FGclicmdj2f& gclicmdj2f, u32 n) {
    u32 old_max = gclicmdj2f.c_gclicmdf_max;
    if (UNLIKELY(gclicmdj2f.c_gclicmdf_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGclicmdf*);
        u32 new_size = new_max * sizeof(gcli::FGclicmdf*);
        void *new_mem = algo_lib::malloc_ReallocMem(gclicmdj2f.c_gclicmdf_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGclicmdj2f.c_gclicmdf");
        }
        gclicmdj2f.c_gclicmdf_elems = (gcli::FGclicmdf**)new_mem;
        gclicmdj2f.c_gclicmdf_max = new_max;
    }
}

// --- gcli.FGclicmdj2f..Concat_gclicmd_jkey
tempstr gcli::FGclicmdj2f_Concat_gclicmd_jkey( const algo::strptr& gclicmd ,const algo::strptr& jkey ) {
    return tempstr() << gclicmd <<'/'<< jkey ;
}

// --- gcli.FGclicmdj2f..Uninit
void gcli::FGclicmdj2f_Uninit(gcli::FGclicmdj2f& gclicmdj2f) {
    gcli::FGclicmdj2f &row = gclicmdj2f; (void)row;
    ind_gclicmdj2f_Remove(row); // remove gclicmdj2f from index ind_gclicmdj2f

    // gcli.FGclicmdj2f.c_gclicmdf.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gclicmdj2f.c_gclicmdf_elems, sizeof(gcli::FGclicmdf*)*gclicmdj2f.c_gclicmdf_max); // (gcli.FGclicmdj2f.c_gclicmdf)
}

// --- gcli.FGclicmdt.base.CopyOut
// Copy fields out of row
void gcli::gclicmdt_CopyOut(gcli::FGclicmdt &row, gclidb::Gclicmdt &out) {
    out.gclicmdt = row.gclicmdt;
    out.gmethod = row.gmethod;
    out.uri = row.uri;
    out.comment = row.comment;
}

// --- gcli.FGclicmdt.base.CopyIn
// Copy fields in to row
void gcli::gclicmdt_CopyIn(gcli::FGclicmdt &row, gclidb::Gclicmdt &in) {
    row.gclicmdt = in.gclicmdt;
    row.gmethod = in.gmethod;
    row.uri = in.uri;
    row.comment = in.comment;
}

// --- gcli.FGclicmdt.gclicmd.Get
algo::Smallstr250 gcli::gclicmd_Get(gcli::FGclicmdt& gclicmdt) {
    algo::Smallstr250 ret(algo::Pathcomp(gclicmdt.gclicmdt, ".RL"));
    return ret;
}

// --- gcli.FGclicmdt.gtype.Get
algo::Smallstr50 gcli::gtype_Get(gcli::FGclicmdt& gclicmdt) {
    algo::Smallstr50 ret(algo::Pathcomp(gclicmdt.gclicmdt, ".RR"));
    return ret;
}

// --- gcli.FGclicmdt..Uninit
void gcli::FGclicmdt_Uninit(gcli::FGclicmdt& gclicmdt) {
    gcli::FGclicmdt &row = gclicmdt; (void)row;
    ind_gclicmdt_Remove(row); // remove gclicmdt from index ind_gclicmdt
}

// --- gcli.FGfld.base.CopyOut
// Copy fields out of row
void gcli::gfld_CopyOut(gcli::FGfld &row, gclidb::Gfld &out) {
    out.gfld = row.gfld;
    out.comment = row.comment;
}

// --- gcli.FGfld.base.CopyIn
// Copy fields in to row
void gcli::gfld_CopyIn(gcli::FGfld &row, gclidb::Gfld &in) {
    row.gfld = in.gfld;
    row.comment = in.comment;
}

// --- gcli.FGfld.c_gtblactfld.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gtblactfld_Insert(gcli::FGfld& gfld, gcli::FGtblactfld& row) {
    if (bool_Update(row.gfld_c_gtblactfld_in_ary,true)) {
        // reserve space
        c_gtblactfld_Reserve(gfld, 1);
        u32 n  = gfld.c_gtblactfld_n;
        u32 at = n;
        gcli::FGtblactfld* *elems = gfld.c_gtblactfld_elems;
        elems[at] = &row;
        gfld.c_gtblactfld_n = n+1;

    }
}

// --- gcli.FGfld.c_gtblactfld.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gtblactfld_InsertMaybe(gcli::FGfld& gfld, gcli::FGtblactfld& row) {
    bool retval = !row.gfld_c_gtblactfld_in_ary;
    c_gtblactfld_Insert(gfld,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGfld.c_gtblactfld.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gtblactfld_Remove(gcli::FGfld& gfld, gcli::FGtblactfld& row) {
    if (bool_Update(row.gfld_c_gtblactfld_in_ary,false)) {
        int lim = gfld.c_gtblactfld_n;
        gcli::FGtblactfld* *elems = gfld.c_gtblactfld_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGtblactfld* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGtblactfld*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gfld.c_gtblactfld_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGfld.c_gtblactfld.Reserve
// Reserve space in index for N more elements;
void gcli::c_gtblactfld_Reserve(gcli::FGfld& gfld, u32 n) {
    u32 old_max = gfld.c_gtblactfld_max;
    if (UNLIKELY(gfld.c_gtblactfld_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGtblactfld*);
        u32 new_size = new_max * sizeof(gcli::FGtblactfld*);
        void *new_mem = algo_lib::malloc_ReallocMem(gfld.c_gtblactfld_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGfld.c_gtblactfld");
        }
        gfld.c_gtblactfld_elems = (gcli::FGtblactfld**)new_mem;
        gfld.c_gtblactfld_max = new_max;
    }
}

// --- gcli.FGfld..Uninit
void gcli::FGfld_Uninit(gcli::FGfld& gfld) {
    gcli::FGfld &row = gfld; (void)row;
    ind_gfld_Remove(row); // remove gfld from index ind_gfld

    // gcli.FGfld.c_gtblactfld.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gfld.c_gtblactfld_elems, sizeof(gcli::FGtblactfld*)*gfld.c_gtblactfld_max); // (gcli.FGfld.c_gtblactfld)
}

// --- gcli.FGithost..Uninit
void gcli::FGithost_Uninit(gcli::FGithost& githost) {
    gcli::FGithost &row = githost; (void)row;
    ind_githost_Remove(row); // remove githost from index ind_githost
}

// --- gcli.FGmethod.base.CopyOut
// Copy fields out of row
void gcli::gmethod_CopyOut(gcli::FGmethod &row, gclidb::Gmethod &out) {
    out.gmethod = row.gmethod;
    out.val = row.val;
    out.comment = row.comment;
}

// --- gcli.FGmethod.base.CopyIn
// Copy fields in to row
void gcli::gmethod_CopyIn(gcli::FGmethod &row, gclidb::Gmethod &in) {
    row.gmethod = in.gmethod;
    row.val = in.val;
    row.comment = in.comment;
}

// --- gcli.FGmethod..Uninit
void gcli::FGmethod_Uninit(gcli::FGmethod& gmethod) {
    gcli::FGmethod &row = gmethod; (void)row;
    ind_gmethod_Remove(row); // remove gmethod from index ind_gmethod
}

// --- gcli.FGrepo.base.CopyOut
// Copy fields out of row
void gcli::grepo_CopyOut(gcli::FGrepo &row, gclidb::Grepo &out) {
    out.grepo = row.grepo;
    out.name = row.name;
    out.token = row.token;
    out.default_branch = row.default_branch;
    out.keyid = row.keyid;
    out.ssh_repo = row.ssh_repo;
    out.web_url = row.web_url;
    out.descr = row.descr;
    out.active = row.active;
    out.priv = row.priv;
}

// --- gcli.FGrepo.base.CopyIn
// Copy fields in to row
void gcli::grepo_CopyIn(gcli::FGrepo &row, gclidb::Grepo &in) {
    row.grepo = in.grepo;
    row.name = in.name;
    row.token = in.token;
    row.default_branch = in.default_branch;
    row.keyid = in.keyid;
    row.ssh_repo = in.ssh_repo;
    row.web_url = in.web_url;
    row.descr = in.descr;
    row.active = in.active;
    row.priv = in.priv;
}

// --- gcli.FGrepo.host.Get
algo::cstring gcli::host_Get(gcli::FGrepo& grepo) {
    algo::cstring ret(algo::Pathcomp(grepo.grepo, "@LL"));
    return ret;
}

// --- gcli.FGrepo.fname.Get
algo::cstring gcli::fname_Get(gcli::FGrepo& grepo) {
    algo::cstring ret(algo::Pathcomp(grepo.grepo, "@LR"));
    return ret;
}

// --- gcli.FGrepo..Init
// Set all fields to initial values.
void gcli::FGrepo_Init(gcli::FGrepo& grepo) {
    grepo.default_branch = algo::strptr("origin");
    grepo.active = bool(true);
    grepo.select = bool(false);
    grepo.ind_grepo_next = (gcli::FGrepo*)-1; // (gcli.FDb.ind_grepo) not-in-hash
}

// --- gcli.FGrepo..Uninit
void gcli::FGrepo_Uninit(gcli::FGrepo& grepo) {
    gcli::FGrepo &row = grepo; (void)row;
    ind_grepo_Remove(row); // remove grepo from index ind_grepo
}

// --- gcli.FGrepogitport.base.CopyOut
// Copy fields out of row
void gcli::grepogitport_CopyOut(gcli::FGrepogitport &row, gclidb::Grepogitport &out) {
    out.grepogitport = row.grepogitport;
    out.port = row.port;
    out.comment = row.comment;
}

// --- gcli.FGrepogitport.base.CopyIn
// Copy fields in to row
void gcli::grepogitport_CopyIn(gcli::FGrepogitport &row, gclidb::Grepogitport &in) {
    row.grepogitport = in.grepogitport;
    row.port = in.port;
    row.comment = in.comment;
}

// --- gcli.FGrepogitport..Uninit
void gcli::FGrepogitport_Uninit(gcli::FGrepogitport& grepogitport) {
    gcli::FGrepogitport &row = grepogitport; (void)row;
    ind_grepogitport_Remove(row); // remove grepogitport from index ind_grepogitport
}

// --- gcli.FGrepossh.base.CopyOut
// Copy fields out of row
void gcli::grepossh_CopyOut(gcli::FGrepossh &row, gclidb::Grepossh &out) {
    out.grepossh = row.grepossh;
    out.sshid = row.sshid;
    out.comment = row.comment;
}

// --- gcli.FGrepossh.base.CopyIn
// Copy fields in to row
void gcli::grepossh_CopyIn(gcli::FGrepossh &row, gclidb::Grepossh &in) {
    row.grepossh = in.grepossh;
    row.sshid = in.sshid;
    row.comment = in.comment;
}

// --- gcli.FGrepossh.name.Get
algo::cstring gcli::name_Get(gcli::FGrepossh& grepossh) {
    algo::cstring ret(algo::Pathcomp(grepossh.sshid, "/RR"));
    return ret;
}

// --- gcli.FGrepossh..Uninit
void gcli::FGrepossh_Uninit(gcli::FGrepossh& grepossh) {
    gcli::FGrepossh &row = grepossh; (void)row;
    ind_grepossh_Remove(row); // remove grepossh from index ind_grepossh
}

// --- gcli.FGstatet.base.CopyOut
// Copy fields out of row
void gcli::gstatet_CopyOut(gcli::FGstatet &row, gclidb::Gstatet &out) {
    out.gstatet = row.gstatet;
    out.state = row.state;
}

// --- gcli.FGstatet.base.CopyIn
// Copy fields in to row
void gcli::gstatet_CopyIn(gcli::FGstatet &row, gclidb::Gstatet &in) {
    row.gstatet = in.gstatet;
    row.state = in.state;
}

// --- gcli.FGstatet.gtype.Get
algo::Smallstr50 gcli::gtype_Get(gcli::FGstatet& gstatet) {
    algo::Smallstr50 ret(algo::Pathcomp(gstatet.gstatet, ".RR"));
    return ret;
}

// --- gcli.FGstatet.gstate.Get
algo::Smallstr50 gcli::gstate_Get(gcli::FGstatet& gstatet) {
    algo::Smallstr50 ret(algo::Pathcomp(gstatet.gstatet, ".RL"));
    return ret;
}

// --- gcli.FGstatet..Uninit
void gcli::FGstatet_Uninit(gcli::FGstatet& gstatet) {
    gcli::FGstatet &row = gstatet; (void)row;
    ind_gstatet_Remove(row); // remove gstatet from index ind_gstatet
}

// --- gcli.FGtbl.base.CopyOut
// Copy fields out of row
void gcli::gtbl_CopyOut(gcli::FGtbl &row, gclidb::Gtbl &out) {
    out.gtbl = row.gtbl;
    out.comment = row.comment;
}

// --- gcli.FGtbl.base.CopyIn
// Copy fields in to row
void gcli::gtbl_CopyIn(gcli::FGtbl &row, gclidb::Gtbl &in) {
    row.gtbl = in.gtbl;
    row.comment = in.comment;
}

// --- gcli.FGtbl.c_gtblact.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gtblact_Insert(gcli::FGtbl& gtbl, gcli::FGtblact& row) {
    if (bool_Update(row.gtbl_c_gtblact_in_ary,true)) {
        // reserve space
        c_gtblact_Reserve(gtbl, 1);
        u32 n  = gtbl.c_gtblact_n;
        u32 at = n;
        gcli::FGtblact* *elems = gtbl.c_gtblact_elems;
        elems[at] = &row;
        gtbl.c_gtblact_n = n+1;

    }
}

// --- gcli.FGtbl.c_gtblact.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gtblact_InsertMaybe(gcli::FGtbl& gtbl, gcli::FGtblact& row) {
    bool retval = !row.gtbl_c_gtblact_in_ary;
    c_gtblact_Insert(gtbl,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGtbl.c_gtblact.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gtblact_Remove(gcli::FGtbl& gtbl, gcli::FGtblact& row) {
    if (bool_Update(row.gtbl_c_gtblact_in_ary,false)) {
        int lim = gtbl.c_gtblact_n;
        gcli::FGtblact* *elems = gtbl.c_gtblact_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGtblact* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGtblact*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gtbl.c_gtblact_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGtbl.c_gtblact.Reserve
// Reserve space in index for N more elements;
void gcli::c_gtblact_Reserve(gcli::FGtbl& gtbl, u32 n) {
    u32 old_max = gtbl.c_gtblact_max;
    if (UNLIKELY(gtbl.c_gtblact_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGtblact*);
        u32 new_size = new_max * sizeof(gcli::FGtblact*);
        void *new_mem = algo_lib::malloc_ReallocMem(gtbl.c_gtblact_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGtbl.c_gtblact");
        }
        gtbl.c_gtblact_elems = (gcli::FGtblact**)new_mem;
        gtbl.c_gtblact_max = new_max;
    }
}

// --- gcli.FGtbl..Uninit
void gcli::FGtbl_Uninit(gcli::FGtbl& gtbl) {
    gcli::FGtbl &row = gtbl; (void)row;
    ind_gtbl_Remove(row); // remove gtbl from index ind_gtbl

    // gcli.FGtbl.c_gtblact.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gtbl.c_gtblact_elems, sizeof(gcli::FGtblact*)*gtbl.c_gtblact_max); // (gcli.FGtbl.c_gtblact)
}

// --- gcli.FGtblact.base.CopyOut
// Copy fields out of row
void gcli::gtblact_CopyOut(gcli::FGtblact &row, gclidb::Gtblact &out) {
    out.gtblact = row.gtblact;
    out.t = row.t;
    out.e = row.e;
    out.auth = row.auth;
}

// --- gcli.FGtblact.base.CopyIn
// Copy fields in to row
void gcli::gtblact_CopyIn(gcli::FGtblact &row, gclidb::Gtblact &in) {
    row.gtblact = in.gtblact;
    row.t = in.t;
    row.e = in.e;
    row.auth = in.auth;
}

// --- gcli.FGtblact.gtbl.Get
algo::Smallstr250 gcli::gtbl_Get(gcli::FGtblact& gtblact) {
    algo::Smallstr250 ret(algo::Pathcomp(gtblact.gtblact, "_LL"));
    return ret;
}

// --- gcli.FGtblact.gact.Get
algo::Smallstr50 gcli::gact_Get(gcli::FGtblact& gtblact) {
    algo::Smallstr50 ret(algo::Pathcomp(gtblact.gtblact, "_LR"));
    return ret;
}

// --- gcli.FGtblact.c_gtblactfld.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gtblactfld_Insert(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) {
    if (bool_Update(row.gtblact_c_gtblactfld_in_ary,true)) {
        // reserve space
        c_gtblactfld_Reserve(gtblact, 1);
        u32 n  = gtblact.c_gtblactfld_n;
        u32 at = n;
        gcli::FGtblactfld* *elems = gtblact.c_gtblactfld_elems;
        elems[at] = &row;
        gtblact.c_gtblactfld_n = n+1;

    }
}

// --- gcli.FGtblact.c_gtblactfld.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gtblactfld_InsertMaybe(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) {
    bool retval = !row.gtblact_c_gtblactfld_in_ary;
    c_gtblactfld_Insert(gtblact,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGtblact.c_gtblactfld.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gtblactfld_Remove(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) {
    if (bool_Update(row.gtblact_c_gtblactfld_in_ary,false)) {
        int lim = gtblact.c_gtblactfld_n;
        gcli::FGtblactfld* *elems = gtblact.c_gtblactfld_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGtblactfld* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGtblactfld*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gtblact.c_gtblactfld_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGtblact.c_gtblactfld.Reserve
// Reserve space in index for N more elements;
void gcli::c_gtblactfld_Reserve(gcli::FGtblact& gtblact, u32 n) {
    u32 old_max = gtblact.c_gtblactfld_max;
    if (UNLIKELY(gtblact.c_gtblactfld_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGtblactfld*);
        u32 new_size = new_max * sizeof(gcli::FGtblactfld*);
        void *new_mem = algo_lib::malloc_ReallocMem(gtblact.c_gtblactfld_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGtblact.c_gtblactfld");
        }
        gtblact.c_gtblactfld_elems = (gcli::FGtblactfld**)new_mem;
        gtblact.c_gtblactfld_max = new_max;
    }
}

// --- gcli.FGtblact..Init
// Set all fields to initial values.
void gcli::FGtblact_Init(gcli::FGtblact& gtblact) {
    gtblact.t = bool(false);
    gtblact.e = bool(false);
    gtblact.auth = bool(false);
    gtblact.c_gtblactfld_elems = NULL; // (gcli.FGtblact.c_gtblactfld)
    gtblact.c_gtblactfld_n = 0; // (gcli.FGtblact.c_gtblactfld)
    gtblact.c_gtblactfld_max = 0; // (gcli.FGtblact.c_gtblactfld)
    gtblact.select = bool(false);
    gtblact.gtbl_c_gtblact_in_ary = bool(false);
    gtblact.ind_gtblact_next = (gcli::FGtblact*)-1; // (gcli.FDb.ind_gtblact) not-in-hash
    gtblact.zd_gtblact_next = (gcli::FGtblact*)-1; // (gcli.FDb.zd_gtblact) not-in-list
    gtblact.zd_gtblact_prev = NULL; // (gcli.FDb.zd_gtblact)
    gtblact.step = NULL;
}

// --- gcli.FGtblact..Uninit
void gcli::FGtblact_Uninit(gcli::FGtblact& gtblact) {
    gcli::FGtblact &row = gtblact; (void)row;
    zd_gtblact_Remove(row); // remove gtblact from index zd_gtblact
    ind_gtblact_Remove(row); // remove gtblact from index ind_gtblact

    // gcli.FGtblact.c_gtblactfld.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gtblact.c_gtblactfld_elems, sizeof(gcli::FGtblactfld*)*gtblact.c_gtblactfld_max); // (gcli.FGtblact.c_gtblactfld)
}

// --- gcli.FGtblactfld.base.CopyOut
// Copy fields out of row
void gcli::gtblactfld_CopyOut(gcli::FGtblactfld &row, gclidb::Gtblactfld &out) {
    out.gtblactfld = row.gtblactfld;
    out.dflt = row.dflt;
    out.field_name_dflt = row.field_name_dflt;
    out.optional = row.optional;
    out.regx = row.regx;
    out.comment = row.comment;
}

// --- gcli.FGtblactfld.base.CopyIn
// Copy fields in to row
void gcli::gtblactfld_CopyIn(gcli::FGtblactfld &row, gclidb::Gtblactfld &in) {
    row.gtblactfld = in.gtblactfld;
    row.dflt = in.dflt;
    row.field_name_dflt = in.field_name_dflt;
    row.optional = in.optional;
    row.regx = in.regx;
    row.comment = in.comment;
}

// --- gcli.FGtblactfld.gtblact.Get
algo::Smallstr50 gcli::gtblact_Get(gcli::FGtblactfld& gtblactfld) {
    algo::Smallstr50 ret(algo::Pathcomp(gtblactfld.gtblactfld, ".RL"));
    return ret;
}

// --- gcli.FGtblactfld.field.Get
algo::Smallstr50 gcli::field_Get(gcli::FGtblactfld& gtblactfld) {
    algo::Smallstr50 ret(algo::Pathcomp(gtblactfld.gtblactfld, ".RR"));
    return ret;
}

// --- gcli.FGtblactfld..Init
// Set all fields to initial values.
void gcli::FGtblactfld_Init(gcli::FGtblactfld& gtblactfld) {
    gtblactfld.field_name_dflt = bool(false);
    gtblactfld.optional = bool(false);
    gtblactfld.regx = bool(false);
    gtblactfld.select = bool(false);
    gtblactfld.present = bool(false);
    gtblactfld.update = bool(false);
    gtblactfld.p_gfld = NULL;
    gtblactfld.gfld_c_gtblactfld_in_ary = bool(false);
    gtblactfld.gtblact_c_gtblactfld_in_ary = bool(false);
    gtblactfld.ind_gtblactfld_next = (gcli::FGtblactfld*)-1; // (gcli.FDb.ind_gtblactfld) not-in-hash
}

// --- gcli.FGtblactfld..Uninit
void gcli::FGtblactfld_Uninit(gcli::FGtblactfld& gtblactfld) {
    gcli::FGtblactfld &row = gtblactfld; (void)row;
    gcli::FGtblact* p_gtblact = gcli::ind_gtblact_Find(gtblact_Get(row));
    if (p_gtblact)  {
        c_gtblactfld_Remove(*p_gtblact, row);// remove gtblactfld from index c_gtblactfld
    }
    ind_gtblactfld_Remove(row); // remove gtblactfld from index ind_gtblactfld
    gcli::FGfld* p_field = gcli::ind_gfld_Find(field_Get(row));
    if (p_field)  {
        c_gtblactfld_Remove(*p_field, row);// remove gtblactfld from index c_gtblactfld
    }
}

// --- gcli.FGtype.base.CopyOut
// Copy fields out of row
void gcli::gtype_CopyOut(gcli::FGtype &row, gclidb::Gtype &out) {
    out.gtype = row.gtype;
    out.default_url = row.default_url;
    out.comment = row.comment;
}

// --- gcli.FGtype.base.CopyIn
// Copy fields in to row
void gcli::gtype_CopyIn(gcli::FGtype &row, gclidb::Gtype &in) {
    row.gtype = in.gtype;
    row.default_url = in.default_url;
    row.comment = in.comment;
}

// --- gcli.FGtype.c_gtypeh.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gtypeh_Insert(gcli::FGtype& gtype, gcli::FGtypeh& row) {
    if (bool_Update(row.gtype_c_gtypeh_in_ary,true)) {
        // reserve space
        c_gtypeh_Reserve(gtype, 1);
        u32 n  = gtype.c_gtypeh_n;
        u32 at = n;
        gcli::FGtypeh* *elems = gtype.c_gtypeh_elems;
        elems[at] = &row;
        gtype.c_gtypeh_n = n+1;

    }
}

// --- gcli.FGtype.c_gtypeh.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gtypeh_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeh& row) {
    bool retval = !row.gtype_c_gtypeh_in_ary;
    c_gtypeh_Insert(gtype,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGtype.c_gtypeh.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gtypeh_Remove(gcli::FGtype& gtype, gcli::FGtypeh& row) {
    if (bool_Update(row.gtype_c_gtypeh_in_ary,false)) {
        int lim = gtype.c_gtypeh_n;
        gcli::FGtypeh* *elems = gtype.c_gtypeh_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGtypeh* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGtypeh*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gtype.c_gtypeh_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGtype.c_gtypeh.Reserve
// Reserve space in index for N more elements;
void gcli::c_gtypeh_Reserve(gcli::FGtype& gtype, u32 n) {
    u32 old_max = gtype.c_gtypeh_max;
    if (UNLIKELY(gtype.c_gtypeh_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGtypeh*);
        u32 new_size = new_max * sizeof(gcli::FGtypeh*);
        void *new_mem = algo_lib::malloc_ReallocMem(gtype.c_gtypeh_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGtype.c_gtypeh");
        }
        gtype.c_gtypeh_elems = (gcli::FGtypeh**)new_mem;
        gtype.c_gtypeh_max = new_max;
    }
}

// --- gcli.FGtype.c_gtypeprefix.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_gtypeprefix_Insert(gcli::FGtype& gtype, gcli::FGtypeprefix& row) {
    if (bool_Update(row.gtype_c_gtypeprefix_in_ary,true)) {
        // reserve space
        c_gtypeprefix_Reserve(gtype, 1);
        u32 n  = gtype.c_gtypeprefix_n;
        u32 at = n;
        gcli::FGtypeprefix* *elems = gtype.c_gtypeprefix_elems;
        elems[at] = &row;
        gtype.c_gtypeprefix_n = n+1;

    }
}

// --- gcli.FGtype.c_gtypeprefix.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_gtypeprefix_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeprefix& row) {
    bool retval = !row.gtype_c_gtypeprefix_in_ary;
    c_gtypeprefix_Insert(gtype,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FGtype.c_gtypeprefix.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_gtypeprefix_Remove(gcli::FGtype& gtype, gcli::FGtypeprefix& row) {
    if (bool_Update(row.gtype_c_gtypeprefix_in_ary,false)) {
        int lim = gtype.c_gtypeprefix_n;
        gcli::FGtypeprefix* *elems = gtype.c_gtypeprefix_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FGtypeprefix* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FGtypeprefix*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                gtype.c_gtypeprefix_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FGtype.c_gtypeprefix.Reserve
// Reserve space in index for N more elements;
void gcli::c_gtypeprefix_Reserve(gcli::FGtype& gtype, u32 n) {
    u32 old_max = gtype.c_gtypeprefix_max;
    if (UNLIKELY(gtype.c_gtypeprefix_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FGtypeprefix*);
        u32 new_size = new_max * sizeof(gcli::FGtypeprefix*);
        void *new_mem = algo_lib::malloc_ReallocMem(gtype.c_gtypeprefix_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FGtype.c_gtypeprefix");
        }
        gtype.c_gtypeprefix_elems = (gcli::FGtypeprefix**)new_mem;
        gtype.c_gtypeprefix_max = new_max;
    }
}

// --- gcli.FGtype..Uninit
void gcli::FGtype_Uninit(gcli::FGtype& gtype) {
    gcli::FGtype &row = gtype; (void)row;
    ind_gtype_Remove(row); // remove gtype from index ind_gtype

    // gcli.FGtype.c_gtypeprefix.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gtype.c_gtypeprefix_elems, sizeof(gcli::FGtypeprefix*)*gtype.c_gtypeprefix_max); // (gcli.FGtype.c_gtypeprefix)

    // gcli.FGtype.c_gtypeh.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(gtype.c_gtypeh_elems, sizeof(gcli::FGtypeh*)*gtype.c_gtypeh_max); // (gcli.FGtype.c_gtypeh)
}

// --- gcli.FGtypeh.base.CopyOut
// Copy fields out of row
void gcli::gtypeh_CopyOut(gcli::FGtypeh &row, gclidb::Gtypeh &out) {
    out.gtypeh = row.gtypeh;
    out.header = row.header;
}

// --- gcli.FGtypeh.base.CopyIn
// Copy fields in to row
void gcli::gtypeh_CopyIn(gcli::FGtypeh &row, gclidb::Gtypeh &in) {
    row.gtypeh = in.gtypeh;
    row.header = in.header;
}

// --- gcli.FGtypeh.gtype.Get
algo::Smallstr50 gcli::gtype_Get(gcli::FGtypeh& gtypeh) {
    algo::Smallstr50 ret(algo::Pathcomp(gtypeh.gtypeh, ".RL"));
    return ret;
}

// --- gcli.FGtypeh.name.Get
algo::cstring gcli::name_Get(gcli::FGtypeh& gtypeh) {
    algo::cstring ret(algo::Pathcomp(gtypeh.gtypeh, ".RR"));
    return ret;
}

// --- gcli.FGtypeh..Uninit
void gcli::FGtypeh_Uninit(gcli::FGtypeh& gtypeh) {
    gcli::FGtypeh &row = gtypeh; (void)row;
    gcli::FGtype* p_gtype = gcli::ind_gtype_Find(gtype_Get(row));
    if (p_gtype)  {
        c_gtypeh_Remove(*p_gtype, row);// remove gtypeh from index c_gtypeh
    }
}

// --- gcli.FGtypeprefix.base.CopyOut
// Copy fields out of row
void gcli::gtypeprefix_CopyOut(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &out) {
    out.gtypeprefix = row.gtypeprefix;
    out.comment = row.comment;
}

// --- gcli.FGtypeprefix.base.CopyIn
// Copy fields in to row
void gcli::gtypeprefix_CopyIn(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &in) {
    row.gtypeprefix = in.gtypeprefix;
    row.comment = in.comment;
}

// --- gcli.FGtypeprefix.gtype.Get
algo::Smallstr50 gcli::gtype_Get(gcli::FGtypeprefix& gtypeprefix) {
    algo::Smallstr50 ret(algo::Pathcomp(gtypeprefix.gtypeprefix, ".RL"));
    return ret;
}

// --- gcli.FGtypeprefix.prefix.Get
algo::cstring gcli::prefix_Get(gcli::FGtypeprefix& gtypeprefix) {
    algo::cstring ret(algo::Pathcomp(gtypeprefix.gtypeprefix, ".RR"));
    return ret;
}

// --- gcli.FGtypeprefix..Uninit
void gcli::FGtypeprefix_Uninit(gcli::FGtypeprefix& gtypeprefix) {
    gcli::FGtypeprefix &row = gtypeprefix; (void)row;
    gcli::FGtype* p_gtype = gcli::ind_gtype_Find(gtype_Get(row));
    if (p_gtype)  {
        c_gtypeprefix_Remove(*p_gtype, row);// remove gtypeprefix from index c_gtypeprefix
    }
}

// --- gcli.FHttp.request_method.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gcli::request_method_ToCstr(const gcli::FHttp& parent) {
    const char *ret = NULL;
    switch(request_method_GetEnum(parent)) {
        case gcli_FHttp_request_method_GET : ret = "GET";  break;
        case gcli_FHttp_request_method_POST: ret = "POST";  break;
        case gcli_FHttp_request_method_PUT : ret = "PUT";  break;
        case gcli_FHttp_request_method_PATCH: ret = "PATCH";  break;
        case gcli_FHttp_request_method_DELETE: ret = "DELETE";  break;
    }
    return ret;
}

// --- gcli.FHttp.request_method.Print
// Convert request_method to a string. First, attempt conversion to a known string.
// If no string matches, print request_method as a numeric value.
void gcli::request_method_Print(const gcli::FHttp& parent, algo::cstring &lhs) {
    const char *strval = request_method_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.request_method;
    }
}

// --- gcli.FHttp.request_method.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gcli::request_method_SetStrptrMaybe(gcli::FHttp& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('G','E','T'): {
                    request_method_SetEnum(parent,gcli_FHttp_request_method_GET); ret = true; break;
                }
                case LE_STR3('P','U','T'): {
                    request_method_SetEnum(parent,gcli_FHttp_request_method_PUT); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('P','O','S','T'): {
                    request_method_SetEnum(parent,gcli_FHttp_request_method_POST); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('P','A','T','C','H'): {
                    request_method_SetEnum(parent,gcli_FHttp_request_method_PATCH); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('D','E','L','E','T','E'): {
                    request_method_SetEnum(parent,gcli_FHttp_request_method_DELETE); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gcli.FHttp.request_method.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gcli::request_method_SetStrptr(gcli::FHttp& parent, algo::strptr rhs, gcli_FHttp_request_method_Enum dflt) {
    if (!request_method_SetStrptrMaybe(parent,rhs)) request_method_SetEnum(parent,dflt);
}

// --- gcli.FHttp.response_header.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& gcli::response_header_Alloc(gcli::FHttp& parent) {
    response_header_Reserve(parent, 1);
    int n  = parent.response_header_n;
    int at = n;
    algo::cstring *elems = parent.response_header_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.response_header_n = n+1;
    return elems[at];
}

// --- gcli.FHttp.response_header.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& gcli::response_header_AllocAt(gcli::FHttp& parent, int at) {
    response_header_Reserve(parent, 1);
    int n  = parent.response_header_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("gcli.bad_alloc_at  field:gcli.FHttp.response_header  comment:'index out of range'");
    }
    algo::cstring *elems = parent.response_header_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.response_header_n = n+1;
    return elems[at];
}

// --- gcli.FHttp.response_header.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> gcli::response_header_AllocN(gcli::FHttp& parent, int n_elems) {
    response_header_Reserve(parent, n_elems);
    int old_n  = parent.response_header_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.response_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.response_header_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- gcli.FHttp.response_header.Remove
// Remove item by index. If index outside of range, do nothing.
void gcli::response_header_Remove(gcli::FHttp& parent, u32 i) {
    u32 lim = parent.response_header_n;
    algo::cstring *elems = parent.response_header_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.response_header_n = lim - 1;
    }
}

// --- gcli.FHttp.response_header.RemoveAll
void gcli::response_header_RemoveAll(gcli::FHttp& parent) {
    u32 n = parent.response_header_n;
    while (n > 0) {
        n -= 1;
        parent.response_header_elems[n].~cstring();
        parent.response_header_n = n;
    }
}

// --- gcli.FHttp.response_header.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gcli::response_header_RemoveLast(gcli::FHttp& parent) {
    u64 n = parent.response_header_n;
    if (n > 0) {
        n -= 1;
        response_header_qFind(parent, u64(n)).~cstring();
        parent.response_header_n = n;
    }
}

// --- gcli.FHttp.response_header.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void gcli::response_header_AbsReserve(gcli::FHttp& parent, int n) {
    u32 old_max  = parent.response_header_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.response_header_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.tary_nomem  field:gcli.FHttp.response_header  comment:'out of memory'");
        }
        parent.response_header_elems = (algo::cstring*)new_mem;
        parent.response_header_max = new_max;
    }
}

// --- gcli.FHttp.response_header.Setary
// Copy contents of RHS to PARENT.
void gcli::response_header_Setary(gcli::FHttp& parent, gcli::FHttp &rhs) {
    response_header_RemoveAll(parent);
    int nnew = rhs.response_header_n;
    response_header_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.response_header_elems + i) algo::cstring(response_header_qFind(rhs, i));
        parent.response_header_n = i + 1;
    }
}

// --- gcli.FHttp.response_header.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> gcli::response_header_AllocNVal(gcli::FHttp& parent, int n_elems, const algo::cstring& val) {
    response_header_Reserve(parent, n_elems);
    int old_n  = parent.response_header_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.response_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.response_header_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- gcli.FHttp..Init
// Set all fields to initial values.
void gcli::FHttp_Init(gcli::FHttp& parent) {
    parent.response_status_code = u32(0);
    parent.request_method = u32(gcli_FHttp_request_method_GET);
    parent.response_header_elems 	= 0; // (gcli.FHttp.response_header)
    parent.response_header_n     	= 0; // (gcli.FHttp.response_header)
    parent.response_header_max   	= 0; // (gcli.FHttp.response_header)
    parent.response_content_type_json = bool(false);
    parent.request_body_sent_bytes = u32(0);
}

// --- gcli.FHttp..Uninit
void gcli::FHttp_Uninit(gcli::FHttp& parent) {
    gcli::FHttp &row = parent; (void)row;

    // gcli.FHttp.response_header.Uninit (Tary)  //Array of request headers
    // remove all elements from gcli.FHttp.response_header
    response_header_RemoveAll(parent);
    // free memory for Tary gcli.FHttp.response_header
    algo_lib::malloc_FreeMem(parent.response_header_elems, sizeof(algo::cstring)*parent.response_header_max); // (gcli.FHttp.response_header)
}

// --- gcli.FHttp..Print
// print string representation of gcli::FHttp to string LHS, no header -- cprint:gcli.FHttp.String
void gcli::FHttp_Print(gcli::FHttp & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gcli.FHttp";

    algo::cstring_Print(row.request_uri, temp);
    PrintAttrSpaceReset(str,"request_uri", temp);

    algo::cstring_Print(row.request_content_type, temp);
    PrintAttrSpaceReset(str,"request_content_type", temp);

    algo::cstring_Print(row.request_body, temp);
    PrintAttrSpaceReset(str,"request_body", temp);

    algo::cstring_Print(row.response_status_line, temp);
    PrintAttrSpaceReset(str,"response_status_line", temp);

    u32_Print(row.response_status_code, temp);
    PrintAttrSpaceReset(str,"response_status_code", temp);

    gcli::request_method_Print(row, temp);
    PrintAttrSpaceReset(str,"request_method", temp);

    algo::cstring_Print(row.response_reason_phrase, temp);
    PrintAttrSpaceReset(str,"response_reason_phrase", temp);

    algo::cstring_Print(row.response_content_type, temp);
    PrintAttrSpaceReset(str,"response_content_type", temp);

    algo::cstring_Print(row.response_body, temp);
    PrintAttrSpaceReset(str,"response_body", temp);

    bool_Print(row.response_content_type_json, temp);
    PrintAttrSpaceReset(str,"response_content_type_json", temp);

    lib_json::FParser_Print(row.response_json_parser, temp);
    PrintAttrSpaceReset(str,"response_json_parser", temp);

    u32_Print(row.request_body_sent_bytes, temp);
    PrintAttrSpaceReset(str,"request_body_sent_bytes", temp);
}

// --- gcli.FIssue.base.CopyOut
// Copy fields out of row
void gcli::issue_CopyOut(gcli::FIssue &row, gclidb::Issue &out) {
    out.issue = row.issue;
    out.assignee = row.assignee;
    out.labels = row.labels;
    out.milestone_iid = row.milestone_iid;
    out.milestone_num = row.milestone_num;
    out.milestone = row.milestone;
    out.title = row.title;
    out.author = row.author;
    out.state = row.state;
    out.mr = row.mr;
    out.description = row.description;
}

// --- gcli.FIssue.base.CopyIn
// Copy fields in to row
void gcli::issue_CopyIn(gcli::FIssue &row, gclidb::Issue &in) {
    row.issue = in.issue;
    row.assignee = in.assignee;
    row.labels = in.labels;
    row.milestone_iid = in.milestone_iid;
    row.milestone_num = in.milestone_num;
    row.milestone = in.milestone;
    row.title = in.title;
    row.author = in.author;
    row.state = in.state;
    row.mr = in.mr;
    row.description = in.description;
}

// --- gcli.FIssue.project.Get
algo::Smallstr50 gcli::project_Get(gcli::FIssue& issue) {
    algo::Smallstr50 ret(algo::Pathcomp(issue.issue, ".RL"));
    return ret;
}

// --- gcli.FIssue.iid.Get
algo::cstring gcli::iid_Get(gcli::FIssue& issue) {
    algo::cstring ret(algo::Pathcomp(issue.issue, ".RR"));
    return ret;
}

// --- gcli.FIssue.c_mrjob.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_mrjob_Insert(gcli::FIssue& issue, gcli::FMrjob& row) {
    if (bool_Update(row.issue_c_mrjob_in_ary,true)) {
        // reserve space
        c_mrjob_Reserve(issue, 1);
        u32 n  = issue.c_mrjob_n;
        u32 at = n;
        gcli::FMrjob* *elems = issue.c_mrjob_elems;
        elems[at] = &row;
        issue.c_mrjob_n = n+1;

    }
}

// --- gcli.FIssue.c_mrjob.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_mrjob_InsertMaybe(gcli::FIssue& issue, gcli::FMrjob& row) {
    bool retval = !row.issue_c_mrjob_in_ary;
    c_mrjob_Insert(issue,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FIssue.c_mrjob.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_mrjob_Remove(gcli::FIssue& issue, gcli::FMrjob& row) {
    if (bool_Update(row.issue_c_mrjob_in_ary,false)) {
        int lim = issue.c_mrjob_n;
        gcli::FMrjob* *elems = issue.c_mrjob_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FMrjob* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FMrjob*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                issue.c_mrjob_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FIssue.c_mrjob.Reserve
// Reserve space in index for N more elements;
void gcli::c_mrjob_Reserve(gcli::FIssue& issue, u32 n) {
    u32 old_max = issue.c_mrjob_max;
    if (UNLIKELY(issue.c_mrjob_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FMrjob*);
        u32 new_size = new_max * sizeof(gcli::FMrjob*);
        void *new_mem = algo_lib::malloc_ReallocMem(issue.c_mrjob_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FIssue.c_mrjob");
        }
        issue.c_mrjob_elems = (gcli::FMrjob**)new_mem;
        issue.c_mrjob_max = new_max;
    }
}

// --- gcli.FIssue.c_issuenote.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_issuenote_Insert(gcli::FIssue& issue, gcli::FIssuenote& row) {
    if (bool_Update(row.issue_c_issuenote_in_ary,true)) {
        // reserve space
        c_issuenote_Reserve(issue, 1);
        u32 n  = issue.c_issuenote_n;
        u32 at = n;
        gcli::FIssuenote* *elems = issue.c_issuenote_elems;
        elems[at] = &row;
        issue.c_issuenote_n = n+1;

    }
}

// --- gcli.FIssue.c_issuenote.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_issuenote_InsertMaybe(gcli::FIssue& issue, gcli::FIssuenote& row) {
    bool retval = !row.issue_c_issuenote_in_ary;
    c_issuenote_Insert(issue,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FIssue.c_issuenote.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_issuenote_Remove(gcli::FIssue& issue, gcli::FIssuenote& row) {
    if (bool_Update(row.issue_c_issuenote_in_ary,false)) {
        int lim = issue.c_issuenote_n;
        gcli::FIssuenote* *elems = issue.c_issuenote_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FIssuenote* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FIssuenote*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                issue.c_issuenote_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FIssue.c_issuenote.Reserve
// Reserve space in index for N more elements;
void gcli::c_issuenote_Reserve(gcli::FIssue& issue, u32 n) {
    u32 old_max = issue.c_issuenote_max;
    if (UNLIKELY(issue.c_issuenote_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FIssuenote*);
        u32 new_size = new_max * sizeof(gcli::FIssuenote*);
        void *new_mem = algo_lib::malloc_ReallocMem(issue.c_issuenote_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FIssue.c_issuenote");
        }
        issue.c_issuenote_elems = (gcli::FIssuenote**)new_mem;
        issue.c_issuenote_max = new_max;
    }
}

// --- gcli.FIssue..Init
// Set all fields to initial values.
void gcli::FIssue_Init(gcli::FIssue& issue) {
    issue.select = bool(false);
    issue.p_mr_open = NULL;
    issue.c_mrjob_elems = NULL; // (gcli.FIssue.c_mrjob)
    issue.c_mrjob_n = 0; // (gcli.FIssue.c_mrjob)
    issue.c_mrjob_max = 0; // (gcli.FIssue.c_mrjob)
    issue.c_issuenote_elems = NULL; // (gcli.FIssue.c_issuenote)
    issue.c_issuenote_n = 0; // (gcli.FIssue.c_issuenote)
    issue.c_issuenote_max = 0; // (gcli.FIssue.c_issuenote)
    issue.ind_issue_next = (gcli::FIssue*)-1; // (gcli.FDb.ind_issue) not-in-hash
}

// --- gcli.FIssue..Uninit
void gcli::FIssue_Uninit(gcli::FIssue& issue) {
    gcli::FIssue &row = issue; (void)row;
    ind_issue_Remove(row); // remove issue from index ind_issue

    // gcli.FIssue.c_issuenote.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(issue.c_issuenote_elems, sizeof(gcli::FIssuenote*)*issue.c_issuenote_max); // (gcli.FIssue.c_issuenote)

    // gcli.FIssue.c_mrjob.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(issue.c_mrjob_elems, sizeof(gcli::FMrjob*)*issue.c_mrjob_max); // (gcli.FIssue.c_mrjob)
}

// --- gcli.FIssuenote.base.CopyOut
// Copy fields out of row
void gcli::issuenote_CopyOut(gcli::FIssuenote &row, gclidb::Issuenote &out) {
    out.issuenote = row.issuenote;
    out.note = row.note;
    out.system = row.system;
    out.author = row.author;
}

// --- gcli.FIssuenote.base.CopyIn
// Copy fields in to row
void gcli::issuenote_CopyIn(gcli::FIssuenote &row, gclidb::Issuenote &in) {
    row.issuenote = in.issuenote;
    row.note = in.note;
    row.system = in.system;
    row.author = in.author;
}

// --- gcli.FIssuenote.issue.Get
algo::Smallstr50 gcli::issue_Get(gcli::FIssuenote& issuenote) {
    algo::Smallstr50 ret(algo::Pathcomp(issuenote.issuenote, ".RL"));
    return ret;
}

// --- gcli.FIssuenote.nid.Get
algo::cstring gcli::nid_Get(gcli::FIssuenote& issuenote) {
    algo::cstring ret(algo::Pathcomp(issuenote.issuenote, ".RR"));
    return ret;
}

// --- gcli.FIssuenote..Uninit
void gcli::FIssuenote_Uninit(gcli::FIssuenote& issuenote) {
    gcli::FIssuenote &row = issuenote; (void)row;
    ind_issuenote_Remove(row); // remove issuenote from index ind_issuenote
    gcli::FIssue* p_issue = gcli::ind_issue_Find(issue_Get(row));
    if (p_issue)  {
        c_issuenote_Remove(*p_issue, row);// remove issuenote from index c_issuenote
    }
}

// --- gcli.FMilestone.base.CopyOut
// Copy fields out of row
void gcli::milestone_CopyOut(gcli::FMilestone &row, gclidb::Milestone &out) {
    out.milestone = row.milestone;
    out.description = row.description;
    out.title = row.title;
}

// --- gcli.FMilestone.base.CopyIn
// Copy fields in to row
void gcli::milestone_CopyIn(gcli::FMilestone &row, gclidb::Milestone &in) {
    row.milestone = in.milestone;
    row.description = in.description;
    row.title = in.title;
}

// --- gcli.FMilestone.project.Get
algo::Smallstr50 gcli::project_Get(gcli::FMilestone& milestone) {
    algo::Smallstr50 ret(algo::Pathcomp(milestone.milestone, ".RL"));
    return ret;
}

// --- gcli.FMilestone.iid.Get
algo::cstring gcli::iid_Get(gcli::FMilestone& milestone) {
    algo::cstring ret(algo::Pathcomp(milestone.milestone, ".RR"));
    return ret;
}

// --- gcli.FMilestone..Uninit
void gcli::FMilestone_Uninit(gcli::FMilestone& milestone) {
    gcli::FMilestone &row = milestone; (void)row;
    ind_milestone_Remove(row); // remove milestone from index ind_milestone
}

// --- gcli.FMilestone..Print
// print string representation of gcli::FMilestone to string LHS, no header -- cprint:gcli.FMilestone.String
void gcli::FMilestone_Print(gcli::FMilestone & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gcli.FMilestone";

    algo::Smallstr200_Print(row.milestone, temp);
    PrintAttrSpaceReset(str,"milestone", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);
}

// --- gcli.FMr.base.CopyOut
// Copy fields out of row
void gcli::mr_CopyOut(gcli::FMr &row, gclidb::Mr &out) {
    out.mr = row.mr;
    out.state = row.state;
    out.title = row.title;
    out.description = row.description;
    out.source_branch = row.source_branch;
    out.source_repo = row.source_repo;
    out.reviewer = row.reviewer;
    out.author = row.author;
    out.pipeline_status = row.pipeline_status;
    out.pipeline_id = row.pipeline_id;
    out.draft = row.draft;
    out.node_id = row.node_id;
}

// --- gcli.FMr.base.CopyIn
// Copy fields in to row
void gcli::mr_CopyIn(gcli::FMr &row, gclidb::Mr &in) {
    row.mr = in.mr;
    row.state = in.state;
    row.title = in.title;
    row.description = in.description;
    row.source_branch = in.source_branch;
    row.source_repo = in.source_repo;
    row.reviewer = in.reviewer;
    row.author = in.author;
    row.pipeline_status = in.pipeline_status;
    row.pipeline_id = in.pipeline_id;
    row.draft = in.draft;
    row.node_id = in.node_id;
}

// --- gcli.FMr.proj.Get
algo::Smallstr50 gcli::proj_Get(gcli::FMr& mr) {
    algo::Smallstr50 ret(algo::Pathcomp(mr.mr, ".RL"));
    return ret;
}

// --- gcli.FMr.iid.Get
algo::cstring gcli::iid_Get(gcli::FMr& mr) {
    algo::cstring ret(algo::Pathcomp(mr.mr, ".RR"));
    return ret;
}

// --- gcli.FMr.c_mrnote.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_mrnote_Insert(gcli::FMr& mr, gcli::FMrnote& row) {
    if (bool_Update(row.mr_c_mrnote_in_ary,true)) {
        // reserve space
        c_mrnote_Reserve(mr, 1);
        u32 n  = mr.c_mrnote_n;
        u32 at = n;
        gcli::FMrnote* *elems = mr.c_mrnote_elems;
        elems[at] = &row;
        mr.c_mrnote_n = n+1;

    }
}

// --- gcli.FMr.c_mrnote.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_mrnote_InsertMaybe(gcli::FMr& mr, gcli::FMrnote& row) {
    bool retval = !row.mr_c_mrnote_in_ary;
    c_mrnote_Insert(mr,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FMr.c_mrnote.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_mrnote_Remove(gcli::FMr& mr, gcli::FMrnote& row) {
    if (bool_Update(row.mr_c_mrnote_in_ary,false)) {
        int lim = mr.c_mrnote_n;
        gcli::FMrnote* *elems = mr.c_mrnote_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FMrnote* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FMrnote*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                mr.c_mrnote_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FMr.c_mrnote.Reserve
// Reserve space in index for N more elements;
void gcli::c_mrnote_Reserve(gcli::FMr& mr, u32 n) {
    u32 old_max = mr.c_mrnote_max;
    if (UNLIKELY(mr.c_mrnote_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FMrnote*);
        u32 new_size = new_max * sizeof(gcli::FMrnote*);
        void *new_mem = algo_lib::malloc_ReallocMem(mr.c_mrnote_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FMr.c_mrnote");
        }
        mr.c_mrnote_elems = (gcli::FMrnote**)new_mem;
        mr.c_mrnote_max = new_max;
    }
}

// --- gcli.FMr.c_mrjob.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gcli::c_mrjob_Insert(gcli::FMr& mr, gcli::FMrjob& row) {
    if (bool_Update(row.mr_c_mrjob_in_ary,true)) {
        // reserve space
        c_mrjob_Reserve(mr, 1);
        u32 n  = mr.c_mrjob_n;
        u32 at = n;
        gcli::FMrjob* *elems = mr.c_mrjob_elems;
        elems[at] = &row;
        mr.c_mrjob_n = n+1;

    }
}

// --- gcli.FMr.c_mrjob.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gcli::c_mrjob_InsertMaybe(gcli::FMr& mr, gcli::FMrjob& row) {
    bool retval = !row.mr_c_mrjob_in_ary;
    c_mrjob_Insert(mr,row); // check is performed in _Insert again
    return retval;
}

// --- gcli.FMr.c_mrjob.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gcli::c_mrjob_Remove(gcli::FMr& mr, gcli::FMrjob& row) {
    if (bool_Update(row.mr_c_mrjob_in_ary,false)) {
        int lim = mr.c_mrjob_n;
        gcli::FMrjob* *elems = mr.c_mrjob_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gcli::FMrjob* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gcli::FMrjob*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                mr.c_mrjob_n = lim - 1;
                break;
            }
        }
    }
}

// --- gcli.FMr.c_mrjob.Reserve
// Reserve space in index for N more elements;
void gcli::c_mrjob_Reserve(gcli::FMr& mr, u32 n) {
    u32 old_max = mr.c_mrjob_max;
    if (UNLIKELY(mr.c_mrjob_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gcli::FMrjob*);
        u32 new_size = new_max * sizeof(gcli::FMrjob*);
        void *new_mem = algo_lib::malloc_ReallocMem(mr.c_mrjob_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gcli.out_of_memory  field:gcli.FMr.c_mrjob");
        }
        mr.c_mrjob_elems = (gcli::FMrjob**)new_mem;
        mr.c_mrjob_max = new_max;
    }
}

// --- gcli.FMr..Init
// Set all fields to initial values.
void gcli::FMr_Init(gcli::FMr& mr) {
    mr.c_mrnote_elems = NULL; // (gcli.FMr.c_mrnote)
    mr.c_mrnote_n = 0; // (gcli.FMr.c_mrnote)
    mr.c_mrnote_max = 0; // (gcli.FMr.c_mrnote)
    mr.c_mrjob_elems = NULL; // (gcli.FMr.c_mrjob)
    mr.c_mrjob_n = 0; // (gcli.FMr.c_mrjob)
    mr.c_mrjob_max = 0; // (gcli.FMr.c_mrjob)
    mr.select = bool(false);
    mr.ind_mr_next = (gcli::FMr*)-1; // (gcli.FDb.ind_mr) not-in-hash
}

// --- gcli.FMr..Uninit
void gcli::FMr_Uninit(gcli::FMr& mr) {
    gcli::FMr &row = mr; (void)row;
    ind_mr_Remove(row); // remove mr from index ind_mr

    // gcli.FMr.c_mrjob.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(mr.c_mrjob_elems, sizeof(gcli::FMrjob*)*mr.c_mrjob_max); // (gcli.FMr.c_mrjob)

    // gcli.FMr.c_mrnote.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(mr.c_mrnote_elems, sizeof(gcli::FMrnote*)*mr.c_mrnote_max); // (gcli.FMr.c_mrnote)
}

// --- gcli.FMr..Print
// print string representation of gcli::FMr to string LHS, no header -- cprint:gcli.FMr.String
void gcli::FMr_Print(gcli::FMr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gcli.FMr";

    algo::Smallstr150_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.state, temp);
    PrintAttrSpaceReset(str,"state", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);

    algo::cstring_Print(row.source_branch, temp);
    PrintAttrSpaceReset(str,"source_branch", temp);

    algo::cstring_Print(row.source_repo, temp);
    PrintAttrSpaceReset(str,"source_repo", temp);

    algo::cstring_Print(row.reviewer, temp);
    PrintAttrSpaceReset(str,"reviewer", temp);

    algo::cstring_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr20_Print(row.pipeline_status, temp);
    PrintAttrSpaceReset(str,"pipeline_status", temp);

    algo::cstring_Print(row.pipeline_id, temp);
    PrintAttrSpaceReset(str,"pipeline_id", temp);

    algo::cstring_Print(row.draft, temp);
    PrintAttrSpaceReset(str,"draft", temp);

    algo::cstring_Print(row.node_id, temp);
    PrintAttrSpaceReset(str,"node_id", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);
}

// --- gcli.FMrjob.base.CopyOut
// Copy fields out of row
void gcli::mrjob_CopyOut(gcli::FMrjob &row, gclidb::Mrjob &out) {
    out.mrjob = row.mrjob;
    out.ref = row.ref;
    out.id = row.id;
    out.name = row.name;
    out.pipeline_id = row.pipeline_id;
    out.status = row.status;
    out.runner = row.runner;
}

// --- gcli.FMrjob.base.CopyIn
// Copy fields in to row
void gcli::mrjob_CopyIn(gcli::FMrjob &row, gclidb::Mrjob &in) {
    row.mrjob = in.mrjob;
    row.ref = in.ref;
    row.id = in.id;
    row.name = in.name;
    row.pipeline_id = in.pipeline_id;
    row.status = in.status;
    row.runner = in.runner;
}

// --- gcli.FMrjob.mr.Get
algo::Smallstr150 gcli::mr_Get(gcli::FMrjob& mrjob) {
    algo::Smallstr150 ret(algo::Pathcomp(mrjob.mrjob, "/RL"));
    return ret;
}

// --- gcli.FMrjob.job.Get
algo::cstring gcli::job_Get(gcli::FMrjob& mrjob) {
    algo::cstring ret(algo::Pathcomp(mrjob.mrjob, "/RR"));
    return ret;
}

// --- gcli.FMrjob..Init
// Set all fields to initial values.
void gcli::FMrjob_Init(gcli::FMrjob& mrjob) {
    mrjob.select = bool(false);
    mrjob.issue_c_mrjob_in_ary = bool(false);
    mrjob.mr_c_mrjob_in_ary = bool(false);
    mrjob.ind_mrjob_next = (gcli::FMrjob*)-1; // (gcli.FDb.ind_mrjob) not-in-hash
}

// --- gcli.FMrjob..Uninit
void gcli::FMrjob_Uninit(gcli::FMrjob& mrjob) {
    gcli::FMrjob &row = mrjob; (void)row;
    ind_mrjob_Remove(row); // remove mrjob from index ind_mrjob
    gcli::FMr* p_mr = gcli::ind_mr_Find(mr_Get(row));
    if (p_mr)  {
        c_mrjob_Remove(*p_mr, row);// remove mrjob from index c_mrjob
    }
}

// --- gcli.FMrnote.base.CopyOut
// Copy fields out of row
void gcli::mrnote_CopyOut(gcli::FMrnote &row, gclidb::Mrnote &out) {
    out.system = row.system;
    out.mrnote = row.mrnote;
    out.note = row.note;
    out.author = row.author;
}

// --- gcli.FMrnote.base.CopyIn
// Copy fields in to row
void gcli::mrnote_CopyIn(gcli::FMrnote &row, gclidb::Mrnote &in) {
    row.system = in.system;
    row.mrnote = in.mrnote;
    row.note = in.note;
    row.author = in.author;
}

// --- gcli.FMrnote.nid.Get
algo::cstring gcli::nid_Get(gcli::FMrnote& mrnote) {
    algo::cstring ret(algo::Pathcomp(mrnote.mrnote, ".RR"));
    return ret;
}

// --- gcli.FMrnote.mr.Get
algo::Smallstr150 gcli::mr_Get(gcli::FMrnote& mrnote) {
    algo::Smallstr150 ret(algo::Pathcomp(mrnote.mrnote, ".RL"));
    return ret;
}

// --- gcli.FMrnote..Uninit
void gcli::FMrnote_Uninit(gcli::FMrnote& mrnote) {
    gcli::FMrnote &row = mrnote; (void)row;
    ind_mrnote_Remove(row); // remove mrnote from index ind_mrnote
    gcli::FMr* p_mr = gcli::ind_mr_Find(mr_Get(row));
    if (p_mr)  {
        c_mrnote_Remove(*p_mr, row);// remove mrnote from index c_mrnote
    }
}

// --- gcli.FUser.base.CopyOut
// Copy fields out of row
void gcli::user_CopyOut(gcli::FUser &row, gclidb::User &out) {
    out.user = row.user;
    out.id = row.id;
    out.name = row.name;
}

// --- gcli.FUser.base.CopyIn
// Copy fields in to row
void gcli::user_CopyIn(gcli::FUser &row, gclidb::User &in) {
    row.user = in.user;
    row.id = in.id;
    row.name = in.name;
}

// --- gcli.FUser..Uninit
void gcli::FUser_Uninit(gcli::FUser& user) {
    gcli::FUser &row = user; (void)row;
    ind_user_Remove(row); // remove user from index ind_user
}

// --- gcli.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gcli::value_ToCstr(const gcli::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case gcli_FieldId_value            : ret = "value";  break;
    }
    return ret;
}

// --- gcli.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void gcli::value_Print(const gcli::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- gcli.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gcli::value_SetStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,gcli_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gcli.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gcli::value_SetStrptr(gcli::FieldId& parent, algo::strptr rhs, gcli_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- gcli.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool gcli::value_ReadStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- gcli.FieldId..ReadStrptrMaybe
// Read fields of gcli::FieldId from an ascii string.
// The format of the string is the format of the gcli::FieldId's only field
bool gcli::FieldId_ReadStrptrMaybe(gcli::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- gcli.FieldId..Print
// print string representation of gcli::FieldId to string LHS, no header -- cprint:gcli.FieldId.String
void gcli::FieldId_Print(gcli::FieldId & row, algo::cstring &str) {
    gcli::value_Print(row, str);
}

// --- gcli.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gcli::value_ToCstr(const gcli::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case gcli_TableId_gclidb_Gact      : ret = "gclidb.Gact";  break;
        case gcli_TableId_gclidb_Gclicmdf2j: ret = "gclidb.Gclicmdf2j";  break;
        case gcli_TableId_gclidb_Gclicmdt  : ret = "gclidb.Gclicmdt";  break;
        case gcli_TableId_gclidb_Gfld      : ret = "gclidb.Gfld";  break;
        case gcli_TableId_gclidb_Gmethod   : ret = "gclidb.Gmethod";  break;
        case gcli_TableId_gclidb_Grepo     : ret = "gclidb.Grepo";  break;
        case gcli_TableId_gclidb_Grepogitport: ret = "gclidb.Grepogitport";  break;
        case gcli_TableId_gclidb_Grepossh  : ret = "gclidb.Grepossh";  break;
        case gcli_TableId_gclidb_Gstatet   : ret = "gclidb.Gstatet";  break;
        case gcli_TableId_gclidb_Gtbl      : ret = "gclidb.Gtbl";  break;
        case gcli_TableId_gclidb_Gtblactfld: ret = "gclidb.Gtblactfld";  break;
        case gcli_TableId_gclidb_Gtype     : ret = "gclidb.Gtype";  break;
        case gcli_TableId_gclidb_Gtypeh    : ret = "gclidb.Gtypeh";  break;
        case gcli_TableId_gclidb_Gtypeprefix: ret = "gclidb.Gtypeprefix";  break;
    }
    return ret;
}

// --- gcli.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void gcli::value_Print(const gcli::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- gcli.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gcli::value_SetStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"act",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gact); ret = true; break; }
                    if (memcmp(rhs.elems+8,"fld",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gfld); ret = true; break; }
                    if (memcmp(rhs.elems+8,"tbl",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gtbl); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"act",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gact); ret = true; break; }
                    if (memcmp(rhs.elems+8,"fld",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gfld); ret = true; break; }
                    if (memcmp(rhs.elems+8,"tbl",3)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gtbl); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"repo",4)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Grepo); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gtype); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"repo",4)==0) { value_SetEnum(parent,gcli_TableId_gclidb_grepo); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gtype); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"typeh",5)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gtypeh); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"typeh",5)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gtypeh); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"method",6)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gmethod); ret = true; break; }
                    if (memcmp(rhs.elems+8,"statet",6)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gstatet); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"method",6)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gmethod); ret = true; break; }
                    if (memcmp(rhs.elems+8,"statet",6)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gstatet); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"clicmdt",7)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gclicmdt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"repossh",7)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Grepossh); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"clicmdt",7)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gclicmdt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"repossh",7)==0) { value_SetEnum(parent,gcli_TableId_gclidb_grepossh); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"clicmdf2j",9)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gclicmdf2j); ret = true; break; }
                    if (memcmp(rhs.elems+8,"tblactfld",9)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gtblactfld); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"clicmdf2j",9)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gclicmdf2j); ret = true; break; }
                    if (memcmp(rhs.elems+8,"tblactfld",9)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gtblactfld); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"typeprefix",10)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Gtypeprefix); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"typeprefix",10)==0) { value_SetEnum(parent,gcli_TableId_gclidb_gtypeprefix); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','l','i','d','b','.','G'): {
                    if (memcmp(rhs.elems+8,"repogitport",11)==0) { value_SetEnum(parent,gcli_TableId_gclidb_Grepogitport); ret = true; break; }
                    break;
                }
                case LE_STR8('g','c','l','i','d','b','.','g'): {
                    if (memcmp(rhs.elems+8,"repogitport",11)==0) { value_SetEnum(parent,gcli_TableId_gclidb_grepogitport); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gcli.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gcli::value_SetStrptr(gcli::TableId& parent, algo::strptr rhs, gcli_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- gcli.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool gcli::value_ReadStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- gcli.TableId..ReadStrptrMaybe
// Read fields of gcli::TableId from an ascii string.
// The format of the string is the format of the gcli::TableId's only field
bool gcli::TableId_ReadStrptrMaybe(gcli::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- gcli.TableId..Print
// print string representation of gcli::TableId to string LHS, no header -- cprint:gcli.TableId.String
void gcli::TableId_Print(gcli::TableId & row, algo::cstring &str) {
    gcli::value_Print(row, str);
}

// --- gcli...SizeCheck
inline static void gcli::SizeCheck() {
}

// --- gcli...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        gcli::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        gcli::ReadArgv(); // dmmeta.main:gcli
        gcli::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("gcli.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        gcli::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- gcli...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
