//
// cpp/gen/gitlab_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/gitlab_gen.h"
#include "include/gen/gitlab_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
gitlab::FDb     gitlab::_db;      // dependency found via dev.targdep

namespace gitlab {
const char *gitlab_help =
"gitlab: Gitlab command line interface\n"
"Usage: gitlab [options]\n"
"    -in           string  Input directory or filename, - for stdin. default: \"data\"\n"
"    [issue]       string  Issue id (e.g. myproject.33, 33 or %)\n"
"    -server       string  (config) GitLab server host. default: \"gitlab.lon.algo\"\n"
"    -project      string  (config) Project to use. default: \"myproject\"\n"
"    -auth_token   string  (config) GitLab auth token\n"
"    -mrlist               (action) Show list of merge requests. default: false\n"
"    -mergereq             (action) Push current branch to origin, create merge request. default: false\n"
"    -ilist                (action) Show list of issues matching regx. default: false\n"
"    -istart               (action) Start working on the specified issue. default: false\n"
"    -t                    Tree view: expand issue description. default: false\n"
"    -iadd                 (action) Add new issue. default: false\n"
"    -ic                   (action) Add issue comment. default: false\n"
"    -iclose               (action) Close issue. default: false\n"
"    -iassignto    string  (action) Assign issue to user\n"
"    -title        string  (with -iadd), skip editor and use argument as title\n"
"    -description  string  (with -iadd -title), use argument as description\n"
"    -comment      string  (with -ic), skip editor and use argument as comment\n"
"    -gitdir       string  (setup) Change directory of dit repository\n"
"    -assignee     string  Filter assignee. Default=current user only\n"
"    -ulist                (action) List users. default: false\n"
"    -mraccept     string  (action) Accept merge request\n"
"    -verbose              Enable verbose mode\n"
"    -debug                Enable debug mode\n"
"    -version              Show version information\n"
"    -sig                  Print SHA1 signatures for dispatches\n"
"    -help                 Print this screen and exit\n"
;


const char *gitlab_syntax =
"-in:string=\"data\"\n"
" [issue]:string=\n"
" -server:string=\"gitlab.lon.algo\"\n"
" -project:string=\"myproject\"\n"
" -auth_token:string=\n"
" -mrlist:flag\n"
" -mergereq:flag\n"
" -ilist:flag\n"
" -istart:flag\n"
" -t:flag\n"
" -iadd:flag\n"
" -ic:flag\n"
" -iclose:flag\n"
" -iassignto:string=\n"
" -title:string=\n"
" -description:string=\n"
" -comment:string=\n"
" -gitdir:string=\n"
" -assignee:string=\n"
" -ulist:flag\n"
" -mraccept:string=\n"
;
} // namespace gitlab
namespace gitlab {
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          project_InputMaybe(dev::GitlabProject &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // end namespace gitlab

// --- gitlab.trace..Print
// print string representation of gitlab::trace to string LHS, no header -- cprint:gitlab.trace.String
void gitlab::trace_Print(gitlab::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- gitlab.FDb._db.MainArgs
// Main function
void gitlab::MainArgs(int argc, char **argv) {
    Argtuple argtuple;
    Argtuple_ReadArgv(argtuple, argc,argv,gitlab_syntax, gitlab_help);
    vrfy(gitlab_ReadTupleMaybe(gitlab::_db.cmdline, argtuple.tuple),"where:read_cmdline");
    vrfy(gitlab::LoadTuplesMaybe(gitlab::_db.cmdline.in)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
    gitlab::Main(); // call through to user-defined main
}

// --- gitlab.FDb._db.MainLoop
// Main loop.
void gitlab::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        algo_lib::Step(); // dependent namespace specified via (dev.targdep)
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- gitlab.FDb._db.Step
// Main step
void gitlab::Step() {
}

// --- gitlab.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void gitlab::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("gitlab", gitlab::InsertStrptrMaybe, NULL, gitlab::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "gitlab.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(gitlab::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)gitlab::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'gitlab.Input'  signature:'cd941ad82205e82576bcadd62546d69d72cdbca6'");
}

// --- gitlab.FDb._db.StaticCheck
void gitlab::StaticCheck() {
    algo_assert(_offset_of(gitlab::FieldId, value) + sizeof(((gitlab::FieldId*)0)->value) == sizeof(gitlab::FieldId));
}

// --- gitlab.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool gitlab::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    gitlab::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case gitlab_TableId_dev_GitlabProject: { // finput:gitlab.FDb.project
            dev::GitlabProject elem;
            retval = dev::GitlabProject_ReadStrptrMaybe(elem, str);
            retval = retval && project_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- gitlab.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool gitlab::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dev.gitlab_project"
        , NULL};
        retval = algo_lib::DoLoadTuples(root, gitlab::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- gitlab.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool gitlab::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, gitlab::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- gitlab.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- gitlab.FDb.project.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FProject& gitlab::project_Alloc() {
    gitlab::FProject* row = project_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.project  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.project.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FProject* gitlab::project_AllocMaybe() {
    gitlab::FProject *row = (gitlab::FProject*)project_AllocMem();
    if (row) {
        new (row) gitlab::FProject; // call constructor
    }
    return row;
}

// --- gitlab.FDb.project.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FProject* gitlab::project_InsertMaybe(const dev::GitlabProject &value) {
    gitlab::FProject *row = &project_Alloc(); // if out of memory, process dies. if input error, return NULL.
    project_CopyIn(*row,const_cast<dev::GitlabProject&>(value));
    bool ok = project_XrefMaybe(*row); // this may return false
    if (!ok) {
        project_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.project.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::project_AllocMem() {
    u64 new_nelems     = _db.project_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FProject*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.project_lary[bsr];
        if (!lev) {
            lev=(gitlab::FProject*)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject) * (u64(1)<<bsr));
            _db.project_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.project_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.project.RemoveAll
// Remove all elements from Lary
void gitlab::project_RemoveAll() {
    for (u64 n = _db.project_n; n>0; ) {
        n--;
        project_qFind(u64(n)).~FProject(); // destroy last element
        _db.project_n = n;
    }
}

// --- gitlab.FDb.project.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::project_RemoveLast() {
    u64 n = _db.project_n;
    if (n > 0) {
        n -= 1;
        project_qFind(u64(n)).~FProject();
        _db.project_n = n;
    }
}

// --- gitlab.FDb.project.InputMaybe
static bool gitlab::project_InputMaybe(dev::GitlabProject &elem) {
    bool retval = true;
    retval = project_InsertMaybe(elem);
    return retval;
}

// --- gitlab.FDb.project.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::project_XrefMaybe(gitlab::FProject &row) {
    bool retval = true;
    (void)row;
    // insert project into index ind_project
    if (true) { // user-defined insert condition
        bool success = ind_project_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_project"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_project.Find
// Find row by key. Return NULL if not found.
gitlab::FProject* gitlab::ind_project_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_project_buckets_n - 1);
    gitlab::FProject* *e = &_db.ind_project_buckets_elems[index];
    gitlab::FProject* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).gitlab_project == key;
        if (done) break;
        e         = &ret->ind_project_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_project.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FProject& gitlab::ind_project_FindX(const algo::strptr& key) {
    gitlab::FProject* ret = ind_project_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_project  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_project.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gitlab::FProject& gitlab::ind_project_GetOrCreate(const algo::strptr& key) {
    gitlab::FProject* ret = ind_project_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &project_Alloc();
        (*ret).gitlab_project = key;
        bool good = project_XrefMaybe(*ret);
        if (!good) {
            project_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- gitlab.FDb.ind_project.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_project_InsertMaybe(gitlab::FProject& row) {
    ind_project_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_project_next == (gitlab::FProject*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gitlab_project) & (_db.ind_project_buckets_n - 1);
        gitlab::FProject* *prev = &_db.ind_project_buckets_elems[index];
        do {
            gitlab::FProject* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).gitlab_project == row.gitlab_project) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_project_next;
        } while (true);
        if (retval) {
            row.ind_project_next = *prev;
            _db.ind_project_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_project.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_project_Remove(gitlab::FProject& row) {
    if (LIKELY(row.ind_project_next != (gitlab::FProject*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.gitlab_project) & (_db.ind_project_buckets_n - 1);
        gitlab::FProject* *prev = &_db.ind_project_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FProject *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_project_next; // unlink (singly linked list)
                _db.ind_project_n--;
                row.ind_project_next = (gitlab::FProject*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_project_next;
        }
    }
}

// --- gitlab.FDb.ind_project.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_project_Reserve(int n) {
    u32 old_nbuckets = _db.ind_project_buckets_n;
    u32 new_nelems   = _db.ind_project_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FProject*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FProject*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FProject* *new_buckets = (gitlab::FProject**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_project");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_project_buckets_n; i++) {
            gitlab::FProject* elem = _db.ind_project_buckets_elems[i];
            while (elem) {
                gitlab::FProject &row        = *elem;
                gitlab::FProject* next       = row.ind_project_next;
                u32 index          = algo::Smallstr50_Hash(0, row.gitlab_project) & (new_nbuckets-1);
                row.ind_project_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_project_buckets_elems, old_size);
        _db.ind_project_buckets_elems = new_buckets;
        _db.ind_project_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.ind_issue.Find
// Find row by key. Return NULL if not found.
gitlab::FIssue* gitlab::ind_issue_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_issue_buckets_n - 1);
    gitlab::FIssue* *e = &_db.ind_issue_buckets_elems[index];
    gitlab::FIssue* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).issue == key;
        if (done) break;
        e         = &ret->ind_issue_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_issue.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FIssue& gitlab::ind_issue_FindX(const algo::strptr& key) {
    gitlab::FIssue* ret = ind_issue_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_issue  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_issue.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_issue_InsertMaybe(gitlab::FIssue& row) {
    ind_issue_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_issue_next == (gitlab::FIssue*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
        gitlab::FIssue* *prev = &_db.ind_issue_buckets_elems[index];
        do {
            gitlab::FIssue* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).issue == row.issue) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_issue_next;
        } while (true);
        if (retval) {
            row.ind_issue_next = *prev;
            _db.ind_issue_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_issue.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_issue_Remove(gitlab::FIssue& row) {
    if (LIKELY(row.ind_issue_next != (gitlab::FIssue*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
        gitlab::FIssue* *prev = &_db.ind_issue_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FIssue *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_issue_next; // unlink (singly linked list)
                _db.ind_issue_n--;
                row.ind_issue_next = (gitlab::FIssue*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_issue_next;
        }
    }
}

// --- gitlab.FDb.ind_issue.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_issue_Reserve(int n) {
    u32 old_nbuckets = _db.ind_issue_buckets_n;
    u32 new_nelems   = _db.ind_issue_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FIssue*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FIssue*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FIssue* *new_buckets = (gitlab::FIssue**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_issue");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_issue_buckets_n; i++) {
            gitlab::FIssue* elem = _db.ind_issue_buckets_elems[i];
            while (elem) {
                gitlab::FIssue &row        = *elem;
                gitlab::FIssue* next       = row.ind_issue_next;
                u32 index          = algo::Smallstr50_Hash(0, row.issue) & (new_nbuckets-1);
                row.ind_issue_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_issue_buckets_elems, old_size);
        _db.ind_issue_buckets_elems = new_buckets;
        _db.ind_issue_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.issue.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssue& gitlab::issue_Alloc() {
    gitlab::FIssue* row = issue_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.issue.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssue* gitlab::issue_AllocMaybe() {
    gitlab::FIssue *row = (gitlab::FIssue*)issue_AllocMem();
    if (row) {
        new (row) gitlab::FIssue; // call constructor
    }
    return row;
}

// --- gitlab.FDb.issue.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssue* gitlab::issue_InsertMaybe(const gitlab::Issue &value) {
    gitlab::FIssue *row = &issue_Alloc(); // if out of memory, process dies. if input error, return NULL.
    issue_CopyIn(*row,const_cast<gitlab::Issue&>(value));
    bool ok = issue_XrefMaybe(*row); // this may return false
    if (!ok) {
        issue_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.issue.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::issue_AllocMem() {
    u64 new_nelems     = _db.issue_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FIssue*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.issue_lary[bsr];
        if (!lev) {
            lev=(gitlab::FIssue*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue) * (u64(1)<<bsr));
            _db.issue_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.issue_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.issue.RemoveAll
// Remove all elements from Lary
void gitlab::issue_RemoveAll() {
    for (u64 n = _db.issue_n; n>0; ) {
        n--;
        issue_qFind(u64(n)).~FIssue(); // destroy last element
        _db.issue_n = n;
    }
}

// --- gitlab.FDb.issue.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::issue_RemoveLast() {
    u64 n = _db.issue_n;
    if (n > 0) {
        n -= 1;
        issue_qFind(u64(n)).~FIssue();
        _db.issue_n = n;
    }
}

// --- gitlab.FDb.issue.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::issue_XrefMaybe(gitlab::FIssue &row) {
    bool retval = true;
    (void)row;
    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
    if (UNLIKELY(!p_project)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_project" << Keyval("key", project_Get(row));
        return false;
    }
    // issue: save pointer to project
    if (true) { // user-defined insert condition
        row.p_project = p_project;
    }
    // insert issue into index c_issue
    if (true) { // user-defined insert condition
        c_issue_Insert(*p_project, row);
    }
    // insert issue into index ind_issue
    if (true) { // user-defined insert condition
        bool success = ind_issue_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_issue"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.issue_note.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssueNote& gitlab::issue_note_Alloc() {
    gitlab::FIssueNote* row = issue_note_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue_note  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.issue_note.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssueNote* gitlab::issue_note_AllocMaybe() {
    gitlab::FIssueNote *row = (gitlab::FIssueNote*)issue_note_AllocMem();
    if (row) {
        new (row) gitlab::FIssueNote; // call constructor
    }
    return row;
}

// --- gitlab.FDb.issue_note.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssueNote* gitlab::issue_note_InsertMaybe(const gitlab::IssueNote &value) {
    gitlab::FIssueNote *row = &issue_note_Alloc(); // if out of memory, process dies. if input error, return NULL.
    issue_note_CopyIn(*row,const_cast<gitlab::IssueNote&>(value));
    bool ok = issue_note_XrefMaybe(*row); // this may return false
    if (!ok) {
        issue_note_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.issue_note.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::issue_note_AllocMem() {
    u64 new_nelems     = _db.issue_note_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FIssueNote*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.issue_note_lary[bsr];
        if (!lev) {
            lev=(gitlab::FIssueNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote) * (u64(1)<<bsr));
            _db.issue_note_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.issue_note_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.issue_note.RemoveAll
// Remove all elements from Lary
void gitlab::issue_note_RemoveAll() {
    for (u64 n = _db.issue_note_n; n>0; ) {
        n--;
        issue_note_qFind(u64(n)).~FIssueNote(); // destroy last element
        _db.issue_note_n = n;
    }
}

// --- gitlab.FDb.issue_note.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::issue_note_RemoveLast() {
    u64 n = _db.issue_note_n;
    if (n > 0) {
        n -= 1;
        issue_note_qFind(u64(n)).~FIssueNote();
        _db.issue_note_n = n;
    }
}

// --- gitlab.FDb.issue_note.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::issue_note_XrefMaybe(gitlab::FIssueNote &row) {
    bool retval = true;
    (void)row;
    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(issue_Get(row));
    if (UNLIKELY(!p_issue)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_issue" << Keyval("key", issue_Get(row));
        return false;
    }
    // issue_note: save pointer to issue
    if (true) { // user-defined insert condition
        row.p_issue = p_issue;
    }
    // insert issue_note into index ind_issue_note
    if (true) { // user-defined insert condition
        bool success = ind_issue_note_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_issue_note"; // check for duplicate key
            return false;
        }
    }
    // insert issue_note into index c_issue_note
    if (true) { // user-defined insert condition
        c_issue_note_Insert(*p_issue, row);
    }
    return retval;
}

// --- gitlab.FDb.ind_issue_note.Find
// Find row by key. Return NULL if not found.
gitlab::FIssueNote* gitlab::ind_issue_note_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_issue_note_buckets_n - 1);
    gitlab::FIssueNote* *e = &_db.ind_issue_note_buckets_elems[index];
    gitlab::FIssueNote* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).issue_note == key;
        if (done) break;
        e         = &ret->ind_issue_note_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_issue_note.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FIssueNote& gitlab::ind_issue_note_FindX(const algo::strptr& key) {
    gitlab::FIssueNote* ret = ind_issue_note_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_issue_note  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_issue_note.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_issue_note_InsertMaybe(gitlab::FIssueNote& row) {
    ind_issue_note_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_issue_note_next == (gitlab::FIssueNote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue_note) & (_db.ind_issue_note_buckets_n - 1);
        gitlab::FIssueNote* *prev = &_db.ind_issue_note_buckets_elems[index];
        do {
            gitlab::FIssueNote* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).issue_note == row.issue_note) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_issue_note_next;
        } while (true);
        if (retval) {
            row.ind_issue_note_next = *prev;
            _db.ind_issue_note_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_issue_note.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_issue_note_Remove(gitlab::FIssueNote& row) {
    if (LIKELY(row.ind_issue_note_next != (gitlab::FIssueNote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.issue_note) & (_db.ind_issue_note_buckets_n - 1);
        gitlab::FIssueNote* *prev = &_db.ind_issue_note_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FIssueNote *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_issue_note_next; // unlink (singly linked list)
                _db.ind_issue_note_n--;
                row.ind_issue_note_next = (gitlab::FIssueNote*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_issue_note_next;
        }
    }
}

// --- gitlab.FDb.ind_issue_note.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_issue_note_Reserve(int n) {
    u32 old_nbuckets = _db.ind_issue_note_buckets_n;
    u32 new_nelems   = _db.ind_issue_note_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FIssueNote*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FIssueNote*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FIssueNote* *new_buckets = (gitlab::FIssueNote**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_issue_note");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_issue_note_buckets_n; i++) {
            gitlab::FIssueNote* elem = _db.ind_issue_note_buckets_elems[i];
            while (elem) {
                gitlab::FIssueNote &row        = *elem;
                gitlab::FIssueNote* next       = row.ind_issue_note_next;
                u32 index          = algo::Smallstr50_Hash(0, row.issue_note) & (new_nbuckets-1);
                row.ind_issue_note_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_issue_note_buckets_elems, old_size);
        _db.ind_issue_note_buckets_elems = new_buckets;
        _db.ind_issue_note_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.issue_description.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssueDescription& gitlab::issue_description_Alloc() {
    gitlab::FIssueDescription* row = issue_description_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue_description  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.issue_description.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssueDescription* gitlab::issue_description_AllocMaybe() {
    gitlab::FIssueDescription *row = (gitlab::FIssueDescription*)issue_description_AllocMem();
    if (row) {
        new (row) gitlab::FIssueDescription; // call constructor
    }
    return row;
}

// --- gitlab.FDb.issue_description.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssueDescription* gitlab::issue_description_InsertMaybe(const gitlab::IssueDescription &value) {
    gitlab::FIssueDescription *row = &issue_description_Alloc(); // if out of memory, process dies. if input error, return NULL.
    issue_description_CopyIn(*row,const_cast<gitlab::IssueDescription&>(value));
    bool ok = issue_description_XrefMaybe(*row); // this may return false
    if (!ok) {
        issue_description_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.issue_description.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::issue_description_AllocMem() {
    u64 new_nelems     = _db.issue_description_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FIssueDescription*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.issue_description_lary[bsr];
        if (!lev) {
            lev=(gitlab::FIssueDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueDescription) * (u64(1)<<bsr));
            _db.issue_description_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.issue_description_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.issue_description.RemoveAll
// Remove all elements from Lary
void gitlab::issue_description_RemoveAll() {
    for (u64 n = _db.issue_description_n; n>0; ) {
        n--;
        issue_description_qFind(u64(n)).~FIssueDescription(); // destroy last element
        _db.issue_description_n = n;
    }
}

// --- gitlab.FDb.issue_description.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::issue_description_RemoveLast() {
    u64 n = _db.issue_description_n;
    if (n > 0) {
        n -= 1;
        issue_description_qFind(u64(n)).~FIssueDescription();
        _db.issue_description_n = n;
    }
}

// --- gitlab.FDb.issue_description.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::issue_description_XrefMaybe(gitlab::FIssueDescription &row) {
    bool retval = true;
    (void)row;
    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(row.issue);
    if (UNLIKELY(!p_issue)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_issue" << Keyval("key", row.issue);
        return false;
    }
    // issue_description: save pointer to issue
    if (true) { // user-defined insert condition
        row.p_issue = p_issue;
    }
    // insert issue_description into index c_issue_description
    if (true) { // user-defined insert condition
        bool success = c_issue_description_InsertMaybe(*p_issue, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FIssue.c_issue_description"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_mr.Find
// Find row by key. Return NULL if not found.
gitlab::FMr* gitlab::ind_mr_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_mr_buckets_n - 1);
    gitlab::FMr* *e = &_db.ind_mr_buckets_elems[index];
    gitlab::FMr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mr == key;
        if (done) break;
        e         = &ret->ind_mr_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_mr.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FMr& gitlab::ind_mr_FindX(const algo::strptr& key) {
    gitlab::FMr* ret = ind_mr_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_mr  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_mr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_mr_InsertMaybe(gitlab::FMr& row) {
    ind_mr_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mr_next == (gitlab::FMr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
        gitlab::FMr* *prev = &_db.ind_mr_buckets_elems[index];
        do {
            gitlab::FMr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mr == row.mr) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mr_next;
        } while (true);
        if (retval) {
            row.ind_mr_next = *prev;
            _db.ind_mr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_mr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_mr_Remove(gitlab::FMr& row) {
    if (LIKELY(row.ind_mr_next != (gitlab::FMr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
        gitlab::FMr* *prev = &_db.ind_mr_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FMr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mr_next; // unlink (singly linked list)
                _db.ind_mr_n--;
                row.ind_mr_next = (gitlab::FMr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mr_next;
        }
    }
}

// --- gitlab.FDb.ind_mr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_mr_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mr_buckets_n;
    u32 new_nelems   = _db.ind_mr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FMr*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FMr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FMr* *new_buckets = (gitlab::FMr**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_mr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mr_buckets_n; i++) {
            gitlab::FMr* elem = _db.ind_mr_buckets_elems[i];
            while (elem) {
                gitlab::FMr &row        = *elem;
                gitlab::FMr* next       = row.ind_mr_next;
                u32 index          = algo::Smallstr50_Hash(0, row.mr) & (new_nbuckets-1);
                row.ind_mr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mr_buckets_elems, old_size);
        _db.ind_mr_buckets_elems = new_buckets;
        _db.ind_mr_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.mr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMr& gitlab::mr_Alloc() {
    gitlab::FMr* row = mr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.mr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMr* gitlab::mr_AllocMaybe() {
    gitlab::FMr *row = (gitlab::FMr*)mr_AllocMem();
    if (row) {
        new (row) gitlab::FMr; // call constructor
    }
    return row;
}

// --- gitlab.FDb.mr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMr* gitlab::mr_InsertMaybe(const gitlab::Mr &value) {
    gitlab::FMr *row = &mr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mr_CopyIn(*row,const_cast<gitlab::Mr&>(value));
    bool ok = mr_XrefMaybe(*row); // this may return false
    if (!ok) {
        mr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.mr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::mr_AllocMem() {
    u64 new_nelems     = _db.mr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FMr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mr_lary[bsr];
        if (!lev) {
            lev=(gitlab::FMr*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr) * (u64(1)<<bsr));
            _db.mr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mr_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.mr.RemoveAll
// Remove all elements from Lary
void gitlab::mr_RemoveAll() {
    for (u64 n = _db.mr_n; n>0; ) {
        n--;
        mr_qFind(u64(n)).~FMr(); // destroy last element
        _db.mr_n = n;
    }
}

// --- gitlab.FDb.mr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::mr_RemoveLast() {
    u64 n = _db.mr_n;
    if (n > 0) {
        n -= 1;
        mr_qFind(u64(n)).~FMr();
        _db.mr_n = n;
    }
}

// --- gitlab.FDb.mr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::mr_XrefMaybe(gitlab::FMr &row) {
    bool retval = true;
    (void)row;
    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
    if (UNLIKELY(!p_project)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_project" << Keyval("key", project_Get(row));
        return false;
    }
    // mr: save pointer to project
    if (true) { // user-defined insert condition
        row.p_project = p_project;
    }
    // insert mr into index c_mr
    if (true) { // user-defined insert condition
        c_mr_Insert(*p_project, row);
    }
    // insert mr into index ind_mr
    if (true) { // user-defined insert condition
        bool success = ind_mr_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_mr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.mr_note.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMrNote& gitlab::mr_note_Alloc() {
    gitlab::FMrNote* row = mr_note_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr_note  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.mr_note.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMrNote* gitlab::mr_note_AllocMaybe() {
    gitlab::FMrNote *row = (gitlab::FMrNote*)mr_note_AllocMem();
    if (row) {
        new (row) gitlab::FMrNote; // call constructor
    }
    return row;
}

// --- gitlab.FDb.mr_note.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMrNote* gitlab::mr_note_InsertMaybe(const gitlab::MrNote &value) {
    gitlab::FMrNote *row = &mr_note_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mr_note_CopyIn(*row,const_cast<gitlab::MrNote&>(value));
    bool ok = mr_note_XrefMaybe(*row); // this may return false
    if (!ok) {
        mr_note_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.mr_note.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::mr_note_AllocMem() {
    u64 new_nelems     = _db.mr_note_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FMrNote*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mr_note_lary[bsr];
        if (!lev) {
            lev=(gitlab::FMrNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote) * (u64(1)<<bsr));
            _db.mr_note_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mr_note_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.mr_note.RemoveAll
// Remove all elements from Lary
void gitlab::mr_note_RemoveAll() {
    for (u64 n = _db.mr_note_n; n>0; ) {
        n--;
        mr_note_qFind(u64(n)).~FMrNote(); // destroy last element
        _db.mr_note_n = n;
    }
}

// --- gitlab.FDb.mr_note.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::mr_note_RemoveLast() {
    u64 n = _db.mr_note_n;
    if (n > 0) {
        n -= 1;
        mr_note_qFind(u64(n)).~FMrNote();
        _db.mr_note_n = n;
    }
}

// --- gitlab.FDb.mr_note.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::mr_note_XrefMaybe(gitlab::FMrNote &row) {
    bool retval = true;
    (void)row;
    gitlab::FMr* p_mr = gitlab::ind_mr_Find(mr_Get(row));
    if (UNLIKELY(!p_mr)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_mr" << Keyval("key", mr_Get(row));
        return false;
    }
    // mr_note: save pointer to mr
    if (true) { // user-defined insert condition
        row.p_mr = p_mr;
    }
    // insert mr_note into index ind_mr_note
    if (true) { // user-defined insert condition
        bool success = ind_mr_note_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_mr_note"; // check for duplicate key
            return false;
        }
    }
    // insert mr_note into index c_mr_note
    if (true) { // user-defined insert condition
        c_mr_note_Insert(*p_mr, row);
    }
    return retval;
}

// --- gitlab.FDb.ind_mr_note.Find
// Find row by key. Return NULL if not found.
gitlab::FMrNote* gitlab::ind_mr_note_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_mr_note_buckets_n - 1);
    gitlab::FMrNote* *e = &_db.ind_mr_note_buckets_elems[index];
    gitlab::FMrNote* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).mr_note == key;
        if (done) break;
        e         = &ret->ind_mr_note_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_mr_note.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FMrNote& gitlab::ind_mr_note_FindX(const algo::strptr& key) {
    gitlab::FMrNote* ret = ind_mr_note_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_mr_note  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_mr_note.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_mr_note_InsertMaybe(gitlab::FMrNote& row) {
    ind_mr_note_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_mr_note_next == (gitlab::FMrNote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.mr_note) & (_db.ind_mr_note_buckets_n - 1);
        gitlab::FMrNote* *prev = &_db.ind_mr_note_buckets_elems[index];
        do {
            gitlab::FMrNote* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).mr_note == row.mr_note) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_mr_note_next;
        } while (true);
        if (retval) {
            row.ind_mr_note_next = *prev;
            _db.ind_mr_note_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_mr_note.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_mr_note_Remove(gitlab::FMrNote& row) {
    if (LIKELY(row.ind_mr_note_next != (gitlab::FMrNote*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.mr_note) & (_db.ind_mr_note_buckets_n - 1);
        gitlab::FMrNote* *prev = &_db.ind_mr_note_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FMrNote *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_mr_note_next; // unlink (singly linked list)
                _db.ind_mr_note_n--;
                row.ind_mr_note_next = (gitlab::FMrNote*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_mr_note_next;
        }
    }
}

// --- gitlab.FDb.ind_mr_note.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_mr_note_Reserve(int n) {
    u32 old_nbuckets = _db.ind_mr_note_buckets_n;
    u32 new_nelems   = _db.ind_mr_note_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FMrNote*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FMrNote*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FMrNote* *new_buckets = (gitlab::FMrNote**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_mr_note");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_mr_note_buckets_n; i++) {
            gitlab::FMrNote* elem = _db.ind_mr_note_buckets_elems[i];
            while (elem) {
                gitlab::FMrNote &row        = *elem;
                gitlab::FMrNote* next       = row.ind_mr_note_next;
                u32 index          = algo::Smallstr50_Hash(0, row.mr_note) & (new_nbuckets-1);
                row.ind_mr_note_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_mr_note_buckets_elems, old_size);
        _db.ind_mr_note_buckets_elems = new_buckets;
        _db.ind_mr_note_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.mr_description.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMrDescription& gitlab::mr_description_Alloc() {
    gitlab::FMrDescription* row = mr_description_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr_description  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.mr_description.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMrDescription* gitlab::mr_description_AllocMaybe() {
    gitlab::FMrDescription *row = (gitlab::FMrDescription*)mr_description_AllocMem();
    if (row) {
        new (row) gitlab::FMrDescription; // call constructor
    }
    return row;
}

// --- gitlab.FDb.mr_description.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMrDescription* gitlab::mr_description_InsertMaybe(const gitlab::MrDescription &value) {
    gitlab::FMrDescription *row = &mr_description_Alloc(); // if out of memory, process dies. if input error, return NULL.
    mr_description_CopyIn(*row,const_cast<gitlab::MrDescription&>(value));
    bool ok = mr_description_XrefMaybe(*row); // this may return false
    if (!ok) {
        mr_description_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.mr_description.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::mr_description_AllocMem() {
    u64 new_nelems     = _db.mr_description_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FMrDescription*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.mr_description_lary[bsr];
        if (!lev) {
            lev=(gitlab::FMrDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrDescription) * (u64(1)<<bsr));
            _db.mr_description_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.mr_description_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.mr_description.RemoveAll
// Remove all elements from Lary
void gitlab::mr_description_RemoveAll() {
    for (u64 n = _db.mr_description_n; n>0; ) {
        n--;
        mr_description_qFind(u64(n)).~FMrDescription(); // destroy last element
        _db.mr_description_n = n;
    }
}

// --- gitlab.FDb.mr_description.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::mr_description_RemoveLast() {
    u64 n = _db.mr_description_n;
    if (n > 0) {
        n -= 1;
        mr_description_qFind(u64(n)).~FMrDescription();
        _db.mr_description_n = n;
    }
}

// --- gitlab.FDb.mr_description.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::mr_description_XrefMaybe(gitlab::FMrDescription &row) {
    bool retval = true;
    (void)row;
    gitlab::FMr* p_mr = gitlab::ind_mr_Find(row.mr);
    if (UNLIKELY(!p_mr)) {
        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_mr" << Keyval("key", row.mr);
        return false;
    }
    // mr_description: save pointer to mr
    if (true) { // user-defined insert condition
        row.p_mr = p_mr;
    }
    // insert mr_description into index c_mr_description
    if (true) { // user-defined insert condition
        bool success = c_mr_description_InsertMaybe(*p_mr, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FMr.c_mr_description"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.user.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FUser& gitlab::user_Alloc() {
    gitlab::FUser* row = user_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.user  comment:'Alloc failed'");
    }
    return *row;
}

// --- gitlab.FDb.user.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FUser* gitlab::user_AllocMaybe() {
    gitlab::FUser *row = (gitlab::FUser*)user_AllocMem();
    if (row) {
        new (row) gitlab::FUser; // call constructor
    }
    return row;
}

// --- gitlab.FDb.user.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FUser* gitlab::user_InsertMaybe(const gitlab::User &value) {
    gitlab::FUser *row = &user_Alloc(); // if out of memory, process dies. if input error, return NULL.
    user_CopyIn(*row,const_cast<gitlab::User&>(value));
    bool ok = user_XrefMaybe(*row); // this may return false
    if (!ok) {
        user_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- gitlab.FDb.user.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* gitlab::user_AllocMem() {
    u64 new_nelems     = _db.user_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    gitlab::FUser*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.user_lary[bsr];
        if (!lev) {
            lev=(gitlab::FUser*)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser) * (u64(1)<<bsr));
            _db.user_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.user_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- gitlab.FDb.user.RemoveAll
// Remove all elements from Lary
void gitlab::user_RemoveAll() {
    for (u64 n = _db.user_n; n>0; ) {
        n--;
        user_qFind(u64(n)).~FUser(); // destroy last element
        _db.user_n = n;
    }
}

// --- gitlab.FDb.user.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::user_RemoveLast() {
    u64 n = _db.user_n;
    if (n > 0) {
        n -= 1;
        user_qFind(u64(n)).~FUser();
        _db.user_n = n;
    }
}

// --- gitlab.FDb.user.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool gitlab::user_XrefMaybe(gitlab::FUser &row) {
    bool retval = true;
    (void)row;
    // insert user into index ind_user
    if (true) { // user-defined insert condition
        bool success = ind_user_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_user"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_user.Find
// Find row by key. Return NULL if not found.
gitlab::FUser* gitlab::ind_user_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_user_buckets_n - 1);
    gitlab::FUser* *e = &_db.ind_user_buckets_elems[index];
    gitlab::FUser* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).user == key;
        if (done) break;
        e         = &ret->ind_user_next;
    } while (true);
    return ret;
}

// --- gitlab.FDb.ind_user.FindX
// Look up row by key and return reference. Throw exception if not found
gitlab::FUser& gitlab::ind_user_FindX(const algo::strptr& key) {
    gitlab::FUser* ret = ind_user_Find(key);
    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_user  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- gitlab.FDb.ind_user.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
gitlab::FUser& gitlab::ind_user_GetOrCreate(const algo::strptr& key) {
    gitlab::FUser* ret = ind_user_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &user_Alloc();
        (*ret).user = key;
        bool good = user_XrefMaybe(*ret);
        if (!good) {
            user_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- gitlab.FDb.ind_user.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool gitlab::ind_user_InsertMaybe(gitlab::FUser& row) {
    ind_user_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_user_next == (gitlab::FUser*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
        gitlab::FUser* *prev = &_db.ind_user_buckets_elems[index];
        do {
            gitlab::FUser* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).user == row.user) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_user_next;
        } while (true);
        if (retval) {
            row.ind_user_next = *prev;
            _db.ind_user_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- gitlab.FDb.ind_user.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void gitlab::ind_user_Remove(gitlab::FUser& row) {
    if (LIKELY(row.ind_user_next != (gitlab::FUser*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
        gitlab::FUser* *prev = &_db.ind_user_buckets_elems[index]; // addr of pointer to current element
        while (gitlab::FUser *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_user_next; // unlink (singly linked list)
                _db.ind_user_n--;
                row.ind_user_next = (gitlab::FUser*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_user_next;
        }
    }
}

// --- gitlab.FDb.ind_user.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void gitlab::ind_user_Reserve(int n) {
    u32 old_nbuckets = _db.ind_user_buckets_n;
    u32 new_nelems   = _db.ind_user_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(gitlab::FUser*);
        u32 new_size = new_nbuckets * sizeof(gitlab::FUser*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        gitlab::FUser* *new_buckets = (gitlab::FUser**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_user");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_user_buckets_n; i++) {
            gitlab::FUser* elem = _db.ind_user_buckets_elems[i];
            while (elem) {
                gitlab::FUser &row        = *elem;
                gitlab::FUser* next       = row.ind_user_next;
                u32 index          = algo::Smallstr50_Hash(0, row.user) & (new_nbuckets-1);
                row.ind_user_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_user_buckets_elems, old_size);
        _db.ind_user_buckets_elems = new_buckets;
        _db.ind_user_buckets_n = new_nbuckets;
    }
}

// --- gitlab.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr gitlab::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- gitlab.FDb.trace.N
// Function return 1
inline static i32 gitlab::trace_N() {
    return 1;
}

// --- gitlab.FDb..Init
// Set all fields to initial values.
void gitlab::FDb_Init() {
    _db.auth_file_name = algo::strptr(".gitlab_auth");
    _db.usrmsg_no_token = algo::strptr("Please supply personal access token via -auth_token option (could be done once). Visit <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html> for directions. Token scope shall be 'api', i.e. whole GitLab API.");
    // initialize LAry project (gitlab.FDb.project)
    _db.project_n = 0;
    memset(_db.project_lary, 0, sizeof(_db.project_lary)); // zero out all level pointers
    gitlab::FProject* project_first = (gitlab::FProject*)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject) * (u64(1)<<4));
    if (!project_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.project_lary[i]  = project_first;
        project_first    += 1ULL<<i;
    }
    _db.project_id = u32(0);
    // initialize hash table for gitlab::FProject;
    _db.ind_project_n             	= 0; // (gitlab.FDb.ind_project)
    _db.ind_project_buckets_n     	= 4; // (gitlab.FDb.ind_project)
    _db.ind_project_buckets_elems 	= (gitlab::FProject**)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject*)*_db.ind_project_buckets_n); // initial buckets (gitlab.FDb.ind_project)
    if (!_db.ind_project_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_project)
    }
    memset(_db.ind_project_buckets_elems, 0, sizeof(gitlab::FProject*)*_db.ind_project_buckets_n); // (gitlab.FDb.ind_project)
    // initialize hash table for gitlab::FIssue;
    _db.ind_issue_n             	= 0; // (gitlab.FDb.ind_issue)
    _db.ind_issue_buckets_n     	= 4; // (gitlab.FDb.ind_issue)
    _db.ind_issue_buckets_elems 	= (gitlab::FIssue**)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue*)*_db.ind_issue_buckets_n); // initial buckets (gitlab.FDb.ind_issue)
    if (!_db.ind_issue_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_issue)
    }
    memset(_db.ind_issue_buckets_elems, 0, sizeof(gitlab::FIssue*)*_db.ind_issue_buckets_n); // (gitlab.FDb.ind_issue)
    // initialize LAry issue (gitlab.FDb.issue)
    _db.issue_n = 0;
    memset(_db.issue_lary, 0, sizeof(_db.issue_lary)); // zero out all level pointers
    gitlab::FIssue* issue_first = (gitlab::FIssue*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue) * (u64(1)<<4));
    if (!issue_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.issue_lary[i]  = issue_first;
        issue_first    += 1ULL<<i;
    }
    // initialize LAry issue_note (gitlab.FDb.issue_note)
    _db.issue_note_n = 0;
    memset(_db.issue_note_lary, 0, sizeof(_db.issue_note_lary)); // zero out all level pointers
    gitlab::FIssueNote* issue_note_first = (gitlab::FIssueNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote) * (u64(1)<<4));
    if (!issue_note_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.issue_note_lary[i]  = issue_note_first;
        issue_note_first    += 1ULL<<i;
    }
    // initialize hash table for gitlab::FIssueNote;
    _db.ind_issue_note_n             	= 0; // (gitlab.FDb.ind_issue_note)
    _db.ind_issue_note_buckets_n     	= 4; // (gitlab.FDb.ind_issue_note)
    _db.ind_issue_note_buckets_elems 	= (gitlab::FIssueNote**)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote*)*_db.ind_issue_note_buckets_n); // initial buckets (gitlab.FDb.ind_issue_note)
    if (!_db.ind_issue_note_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_issue_note)
    }
    memset(_db.ind_issue_note_buckets_elems, 0, sizeof(gitlab::FIssueNote*)*_db.ind_issue_note_buckets_n); // (gitlab.FDb.ind_issue_note)
    // initialize LAry issue_description (gitlab.FDb.issue_description)
    _db.issue_description_n = 0;
    memset(_db.issue_description_lary, 0, sizeof(_db.issue_description_lary)); // zero out all level pointers
    gitlab::FIssueDescription* issue_description_first = (gitlab::FIssueDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueDescription) * (u64(1)<<4));
    if (!issue_description_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.issue_description_lary[i]  = issue_description_first;
        issue_description_first    += 1ULL<<i;
    }
    // initialize hash table for gitlab::FMr;
    _db.ind_mr_n             	= 0; // (gitlab.FDb.ind_mr)
    _db.ind_mr_buckets_n     	= 4; // (gitlab.FDb.ind_mr)
    _db.ind_mr_buckets_elems 	= (gitlab::FMr**)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr*)*_db.ind_mr_buckets_n); // initial buckets (gitlab.FDb.ind_mr)
    if (!_db.ind_mr_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_mr)
    }
    memset(_db.ind_mr_buckets_elems, 0, sizeof(gitlab::FMr*)*_db.ind_mr_buckets_n); // (gitlab.FDb.ind_mr)
    // initialize LAry mr (gitlab.FDb.mr)
    _db.mr_n = 0;
    memset(_db.mr_lary, 0, sizeof(_db.mr_lary)); // zero out all level pointers
    gitlab::FMr* mr_first = (gitlab::FMr*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr) * (u64(1)<<4));
    if (!mr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mr_lary[i]  = mr_first;
        mr_first    += 1ULL<<i;
    }
    // initialize LAry mr_note (gitlab.FDb.mr_note)
    _db.mr_note_n = 0;
    memset(_db.mr_note_lary, 0, sizeof(_db.mr_note_lary)); // zero out all level pointers
    gitlab::FMrNote* mr_note_first = (gitlab::FMrNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote) * (u64(1)<<4));
    if (!mr_note_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mr_note_lary[i]  = mr_note_first;
        mr_note_first    += 1ULL<<i;
    }
    // initialize hash table for gitlab::FMrNote;
    _db.ind_mr_note_n             	= 0; // (gitlab.FDb.ind_mr_note)
    _db.ind_mr_note_buckets_n     	= 4; // (gitlab.FDb.ind_mr_note)
    _db.ind_mr_note_buckets_elems 	= (gitlab::FMrNote**)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote*)*_db.ind_mr_note_buckets_n); // initial buckets (gitlab.FDb.ind_mr_note)
    if (!_db.ind_mr_note_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_mr_note)
    }
    memset(_db.ind_mr_note_buckets_elems, 0, sizeof(gitlab::FMrNote*)*_db.ind_mr_note_buckets_n); // (gitlab.FDb.ind_mr_note)
    // initialize LAry mr_description (gitlab.FDb.mr_description)
    _db.mr_description_n = 0;
    memset(_db.mr_description_lary, 0, sizeof(_db.mr_description_lary)); // zero out all level pointers
    gitlab::FMrDescription* mr_description_first = (gitlab::FMrDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrDescription) * (u64(1)<<4));
    if (!mr_description_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.mr_description_lary[i]  = mr_description_first;
        mr_description_first    += 1ULL<<i;
    }
    // initialize LAry user (gitlab.FDb.user)
    _db.user_n = 0;
    memset(_db.user_lary, 0, sizeof(_db.user_lary)); // zero out all level pointers
    gitlab::FUser* user_first = (gitlab::FUser*)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser) * (u64(1)<<4));
    if (!user_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.user_lary[i]  = user_first;
        user_first    += 1ULL<<i;
    }
    // initialize hash table for gitlab::FUser;
    _db.ind_user_n             	= 0; // (gitlab.FDb.ind_user)
    _db.ind_user_buckets_n     	= 4; // (gitlab.FDb.ind_user)
    _db.ind_user_buckets_elems 	= (gitlab::FUser**)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser*)*_db.ind_user_buckets_n); // initial buckets (gitlab.FDb.ind_user)
    if (!_db.ind_user_buckets_elems) {
        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_user)
    }
    memset(_db.ind_user_buckets_elems, 0, sizeof(gitlab::FUser*)*_db.ind_user_buckets_n); // (gitlab.FDb.ind_user)

    gitlab::InitReflection();
}

// --- gitlab.FDb..Uninit
void gitlab::FDb_Uninit() {
    gitlab::FDb &row = _db; (void)row;

    // gitlab.FDb.ind_user.Uninit (Thash)  //
    // skip destruction of ind_user in global scope

    // gitlab.FDb.user.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.mr_description.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.ind_mr_note.Uninit (Thash)  //
    // skip destruction of ind_mr_note in global scope

    // gitlab.FDb.mr_note.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.mr.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.ind_mr.Uninit (Thash)  //
    // skip destruction of ind_mr in global scope

    // gitlab.FDb.issue_description.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.ind_issue_note.Uninit (Thash)  //
    // skip destruction of ind_issue_note in global scope

    // gitlab.FDb.issue_note.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.issue.Uninit (Lary)  //
    // skip destruction in global scope

    // gitlab.FDb.ind_issue.Uninit (Thash)  //
    // skip destruction of ind_issue in global scope

    // gitlab.FDb.ind_project.Uninit (Thash)  //
    // skip destruction of ind_project in global scope

    // gitlab.FDb.project.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- gitlab.FHttp.request_header.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& gitlab::request_header_Alloc(gitlab::FHttp& parent) {
    request_header_Reserve(parent, 1);
    int n  = parent.request_header_n;
    int at = n;
    algo::cstring *elems = parent.request_header_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.request_header_n = n+1;
    return elems[at];
}

// --- gitlab.FHttp.request_header.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& gitlab::request_header_AllocAt(gitlab::FHttp& parent, int at) {
    request_header_Reserve(parent, 1);
    int n  = parent.request_header_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("gitlab.bad_alloc_at  field:gitlab.FHttp.request_header  comment:'index out of range'");
    }
    algo::cstring *elems = parent.request_header_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.request_header_n = n+1;
    return elems[at];
}

// --- gitlab.FHttp.request_header.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> gitlab::request_header_AllocN(gitlab::FHttp& parent, int n_elems) {
    request_header_Reserve(parent, n_elems);
    int old_n  = parent.request_header_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.request_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.request_header_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- gitlab.FHttp.request_header.Remove
// Remove item by index. If index outside of range, do nothing.
void gitlab::request_header_Remove(gitlab::FHttp& parent, u32 i) {
    u32 lim = parent.request_header_n;
    algo::cstring *elems = parent.request_header_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.request_header_n = lim - 1;
    }
}

// --- gitlab.FHttp.request_header.RemoveAll
void gitlab::request_header_RemoveAll(gitlab::FHttp& parent) {
    u32 n = parent.request_header_n;
    while (n > 0) {
        n -= 1;
        parent.request_header_elems[n].~cstring();
        parent.request_header_n = n;
    }
}

// --- gitlab.FHttp.request_header.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::request_header_RemoveLast(gitlab::FHttp& parent) {
    u64 n = parent.request_header_n;
    if (n > 0) {
        n -= 1;
        request_header_qFind(parent, u64(n)).~cstring();
        parent.request_header_n = n;
    }
}

// --- gitlab.FHttp.request_header.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void gitlab::request_header_AbsReserve(gitlab::FHttp& parent, int n) {
    u32 old_max  = parent.request_header_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.request_header_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.tary_nomem  field:gitlab.FHttp.request_header  comment:'out of memory'");
        }
        parent.request_header_elems = (algo::cstring*)new_mem;
        parent.request_header_max = new_max;
    }
}

// --- gitlab.FHttp.request_header.Setary
// Copy contents of RHS to PARENT.
void gitlab::request_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) {
    request_header_RemoveAll(parent);
    int nnew = rhs.request_header_n;
    request_header_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.request_header_elems + i) algo::cstring(request_header_qFind(rhs, i));
        parent.request_header_n = i + 1;
    }
}

// --- gitlab.FHttp.request_method.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gitlab::request_method_ToCstr(const gitlab::FHttp& parent) {
    const char *ret = NULL;
    switch(request_method_GetEnum(parent)) {
        case gitlab_FHttp_request_method_GET: ret = "GET";  break;
        case gitlab_FHttp_request_method_POST: ret = "POST";  break;
        case gitlab_FHttp_request_method_PUT: ret = "PUT";  break;
    }
    return ret;
}

// --- gitlab.FHttp.request_method.Print
// Convert request_method to a string. First, attempt conversion to a known string.
// If no string matches, print request_method as a numeric value.
void gitlab::request_method_Print(const gitlab::FHttp& parent, algo::cstring &lhs) {
    const char *strval = request_method_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.request_method;
    }
}

// --- gitlab.FHttp.request_method.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gitlab::request_method_SetStrptrMaybe(gitlab::FHttp& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('G','E','T'): {
                    request_method_SetEnum(parent,gitlab_FHttp_request_method_GET); ret = true; break;
                }
                case LE_STR3('P','U','T'): {
                    request_method_SetEnum(parent,gitlab_FHttp_request_method_PUT); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('P','O','S','T'): {
                    request_method_SetEnum(parent,gitlab_FHttp_request_method_POST); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gitlab.FHttp.request_method.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gitlab::request_method_SetStrptr(gitlab::FHttp& parent, algo::strptr rhs, gitlab_FHttp_request_method_Enum dflt) {
    if (!request_method_SetStrptrMaybe(parent,rhs)) request_method_SetEnum(parent,dflt);
}

// --- gitlab.FHttp.response_header.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& gitlab::response_header_Alloc(gitlab::FHttp& parent) {
    response_header_Reserve(parent, 1);
    int n  = parent.response_header_n;
    int at = n;
    algo::cstring *elems = parent.response_header_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.response_header_n = n+1;
    return elems[at];
}

// --- gitlab.FHttp.response_header.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& gitlab::response_header_AllocAt(gitlab::FHttp& parent, int at) {
    response_header_Reserve(parent, 1);
    int n  = parent.response_header_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("gitlab.bad_alloc_at  field:gitlab.FHttp.response_header  comment:'index out of range'");
    }
    algo::cstring *elems = parent.response_header_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.response_header_n = n+1;
    return elems[at];
}

// --- gitlab.FHttp.response_header.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> gitlab::response_header_AllocN(gitlab::FHttp& parent, int n_elems) {
    response_header_Reserve(parent, n_elems);
    int old_n  = parent.response_header_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.response_header_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.response_header_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- gitlab.FHttp.response_header.Remove
// Remove item by index. If index outside of range, do nothing.
void gitlab::response_header_Remove(gitlab::FHttp& parent, u32 i) {
    u32 lim = parent.response_header_n;
    algo::cstring *elems = parent.response_header_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.response_header_n = lim - 1;
    }
}

// --- gitlab.FHttp.response_header.RemoveAll
void gitlab::response_header_RemoveAll(gitlab::FHttp& parent) {
    u32 n = parent.response_header_n;
    while (n > 0) {
        n -= 1;
        parent.response_header_elems[n].~cstring();
        parent.response_header_n = n;
    }
}

// --- gitlab.FHttp.response_header.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void gitlab::response_header_RemoveLast(gitlab::FHttp& parent) {
    u64 n = parent.response_header_n;
    if (n > 0) {
        n -= 1;
        response_header_qFind(parent, u64(n)).~cstring();
        parent.response_header_n = n;
    }
}

// --- gitlab.FHttp.response_header.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void gitlab::response_header_AbsReserve(gitlab::FHttp& parent, int n) {
    u32 old_max  = parent.response_header_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.response_header_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.tary_nomem  field:gitlab.FHttp.response_header  comment:'out of memory'");
        }
        parent.response_header_elems = (algo::cstring*)new_mem;
        parent.response_header_max = new_max;
    }
}

// --- gitlab.FHttp.response_header.Setary
// Copy contents of RHS to PARENT.
void gitlab::response_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) {
    response_header_RemoveAll(parent);
    int nnew = rhs.response_header_n;
    response_header_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.response_header_elems + i) algo::cstring(response_header_qFind(rhs, i));
        parent.response_header_n = i + 1;
    }
}

// --- gitlab.FHttp..Init
// Set all fields to initial values.
void gitlab::FHttp_Init(gitlab::FHttp& parent) {
    parent.request_header_elems 	= 0; // (gitlab.FHttp.request_header)
    parent.request_header_n     	= 0; // (gitlab.FHttp.request_header)
    parent.request_header_max   	= 0; // (gitlab.FHttp.request_header)
    parent.response_status_code = u32(0);
    parent.request_method = u32(gitlab_FHttp_request_method_GET);
    parent.response_header_elems 	= 0; // (gitlab.FHttp.response_header)
    parent.response_header_n     	= 0; // (gitlab.FHttp.response_header)
    parent.response_header_max   	= 0; // (gitlab.FHttp.response_header)
    parent.response_content_type_json = bool(false);
    parent.request_body_sent_bytes = u32(0);
}

// --- gitlab.FHttp..Uninit
void gitlab::FHttp_Uninit(gitlab::FHttp& parent) {
    gitlab::FHttp &row = parent; (void)row;

    // gitlab.FHttp.response_header.Uninit (Tary)  //Array of request headers
    // remove all elements from gitlab.FHttp.response_header
    response_header_RemoveAll(parent);
    // free memory for Tary gitlab.FHttp.response_header
    algo_lib::malloc_FreeMem(parent.response_header_elems, sizeof(algo::cstring)*parent.response_header_max); // (gitlab.FHttp.response_header)

    // gitlab.FHttp.request_header.Uninit (Tary)  //Array of request headers
    // remove all elements from gitlab.FHttp.request_header
    request_header_RemoveAll(parent);
    // free memory for Tary gitlab.FHttp.request_header
    algo_lib::malloc_FreeMem(parent.request_header_elems, sizeof(algo::cstring)*parent.request_header_max); // (gitlab.FHttp.request_header)
}

// --- gitlab.FHttp..Print
// print string representation of gitlab::FHttp to string LHS, no header -- cprint:gitlab.FHttp.String
void gitlab::FHttp_Print(gitlab::FHttp & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.FHttp";

    algo::cstring_Print(row.request_uri, temp);
    PrintAttrSpaceReset(str,"request_uri", temp);

    algo::cstring_Print(row.request_content_type, temp);
    PrintAttrSpaceReset(str,"request_content_type", temp);

    algo::cstring_Print(row.request_body, temp);
    PrintAttrSpaceReset(str,"request_body", temp);

    algo::cstring_Print(row.response_status_line, temp);
    PrintAttrSpaceReset(str,"response_status_line", temp);

    u32_Print(row.response_status_code, temp);
    PrintAttrSpaceReset(str,"response_status_code", temp);

    gitlab::request_method_Print(row, temp);
    PrintAttrSpaceReset(str,"request_method", temp);

    algo::cstring_Print(row.response_reason_phrase, temp);
    PrintAttrSpaceReset(str,"response_reason_phrase", temp);

    algo::cstring_Print(row.response_content_type, temp);
    PrintAttrSpaceReset(str,"response_content_type", temp);

    algo::cstring_Print(row.response_body, temp);
    PrintAttrSpaceReset(str,"response_body", temp);

    bool_Print(row.response_content_type_json, temp);
    PrintAttrSpaceReset(str,"response_content_type_json", temp);

    lib_json::FParser_Print(row.response_json_parser, temp);
    PrintAttrSpaceReset(str,"response_json_parser", temp);

    u32_Print(row.request_body_sent_bytes, temp);
    PrintAttrSpaceReset(str,"request_body_sent_bytes", temp);
}

// --- gitlab.FIssue.base.CopyOut
// Copy fields out of row
void gitlab::issue_CopyOut(gitlab::FIssue &row, gitlab::Issue &out) {
    out.issue = row.issue;
    out.assignee = row.assignee;
    out.title = row.title;
}

// --- gitlab.FIssue.base.CopyIn
// Copy fields in to row
void gitlab::issue_CopyIn(gitlab::FIssue &row, gitlab::Issue &in) {
    row.issue = in.issue;
    row.assignee = in.assignee;
    row.title = in.title;
}

// --- gitlab.FIssue.project.Get
algo::Smallstr50 gitlab::project_Get(gitlab::FIssue& issue) {
    algo::Smallstr50 ret(algo::Pathcomp(issue.issue, ".RL"));
    return ret;
}

// --- gitlab.FIssue.iid.Get
u32 gitlab::iid_Get(gitlab::FIssue& issue) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(issue.issue, ".RR"));
    return ret;
}

// --- gitlab.FIssue.c_issue_note.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gitlab::c_issue_note_Insert(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
    if (bool_Update(row.issue_c_issue_note_in_ary,true)) {
        // reserve space
        c_issue_note_Reserve(issue, 1);
        u32 n  = issue.c_issue_note_n;
        u32 at = n;
        gitlab::FIssueNote* *elems = issue.c_issue_note_elems;
        elems[at] = &row;
        issue.c_issue_note_n = n+1;

    }
}

// --- gitlab.FIssue.c_issue_note.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gitlab::c_issue_note_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
    bool retval = !row.issue_c_issue_note_in_ary;
    c_issue_note_Insert(issue,row); // check is performed in _Insert again
    return retval;
}

// --- gitlab.FIssue.c_issue_note.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gitlab::c_issue_note_Remove(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
    if (bool_Update(row.issue_c_issue_note_in_ary,false)) {
        int lim = issue.c_issue_note_n;
        gitlab::FIssueNote* *elems = issue.c_issue_note_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gitlab::FIssueNote* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gitlab::FIssueNote*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                issue.c_issue_note_n = lim - 1;
                break;
            }
        }
    }
}

// --- gitlab.FIssue.c_issue_note.Reserve
// Reserve space in index for N more elements;
void gitlab::c_issue_note_Reserve(gitlab::FIssue& issue, u32 n) {
    u32 old_max = issue.c_issue_note_max;
    if (UNLIKELY(issue.c_issue_note_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gitlab::FIssueNote*);
        u32 new_size = new_max * sizeof(gitlab::FIssueNote*);
        void *new_mem = algo_lib::malloc_ReallocMem(issue.c_issue_note_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FIssue.c_issue_note");
        }
        issue.c_issue_note_elems = (gitlab::FIssueNote**)new_mem;
        issue.c_issue_note_max = new_max;
    }
}

// --- gitlab.FIssue..Init
// Set all fields to initial values.
void gitlab::FIssue_Init(gitlab::FIssue& issue) {
    issue.p_project = NULL;
    issue.c_issue_note_elems = NULL; // (gitlab.FIssue.c_issue_note)
    issue.c_issue_note_n = 0; // (gitlab.FIssue.c_issue_note)
    issue.c_issue_note_max = 0; // (gitlab.FIssue.c_issue_note)
    issue.c_issue_description = NULL;
    issue.select = bool(false);
    issue.project_c_issue_in_ary = bool(false);
    issue.ind_issue_next = (gitlab::FIssue*)-1; // (gitlab.FDb.ind_issue) not-in-hash
}

// --- gitlab.FIssue..Uninit
void gitlab::FIssue_Uninit(gitlab::FIssue& issue) {
    gitlab::FIssue &row = issue; (void)row;
    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
    if (p_project)  {
        c_issue_Remove(*p_project, row);// remove issue from index c_issue
    }
    ind_issue_Remove(row); // remove issue from index ind_issue

    // gitlab.FIssue.c_issue_note.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(issue.c_issue_note_elems, sizeof(gitlab::FIssueNote*)*issue.c_issue_note_max); // (gitlab.FIssue.c_issue_note)
}

// --- gitlab.FIssue..Print
// print string representation of gitlab::FIssue to string LHS, no header -- cprint:gitlab.FIssue.String
void gitlab::FIssue_Print(gitlab::FIssue & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.FIssue";

    algo::Smallstr50_Print(row.issue, temp);
    PrintAttrSpaceReset(str,"issue", temp);

    algo::Smallstr50_Print(row.assignee, temp);
    PrintAttrSpaceReset(str,"assignee", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    u64_PrintHex(u64((const gitlab::FIssueDescription*)row.c_issue_description), temp, 8, true);
    PrintAttrSpaceReset(str,"c_issue_description", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);

    bool_Print(row.project_c_issue_in_ary, temp);
    PrintAttrSpaceReset(str,"project_c_issue_in_ary", temp);
}

// --- gitlab.FIssueDescription.base.CopyOut
// Copy fields out of row
void gitlab::issue_description_CopyOut(gitlab::FIssueDescription &row, gitlab::IssueDescription &out) {
    out.issue = row.issue;
    out.description = row.description;
}

// --- gitlab.FIssueDescription.base.CopyIn
// Copy fields in to row
void gitlab::issue_description_CopyIn(gitlab::FIssueDescription &row, gitlab::IssueDescription &in) {
    row.issue = in.issue;
    row.description = in.description;
}

// --- gitlab.FIssueDescription..Uninit
void gitlab::FIssueDescription_Uninit(gitlab::FIssueDescription& issue_description) {
    gitlab::FIssueDescription &row = issue_description; (void)row;
    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(row.issue);
    if (p_issue)  {
        c_issue_description_Remove(*p_issue, row);// remove issue_description from index c_issue_description
    }
}

// --- gitlab.FIssueNote.base.CopyOut
// Copy fields out of row
void gitlab::issue_note_CopyOut(gitlab::FIssueNote &row, gitlab::IssueNote &out) {
    out.issue_note = row.issue_note;
    out.body = row.body;
}

// --- gitlab.FIssueNote.base.CopyIn
// Copy fields in to row
void gitlab::issue_note_CopyIn(gitlab::FIssueNote &row, gitlab::IssueNote &in) {
    row.issue_note = in.issue_note;
    row.body = in.body;
}

// --- gitlab.FIssueNote.issue.Get
algo::Smallstr50 gitlab::issue_Get(gitlab::FIssueNote& issue_note) {
    algo::Smallstr50 ret(algo::Pathcomp(issue_note.issue_note, ".RL"));
    return ret;
}

// --- gitlab.FIssueNote.id.Get
u32 gitlab::id_Get(gitlab::FIssueNote& issue_note) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(issue_note.issue_note, ".RR"));
    return ret;
}

// --- gitlab.FIssueNote..Uninit
void gitlab::FIssueNote_Uninit(gitlab::FIssueNote& issue_note) {
    gitlab::FIssueNote &row = issue_note; (void)row;
    ind_issue_note_Remove(row); // remove issue_note from index ind_issue_note
    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(issue_Get(row));
    if (p_issue)  {
        c_issue_note_Remove(*p_issue, row);// remove issue_note from index c_issue_note
    }
}

// --- gitlab.FMr.base.CopyOut
// Copy fields out of row
void gitlab::mr_CopyOut(gitlab::FMr &row, gitlab::Mr &out) {
    out.mr = row.mr;
    out.title = row.title;
    out.source_branch = row.source_branch;
    out.pipeline_status = row.pipeline_status;
}

// --- gitlab.FMr.base.CopyIn
// Copy fields in to row
void gitlab::mr_CopyIn(gitlab::FMr &row, gitlab::Mr &in) {
    row.mr = in.mr;
    row.title = in.title;
    row.source_branch = in.source_branch;
    row.pipeline_status = in.pipeline_status;
}

// --- gitlab.FMr.project.Get
algo::Smallstr50 gitlab::project_Get(gitlab::FMr& mr) {
    algo::Smallstr50 ret(algo::Pathcomp(mr.mr, ".RL"));
    return ret;
}

// --- gitlab.FMr.iid.Get
u32 gitlab::iid_Get(gitlab::FMr& mr) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(mr.mr, ".RR"));
    return ret;
}

// --- gitlab.FMr.c_mr_note.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gitlab::c_mr_note_Insert(gitlab::FMr& mr, gitlab::FMrNote& row) {
    if (bool_Update(row.mr_c_mr_note_in_ary,true)) {
        // reserve space
        c_mr_note_Reserve(mr, 1);
        u32 n  = mr.c_mr_note_n;
        u32 at = n;
        gitlab::FMrNote* *elems = mr.c_mr_note_elems;
        elems[at] = &row;
        mr.c_mr_note_n = n+1;

    }
}

// --- gitlab.FMr.c_mr_note.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gitlab::c_mr_note_InsertMaybe(gitlab::FMr& mr, gitlab::FMrNote& row) {
    bool retval = !row.mr_c_mr_note_in_ary;
    c_mr_note_Insert(mr,row); // check is performed in _Insert again
    return retval;
}

// --- gitlab.FMr.c_mr_note.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gitlab::c_mr_note_Remove(gitlab::FMr& mr, gitlab::FMrNote& row) {
    if (bool_Update(row.mr_c_mr_note_in_ary,false)) {
        int lim = mr.c_mr_note_n;
        gitlab::FMrNote* *elems = mr.c_mr_note_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gitlab::FMrNote* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gitlab::FMrNote*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                mr.c_mr_note_n = lim - 1;
                break;
            }
        }
    }
}

// --- gitlab.FMr.c_mr_note.Reserve
// Reserve space in index for N more elements;
void gitlab::c_mr_note_Reserve(gitlab::FMr& mr, u32 n) {
    u32 old_max = mr.c_mr_note_max;
    if (UNLIKELY(mr.c_mr_note_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gitlab::FMrNote*);
        u32 new_size = new_max * sizeof(gitlab::FMrNote*);
        void *new_mem = algo_lib::malloc_ReallocMem(mr.c_mr_note_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FMr.c_mr_note");
        }
        mr.c_mr_note_elems = (gitlab::FMrNote**)new_mem;
        mr.c_mr_note_max = new_max;
    }
}

// --- gitlab.FMr..Init
// Set all fields to initial values.
void gitlab::FMr_Init(gitlab::FMr& mr) {
    mr.p_project = NULL;
    mr.c_mr_note_elems = NULL; // (gitlab.FMr.c_mr_note)
    mr.c_mr_note_n = 0; // (gitlab.FMr.c_mr_note)
    mr.c_mr_note_max = 0; // (gitlab.FMr.c_mr_note)
    mr.c_mr_description = NULL;
    mr.project_c_mr_in_ary = bool(false);
    mr.ind_mr_next = (gitlab::FMr*)-1; // (gitlab.FDb.ind_mr) not-in-hash
}

// --- gitlab.FMr..Uninit
void gitlab::FMr_Uninit(gitlab::FMr& mr) {
    gitlab::FMr &row = mr; (void)row;
    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
    if (p_project)  {
        c_mr_Remove(*p_project, row);// remove mr from index c_mr
    }
    ind_mr_Remove(row); // remove mr from index ind_mr

    // gitlab.FMr.c_mr_note.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(mr.c_mr_note_elems, sizeof(gitlab::FMrNote*)*mr.c_mr_note_max); // (gitlab.FMr.c_mr_note)
}

// --- gitlab.FMr..Print
// print string representation of gitlab::FMr to string LHS, no header -- cprint:gitlab.FMr.String
void gitlab::FMr_Print(gitlab::FMr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.FMr";

    algo::Smallstr50_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.source_branch, temp);
    PrintAttrSpaceReset(str,"source_branch", temp);

    algo::Smallstr20_Print(row.pipeline_status, temp);
    PrintAttrSpaceReset(str,"pipeline_status", temp);

    u64_PrintHex(u64((const gitlab::FMrDescription*)row.c_mr_description), temp, 8, true);
    PrintAttrSpaceReset(str,"c_mr_description", temp);

    bool_Print(row.project_c_mr_in_ary, temp);
    PrintAttrSpaceReset(str,"project_c_mr_in_ary", temp);
}

// --- gitlab.FMrDescription.base.CopyOut
// Copy fields out of row
void gitlab::mr_description_CopyOut(gitlab::FMrDescription &row, gitlab::MrDescription &out) {
    out.mr = row.mr;
    out.description = row.description;
}

// --- gitlab.FMrDescription.base.CopyIn
// Copy fields in to row
void gitlab::mr_description_CopyIn(gitlab::FMrDescription &row, gitlab::MrDescription &in) {
    row.mr = in.mr;
    row.description = in.description;
}

// --- gitlab.FMrDescription..Uninit
void gitlab::FMrDescription_Uninit(gitlab::FMrDescription& mr_description) {
    gitlab::FMrDescription &row = mr_description; (void)row;
    gitlab::FMr* p_mr = gitlab::ind_mr_Find(row.mr);
    if (p_mr)  {
        c_mr_description_Remove(*p_mr, row);// remove mr_description from index c_mr_description
    }
}

// --- gitlab.FMrNote.base.CopyOut
// Copy fields out of row
void gitlab::mr_note_CopyOut(gitlab::FMrNote &row, gitlab::MrNote &out) {
    out.mr_note = row.mr_note;
    out.body = row.body;
}

// --- gitlab.FMrNote.base.CopyIn
// Copy fields in to row
void gitlab::mr_note_CopyIn(gitlab::FMrNote &row, gitlab::MrNote &in) {
    row.mr_note = in.mr_note;
    row.body = in.body;
}

// --- gitlab.FMrNote.mr.Get
algo::Smallstr50 gitlab::mr_Get(gitlab::FMrNote& mr_note) {
    algo::Smallstr50 ret(algo::Pathcomp(mr_note.mr_note, ".RL"));
    return ret;
}

// --- gitlab.FMrNote.id.Get
u32 gitlab::id_Get(gitlab::FMrNote& mr_note) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(mr_note.mr_note, ".RR"));
    return ret;
}

// --- gitlab.FMrNote..Uninit
void gitlab::FMrNote_Uninit(gitlab::FMrNote& mr_note) {
    gitlab::FMrNote &row = mr_note; (void)row;
    ind_mr_note_Remove(row); // remove mr_note from index ind_mr_note
    gitlab::FMr* p_mr = gitlab::ind_mr_Find(mr_Get(row));
    if (p_mr)  {
        c_mr_note_Remove(*p_mr, row);// remove mr_note from index c_mr_note
    }
}

// --- gitlab.FProject.base.CopyOut
// Copy fields out of row
void gitlab::project_CopyOut(gitlab::FProject &row, dev::GitlabProject &out) {
    out.gitlab_project = row.gitlab_project;
    out.url = row.url;
    out.comment = row.comment;
    out.gitlab_project_id = row.gitlab_project_id;
}

// --- gitlab.FProject.base.CopyIn
// Copy fields in to row
void gitlab::project_CopyIn(gitlab::FProject &row, dev::GitlabProject &in) {
    row.gitlab_project = in.gitlab_project;
    row.url = in.url;
    row.comment = in.comment;
    row.gitlab_project_id = in.gitlab_project_id;
}

// --- gitlab.FProject.c_issue.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gitlab::c_issue_Insert(gitlab::FProject& project, gitlab::FIssue& row) {
    if (bool_Update(row.project_c_issue_in_ary,true)) {
        // reserve space
        c_issue_Reserve(project, 1);
        u32 n  = project.c_issue_n;
        u32 at = n;
        gitlab::FIssue* *elems = project.c_issue_elems;
        elems[at] = &row;
        project.c_issue_n = n+1;

    }
}

// --- gitlab.FProject.c_issue.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gitlab::c_issue_InsertMaybe(gitlab::FProject& project, gitlab::FIssue& row) {
    bool retval = !row.project_c_issue_in_ary;
    c_issue_Insert(project,row); // check is performed in _Insert again
    return retval;
}

// --- gitlab.FProject.c_issue.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gitlab::c_issue_Remove(gitlab::FProject& project, gitlab::FIssue& row) {
    if (bool_Update(row.project_c_issue_in_ary,false)) {
        int lim = project.c_issue_n;
        gitlab::FIssue* *elems = project.c_issue_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gitlab::FIssue* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gitlab::FIssue*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                project.c_issue_n = lim - 1;
                break;
            }
        }
    }
}

// --- gitlab.FProject.c_issue.Reserve
// Reserve space in index for N more elements;
void gitlab::c_issue_Reserve(gitlab::FProject& project, u32 n) {
    u32 old_max = project.c_issue_max;
    if (UNLIKELY(project.c_issue_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gitlab::FIssue*);
        u32 new_size = new_max * sizeof(gitlab::FIssue*);
        void *new_mem = algo_lib::malloc_ReallocMem(project.c_issue_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FProject.c_issue");
        }
        project.c_issue_elems = (gitlab::FIssue**)new_mem;
        project.c_issue_max = new_max;
    }
}

// --- gitlab.FProject.c_mr.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void gitlab::c_mr_Insert(gitlab::FProject& project, gitlab::FMr& row) {
    if (bool_Update(row.project_c_mr_in_ary,true)) {
        // reserve space
        c_mr_Reserve(project, 1);
        u32 n  = project.c_mr_n;
        u32 at = n;
        gitlab::FMr* *elems = project.c_mr_elems;
        elems[at] = &row;
        project.c_mr_n = n+1;

    }
}

// --- gitlab.FProject.c_mr.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool gitlab::c_mr_InsertMaybe(gitlab::FProject& project, gitlab::FMr& row) {
    bool retval = !row.project_c_mr_in_ary;
    c_mr_Insert(project,row); // check is performed in _Insert again
    return retval;
}

// --- gitlab.FProject.c_mr.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void gitlab::c_mr_Remove(gitlab::FProject& project, gitlab::FMr& row) {
    if (bool_Update(row.project_c_mr_in_ary,false)) {
        int lim = project.c_mr_n;
        gitlab::FMr* *elems = project.c_mr_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            gitlab::FMr* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(gitlab::FMr*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                project.c_mr_n = lim - 1;
                break;
            }
        }
    }
}

// --- gitlab.FProject.c_mr.Reserve
// Reserve space in index for N more elements;
void gitlab::c_mr_Reserve(gitlab::FProject& project, u32 n) {
    u32 old_max = project.c_mr_max;
    if (UNLIKELY(project.c_mr_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(gitlab::FMr*);
        u32 new_size = new_max * sizeof(gitlab::FMr*);
        void *new_mem = algo_lib::malloc_ReallocMem(project.c_mr_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FProject.c_mr");
        }
        project.c_mr_elems = (gitlab::FMr**)new_mem;
        project.c_mr_max = new_max;
    }
}

// --- gitlab.FProject..Uninit
void gitlab::FProject_Uninit(gitlab::FProject& project) {
    gitlab::FProject &row = project; (void)row;
    ind_project_Remove(row); // remove project from index ind_project

    // gitlab.FProject.c_mr.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(project.c_mr_elems, sizeof(gitlab::FMr*)*project.c_mr_max); // (gitlab.FProject.c_mr)

    // gitlab.FProject.c_issue.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(project.c_issue_elems, sizeof(gitlab::FIssue*)*project.c_issue_max); // (gitlab.FProject.c_issue)
}

// --- gitlab.FUser.base.CopyOut
// Copy fields out of row
void gitlab::user_CopyOut(gitlab::FUser &row, gitlab::User &out) {
    out.user = row.user;
    out.id = row.id;
    out.name = row.name;
}

// --- gitlab.FUser.base.CopyIn
// Copy fields in to row
void gitlab::user_CopyIn(gitlab::FUser &row, gitlab::User &in) {
    row.user = in.user;
    row.id = in.id;
    row.name = in.name;
}

// --- gitlab.FUser..Uninit
void gitlab::FUser_Uninit(gitlab::FUser& user) {
    gitlab::FUser &row = user; (void)row;
    ind_user_Remove(row); // remove user from index ind_user
}

// --- gitlab.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gitlab::value_ToCstr(const gitlab::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case gitlab_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- gitlab.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void gitlab::value_Print(const gitlab::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- gitlab.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gitlab::value_SetStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,gitlab_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gitlab.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gitlab::value_SetStrptr(gitlab::FieldId& parent, algo::strptr rhs, gitlab_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- gitlab.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool gitlab::value_ReadStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- gitlab.FieldId..ReadStrptrMaybe
// Read fields of gitlab::FieldId from an ascii string.
// The format of the string is the format of the gitlab::FieldId's only field
bool gitlab::FieldId_ReadStrptrMaybe(gitlab::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && gitlab::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- gitlab.FieldId..Print
// print string representation of gitlab::FieldId to string LHS, no header -- cprint:gitlab.FieldId.String
void gitlab::FieldId_Print(gitlab::FieldId & row, algo::cstring &str) {
    gitlab::value_Print(row, str);
}

// --- gitlab.Issue.project.Get
algo::Smallstr50 gitlab::project_Get(gitlab::Issue& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issue, ".RL"));
    return ret;
}

// --- gitlab.Issue.iid.Get
u32 gitlab::iid_Get(gitlab::Issue& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.issue, ".RR"));
    return ret;
}

// --- gitlab.Issue..Concat_project_iid
tempstr gitlab::Issue_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- gitlab.Issue..Print
// print string representation of gitlab::Issue to string LHS, no header -- cprint:gitlab.Issue.String
void gitlab::Issue_Print(gitlab::Issue & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.Issue";

    algo::Smallstr50_Print(row.issue, temp);
    PrintAttrSpaceReset(str,"issue", temp);

    algo::Smallstr50_Print(row.assignee, temp);
    PrintAttrSpaceReset(str,"assignee", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);
}

// --- gitlab.IssueDescription..Print
// print string representation of gitlab::IssueDescription to string LHS, no header -- cprint:gitlab.IssueDescription.String
void gitlab::IssueDescription_Print(gitlab::IssueDescription & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.IssueDescription";

    algo::Smallstr50_Print(row.issue, temp);
    PrintAttrSpaceReset(str,"issue", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);
}

// --- gitlab.IssueNote.issue.Get
algo::Smallstr50 gitlab::issue_Get(gitlab::IssueNote& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.issue_note, ".RL"));
    return ret;
}

// --- gitlab.IssueNote.id.Get
u32 gitlab::id_Get(gitlab::IssueNote& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.issue_note, ".RR"));
    return ret;
}

// --- gitlab.IssueNote..Concat_issue_id
tempstr gitlab::IssueNote_Concat_issue_id( const algo::strptr& issue ,u32 id ) {
    return tempstr() << issue <<'.'<< id ;
}

// --- gitlab.IssueNote..Print
// print string representation of gitlab::IssueNote to string LHS, no header -- cprint:gitlab.IssueNote.String
void gitlab::IssueNote_Print(gitlab::IssueNote & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.IssueNote";

    algo::Smallstr50_Print(row.issue_note, temp);
    PrintAttrSpaceReset(str,"issue_note", temp);

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);
}

// --- gitlab.Mr.project.Get
algo::Smallstr50 gitlab::project_Get(gitlab::Mr& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.mr, ".RL"));
    return ret;
}

// --- gitlab.Mr.iid.Get
u32 gitlab::iid_Get(gitlab::Mr& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.mr, ".RR"));
    return ret;
}

// --- gitlab.Mr..Concat_project_iid
tempstr gitlab::Mr_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
    return tempstr() << project <<'.'<< iid ;
}

// --- gitlab.Mr..Print
// print string representation of gitlab::Mr to string LHS, no header -- cprint:gitlab.Mr.String
void gitlab::Mr_Print(gitlab::Mr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.Mr";

    algo::Smallstr50_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.title, temp);
    PrintAttrSpaceReset(str,"title", temp);

    algo::cstring_Print(row.source_branch, temp);
    PrintAttrSpaceReset(str,"source_branch", temp);

    algo::Smallstr20_Print(row.pipeline_status, temp);
    PrintAttrSpaceReset(str,"pipeline_status", temp);
}

// --- gitlab.MrDescription..Print
// print string representation of gitlab::MrDescription to string LHS, no header -- cprint:gitlab.MrDescription.String
void gitlab::MrDescription_Print(gitlab::MrDescription & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.MrDescription";

    algo::Smallstr50_Print(row.mr, temp);
    PrintAttrSpaceReset(str,"mr", temp);

    algo::cstring_Print(row.description, temp);
    PrintAttrSpaceReset(str,"description", temp);
}

// --- gitlab.MrNote.mr.Get
algo::Smallstr50 gitlab::mr_Get(gitlab::MrNote& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.mr_note, ".RL"));
    return ret;
}

// --- gitlab.MrNote.id.Get
u32 gitlab::id_Get(gitlab::MrNote& parent) {
    u32 ret;
    ret = 0; // default value
    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.mr_note, ".RR"));
    return ret;
}

// --- gitlab.MrNote..Concat_mr_id
tempstr gitlab::MrNote_Concat_mr_id( const algo::strptr& mr ,u32 id ) {
    return tempstr() << mr <<'.'<< id ;
}

// --- gitlab.MrNote..Print
// print string representation of gitlab::MrNote to string LHS, no header -- cprint:gitlab.MrNote.String
void gitlab::MrNote_Print(gitlab::MrNote & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "gitlab.MrNote";

    algo::Smallstr50_Print(row.mr_note, temp);
    PrintAttrSpaceReset(str,"mr_note", temp);

    algo::cstring_Print(row.body, temp);
    PrintAttrSpaceReset(str,"body", temp);
}

// --- gitlab.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* gitlab::value_ToCstr(const gitlab::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case gitlab_TableId_dev_GitlabProject: ret = "dev.GitlabProject";  break;
    }
    return ret;
}

// --- gitlab.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void gitlab::value_Print(const gitlab::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- gitlab.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool gitlab::value_SetStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','G','i','t','l'): {
                    if (memcmp(rhs.elems+8,"abProject",9)==0) { value_SetEnum(parent,gitlab_TableId_dev_GitlabProject); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','g','i','t','l'): {
                    if (memcmp(rhs.elems+8,"ab_project",10)==0) { value_SetEnum(parent,gitlab_TableId_dev_gitlab_project); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- gitlab.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void gitlab::value_SetStrptr(gitlab::TableId& parent, algo::strptr rhs, gitlab_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- gitlab.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool gitlab::value_ReadStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- gitlab.TableId..ReadStrptrMaybe
// Read fields of gitlab::TableId from an ascii string.
// The format of the string is the format of the gitlab::TableId's only field
bool gitlab::TableId_ReadStrptrMaybe(gitlab::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && gitlab::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- gitlab.TableId..Print
// print string representation of gitlab::TableId to string LHS, no header -- cprint:gitlab.TableId.String
void gitlab::TableId_Print(gitlab::TableId & row, algo::cstring &str) {
    gitlab::value_Print(row, str);
}

// --- gitlab...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        gitlab::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        gitlab::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:gitlab
    } catch(algo_lib::ErrorX &x) {
        prerr("gitlab.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        gitlab::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- gitlab...SizeCheck
inline static void gitlab::SizeCheck() {
}
