//
// cpp/gen/acr_ed_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/acr_ed_gen.h"
#include "include/gen/acr_ed_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
acr_ed::FDb     acr_ed::_db;      // dependency found via dev.targdep

namespace acr_ed {
const char *acr_ed_help =
"acr_ed: ACR Editor Set of useful recipes, uses acr, abt, git, and other tools\n"
"Usage: acr_ed [options]\n"
"    OPTION      TYPE    DFLT    COMMENT\n"
"    -in         string  \"data\"  Input directory or filename, - for stdin\n"
"    -create                     Create new entity (-finput, -target, -ctype, -field)\n"
"    -del                        Delete mode\n"
"    -rename     string  \"\"      Rename to something else\n"
"    -replace                    Use acr -replace (default is -insert, fails on duplicate)\n"
"    -finput                     Create in-memory table based on ssimfile\n"
"    -foutput                    Declare field as an output\n"
"    -srcfile    string  \"\"          Create source file\n"
"    -gstatic                    Like -finput, but data is loaded at compile time\n"
"    -indexed                    (with -finput) Add hash index\n"
"    -target     string  \"\"      Create new target\n"
"    -nstype     string  \"exe\"   (with -create -target): exe,lib,etc.\n"
"    -ctype      string  \"\"      Create new ctype\n"
"    -pooltype   string  \"\"       Pool reftype (Lary,Lpool etc) for finput/ctype\n"
"    -ssimfile   string  \"\"        Ssimfile for new ctype\n"
"    -subset     string  \"\"        Primary key is a subset of this ctype\n"
"    -subset2    string  \"\"        Primary key is also a subset of this ctype\n"
"    -separator  string  \".\"         Key separator\n"
"    -field      string  \"\"      Create field\n"
"    -arg        string  \"\"        Field type (e.g. u32, etc), (with -ctype) add the base field\n"
"    -dflt       string  \"\"        Field default value\n"
"    -anon                         Anonymous field (use with command lines)\n"
"    -bigend                       Big-endian field\n"
"    -cascdel                      Field is cascdel\n"
"    -before     string  \"\"        Place field before this one\n"
"    -substr     string  \"\"        New field is a substring\n"
"    -srcfield   string  \"\"        Source field for bitfld/substr\n"
"    -fstep      string  \"\"        Add fstep record\n"
"    -inscond    string  \"true\"    Insert condition (for xref)\n"
"    -reftype    string  \"\"        Reftype (e.g. Val, Thash, Llist, etc)\n"
"    -hashfld    string  \"\"          (-reftype:Thash) Hash field\n"
"    -sortfld    string  \"\"          (-reftype:Bheap) Sort field\n"
"    -unittest   string  \"\"      Create unit test, <ns>.<functionname>\n"
"    -citest     string  \"\"      Create CI test\n"
"    -cppfunc    string  \"\"      Field is a cppfunc, pass c++ expression as argument\n"
"    -xref                           X-ref with field type\n"
"    -via        string  \"\"            X-ref argument (index, pointer, or index/key)\n"
"    -write                      Commit output to disk\n"
"    -e                           (with -create -unittest) Edit new testcase\n"
"    -comment    string  \"\"      Comment for new entity\n"
"    -sandbox                    Make changes in sandbox\n"
"    -test                       Build resulting changes, run tests\n"
"    -showcpp                    (With -sandbox), show resulting diff\n"
"    -msgtype    string  \"\"      (with -ctype) use this msgtype as type\n"
"    -anonfld                    Create anonfld\n"
"    -verbose    int             Verbosity level (0..255); alias -v; cumulative\n"
"    -debug      int             Debug level (0..255); alias -d; cumulative\n"
"    -help                       Print help an exit; alias -h\n"
"    -version                    Print version and exit\n"
"    -signature                  Show signatures and exit; alias -sig\n"
;


} // namespace acr_ed
namespace acr_ed { // gen:ns_print_proto
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    static bool          cstr_InputMaybe(dmmeta::Cstr &elem) __attribute__((nothrow));
    static bool          listtype_InputMaybe(dmmeta::Listtype &elem) __attribute__((nothrow));
    static bool          fprefix_InputMaybe(dmmeta::Fprefix &elem) __attribute__((nothrow));
    static bool          target_InputMaybe(dev::Target &elem) __attribute__((nothrow));
    static bool          targsrc_InputMaybe(dev::Targsrc &elem) __attribute__((nothrow));
    static bool          sbpath_InputMaybe(dev::Sbpath &elem) __attribute__((nothrow));
    static bool          pack_InputMaybe(dmmeta::Pack &elem) __attribute__((nothrow));
    static bool          typefld_InputMaybe(dmmeta::Typefld &elem) __attribute__((nothrow));
    static bool          cpptype_InputMaybe(dmmeta::Cpptype &elem) __attribute__((nothrow));
    static bool          cfmt_InputMaybe(dmmeta::Cfmt &elem) __attribute__((nothrow));
    static bool          nsdb_InputMaybe(dmmeta::Nsdb &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- acr_ed.FCfmt.base.CopyOut
// Copy fields out of row
void acr_ed::cfmt_CopyOut(acr_ed::FCfmt &row, dmmeta::Cfmt &out) {
    out.cfmt = row.cfmt;
    out.printfmt = row.printfmt;
    out.read = row.read;
    out.print = row.print;
    out.sep = row.sep;
    out.genop = row.genop;
    out.comment = row.comment;
}

// --- acr_ed.FCfmt.base.CopyIn
// Copy fields in to row
void acr_ed::cfmt_CopyIn(acr_ed::FCfmt &row, dmmeta::Cfmt &in) {
    row.cfmt = in.cfmt;
    row.printfmt = in.printfmt;
    row.read = in.read;
    row.print = in.print;
    row.sep = in.sep;
    row.genop = in.genop;
    row.comment = in.comment;
}

// --- acr_ed.FCfmt.ctype.Get
algo::Smallstr50 acr_ed::ctype_Get(acr_ed::FCfmt& cfmt) {
    algo::Smallstr50 ret(algo::Pathcomp(cfmt.cfmt, ".RL"));
    return ret;
}

// --- acr_ed.FCfmt.strfmt.Get
algo::Smallstr50 acr_ed::strfmt_Get(acr_ed::FCfmt& cfmt) {
    algo::Smallstr50 ret(algo::Pathcomp(cfmt.cfmt, ".RR"));
    return ret;
}

// --- acr_ed.FCfmt..Uninit
void acr_ed::FCfmt_Uninit(acr_ed::FCfmt& cfmt) {
    acr_ed::FCfmt &row = cfmt; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_cfmt_Remove(*p_ctype, row);// remove cfmt from index c_cfmt
    }
}

// --- acr_ed.FCpptype.base.CopyOut
// Copy fields out of row
void acr_ed::cpptype_CopyOut(acr_ed::FCpptype &row, dmmeta::Cpptype &out) {
    out.ctype = row.ctype;
    out.ctor = row.ctor;
    out.dtor = row.dtor;
    out.cheap_copy = row.cheap_copy;
}

// --- acr_ed.FCpptype.base.CopyIn
// Copy fields in to row
void acr_ed::cpptype_CopyIn(acr_ed::FCpptype &row, dmmeta::Cpptype &in) {
    row.ctype = in.ctype;
    row.ctor = in.ctor;
    row.dtor = in.dtor;
    row.cheap_copy = in.cheap_copy;
}

// --- acr_ed.FCpptype..Uninit
void acr_ed::FCpptype_Uninit(acr_ed::FCpptype& cpptype) {
    acr_ed::FCpptype &row = cpptype; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cpptype_Remove(*p_ctype, row);// remove cpptype from index c_cpptype
    }
}

// --- acr_ed.FCstr.msghdr.CopyOut
// Copy fields out of row
void acr_ed::cstr_CopyOut(acr_ed::FCstr &row, dmmeta::Cstr &out) {
    out.ctype = row.ctype;
    out.strequiv = row.strequiv;
    out.comment = row.comment;
}

// --- acr_ed.FCstr.msghdr.CopyIn
// Copy fields in to row
void acr_ed::cstr_CopyIn(acr_ed::FCstr &row, dmmeta::Cstr &in) {
    row.ctype = in.ctype;
    row.strequiv = in.strequiv;
    row.comment = in.comment;
}

// --- acr_ed.FCstr..Uninit
void acr_ed::FCstr_Uninit(acr_ed::FCstr& cstr) {
    acr_ed::FCstr &row = cstr; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cstr_Remove(*p_ctype, row);// remove cstr from index c_cstr
    }
}

// --- acr_ed.FCtype.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ctype_CopyOut(acr_ed::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- acr_ed.FCtype.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ctype_CopyIn(acr_ed::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- acr_ed.FCtype.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- acr_ed.FCtype.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FCtype& ctype) {
    algo::Smallstr50 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- acr_ed.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr_ed::c_field_Insert(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,true)) {
        // reserve space
        c_field_Reserve(ctype, 1);
        u32 n  = ctype.c_field_n;
        u32 at = n;
        acr_ed::FField* *elems = ctype.c_field_elems;
        elems[at] = &row;
        ctype.c_field_n = n+1;

    }
}

// --- acr_ed.FCtype.c_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool acr_ed::c_field_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    bool retval = !row.ctype_c_field_in_ary;
    c_field_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- acr_ed.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr_ed::c_field_Remove(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,false)) {
        int lim = ctype.c_field_n;
        acr_ed::FField* *elems = ctype.c_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            acr_ed::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(acr_ed::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- acr_ed.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void acr_ed::c_field_Reserve(acr_ed::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr_ed::FField*);
        u32 new_size = new_max * sizeof(acr_ed::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FCtype.c_field");
        }
        ctype.c_field_elems = (acr_ed::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- acr_ed.FCtype.c_cfmt.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr_ed::c_cfmt_Insert(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) {
    // reserve space
    c_cfmt_Reserve(ctype, 1);
    u32 n  = ctype.c_cfmt_n;
    u32 at = n;
    acr_ed::FCfmt* *elems = ctype.c_cfmt_elems;
    elems[at] = &row;
    ctype.c_cfmt_n = n+1;

}

// --- acr_ed.FCtype.c_cfmt.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool acr_ed::c_cfmt_ScanInsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) {
    bool retval = true;
    u32 n  = ctype.c_cfmt_n;
    for (u32 i = 0; i < n; i++) {
        if (ctype.c_cfmt_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_cfmt_Reserve(ctype, 1);
        ctype.c_cfmt_elems[n] = &row;
        ctype.c_cfmt_n = n+1;
    }
    return retval;
}

// --- acr_ed.FCtype.c_cfmt.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr_ed::c_cfmt_Remove(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) {
    int lim = ctype.c_cfmt_n;
    acr_ed::FCfmt* *elems = ctype.c_cfmt_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        acr_ed::FCfmt* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(acr_ed::FCfmt*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ctype.c_cfmt_n = lim - 1;
            break;
        }
    }
}

// --- acr_ed.FCtype.c_cfmt.Reserve
// Reserve space in index for N more elements;
void acr_ed::c_cfmt_Reserve(acr_ed::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_cfmt_max;
    if (UNLIKELY(ctype.c_cfmt_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr_ed::FCfmt*);
        u32 new_size = new_max * sizeof(acr_ed::FCfmt*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_cfmt_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FCtype.c_cfmt");
        }
        ctype.c_cfmt_elems = (acr_ed::FCfmt**)new_mem;
        ctype.c_cfmt_max = new_max;
    }
}

// --- acr_ed.FCtype..Init
// Set all fields to initial values.
void acr_ed::FCtype_Init(acr_ed::FCtype& ctype) {
    ctype.c_field_elems = NULL; // (acr_ed.FCtype.c_field)
    ctype.c_field_n = 0; // (acr_ed.FCtype.c_field)
    ctype.c_field_max = 0; // (acr_ed.FCtype.c_field)
    ctype.c_cstr = NULL;
    ctype.p_ns = NULL;
    ctype.c_ssimfile = NULL;
    ctype.c_pack = NULL;
    ctype.c_typefld = NULL;
    ctype.c_cpptype = NULL;
    ctype.c_cfmt_elems = NULL; // (acr_ed.FCtype.c_cfmt)
    ctype.c_cfmt_n = 0; // (acr_ed.FCtype.c_cfmt)
    ctype.c_cfmt_max = 0; // (acr_ed.FCtype.c_cfmt)
    ctype.ind_ctype_next = (acr_ed::FCtype*)-1; // (acr_ed.FDb.ind_ctype) not-in-hash
}

// --- acr_ed.FCtype..Uninit
void acr_ed::FCtype_Uninit(acr_ed::FCtype& ctype) {
    acr_ed::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype

    // acr_ed.FCtype.c_cfmt.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_cfmt_elems, sizeof(acr_ed::FCfmt*)*ctype.c_cfmt_max); // (acr_ed.FCtype.c_cfmt)

    // acr_ed.FCtype.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_field_elems, sizeof(acr_ed::FField*)*ctype.c_field_max); // (acr_ed.FCtype.c_field)
}

// --- acr_ed.trace..Print
// print string representation of acr_ed::trace to string LHS, no header -- cprint:acr_ed.trace.String
void acr_ed::trace_Print(acr_ed::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr_ed.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- acr_ed.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNs& acr_ed::ns_Alloc() {
    acr_ed::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNs* acr_ed::ns_AllocMaybe() {
    acr_ed::FNs *row = (acr_ed::FNs*)ns_AllocMem();
    if (row) {
        new (row) acr_ed::FNs; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNs* acr_ed::ns_InsertMaybe(const dmmeta::Ns &value) {
    acr_ed::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FNs*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = i32(n);
    }
}

// --- acr_ed.FDb.ns.InputMaybe
static bool acr_ed::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ns_XrefMaybe(acr_ed::FNs &row) {
    bool retval = true;
    (void)row;
    // insert ns into index ind_ns
    if (true) { // user-defined insert condition
        bool success = ind_ns_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ns"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ns.Find
// Find row by key. Return NULL if not found.
acr_ed::FNs* acr_ed::ind_ns_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_ns_buckets_n - 1);
    acr_ed::FNs* *e = &_db.ind_ns_buckets_elems[index];
    acr_ed::FNs* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_ns_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ns.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNs& acr_ed::ind_ns_FindX(const algo::strptr& key) {
    acr_ed::FNs* ret = ind_ns_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ns  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ns.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNs& acr_ed::ind_ns_GetOrCreate(const algo::strptr& key) {
    acr_ed::FNs* ret = ind_ns_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ns_Alloc();
        (*ret).ns = key;
        bool good = ns_XrefMaybe(*ret);
        if (!good) {
            ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr_ed.create_error  table:ind_ns  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr_ed.FDb.ind_ns.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ns_InsertMaybe(acr_ed::FNs& row) {
    ind_ns_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ns_next == (acr_ed::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        acr_ed::FNs* *prev = &_db.ind_ns_buckets_elems[index];
        do {
            acr_ed::FNs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ns_next;
        } while (true);
        if (retval) {
            row.ind_ns_next = *prev;
            _db.ind_ns_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ns.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ns_Remove(acr_ed::FNs& row) {
    if (LIKELY(row.ind_ns_next != (acr_ed::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        acr_ed::FNs* *prev = &_db.ind_ns_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FNs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ns_next; // unlink (singly linked list)
                _db.ind_ns_n--;
                row.ind_ns_next = (acr_ed::FNs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ns_next;
        }
    }
}

// --- acr_ed.FDb.ind_ns.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ns_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ns_buckets_n;
    u32 new_nelems   = _db.ind_ns_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FNs*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FNs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FNs* *new_buckets = (acr_ed::FNs**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ns");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ns_buckets_n; i++) {
            acr_ed::FNs* elem = _db.ind_ns_buckets_elems[i];
            while (elem) {
                acr_ed::FNs &row        = *elem;
                acr_ed::FNs* next       = row.ind_ns_next;
                u32 index          = algo::Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_ns_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ns_buckets_elems, old_size);
        _db.ind_ns_buckets_elems = new_buckets;
        _db.ind_ns_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     acr_ed.FDb.cmdline
//     algo_lib.FDb.cmdline
void acr_ed::ReadArgv() {
    command::acr_ed &cmd = acr_ed::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::acr_ed_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"acr_ed: unknown option "<<Keyval("value",arg)<<eol;
            } else {
            }
        }
        if (ch_N(attrname) == 0) {
            err << "acr_ed: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::acr_ed_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"acr_ed: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(acr_ed_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
    vrfy(acr_ed::LoadTuplesMaybe(cmd.in)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
}

// --- acr_ed.FDb._db.MainLoop
// Main loop.
void acr_ed::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        acr_ed::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- acr_ed.FDb._db.Step
// Main step
void acr_ed::Step() {
}

// --- acr_ed.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void acr_ed::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("acr_ed", acr_ed::InsertStrptrMaybe, NULL, acr_ed::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "acr_ed.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(acr_ed::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)acr_ed::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'acr_ed.Input'  signature:'639bf4accf4b0ae5a1edac114fd03a4c77be2e52'");
}

// --- acr_ed.FDb._db.StaticCheck
void acr_ed::StaticCheck() {
    algo_assert(_offset_of(acr_ed::FieldId, value) + sizeof(((acr_ed::FieldId*)0)->value) == sizeof(acr_ed::FieldId));
}

// --- acr_ed.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool acr_ed::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    acr_ed::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case acr_ed_TableId_dmmeta_Ns: { // finput:acr_ed.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Field: { // finput:acr_ed.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Ctype: { // finput:acr_ed.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Ssimfile: { // finput:acr_ed.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Cstr: { // finput:acr_ed.FDb.cstr
            dmmeta::Cstr elem;
            retval = dmmeta::Cstr_ReadStrptrMaybe(elem, str);
            retval = retval && cstr_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Listtype: { // finput:acr_ed.FDb.listtype
            dmmeta::Listtype elem;
            retval = dmmeta::Listtype_ReadStrptrMaybe(elem, str);
            retval = retval && listtype_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Fprefix: { // finput:acr_ed.FDb.fprefix
            dmmeta::Fprefix elem;
            retval = dmmeta::Fprefix_ReadStrptrMaybe(elem, str);
            retval = retval && fprefix_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dev_Target: { // finput:acr_ed.FDb.target
            dev::Target elem;
            retval = dev::Target_ReadStrptrMaybe(elem, str);
            retval = retval && target_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dev_Targsrc: { // finput:acr_ed.FDb.targsrc
            dev::Targsrc elem;
            retval = dev::Targsrc_ReadStrptrMaybe(elem, str);
            retval = retval && targsrc_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dev_Sbpath: { // finput:acr_ed.FDb.sbpath
            dev::Sbpath elem;
            retval = dev::Sbpath_ReadStrptrMaybe(elem, str);
            retval = retval && sbpath_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Pack: { // finput:acr_ed.FDb.pack
            dmmeta::Pack elem;
            retval = dmmeta::Pack_ReadStrptrMaybe(elem, str);
            retval = retval && pack_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Typefld: { // finput:acr_ed.FDb.typefld
            dmmeta::Typefld elem;
            retval = dmmeta::Typefld_ReadStrptrMaybe(elem, str);
            retval = retval && typefld_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Cpptype: { // finput:acr_ed.FDb.cpptype
            dmmeta::Cpptype elem;
            retval = dmmeta::Cpptype_ReadStrptrMaybe(elem, str);
            retval = retval && cpptype_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Cfmt: { // finput:acr_ed.FDb.cfmt
            dmmeta::Cfmt elem;
            retval = dmmeta::Cfmt_ReadStrptrMaybe(elem, str);
            retval = retval && cfmt_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Nsdb: { // finput:acr_ed.FDb.nsdb
            dmmeta::Nsdb elem;
            retval = dmmeta::Nsdb_ReadStrptrMaybe(elem, str);
            retval = retval && nsdb_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- acr_ed.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool acr_ed::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dmmeta.ns", "dmmeta.ctype", "dmmeta.cfmt", "dmmeta.cpptype"
        , "dmmeta.cstr", "dmmeta.field", "dmmeta.fprefix", "dmmeta.listtype"
        , "dmmeta.nsdb", "dmmeta.pack", "dev.sbpath", "dmmeta.ssimfile"
        , "dev.target", "dev.targsrc", "dmmeta.typefld"
        , NULL};
        retval = algo_lib::DoLoadTuples(root, acr_ed::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- acr_ed.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool acr_ed::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, acr_ed::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- acr_ed.FDb._db.Steps
// Calls Step function of dependencies
void acr_ed::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- acr_ed.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- acr_ed.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FField& acr_ed::field_Alloc() {
    acr_ed::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FField* acr_ed::field_AllocMaybe() {
    acr_ed::FField *row = (acr_ed::FField*)field_AllocMem();
    if (row) {
        new (row) acr_ed::FField; // call constructor
        row->rowid = u32(field_N() - 1);
    }
    return row;
}

// --- acr_ed.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FField* acr_ed::field_InsertMaybe(const dmmeta::Field &value) {
    acr_ed::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FField*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u32(n)).~FField();
        _db.field_n = i32(n);
    }
}

// --- acr_ed.FDb.field.InputMaybe
static bool acr_ed::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::field_XrefMaybe(acr_ed::FField &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    acr_ed::FCtype* p_arg = acr_ed::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    acr_ed::FNs* p_ns = acr_ed::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // field: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    return retval;
}

// --- acr_ed.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
acr_ed::FField* acr_ed::ind_field_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    acr_ed::FField* *e = &_db.ind_field_buckets_elems[index];
    acr_ed::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_field.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FField& acr_ed::ind_field_FindX(const algo::strptr& key) {
    acr_ed::FField* ret = ind_field_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_field  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_field_InsertMaybe(acr_ed::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (acr_ed::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr_ed::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            acr_ed::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_field_Remove(acr_ed::FField& row) {
    if (LIKELY(row.ind_field_next != (acr_ed::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr_ed::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (acr_ed::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- acr_ed.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FField*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FField* *new_buckets = (acr_ed::FField**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            acr_ed::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                acr_ed::FField &row        = *elem;
                acr_ed::FField* next       = row.ind_field_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCtype& acr_ed::ctype_Alloc() {
    acr_ed::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCtype* acr_ed::ctype_AllocMaybe() {
    acr_ed::FCtype *row = (acr_ed::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) acr_ed::FCtype; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCtype* acr_ed::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    acr_ed::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(u64(n)).~FCtype();
        _db.ctype_n = i32(n);
    }
}

// --- acr_ed.FDb.ctype.InputMaybe
static bool acr_ed::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ctype_XrefMaybe(acr_ed::FCtype &row) {
    bool retval = true;
    (void)row;
    acr_ed::FNs* p_ns = acr_ed::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // ctype: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
acr_ed::FCtype* acr_ed::ind_ctype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    acr_ed::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    acr_ed::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ctype.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FCtype& acr_ed::ind_ctype_FindX(const algo::strptr& key) {
    acr_ed::FCtype* ret = ind_ctype_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ctype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ctype_InsertMaybe(acr_ed::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (acr_ed::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr_ed::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            acr_ed::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ctype_Remove(acr_ed::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (acr_ed::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr_ed::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (acr_ed::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- acr_ed.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FCtype*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FCtype* *new_buckets = (acr_ed::FCtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            acr_ed::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                acr_ed::FCtype &row        = *elem;
                acr_ed::FCtype* next       = row.ind_ctype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSsimfile& acr_ed::ssimfile_Alloc() {
    acr_ed::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSsimfile* acr_ed::ssimfile_AllocMaybe() {
    acr_ed::FSsimfile *row = (acr_ed::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) acr_ed::FSsimfile; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSsimfile* acr_ed::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    acr_ed::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = i32(n);
    }
}

// --- acr_ed.FDb.ssimfile.InputMaybe
static bool acr_ed::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ssimfile_XrefMaybe(acr_ed::FSsimfile &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        bool success = c_ssimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_ssimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
acr_ed::FSsimfile* acr_ed::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    acr_ed::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    acr_ed::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ssimfile.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FSsimfile& acr_ed::ind_ssimfile_FindX(const algo::strptr& key) {
    acr_ed::FSsimfile* ret = ind_ssimfile_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ssimfile_InsertMaybe(acr_ed::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (acr_ed::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr_ed::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            acr_ed::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ssimfile_Remove(acr_ed::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (acr_ed::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr_ed::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (acr_ed::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- acr_ed.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FSsimfile* *new_buckets = (acr_ed::FSsimfile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            acr_ed::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                acr_ed::FSsimfile &row        = *elem;
                acr_ed::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.cstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCstr& acr_ed::cstr_Alloc() {
    acr_ed::FCstr* row = cstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.cstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.cstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCstr* acr_ed::cstr_AllocMaybe() {
    acr_ed::FCstr *row = (acr_ed::FCstr*)cstr_AllocMem();
    if (row) {
        new (row) acr_ed::FCstr; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.cstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCstr* acr_ed::cstr_InsertMaybe(const dmmeta::Cstr &value) {
    acr_ed::FCstr *row = &cstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cstr_CopyIn(*row,const_cast<dmmeta::Cstr&>(value));
    bool ok = cstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        cstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.cstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::cstr_AllocMem() {
    u64 new_nelems     = _db.cstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cstr_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCstr*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCstr) * (u64(1)<<bsr));
            _db.cstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.cstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::cstr_RemoveLast() {
    u64 n = _db.cstr_n;
    if (n > 0) {
        n -= 1;
        cstr_qFind(u64(n)).~FCstr();
        _db.cstr_n = i32(n);
    }
}

// --- acr_ed.FDb.cstr.InputMaybe
static bool acr_ed::cstr_InputMaybe(dmmeta::Cstr &elem) {
    bool retval = true;
    retval = cstr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.cstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::cstr_XrefMaybe(acr_ed::FCstr &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cstr into index c_cstr
    if (true) { // user-defined insert condition
        bool success = c_cstr_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_cstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.vis.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& acr_ed::vis_Alloc() {
    vis_Reserve(1);
    int n  = _db.vis_n;
    int at = n;
    algo::cstring *elems = _db.vis_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    _db.vis_n = n+1;
    return elems[at];
}

// --- acr_ed.FDb.vis.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& acr_ed::vis_AllocAt(int at) {
    vis_Reserve(1);
    int n  = _db.vis_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("acr_ed.bad_alloc_at  field:acr_ed.FDb.vis  comment:'index out of range'");
    }
    algo::cstring *elems = _db.vis_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    _db.vis_n = n+1;
    return elems[at];
}

// --- acr_ed.FDb.vis.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> acr_ed::vis_AllocN(int n_elems) {
    vis_Reserve(n_elems);
    int old_n  = _db.vis_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = _db.vis_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    _db.vis_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- acr_ed.FDb.vis.Remove
// Remove item by index. If index outside of range, do nothing.
void acr_ed::vis_Remove(u32 i) {
    u32 lim = _db.vis_n;
    algo::cstring *elems = _db.vis_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        _db.vis_n = lim - 1;
    }
}

// --- acr_ed.FDb.vis.RemoveAll
void acr_ed::vis_RemoveAll() {
    u32 n = _db.vis_n;
    while (n > 0) {
        n -= 1;
        _db.vis_elems[n].~cstring();
        _db.vis_n = n;
    }
}

// --- acr_ed.FDb.vis.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::vis_RemoveLast() {
    u64 n = _db.vis_n;
    if (n > 0) {
        n -= 1;
        vis_qFind(u64(n)).~cstring();
        _db.vis_n = n;
    }
}

// --- acr_ed.FDb.vis.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void acr_ed::vis_AbsReserve(int n) {
    u32 old_max  = _db.vis_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(_db.vis_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr_ed.tary_nomem  field:acr_ed.FDb.vis  comment:'out of memory'");
        }
        _db.vis_elems = (algo::cstring*)new_mem;
        _db.vis_max = new_max;
    }
}

// --- acr_ed.FDb.vis.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> acr_ed::vis_AllocNVal(int n_elems, const algo::cstring& val) {
    vis_Reserve(n_elems);
    int old_n  = _db.vis_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = _db.vis_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    _db.vis_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- acr_ed.FDb.listtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FListtype& acr_ed::listtype_Alloc() {
    acr_ed::FListtype* row = listtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.listtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.listtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FListtype* acr_ed::listtype_AllocMaybe() {
    acr_ed::FListtype *row = (acr_ed::FListtype*)listtype_AllocMem();
    if (row) {
        new (row) acr_ed::FListtype; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.listtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FListtype* acr_ed::listtype_InsertMaybe(const dmmeta::Listtype &value) {
    acr_ed::FListtype *row = &listtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    listtype_CopyIn(*row,const_cast<dmmeta::Listtype&>(value));
    bool ok = listtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.listtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::listtype_AllocMem() {
    u64 new_nelems     = _db.listtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FListtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.listtype_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FListtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype) * (u64(1)<<bsr));
            _db.listtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.listtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.listtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::listtype_RemoveLast() {
    u64 n = _db.listtype_n;
    if (n > 0) {
        n -= 1;
        listtype_qFind(u64(n)).~FListtype();
        _db.listtype_n = i32(n);
    }
}

// --- acr_ed.FDb.listtype.InputMaybe
static bool acr_ed::listtype_InputMaybe(dmmeta::Listtype &elem) {
    bool retval = true;
    retval = listtype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.listtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::listtype_XrefMaybe(acr_ed::FListtype &row) {
    bool retval = true;
    (void)row;
    // insert listtype into index ind_listtype
    if (true) { // user-defined insert condition
        bool success = ind_listtype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_listtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_listtype.Find
// Find row by key. Return NULL if not found.
acr_ed::FListtype* acr_ed::ind_listtype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr5_Hash(0, key) & (_db.ind_listtype_buckets_n - 1);
    acr_ed::FListtype* *e = &_db.ind_listtype_buckets_elems[index];
    acr_ed::FListtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).listtype == key;
        if (done) break;
        e         = &ret->ind_listtype_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_listtype.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FListtype& acr_ed::ind_listtype_FindX(const algo::strptr& key) {
    acr_ed::FListtype* ret = ind_listtype_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_listtype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_listtype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FListtype& acr_ed::ind_listtype_GetOrCreate(const algo::strptr& key) {
    acr_ed::FListtype* ret = ind_listtype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &listtype_Alloc();
        (*ret).listtype = key;
        bool good = listtype_XrefMaybe(*ret);
        if (!good) {
            listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr_ed.create_error  table:ind_listtype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr_ed.FDb.ind_listtype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_listtype_InsertMaybe(acr_ed::FListtype& row) {
    ind_listtype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_listtype_next == (acr_ed::FListtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        acr_ed::FListtype* *prev = &_db.ind_listtype_buckets_elems[index];
        do {
            acr_ed::FListtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).listtype == row.listtype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_listtype_next;
        } while (true);
        if (retval) {
            row.ind_listtype_next = *prev;
            _db.ind_listtype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_listtype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_listtype_Remove(acr_ed::FListtype& row) {
    if (LIKELY(row.ind_listtype_next != (acr_ed::FListtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        acr_ed::FListtype* *prev = &_db.ind_listtype_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FListtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_listtype_next; // unlink (singly linked list)
                _db.ind_listtype_n--;
                row.ind_listtype_next = (acr_ed::FListtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_listtype_next;
        }
    }
}

// --- acr_ed.FDb.ind_listtype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_listtype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_listtype_buckets_n;
    u32 new_nelems   = _db.ind_listtype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FListtype*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FListtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FListtype* *new_buckets = (acr_ed::FListtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_listtype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_listtype_buckets_n; i++) {
            acr_ed::FListtype* elem = _db.ind_listtype_buckets_elems[i];
            while (elem) {
                acr_ed::FListtype &row        = *elem;
                acr_ed::FListtype* next       = row.ind_listtype_next;
                u32 index          = algo::Smallstr5_Hash(0, row.listtype) & (new_nbuckets-1);
                row.ind_listtype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_listtype_buckets_elems, old_size);
        _db.ind_listtype_buckets_elems = new_buckets;
        _db.ind_listtype_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.fprefix.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FFprefix& acr_ed::fprefix_Alloc() {
    acr_ed::FFprefix* row = fprefix_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.fprefix  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.fprefix.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FFprefix* acr_ed::fprefix_AllocMaybe() {
    acr_ed::FFprefix *row = (acr_ed::FFprefix*)fprefix_AllocMem();
    if (row) {
        new (row) acr_ed::FFprefix; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.fprefix.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FFprefix* acr_ed::fprefix_InsertMaybe(const dmmeta::Fprefix &value) {
    acr_ed::FFprefix *row = &fprefix_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fprefix_CopyIn(*row,const_cast<dmmeta::Fprefix&>(value));
    bool ok = fprefix_XrefMaybe(*row); // this may return false
    if (!ok) {
        fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.fprefix.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::fprefix_AllocMem() {
    u64 new_nelems     = _db.fprefix_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FFprefix*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fprefix_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FFprefix*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix) * (u64(1)<<bsr));
            _db.fprefix_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fprefix_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.fprefix.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::fprefix_RemoveLast() {
    u64 n = _db.fprefix_n;
    if (n > 0) {
        n -= 1;
        fprefix_qFind(u64(n)).~FFprefix();
        _db.fprefix_n = i32(n);
    }
}

// --- acr_ed.FDb.fprefix.InputMaybe
static bool acr_ed::fprefix_InputMaybe(dmmeta::Fprefix &elem) {
    bool retval = true;
    retval = fprefix_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.fprefix.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::fprefix_XrefMaybe(acr_ed::FFprefix &row) {
    bool retval = true;
    (void)row;
    // insert fprefix into index ind_fprefix
    if (true) { // user-defined insert condition
        bool success = ind_fprefix_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_fprefix"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_fprefix.Find
// Find row by key. Return NULL if not found.
acr_ed::FFprefix* acr_ed::ind_fprefix_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr5_Hash(0, key) & (_db.ind_fprefix_buckets_n - 1);
    acr_ed::FFprefix* *e = &_db.ind_fprefix_buckets_elems[index];
    acr_ed::FFprefix* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fprefix == key;
        if (done) break;
        e         = &ret->ind_fprefix_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_fprefix.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FFprefix& acr_ed::ind_fprefix_FindX(const algo::strptr& key) {
    acr_ed::FFprefix* ret = ind_fprefix_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_fprefix  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_fprefix.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FFprefix& acr_ed::ind_fprefix_GetOrCreate(const algo::strptr& key) {
    acr_ed::FFprefix* ret = ind_fprefix_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fprefix_Alloc();
        (*ret).fprefix = key;
        bool good = fprefix_XrefMaybe(*ret);
        if (!good) {
            fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr_ed.create_error  table:ind_fprefix  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr_ed.FDb.ind_fprefix.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_fprefix_InsertMaybe(acr_ed::FFprefix& row) {
    ind_fprefix_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fprefix_next == (acr_ed::FFprefix*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.fprefix) & (_db.ind_fprefix_buckets_n - 1);
        acr_ed::FFprefix* *prev = &_db.ind_fprefix_buckets_elems[index];
        do {
            acr_ed::FFprefix* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fprefix == row.fprefix) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fprefix_next;
        } while (true);
        if (retval) {
            row.ind_fprefix_next = *prev;
            _db.ind_fprefix_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_fprefix.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_fprefix_Remove(acr_ed::FFprefix& row) {
    if (LIKELY(row.ind_fprefix_next != (acr_ed::FFprefix*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.fprefix) & (_db.ind_fprefix_buckets_n - 1);
        acr_ed::FFprefix* *prev = &_db.ind_fprefix_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FFprefix *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fprefix_next; // unlink (singly linked list)
                _db.ind_fprefix_n--;
                row.ind_fprefix_next = (acr_ed::FFprefix*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fprefix_next;
        }
    }
}

// --- acr_ed.FDb.ind_fprefix.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_fprefix_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fprefix_buckets_n;
    u32 new_nelems   = _db.ind_fprefix_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FFprefix*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FFprefix*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FFprefix* *new_buckets = (acr_ed::FFprefix**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_fprefix");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fprefix_buckets_n; i++) {
            acr_ed::FFprefix* elem = _db.ind_fprefix_buckets_elems[i];
            while (elem) {
                acr_ed::FFprefix &row        = *elem;
                acr_ed::FFprefix* next       = row.ind_fprefix_next;
                u32 index          = algo::Smallstr5_Hash(0, row.fprefix) & (new_nbuckets-1);
                row.ind_fprefix_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_fprefix_buckets_elems, old_size);
        _db.ind_fprefix_buckets_elems = new_buckets;
        _db.ind_fprefix_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.target.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTarget& acr_ed::target_Alloc() {
    acr_ed::FTarget* row = target_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.target  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.target.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTarget* acr_ed::target_AllocMaybe() {
    acr_ed::FTarget *row = (acr_ed::FTarget*)target_AllocMem();
    if (row) {
        new (row) acr_ed::FTarget; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.target.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTarget* acr_ed::target_InsertMaybe(const dev::Target &value) {
    acr_ed::FTarget *row = &target_Alloc(); // if out of memory, process dies. if input error, return NULL.
    target_CopyIn(*row,const_cast<dev::Target&>(value));
    bool ok = target_XrefMaybe(*row); // this may return false
    if (!ok) {
        target_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.target.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::target_AllocMem() {
    u64 new_nelems     = _db.target_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FTarget*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.target_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FTarget*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget) * (u64(1)<<bsr));
            _db.target_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.target_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.target.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::target_RemoveLast() {
    u64 n = _db.target_n;
    if (n > 0) {
        n -= 1;
        target_qFind(u64(n)).~FTarget();
        _db.target_n = i32(n);
    }
}

// --- acr_ed.FDb.target.InputMaybe
static bool acr_ed::target_InputMaybe(dev::Target &elem) {
    bool retval = true;
    retval = target_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.target.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::target_XrefMaybe(acr_ed::FTarget &row) {
    bool retval = true;
    (void)row;
    // insert target into index ind_target
    if (true) { // user-defined insert condition
        bool success = ind_target_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_target"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_target.Find
// Find row by key. Return NULL if not found.
acr_ed::FTarget* acr_ed::ind_target_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_target_buckets_n - 1);
    acr_ed::FTarget* *e = &_db.ind_target_buckets_elems[index];
    acr_ed::FTarget* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).target == key;
        if (done) break;
        e         = &ret->ind_target_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_target.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FTarget& acr_ed::ind_target_FindX(const algo::strptr& key) {
    acr_ed::FTarget* ret = ind_target_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_target  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_target.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FTarget& acr_ed::ind_target_GetOrCreate(const algo::strptr& key) {
    acr_ed::FTarget* ret = ind_target_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &target_Alloc();
        (*ret).target = key;
        bool good = target_XrefMaybe(*ret);
        if (!good) {
            target_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr_ed.create_error  table:ind_target  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr_ed.FDb.ind_target.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_target_InsertMaybe(acr_ed::FTarget& row) {
    ind_target_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_target_next == (acr_ed::FTarget*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        acr_ed::FTarget* *prev = &_db.ind_target_buckets_elems[index];
        do {
            acr_ed::FTarget* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).target == row.target) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_target_next;
        } while (true);
        if (retval) {
            row.ind_target_next = *prev;
            _db.ind_target_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_target.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_target_Remove(acr_ed::FTarget& row) {
    if (LIKELY(row.ind_target_next != (acr_ed::FTarget*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        acr_ed::FTarget* *prev = &_db.ind_target_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FTarget *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_target_next; // unlink (singly linked list)
                _db.ind_target_n--;
                row.ind_target_next = (acr_ed::FTarget*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_target_next;
        }
    }
}

// --- acr_ed.FDb.ind_target.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_target_Reserve(int n) {
    u32 old_nbuckets = _db.ind_target_buckets_n;
    u32 new_nelems   = _db.ind_target_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FTarget*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FTarget*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FTarget* *new_buckets = (acr_ed::FTarget**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_target");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_target_buckets_n; i++) {
            acr_ed::FTarget* elem = _db.ind_target_buckets_elems[i];
            while (elem) {
                acr_ed::FTarget &row        = *elem;
                acr_ed::FTarget* next       = row.ind_target_next;
                u32 index          = algo::Smallstr16_Hash(0, row.target) & (new_nbuckets-1);
                row.ind_target_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_target_buckets_elems, old_size);
        _db.ind_target_buckets_elems = new_buckets;
        _db.ind_target_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.targsrc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTargsrc& acr_ed::targsrc_Alloc() {
    acr_ed::FTargsrc* row = targsrc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.targsrc  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.targsrc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTargsrc* acr_ed::targsrc_AllocMaybe() {
    acr_ed::FTargsrc *row = (acr_ed::FTargsrc*)targsrc_AllocMem();
    if (row) {
        new (row) acr_ed::FTargsrc; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.targsrc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTargsrc* acr_ed::targsrc_InsertMaybe(const dev::Targsrc &value) {
    acr_ed::FTargsrc *row = &targsrc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targsrc_CopyIn(*row,const_cast<dev::Targsrc&>(value));
    bool ok = targsrc_XrefMaybe(*row); // this may return false
    if (!ok) {
        targsrc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.targsrc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::targsrc_AllocMem() {
    u64 new_nelems     = _db.targsrc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FTargsrc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targsrc_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FTargsrc*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTargsrc) * (u64(1)<<bsr));
            _db.targsrc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targsrc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.targsrc.RemoveAll
// Remove all elements from Lary
void acr_ed::targsrc_RemoveAll() {
    for (u64 n = _db.targsrc_n; n>0; ) {
        n--;
        targsrc_qFind(u64(n)).~FTargsrc(); // destroy last element
        _db.targsrc_n = i32(n);
    }
}

// --- acr_ed.FDb.targsrc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::targsrc_RemoveLast() {
    u64 n = _db.targsrc_n;
    if (n > 0) {
        n -= 1;
        targsrc_qFind(u64(n)).~FTargsrc();
        _db.targsrc_n = i32(n);
    }
}

// --- acr_ed.FDb.targsrc.InputMaybe
static bool acr_ed::targsrc_InputMaybe(dev::Targsrc &elem) {
    bool retval = true;
    retval = targsrc_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.targsrc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::targsrc_XrefMaybe(acr_ed::FTargsrc &row) {
    bool retval = true;
    (void)row;
    acr_ed::FTarget* p_target = acr_ed::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // targsrc: save pointer to target
    if (true) { // user-defined insert condition
        row.p_target = p_target;
    }
    return retval;
}

// --- acr_ed.FDb.abt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int acr_ed::abt_Start() {
    int retval = 0;
    if (_db.abt_pid == 0) {
        verblog(abt_ToCmdline()); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(_db.abt_path);
        tempstr cmdline(abt_ToCmdline());
        _db.abt_pid = dospawn(Zeroterm(_db.abt_path),Zeroterm(cmdline),_db.abt_timeout,_db.abt_fstdin,_db.abt_fstdout,_db.abt_fstderr);
#else
        _db.abt_pid = fork();
        if (_db.abt_pid == 0) { // child
            algo_lib::DieWithParent();
            if (_db.abt_timeout > 0) {
                alarm(_db.abt_timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(_db.abt_fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(_db.abt_fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(_db.abt_fstderr, 2);
            if (retval==0) retval= abt_Execv();
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("acr_ed.abt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (_db.abt_pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    _db.abt_status = _db.abt_pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- acr_ed.FDb.abt.StartRead
// Start subprocess & Read output
algo::Fildes acr_ed::abt_StartRead(algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    _db.abt_fstdout  << ">&" << pipefd[1];
    abt_Start();
    (void)close(pipefd[1]);
    return read.fd;
}

// --- acr_ed.FDb.abt.Kill
// Kill subprocess and wait
void acr_ed::abt_Kill() {
    if (_db.abt_pid != 0) {
        kill(_db.abt_pid,9);
        abt_Wait();
    }
}

// --- acr_ed.FDb.abt.Wait
// Wait for subprocess to return
void acr_ed::abt_Wait() {
    if (_db.abt_pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(_db.abt_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == _db.abt_pid) {
            _db.abt_status = wait_status;
            _db.abt_pid = 0;
        }
    }
}

// --- acr_ed.FDb.abt.Exec
// Start + Wait
// Execute subprocess and return exit code
int acr_ed::abt_Exec() {
    abt_Start();
    abt_Wait();
    return _db.abt_status;
}

// --- acr_ed.FDb.abt.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void acr_ed::abt_ExecX() {
    int rc = abt_Exec();
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",abt_ToCmdline())
    << Keyval("comment",algo::DescribeWaitStatus(_db.abt_status)));
}

// --- acr_ed.FDb.abt.Execv
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int acr_ed::abt_Execv() {
    algo_lib::exec_args_Alloc() << _db.abt_path;

    if (_db.abt_cmd.target.expr != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-target:";
        command::target_Print(_db.abt_cmd, *arg);
    }

    if (_db.abt_cmd.in != "data") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-in:";
        cstring_Print(_db.abt_cmd.in, *arg);
    }

    if (_db.abt_cmd.out_dir != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-out_dir:";
        cstring_Print(_db.abt_cmd.out_dir, *arg);
    }

    if (_db.abt_cmd.cfg != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-cfg:";
        Smallstr50_Print(_db.abt_cmd.cfg, *arg);
    }

    if (_db.abt_cmd.compiler != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-compiler:";
        Smallstr50_Print(_db.abt_cmd.compiler, *arg);
    }

    if (_db.abt_cmd.uname != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-uname:";
        Smallstr50_Print(_db.abt_cmd.uname, *arg);
    }

    if (_db.abt_cmd.arch != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-arch:";
        Smallstr50_Print(_db.abt_cmd.arch, *arg);
    }

    if (_db.abt_cmd.ood != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-ood:";
        bool_Print(_db.abt_cmd.ood, *arg);
    }

    if (_db.abt_cmd.list != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-list:";
        bool_Print(_db.abt_cmd.list, *arg);
    }

    if (_db.abt_cmd.listincl != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-listincl:";
        bool_Print(_db.abt_cmd.listincl, *arg);
    }

    if (_db.abt_cmd.build != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-build:";
        bool_Print(_db.abt_cmd.build, *arg);
    }

    if (_db.abt_cmd.preproc != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-preproc:";
        bool_Print(_db.abt_cmd.preproc, *arg);
    }

    if (_db.abt_cmd.clean != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-clean:";
        bool_Print(_db.abt_cmd.clean, *arg);
    }

    if (_db.abt_cmd.dry_run != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-dry_run:";
        bool_Print(_db.abt_cmd.dry_run, *arg);
    }

    if (_db.abt_cmd.maxjobs != 0) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-maxjobs:";
        i32_Print(_db.abt_cmd.maxjobs, *arg);
    }

    if (_db.abt_cmd.printcmd != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-printcmd:";
        bool_Print(_db.abt_cmd.printcmd, *arg);
    }

    if (_db.abt_cmd.force != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-force:";
        bool_Print(_db.abt_cmd.force, *arg);
    }

    if (_db.abt_cmd.install != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-install:";
        bool_Print(_db.abt_cmd.install, *arg);
    }

    if (_db.abt_cmd.coverity != false) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-coverity:";
        bool_Print(_db.abt_cmd.coverity, *arg);
    }

    if (_db.abt_cmd.package != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-package:";
        cstring_Print(_db.abt_cmd.package, *arg);
    }

    if (_db.abt_cmd.maxerr != 100) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-maxerr:";
        u32_Print(_db.abt_cmd.maxerr, *arg);
    }

    if (_db.abt_cmd.disas.expr != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-disas:";
        command::disas_Print(_db.abt_cmd, *arg);
    }

    if (_db.abt_cmd.report != true) {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-report:";
        bool_Print(_db.abt_cmd.report, *arg);
    }

    if (_db.abt_cmd.jcdb != "") {
        cstring *arg = &algo_lib::exec_args_Alloc();
        *arg << "-jcdb:";
        cstring_Print(_db.abt_cmd.jcdb, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        algo_lib::exec_args_Alloc() << "-verbose";
    }
    char **argv = (char**)alloca((algo_lib::exec_args_N()+1)*sizeof(*argv));
    ind_beg(algo_lib::_db_exec_args_curs,arg,algo_lib::_db) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[algo_lib::exec_args_N()] = NULL;
    // if _db.abt_path is relative, search for it in PATH
    algo_lib::ResolveExecFname(_db.abt_path);
    return execv(Zeroterm(_db.abt_path),argv);
}

// --- acr_ed.FDb.abt.ToCmdline
algo::tempstr acr_ed::abt_ToCmdline() {
    algo::tempstr retval;
    retval << _db.abt_path << " ";
    command::abt_PrintArgv(_db.abt_cmd,retval);
    if (ch_N(_db.abt_fstdin)) {
        retval << " " << _db.abt_fstdin;
    }
    if (ch_N(_db.abt_fstdout)) {
        retval << " " << _db.abt_fstdout;
    }
    if (ch_N(_db.abt_fstderr)) {
        retval << " 2" << _db.abt_fstderr;
    }
    return retval;
}

// --- acr_ed.FDb.sbpath.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSbpath& acr_ed::sbpath_Alloc() {
    acr_ed::FSbpath* row = sbpath_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.sbpath  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.sbpath.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSbpath* acr_ed::sbpath_AllocMaybe() {
    acr_ed::FSbpath *row = (acr_ed::FSbpath*)sbpath_AllocMem();
    if (row) {
        new (row) acr_ed::FSbpath; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.sbpath.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSbpath* acr_ed::sbpath_InsertMaybe(const dev::Sbpath &value) {
    acr_ed::FSbpath *row = &sbpath_Alloc(); // if out of memory, process dies. if input error, return NULL.
    sbpath_CopyIn(*row,const_cast<dev::Sbpath&>(value));
    bool ok = sbpath_XrefMaybe(*row); // this may return false
    if (!ok) {
        sbpath_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.sbpath.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::sbpath_AllocMem() {
    u64 new_nelems     = _db.sbpath_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FSbpath*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.sbpath_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FSbpath*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSbpath) * (u64(1)<<bsr));
            _db.sbpath_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.sbpath_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.sbpath.RemoveAll
// Remove all elements from Lary
void acr_ed::sbpath_RemoveAll() {
    for (u64 n = _db.sbpath_n; n>0; ) {
        n--;
        sbpath_qFind(u64(n)).~FSbpath(); // destroy last element
        _db.sbpath_n = i32(n);
    }
}

// --- acr_ed.FDb.sbpath.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::sbpath_RemoveLast() {
    u64 n = _db.sbpath_n;
    if (n > 0) {
        n -= 1;
        sbpath_qFind(u64(n)).~FSbpath();
        _db.sbpath_n = i32(n);
    }
}

// --- acr_ed.FDb.sbpath.InputMaybe
static bool acr_ed::sbpath_InputMaybe(dev::Sbpath &elem) {
    bool retval = true;
    retval = sbpath_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.sbpath.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::sbpath_XrefMaybe(acr_ed::FSbpath &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- acr_ed.FDb.pack.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FPack& acr_ed::pack_Alloc() {
    acr_ed::FPack* row = pack_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.pack  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.pack.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FPack* acr_ed::pack_AllocMaybe() {
    acr_ed::FPack *row = (acr_ed::FPack*)pack_AllocMem();
    if (row) {
        new (row) acr_ed::FPack; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.pack.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FPack* acr_ed::pack_InsertMaybe(const dmmeta::Pack &value) {
    acr_ed::FPack *row = &pack_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pack_CopyIn(*row,const_cast<dmmeta::Pack&>(value));
    bool ok = pack_XrefMaybe(*row); // this may return false
    if (!ok) {
        pack_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.pack.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::pack_AllocMem() {
    u64 new_nelems     = _db.pack_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FPack*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pack_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FPack*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FPack) * (u64(1)<<bsr));
            _db.pack_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pack_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.pack.RemoveAll
// Remove all elements from Lary
void acr_ed::pack_RemoveAll() {
    for (u64 n = _db.pack_n; n>0; ) {
        n--;
        pack_qFind(u64(n)).~FPack(); // destroy last element
        _db.pack_n = i32(n);
    }
}

// --- acr_ed.FDb.pack.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::pack_RemoveLast() {
    u64 n = _db.pack_n;
    if (n > 0) {
        n -= 1;
        pack_qFind(u64(n)).~FPack();
        _db.pack_n = i32(n);
    }
}

// --- acr_ed.FDb.pack.InputMaybe
static bool acr_ed::pack_InputMaybe(dmmeta::Pack &elem) {
    bool retval = true;
    retval = pack_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.pack.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::pack_XrefMaybe(acr_ed::FPack &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert pack into index c_pack
    if (true) { // user-defined insert condition
        bool success = c_pack_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_pack"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.typefld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTypefld& acr_ed::typefld_Alloc() {
    acr_ed::FTypefld* row = typefld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.typefld  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.typefld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTypefld* acr_ed::typefld_AllocMaybe() {
    acr_ed::FTypefld *row = (acr_ed::FTypefld*)typefld_AllocMem();
    if (row) {
        new (row) acr_ed::FTypefld; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.typefld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTypefld* acr_ed::typefld_InsertMaybe(const dmmeta::Typefld &value) {
    acr_ed::FTypefld *row = &typefld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typefld_CopyIn(*row,const_cast<dmmeta::Typefld&>(value));
    bool ok = typefld_XrefMaybe(*row); // this may return false
    if (!ok) {
        typefld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.typefld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::typefld_AllocMem() {
    u64 new_nelems     = _db.typefld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FTypefld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.typefld_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FTypefld*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTypefld) * (u64(1)<<bsr));
            _db.typefld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.typefld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.typefld.RemoveAll
// Remove all elements from Lary
void acr_ed::typefld_RemoveAll() {
    for (u64 n = _db.typefld_n; n>0; ) {
        n--;
        typefld_qFind(u64(n)).~FTypefld(); // destroy last element
        _db.typefld_n = i32(n);
    }
}

// --- acr_ed.FDb.typefld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::typefld_RemoveLast() {
    u64 n = _db.typefld_n;
    if (n > 0) {
        n -= 1;
        typefld_qFind(u64(n)).~FTypefld();
        _db.typefld_n = i32(n);
    }
}

// --- acr_ed.FDb.typefld.InputMaybe
static bool acr_ed::typefld_InputMaybe(dmmeta::Typefld &elem) {
    bool retval = true;
    retval = typefld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.typefld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::typefld_XrefMaybe(acr_ed::FTypefld &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert typefld into index c_typefld
    if (true) { // user-defined insert condition
        bool success = c_typefld_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_typefld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.cpptype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCpptype& acr_ed::cpptype_Alloc() {
    acr_ed::FCpptype* row = cpptype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.cpptype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.cpptype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCpptype* acr_ed::cpptype_AllocMaybe() {
    acr_ed::FCpptype *row = (acr_ed::FCpptype*)cpptype_AllocMem();
    if (row) {
        new (row) acr_ed::FCpptype; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.cpptype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCpptype* acr_ed::cpptype_InsertMaybe(const dmmeta::Cpptype &value) {
    acr_ed::FCpptype *row = &cpptype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cpptype_CopyIn(*row,const_cast<dmmeta::Cpptype&>(value));
    bool ok = cpptype_XrefMaybe(*row); // this may return false
    if (!ok) {
        cpptype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.cpptype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::cpptype_AllocMem() {
    u64 new_nelems     = _db.cpptype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCpptype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cpptype_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCpptype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCpptype) * (u64(1)<<bsr));
            _db.cpptype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cpptype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.cpptype.RemoveAll
// Remove all elements from Lary
void acr_ed::cpptype_RemoveAll() {
    for (u64 n = _db.cpptype_n; n>0; ) {
        n--;
        cpptype_qFind(u64(n)).~FCpptype(); // destroy last element
        _db.cpptype_n = i32(n);
    }
}

// --- acr_ed.FDb.cpptype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::cpptype_RemoveLast() {
    u64 n = _db.cpptype_n;
    if (n > 0) {
        n -= 1;
        cpptype_qFind(u64(n)).~FCpptype();
        _db.cpptype_n = i32(n);
    }
}

// --- acr_ed.FDb.cpptype.InputMaybe
static bool acr_ed::cpptype_InputMaybe(dmmeta::Cpptype &elem) {
    bool retval = true;
    retval = cpptype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.cpptype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::cpptype_XrefMaybe(acr_ed::FCpptype &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cpptype into index c_cpptype
    if (true) { // user-defined insert condition
        bool success = c_cpptype_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_cpptype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.cfmt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCfmt& acr_ed::cfmt_Alloc() {
    acr_ed::FCfmt* row = cfmt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.cfmt  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.cfmt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCfmt* acr_ed::cfmt_AllocMaybe() {
    acr_ed::FCfmt *row = (acr_ed::FCfmt*)cfmt_AllocMem();
    if (row) {
        new (row) acr_ed::FCfmt; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.cfmt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCfmt* acr_ed::cfmt_InsertMaybe(const dmmeta::Cfmt &value) {
    acr_ed::FCfmt *row = &cfmt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cfmt_CopyIn(*row,const_cast<dmmeta::Cfmt&>(value));
    bool ok = cfmt_XrefMaybe(*row); // this may return false
    if (!ok) {
        cfmt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.cfmt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::cfmt_AllocMem() {
    u64 new_nelems     = _db.cfmt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCfmt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cfmt_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCfmt*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCfmt) * (u64(1)<<bsr));
            _db.cfmt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cfmt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.cfmt.RemoveAll
// Remove all elements from Lary
void acr_ed::cfmt_RemoveAll() {
    for (u64 n = _db.cfmt_n; n>0; ) {
        n--;
        cfmt_qFind(u64(n)).~FCfmt(); // destroy last element
        _db.cfmt_n = i32(n);
    }
}

// --- acr_ed.FDb.cfmt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::cfmt_RemoveLast() {
    u64 n = _db.cfmt_n;
    if (n > 0) {
        n -= 1;
        cfmt_qFind(u64(n)).~FCfmt();
        _db.cfmt_n = i32(n);
    }
}

// --- acr_ed.FDb.cfmt.InputMaybe
static bool acr_ed::cfmt_InputMaybe(dmmeta::Cfmt &elem) {
    bool retval = true;
    retval = cfmt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.cfmt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::cfmt_XrefMaybe(acr_ed::FCfmt &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert cfmt into index c_cfmt
    if (true) { // user-defined insert condition
        c_cfmt_Insert(*p_ctype, row);
    }
    return retval;
}

// --- acr_ed.FDb.nsdb.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNsdb& acr_ed::nsdb_Alloc() {
    acr_ed::FNsdb* row = nsdb_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.nsdb  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.nsdb.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNsdb* acr_ed::nsdb_AllocMaybe() {
    acr_ed::FNsdb *row = (acr_ed::FNsdb*)nsdb_AllocMem();
    if (row) {
        new (row) acr_ed::FNsdb; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.nsdb.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNsdb* acr_ed::nsdb_InsertMaybe(const dmmeta::Nsdb &value) {
    acr_ed::FNsdb *row = &nsdb_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nsdb_CopyIn(*row,const_cast<dmmeta::Nsdb&>(value));
    bool ok = nsdb_XrefMaybe(*row); // this may return false
    if (!ok) {
        nsdb_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.nsdb.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::nsdb_AllocMem() {
    u64 new_nelems     = _db.nsdb_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FNsdb*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nsdb_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FNsdb*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNsdb) * (u64(1)<<bsr));
            _db.nsdb_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nsdb_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.nsdb.RemoveAll
// Remove all elements from Lary
void acr_ed::nsdb_RemoveAll() {
    for (u64 n = _db.nsdb_n; n>0; ) {
        n--;
        nsdb_qFind(u64(n)).~FNsdb(); // destroy last element
        _db.nsdb_n = i32(n);
    }
}

// --- acr_ed.FDb.nsdb.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::nsdb_RemoveLast() {
    u64 n = _db.nsdb_n;
    if (n > 0) {
        n -= 1;
        nsdb_qFind(u64(n)).~FNsdb();
        _db.nsdb_n = i32(n);
    }
}

// --- acr_ed.FDb.nsdb.InputMaybe
static bool acr_ed::nsdb_InputMaybe(dmmeta::Nsdb &elem) {
    bool retval = true;
    retval = nsdb_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- acr_ed.FDb.nsdb.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::nsdb_XrefMaybe(acr_ed::FNsdb &row) {
    bool retval = true;
    (void)row;
    // insert nsdb into index ind_nsdb
    if (true) { // user-defined insert condition
        bool success = ind_nsdb_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_nsdb"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_nsdb.Find
// Find row by key. Return NULL if not found.
acr_ed::FNsdb* acr_ed::ind_nsdb_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_nsdb_buckets_n - 1);
    acr_ed::FNsdb* *e = &_db.ind_nsdb_buckets_elems[index];
    acr_ed::FNsdb* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_nsdb_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_nsdb.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNsdb& acr_ed::ind_nsdb_FindX(const algo::strptr& key) {
    acr_ed::FNsdb* ret = ind_nsdb_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_nsdb  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_nsdb.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNsdb& acr_ed::ind_nsdb_GetOrCreate(const algo::strptr& key) {
    acr_ed::FNsdb* ret = ind_nsdb_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &nsdb_Alloc();
        (*ret).ns = key;
        bool good = nsdb_XrefMaybe(*ret);
        if (!good) {
            nsdb_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "acr_ed.create_error  table:ind_nsdb  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- acr_ed.FDb.ind_nsdb.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_nsdb_InsertMaybe(acr_ed::FNsdb& row) {
    ind_nsdb_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_nsdb_next == (acr_ed::FNsdb*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_nsdb_buckets_n - 1);
        acr_ed::FNsdb* *prev = &_db.ind_nsdb_buckets_elems[index];
        do {
            acr_ed::FNsdb* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_nsdb_next;
        } while (true);
        if (retval) {
            row.ind_nsdb_next = *prev;
            _db.ind_nsdb_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_nsdb.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_nsdb_Remove(acr_ed::FNsdb& row) {
    if (LIKELY(row.ind_nsdb_next != (acr_ed::FNsdb*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_nsdb_buckets_n - 1);
        acr_ed::FNsdb* *prev = &_db.ind_nsdb_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FNsdb *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_nsdb_next; // unlink (singly linked list)
                _db.ind_nsdb_n--;
                row.ind_nsdb_next = (acr_ed::FNsdb*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_nsdb_next;
        }
    }
}

// --- acr_ed.FDb.ind_nsdb.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_nsdb_Reserve(int n) {
    u32 old_nbuckets = _db.ind_nsdb_buckets_n;
    u32 new_nelems   = _db.ind_nsdb_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FNsdb*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FNsdb*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FNsdb* *new_buckets = (acr_ed::FNsdb**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_nsdb");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_nsdb_buckets_n; i++) {
            acr_ed::FNsdb* elem = _db.ind_nsdb_buckets_elems[i];
            while (elem) {
                acr_ed::FNsdb &row        = *elem;
                acr_ed::FNsdb* next       = row.ind_nsdb_next;
                u32 index          = algo::Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_nsdb_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_nsdb_buckets_elems, old_size);
        _db.ind_nsdb_buckets_elems = new_buckets;
        _db.ind_nsdb_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr acr_ed::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- acr_ed.FDb.trace.N
// Function return 1
inline static i32 acr_ed::trace_N() {
    return 1;
}

// --- acr_ed.FDb..Init
// Set all fields to initial values.
void acr_ed::FDb_Init() {
    // initialize LAry ns (acr_ed.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    acr_ed::FNs* ns_first = (acr_ed::FNs*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FNs;
    _db.ind_ns_n             	= 0; // (acr_ed.FDb.ind_ns)
    _db.ind_ns_buckets_n     	= 4; // (acr_ed.FDb.ind_ns)
    _db.ind_ns_buckets_elems 	= (acr_ed::FNs**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs*)*_db.ind_ns_buckets_n); // initial buckets (acr_ed.FDb.ind_ns)
    if (!_db.ind_ns_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ns)
    }
    memset(_db.ind_ns_buckets_elems, 0, sizeof(acr_ed::FNs*)*_db.ind_ns_buckets_n); // (acr_ed.FDb.ind_ns)
    // initialize LAry field (acr_ed.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    acr_ed::FField* field_first = (acr_ed::FField*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FField;
    _db.ind_field_n             	= 0; // (acr_ed.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (acr_ed.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (acr_ed::FField**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField*)*_db.ind_field_buckets_n); // initial buckets (acr_ed.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(acr_ed::FField*)*_db.ind_field_buckets_n); // (acr_ed.FDb.ind_field)
    // initialize LAry ctype (acr_ed.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    acr_ed::FCtype* ctype_first = (acr_ed::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FCtype;
    _db.ind_ctype_n             	= 0; // (acr_ed.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (acr_ed.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (acr_ed::FCtype**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (acr_ed.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(acr_ed::FCtype*)*_db.ind_ctype_buckets_n); // (acr_ed.FDb.ind_ctype)
    // initialize LAry ssimfile (acr_ed.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    acr_ed::FSsimfile* ssimfile_first = (acr_ed::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (acr_ed.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (acr_ed.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (acr_ed::FSsimfile**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (acr_ed.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(acr_ed::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (acr_ed.FDb.ind_ssimfile)
    // initialize LAry cstr (acr_ed.FDb.cstr)
    _db.cstr_n = 0;
    memset(_db.cstr_lary, 0, sizeof(_db.cstr_lary)); // zero out all level pointers
    acr_ed::FCstr* cstr_first = (acr_ed::FCstr*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCstr) * (u64(1)<<4));
    if (!cstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cstr_lary[i]  = cstr_first;
        cstr_first    += 1ULL<<i;
    }
    _db.vis_elems 	= 0; // (acr_ed.FDb.vis)
    _db.vis_n     	= 0; // (acr_ed.FDb.vis)
    _db.vis_max   	= 0; // (acr_ed.FDb.vis)
    // initialize LAry listtype (acr_ed.FDb.listtype)
    _db.listtype_n = 0;
    memset(_db.listtype_lary, 0, sizeof(_db.listtype_lary)); // zero out all level pointers
    acr_ed::FListtype* listtype_first = (acr_ed::FListtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype) * (u64(1)<<4));
    if (!listtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.listtype_lary[i]  = listtype_first;
        listtype_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FListtype;
    _db.ind_listtype_n             	= 0; // (acr_ed.FDb.ind_listtype)
    _db.ind_listtype_buckets_n     	= 4; // (acr_ed.FDb.ind_listtype)
    _db.ind_listtype_buckets_elems 	= (acr_ed::FListtype**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype*)*_db.ind_listtype_buckets_n); // initial buckets (acr_ed.FDb.ind_listtype)
    if (!_db.ind_listtype_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_listtype)
    }
    memset(_db.ind_listtype_buckets_elems, 0, sizeof(acr_ed::FListtype*)*_db.ind_listtype_buckets_n); // (acr_ed.FDb.ind_listtype)
    // initialize LAry fprefix (acr_ed.FDb.fprefix)
    _db.fprefix_n = 0;
    memset(_db.fprefix_lary, 0, sizeof(_db.fprefix_lary)); // zero out all level pointers
    acr_ed::FFprefix* fprefix_first = (acr_ed::FFprefix*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix) * (u64(1)<<4));
    if (!fprefix_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fprefix_lary[i]  = fprefix_first;
        fprefix_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FFprefix;
    _db.ind_fprefix_n             	= 0; // (acr_ed.FDb.ind_fprefix)
    _db.ind_fprefix_buckets_n     	= 4; // (acr_ed.FDb.ind_fprefix)
    _db.ind_fprefix_buckets_elems 	= (acr_ed::FFprefix**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix*)*_db.ind_fprefix_buckets_n); // initial buckets (acr_ed.FDb.ind_fprefix)
    if (!_db.ind_fprefix_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_fprefix)
    }
    memset(_db.ind_fprefix_buckets_elems, 0, sizeof(acr_ed::FFprefix*)*_db.ind_fprefix_buckets_n); // (acr_ed.FDb.ind_fprefix)
    // initialize LAry target (acr_ed.FDb.target)
    _db.target_n = 0;
    memset(_db.target_lary, 0, sizeof(_db.target_lary)); // zero out all level pointers
    acr_ed::FTarget* target_first = (acr_ed::FTarget*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget) * (u64(1)<<4));
    if (!target_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.target_lary[i]  = target_first;
        target_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FTarget;
    _db.ind_target_n             	= 0; // (acr_ed.FDb.ind_target)
    _db.ind_target_buckets_n     	= 4; // (acr_ed.FDb.ind_target)
    _db.ind_target_buckets_elems 	= (acr_ed::FTarget**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget*)*_db.ind_target_buckets_n); // initial buckets (acr_ed.FDb.ind_target)
    if (!_db.ind_target_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_target)
    }
    memset(_db.ind_target_buckets_elems, 0, sizeof(acr_ed::FTarget*)*_db.ind_target_buckets_n); // (acr_ed.FDb.ind_target)
    _db.need_amc = bool(false);
    // initialize LAry targsrc (acr_ed.FDb.targsrc)
    _db.targsrc_n = 0;
    memset(_db.targsrc_lary, 0, sizeof(_db.targsrc_lary)); // zero out all level pointers
    acr_ed::FTargsrc* targsrc_first = (acr_ed::FTargsrc*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTargsrc) * (u64(1)<<4));
    if (!targsrc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targsrc_lary[i]  = targsrc_first;
        targsrc_first    += 1ULL<<i;
    }
    _db.abt_path = algo::strptr("bin/abt");
    _db.abt_pid = pid_t(0);
    _db.abt_timeout = i32(0);
    _db.abt_status = i32(0);
    // initialize LAry sbpath (acr_ed.FDb.sbpath)
    _db.sbpath_n = 0;
    memset(_db.sbpath_lary, 0, sizeof(_db.sbpath_lary)); // zero out all level pointers
    acr_ed::FSbpath* sbpath_first = (acr_ed::FSbpath*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSbpath) * (u64(1)<<4));
    if (!sbpath_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.sbpath_lary[i]  = sbpath_first;
        sbpath_first    += 1ULL<<i;
    }
    // initialize LAry pack (acr_ed.FDb.pack)
    _db.pack_n = 0;
    memset(_db.pack_lary, 0, sizeof(_db.pack_lary)); // zero out all level pointers
    acr_ed::FPack* pack_first = (acr_ed::FPack*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FPack) * (u64(1)<<4));
    if (!pack_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pack_lary[i]  = pack_first;
        pack_first    += 1ULL<<i;
    }
    // initialize LAry typefld (acr_ed.FDb.typefld)
    _db.typefld_n = 0;
    memset(_db.typefld_lary, 0, sizeof(_db.typefld_lary)); // zero out all level pointers
    acr_ed::FTypefld* typefld_first = (acr_ed::FTypefld*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTypefld) * (u64(1)<<4));
    if (!typefld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.typefld_lary[i]  = typefld_first;
        typefld_first    += 1ULL<<i;
    }
    // initialize LAry cpptype (acr_ed.FDb.cpptype)
    _db.cpptype_n = 0;
    memset(_db.cpptype_lary, 0, sizeof(_db.cpptype_lary)); // zero out all level pointers
    acr_ed::FCpptype* cpptype_first = (acr_ed::FCpptype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCpptype) * (u64(1)<<4));
    if (!cpptype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cpptype_lary[i]  = cpptype_first;
        cpptype_first    += 1ULL<<i;
    }
    // initialize LAry cfmt (acr_ed.FDb.cfmt)
    _db.cfmt_n = 0;
    memset(_db.cfmt_lary, 0, sizeof(_db.cfmt_lary)); // zero out all level pointers
    acr_ed::FCfmt* cfmt_first = (acr_ed::FCfmt*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCfmt) * (u64(1)<<4));
    if (!cfmt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cfmt_lary[i]  = cfmt_first;
        cfmt_first    += 1ULL<<i;
    }
    // initialize LAry nsdb (acr_ed.FDb.nsdb)
    _db.nsdb_n = 0;
    memset(_db.nsdb_lary, 0, sizeof(_db.nsdb_lary)); // zero out all level pointers
    acr_ed::FNsdb* nsdb_first = (acr_ed::FNsdb*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNsdb) * (u64(1)<<4));
    if (!nsdb_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nsdb_lary[i]  = nsdb_first;
        nsdb_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FNsdb;
    _db.ind_nsdb_n             	= 0; // (acr_ed.FDb.ind_nsdb)
    _db.ind_nsdb_buckets_n     	= 4; // (acr_ed.FDb.ind_nsdb)
    _db.ind_nsdb_buckets_elems 	= (acr_ed::FNsdb**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNsdb*)*_db.ind_nsdb_buckets_n); // initial buckets (acr_ed.FDb.ind_nsdb)
    if (!_db.ind_nsdb_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_nsdb)
    }
    memset(_db.ind_nsdb_buckets_elems, 0, sizeof(acr_ed::FNsdb*)*_db.ind_nsdb_buckets_n); // (acr_ed.FDb.ind_nsdb)
    _db.could_be_ptr = bool(false);

    acr_ed::InitReflection();
}

// --- acr_ed.FDb..Uninit
void acr_ed::FDb_Uninit() {
    acr_ed::FDb &row = _db; (void)row;

    // acr_ed.FDb.ind_nsdb.Uninit (Thash)  //
    // skip destruction of ind_nsdb in global scope

    // acr_ed.FDb.nsdb.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.cfmt.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.cpptype.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.typefld.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.pack.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.sbpath.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.abt.Uninit (Exec)  //
    abt_Kill(); // kill child, ensure forward progress

    // acr_ed.FDb.targsrc.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_target.Uninit (Thash)  //
    // skip destruction of ind_target in global scope

    // acr_ed.FDb.target.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_fprefix.Uninit (Thash)  //
    // skip destruction of ind_fprefix in global scope

    // acr_ed.FDb.fprefix.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_listtype.Uninit (Thash)  //
    // skip destruction of ind_listtype in global scope

    // acr_ed.FDb.listtype.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.vis.Uninit (Tary)  //
    // remove all elements from acr_ed.FDb.vis
    vis_RemoveAll();
    // free memory for Tary acr_ed.FDb.vis
    algo_lib::malloc_FreeMem(_db.vis_elems, sizeof(algo::cstring)*_db.vis_max); // (acr_ed.FDb.vis)

    // acr_ed.FDb.cstr.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // acr_ed.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // acr_ed.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // acr_ed.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ns.Uninit (Thash)  //
    // skip destruction of ind_ns in global scope

    // acr_ed.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- acr_ed.FField.msghdr.CopyOut
// Copy fields out of row
void acr_ed::field_CopyOut(acr_ed::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- acr_ed.FField.msghdr.CopyIn
// Copy fields in to row
void acr_ed::field_CopyIn(acr_ed::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- acr_ed.FField.ctype.Get
algo::Smallstr50 acr_ed::ctype_Get(acr_ed::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- acr_ed.FField.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- acr_ed.FField.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- acr_ed.FField..Init
// Set all fields to initial values.
void acr_ed::FField_Init(acr_ed::FField& field) {
    field.reftype = algo::strptr("Val");
    field.p_ctype = NULL;
    field.rowid = u32(0);
    field.p_arg = NULL;
    field.p_ns = NULL;
    field.ctype_c_field_in_ary = bool(false);
    field.ind_field_next = (acr_ed::FField*)-1; // (acr_ed.FDb.ind_field) not-in-hash
}

// --- acr_ed.FField..Uninit
void acr_ed::FField_Uninit(acr_ed::FField& field) {
    acr_ed::FField &row = field; (void)row;
    ind_field_Remove(row); // remove field from index ind_field
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
}

// --- acr_ed.FFprefix.base.CopyOut
// Copy fields out of row
void acr_ed::fprefix_CopyOut(acr_ed::FFprefix &row, dmmeta::Fprefix &out) {
    out.fprefix = row.fprefix;
    out.reftype = row.reftype;
    out.comment = row.comment;
}

// --- acr_ed.FFprefix.base.CopyIn
// Copy fields in to row
void acr_ed::fprefix_CopyIn(acr_ed::FFprefix &row, dmmeta::Fprefix &in) {
    row.fprefix = in.fprefix;
    row.reftype = in.reftype;
    row.comment = in.comment;
}

// --- acr_ed.FFprefix..Uninit
void acr_ed::FFprefix_Uninit(acr_ed::FFprefix& fprefix) {
    acr_ed::FFprefix &row = fprefix; (void)row;
    ind_fprefix_Remove(row); // remove fprefix from index ind_fprefix
}

// --- acr_ed.FListtype.msghdr.CopyOut
// Copy fields out of row
void acr_ed::listtype_CopyOut(acr_ed::FListtype &row, dmmeta::Listtype &out) {
    out.listtype = row.listtype;
    out.circular = row.circular;
    out.haveprev = row.haveprev;
    out.instail = row.instail;
    out.comment = row.comment;
}

// --- acr_ed.FListtype.msghdr.CopyIn
// Copy fields in to row
void acr_ed::listtype_CopyIn(acr_ed::FListtype &row, dmmeta::Listtype &in) {
    row.listtype = in.listtype;
    row.circular = in.circular;
    row.haveprev = in.haveprev;
    row.instail = in.instail;
    row.comment = in.comment;
}

// --- acr_ed.FListtype..Uninit
void acr_ed::FListtype_Uninit(acr_ed::FListtype& listtype) {
    acr_ed::FListtype &row = listtype; (void)row;
    ind_listtype_Remove(row); // remove listtype from index ind_listtype
}

// --- acr_ed.FNs.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ns_CopyOut(acr_ed::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.license = row.license;
    out.comment = row.comment;
}

// --- acr_ed.FNs.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ns_CopyIn(acr_ed::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.license = in.license;
    row.comment = in.comment;
}

// --- acr_ed.FNs..Uninit
void acr_ed::FNs_Uninit(acr_ed::FNs& ns) {
    acr_ed::FNs &row = ns; (void)row;
    ind_ns_Remove(row); // remove ns from index ind_ns
}

// --- acr_ed.FNsdb.base.CopyOut
// Copy fields out of row
void acr_ed::nsdb_CopyOut(acr_ed::FNsdb &row, dmmeta::Nsdb &out) {
    out.ns = row.ns;
    out.comment = row.comment;
}

// --- acr_ed.FNsdb.base.CopyIn
// Copy fields in to row
void acr_ed::nsdb_CopyIn(acr_ed::FNsdb &row, dmmeta::Nsdb &in) {
    row.ns = in.ns;
    row.comment = in.comment;
}

// --- acr_ed.FNsdb..Uninit
void acr_ed::FNsdb_Uninit(acr_ed::FNsdb& nsdb) {
    acr_ed::FNsdb &row = nsdb; (void)row;
    ind_nsdb_Remove(row); // remove nsdb from index ind_nsdb
}

// --- acr_ed.FPack.base.CopyOut
// Copy fields out of row
void acr_ed::pack_CopyOut(acr_ed::FPack &row, dmmeta::Pack &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- acr_ed.FPack.base.CopyIn
// Copy fields in to row
void acr_ed::pack_CopyIn(acr_ed::FPack &row, dmmeta::Pack &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- acr_ed.FPack..Uninit
void acr_ed::FPack_Uninit(acr_ed::FPack& pack) {
    acr_ed::FPack &row = pack; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_pack_Remove(*p_ctype, row);// remove pack from index c_pack
    }
}

// --- acr_ed.FSbpath.base.CopyOut
// Copy fields out of row
void acr_ed::sbpath_CopyOut(acr_ed::FSbpath &row, dev::Sbpath &out) {
    out.sbpath = row.sbpath;
    out.comment = row.comment;
}

// --- acr_ed.FSbpath.base.CopyIn
// Copy fields in to row
void acr_ed::sbpath_CopyIn(acr_ed::FSbpath &row, dev::Sbpath &in) {
    row.sbpath = in.sbpath;
    row.comment = in.comment;
}

// --- acr_ed.FSsimfile.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ssimfile_CopyOut(acr_ed::FSsimfile &row, dmmeta::Ssimfile &out) {
    out.ssimfile = row.ssimfile;
    out.ctype = row.ctype;
}

// --- acr_ed.FSsimfile.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ssimfile_CopyIn(acr_ed::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- acr_ed.FSsimfile.ssimns.Get
algo::Smallstr16 acr_ed::ssimns_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr_ed.FSsimfile.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr_ed.FSsimfile.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- acr_ed.FSsimfile..Uninit
void acr_ed::FSsimfile_Uninit(acr_ed::FSsimfile& ssimfile) {
    acr_ed::FSsimfile &row = ssimfile; (void)row;
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ssimfile_Remove(*p_ctype, row);// remove ssimfile from index c_ssimfile
    }
}

// --- acr_ed.FTarget.base.CopyOut
// Copy fields out of row
void acr_ed::target_CopyOut(acr_ed::FTarget &row, dev::Target &out) {
    out.target = row.target;
    out.compat = row.compat;
}

// --- acr_ed.FTarget.base.CopyIn
// Copy fields in to row
void acr_ed::target_CopyIn(acr_ed::FTarget &row, dev::Target &in) {
    row.target = in.target;
    row.compat = in.compat;
}

// --- acr_ed.FTarget..Uninit
void acr_ed::FTarget_Uninit(acr_ed::FTarget& target) {
    acr_ed::FTarget &row = target; (void)row;
    ind_target_Remove(row); // remove target from index ind_target
}

// --- acr_ed.FTargsrc.base.CopyOut
// Copy fields out of row
void acr_ed::targsrc_CopyOut(acr_ed::FTargsrc &row, dev::Targsrc &out) {
    out.targsrc = row.targsrc;
    out.comment = row.comment;
}

// --- acr_ed.FTargsrc.base.CopyIn
// Copy fields in to row
void acr_ed::targsrc_CopyIn(acr_ed::FTargsrc &row, dev::Targsrc &in) {
    row.targsrc = in.targsrc;
    row.comment = in.comment;
}

// --- acr_ed.FTargsrc.target.Get
algo::Smallstr16 acr_ed::target_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr16 ret(algo::Pathcomp(targsrc.targsrc, "/LL"));
    return ret;
}

// --- acr_ed.FTargsrc.src.Get
algo::Smallstr200 acr_ed::src_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr200 ret(algo::Pathcomp(targsrc.targsrc, "/LR"));
    return ret;
}

// --- acr_ed.FTargsrc.ext.Get
algo::Smallstr10 acr_ed::ext_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr10 ret(algo::Pathcomp(targsrc.targsrc, ".RR"));
    return ret;
}

// --- acr_ed.FTypefld.base.CopyOut
// Copy fields out of row
void acr_ed::typefld_CopyOut(acr_ed::FTypefld &row, dmmeta::Typefld &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- acr_ed.FTypefld.base.CopyIn
// Copy fields in to row
void acr_ed::typefld_CopyIn(acr_ed::FTypefld &row, dmmeta::Typefld &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- acr_ed.FTypefld.ctype.Get
algo::Smallstr50 acr_ed::ctype_Get(acr_ed::FTypefld& typefld) {
    algo::Smallstr50 ret(algo::Pathcomp(typefld.field, ".RL"));
    return ret;
}

// --- acr_ed.FTypefld..Uninit
void acr_ed::FTypefld_Uninit(acr_ed::FTypefld& typefld) {
    acr_ed::FTypefld &row = typefld; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_typefld_Remove(*p_ctype, row);// remove typefld from index c_typefld
    }
}

// --- acr_ed.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr_ed::value_ToCstr(const acr_ed::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_ed_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- acr_ed.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr_ed::value_Print(const acr_ed::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr_ed.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr_ed::value_SetStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,acr_ed_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr_ed.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr_ed::value_SetStrptr(acr_ed::FieldId& parent, algo::strptr rhs, acr_ed_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr_ed.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr_ed::value_ReadStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr_ed.FieldId..ReadStrptrMaybe
// Read fields of acr_ed::FieldId from an ascii string.
// The format of the string is the format of the acr_ed::FieldId's only field
bool acr_ed::FieldId_ReadStrptrMaybe(acr_ed::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr_ed.FieldId..Print
// print string representation of acr_ed::FieldId to string LHS, no header -- cprint:acr_ed.FieldId.String
void acr_ed::FieldId_Print(acr_ed::FieldId & row, algo::cstring &str) {
    acr_ed::value_Print(row, str);
}

// --- acr_ed.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr_ed::value_ToCstr(const acr_ed::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_ed_TableId_dmmeta_Cfmt    : ret = "dmmeta.Cfmt";  break;
        case acr_ed_TableId_dmmeta_Cpptype : ret = "dmmeta.Cpptype";  break;
        case acr_ed_TableId_dmmeta_Cstr    : ret = "dmmeta.Cstr";  break;
        case acr_ed_TableId_dmmeta_Ctype   : ret = "dmmeta.Ctype";  break;
        case acr_ed_TableId_dmmeta_Field   : ret = "dmmeta.Field";  break;
        case acr_ed_TableId_dmmeta_Fprefix : ret = "dmmeta.Fprefix";  break;
        case acr_ed_TableId_dmmeta_Listtype: ret = "dmmeta.Listtype";  break;
        case acr_ed_TableId_dmmeta_Ns      : ret = "dmmeta.Ns";  break;
        case acr_ed_TableId_dmmeta_Nsdb    : ret = "dmmeta.Nsdb";  break;
        case acr_ed_TableId_dmmeta_Pack    : ret = "dmmeta.Pack";  break;
        case acr_ed_TableId_dev_Sbpath     : ret = "dev.Sbpath";  break;
        case acr_ed_TableId_dmmeta_Ssimfile: ret = "dmmeta.Ssimfile";  break;
        case acr_ed_TableId_dev_Target     : ret = "dev.Target";  break;
        case acr_ed_TableId_dev_Targsrc    : ret = "dev.Targsrc";  break;
        case acr_ed_TableId_dmmeta_Typefld : ret = "dmmeta.Typefld";  break;
    }
    return ret;
}

// --- acr_ed.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr_ed::value_Print(const acr_ed::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr_ed.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr_ed::value_SetStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','S','b','p','a'): {
                    if (memcmp(rhs.elems+8,"th",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_Sbpath); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_Target); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','s','b','p','a'): {
                    if (memcmp(rhs.elems+8,"th",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_sbpath); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_target); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,acr_ed_TableId_dev_Targsrc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,acr_ed_TableId_dev_targsrc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"fmt",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Cfmt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Cstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"sdb",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Nsdb); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','P'): {
                    if (memcmp(rhs.elems+8,"ack",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Pack); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"fmt",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_cfmt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_cstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"sdb",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_nsdb); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','p'): {
                    if (memcmp(rhs.elems+8,"ack",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_pack); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Field); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"pptype",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Cpptype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Fprefix); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','T'): {
                    if (memcmp(rhs.elems+8,"ypefld",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Typefld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"pptype",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_cpptype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_fprefix); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','t'): {
                    if (memcmp(rhs.elems+8,"ypefld",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_typefld); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','L'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','l'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr_ed.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr_ed::value_SetStrptr(acr_ed::TableId& parent, algo::strptr rhs, acr_ed_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr_ed.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr_ed::value_ReadStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr_ed.TableId..ReadStrptrMaybe
// Read fields of acr_ed::TableId from an ascii string.
// The format of the string is the format of the acr_ed::TableId's only field
bool acr_ed::TableId_ReadStrptrMaybe(acr_ed::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr_ed.TableId..Print
// print string representation of acr_ed::TableId to string LHS, no header -- cprint:acr_ed.TableId.String
void acr_ed::TableId_Print(acr_ed::TableId & row, algo::cstring &str) {
    acr_ed::value_Print(row, str);
}

// --- acr_ed...SizeCheck
inline static void acr_ed::SizeCheck() {
}

// --- acr_ed...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        acr_ed::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        acr_ed::ReadArgv(); // dmmeta.main:acr_ed
        acr_ed::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("acr_ed.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        acr_ed::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- acr_ed...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
