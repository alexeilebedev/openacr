//
// cpp/gen/acr_ed_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/acr_ed_gen.h"
#include "include/gen/acr_ed_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
acr_ed::FDb     acr_ed::_db;      // dependency found via dev.targdep

namespace acr_ed {
const char *acr_ed_help =
"acr_ed: ACR Editor Set of useful recipes, uses acr, abt, git, and other tools\n"
"Usage: acr_ed [options]\n"
"    -in         string  Input directory or filename, - for stdin. default: \"data\"\n"
"    -create             Create new entity (-finput, -target, -ctype, -field). default: false\n"
"    -del                Delete mode. default: false\n"
"    -rename     string  Rename to something else\n"
"    -replace            Use acr -replace (default is -insert, fails on duplicate). default: false\n"
"    -finput             Create in-memory table based on ssimfile. default: false\n"
"    -srcfile    string      Create source file\n"
"    -gstatic            Like -finput, but data is loaded at compile time. default: false\n"
"    -indexed            (with -finput) Add hash index. default: false\n"
"    -target     string  Create new target\n"
"    -nstype     string  (with -create -target): exe,lib,etc.. default: \"exe\"\n"
"    -ctype      string  Create new ctype\n"
"    -pooltype   string   Pool reftype (Lary,Lpool etc) for finput/ctype\n"
"    -ssimfile   string    Ssimfile for new ctype\n"
"    -subset     string    Primary key is a subset of this ctype\n"
"    -subset2    string    Primary key is also a subset of this ctype\n"
"    -separator  string      Key separator. default: \".\"\n"
"    -field      string  Create field\n"
"    -arg        string    Field type (e.g. u32, etc)\n"
"    -dflt       string    Field default value\n"
"    -anon                 Anonymous field (use with command lines). default: false\n"
"    -bigend               Big-endian field. default: false\n"
"    -cascdel              Field is cascdel. default: false\n"
"    -before     string    Place field before this one\n"
"    -substr     string    New field is a substring\n"
"    -srcfield   string    Source field for bitfld/substr\n"
"    -fstep      string    Add fstep record\n"
"    -inscond    string    Insert condition (for xref). default: \"true\"\n"
"    -reftype    string    Reftype (e.g. Val, Thash, Llist, etc)\n"
"    -hashfld    string      (-reftype:Thash) Hash field\n"
"    -sortfld    string      (-reftype:Bheap) Sort field\n"
"    -unittest   string  Create unit test, <ns>.<functionname>\n"
"    -normcheck  string  Create normalization check\n"
"    -cppfunc    string  Field is a cppfunc, pass c++ expression as argument\n"
"    -xref                   X-ref with field type. default: false\n"
"    -via        string        X-ref argument (index, pointer, or index/key)\n"
"    -showcpp            Show resulting C++ code. default: false\n"
"    -write              Commit output to disk. default: false\n"
"    -e                   (with -create -unittest) Edit new testcase. default: false\n"
"    -comment    string  Comment for new entity\n"
"    -sandbox            Make changes in sandbox. default: false\n"
"    -verbose            Enable verbose mode\n"
"    -debug              Enable debug mode\n"
"    -version            Show version information\n"
"    -sig                Print SHA1 signatures for dispatches\n"
"    -help               Print this screen and exit\n"
;


const char *acr_ed_syntax =
"-in:string=\"data\"\n"
" -create:flag\n"
" -del:flag\n"
" -rename:string=\n"
" -replace:flag\n"
" -finput:flag\n"
" -srcfile:string=\n"
" -gstatic:flag\n"
" -indexed:flag\n"
" -target:string=\n"
" -nstype:string=\"exe\"\n"
" -ctype:string=\n"
" -pooltype:string=\n"
" -ssimfile:string=\n"
" -subset:string=\n"
" -subset2:string=\n"
" -separator:string=\".\"\n"
" -field:string=\n"
" -arg:string=\n"
" -dflt:string=\n"
" -anon:flag\n"
" -bigend:flag\n"
" -cascdel:flag\n"
" -before:string=\n"
" -substr:string=\n"
" -srcfield:string=\n"
" -fstep:string=\n"
" -inscond:string=\"true\"\n"
" -reftype:string=\n"
" -hashfld:string=\n"
" -sortfld:string=\n"
" -unittest:string=\n"
" -normcheck:string=\n"
" -cppfunc:string=\n"
" -xref:flag\n"
" -via:string=\n"
" -showcpp:flag\n"
" -write:flag\n"
" -e:flag\n"
" -comment:string=\n"
" -sandbox:flag\n"
;
} // namespace acr_ed
namespace acr_ed {
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    static bool          cstr_InputMaybe(dmmeta::Cstr &elem) __attribute__((nothrow));
    static bool          listtype_InputMaybe(dmmeta::Listtype &elem) __attribute__((nothrow));
    static bool          fprefix_InputMaybe(dmmeta::Fprefix &elem) __attribute__((nothrow));
    static bool          target_InputMaybe(dev::Target &elem) __attribute__((nothrow));
    static bool          targsrc_InputMaybe(dev::Targsrc &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // end namespace acr_ed

// --- acr_ed.FCstr.msghdr.CopyOut
// Copy fields out of row
void acr_ed::cstr_CopyOut(acr_ed::FCstr &row, dmmeta::Cstr &out) {
    out.ctype = row.ctype;
    out.strequiv = row.strequiv;
    out.comment = row.comment;
}

// --- acr_ed.FCstr.msghdr.CopyIn
// Copy fields in to row
void acr_ed::cstr_CopyIn(acr_ed::FCstr &row, dmmeta::Cstr &in) {
    row.ctype = in.ctype;
    row.strequiv = in.strequiv;
    row.comment = in.comment;
}

// --- acr_ed.FCstr..Uninit
void acr_ed::FCstr_Uninit(acr_ed::FCstr& cstr) {
    acr_ed::FCstr &row = cstr; (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cstr_Remove(*p_ctype, row);// remove cstr from index c_cstr
    }
}

// --- acr_ed.FCtype.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ctype_CopyOut(acr_ed::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- acr_ed.FCtype.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ctype_CopyIn(acr_ed::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- acr_ed.FCtype.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- acr_ed.FCtype.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FCtype& ctype) {
    algo::Smallstr50 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- acr_ed.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void acr_ed::c_field_Insert(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,true)) {
        // reserve space
        c_field_Reserve(ctype, 1);
        u32 n  = ctype.c_field_n;
        u32 at = n;
        acr_ed::FField* *elems = ctype.c_field_elems;
        elems[at] = &row;
        ctype.c_field_n = n+1;

    }
}

// --- acr_ed.FCtype.c_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool acr_ed::c_field_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    bool retval = !row.ctype_c_field_in_ary;
    c_field_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- acr_ed.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void acr_ed::c_field_Remove(acr_ed::FCtype& ctype, acr_ed::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,false)) {
        int lim = ctype.c_field_n;
        acr_ed::FField* *elems = ctype.c_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            acr_ed::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(acr_ed::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- acr_ed.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void acr_ed::c_field_Reserve(acr_ed::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(acr_ed::FField*);
        u32 new_size = new_max * sizeof(acr_ed::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FCtype.c_field");
        }
        ctype.c_field_elems = (acr_ed::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- acr_ed.FCtype..Uninit
void acr_ed::FCtype_Uninit(acr_ed::FCtype& ctype) {
    acr_ed::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype

    // acr_ed.FCtype.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_field_elems, sizeof(acr_ed::FField*)*ctype.c_field_max); // (acr_ed.FCtype.c_field)
}

// --- acr_ed.trace..Print
// print string representation of acr_ed::trace to string LHS, no header -- cprint:acr_ed.trace.String
void acr_ed::trace_Print(acr_ed::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "acr_ed.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- acr_ed.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNs& acr_ed::ns_Alloc() {
    acr_ed::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNs* acr_ed::ns_AllocMaybe() {
    acr_ed::FNs *row = (acr_ed::FNs*)ns_AllocMem();
    if (row) {
        new (row) acr_ed::FNs; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNs* acr_ed::ns_InsertMaybe(const dmmeta::Ns &value) {
    acr_ed::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FNs*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = n;
    }
}

// --- acr_ed.FDb.ns.InputMaybe
static bool acr_ed::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ns_XrefMaybe(acr_ed::FNs &row) {
    bool retval = true;
    (void)row;
    // insert ns into index ind_ns
    if (true) { // user-defined insert condition
        bool success = ind_ns_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ns"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ns.Find
// Find row by key. Return NULL if not found.
acr_ed::FNs* acr_ed::ind_ns_Find(const algo::strptr& key) {
    u32 index = Smallstr16_Hash(0, key) & (_db.ind_ns_buckets_n - 1);
    acr_ed::FNs* *e = &_db.ind_ns_buckets_elems[index];
    acr_ed::FNs* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_ns_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ns.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNs& acr_ed::ind_ns_FindX(const algo::strptr& key) {
    acr_ed::FNs* ret = ind_ns_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ns  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ns.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNs& acr_ed::ind_ns_GetOrCreate(const algo::strptr& key) {
    acr_ed::FNs* ret = ind_ns_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ns_Alloc();
        (*ret).ns = key;
        bool good = ns_XrefMaybe(*ret);
        if (!good) {
            ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- acr_ed.FDb.ind_ns.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ns_InsertMaybe(acr_ed::FNs& row) {
    ind_ns_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ns_next == (acr_ed::FNs*)-1)) {// check if in hash already
        u32 index = Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        acr_ed::FNs* *prev = &_db.ind_ns_buckets_elems[index];
        do {
            acr_ed::FNs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ns_next;
        } while (true);
        if (retval) {
            row.ind_ns_next = *prev;
            _db.ind_ns_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ns.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ns_Remove(acr_ed::FNs& row) {
    if (LIKELY(row.ind_ns_next != (acr_ed::FNs*)-1)) {// check if in hash already
        u32 index = Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        acr_ed::FNs* *prev = &_db.ind_ns_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FNs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ns_next; // unlink (singly linked list)
                _db.ind_ns_n--;
                row.ind_ns_next = (acr_ed::FNs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ns_next;
        }
    }
}

// --- acr_ed.FDb.ind_ns.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ns_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ns_buckets_n;
    u32 new_nelems   = _db.ind_ns_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FNs*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FNs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FNs* *new_buckets = (acr_ed::FNs**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ns");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ns_buckets_n; i++) {
            acr_ed::FNs* elem = _db.ind_ns_buckets_elems[i];
            while (elem) {
                acr_ed::FNs &row        = *elem;
                acr_ed::FNs* next       = row.ind_ns_next;
                u32 index          = Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_ns_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ns_buckets_elems, old_size);
        _db.ind_ns_buckets_elems = new_buckets;
        _db.ind_ns_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb._db.MainArgs
// Main function
void acr_ed::MainArgs(int argc, char **argv) {
    Argtuple argtuple;
    Argtuple_ReadArgv(argtuple, argc,argv,acr_ed_syntax, acr_ed_help);
    vrfy(acr_ed_ReadTupleMaybe(acr_ed::_db.cmdline, argtuple.tuple),"where:read_cmdline");
    vrfy(acr_ed::LoadTuplesMaybe(acr_ed::_db.cmdline.in)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
    acr_ed::Main(); // call through to user-defined main
}

// --- acr_ed.FDb._db.MainLoop
// Main loop.
void acr_ed::MainLoop() {
    SchedTime time(get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        algo_lib::Step(); // dependent namespace specified via (dev.targdep)
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- acr_ed.FDb._db.Step
// Main step
void acr_ed::Step() {
}

// --- acr_ed.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void acr_ed::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("acr_ed", acr_ed::InsertStrptrMaybe, NULL, acr_ed::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "acr_ed.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(acr_ed::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)acr_ed::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'acr_ed.Input'  signature:'4a62829eabcceb6a0156ada29e54841bfb759772'");
}

// --- acr_ed.FDb._db.StaticCheck
void acr_ed::StaticCheck() {
    algo_assert(_offset_of(acr_ed::FieldId, value) + sizeof(((acr_ed::FieldId*)0)->value) == sizeof(acr_ed::FieldId));
}

// --- acr_ed.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool acr_ed::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    acr_ed::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case acr_ed_TableId_dmmeta_Ns: { // finput:acr_ed.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Field: { // finput:acr_ed.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Ctype: { // finput:acr_ed.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Ssimfile: { // finput:acr_ed.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Cstr: { // finput:acr_ed.FDb.cstr
            dmmeta::Cstr elem;
            retval = dmmeta::Cstr_ReadStrptrMaybe(elem, str);
            retval = retval && cstr_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Listtype: { // finput:acr_ed.FDb.listtype
            dmmeta::Listtype elem;
            retval = dmmeta::Listtype_ReadStrptrMaybe(elem, str);
            retval = retval && listtype_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dmmeta_Fprefix: { // finput:acr_ed.FDb.fprefix
            dmmeta::Fprefix elem;
            retval = dmmeta::Fprefix_ReadStrptrMaybe(elem, str);
            retval = retval && fprefix_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dev_Target: { // finput:acr_ed.FDb.target
            dev::Target elem;
            retval = dev::Target_ReadStrptrMaybe(elem, str);
            retval = retval && target_InputMaybe(elem);
            break;
        }
        case acr_ed_TableId_dev_Targsrc: { // finput:acr_ed.FDb.targsrc
            dev::Targsrc elem;
            retval = dev::Targsrc_ReadStrptrMaybe(elem, str);
            retval = retval && targsrc_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- acr_ed.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool acr_ed::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dmmeta.ns", "dmmeta.ctype", "dmmeta.cstr", "dmmeta.field"
        , "dmmeta.fprefix", "dmmeta.listtype", "dmmeta.ssimfile", "dev.target"
        , "dev.targsrc"
        , NULL};
        retval = algo_lib::DoLoadTuples(root, acr_ed::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- acr_ed.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool acr_ed::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, acr_ed::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- acr_ed.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- acr_ed.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FField& acr_ed::field_Alloc() {
    acr_ed::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FField* acr_ed::field_AllocMaybe() {
    acr_ed::FField *row = (acr_ed::FField*)field_AllocMem();
    if (row) {
        new (row) acr_ed::FField; // call constructor
        row->rowid = u32(field_N() - 1);
    }
    return row;
}

// --- acr_ed.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FField* acr_ed::field_InsertMaybe(const dmmeta::Field &value) {
    acr_ed::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FField*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u32(n)).~FField();
        _db.field_n = n;
    }
}

// --- acr_ed.FDb.field.InputMaybe
static bool acr_ed::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::field_XrefMaybe(acr_ed::FField &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    acr_ed::FCtype* p_arg = acr_ed::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    acr_ed::FNs* p_ns = acr_ed::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // field: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    return retval;
}

// --- acr_ed.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
acr_ed::FField* acr_ed::ind_field_Find(const algo::strptr& key) {
    u32 index = Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    acr_ed::FField* *e = &_db.ind_field_buckets_elems[index];
    acr_ed::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_field.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FField& acr_ed::ind_field_FindX(const algo::strptr& key) {
    acr_ed::FField* ret = ind_field_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_field  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_field_InsertMaybe(acr_ed::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (acr_ed::FField*)-1)) {// check if in hash already
        u32 index = Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr_ed::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            acr_ed::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_field_Remove(acr_ed::FField& row) {
    if (LIKELY(row.ind_field_next != (acr_ed::FField*)-1)) {// check if in hash already
        u32 index = Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        acr_ed::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (acr_ed::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- acr_ed.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FField*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FField* *new_buckets = (acr_ed::FField**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            acr_ed::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                acr_ed::FField &row        = *elem;
                acr_ed::FField* next       = row.ind_field_next;
                u32 index          = Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCtype& acr_ed::ctype_Alloc() {
    acr_ed::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCtype* acr_ed::ctype_AllocMaybe() {
    acr_ed::FCtype *row = (acr_ed::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) acr_ed::FCtype; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCtype* acr_ed::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    acr_ed::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(u64(n)).~FCtype();
        _db.ctype_n = n;
    }
}

// --- acr_ed.FDb.ctype.InputMaybe
static bool acr_ed::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ctype_XrefMaybe(acr_ed::FCtype &row) {
    bool retval = true;
    (void)row;
    acr_ed::FNs* p_ns = acr_ed::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // ctype: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
acr_ed::FCtype* acr_ed::ind_ctype_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    acr_ed::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    acr_ed::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ctype.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FCtype& acr_ed::ind_ctype_FindX(const algo::strptr& key) {
    acr_ed::FCtype* ret = ind_ctype_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ctype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ctype_InsertMaybe(acr_ed::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (acr_ed::FCtype*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr_ed::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            acr_ed::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ctype_Remove(acr_ed::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (acr_ed::FCtype*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        acr_ed::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (acr_ed::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- acr_ed.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FCtype*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FCtype* *new_buckets = (acr_ed::FCtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            acr_ed::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                acr_ed::FCtype &row        = *elem;
                acr_ed::FCtype* next       = row.ind_ctype_next;
                u32 index          = Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSsimfile& acr_ed::ssimfile_Alloc() {
    acr_ed::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSsimfile* acr_ed::ssimfile_AllocMaybe() {
    acr_ed::FSsimfile *row = (acr_ed::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) acr_ed::FSsimfile; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSsimfile* acr_ed::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    acr_ed::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = n;
    }
}

// --- acr_ed.FDb.ssimfile.InputMaybe
static bool acr_ed::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::ssimfile_XrefMaybe(acr_ed::FSsimfile &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
acr_ed::FSsimfile* acr_ed::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    acr_ed::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    acr_ed::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_ssimfile.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FSsimfile& acr_ed::ind_ssimfile_FindX(const algo::strptr& key) {
    acr_ed::FSsimfile* ret = ind_ssimfile_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_ssimfile_InsertMaybe(acr_ed::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (acr_ed::FSsimfile*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr_ed::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            acr_ed::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_ssimfile_Remove(acr_ed::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (acr_ed::FSsimfile*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        acr_ed::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (acr_ed::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- acr_ed.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FSsimfile* *new_buckets = (acr_ed::FSsimfile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            acr_ed::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                acr_ed::FSsimfile &row        = *elem;
                acr_ed::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.cstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCstr& acr_ed::cstr_Alloc() {
    acr_ed::FCstr* row = cstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.cstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.cstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCstr* acr_ed::cstr_AllocMaybe() {
    acr_ed::FCstr *row = (acr_ed::FCstr*)cstr_AllocMem();
    if (row) {
        new (row) acr_ed::FCstr; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.cstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCstr* acr_ed::cstr_InsertMaybe(const dmmeta::Cstr &value) {
    acr_ed::FCstr *row = &cstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cstr_CopyIn(*row,const_cast<dmmeta::Cstr&>(value));
    bool ok = cstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        cstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.cstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::cstr_AllocMem() {
    u64 new_nelems     = _db.cstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FCstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cstr_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FCstr*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCstr) * (u64(1)<<bsr));
            _db.cstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cstr_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.cstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::cstr_RemoveLast() {
    u64 n = _db.cstr_n;
    if (n > 0) {
        n -= 1;
        cstr_qFind(u64(n)).~FCstr();
        _db.cstr_n = n;
    }
}

// --- acr_ed.FDb.cstr.InputMaybe
static bool acr_ed::cstr_InputMaybe(dmmeta::Cstr &elem) {
    bool retval = true;
    retval = cstr_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.cstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::cstr_XrefMaybe(acr_ed::FCstr &row) {
    bool retval = true;
    (void)row;
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cstr into index c_cstr
    if (true) { // user-defined insert condition
        bool success = c_cstr_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FCtype.c_cstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.vis.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& acr_ed::vis_Alloc() {
    vis_Reserve(1);
    int n  = _db.vis_n;
    int at = n;
    algo::cstring *elems = _db.vis_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    _db.vis_n = n+1;
    return elems[at];
}

// --- acr_ed.FDb.vis.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& acr_ed::vis_AllocAt(int at) {
    vis_Reserve(1);
    int n  = _db.vis_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("acr_ed.bad_alloc_at  field:acr_ed.FDb.vis  comment:'index out of range'");
    }
    algo::cstring *elems = _db.vis_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    _db.vis_n = n+1;
    return elems[at];
}

// --- acr_ed.FDb.vis.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> acr_ed::vis_AllocN(int n_elems) {
    vis_Reserve(n_elems);
    int old_n  = _db.vis_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = _db.vis_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    _db.vis_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- acr_ed.FDb.vis.Remove
// Remove item by index. If index outside of range, do nothing.
void acr_ed::vis_Remove(u32 i) {
    u32 lim = _db.vis_n;
    algo::cstring *elems = _db.vis_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        _db.vis_n = lim - 1;
    }
}

// --- acr_ed.FDb.vis.RemoveAll
void acr_ed::vis_RemoveAll() {
    u32 n = _db.vis_n;
    while (n > 0) {
        n -= 1;
        _db.vis_elems[n].~cstring();
        _db.vis_n = n;
    }
}

// --- acr_ed.FDb.vis.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::vis_RemoveLast() {
    u64 n = _db.vis_n;
    if (n > 0) {
        n -= 1;
        vis_qFind(u64(n)).~cstring();
        _db.vis_n = n;
    }
}

// --- acr_ed.FDb.vis.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void acr_ed::vis_AbsReserve(int n) {
    u32 old_max  = _db.vis_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::malloc_ReallocMem(_db.vis_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("acr_ed.tary_nomem  field:acr_ed.FDb.vis  comment:'out of memory'");
    }
    _db.vis_elems = (algo::cstring*)new_mem;
    _db.vis_max = new_max;
}

// --- acr_ed.FDb.listtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FListtype& acr_ed::listtype_Alloc() {
    acr_ed::FListtype* row = listtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.listtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.listtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FListtype* acr_ed::listtype_AllocMaybe() {
    acr_ed::FListtype *row = (acr_ed::FListtype*)listtype_AllocMem();
    if (row) {
        new (row) acr_ed::FListtype; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.listtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FListtype* acr_ed::listtype_InsertMaybe(const dmmeta::Listtype &value) {
    acr_ed::FListtype *row = &listtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    listtype_CopyIn(*row,const_cast<dmmeta::Listtype&>(value));
    bool ok = listtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.listtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::listtype_AllocMem() {
    u64 new_nelems     = _db.listtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FListtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.listtype_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FListtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype) * (u64(1)<<bsr));
            _db.listtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.listtype_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.listtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::listtype_RemoveLast() {
    u64 n = _db.listtype_n;
    if (n > 0) {
        n -= 1;
        listtype_qFind(u64(n)).~FListtype();
        _db.listtype_n = n;
    }
}

// --- acr_ed.FDb.listtype.InputMaybe
static bool acr_ed::listtype_InputMaybe(dmmeta::Listtype &elem) {
    bool retval = true;
    retval = listtype_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.listtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::listtype_XrefMaybe(acr_ed::FListtype &row) {
    bool retval = true;
    (void)row;
    // insert listtype into index ind_listtype
    if (true) { // user-defined insert condition
        bool success = ind_listtype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_listtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_listtype.Find
// Find row by key. Return NULL if not found.
acr_ed::FListtype* acr_ed::ind_listtype_Find(const algo::strptr& key) {
    u32 index = Smallstr5_Hash(0, key) & (_db.ind_listtype_buckets_n - 1);
    acr_ed::FListtype* *e = &_db.ind_listtype_buckets_elems[index];
    acr_ed::FListtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).listtype == key;
        if (done) break;
        e         = &ret->ind_listtype_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_listtype.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FListtype& acr_ed::ind_listtype_FindX(const algo::strptr& key) {
    acr_ed::FListtype* ret = ind_listtype_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_listtype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_listtype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FListtype& acr_ed::ind_listtype_GetOrCreate(const algo::strptr& key) {
    acr_ed::FListtype* ret = ind_listtype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &listtype_Alloc();
        (*ret).listtype = key;
        bool good = listtype_XrefMaybe(*ret);
        if (!good) {
            listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- acr_ed.FDb.ind_listtype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_listtype_InsertMaybe(acr_ed::FListtype& row) {
    ind_listtype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_listtype_next == (acr_ed::FListtype*)-1)) {// check if in hash already
        u32 index = Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        acr_ed::FListtype* *prev = &_db.ind_listtype_buckets_elems[index];
        do {
            acr_ed::FListtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).listtype == row.listtype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_listtype_next;
        } while (true);
        if (retval) {
            row.ind_listtype_next = *prev;
            _db.ind_listtype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_listtype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_listtype_Remove(acr_ed::FListtype& row) {
    if (LIKELY(row.ind_listtype_next != (acr_ed::FListtype*)-1)) {// check if in hash already
        u32 index = Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        acr_ed::FListtype* *prev = &_db.ind_listtype_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FListtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_listtype_next; // unlink (singly linked list)
                _db.ind_listtype_n--;
                row.ind_listtype_next = (acr_ed::FListtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_listtype_next;
        }
    }
}

// --- acr_ed.FDb.ind_listtype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_listtype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_listtype_buckets_n;
    u32 new_nelems   = _db.ind_listtype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FListtype*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FListtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FListtype* *new_buckets = (acr_ed::FListtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_listtype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_listtype_buckets_n; i++) {
            acr_ed::FListtype* elem = _db.ind_listtype_buckets_elems[i];
            while (elem) {
                acr_ed::FListtype &row        = *elem;
                acr_ed::FListtype* next       = row.ind_listtype_next;
                u32 index          = Smallstr5_Hash(0, row.listtype) & (new_nbuckets-1);
                row.ind_listtype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_listtype_buckets_elems, old_size);
        _db.ind_listtype_buckets_elems = new_buckets;
        _db.ind_listtype_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.fprefix.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FFprefix& acr_ed::fprefix_Alloc() {
    acr_ed::FFprefix* row = fprefix_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.fprefix  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.fprefix.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FFprefix* acr_ed::fprefix_AllocMaybe() {
    acr_ed::FFprefix *row = (acr_ed::FFprefix*)fprefix_AllocMem();
    if (row) {
        new (row) acr_ed::FFprefix; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.fprefix.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FFprefix* acr_ed::fprefix_InsertMaybe(const dmmeta::Fprefix &value) {
    acr_ed::FFprefix *row = &fprefix_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fprefix_CopyIn(*row,const_cast<dmmeta::Fprefix&>(value));
    bool ok = fprefix_XrefMaybe(*row); // this may return false
    if (!ok) {
        fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.fprefix.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::fprefix_AllocMem() {
    u64 new_nelems     = _db.fprefix_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FFprefix*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fprefix_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FFprefix*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix) * (u64(1)<<bsr));
            _db.fprefix_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fprefix_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.fprefix.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::fprefix_RemoveLast() {
    u64 n = _db.fprefix_n;
    if (n > 0) {
        n -= 1;
        fprefix_qFind(u64(n)).~FFprefix();
        _db.fprefix_n = n;
    }
}

// --- acr_ed.FDb.fprefix.InputMaybe
static bool acr_ed::fprefix_InputMaybe(dmmeta::Fprefix &elem) {
    bool retval = true;
    retval = fprefix_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.fprefix.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::fprefix_XrefMaybe(acr_ed::FFprefix &row) {
    bool retval = true;
    (void)row;
    // insert fprefix into index ind_fprefix
    if (true) { // user-defined insert condition
        bool success = ind_fprefix_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_fprefix"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_fprefix.Find
// Find row by key. Return NULL if not found.
acr_ed::FFprefix* acr_ed::ind_fprefix_Find(const algo::strptr& key) {
    u32 index = Smallstr5_Hash(0, key) & (_db.ind_fprefix_buckets_n - 1);
    acr_ed::FFprefix* *e = &_db.ind_fprefix_buckets_elems[index];
    acr_ed::FFprefix* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fprefix == key;
        if (done) break;
        e         = &ret->ind_fprefix_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_fprefix.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FFprefix& acr_ed::ind_fprefix_FindX(const algo::strptr& key) {
    acr_ed::FFprefix* ret = ind_fprefix_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_fprefix  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_fprefix.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FFprefix& acr_ed::ind_fprefix_GetOrCreate(const algo::strptr& key) {
    acr_ed::FFprefix* ret = ind_fprefix_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fprefix_Alloc();
        (*ret).fprefix = key;
        bool good = fprefix_XrefMaybe(*ret);
        if (!good) {
            fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- acr_ed.FDb.ind_fprefix.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_fprefix_InsertMaybe(acr_ed::FFprefix& row) {
    ind_fprefix_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fprefix_next == (acr_ed::FFprefix*)-1)) {// check if in hash already
        u32 index = Smallstr5_Hash(0, row.fprefix) & (_db.ind_fprefix_buckets_n - 1);
        acr_ed::FFprefix* *prev = &_db.ind_fprefix_buckets_elems[index];
        do {
            acr_ed::FFprefix* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fprefix == row.fprefix) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fprefix_next;
        } while (true);
        if (retval) {
            row.ind_fprefix_next = *prev;
            _db.ind_fprefix_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_fprefix.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_fprefix_Remove(acr_ed::FFprefix& row) {
    if (LIKELY(row.ind_fprefix_next != (acr_ed::FFprefix*)-1)) {// check if in hash already
        u32 index = Smallstr5_Hash(0, row.fprefix) & (_db.ind_fprefix_buckets_n - 1);
        acr_ed::FFprefix* *prev = &_db.ind_fprefix_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FFprefix *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fprefix_next; // unlink (singly linked list)
                _db.ind_fprefix_n--;
                row.ind_fprefix_next = (acr_ed::FFprefix*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fprefix_next;
        }
    }
}

// --- acr_ed.FDb.ind_fprefix.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_fprefix_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fprefix_buckets_n;
    u32 new_nelems   = _db.ind_fprefix_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FFprefix*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FFprefix*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FFprefix* *new_buckets = (acr_ed::FFprefix**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_fprefix");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fprefix_buckets_n; i++) {
            acr_ed::FFprefix* elem = _db.ind_fprefix_buckets_elems[i];
            while (elem) {
                acr_ed::FFprefix &row        = *elem;
                acr_ed::FFprefix* next       = row.ind_fprefix_next;
                u32 index          = Smallstr5_Hash(0, row.fprefix) & (new_nbuckets-1);
                row.ind_fprefix_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_fprefix_buckets_elems, old_size);
        _db.ind_fprefix_buckets_elems = new_buckets;
        _db.ind_fprefix_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.target.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTarget& acr_ed::target_Alloc() {
    acr_ed::FTarget* row = target_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.target  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.target.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTarget* acr_ed::target_AllocMaybe() {
    acr_ed::FTarget *row = (acr_ed::FTarget*)target_AllocMem();
    if (row) {
        new (row) acr_ed::FTarget; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.target.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTarget* acr_ed::target_InsertMaybe(const dev::Target &value) {
    acr_ed::FTarget *row = &target_Alloc(); // if out of memory, process dies. if input error, return NULL.
    target_CopyIn(*row,const_cast<dev::Target&>(value));
    bool ok = target_XrefMaybe(*row); // this may return false
    if (!ok) {
        target_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.target.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::target_AllocMem() {
    u64 new_nelems     = _db.target_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FTarget*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.target_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FTarget*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget) * (u64(1)<<bsr));
            _db.target_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.target_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.target.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::target_RemoveLast() {
    u64 n = _db.target_n;
    if (n > 0) {
        n -= 1;
        target_qFind(u64(n)).~FTarget();
        _db.target_n = n;
    }
}

// --- acr_ed.FDb.target.InputMaybe
static bool acr_ed::target_InputMaybe(dev::Target &elem) {
    bool retval = true;
    retval = target_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.target.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::target_XrefMaybe(acr_ed::FTarget &row) {
    bool retval = true;
    (void)row;
    // insert target into index ind_target
    if (true) { // user-defined insert condition
        bool success = ind_target_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "acr_ed.duplicate_key  xref:acr_ed.FDb.ind_target"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_target.Find
// Find row by key. Return NULL if not found.
acr_ed::FTarget* acr_ed::ind_target_Find(const algo::strptr& key) {
    u32 index = Smallstr16_Hash(0, key) & (_db.ind_target_buckets_n - 1);
    acr_ed::FTarget* *e = &_db.ind_target_buckets_elems[index];
    acr_ed::FTarget* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).target == key;
        if (done) break;
        e         = &ret->ind_target_next;
    } while (true);
    return ret;
}

// --- acr_ed.FDb.ind_target.FindX
// Look up row by key and return reference. Throw exception if not found
acr_ed::FTarget& acr_ed::ind_target_FindX(const algo::strptr& key) {
    acr_ed::FTarget* ret = ind_target_Find(key);
    vrfy(ret, tempstr() << "acr_ed.key_error  table:ind_target  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- acr_ed.FDb.ind_target.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FTarget& acr_ed::ind_target_GetOrCreate(const algo::strptr& key) {
    acr_ed::FTarget* ret = ind_target_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &target_Alloc();
        (*ret).target = key;
        bool good = target_XrefMaybe(*ret);
        if (!good) {
            target_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- acr_ed.FDb.ind_target.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool acr_ed::ind_target_InsertMaybe(acr_ed::FTarget& row) {
    ind_target_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_target_next == (acr_ed::FTarget*)-1)) {// check if in hash already
        u32 index = Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        acr_ed::FTarget* *prev = &_db.ind_target_buckets_elems[index];
        do {
            acr_ed::FTarget* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).target == row.target) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_target_next;
        } while (true);
        if (retval) {
            row.ind_target_next = *prev;
            _db.ind_target_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- acr_ed.FDb.ind_target.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void acr_ed::ind_target_Remove(acr_ed::FTarget& row) {
    if (LIKELY(row.ind_target_next != (acr_ed::FTarget*)-1)) {// check if in hash already
        u32 index = Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        acr_ed::FTarget* *prev = &_db.ind_target_buckets_elems[index]; // addr of pointer to current element
        while (acr_ed::FTarget *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_target_next; // unlink (singly linked list)
                _db.ind_target_n--;
                row.ind_target_next = (acr_ed::FTarget*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_target_next;
        }
    }
}

// --- acr_ed.FDb.ind_target.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void acr_ed::ind_target_Reserve(int n) {
    u32 old_nbuckets = _db.ind_target_buckets_n;
    u32 new_nelems   = _db.ind_target_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(acr_ed::FTarget*);
        u32 new_size = new_nbuckets * sizeof(acr_ed::FTarget*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        acr_ed::FTarget* *new_buckets = (acr_ed::FTarget**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("acr_ed.out_of_memory  field:acr_ed.FDb.ind_target");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_target_buckets_n; i++) {
            acr_ed::FTarget* elem = _db.ind_target_buckets_elems[i];
            while (elem) {
                acr_ed::FTarget &row        = *elem;
                acr_ed::FTarget* next       = row.ind_target_next;
                u32 index          = Smallstr16_Hash(0, row.target) & (new_nbuckets-1);
                row.ind_target_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_target_buckets_elems, old_size);
        _db.ind_target_buckets_elems = new_buckets;
        _db.ind_target_buckets_n = new_nbuckets;
    }
}

// --- acr_ed.FDb.targsrc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTargsrc& acr_ed::targsrc_Alloc() {
    acr_ed::FTargsrc* row = targsrc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("acr_ed.out_of_mem  field:acr_ed.FDb.targsrc  comment:'Alloc failed'");
    }
    return *row;
}

// --- acr_ed.FDb.targsrc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTargsrc* acr_ed::targsrc_AllocMaybe() {
    acr_ed::FTargsrc *row = (acr_ed::FTargsrc*)targsrc_AllocMem();
    if (row) {
        new (row) acr_ed::FTargsrc; // call constructor
    }
    return row;
}

// --- acr_ed.FDb.targsrc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTargsrc* acr_ed::targsrc_InsertMaybe(const dev::Targsrc &value) {
    acr_ed::FTargsrc *row = &targsrc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targsrc_CopyIn(*row,const_cast<dev::Targsrc&>(value));
    bool ok = targsrc_XrefMaybe(*row); // this may return false
    if (!ok) {
        targsrc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- acr_ed.FDb.targsrc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* acr_ed::targsrc_AllocMem() {
    u64 new_nelems     = _db.targsrc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    acr_ed::FTargsrc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targsrc_lary[bsr];
        if (!lev) {
            lev=(acr_ed::FTargsrc*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTargsrc) * (u64(1)<<bsr));
            _db.targsrc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targsrc_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- acr_ed.FDb.targsrc.RemoveAll
// Remove all elements from Lary
void acr_ed::targsrc_RemoveAll() {
    for (u64 n = _db.targsrc_n; n>0; ) {
        n--;
        targsrc_qFind(u64(n)).~FTargsrc(); // destroy last element
        _db.targsrc_n = n;
    }
}

// --- acr_ed.FDb.targsrc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void acr_ed::targsrc_RemoveLast() {
    u64 n = _db.targsrc_n;
    if (n > 0) {
        n -= 1;
        targsrc_qFind(u64(n)).~FTargsrc();
        _db.targsrc_n = n;
    }
}

// --- acr_ed.FDb.targsrc.InputMaybe
static bool acr_ed::targsrc_InputMaybe(dev::Targsrc &elem) {
    bool retval = true;
    retval = targsrc_InsertMaybe(elem);
    return retval;
}

// --- acr_ed.FDb.targsrc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool acr_ed::targsrc_XrefMaybe(acr_ed::FTargsrc &row) {
    bool retval = true;
    (void)row;
    acr_ed::FTarget* p_target = acr_ed::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "acr_ed.bad_xref  index:acr_ed.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // targsrc: save pointer to target
    if (true) { // user-defined insert condition
        row.p_target = p_target;
    }
    return retval;
}

// --- acr_ed.FDb.abt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int acr_ed::abt_Start() {
    int retval = 0;
    if (_db.abt_pid == 0) {
        verblog(abt_ToCmdline()); // maybe print command
        _db.abt_status = 0; // reset last status
        _db.abt_pid = fork();
        if (_db.abt_pid == 0) { // child
            algo_lib::DieWithParent();
            if (_db.abt_timeout > 0) {
                alarm(_db.abt_timeout);
            }
            algo_lib::ApplyRedirect(_db.abt_stdin, 0);
            algo_lib::ApplyRedirect(_db.abt_stdout, 1);
            algo_lib::ApplyRedirect(_db.abt_stderr, 2);
            retval = abt_Execv();
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("acr_ed.abt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (_db.abt_pid == -1) {
            retval = errno; // failed to fork
        } else {
            retval = _db.abt_status; // parent
        }
    }
    return retval;
}

// --- acr_ed.FDb.abt.Kill
// Kill subprocess and wait
void acr_ed::abt_Kill() {
    if (_db.abt_pid != 0) {
        kill(_db.abt_pid,9);
        abt_Wait();
    }
}

// --- acr_ed.FDb.abt.Wait
// Wait for subprocess to return
void acr_ed::abt_Wait() {
    if (_db.abt_pid != 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(_db.abt_pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == _db.abt_pid) {
            _db.abt_status = wait_status;
            _db.abt_pid = 0;
        }
    }
}

// --- acr_ed.FDb.abt.Exec
// Start + Wait
// Execute subprocess and return exit code
int acr_ed::abt_Exec() {
    abt_Start();
    abt_Wait();
    return _db.abt_status;
}

// --- acr_ed.FDb.abt.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void acr_ed::abt_ExecX() {
    int rc = abt_Exec();
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",abt_ToCmdline())
    << Keyval("comment",algo::DescribeWaitStatus(_db.abt_status)));
}

// --- acr_ed.FDb.abt.Execv
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int acr_ed::abt_Execv() {
    char *argv[26+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << _db.abt_path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (_db.abt_cmd.target.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        command::target_Print(_db.abt_cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(_db.abt_cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.out_dir != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-out_dir:";
        cstring_Print(_db.abt_cmd.out_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.cfg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cfg:";
        Smallstr50_Print(_db.abt_cmd.cfg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.compiler != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-compiler:";
        Smallstr50_Print(_db.abt_cmd.compiler, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.uname != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-uname:";
        Smallstr50_Print(_db.abt_cmd.uname, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.arch != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arch:";
        Smallstr50_Print(_db.abt_cmd.arch, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.ood != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ood:";
        bool_Print(_db.abt_cmd.ood, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.list != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-list:";
        bool_Print(_db.abt_cmd.list, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.listincl != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-listincl:";
        bool_Print(_db.abt_cmd.listincl, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.build != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-build:";
        bool_Print(_db.abt_cmd.build, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.preproc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-preproc:";
        bool_Print(_db.abt_cmd.preproc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.clean != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-clean:";
        bool_Print(_db.abt_cmd.clean, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.dry_run != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dry_run:";
        bool_Print(_db.abt_cmd.dry_run, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.maxjobs != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxjobs:";
        i32_Print(_db.abt_cmd.maxjobs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.printcmd != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-printcmd:";
        bool_Print(_db.abt_cmd.printcmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.force != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-force:";
        bool_Print(_db.abt_cmd.force, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.testgen != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-testgen:";
        bool_Print(_db.abt_cmd.testgen, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.install != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-install:";
        bool_Print(_db.abt_cmd.install, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.coverity != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-coverity:";
        bool_Print(_db.abt_cmd.coverity, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.release != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-release:";
        cstring_Print(_db.abt_cmd.release, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.package != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-package:";
        cstring_Print(_db.abt_cmd.package, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.nover != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nover:";
        bool_Print(_db.abt_cmd.nover, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.maxerr != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxerr:";
        u32_Print(_db.abt_cmd.maxerr, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.disas.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-disas:";
        command::disas_Print(_db.abt_cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (_db.abt_cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(_db.abt_cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    return execv(Zeroterm(_db.abt_path),argv);
}

// --- acr_ed.FDb.abt.ToCmdline
algo::tempstr acr_ed::abt_ToCmdline() {
    algo::tempstr retval;
    retval << _db.abt_path << " ";
    command::abt_PrintArgv(_db.abt_cmd,retval);
    if (ch_N(_db.abt_stdin)) {
        retval << " " << _db.abt_stdin;
    }
    if (ch_N(_db.abt_stdout)) {
        retval << " " << _db.abt_stdout;
    }
    if (ch_N(_db.abt_stderr)) {
        retval << " 2" << _db.abt_stderr;
    }
    return retval;
}

// --- acr_ed.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr acr_ed::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- acr_ed.FDb.trace.N
// Function return 1
inline static i32 acr_ed::trace_N() {
    return 1;
}

// --- acr_ed.FDb..Init
// Set all fields to initial values.
void acr_ed::FDb_Init() {
    // initialize LAry ns (acr_ed.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    acr_ed::FNs* ns_first = (acr_ed::FNs*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FNs;
    _db.ind_ns_n             	= 0; // (acr_ed.FDb.ind_ns)
    _db.ind_ns_buckets_n     	= 4; // (acr_ed.FDb.ind_ns)
    _db.ind_ns_buckets_elems 	= (acr_ed::FNs**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FNs*)*_db.ind_ns_buckets_n); // initial buckets (acr_ed.FDb.ind_ns)
    if (!_db.ind_ns_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ns)
    }
    memset(_db.ind_ns_buckets_elems, 0, sizeof(acr_ed::FNs*)*_db.ind_ns_buckets_n); // (acr_ed.FDb.ind_ns)
    // initialize LAry field (acr_ed.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    acr_ed::FField* field_first = (acr_ed::FField*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FField;
    _db.ind_field_n             	= 0; // (acr_ed.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (acr_ed.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (acr_ed::FField**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FField*)*_db.ind_field_buckets_n); // initial buckets (acr_ed.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(acr_ed::FField*)*_db.ind_field_buckets_n); // (acr_ed.FDb.ind_field)
    // initialize LAry ctype (acr_ed.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    acr_ed::FCtype* ctype_first = (acr_ed::FCtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FCtype;
    _db.ind_ctype_n             	= 0; // (acr_ed.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (acr_ed.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (acr_ed::FCtype**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (acr_ed.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(acr_ed::FCtype*)*_db.ind_ctype_buckets_n); // (acr_ed.FDb.ind_ctype)
    // initialize LAry ssimfile (acr_ed.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    acr_ed::FSsimfile* ssimfile_first = (acr_ed::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (acr_ed.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (acr_ed.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (acr_ed::FSsimfile**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (acr_ed.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(acr_ed::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (acr_ed.FDb.ind_ssimfile)
    // initialize LAry cstr (acr_ed.FDb.cstr)
    _db.cstr_n = 0;
    memset(_db.cstr_lary, 0, sizeof(_db.cstr_lary)); // zero out all level pointers
    acr_ed::FCstr* cstr_first = (acr_ed::FCstr*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FCstr) * (u64(1)<<4));
    if (!cstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cstr_lary[i]  = cstr_first;
        cstr_first    += 1ULL<<i;
    }
    _db.vis_elems 	= 0; // (acr_ed.FDb.vis)
    _db.vis_n     	= 0; // (acr_ed.FDb.vis)
    _db.vis_max   	= 0; // (acr_ed.FDb.vis)
    // initialize LAry listtype (acr_ed.FDb.listtype)
    _db.listtype_n = 0;
    memset(_db.listtype_lary, 0, sizeof(_db.listtype_lary)); // zero out all level pointers
    acr_ed::FListtype* listtype_first = (acr_ed::FListtype*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype) * (u64(1)<<4));
    if (!listtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.listtype_lary[i]  = listtype_first;
        listtype_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FListtype;
    _db.ind_listtype_n             	= 0; // (acr_ed.FDb.ind_listtype)
    _db.ind_listtype_buckets_n     	= 4; // (acr_ed.FDb.ind_listtype)
    _db.ind_listtype_buckets_elems 	= (acr_ed::FListtype**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FListtype*)*_db.ind_listtype_buckets_n); // initial buckets (acr_ed.FDb.ind_listtype)
    if (!_db.ind_listtype_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_listtype)
    }
    memset(_db.ind_listtype_buckets_elems, 0, sizeof(acr_ed::FListtype*)*_db.ind_listtype_buckets_n); // (acr_ed.FDb.ind_listtype)
    // initialize LAry fprefix (acr_ed.FDb.fprefix)
    _db.fprefix_n = 0;
    memset(_db.fprefix_lary, 0, sizeof(_db.fprefix_lary)); // zero out all level pointers
    acr_ed::FFprefix* fprefix_first = (acr_ed::FFprefix*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix) * (u64(1)<<4));
    if (!fprefix_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fprefix_lary[i]  = fprefix_first;
        fprefix_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FFprefix;
    _db.ind_fprefix_n             	= 0; // (acr_ed.FDb.ind_fprefix)
    _db.ind_fprefix_buckets_n     	= 4; // (acr_ed.FDb.ind_fprefix)
    _db.ind_fprefix_buckets_elems 	= (acr_ed::FFprefix**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FFprefix*)*_db.ind_fprefix_buckets_n); // initial buckets (acr_ed.FDb.ind_fprefix)
    if (!_db.ind_fprefix_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_fprefix)
    }
    memset(_db.ind_fprefix_buckets_elems, 0, sizeof(acr_ed::FFprefix*)*_db.ind_fprefix_buckets_n); // (acr_ed.FDb.ind_fprefix)
    // initialize LAry target (acr_ed.FDb.target)
    _db.target_n = 0;
    memset(_db.target_lary, 0, sizeof(_db.target_lary)); // zero out all level pointers
    acr_ed::FTarget* target_first = (acr_ed::FTarget*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget) * (u64(1)<<4));
    if (!target_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.target_lary[i]  = target_first;
        target_first    += 1ULL<<i;
    }
    // initialize hash table for acr_ed::FTarget;
    _db.ind_target_n             	= 0; // (acr_ed.FDb.ind_target)
    _db.ind_target_buckets_n     	= 4; // (acr_ed.FDb.ind_target)
    _db.ind_target_buckets_elems 	= (acr_ed::FTarget**)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTarget*)*_db.ind_target_buckets_n); // initial buckets (acr_ed.FDb.ind_target)
    if (!_db.ind_target_buckets_elems) {
        FatalErrorExit("out of memory"); // (acr_ed.FDb.ind_target)
    }
    memset(_db.ind_target_buckets_elems, 0, sizeof(acr_ed::FTarget*)*_db.ind_target_buckets_n); // (acr_ed.FDb.ind_target)
    _db.need_amc = bool(false);
    // initialize LAry targsrc (acr_ed.FDb.targsrc)
    _db.targsrc_n = 0;
    memset(_db.targsrc_lary, 0, sizeof(_db.targsrc_lary)); // zero out all level pointers
    acr_ed::FTargsrc* targsrc_first = (acr_ed::FTargsrc*)algo_lib::malloc_AllocMem(sizeof(acr_ed::FTargsrc) * (u64(1)<<4));
    if (!targsrc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targsrc_lary[i]  = targsrc_first;
        targsrc_first    += 1ULL<<i;
    }
    _db.abt_path = algo::strptr("bin/abt");
    _db.abt_pid = pid_t(0);
    _db.abt_timeout = i32(0);
    _db.abt_status = i32(0);

    acr_ed::InitReflection();
}

// --- acr_ed.FDb..Uninit
void acr_ed::FDb_Uninit() {
    acr_ed::FDb &row = _db; (void)row;

    // acr_ed.FDb.abt.Uninit (Exec)  //
    abt_Kill(); // kill child, ensure forward progress

    // acr_ed.FDb.targsrc.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_target.Uninit (Thash)  //
    // skip destruction of ind_target in global scope

    // acr_ed.FDb.target.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_fprefix.Uninit (Thash)  //
    // skip destruction of ind_fprefix in global scope

    // acr_ed.FDb.fprefix.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_listtype.Uninit (Thash)  //
    // skip destruction of ind_listtype in global scope

    // acr_ed.FDb.listtype.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.vis.Uninit (Tary)  //
    // remove all elements from acr_ed.FDb.vis
    vis_RemoveAll();
    // free memory for Tary acr_ed.FDb.vis
    algo_lib::malloc_FreeMem(_db.vis_elems, sizeof(algo::cstring)*_db.vis_max); // (acr_ed.FDb.vis)

    // acr_ed.FDb.cstr.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // acr_ed.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // acr_ed.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // acr_ed.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // acr_ed.FDb.ind_ns.Uninit (Thash)  //
    // skip destruction of ind_ns in global scope

    // acr_ed.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- acr_ed.FField.msghdr.CopyOut
// Copy fields out of row
void acr_ed::field_CopyOut(acr_ed::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- acr_ed.FField.msghdr.CopyIn
// Copy fields in to row
void acr_ed::field_CopyIn(acr_ed::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- acr_ed.FField.ctype.Get
algo::Smallstr50 acr_ed::ctype_Get(acr_ed::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- acr_ed.FField.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- acr_ed.FField.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- acr_ed.FField..Init
// Set all fields to initial values.
void acr_ed::FField_Init(acr_ed::FField& field) {
    field.reftype = algo::strptr("Val");
    field.p_ctype = NULL;
    field.rowid = u32(0);
    field.p_arg = NULL;
    field.p_ns = NULL;
    field.ctype_c_field_in_ary = bool(false);
    field.ind_field_next = (acr_ed::FField*)-1; // (acr_ed.FDb.ind_field) not-in-hash
}

// --- acr_ed.FField..Uninit
void acr_ed::FField_Uninit(acr_ed::FField& field) {
    acr_ed::FField &row = field; (void)row;
    ind_field_Remove(row); // remove field from index ind_field
    acr_ed::FCtype* p_ctype = acr_ed::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
}

// --- acr_ed.FFprefix.base.CopyOut
// Copy fields out of row
void acr_ed::fprefix_CopyOut(acr_ed::FFprefix &row, dmmeta::Fprefix &out) {
    out.fprefix = row.fprefix;
    out.reftype = row.reftype;
    out.comment = row.comment;
}

// --- acr_ed.FFprefix.base.CopyIn
// Copy fields in to row
void acr_ed::fprefix_CopyIn(acr_ed::FFprefix &row, dmmeta::Fprefix &in) {
    row.fprefix = in.fprefix;
    row.reftype = in.reftype;
    row.comment = in.comment;
}

// --- acr_ed.FFprefix..Uninit
void acr_ed::FFprefix_Uninit(acr_ed::FFprefix& fprefix) {
    acr_ed::FFprefix &row = fprefix; (void)row;
    ind_fprefix_Remove(row); // remove fprefix from index ind_fprefix
}

// --- acr_ed.FListtype.msghdr.CopyOut
// Copy fields out of row
void acr_ed::listtype_CopyOut(acr_ed::FListtype &row, dmmeta::Listtype &out) {
    out.listtype = row.listtype;
    out.circular = row.circular;
    out.haveprev = row.haveprev;
    out.instail = row.instail;
    out.comment = row.comment;
}

// --- acr_ed.FListtype.msghdr.CopyIn
// Copy fields in to row
void acr_ed::listtype_CopyIn(acr_ed::FListtype &row, dmmeta::Listtype &in) {
    row.listtype = in.listtype;
    row.circular = in.circular;
    row.haveprev = in.haveprev;
    row.instail = in.instail;
    row.comment = in.comment;
}

// --- acr_ed.FListtype..Uninit
void acr_ed::FListtype_Uninit(acr_ed::FListtype& listtype) {
    acr_ed::FListtype &row = listtype; (void)row;
    ind_listtype_Remove(row); // remove listtype from index ind_listtype
}

// --- acr_ed.FNs.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ns_CopyOut(acr_ed::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.comment = row.comment;
}

// --- acr_ed.FNs.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ns_CopyIn(acr_ed::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.comment = in.comment;
}

// --- acr_ed.FNs..Uninit
void acr_ed::FNs_Uninit(acr_ed::FNs& ns) {
    acr_ed::FNs &row = ns; (void)row;
    ind_ns_Remove(row); // remove ns from index ind_ns
}

// --- acr_ed.FSsimfile.msghdr.CopyOut
// Copy fields out of row
void acr_ed::ssimfile_CopyOut(acr_ed::FSsimfile &row, dmmeta::Ssimfile &out) {
    out.ssimfile = row.ssimfile;
    out.ctype = row.ctype;
}

// --- acr_ed.FSsimfile.msghdr.CopyIn
// Copy fields in to row
void acr_ed::ssimfile_CopyIn(acr_ed::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- acr_ed.FSsimfile.ssimns.Get
algo::Smallstr16 acr_ed::ssimns_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr_ed.FSsimfile.ns.Get
algo::Smallstr16 acr_ed::ns_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- acr_ed.FSsimfile.name.Get
algo::Smallstr50 acr_ed::name_Get(acr_ed::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- acr_ed.FSsimfile..Uninit
void acr_ed::FSsimfile_Uninit(acr_ed::FSsimfile& ssimfile) {
    acr_ed::FSsimfile &row = ssimfile; (void)row;
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
}

// --- acr_ed.FTarget.base.CopyOut
// Copy fields out of row
void acr_ed::target_CopyOut(acr_ed::FTarget &row, dev::Target &out) {
    out.target = row.target;
}

// --- acr_ed.FTarget.base.CopyIn
// Copy fields in to row
void acr_ed::target_CopyIn(acr_ed::FTarget &row, dev::Target &in) {
    row.target = in.target;
}

// --- acr_ed.FTarget..Uninit
void acr_ed::FTarget_Uninit(acr_ed::FTarget& target) {
    acr_ed::FTarget &row = target; (void)row;
    ind_target_Remove(row); // remove target from index ind_target
}

// --- acr_ed.FTargsrc.base.CopyOut
// Copy fields out of row
void acr_ed::targsrc_CopyOut(acr_ed::FTargsrc &row, dev::Targsrc &out) {
    out.targsrc = row.targsrc;
    out.comment = row.comment;
}

// --- acr_ed.FTargsrc.base.CopyIn
// Copy fields in to row
void acr_ed::targsrc_CopyIn(acr_ed::FTargsrc &row, dev::Targsrc &in) {
    row.targsrc = in.targsrc;
    row.comment = in.comment;
}

// --- acr_ed.FTargsrc.target.Get
algo::Smallstr16 acr_ed::target_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr16 ret(algo::Pathcomp(targsrc.targsrc, "/LL"));
    return ret;
}

// --- acr_ed.FTargsrc.src.Get
algo::Smallstr200 acr_ed::src_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr200 ret(algo::Pathcomp(targsrc.targsrc, "/LR"));
    return ret;
}

// --- acr_ed.FTargsrc.ext.Get
algo::Smallstr10 acr_ed::ext_Get(acr_ed::FTargsrc& targsrc) {
    algo::Smallstr10 ret(algo::Pathcomp(targsrc.targsrc, ".RR"));
    return ret;
}

// --- acr_ed.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr_ed::value_ToCstr(const acr_ed::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_ed_FieldId_value          : ret = "value";  break;
    }
    return ret;
}

// --- acr_ed.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr_ed::value_Print(const acr_ed::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr_ed.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr_ed::value_SetStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,acr_ed_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr_ed.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr_ed::value_SetStrptr(acr_ed::FieldId& parent, algo::strptr rhs, acr_ed_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr_ed.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr_ed::value_ReadStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr_ed.FieldId..ReadStrptrMaybe
// Read fields of acr_ed::FieldId from an ascii string.
// The format of the string is the format of the acr_ed::FieldId's only field
bool acr_ed::FieldId_ReadStrptrMaybe(acr_ed::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && acr_ed::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr_ed.FieldId..Print
// print string representation of acr_ed::FieldId to string LHS, no header -- cprint:acr_ed.FieldId.String
void acr_ed::FieldId_Print(acr_ed::FieldId & row, algo::cstring &str) {
    acr_ed::value_Print(row, str);
}

// --- acr_ed.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* acr_ed::value_ToCstr(const acr_ed::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case acr_ed_TableId_dmmeta_Cstr    : ret = "dmmeta.Cstr";  break;
        case acr_ed_TableId_dmmeta_Ctype   : ret = "dmmeta.Ctype";  break;
        case acr_ed_TableId_dmmeta_Field   : ret = "dmmeta.Field";  break;
        case acr_ed_TableId_dmmeta_Fprefix : ret = "dmmeta.Fprefix";  break;
        case acr_ed_TableId_dmmeta_Listtype: ret = "dmmeta.Listtype";  break;
        case acr_ed_TableId_dmmeta_Ns      : ret = "dmmeta.Ns";  break;
        case acr_ed_TableId_dmmeta_Ssimfile: ret = "dmmeta.Ssimfile";  break;
        case acr_ed_TableId_dev_Target     : ret = "dev.Target";  break;
        case acr_ed_TableId_dev_Targsrc    : ret = "dev.Targsrc";  break;
    }
    return ret;
}

// --- acr_ed.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void acr_ed::value_Print(const acr_ed::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- acr_ed.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool acr_ed::value_SetStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 9: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_Target); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,acr_ed_TableId_dev_target); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,acr_ed_TableId_dev_Targsrc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"src",3)==0) { value_SetEnum(parent,acr_ed_TableId_dev_targsrc); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Cstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_cstr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Field); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Fprefix); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_fprefix); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','L'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_Ssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','l'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,acr_ed_TableId_dmmeta_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- acr_ed.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void acr_ed::value_SetStrptr(acr_ed::TableId& parent, algo::strptr rhs, acr_ed_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- acr_ed.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool acr_ed::value_ReadStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- acr_ed.TableId..ReadStrptrMaybe
// Read fields of acr_ed::TableId from an ascii string.
// The format of the string is the format of the acr_ed::TableId's only field
bool acr_ed::TableId_ReadStrptrMaybe(acr_ed::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && acr_ed::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- acr_ed.TableId..Print
// print string representation of acr_ed::TableId to string LHS, no header -- cprint:acr_ed.TableId.String
void acr_ed::TableId_Print(acr_ed::TableId & row, algo::cstring &str) {
    acr_ed::value_Print(row, str);
}

// --- acr_ed...main
int main(int argc, char **argv) {
    try {
        algo_lib::FDb_Init();
        acr_ed::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::_db.epoll_fd = epoll_create(1);
        if (algo_lib::_db.epoll_fd == -1) {
            FatalErrorExit("epoll_create");
        }
        acr_ed::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:acr_ed
    } catch(algo_lib::ErrorX &x) {
        prerr("acr_ed.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        acr_ed::FDb_Uninit();
        algo_lib::FDb_Uninit();
    } catch(algo_lib::ErrorX &x) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    return algo_lib::_db.exit_code;
}

// --- acr_ed...SizeCheck
inline static void acr_ed::SizeCheck() {
}
