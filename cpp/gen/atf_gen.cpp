//
// cpp/gen/atf_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/atf_gen.h"
#include "include/gen/atf_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace atf { // gen:ns_print_proto
    static void          SizeCheck();
} // gen:ns_print_proto

// --- atf.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf::value_ToCstr(const atf::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_FieldId_value             : ret = "value";  break;
        case atf_FieldId_testrun           : ret = "testrun";  break;
        case atf_FieldId_testresult        : ret = "testresult";  break;
        case atf_FieldId_n_step            : ret = "n_step";  break;
        case atf_FieldId_n_cmp             : ret = "n_cmp";  break;
        case atf_FieldId_comment           : ret = "comment";  break;
    }
    return ret;
}

// --- atf.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf::value_Print(const atf::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf::value_SetStrptrMaybe(atf::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('n','_','c','m','p'): {
                    value_SetEnum(parent,atf_FieldId_n_cmp); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,atf_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('n','_','s','t','e','p'): {
                    value_SetEnum(parent,atf_FieldId_n_step); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,atf_FieldId_comment); ret = true; break;
                }
                case LE_STR7('t','e','s','t','r','u','n'): {
                    value_SetEnum(parent,atf_FieldId_testrun); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('t','e','s','t','r','e','s','u'): {
                    if (memcmp(rhs.elems+8,"lt",2)==0) { value_SetEnum(parent,atf_FieldId_testresult); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf::value_SetStrptr(atf::FieldId& parent, algo::strptr rhs, atf_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf::value_ReadStrptrMaybe(atf::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf.FieldId..ReadStrptrMaybe
// Read fields of atf::FieldId from an ascii string.
// The format of the string is the format of the atf::FieldId's only field
bool atf::FieldId_ReadStrptrMaybe(atf::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && atf::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf.FieldId..Print
// print string representation of atf::FieldId to string LHS, no header -- cprint:atf.FieldId.String
void atf::FieldId_Print(atf::FieldId & row, algo::cstring &str) {
    atf::value_Print(row, str);
}

// --- atf.Protocol.proto.StaticCheck
void atf::StaticCheck() {
    algo_assert(_offset_of(atf::FieldId, value) + sizeof(((atf::FieldId*)0)->value) == sizeof(atf::FieldId));
}

// --- atf.Testresult.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atf::value_ToCstr(const atf::Testresult& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atf_Testresult_UNTESTED       : ret = "UNTESTED";  break;
        case atf_Testresult_UNTESTED_PREPERROR: ret = "UNTESTED_PREPERROR";  break;
        case atf_Testresult_UNRESOLVED     : ret = "UNRESOLVED";  break;
        case atf_Testresult_PASSED         : ret = "PASSED";  break;
        case atf_Testresult_FAILED         : ret = "FAILED";  break;
        case atf_Testresult_TIMEOUT        : ret = "TIMEOUT";  break;
    }
    return ret;
}

// --- atf.Testresult.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atf::value_Print(const atf::Testresult& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atf.Testresult.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atf::value_SetStrptrMaybe(atf::Testresult& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('F','A','I','L','E','D'): {
                    value_SetEnum(parent,atf_Testresult_FAILED); ret = true; break;
                }
                case LE_STR6('P','A','S','S','E','D'): {
                    value_SetEnum(parent,atf_Testresult_PASSED); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('T','I','M','E','O','U','T'): {
                    value_SetEnum(parent,atf_Testresult_TIMEOUT); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('U','N','T','E','S','T','E','D'): {
                    value_SetEnum(parent,atf_Testresult_UNTESTED); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('U','N','R','E','S','O','L','V'): {
                    if (memcmp(rhs.elems+8,"ED",2)==0) { value_SetEnum(parent,atf_Testresult_UNRESOLVED); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('U','N','T','E','S','T','E','D'): {
                    if (memcmp(rhs.elems+8,"_PREPERROR",10)==0) { value_SetEnum(parent,atf_Testresult_UNTESTED_PREPERROR); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atf.Testresult.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atf::value_SetStrptr(atf::Testresult& parent, algo::strptr rhs, atf_TestresultEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atf.Testresult.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atf::value_ReadStrptrMaybe(atf::Testresult& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atf.Testresult..ReadStrptrMaybe
// Read fields of atf::Testresult from an ascii string.
// The format of the string is the format of the atf::Testresult's only field
bool atf::Testresult_ReadStrptrMaybe(atf::Testresult &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && atf::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atf.Testresult..Print
// print string representation of atf::Testresult to string LHS, no header -- cprint:atf.Testresult.String
void atf::Testresult_Print(atf::Testresult & row, algo::cstring &str) {
    atf::value_Print(row, str);
}

// --- atf.Testrun..ReadFieldMaybe
bool atf::Testrun_ReadFieldMaybe(atf::Testrun &parent, algo::strptr field, algo::strptr strval) {
    atf::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atf_FieldId_testrun: retval = algo::Smallstr50_ReadStrptrMaybe(parent.testrun, strval); break;
        case atf_FieldId_testresult: retval = atf::Testresult_ReadStrptrMaybe(parent.testresult, strval); break;
        case atf_FieldId_n_step: retval = u64_ReadStrptrMaybe(parent.n_step, strval); break;
        case atf_FieldId_n_cmp: retval = u64_ReadStrptrMaybe(parent.n_cmp, strval); break;
        case atf_FieldId_comment: retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atf.Testrun..ReadStrptrMaybe
// Read fields of atf::Testrun from an ascii string.
// The format of the string is an ssim Tuple
bool atf::Testrun_ReadStrptrMaybe(atf::Testrun &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atf.Testrun");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Testrun_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atf.Testrun..Print
// print string representation of atf::Testrun to string LHS, no header -- cprint:atf.Testrun.String
void atf::Testrun_Print(atf::Testrun & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atf.Testrun";

    algo::Smallstr50_Print(row.testrun, temp);
    PrintAttrSpaceReset(str,"testrun", temp);

    atf::Testresult_Print(row.testresult, temp);
    PrintAttrSpaceReset(str,"testresult", temp);

    u64_Print(row.n_step, temp);
    PrintAttrSpaceReset(str,"n_step", temp);

    u64_Print(row.n_cmp, temp);
    PrintAttrSpaceReset(str,"n_cmp", temp);

    algo::cstring_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atf...SizeCheck
inline static void atf::SizeCheck() {
}
