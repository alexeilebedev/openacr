//
// cpp/gen/lib_json_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace lib_json { // gen:ns_print_proto
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- lib_json.trace..Print
// print string representation of lib_json::trace to string LHS, no header -- cprint:lib_json.trace.String
void lib_json::trace_Print(lib_json::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_json.trace";

    u64_Print(row.alloc__db_node, temp);
    PrintAttrSpaceReset(str,"alloc__db_node", temp);

    u64_Print(row.del__db_node, temp);
    PrintAttrSpaceReset(str,"del__db_node", temp);
}

// --- lib_json.FDb.lpool.FreeMem
// Free block of memory previously returned by Lpool.
void lib_json::lpool_FreeMem(void *mem, u64 size) {
    if (mem) {
        size = u64_Max(size,16); // enforce alignment
        u64 cell = algo::u64_BitScanReverse(size-1) + 1;
        lpool_Lpblock *temp = (lpool_Lpblock*)mem; // push  singly linked list
        temp->next = _db.lpool_free[cell];
        _db.lpool_free[cell] = temp;
    }
}

// --- lib_json.FDb.lpool.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void* lib_json::lpool_AllocMem(u64 size) {
    size     = u64_Max(size,16); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1)+1;
    u64 i    = cell;
    u8 *retval = NULL;
    // try to find a block that's at least as large as required.
    // if found, remove from free list
    for (; i < 31; i++) {
        lpool_Lpblock *blk = _db.lpool_free[i];
        if (blk) {
            _db.lpool_free[i] = blk->next;
            retval = (u8*)blk;
            break;
        }
    }
    // if suitable size block is not found, create a new one
    // by requesting a block from the base allocator.
    if (UNLIKELY(!retval)) {
        i = u64_Max(cell, 21); // 2MB min -- allow huge page to be used
        retval = (u8*)algo_lib::sbrk_AllocMem(1<<i);
    }
    if (LIKELY(retval)) {
        // if block is more than 2x as large as needed, return the upper half to the free
        // list (repeatedly). meanwhile, retval doesn't change.
        while (i > cell) {
            i--;
            int half = 1<<i;
            lpool_Lpblock *blk = (lpool_Lpblock*)(retval + half);
            blk->next = _db.lpool_free[i];
            _db.lpool_free[i] = blk;
        }
    }
    return retval;
}

// --- lib_json.FDb.lpool.ReserveBuffers
// Add N buffers of some size to the free store
bool lib_json::lpool_ReserveBuffers(int nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 16);
    for (int i = 0; i < nbuf; i++) {
        u64     cell = algo::u64_BitScanReverse(bufsize-1)+1;
        u64     size = 1ULL<<cell;
        lpool_Lpblock *temp = (lpool_Lpblock*)algo_lib::sbrk_AllocMem(size);
        if (temp == NULL) {
            retval = false;
            break;// why continue?
        } else {
            temp->next = _db.lpool_free[cell];
            _db.lpool_free[cell] = temp;
        }
    }
    return retval;
}

// --- lib_json.FDb.lpool.ReallocMem
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void* lib_json::lpool_ReallocMem(void *oldmem, u64 old_size, u64 new_size) {
    void* ret = oldmem;
    if (new_size != old_size) {
        ret = lpool_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            lpool_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- lib_json.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void lib_json::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("lib_json", NULL, NULL, NULL, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "lib_json.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(lib_json::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)lib_json::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
}

// --- lib_json.FDb._db.StaticCheck
void lib_json::StaticCheck() {
    algo_assert(_offset_of(lib_json::trace, del__db_node) + sizeof(((lib_json::trace*)0)->del__db_node) == sizeof(lib_json::trace));
    algo_assert(_offset_of(lib_json::FieldId, value) + sizeof(((lib_json::FieldId*)0)->value) == sizeof(lib_json::FieldId));
}

// --- lib_json.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool lib_json::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    (void)str;//only to avoid -Wunused-parameter
    return retval;
}

// --- lib_json.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool lib_json::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    (void)root;//only to avoid -Wunused-parameter
    return retval;
}

// --- lib_json.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool lib_json::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, lib_json::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- lib_json.FDb._db.Steps
// Calls Step function of dependencies
void lib_json::Steps() {
}

// --- lib_json.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_json::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- lib_json.FDb.node.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
lib_json::FNode& lib_json::node_Alloc() {
    lib_json::FNode* row = node_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("lib_json.out_of_mem  field:lib_json.FDb.node  comment:'Alloc failed'");
    }
    return *row;
}

// --- lib_json.FDb.node.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
lib_json::FNode* lib_json::node_AllocMaybe() {
    lib_json::FNode *row = (lib_json::FNode*)node_AllocMem();
    if (row) {
        new (row) lib_json::FNode; // call constructor
        ++lib_json::_db.trace.alloc__db_node;
    }
    return row;
}

// --- lib_json.FDb.node.Delete
// Remove row from all global and cross indices, then deallocate row
void lib_json::node_Delete(lib_json::FNode &row) {
    row.~FNode();
    node_FreeMem(row);
    ++lib_json::_db.trace.del__db_node;
}

// --- lib_json.FDb.node.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* lib_json::node_AllocMem() {
    lib_json::FNode *row = _db.node_free;
    if (UNLIKELY(!row)) {
        node_Reserve(1);
        row = _db.node_free;
    }
    if (row) {
        _db.node_free = row->node_next;
    }
    return row;
}

// --- lib_json.FDb.node.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void lib_json::node_FreeMem(lib_json::FNode &row) {
    if (UNLIKELY(row.node_next != (lib_json::FNode*)-1)) {
        FatalErrorExit("lib_json.tpool_double_delete  pool:lib_json.FDb.node  comment:'double deletion caught'");
    }
    row.node_next = _db.node_free; // insert into free list
    _db.node_free  = &row;
}

// --- lib_json.FDb.node.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 lib_json::node_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.node_blocksize; // underlying allocator is probably Lpool
        u64 reserved = node_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- lib_json.FDb.node.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 lib_json::node_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(lib_json::FNode)) {
        lib_json::FNode *mem = (lib_json::FNode*)lib_json::lpool_AllocMem(size);
        ret = mem ? size / sizeof(lib_json::FNode) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].node_next = _db.node_free;
            _db.node_free = mem+i;
        }
    }
    return ret;
}

// --- lib_json.FDb.node.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool lib_json::node_XrefMaybe(lib_json::FNode &row) {
    bool retval = true;
    (void)row;
    // insert node into index ind_objfld
    if ((NULL!=fldkey_Get(row).object)) { // user-defined insert condition
        bool success = ind_objfld_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "lib_json.duplicate_key  xref:lib_json.FDb.ind_objfld"; // check for duplicate key
            return false;
        }
    }
    lib_json::FNode* p_p_parent = row.p_parent;
    if (UNLIKELY(!p_p_parent)) {
        algo_lib::ResetErrtext() << "lib_json.null_ref  xref:lib_json.FNode.c_child";
        return false;
    }
    // insert node into index c_child
    if (row.p_parent != &row) { // user-defined insert condition
        c_child_Insert(*p_p_parent, row);
    }
    return retval;
}

// --- lib_json.FDb.ind_objfld.Find
// Find row by key. Return NULL if not found.
lib_json::FNode* lib_json::ind_objfld_Find(const lib_json::FldKey& key) {
    u32 index = lib_json::FldKey_Hash(0, key) & (_db.ind_objfld_buckets_n - 1);
    lib_json::FNode* *e = &_db.ind_objfld_buckets_elems[index];
    lib_json::FNode* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || fldkey_Get((*ret)) == key;
        if (done) break;
        e         = &ret->ind_objfld_next;
    } while (true);
    return ret;
}

// --- lib_json.FDb.ind_objfld.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool lib_json::ind_objfld_InsertMaybe(lib_json::FNode& row) {
    ind_objfld_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_objfld_next == (lib_json::FNode*)-1)) {// check if in hash already
        u32 index = lib_json::FldKey_Hash(0, fldkey_Get(row)) & (_db.ind_objfld_buckets_n - 1);
        lib_json::FNode* *prev = &_db.ind_objfld_buckets_elems[index];
        do {
            lib_json::FNode* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if (fldkey_Get((*ret)) == fldkey_Get(row)) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_objfld_next;
        } while (true);
        if (retval) {
            row.ind_objfld_next = *prev;
            _db.ind_objfld_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- lib_json.FDb.ind_objfld.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void lib_json::ind_objfld_Remove(lib_json::FNode& row) {
    if (LIKELY(row.ind_objfld_next != (lib_json::FNode*)-1)) {// check if in hash already
        u32 index = lib_json::FldKey_Hash(0, fldkey_Get(row)) & (_db.ind_objfld_buckets_n - 1);
        lib_json::FNode* *prev = &_db.ind_objfld_buckets_elems[index]; // addr of pointer to current element
        while (lib_json::FNode *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_objfld_next; // unlink (singly linked list)
                _db.ind_objfld_n--;
                row.ind_objfld_next = (lib_json::FNode*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_objfld_next;
        }
    }
}

// --- lib_json.FDb.ind_objfld.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void lib_json::ind_objfld_Reserve(int n) {
    u32 old_nbuckets = _db.ind_objfld_buckets_n;
    u32 new_nelems   = _db.ind_objfld_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(lib_json::FNode*);
        u32 new_size = new_nbuckets * sizeof(lib_json::FNode*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        lib_json::FNode* *new_buckets = (lib_json::FNode**)lib_json::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("lib_json.out_of_memory  field:lib_json.FDb.ind_objfld");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_objfld_buckets_n; i++) {
            lib_json::FNode* elem = _db.ind_objfld_buckets_elems[i];
            while (elem) {
                lib_json::FNode &row        = *elem;
                lib_json::FNode* next       = row.ind_objfld_next;
                u32 index          = lib_json::FldKey_Hash(0, fldkey_Get(row)) & (new_nbuckets-1);
                row.ind_objfld_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        lib_json::lpool_FreeMem(_db.ind_objfld_buckets_elems, old_size);
        _db.ind_objfld_buckets_elems = new_buckets;
        _db.ind_objfld_buckets_n = new_nbuckets;
    }
}

// --- lib_json.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr lib_json::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- lib_json.FDb.trace.N
// Function return 1
inline static i32 lib_json::trace_N() {
    return 1;
}

// --- lib_json.FDb..Init
// Set all fields to initial values.
void lib_json::FDb_Init() {
    _db.lpool_lock = 0;
    memset(_db.lpool_free, 0, sizeof(_db.lpool_free));
    // node: initialize Tpool
    _db.node_free      = NULL;
    _db.node_blocksize = algo::BumpToPow2(64 * sizeof(lib_json::FNode)); // allocate 64-127 elements at a time
    // initialize hash table for lib_json::FNode;
    _db.ind_objfld_n             	= 0; // (lib_json.FDb.ind_objfld)
    _db.ind_objfld_buckets_n     	= 4; // (lib_json.FDb.ind_objfld)
    _db.ind_objfld_buckets_elems 	= (lib_json::FNode**)lib_json::lpool_AllocMem(sizeof(lib_json::FNode*)*_db.ind_objfld_buckets_n); // initial buckets (lib_json.FDb.ind_objfld)
    if (!_db.ind_objfld_buckets_elems) {
        FatalErrorExit("out of memory"); // (lib_json.FDb.ind_objfld)
    }
    memset(_db.ind_objfld_buckets_elems, 0, sizeof(lib_json::FNode*)*_db.ind_objfld_buckets_n); // (lib_json.FDb.ind_objfld)

    lib_json::InitReflection();
}

// --- lib_json.FDb..Uninit
void lib_json::FDb_Uninit() {
    lib_json::FDb &row = _db; (void)row;

    // lib_json.FDb.ind_objfld.Uninit (Thash)  //
    // skip destruction of ind_objfld in global scope
}

// --- lib_json.FldKey..Print
// print string representation of lib_json::FldKey to string LHS, no header -- cprint:lib_json.FldKey.String
void lib_json::FldKey_Print(lib_json::FldKey & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_json.FldKey";

    u64_PrintHex(u64((const lib_json::FNode*)row.object), temp, 8, true);
    PrintAttrSpaceReset(str,"object", temp);
}

// --- lib_json.FNode.c_child.Cascdel
// Delete all elements pointed to by the index.
void lib_json::c_child_Cascdel(lib_json::FNode& node) {
    // Clear c_child_n so that calls to lib_json.FNode.c_child.Remove do not have to scan
    // the array for pointers or shift anything.
    // This is somewhat of a hack.
    i32 n = node.c_child_n;
    node.c_child_n = 0;
    for (i32 i = n - 1; i >= 0; i--) {
        lib_json::FNode &row = *node.c_child_elems[i];
        row.node_c_child_in_ary = false;
        node_Delete(row);
    }
}

// --- lib_json.FNode.c_child.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void lib_json::c_child_Insert(lib_json::FNode& node, lib_json::FNode& row) {
    if (bool_Update(row.node_c_child_in_ary,true)) {
        // reserve space
        c_child_Reserve(node, 1);
        u32 n  = node.c_child_n;
        u32 at = n;
        lib_json::FNode* *elems = node.c_child_elems;
        elems[at] = &row;
        node.c_child_n = n+1;

    }
}

// --- lib_json.FNode.c_child.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool lib_json::c_child_InsertMaybe(lib_json::FNode& node, lib_json::FNode& row) {
    bool retval = !row.node_c_child_in_ary;
    c_child_Insert(node,row); // check is performed in _Insert again
    return retval;
}

// --- lib_json.FNode.c_child.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void lib_json::c_child_Remove(lib_json::FNode& node, lib_json::FNode& row) {
    if (bool_Update(row.node_c_child_in_ary,false)) {
        int lim = node.c_child_n;
        lib_json::FNode* *elems = node.c_child_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            lib_json::FNode* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(lib_json::FNode*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                node.c_child_n = lim - 1;
                break;
            }
        }
    }
}

// --- lib_json.FNode.c_child.Reserve
// Reserve space in index for N more elements;
void lib_json::c_child_Reserve(lib_json::FNode& node, u32 n) {
    u32 old_max = node.c_child_max;
    if (UNLIKELY(node.c_child_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(lib_json::FNode*);
        u32 new_size = new_max * sizeof(lib_json::FNode*);
        void *new_mem = lib_json::lpool_ReallocMem(node.c_child_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("lib_json.out_of_memory  field:lib_json.FNode.c_child");
        }
        node.c_child_elems = (lib_json::FNode**)new_mem;
        node.c_child_max = new_max;
    }
}

// --- lib_json.FNode.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_json::type_ToCstr(const lib_json::FNode& node) {
    const char *ret = NULL;
    switch(type_GetEnum(node)) {
        case lib_json_FNode_type_null      : ret = "null";  break;
        case lib_json_FNode_type_false     : ret = "false";  break;
        case lib_json_FNode_type_true      : ret = "true";  break;
        case lib_json_FNode_type_string    : ret = "string";  break;
        case lib_json_FNode_type_number    : ret = "number";  break;
        case lib_json_FNode_type_array     : ret = "array";  break;
        case lib_json_FNode_type_object    : ret = "object";  break;
        case lib_json_FNode_type_field     : ret = "field";  break;
    }
    return ret;
}

// --- lib_json.FNode.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void lib_json::type_Print(const lib_json::FNode& node, algo::cstring &lhs) {
    const char *strval = type_ToCstr(node);
    if (strval) {
        lhs << strval;
    } else {
        lhs << node.type;
    }
}

// --- lib_json.FNode.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_json::type_SetStrptrMaybe(lib_json::FNode& node, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('n','u','l','l'): {
                    type_SetEnum(node,lib_json_FNode_type_null); ret = true; break;
                }
                case LE_STR4('t','r','u','e'): {
                    type_SetEnum(node,lib_json_FNode_type_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','r','r','a','y'): {
                    type_SetEnum(node,lib_json_FNode_type_array); ret = true; break;
                }
                case LE_STR5('f','a','l','s','e'): {
                    type_SetEnum(node,lib_json_FNode_type_false); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    type_SetEnum(node,lib_json_FNode_type_field); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('n','u','m','b','e','r'): {
                    type_SetEnum(node,lib_json_FNode_type_number); ret = true; break;
                }
                case LE_STR6('o','b','j','e','c','t'): {
                    type_SetEnum(node,lib_json_FNode_type_object); ret = true; break;
                }
                case LE_STR6('s','t','r','i','n','g'): {
                    type_SetEnum(node,lib_json_FNode_type_string); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_json.FNode.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_json::type_SetStrptr(lib_json::FNode& node, algo::strptr rhs, lib_json_FNode_type_Enum dflt) {
    if (!type_SetStrptrMaybe(node,rhs)) type_SetEnum(node,dflt);
}

// --- lib_json.FNode..Uninit
void lib_json::FNode_Uninit(lib_json::FNode& node) {
    lib_json::FNode &row = node; (void)row;
    c_child_Cascdel(node); // dmmeta.cascdel:lib_json.FNode.c_child
    ind_objfld_Remove(row); // remove node from index ind_objfld
    lib_json::FNode* p_p_parent = row.p_parent;
    if (p_p_parent)  {
        c_child_Remove(*p_p_parent, row);// remove node from index c_child
    }

    // lib_json.FNode.c_child.Uninit (Ptrary)  //Child node(s)
    lib_json::lpool_FreeMem(node.c_child_elems, sizeof(lib_json::FNode*)*node.c_child_max); // (lib_json.FNode.c_child)
}

// --- lib_json.FNode..Print
// print string representation of lib_json::FNode to string LHS, no header -- cprint:lib_json.FNode.String
void lib_json::FNode_Print(lib_json::FNode & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_json.FNode";

    lib_json::type_Print(row, temp);
    PrintAttrSpaceReset(str,"type", temp);

    algo::cstring_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    bool_Print(row.node_c_child_in_ary, temp);
    PrintAttrSpaceReset(str,"node_c_child_in_ary", temp);
}

// --- lib_json.FParser.state.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_json::state_ToCstr(const lib_json::FParser& parent) {
    const char *ret = NULL;
    switch(state_GetEnum(parent)) {
        case lib_json_FParser_state_ws     : ret = "ws";  break;
        case lib_json_FParser_state_value  : ret = "value";  break;
        case lib_json_FParser_state_number : ret = "number";  break;
        case lib_json_FParser_state_str    : ret = "str";  break;
        case lib_json_FParser_state_str_esc: ret = "str_esc";  break;
        case lib_json_FParser_state_str_uesc: ret = "str_uesc";  break;
        case lib_json_FParser_state_str_usurr1: ret = "str_usurr1";  break;
        case lib_json_FParser_state_str_usurr2: ret = "str_usurr2";  break;
        case lib_json_FParser_state_token  : ret = "token";  break;
        case lib_json_FParser_state_sec_line: ret = "sec_line";  break;
        case lib_json_FParser_state_err    : ret = "err";  break;
    }
    return ret;
}

// --- lib_json.FParser.state.Print
// Convert state to a string. First, attempt conversion to a known string.
// If no string matches, print state as a numeric value.
void lib_json::state_Print(const lib_json::FParser& parent, algo::cstring &lhs) {
    const char *strval = state_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.state;
    }
}

// --- lib_json.FParser.state.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_json::state_SetStrptrMaybe(lib_json::FParser& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('w','s'): {
                    state_SetEnum(parent,lib_json_FParser_state_ws); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('e','r','r'): {
                    state_SetEnum(parent,lib_json_FParser_state_err); ret = true; break;
                }
                case LE_STR3('s','t','r'): {
                    state_SetEnum(parent,lib_json_FParser_state_str); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('t','o','k','e','n'): {
                    state_SetEnum(parent,lib_json_FParser_state_token); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    state_SetEnum(parent,lib_json_FParser_state_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('n','u','m','b','e','r'): {
                    state_SetEnum(parent,lib_json_FParser_state_number); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('s','t','r','_','e','s','c'): {
                    state_SetEnum(parent,lib_json_FParser_state_str_esc); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','e','c','_','l','i','n','e'): {
                    state_SetEnum(parent,lib_json_FParser_state_sec_line); ret = true; break;
                }
                case LE_STR8('s','t','r','_','u','e','s','c'): {
                    state_SetEnum(parent,lib_json_FParser_state_str_uesc); ret = true; break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','r','_','u','s','u','r'): {
                    if (memcmp(rhs.elems+8,"r1",2)==0) { state_SetEnum(parent,lib_json_FParser_state_str_usurr1); ret = true; break; }
                    if (memcmp(rhs.elems+8,"r2",2)==0) { state_SetEnum(parent,lib_json_FParser_state_str_usurr2); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_json.FParser.state.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_json::state_SetStrptr(lib_json::FParser& parent, algo::strptr rhs, lib_json_FParser_state_Enum dflt) {
    if (!state_SetStrptrMaybe(parent,rhs)) state_SetEnum(parent,dflt);
}

// --- lib_json.FParser..Init
// Set all fields to initial values.
void lib_json::FParser_Init(lib_json::FParser& parent) {
    parent.ind = i32(0);
    parent.node = NULL;
    parent.root_node = NULL;
    parent.state = u32(0);
    parent.need_comma = bool(false);
    parent.have_comma = bool(false);
    parent.need_colon = bool(false);
    parent.err_offset = i32(0);
    parent.offset = i32(0);
    parent.uesc_value = u32(0);
    parent.uesc_need = u8(0);
}

// --- lib_json.FParser..Uninit
void lib_json::FParser_Uninit(lib_json::FParser& parent) {
    lib_json::FParser &row = parent; (void)row;
    root_node_Cleanup(parent); // dmmeta.fcleanup:lib_json.FParser.root_node
}

// --- lib_json.FParser..Print
// print string representation of lib_json::FParser to string LHS, no header -- cprint:lib_json.FParser.String
void lib_json::FParser_Print(lib_json::FParser & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "lib_json.FParser";

    i32_Print(row.ind, temp);
    PrintAttrSpaceReset(str,"ind", temp);

    u64_PrintHex(u64((const lib_json::FNode*)row.node), temp, 8, true);
    PrintAttrSpaceReset(str,"node", temp);

    u64_PrintHex(u64((const lib_json::FNode*)row.root_node), temp, 8, true);
    PrintAttrSpaceReset(str,"root_node", temp);

    lib_json::state_Print(row, temp);
    PrintAttrSpaceReset(str,"state", temp);

    bool_Print(row.need_comma, temp);
    PrintAttrSpaceReset(str,"need_comma", temp);

    bool_Print(row.have_comma, temp);
    PrintAttrSpaceReset(str,"have_comma", temp);

    bool_Print(row.need_colon, temp);
    PrintAttrSpaceReset(str,"need_colon", temp);

    algo::cstring_Print(row.err_info, temp);
    PrintAttrSpaceReset(str,"err_info", temp);

    i32_Print(row.err_offset, temp);
    PrintAttrSpaceReset(str,"err_offset", temp);

    i32_Print(row.offset, temp);
    PrintAttrSpaceReset(str,"offset", temp);

    u32_Print(row.uesc_value, temp);
    PrintAttrSpaceReset(str,"uesc_value", temp);

    u8_Print(row.uesc_need, temp);
    PrintAttrSpaceReset(str,"uesc_need", temp);

    algo::cstring_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);
}

// --- lib_json.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* lib_json::value_ToCstr(const lib_json::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case lib_json_FieldId_value        : ret = "value";  break;
    }
    return ret;
}

// --- lib_json.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void lib_json::value_Print(const lib_json::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- lib_json.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool lib_json::value_SetStrptrMaybe(lib_json::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,lib_json_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- lib_json.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void lib_json::value_SetStrptr(lib_json::FieldId& parent, algo::strptr rhs, lib_json_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- lib_json.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool lib_json::value_ReadStrptrMaybe(lib_json::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- lib_json.FieldId..ReadStrptrMaybe
// Read fields of lib_json::FieldId from an ascii string.
// The format of the string is the format of the lib_json::FieldId's only field
bool lib_json::FieldId_ReadStrptrMaybe(lib_json::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- lib_json.FieldId..Print
// print string representation of lib_json::FieldId to string LHS, no header -- cprint:lib_json.FieldId.String
void lib_json::FieldId_Print(lib_json::FieldId & row, algo::cstring &str) {
    lib_json::value_Print(row, str);
}

// --- lib_json...SizeCheck
inline static void lib_json::SizeCheck() {
}
