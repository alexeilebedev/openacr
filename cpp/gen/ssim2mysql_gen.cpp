//
// cpp/gen/ssim2mysql_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/ssim2mysql_gen.h"
#include "include/gen/ssim2mysql_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/lib_mysql_gen.h"
#include "include/gen/lib_mysql_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb     lib_json::_db;      // dependency found via dev.targdep
algo_lib::FDb     algo_lib::_db;      // dependency found via dev.targdep
lib_mysql::FDb    lib_mysql::_db;     // dependency found via dev.targdep
ssim2mysql::FDb   ssim2mysql::_db;    // dependency found via dev.targdep

namespace ssim2mysql {
const char *ssim2mysql_help =
"ssim2mysql: Ssim -> mysql\n"
"Usage: ssim2mysql [options]\n"
"    OPTION      TYPE    DFLT    COMMENT\n"
"    -url        string  \"\"      URL of mysql server. user:pass@hostb or sock://filename; Empty -> stdout\n"
"    -data_dir   string  \"data\"  Load dmmeta info from this directory\n"
"    -maxpacket  int     100000  Max Mysql packet size\n"
"    -replace            Y       use REPLACE INTO instead of INSERT INTO\n"
"    -trunc                      Truncate target table\n"
"    -dry_run                    Print SQL commands to the stdout\n"
"    -fldfunc                    create columns for fldfuncs\n"
"    -in         string  \"-\"     Input directory or filename, - for stdin\n"
"    -db         string  \"\"      Optional database name\n"
"    -createdb                   Emit CREATE DATABASE code for namespace specified with <db>\n"
"    -fkey                       Enable foreign key constraints (uses InnoDB storage engine)\n"
"    -verbose    int             Verbosity level (0..255); alias -v; cumulative\n"
"    -debug      int             Debug level (0..255); alias -d; cumulative\n"
"    -help                       Print help an exit; alias -h\n"
"    -version                    Print version and exit\n"
"    -signature                  Show signatures and exit; alias -sig\n"
;


} // namespace ssim2mysql
namespace ssim2mysql { // gen:ns_print_proto
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    static bool          sqltype_InputMaybe(dmmeta::Sqltype &elem) __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          substr_InputMaybe(dmmeta::Substr &elem) __attribute__((nothrow));
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    // First element of index changed.
    static void          zs_cmd_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          zs_cmd_UpdateCycles() __attribute__((nothrow));
    static void          zs_cmd_Call() __attribute__((nothrow));
    // First element of index changed.
    static void          cd_input_line_FirstChanged() __attribute__((nothrow));
    // Update cycles count from previous clock capture
    static void          cd_input_line_UpdateCycles() __attribute__((nothrow));
    static void          cd_input_line_Call() __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Internal function to scan for a message
    //
    static void          in_buf_Scanmsg(ssim2mysql::FInput& input) __attribute__((nothrow));
    // Internal function to shift data left
    // Shift existing bytes over to the beginning of the buffer
    static void          in_buf_Shift(ssim2mysql::FInput& input) __attribute__((nothrow));
    static void          SizeCheck();
} // gen:ns_print_proto

// --- ssim2mysql.FCmd..Uninit
void ssim2mysql::FCmd_Uninit(ssim2mysql::FCmd& cmd) {
    ssim2mysql::FCmd &row = cmd; (void)row;
    zs_cmd_Remove(row); // remove cmd from index zs_cmd
}

// --- ssim2mysql.FCmd..Print
// print string representation of ssim2mysql::FCmd to string LHS, no header -- cprint:ssim2mysql.FCmd.String
void ssim2mysql::FCmd_Print(ssim2mysql::FCmd & row, algo::cstring &str) {
    algo::cstring_Print(row.cmd, str);
}

// --- ssim2mysql.FColumn.name.Get
algo::Smallstr50 ssim2mysql::name_Get(ssim2mysql::FColumn& column) {
    algo::Smallstr50 ret(algo::Pathcomp(column.column, ".RR"));
    return ret;
}

// --- ssim2mysql.FColumn.ssimfile.Get
algo::Smallstr50 ssim2mysql::ssimfile_Get(ssim2mysql::FColumn& column) {
    algo::Smallstr50 ret(algo::Pathcomp(column.column, ".RL"));
    return ret;
}

// --- ssim2mysql.FColumn..Concat_ssimfile_name
tempstr ssim2mysql::FColumn_Concat_ssimfile_name( const algo::strptr& ssimfile ,const algo::strptr& name ) {
    return tempstr() << ssimfile <<'.'<< name ;
}

// --- ssim2mysql.FColumn..Uninit
void ssim2mysql::FColumn_Uninit(ssim2mysql::FColumn& column) {
    ssim2mysql::FColumn &row = column; (void)row;
    ind_column_Remove(row); // remove column from index ind_column
    ssim2mysql::FSsimfile* p_ssimfile = ssim2mysql::ind_ssimfile_Find(ssimfile_Get(row));
    if (p_ssimfile)  {
        c_column_Remove(*p_ssimfile, row);// remove column from index c_column
    }
}

// --- ssim2mysql.FColumn..Print
// print string representation of ssim2mysql::FColumn to string LHS, no header -- cprint:ssim2mysql.FColumn.String
void ssim2mysql::FColumn_Print(ssim2mysql::FColumn & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FColumn";

    algo::Smallstr100_Print(row.column, temp);
    PrintAttrSpaceReset(str,"column", temp);

    algo::cstring_Print(row.defval, temp);
    PrintAttrSpaceReset(str,"defval", temp);

    bool_Print(row.is_int, temp);
    PrintAttrSpaceReset(str,"is_int", temp);

    bool_Print(row.is_pkey, temp);
    PrintAttrSpaceReset(str,"is_pkey", temp);

    bool_Print(row.ssimfile_c_column_in_ary, temp);
    PrintAttrSpaceReset(str,"ssimfile_c_column_in_ary", temp);
}

// --- ssim2mysql.FCtype.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::ctype_CopyOut(ssim2mysql::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- ssim2mysql.FCtype.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::ctype_CopyIn(ssim2mysql::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- ssim2mysql.FCtype.ns.Get
algo::Smallstr16 ssim2mysql::ns_Get(ssim2mysql::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- ssim2mysql.FCtype.name.Get
algo::Smallstr50 ssim2mysql::name_Get(ssim2mysql::FCtype& ctype) {
    algo::Smallstr50 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- ssim2mysql.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void ssim2mysql::c_field_Insert(ssim2mysql::FCtype& ctype, ssim2mysql::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,true)) {
        // reserve space
        c_field_Reserve(ctype, 1);
        u32 n  = ctype.c_field_n;
        u32 at = n;
        ssim2mysql::FField* *elems = ctype.c_field_elems;
        elems[at] = &row;
        ctype.c_field_n = n+1;

    }
}

// --- ssim2mysql.FCtype.c_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool ssim2mysql::c_field_InsertMaybe(ssim2mysql::FCtype& ctype, ssim2mysql::FField& row) {
    bool retval = !row.ctype_c_field_in_ary;
    c_field_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- ssim2mysql.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void ssim2mysql::c_field_Remove(ssim2mysql::FCtype& ctype, ssim2mysql::FField& row) {
    if (bool_Update(row.ctype_c_field_in_ary,false)) {
        int lim = ctype.c_field_n;
        ssim2mysql::FField* *elems = ctype.c_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            ssim2mysql::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(ssim2mysql::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- ssim2mysql.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void ssim2mysql::c_field_Reserve(ssim2mysql::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(ssim2mysql::FField*);
        u32 new_size = new_max * sizeof(ssim2mysql::FField*);
        void *new_mem = algo_lib::malloc_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FCtype.c_field");
        }
        ctype.c_field_elems = (ssim2mysql::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- ssim2mysql.FCtype..Uninit
void ssim2mysql::FCtype_Uninit(ssim2mysql::FCtype& ctype) {
    ssim2mysql::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype

    // ssim2mysql.FCtype.c_field.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ctype.c_field_elems, sizeof(ssim2mysql::FField*)*ctype.c_field_max); // (ssim2mysql.FCtype.c_field)
}

// --- ssim2mysql.FCtype..Print
// print string representation of ssim2mysql::FCtype to string LHS, no header -- cprint:ssim2mysql.FCtype.String
void ssim2mysql::FCtype_Print(ssim2mysql::FCtype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FCtype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);

    u64_PrintHex(u64((const ssim2mysql::FSqltype*)row.c_sqltype), temp, 8, true);
    PrintAttrSpaceReset(str,"c_sqltype", temp);

    u64_PrintHex(u64((const ssim2mysql::FSsimfile*)row.c_ssimfile), temp, 8, true);
    PrintAttrSpaceReset(str,"c_ssimfile", temp);
}

// --- ssim2mysql.trace..Print
// print string representation of ssim2mysql::trace to string LHS, no header -- cprint:ssim2mysql.trace.String
void ssim2mysql::trace_Print(ssim2mysql::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.trace";

    u64_Print(row.step_zs_cmd, temp);
    PrintAttrSpaceReset(str,"step_zs_cmd", temp);

    u64_Print(row.step_zs_cmd_cycles, temp);
    PrintAttrSpaceReset(str,"step_zs_cmd_cycles", temp);

    u64_Print(row.step_cd_input_line, temp);
    PrintAttrSpaceReset(str,"step_cd_input_line", temp);

    u64_Print(row.step_cd_input_line_cycles, temp);
    PrintAttrSpaceReset(str,"step_cd_input_line_cycles", temp);
}

// --- ssim2mysql.FDb.ind_column.Find
// Find row by key. Return NULL if not found.
ssim2mysql::FColumn* ssim2mysql::ind_column_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_column_buckets_n - 1);
    ssim2mysql::FColumn* *e = &_db.ind_column_buckets_elems[index];
    ssim2mysql::FColumn* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).column == key;
        if (done) break;
        e         = &ret->ind_column_next;
    } while (true);
    return ret;
}

// --- ssim2mysql.FDb.ind_column.FindX
// Look up row by key and return reference. Throw exception if not found
ssim2mysql::FColumn& ssim2mysql::ind_column_FindX(const algo::strptr& key) {
    ssim2mysql::FColumn* ret = ind_column_Find(key);
    vrfy(ret, tempstr() << "ssim2mysql.key_error  table:ind_column  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_column.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
ssim2mysql::FColumn& ssim2mysql::ind_column_GetOrCreate(const algo::strptr& key) {
    ssim2mysql::FColumn* ret = ind_column_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &column_Alloc();
        (*ret).column = key;
        bool good = column_XrefMaybe(*ret);
        if (!good) {
            column_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "ssim2mysql.create_error  table:ind_column  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_column.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool ssim2mysql::ind_column_InsertMaybe(ssim2mysql::FColumn& row) {
    ind_column_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_column_next == (ssim2mysql::FColumn*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.column) & (_db.ind_column_buckets_n - 1);
        ssim2mysql::FColumn* *prev = &_db.ind_column_buckets_elems[index];
        do {
            ssim2mysql::FColumn* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).column == row.column) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_column_next;
        } while (true);
        if (retval) {
            row.ind_column_next = *prev;
            _db.ind_column_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_column.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void ssim2mysql::ind_column_Remove(ssim2mysql::FColumn& row) {
    if (LIKELY(row.ind_column_next != (ssim2mysql::FColumn*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.column) & (_db.ind_column_buckets_n - 1);
        ssim2mysql::FColumn* *prev = &_db.ind_column_buckets_elems[index]; // addr of pointer to current element
        while (ssim2mysql::FColumn *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_column_next; // unlink (singly linked list)
                _db.ind_column_n--;
                row.ind_column_next = (ssim2mysql::FColumn*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_column_next;
        }
    }
}

// --- ssim2mysql.FDb.ind_column.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void ssim2mysql::ind_column_Reserve(int n) {
    u32 old_nbuckets = _db.ind_column_buckets_n;
    u32 new_nelems   = _db.ind_column_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(ssim2mysql::FColumn*);
        u32 new_size = new_nbuckets * sizeof(ssim2mysql::FColumn*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        ssim2mysql::FColumn* *new_buckets = (ssim2mysql::FColumn**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FDb.ind_column");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_column_buckets_n; i++) {
            ssim2mysql::FColumn* elem = _db.ind_column_buckets_elems[i];
            while (elem) {
                ssim2mysql::FColumn &row        = *elem;
                ssim2mysql::FColumn* next       = row.ind_column_next;
                u32 index          = algo::Smallstr100_Hash(0, row.column) & (new_nbuckets-1);
                row.ind_column_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_column_buckets_elems, old_size);
        _db.ind_column_buckets_elems = new_buckets;
        _db.ind_column_buckets_n = new_nbuckets;
    }
}

// --- ssim2mysql.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FNs& ssim2mysql::ns_Alloc() {
    ssim2mysql::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FNs* ssim2mysql::ns_AllocMaybe() {
    ssim2mysql::FNs *row = (ssim2mysql::FNs*)ns_AllocMem();
    if (row) {
        new (row) ssim2mysql::FNs; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FNs* ssim2mysql::ns_InsertMaybe(const dmmeta::Ns &value) {
    ssim2mysql::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FNs*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = i32(n);
    }
}

// --- ssim2mysql.FDb.ns.InputMaybe
static bool ssim2mysql::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::ns_XrefMaybe(ssim2mysql::FNs &row) {
    bool retval = true;
    (void)row;
    // insert ns into index ind_ns
    if (true) { // user-defined insert condition
        bool success = ind_ns_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FDb.ind_ns"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FCtype& ssim2mysql::ctype_Alloc() {
    ssim2mysql::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FCtype* ssim2mysql::ctype_AllocMaybe() {
    ssim2mysql::FCtype *row = (ssim2mysql::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) ssim2mysql::FCtype; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FCtype* ssim2mysql::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    ssim2mysql::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FCtype*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(u64(n)).~FCtype();
        _db.ctype_n = i32(n);
    }
}

// --- ssim2mysql.FDb.ctype.InputMaybe
static bool ssim2mysql::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::ctype_XrefMaybe(ssim2mysql::FCtype &row) {
    bool retval = true;
    (void)row;
    ssim2mysql::FNs* p_ns = ssim2mysql::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // ctype: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FField& ssim2mysql::field_Alloc() {
    ssim2mysql::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FField* ssim2mysql::field_AllocMaybe() {
    ssim2mysql::FField *row = (ssim2mysql::FField*)field_AllocMem();
    if (row) {
        new (row) ssim2mysql::FField; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FField* ssim2mysql::field_InsertMaybe(const dmmeta::Field &value) {
    ssim2mysql::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FField*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u64(n)).~FField();
        _db.field_n = i32(n);
    }
}

// --- ssim2mysql.FDb.field.InputMaybe
static bool ssim2mysql::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::field_XrefMaybe(ssim2mysql::FField &row) {
    bool retval = true;
    (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    ssim2mysql::FCtype* p_arg = ssim2mysql::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    return retval;
}

// --- ssim2mysql.FDb.sqltype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FSqltype& ssim2mysql::sqltype_Alloc() {
    ssim2mysql::FSqltype* row = sqltype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.sqltype  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.sqltype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FSqltype* ssim2mysql::sqltype_AllocMaybe() {
    ssim2mysql::FSqltype *row = (ssim2mysql::FSqltype*)sqltype_AllocMem();
    if (row) {
        new (row) ssim2mysql::FSqltype; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.sqltype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FSqltype* ssim2mysql::sqltype_InsertMaybe(const dmmeta::Sqltype &value) {
    ssim2mysql::FSqltype *row = &sqltype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    sqltype_CopyIn(*row,const_cast<dmmeta::Sqltype&>(value));
    bool ok = sqltype_XrefMaybe(*row); // this may return false
    if (!ok) {
        sqltype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.sqltype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::sqltype_AllocMem() {
    u64 new_nelems     = _db.sqltype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FSqltype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.sqltype_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FSqltype*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSqltype) * (u64(1)<<bsr));
            _db.sqltype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.sqltype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.sqltype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::sqltype_RemoveLast() {
    u64 n = _db.sqltype_n;
    if (n > 0) {
        n -= 1;
        sqltype_qFind(u64(n)).~FSqltype();
        _db.sqltype_n = i32(n);
    }
}

// --- ssim2mysql.FDb.sqltype.InputMaybe
static bool ssim2mysql::sqltype_InputMaybe(dmmeta::Sqltype &elem) {
    bool retval = true;
    retval = sqltype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.sqltype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::sqltype_XrefMaybe(ssim2mysql::FSqltype &row) {
    bool retval = true;
    (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert sqltype into index c_sqltype
    if (true) { // user-defined insert condition
        bool success = c_sqltype_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FCtype.c_sqltype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.cmd.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FCmd& ssim2mysql::cmd_Alloc() {
    ssim2mysql::FCmd* row = cmd_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.cmd  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.cmd.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FCmd* ssim2mysql::cmd_AllocMaybe() {
    ssim2mysql::FCmd *row = (ssim2mysql::FCmd*)cmd_AllocMem();
    if (row) {
        new (row) ssim2mysql::FCmd; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.cmd.Delete
// Remove row from all global and cross indices, then deallocate row
void ssim2mysql::cmd_Delete(ssim2mysql::FCmd &row) {
    row.~FCmd();
    cmd_FreeMem(row);
}

// --- ssim2mysql.FDb.cmd.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* ssim2mysql::cmd_AllocMem() {
    ssim2mysql::FCmd *row = _db.cmd_free;
    if (UNLIKELY(!row)) {
        cmd_Reserve(1);
        row = _db.cmd_free;
    }
    if (row) {
        _db.cmd_free = row->cmd_next;
    }
    return row;
}

// --- ssim2mysql.FDb.cmd.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void ssim2mysql::cmd_FreeMem(ssim2mysql::FCmd &row) {
    if (UNLIKELY(row.cmd_next != (ssim2mysql::FCmd*)-1)) {
        FatalErrorExit("ssim2mysql.tpool_double_delete  pool:ssim2mysql.FDb.cmd  comment:'double deletion caught'");
    }
    row.cmd_next = _db.cmd_free; // insert into free list
    _db.cmd_free  = &row;
}

// --- ssim2mysql.FDb.cmd.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 ssim2mysql::cmd_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.cmd_blocksize; // underlying allocator is probably Lpool
        u64 reserved = cmd_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- ssim2mysql.FDb.cmd.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 ssim2mysql::cmd_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(ssim2mysql::FCmd)) {
        ssim2mysql::FCmd *mem = (ssim2mysql::FCmd*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(ssim2mysql::FCmd) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].cmd_next = _db.cmd_free;
            _db.cmd_free = mem+i;
        }
    }
    return ret;
}

// --- ssim2mysql.FDb.cmd.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::cmd_XrefMaybe(ssim2mysql::FCmd &row) {
    bool retval = true;
    (void)row;
    // insert cmd into index zs_cmd
    if (true) { // user-defined insert condition
        zs_cmd_Insert(row);
    }
    return retval;
}

// --- ssim2mysql.FDb.column.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FColumn& ssim2mysql::column_Alloc() {
    ssim2mysql::FColumn* row = column_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.column  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.column.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FColumn* ssim2mysql::column_AllocMaybe() {
    ssim2mysql::FColumn *row = (ssim2mysql::FColumn*)column_AllocMem();
    if (row) {
        new (row) ssim2mysql::FColumn; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.column.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::column_AllocMem() {
    u64 new_nelems     = _db.column_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FColumn*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.column_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FColumn*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FColumn) * (u64(1)<<bsr));
            _db.column_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.column_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.column.RemoveAll
// Remove all elements from Lary
void ssim2mysql::column_RemoveAll() {
    for (u64 n = _db.column_n; n>0; ) {
        n--;
        column_qFind(u64(n)).~FColumn(); // destroy last element
        _db.column_n = i32(n);
    }
}

// --- ssim2mysql.FDb.column.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::column_RemoveLast() {
    u64 n = _db.column_n;
    if (n > 0) {
        n -= 1;
        column_qFind(u64(n)).~FColumn();
        _db.column_n = i32(n);
    }
}

// --- ssim2mysql.FDb.column.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::column_XrefMaybe(ssim2mysql::FColumn &row) {
    bool retval = true;
    (void)row;
    // insert column into index ind_column
    if (true) { // user-defined insert condition
        bool success = ind_column_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FDb.ind_column"; // check for duplicate key
            return false;
        }
    }
    ssim2mysql::FSsimfile* p_ssimfile = ssim2mysql::ind_ssimfile_Find(ssimfile_Get(row));
    if (UNLIKELY(!p_ssimfile)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ssimfile" << Keyval("key", ssimfile_Get(row));
        return false;
    }
    // insert column into index c_column
    if (true) { // user-defined insert condition
        c_column_Insert(*p_ssimfile, row);
    }
    return retval;
}

// --- ssim2mysql.FDb._db.ReadArgv
// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     ssim2mysql.FDb.cmdline
//     algo_lib.FDb.cmdline
void ssim2mysql::ReadArgv() {
    command::ssim2mysql &cmd = ssim2mysql::_db.cmdline;
    algo_lib::Cmdline &base = algo_lib::_db.cmdline;
    int needarg=-1;// unknown
    int argidx=1;// skip process name
    tempstr err;
    algo::strptr attrname;
    bool isanon=false; // true if attrname is anonfld (positional)
    algo_lib::FieldId baseattrid;
    command::FieldId attrid;
    bool endopt=false;
    int whichns=0;// which namespace does the current attribute belong to
    for (; argidx < algo_lib::_db.argc; argidx++) {
        algo::strptr arg = algo_lib::_db.argv[argidx];
        algo::strptr attrval;
        algo::strptr dfltval;
        bool haveval=false;
        bool dash=elems_N(arg)>1 && arg.elems[0]=='-'; // a single dash is not an option
        // this attribute is a value
        if (endopt || needarg>0 || !dash) {
            attrval=arg;
            haveval=true;
        } else {
            // this attribute is a field name (with - or --)
            // or a -- by itself
            bool dashdash = elems_N(arg) >= 2 && arg.elems[1]=='-';
            int skip = int(dash) + dashdash;
            attrname=ch_RestFrom(arg,skip);
            if (skip==2 && elems_N(arg)==2) {
                endopt=true;
                continue;// nothing else to do here
            }
            // parse "-a:B" arg into attrname,attrvalue
            algo::i32_Range colon = TFind(attrname,':');
            if (colon.beg < colon.end) {
                attrval=ch_RestFrom(attrname,colon.end);
                attrname=ch_FirstN(attrname,colon.beg);
                haveval=true;
            }
            // look up which command (this one or the base) contains the field
            whichns=0;
            needarg=-1;
            // look up parameter information in base namespace (needarg will be -1 if lookup fails)
            if (algo_lib::FieldId_ReadStrptrMaybe(baseattrid,attrname)) {
                needarg = algo_lib::Cmdline_NArgs(baseattrid,dfltval,&isanon);
            }
            if (needarg<0) {
                whichns=1;
                // look up parameter information in this namespace (needarg will be -1 if lookup fails)
                if (command::FieldId_ReadStrptrMaybe(attrid,attrname)) {
                    needarg = command::ssim2mysql_NArgs(attrid,dfltval,&isanon);
                }
            }
            if (attrval == "" && dfltval != "") {
                attrval=dfltval;
                haveval=true;
            }
            if (needarg<0) {
                err<<"ssim2mysql: unknown option "<<Keyval("value",arg)<<eol;
            } else {
            }
        }
        if (ch_N(attrname) == 0) {
            err << "ssim2mysql: too many arguments. error at "<<algo::strptr_ToSsim(arg)<<eol;
        }
        // read value into currently selected arg
        if (haveval) {
            bool ret=false;
            // it's already known which namespace is consuming the args,
            // so directly go there
            if (whichns == 0) {
                ret=algo_lib::Cmdline_ReadFieldMaybe(base, attrname, attrval);
            }
            if (whichns==1) {
                ret=command::ssim2mysql_ReadFieldMaybe(cmd, attrname, attrval);
                switch(attrid.value) {
                    default:break;
                }
            }
            if (!ret) {
                err<<"ssim2mysql: error in "
                <<Keyval("option",attrname)
                <<Keyval("value",attrval)<<eol;
            }
            needarg--;
            if (needarg <= 0) {
                attrname="";// forget which argument was being filled
            }
        }
    }
    bool dohelp = false;
    bool doexit=false;
    if (algo_lib::_db.cmdline.help) {
        dohelp = true;
        doexit = true;
        algo_lib::_db.exit_code = 1; // help exits with non-zero status code
    } else if (algo_lib::_db.cmdline.version) {
        // -ver output goes to stdout
        prlog(algo::gitinfo_Get());
        doexit = true;
    } else if (algo_lib::_db.cmdline.signature) {
        ind_beg(algo_lib::_db_dispsigcheck_curs,dispsigcheck,algo_lib::_db) {
            // dispsig goes to stdout
            dmmeta::Dispsigcheck out;
            dispsigcheck_CopyOut(dispsigcheck,out);
            prlog(out);
        }ind_end
        doexit = true;
    }
    if (!dohelp) {
    }
    if (err != "") {
        algo_lib::_db.exit_code=1;
        prerr(err);
        doexit=true;
    }
    if (dohelp) {
        prlog(ssim2mysql_help);
    }
    if (doexit) {
        _exit(algo_lib::_db.exit_code);
    }
    algo_lib::ResetErrtext();
    vrfy(ssim2mysql::LoadTuplesMaybe(cmd.data_dir)
    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
}

// --- ssim2mysql.FDb._db.MainLoop
// Main loop.
void ssim2mysql::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        ssim2mysql::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- ssim2mysql.FDb._db.Step
// Main step
void ssim2mysql::Step() {
    zs_cmd_Call();
    cd_input_line_Call();
}

// --- ssim2mysql.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void ssim2mysql::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("ssim2mysql", ssim2mysql::InsertStrptrMaybe, ssim2mysql::Step, ssim2mysql::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "ssim2mysql.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(ssim2mysql::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)ssim2mysql::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'ssim2mysql.Input'  signature:'0e69864de5bd01f99c3d8aaa899c7f6cf96b3b4f'");
}

// --- ssim2mysql.FDb._db.StaticCheck
void ssim2mysql::StaticCheck() {
    algo_assert(_offset_of(ssim2mysql::trace, step_cd_input_line_cycles) + sizeof(((ssim2mysql::trace*)0)->step_cd_input_line_cycles) == sizeof(ssim2mysql::trace));
    algo_assert(_offset_of(ssim2mysql::FieldId, value) + sizeof(((ssim2mysql::FieldId*)0)->value) == sizeof(ssim2mysql::FieldId));
}

// --- ssim2mysql.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool ssim2mysql::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    ssim2mysql::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case ssim2mysql_TableId_dmmeta_Ns: { // finput:ssim2mysql.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            break;
        }
        case ssim2mysql_TableId_dmmeta_Ctype: { // finput:ssim2mysql.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            break;
        }
        case ssim2mysql_TableId_dmmeta_Field: { // finput:ssim2mysql.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            break;
        }
        case ssim2mysql_TableId_dmmeta_Sqltype: { // finput:ssim2mysql.FDb.sqltype
            dmmeta::Sqltype elem;
            retval = dmmeta::Sqltype_ReadStrptrMaybe(elem, str);
            retval = retval && sqltype_InputMaybe(elem);
            break;
        }
        case ssim2mysql_TableId_dmmeta_Substr: { // finput:ssim2mysql.FDb.substr
            dmmeta::Substr elem;
            retval = dmmeta::Substr_ReadStrptrMaybe(elem, str);
            retval = retval && substr_InputMaybe(elem);
            break;
        }
        case ssim2mysql_TableId_dmmeta_Ssimfile: { // finput:ssim2mysql.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- ssim2mysql.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool ssim2mysql::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dmmeta.ns", "dmmeta.ctype", "dmmeta.ssimfile", "dmmeta.field"
        , "dmmeta.sqltype", "dmmeta.substr"
        , NULL};
        retval = algo_lib::DoLoadTuples(root, ssim2mysql::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- ssim2mysql.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool ssim2mysql::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, ssim2mysql::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- ssim2mysql.FDb._db.Steps
// Calls Step function of dependencies
void ssim2mysql::Steps() {
    ssim2mysql::Step(); // dependent namespace specified via (dev.targdep)
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- ssim2mysql.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- ssim2mysql.FDb.ind_ns.Find
// Find row by key. Return NULL if not found.
ssim2mysql::FNs* ssim2mysql::ind_ns_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_ns_buckets_n - 1);
    ssim2mysql::FNs* *e = &_db.ind_ns_buckets_elems[index];
    ssim2mysql::FNs* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_ns_next;
    } while (true);
    return ret;
}

// --- ssim2mysql.FDb.ind_ns.FindX
// Look up row by key and return reference. Throw exception if not found
ssim2mysql::FNs& ssim2mysql::ind_ns_FindX(const algo::strptr& key) {
    ssim2mysql::FNs* ret = ind_ns_Find(key);
    vrfy(ret, tempstr() << "ssim2mysql.key_error  table:ind_ns  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ns.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
ssim2mysql::FNs& ssim2mysql::ind_ns_GetOrCreate(const algo::strptr& key) {
    ssim2mysql::FNs* ret = ind_ns_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ns_Alloc();
        (*ret).ns = key;
        bool good = ns_XrefMaybe(*ret);
        if (!good) {
            ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "ssim2mysql.create_error  table:ind_ns  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ns.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool ssim2mysql::ind_ns_InsertMaybe(ssim2mysql::FNs& row) {
    ind_ns_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ns_next == (ssim2mysql::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        ssim2mysql::FNs* *prev = &_db.ind_ns_buckets_elems[index];
        do {
            ssim2mysql::FNs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ns_next;
        } while (true);
        if (retval) {
            row.ind_ns_next = *prev;
            _db.ind_ns_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_ns.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void ssim2mysql::ind_ns_Remove(ssim2mysql::FNs& row) {
    if (LIKELY(row.ind_ns_next != (ssim2mysql::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        ssim2mysql::FNs* *prev = &_db.ind_ns_buckets_elems[index]; // addr of pointer to current element
        while (ssim2mysql::FNs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ns_next; // unlink (singly linked list)
                _db.ind_ns_n--;
                row.ind_ns_next = (ssim2mysql::FNs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ns_next;
        }
    }
}

// --- ssim2mysql.FDb.ind_ns.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void ssim2mysql::ind_ns_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ns_buckets_n;
    u32 new_nelems   = _db.ind_ns_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(ssim2mysql::FNs*);
        u32 new_size = new_nbuckets * sizeof(ssim2mysql::FNs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        ssim2mysql::FNs* *new_buckets = (ssim2mysql::FNs**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FDb.ind_ns");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ns_buckets_n; i++) {
            ssim2mysql::FNs* elem = _db.ind_ns_buckets_elems[i];
            while (elem) {
                ssim2mysql::FNs &row        = *elem;
                ssim2mysql::FNs* next       = row.ind_ns_next;
                u32 index          = algo::Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_ns_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ns_buckets_elems, old_size);
        _db.ind_ns_buckets_elems = new_buckets;
        _db.ind_ns_buckets_n = new_nbuckets;
    }
}

// --- ssim2mysql.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
ssim2mysql::FCtype* ssim2mysql::ind_ctype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    ssim2mysql::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    ssim2mysql::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- ssim2mysql.FDb.ind_ctype.FindX
// Look up row by key and return reference. Throw exception if not found
ssim2mysql::FCtype& ssim2mysql::ind_ctype_FindX(const algo::strptr& key) {
    ssim2mysql::FCtype* ret = ind_ctype_Find(key);
    vrfy(ret, tempstr() << "ssim2mysql.key_error  table:ind_ctype  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ctype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
ssim2mysql::FCtype& ssim2mysql::ind_ctype_GetOrCreate(const algo::strptr& key) {
    ssim2mysql::FCtype* ret = ind_ctype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ctype_Alloc();
        (*ret).ctype = key;
        bool good = ctype_XrefMaybe(*ret);
        if (!good) {
            ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "ssim2mysql.create_error  table:ind_ctype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool ssim2mysql::ind_ctype_InsertMaybe(ssim2mysql::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (ssim2mysql::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        ssim2mysql::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            ssim2mysql::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void ssim2mysql::ind_ctype_Remove(ssim2mysql::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (ssim2mysql::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        ssim2mysql::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (ssim2mysql::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (ssim2mysql::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- ssim2mysql.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void ssim2mysql::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(ssim2mysql::FCtype*);
        u32 new_size = new_nbuckets * sizeof(ssim2mysql::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        ssim2mysql::FCtype* *new_buckets = (ssim2mysql::FCtype**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            ssim2mysql::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                ssim2mysql::FCtype &row        = *elem;
                ssim2mysql::FCtype* next       = row.ind_ctype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- ssim2mysql.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
ssim2mysql::FField* ssim2mysql::ind_field_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    ssim2mysql::FField* *e = &_db.ind_field_buckets_elems[index];
    ssim2mysql::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- ssim2mysql.FDb.ind_field.FindX
// Look up row by key and return reference. Throw exception if not found
ssim2mysql::FField& ssim2mysql::ind_field_FindX(const algo::strptr& key) {
    ssim2mysql::FField* ret = ind_field_Find(key);
    vrfy(ret, tempstr() << "ssim2mysql.key_error  table:ind_field  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_field.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
ssim2mysql::FField& ssim2mysql::ind_field_GetOrCreate(const algo::strptr& key) {
    ssim2mysql::FField* ret = ind_field_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &field_Alloc();
        (*ret).field = key;
        bool good = field_XrefMaybe(*ret);
        if (!good) {
            field_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "ssim2mysql.create_error  table:ind_field  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool ssim2mysql::ind_field_InsertMaybe(ssim2mysql::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (ssim2mysql::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        ssim2mysql::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            ssim2mysql::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void ssim2mysql::ind_field_Remove(ssim2mysql::FField& row) {
    if (LIKELY(row.ind_field_next != (ssim2mysql::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        ssim2mysql::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (ssim2mysql::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (ssim2mysql::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- ssim2mysql.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void ssim2mysql::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(ssim2mysql::FField*);
        u32 new_size = new_nbuckets * sizeof(ssim2mysql::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        ssim2mysql::FField* *new_buckets = (ssim2mysql::FField**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            ssim2mysql::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                ssim2mysql::FField &row        = *elem;
                ssim2mysql::FField* next       = row.ind_field_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- ssim2mysql.FDb.substr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FSubstr& ssim2mysql::substr_Alloc() {
    ssim2mysql::FSubstr* row = substr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.substr  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.substr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FSubstr* ssim2mysql::substr_AllocMaybe() {
    ssim2mysql::FSubstr *row = (ssim2mysql::FSubstr*)substr_AllocMem();
    if (row) {
        new (row) ssim2mysql::FSubstr; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.substr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FSubstr* ssim2mysql::substr_InsertMaybe(const dmmeta::Substr &value) {
    ssim2mysql::FSubstr *row = &substr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    substr_CopyIn(*row,const_cast<dmmeta::Substr&>(value));
    bool ok = substr_XrefMaybe(*row); // this may return false
    if (!ok) {
        substr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.substr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::substr_AllocMem() {
    u64 new_nelems     = _db.substr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FSubstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.substr_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FSubstr*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSubstr) * (u64(1)<<bsr));
            _db.substr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.substr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.substr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::substr_RemoveLast() {
    u64 n = _db.substr_n;
    if (n > 0) {
        n -= 1;
        substr_qFind(u64(n)).~FSubstr();
        _db.substr_n = i32(n);
    }
}

// --- ssim2mysql.FDb.substr.InputMaybe
static bool ssim2mysql::substr_InputMaybe(dmmeta::Substr &elem) {
    bool retval = true;
    retval = substr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.substr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::substr_XrefMaybe(ssim2mysql::FSubstr &row) {
    bool retval = true;
    (void)row;
    ssim2mysql::FField* p_field = ssim2mysql::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert substr into index c_substr
    if (true) { // user-defined insert condition
        bool success = c_substr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FField.c_substr"; // check for duplicate key
            return false;
        }
    }
    // substr: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    return retval;
}

// --- ssim2mysql.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FSsimfile& ssim2mysql::ssimfile_Alloc() {
    ssim2mysql::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FSsimfile* ssim2mysql::ssimfile_AllocMaybe() {
    ssim2mysql::FSsimfile *row = (ssim2mysql::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) ssim2mysql::FSsimfile; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
ssim2mysql::FSsimfile* ssim2mysql::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    ssim2mysql::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- ssim2mysql.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* ssim2mysql::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    ssim2mysql::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(ssim2mysql::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- ssim2mysql.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void ssim2mysql::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = i32(n);
    }
}

// --- ssim2mysql.FDb.ssimfile.InputMaybe
static bool ssim2mysql::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- ssim2mysql.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::ssimfile_XrefMaybe(ssim2mysql::FSsimfile &row) {
    bool retval = true;
    (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        bool success = c_ssimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FCtype.c_ssimfile"; // check for duplicate key
            return false;
        }
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "ssim2mysql.duplicate_key  xref:ssim2mysql.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    ssim2mysql::FNs* p_ns = ssim2mysql::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "ssim2mysql.bad_xref  index:ssim2mysql.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        c_ssimfile_Insert(*p_ns, row);
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
ssim2mysql::FSsimfile* ssim2mysql::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    ssim2mysql::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    ssim2mysql::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- ssim2mysql.FDb.ind_ssimfile.FindX
// Look up row by key and return reference. Throw exception if not found
ssim2mysql::FSsimfile& ssim2mysql::ind_ssimfile_FindX(const algo::strptr& key) {
    ssim2mysql::FSsimfile* ret = ind_ssimfile_Find(key);
    vrfy(ret, tempstr() << "ssim2mysql.key_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'key not found'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ssimfile.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
ssim2mysql::FSsimfile& ssim2mysql::ind_ssimfile_GetOrCreate(const algo::strptr& key) {
    ssim2mysql::FSsimfile* ret = ind_ssimfile_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ssimfile_Alloc();
        (*ret).ssimfile = key;
        bool good = ssimfile_XrefMaybe(*ret);
        if (!good) {
            ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "ssim2mysql.create_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- ssim2mysql.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool ssim2mysql::ind_ssimfile_InsertMaybe(ssim2mysql::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (ssim2mysql::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        ssim2mysql::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            ssim2mysql::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- ssim2mysql.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void ssim2mysql::ind_ssimfile_Remove(ssim2mysql::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (ssim2mysql::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        ssim2mysql::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (ssim2mysql::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (ssim2mysql::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- ssim2mysql.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void ssim2mysql::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(ssim2mysql::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(ssim2mysql::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        ssim2mysql::FSsimfile* *new_buckets = (ssim2mysql::FSsimfile**)algo_lib::malloc_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            ssim2mysql::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                ssim2mysql::FSsimfile &row        = *elem;
                ssim2mysql::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::malloc_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- ssim2mysql.FDb.zs_cmd.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void ssim2mysql::zs_cmd_Insert(ssim2mysql::FCmd& row) {
    if (!zs_cmd_InLlistQ(row)) {
        ssim2mysql::FCmd* old_tail       = _db.zs_cmd_tail;
        row.zs_cmd_next  = NULL;
        _db.zs_cmd_tail = &row;
        ssim2mysql::FCmd **new_row_a = &old_tail->zs_cmd_next;
        ssim2mysql::FCmd **new_row_b = &_db.zs_cmd_head;
        ssim2mysql::FCmd **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        if (_db.zs_cmd_head == &row) {
            zs_cmd_FirstChanged();
        }
    }
}

// --- ssim2mysql.FDb.zs_cmd.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void ssim2mysql::zs_cmd_Remove(ssim2mysql::FCmd& row) {
    if (zs_cmd_InLlistQ(row)) {
        ssim2mysql::FCmd* old_head       = _db.zs_cmd_head;
        (void)old_head; // in case it's not used
        ssim2mysql::FCmd* prev=NULL;
        ssim2mysql::FCmd* cur     = _db.zs_cmd_head;
        while (cur) {  // search for element by pointer
            ssim2mysql::FCmd* next = cur->zs_cmd_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_cmd_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_cmd_next = next;
                } else {
                    _db.zs_cmd_head = next;
                }
                row.zs_cmd_next = (ssim2mysql::FCmd*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
        if (old_head != _db.zs_cmd_head) {
            zs_cmd_FirstChanged();
        }
    }
}

// --- ssim2mysql.FDb.zs_cmd.RemoveAll
// Empty the index. (The rows are not deleted)
void ssim2mysql::zs_cmd_RemoveAll() {
    ssim2mysql::FCmd* row = _db.zs_cmd_head;
    _db.zs_cmd_head = NULL;
    _db.zs_cmd_tail = NULL;
    bool do_fire = (NULL != row);
    while (row) {
        ssim2mysql::FCmd* row_next = row->zs_cmd_next;
        row->zs_cmd_next  = (ssim2mysql::FCmd*)-1;
        row = row_next;
    }
    if (do_fire) {
        zs_cmd_FirstChanged();
    }
}

// --- ssim2mysql.FDb.zs_cmd.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
ssim2mysql::FCmd* ssim2mysql::zs_cmd_RemoveFirst() {
    ssim2mysql::FCmd *row = NULL;
    row = _db.zs_cmd_head;
    if (row) {
        ssim2mysql::FCmd *next = row->zs_cmd_next;
        _db.zs_cmd_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_cmd_tail = NULL;
        }
        row->zs_cmd_next = (ssim2mysql::FCmd*)-1; // mark as not-in-list
        zs_cmd_FirstChanged();
    }
    return row;
}

// --- ssim2mysql.FDb.zs_cmd.FirstChanged
// First element of index changed.
static void ssim2mysql::zs_cmd_FirstChanged() {
}

// --- ssim2mysql.FDb.zs_cmd.UpdateCycles
// Update cycles count from previous clock capture
inline static void ssim2mysql::zs_cmd_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++ssim2mysql::_db.trace.step_zs_cmd;
    ssim2mysql::_db.trace.step_zs_cmd_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- ssim2mysql.FDb.zs_cmd.Call
inline static void ssim2mysql::zs_cmd_Call() {
    if (!ssim2mysql::zs_cmd_EmptyQ()) { // fstep:ssim2mysql.FDb.zs_cmd
        ssim2mysql::zs_cmd_Step(); // steptype:Inline: call function on every step
        zs_cmd_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- ssim2mysql.FDb.input.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
ssim2mysql::FInput& ssim2mysql::input_Alloc() {
    ssim2mysql::FInput* row = input_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("ssim2mysql.out_of_mem  field:ssim2mysql.FDb.input  comment:'Alloc failed'");
    }
    return *row;
}

// --- ssim2mysql.FDb.input.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
ssim2mysql::FInput* ssim2mysql::input_AllocMaybe() {
    ssim2mysql::FInput *row = (ssim2mysql::FInput*)input_AllocMem();
    if (row) {
        new (row) ssim2mysql::FInput; // call constructor
    }
    return row;
}

// --- ssim2mysql.FDb.input.Delete
// Remove row from all global and cross indices, then deallocate row
void ssim2mysql::input_Delete(ssim2mysql::FInput &row) {
    row.~FInput();
    input_FreeMem(row);
}

// --- ssim2mysql.FDb.input.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* ssim2mysql::input_AllocMem() {
    ssim2mysql::FInput *row = _db.input_free;
    if (UNLIKELY(!row)) {
        input_Reserve(1);
        row = _db.input_free;
    }
    if (row) {
        _db.input_free = row->input_next;
    }
    return row;
}

// --- ssim2mysql.FDb.input.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void ssim2mysql::input_FreeMem(ssim2mysql::FInput &row) {
    if (UNLIKELY(row.input_next != (ssim2mysql::FInput*)-1)) {
        FatalErrorExit("ssim2mysql.tpool_double_delete  pool:ssim2mysql.FDb.input  comment:'double deletion caught'");
    }
    row.input_next = _db.input_free; // insert into free list
    _db.input_free  = &row;
}

// --- ssim2mysql.FDb.input.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 ssim2mysql::input_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.input_blocksize; // underlying allocator is probably Lpool
        u64 reserved = input_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- ssim2mysql.FDb.input.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 ssim2mysql::input_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(ssim2mysql::FInput)) {
        ssim2mysql::FInput *mem = (ssim2mysql::FInput*)algo_lib::malloc_AllocMem(size);
        ret = mem ? size / sizeof(ssim2mysql::FInput) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].input_next = _db.input_free;
            _db.input_free = mem+i;
        }
    }
    return ret;
}

// --- ssim2mysql.FDb.input.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool ssim2mysql::input_XrefMaybe(ssim2mysql::FInput &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- ssim2mysql.FDb.zd_ssimfile.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void ssim2mysql::zd_ssimfile_Insert(ssim2mysql::FSsimfile& row) {
    if (!zd_ssimfile_InLlistQ(row)) {
        ssim2mysql::FSsimfile* old_tail = _db.zd_ssimfile_tail;
        row.zd_ssimfile_next = NULL;
        row.zd_ssimfile_prev = old_tail;
        _db.zd_ssimfile_tail = &row;
        ssim2mysql::FSsimfile **new_row_a = &old_tail->zd_ssimfile_next;
        ssim2mysql::FSsimfile **new_row_b = &_db.zd_ssimfile_head;
        ssim2mysql::FSsimfile **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- ssim2mysql.FDb.zd_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
void ssim2mysql::zd_ssimfile_Remove(ssim2mysql::FSsimfile& row) {
    if (zd_ssimfile_InLlistQ(row)) {
        ssim2mysql::FSsimfile* old_head       = _db.zd_ssimfile_head;
        (void)old_head; // in case it's not used
        ssim2mysql::FSsimfile* prev = row.zd_ssimfile_prev;
        ssim2mysql::FSsimfile* next = row.zd_ssimfile_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        ssim2mysql::FSsimfile **new_next_a = &prev->zd_ssimfile_next;
        ssim2mysql::FSsimfile **new_next_b = &_db.zd_ssimfile_head;
        ssim2mysql::FSsimfile **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        ssim2mysql::FSsimfile **new_prev_a = &next->zd_ssimfile_prev;
        ssim2mysql::FSsimfile **new_prev_b = &_db.zd_ssimfile_tail;
        ssim2mysql::FSsimfile **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        row.zd_ssimfile_next=(ssim2mysql::FSsimfile*)-1; // not-in-list
    }
}

// --- ssim2mysql.FDb.zd_ssimfile.RemoveAll
// Empty the index. (The rows are not deleted)
void ssim2mysql::zd_ssimfile_RemoveAll() {
    ssim2mysql::FSsimfile* row = _db.zd_ssimfile_head;
    _db.zd_ssimfile_head = NULL;
    _db.zd_ssimfile_tail = NULL;
    while (row) {
        ssim2mysql::FSsimfile* row_next = row->zd_ssimfile_next;
        row->zd_ssimfile_next  = (ssim2mysql::FSsimfile*)-1;
        row->zd_ssimfile_prev  = NULL;
        row = row_next;
    }
}

// --- ssim2mysql.FDb.zd_ssimfile.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
ssim2mysql::FSsimfile* ssim2mysql::zd_ssimfile_RemoveFirst() {
    ssim2mysql::FSsimfile *row = NULL;
    row = _db.zd_ssimfile_head;
    if (row) {
        ssim2mysql::FSsimfile *next = row->zd_ssimfile_next;
        _db.zd_ssimfile_head = next;
        ssim2mysql::FSsimfile **new_end_a = &next->zd_ssimfile_prev;
        ssim2mysql::FSsimfile **new_end_b = &_db.zd_ssimfile_tail;
        ssim2mysql::FSsimfile **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        row->zd_ssimfile_next = (ssim2mysql::FSsimfile*)-1; // mark as not-in-list
    }
    return row;
}

// --- ssim2mysql.FDb.cd_input_line.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void ssim2mysql::cd_input_line_Insert(ssim2mysql::FInput& row) {
    if (!cd_input_line_InLlistQ(row)) {
        if (_db.cd_input_line_head) {
            row.cd_input_line_next = _db.cd_input_line_head;
            row.cd_input_line_prev = _db.cd_input_line_head->cd_input_line_prev;
            row.cd_input_line_prev->cd_input_line_next = &row;
            row.cd_input_line_next->cd_input_line_prev = &row;
        } else {
            row.cd_input_line_next = &row;
            row.cd_input_line_prev = &row;
            _db.cd_input_line_head = &row;
        }
        if (_db.cd_input_line_head == &row) {
            cd_input_line_FirstChanged();
        }
    }
}

// --- ssim2mysql.FDb.cd_input_line.Remove
// Remove element from index. If element is not in index, do nothing.
void ssim2mysql::cd_input_line_Remove(ssim2mysql::FInput& row) {
    if (cd_input_line_InLlistQ(row)) {
        ssim2mysql::FInput* old_head       = _db.cd_input_line_head;
        (void)old_head; // in case it's not used
        ssim2mysql::FInput *oldnext = row.cd_input_line_next;
        ssim2mysql::FInput *oldprev = row.cd_input_line_prev;
        oldnext->cd_input_line_prev = oldprev; // remove element from list
        oldprev->cd_input_line_next = oldnext;
        if (&row == _db.cd_input_line_head) {
            _db.cd_input_line_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_input_line_next = (ssim2mysql::FInput*)-1; // mark element as not-in-list);
        row.cd_input_line_prev = NULL; // clear back-pointer
        if (old_head != _db.cd_input_line_head) {
            cd_input_line_FirstChanged();
        }
    }
}

// --- ssim2mysql.FDb.cd_input_line.RemoveAll
// Empty the index. (The rows are not deleted)
void ssim2mysql::cd_input_line_RemoveAll() {
    ssim2mysql::FInput* row = _db.cd_input_line_head;
    ssim2mysql::FInput* head = _db.cd_input_line_head;
    _db.cd_input_line_head = NULL;
    bool do_fire = (NULL != row);
    while (row) {
        ssim2mysql::FInput* row_next = row->cd_input_line_next;
        row->cd_input_line_next  = (ssim2mysql::FInput*)-1;
        row->cd_input_line_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
    if (do_fire) {
        cd_input_line_FirstChanged();
    }
}

// --- ssim2mysql.FDb.cd_input_line.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
ssim2mysql::FInput* ssim2mysql::cd_input_line_RemoveFirst() {
    ssim2mysql::FInput *row = NULL;
    row = _db.cd_input_line_head;
    if (row) {
        bool hasmore = row!=row->cd_input_line_next;
        _db.cd_input_line_head = hasmore ? row->cd_input_line_next : NULL;
        row->cd_input_line_next->cd_input_line_prev = row->cd_input_line_prev;
        row->cd_input_line_prev->cd_input_line_next = row->cd_input_line_next;
        row->cd_input_line_prev = NULL;
        row->cd_input_line_next = (ssim2mysql::FInput*)-1; // mark as not-in-list
        cd_input_line_FirstChanged();
    }
    return row;
}

// --- ssim2mysql.FDb.cd_input_line.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
ssim2mysql::FInput* ssim2mysql::cd_input_line_RotateFirst() {
    ssim2mysql::FInput *row = NULL;
    row = _db.cd_input_line_head;
    if (row) {
        _db.cd_input_line_head = row->cd_input_line_next;
    }
    return row;
}

// --- ssim2mysql.FDb.cd_input_line.FirstChanged
// First element of index changed.
static void ssim2mysql::cd_input_line_FirstChanged() {
}

// --- ssim2mysql.FDb.cd_input_line.UpdateCycles
// Update cycles count from previous clock capture
inline static void ssim2mysql::cd_input_line_UpdateCycles() {
    u64 cur_cycles                      = algo::get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++ssim2mysql::_db.trace.step_cd_input_line;
    ssim2mysql::_db.trace.step_cd_input_line_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = algo::SchedTime(cur_cycles);
}

// --- ssim2mysql.FDb.cd_input_line.Call
inline static void ssim2mysql::cd_input_line_Call() {
    if (!ssim2mysql::cd_input_line_EmptyQ()) { // fstep:ssim2mysql.FDb.cd_input_line
        ssim2mysql::cd_input_line_Step(); // steptype:Inline: call function on every step
        cd_input_line_UpdateCycles();
        algo_lib::_db.next_loop = algo_lib::_db.clock;
    }
}

// --- ssim2mysql.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr ssim2mysql::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- ssim2mysql.FDb.trace.N
// Function return 1
inline static i32 ssim2mysql::trace_N() {
    return 1;
}

// --- ssim2mysql.FDb..Init
// Set all fields to initial values.
void ssim2mysql::FDb_Init() {
    // initialize hash table for ssim2mysql::FColumn;
    _db.ind_column_n             	= 0; // (ssim2mysql.FDb.ind_column)
    _db.ind_column_buckets_n     	= 4; // (ssim2mysql.FDb.ind_column)
    _db.ind_column_buckets_elems 	= (ssim2mysql::FColumn**)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FColumn*)*_db.ind_column_buckets_n); // initial buckets (ssim2mysql.FDb.ind_column)
    if (!_db.ind_column_buckets_elems) {
        FatalErrorExit("out of memory"); // (ssim2mysql.FDb.ind_column)
    }
    memset(_db.ind_column_buckets_elems, 0, sizeof(ssim2mysql::FColumn*)*_db.ind_column_buckets_n); // (ssim2mysql.FDb.ind_column)
    // initialize LAry ns (ssim2mysql.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    ssim2mysql::FNs* ns_first = (ssim2mysql::FNs*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }
    // initialize LAry ctype (ssim2mysql.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    ssim2mysql::FCtype* ctype_first = (ssim2mysql::FCtype*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // initialize LAry field (ssim2mysql.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    ssim2mysql::FField* field_first = (ssim2mysql::FField*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize LAry sqltype (ssim2mysql.FDb.sqltype)
    _db.sqltype_n = 0;
    memset(_db.sqltype_lary, 0, sizeof(_db.sqltype_lary)); // zero out all level pointers
    ssim2mysql::FSqltype* sqltype_first = (ssim2mysql::FSqltype*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSqltype) * (u64(1)<<4));
    if (!sqltype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.sqltype_lary[i]  = sqltype_first;
        sqltype_first    += 1ULL<<i;
    }
    // cmd: initialize Tpool
    _db.cmd_free      = NULL;
    _db.cmd_blocksize = algo::BumpToPow2(64 * sizeof(ssim2mysql::FCmd)); // allocate 64-127 elements at a time
    // initialize LAry column (ssim2mysql.FDb.column)
    _db.column_n = 0;
    memset(_db.column_lary, 0, sizeof(_db.column_lary)); // zero out all level pointers
    ssim2mysql::FColumn* column_first = (ssim2mysql::FColumn*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FColumn) * (u64(1)<<4));
    if (!column_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.column_lary[i]  = column_first;
        column_first    += 1ULL<<i;
    }
    // initialize hash table for ssim2mysql::FNs;
    _db.ind_ns_n             	= 0; // (ssim2mysql.FDb.ind_ns)
    _db.ind_ns_buckets_n     	= 4; // (ssim2mysql.FDb.ind_ns)
    _db.ind_ns_buckets_elems 	= (ssim2mysql::FNs**)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FNs*)*_db.ind_ns_buckets_n); // initial buckets (ssim2mysql.FDb.ind_ns)
    if (!_db.ind_ns_buckets_elems) {
        FatalErrorExit("out of memory"); // (ssim2mysql.FDb.ind_ns)
    }
    memset(_db.ind_ns_buckets_elems, 0, sizeof(ssim2mysql::FNs*)*_db.ind_ns_buckets_n); // (ssim2mysql.FDb.ind_ns)
    // initialize hash table for ssim2mysql::FCtype;
    _db.ind_ctype_n             	= 0; // (ssim2mysql.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (ssim2mysql.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (ssim2mysql::FCtype**)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (ssim2mysql.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (ssim2mysql.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(ssim2mysql::FCtype*)*_db.ind_ctype_buckets_n); // (ssim2mysql.FDb.ind_ctype)
    // initialize hash table for ssim2mysql::FField;
    _db.ind_field_n             	= 0; // (ssim2mysql.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (ssim2mysql.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (ssim2mysql::FField**)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FField*)*_db.ind_field_buckets_n); // initial buckets (ssim2mysql.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (ssim2mysql.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(ssim2mysql::FField*)*_db.ind_field_buckets_n); // (ssim2mysql.FDb.ind_field)
    // initialize LAry substr (ssim2mysql.FDb.substr)
    _db.substr_n = 0;
    memset(_db.substr_lary, 0, sizeof(_db.substr_lary)); // zero out all level pointers
    ssim2mysql::FSubstr* substr_first = (ssim2mysql::FSubstr*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSubstr) * (u64(1)<<4));
    if (!substr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.substr_lary[i]  = substr_first;
        substr_first    += 1ULL<<i;
    }
    // initialize LAry ssimfile (ssim2mysql.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    ssim2mysql::FSsimfile* ssimfile_first = (ssim2mysql::FSsimfile*)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize hash table for ssim2mysql::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (ssim2mysql.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (ssim2mysql.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (ssim2mysql::FSsimfile**)algo_lib::malloc_AllocMem(sizeof(ssim2mysql::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (ssim2mysql.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (ssim2mysql.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(ssim2mysql::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (ssim2mysql.FDb.ind_ssimfile)
    _db.zs_cmd_head = NULL; // (ssim2mysql.FDb.zs_cmd)
    _db.zs_cmd_tail = NULL; // (ssim2mysql.FDb.zs_cmd)
    _db.c_cmd_cur = NULL;
    _db.c_ssimfile_cur = NULL;
    _db.n_cmd_rows = u32(0);
    // input: initialize Tpool
    _db.input_free      = NULL;
    _db.input_blocksize = algo::BumpToPow2(64 * sizeof(ssim2mysql::FInput)); // allocate 64-127 elements at a time
    _db.zd_ssimfile_head = NULL; // (ssim2mysql.FDb.zd_ssimfile)
    _db.zd_ssimfile_tail = NULL; // (ssim2mysql.FDb.zd_ssimfile)
    _db.cd_input_line_head = NULL; // (ssim2mysql.FDb.cd_input_line)

    ssim2mysql::InitReflection();
}

// --- ssim2mysql.FDb..Uninit
void ssim2mysql::FDb_Uninit() {
    ssim2mysql::FDb &row = _db; (void)row;

    // ssim2mysql.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // ssim2mysql.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.substr.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // ssim2mysql.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // ssim2mysql.FDb.ind_ns.Uninit (Thash)  //
    // skip destruction of ind_ns in global scope

    // ssim2mysql.FDb.column.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.sqltype.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope

    // ssim2mysql.FDb.ind_column.Uninit (Thash)  //
    // skip destruction of ind_column in global scope
}

// --- ssim2mysql.FField.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::field_CopyOut(ssim2mysql::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- ssim2mysql.FField.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::field_CopyIn(ssim2mysql::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- ssim2mysql.FField.ctype.Get
algo::Smallstr50 ssim2mysql::ctype_Get(ssim2mysql::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- ssim2mysql.FField.ns.Get
algo::Smallstr16 ssim2mysql::ns_Get(ssim2mysql::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- ssim2mysql.FField.name.Get
algo::Smallstr50 ssim2mysql::name_Get(ssim2mysql::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- ssim2mysql.FField..Init
// Set all fields to initial values.
void ssim2mysql::FField_Init(ssim2mysql::FField& field) {
    field.reftype = algo::strptr("Val");
    field.p_ctype = NULL;
    field.p_arg = NULL;
    field.c_substr = NULL;
    field.select = bool(false);
    field.is_pkeyref = bool(false);
    field.ctype_c_field_in_ary = bool(false);
    field.ind_field_next = (ssim2mysql::FField*)-1; // (ssim2mysql.FDb.ind_field) not-in-hash
}

// --- ssim2mysql.FField..Uninit
void ssim2mysql::FField_Uninit(ssim2mysql::FField& field) {
    ssim2mysql::FField &row = field; (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
    ind_field_Remove(row); // remove field from index ind_field
}

// --- ssim2mysql.FField..Print
// print string representation of ssim2mysql::FField to string LHS, no header -- cprint:ssim2mysql.FField.String
void ssim2mysql::FField_Print(ssim2mysql::FField & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FField";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    algo::Smallstr50_Print(row.arg, temp);
    PrintAttrSpaceReset(str,"arg", temp);

    algo::Smallstr50_Print(row.reftype, temp);
    PrintAttrSpaceReset(str,"reftype", temp);

    dmmeta::CppExpr_Print(row.dflt, temp);
    PrintAttrSpaceReset(str,"dflt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);

    u64_PrintHex(u64((const ssim2mysql::FSubstr*)row.c_substr), temp, 8, true);
    PrintAttrSpaceReset(str,"c_substr", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);

    bool_Print(row.is_pkeyref, temp);
    PrintAttrSpaceReset(str,"is_pkeyref", temp);

    bool_Print(row.ctype_c_field_in_ary, temp);
    PrintAttrSpaceReset(str,"ctype_c_field_in_ary", temp);
}

// --- ssim2mysql.FInput.in_buf.BeginRead
// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by ssim2mysql::FInput.in_buf via FIohook field.
// Whenever the file descriptor becomes readable, insert input into cd_input_line.
void ssim2mysql::in_buf_BeginRead(ssim2mysql::FInput& input, algo::Fildes fd) {
    callback_Set1(input.in_buf_iohook, input, ssim2mysql::cd_input_line_Insert);
    input.in_buf_iohook.fildes = fd;
    IOEvtFlags flags;
    read_Set(flags, true);
    if (input.in_buf_epoll_enable) {
        algo_lib::IohookAdd(input.in_buf_iohook, flags);
    } else {
        ssim2mysql::cd_input_line_Insert(input);
    }
}

// --- ssim2mysql.FInput.in_buf.EndRead
// Set EOF flag
void ssim2mysql::in_buf_EndRead(ssim2mysql::FInput& input) {
    if (ValidQ(input.in_buf_iohook.fildes)) {
        input.in_buf_eof = true;
        ssim2mysql::cd_input_line_Insert(input);
    }
}

// --- ssim2mysql.FInput.in_buf.GetMsg
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
// 
algo::aryptr<char> ssim2mysql::in_buf_GetMsg(ssim2mysql::FInput& input) {
    algo::aryptr<char> ret;
    if (!input.in_buf_msgvalid) {
        in_buf_Scanmsg(input);
        if (!input.in_buf_msgvalid) {
            bool readable = in_buf_Refill(input);
            if (readable) {
                in_buf_Scanmsg(input);
            }
        }
    }
    char *hdr = (char*)(input.in_buf_elems + input.in_buf_start);
    if (input.in_buf_msgvalid) {
        ret.elems = hdr;
        ret.n_elems = input.in_buf_msglen;
    }
    return ret;
}

// --- ssim2mysql.FInput.in_buf.Refill
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
bool ssim2mysql::in_buf_Refill(ssim2mysql::FInput& input) {
    bool readable = ValidQ(input.in_buf_iohook.fildes);
    if (readable) {
        int fd     = input.in_buf_iohook.fildes.value;
        i32 max    = in_buf_Max(input);
        i32 end    = input.in_buf_end;
        i32 nbytes = end - input.in_buf_start; // # bytes currently in buffer
        i32 nfree  = max - end; // bytes available at the end of buffer
        if (nbytes == 0 || nfree == 0) { // make more room for reading (or take advantage of free shift)
            in_buf_Shift(input);
            end = input.in_buf_end;
            nfree = max - end;
        }
        ssize_t ret         = read(fd, input.in_buf_elems + end, nfree);
        readable            = !(ret < 0 && errno == EAGAIN);
        bool error          = ret < 0 && errno != EAGAIN; // detect permanent error on this fd
        bool eof            = error || (ret == 0 && nfree > 0);
        input.in_buf_end += i32_Max(ret,0); // new end of bytes
        if (error) {
            input.in_buf_err = algo::FromErrno(errno); // fetch errno
        }
        input.in_buf_eof |= eof;
    }
    if (!readable && input.in_buf_epoll_enable) {
        ssim2mysql::cd_input_line_Remove(input);
    }
    return readable;
}

// --- ssim2mysql.FInput.in_buf.RemoveAll
// Empty bfufer
// Discard contents of the buffer.
void ssim2mysql::in_buf_RemoveAll(ssim2mysql::FInput& input) {
    input.in_buf_start    = 0;
    input.in_buf_end      = 0;
    input.in_buf_msgvalid = false;
    input.in_buf_msglen   = 0; // reset message length -- important for delimited streams
}

// --- ssim2mysql.FInput.in_buf.Scanmsg
// Internal function to scan for a message
// 
static void ssim2mysql::in_buf_Scanmsg(ssim2mysql::FInput& input) {
    char *hdr = (char*)(input.in_buf_elems + input.in_buf_start);
    i32 avail = in_buf_N(input);
    i32 msglen;
    bool found = false;
    // scan for delimiter starting from the previous place where we left off.
    // at the end, save offset back to input so we don't have to re-scan.
    // returned message length **does not include delimiter**.
    // a line that exceeds buffer length is not returned.
    for (msglen = input.in_buf_msglen; msglen < avail; msglen += sizeof(char)) {
        if (hdr[msglen] == '\n') { // delimiter?
            found = true;
            break;
        }
    }
    if (!found && msglen >= in_buf_Max(input)) {
        input.in_buf_eof = true; // cause user to detect eof
        input.in_buf_err = algo::FromErrno(E2BIG); // argument list too big -- closest error code
    }
    input.in_buf_msglen = msglen;
    input.in_buf_msgvalid = found;
}

// --- ssim2mysql.FInput.in_buf.Shift
// Internal function to shift data left
// Shift existing bytes over to the beginning of the buffer
static void ssim2mysql::in_buf_Shift(ssim2mysql::FInput& input) {
    i32 start = input.in_buf_start;
    i32 bytes_n = input.in_buf_end - start;
    if (bytes_n > 0) {
        memmove(input.in_buf_elems, input.in_buf_elems + start, bytes_n);
    }
    input.in_buf_end = bytes_n;
    input.in_buf_start = 0;
}

// --- ssim2mysql.FInput.in_buf.SkipBytes
// Skip N bytes when reading
// Mark some buffer contents as read.
// 
void ssim2mysql::in_buf_SkipBytes(ssim2mysql::FInput& input, int n) {
    int avail = input.in_buf_end - input.in_buf_start;
    n = i32_Min(n,avail);
    input.in_buf_start += n;
}

// --- ssim2mysql.FInput.in_buf.SkipMsg
// Skip current message, if any
// Skip current message, if any.
void ssim2mysql::in_buf_SkipMsg(ssim2mysql::FInput& input) {
    if (input.in_buf_msgvalid) {
        int skip = input.in_buf_msglen;
        skip += ssizeof(char); // delimiter
        i32 start = input.in_buf_start;
        start += skip;
        input.in_buf_start = start;
        input.in_buf_msgvalid = false;
        input.in_buf_msglen   = 0; // reset message length -- important for delimited streams
    }
}

// --- ssim2mysql.FInput.in_buf.WriteAll
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
// 
bool ssim2mysql::in_buf_WriteAll(ssim2mysql::FInput& input, u8 *in, i32 in_n) {
    int max = in_buf_Max(input);
    // check if message doesn't fit. if so, shift bytes over.
    if (input.in_buf_end + in_n > max) {
        in_buf_Shift(input);
    }
    // now try to write the message.
    i32 end = input.in_buf_end;
    bool fits = end + in_n <= max;
    if (fits && in_n > 0) {
        memcpy(input.in_buf_elems + end, in, in_n);
        input.in_buf_end = end + in_n;
    }
    return fits;
}

// --- ssim2mysql.FInput..Init
// Set all fields to initial values.
void ssim2mysql::FInput_Init(ssim2mysql::FInput& input) {
    input.in_buf_end = 0; // in_buf: initialize
    input.in_buf_start = 0; // in_buf: initialize
    input.in_buf_eof = false; // in_buf: initialize
    input.in_buf_msgvalid = false; // in_buf: initialize
    input.in_buf_msglen = 0; // in_buf: initialize
    input.in_buf_epoll_enable = true; // in_buf: initialize
    input.input_next = (ssim2mysql::FInput*)-1; // (ssim2mysql.FDb.input) not-in-tpool's freelist
    input.cd_input_line_next = (ssim2mysql::FInput*)-1; // (ssim2mysql.FDb.cd_input_line) not-in-list
    input.cd_input_line_prev = NULL; // (ssim2mysql.FDb.cd_input_line)
}

// --- ssim2mysql.FInput..Uninit
void ssim2mysql::FInput_Uninit(ssim2mysql::FInput& input) {
    ssim2mysql::FInput &row = input; (void)row;
    cd_input_line_Remove(row); // remove input from index cd_input_line
}

// --- ssim2mysql.FInput..Print
// print string representation of ssim2mysql::FInput to string LHS, no header -- cprint:ssim2mysql.FInput.String
void ssim2mysql::FInput_Print(ssim2mysql::FInput & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FInput";

    algo::Tuple_Print(row.tuple, temp);
    PrintAttrSpaceReset(str,"tuple", temp);

    algo::cstring_Print(row.warnstr, temp);
    PrintAttrSpaceReset(str,"warnstr", temp);
}

// --- ssim2mysql.FNs.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::ns_CopyOut(ssim2mysql::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.license = row.license;
    out.comment = row.comment;
}

// --- ssim2mysql.FNs.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::ns_CopyIn(ssim2mysql::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.license = in.license;
    row.comment = in.comment;
}

// --- ssim2mysql.FNs.c_ssimfile.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void ssim2mysql::c_ssimfile_Insert(ssim2mysql::FNs& ns, ssim2mysql::FSsimfile& row) {
    if (bool_Update(row.ns_c_ssimfile_in_ary,true)) {
        // reserve space
        c_ssimfile_Reserve(ns, 1);
        u32 n  = ns.c_ssimfile_n;
        u32 at = n;
        ssim2mysql::FSsimfile* *elems = ns.c_ssimfile_elems;
        elems[at] = &row;
        ns.c_ssimfile_n = n+1;

    }
}

// --- ssim2mysql.FNs.c_ssimfile.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool ssim2mysql::c_ssimfile_InsertMaybe(ssim2mysql::FNs& ns, ssim2mysql::FSsimfile& row) {
    bool retval = !row.ns_c_ssimfile_in_ary;
    c_ssimfile_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- ssim2mysql.FNs.c_ssimfile.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void ssim2mysql::c_ssimfile_Remove(ssim2mysql::FNs& ns, ssim2mysql::FSsimfile& row) {
    if (bool_Update(row.ns_c_ssimfile_in_ary,false)) {
        int lim = ns.c_ssimfile_n;
        ssim2mysql::FSsimfile* *elems = ns.c_ssimfile_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            ssim2mysql::FSsimfile* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(ssim2mysql::FSsimfile*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_ssimfile_n = lim - 1;
                break;
            }
        }
    }
}

// --- ssim2mysql.FNs.c_ssimfile.Reserve
// Reserve space in index for N more elements;
void ssim2mysql::c_ssimfile_Reserve(ssim2mysql::FNs& ns, u32 n) {
    u32 old_max = ns.c_ssimfile_max;
    if (UNLIKELY(ns.c_ssimfile_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(ssim2mysql::FSsimfile*);
        u32 new_size = new_max * sizeof(ssim2mysql::FSsimfile*);
        void *new_mem = algo_lib::malloc_ReallocMem(ns.c_ssimfile_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FNs.c_ssimfile");
        }
        ns.c_ssimfile_elems = (ssim2mysql::FSsimfile**)new_mem;
        ns.c_ssimfile_max = new_max;
    }
}

// --- ssim2mysql.FNs..Uninit
void ssim2mysql::FNs_Uninit(ssim2mysql::FNs& ns) {
    ssim2mysql::FNs &row = ns; (void)row;
    ind_ns_Remove(row); // remove ns from index ind_ns

    // ssim2mysql.FNs.c_ssimfile.Uninit (Ptrary)  //
    algo_lib::malloc_FreeMem(ns.c_ssimfile_elems, sizeof(ssim2mysql::FSsimfile*)*ns.c_ssimfile_max); // (ssim2mysql.FNs.c_ssimfile)
}

// --- ssim2mysql.FNs..Print
// print string representation of ssim2mysql::FNs to string LHS, no header -- cprint:ssim2mysql.FNs.String
void ssim2mysql::FNs_Print(ssim2mysql::FNs & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FNs";

    algo::Smallstr16_Print(row.ns, temp);
    PrintAttrSpaceReset(str,"ns", temp);

    algo::Smallstr50_Print(row.nstype, temp);
    PrintAttrSpaceReset(str,"nstype", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- ssim2mysql.FSqltype.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::sqltype_CopyOut(ssim2mysql::FSqltype &row, dmmeta::Sqltype &out) {
    out.ctype = row.ctype;
    out.expr = row.expr;
    out.comment = row.comment;
}

// --- ssim2mysql.FSqltype.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::sqltype_CopyIn(ssim2mysql::FSqltype &row, dmmeta::Sqltype &in) {
    row.ctype = in.ctype;
    row.expr = in.expr;
    row.comment = in.comment;
}

// --- ssim2mysql.FSqltype..Uninit
void ssim2mysql::FSqltype_Uninit(ssim2mysql::FSqltype& sqltype) {
    ssim2mysql::FSqltype &row = sqltype; (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_sqltype_Remove(*p_ctype, row);// remove sqltype from index c_sqltype
    }
}

// --- ssim2mysql.FSqltype..Print
// print string representation of ssim2mysql::FSqltype to string LHS, no header -- cprint:ssim2mysql.FSqltype.String
void ssim2mysql::FSqltype_Print(ssim2mysql::FSqltype & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FSqltype";

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    algo::Smallstr100_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- ssim2mysql.FSsimfile.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::ssimfile_CopyOut(ssim2mysql::FSsimfile &row, dmmeta::Ssimfile &out) {
    out.ssimfile = row.ssimfile;
    out.ctype = row.ctype;
}

// --- ssim2mysql.FSsimfile.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::ssimfile_CopyIn(ssim2mysql::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- ssim2mysql.FSsimfile.ssimns.Get
algo::Smallstr16 ssim2mysql::ssimns_Get(ssim2mysql::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- ssim2mysql.FSsimfile.ns.Get
algo::Smallstr16 ssim2mysql::ns_Get(ssim2mysql::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- ssim2mysql.FSsimfile.name.Get
algo::Smallstr50 ssim2mysql::name_Get(ssim2mysql::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- ssim2mysql.FSsimfile.c_column.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void ssim2mysql::c_column_Insert(ssim2mysql::FSsimfile& ssimfile, ssim2mysql::FColumn& row) {
    if (bool_Update(row.ssimfile_c_column_in_ary,true)) {
        // reserve space
        c_column_Reserve(ssimfile, 1);
        u32 n  = ssimfile.c_column_n;
        u32 at = n;
        ssim2mysql::FColumn* *elems = ssimfile.c_column_elems;
        elems[at] = &row;
        ssimfile.c_column_n = n+1;

    }
}

// --- ssim2mysql.FSsimfile.c_column.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool ssim2mysql::c_column_InsertMaybe(ssim2mysql::FSsimfile& ssimfile, ssim2mysql::FColumn& row) {
    bool retval = !row.ssimfile_c_column_in_ary;
    c_column_Insert(ssimfile,row); // check is performed in _Insert again
    return retval;
}

// --- ssim2mysql.FSsimfile.c_column.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void ssim2mysql::c_column_Remove(ssim2mysql::FSsimfile& ssimfile, ssim2mysql::FColumn& row) {
    if (bool_Update(row.ssimfile_c_column_in_ary,false)) {
        int lim = ssimfile.c_column_n;
        ssim2mysql::FColumn* *elems = ssimfile.c_column_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            ssim2mysql::FColumn* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(ssim2mysql::FColumn*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ssimfile.c_column_n = lim - 1;
                break;
            }
        }
    }
}

// --- ssim2mysql.FSsimfile.c_column.Reserve
// Reserve space in index for N more elements;
void ssim2mysql::c_column_Reserve(ssim2mysql::FSsimfile& ssimfile, u32 n) {
    u32 old_max = ssimfile.c_column_max;
    if (UNLIKELY(ssimfile.c_column_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(ssim2mysql::FColumn*);
        u32 new_size = new_max * sizeof(ssim2mysql::FColumn*);
        void *new_mem = algo_lib::malloc_ReallocMem(ssimfile.c_column_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("ssim2mysql.out_of_memory  field:ssim2mysql.FSsimfile.c_column");
        }
        ssimfile.c_column_elems = (ssim2mysql::FColumn**)new_mem;
        ssimfile.c_column_max = new_max;
    }
}

// --- ssim2mysql.FSsimfile..Init
// Set all fields to initial values.
void ssim2mysql::FSsimfile_Init(ssim2mysql::FSsimfile& ssimfile) {
    ssimfile.select = bool(false);
    ssimfile.p_ctype = NULL;
    ssimfile.truncated = bool(false);
    ssimfile.c_column_elems = NULL; // (ssim2mysql.FSsimfile.c_column)
    ssimfile.c_column_n = 0; // (ssim2mysql.FSsimfile.c_column)
    ssimfile.c_column_max = 0; // (ssim2mysql.FSsimfile.c_column)
    ssimfile.ns_c_ssimfile_in_ary = bool(false);
    ssimfile.ind_ssimfile_next = (ssim2mysql::FSsimfile*)-1; // (ssim2mysql.FDb.ind_ssimfile) not-in-hash
    ssimfile.zd_ssimfile_next = (ssim2mysql::FSsimfile*)-1; // (ssim2mysql.FDb.zd_ssimfile) not-in-list
    ssimfile.zd_ssimfile_prev = NULL; // (ssim2mysql.FDb.zd_ssimfile)
}

// --- ssim2mysql.FSsimfile..Uninit
void ssim2mysql::FSsimfile_Uninit(ssim2mysql::FSsimfile& ssimfile) {
    ssim2mysql::FSsimfile &row = ssimfile; (void)row;
    ssim2mysql::FCtype* p_ctype = ssim2mysql::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ssimfile_Remove(*p_ctype, row);// remove ssimfile from index c_ssimfile
    }
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
    zd_ssimfile_Remove(row); // remove ssimfile from index zd_ssimfile
    ssim2mysql::FNs* p_ns = ssim2mysql::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_ssimfile_Remove(*p_ns, row);// remove ssimfile from index c_ssimfile
    }

    // ssim2mysql.FSsimfile.c_column.Uninit (Ptrary)  //List of columns
    algo_lib::malloc_FreeMem(ssimfile.c_column_elems, sizeof(ssim2mysql::FColumn*)*ssimfile.c_column_max); // (ssim2mysql.FSsimfile.c_column)
}

// --- ssim2mysql.FSsimfile..Print
// print string representation of ssim2mysql::FSsimfile to string LHS, no header -- cprint:ssim2mysql.FSsimfile.String
void ssim2mysql::FSsimfile_Print(ssim2mysql::FSsimfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FSsimfile";

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Smallstr50_Print(row.ctype, temp);
    PrintAttrSpaceReset(str,"ctype", temp);

    bool_Print(row.select, temp);
    PrintAttrSpaceReset(str,"select", temp);

    bool_Print(row.truncated, temp);
    PrintAttrSpaceReset(str,"truncated", temp);

    bool_Print(row.ns_c_ssimfile_in_ary, temp);
    PrintAttrSpaceReset(str,"ns_c_ssimfile_in_ary", temp);
}

// --- ssim2mysql.FSubstr.msghdr.CopyOut
// Copy fields out of row
void ssim2mysql::substr_CopyOut(ssim2mysql::FSubstr &row, dmmeta::Substr &out) {
    out.field = row.field;
    out.expr = row.expr;
    out.srcfield = row.srcfield;
}

// --- ssim2mysql.FSubstr.msghdr.CopyIn
// Copy fields in to row
void ssim2mysql::substr_CopyIn(ssim2mysql::FSubstr &row, dmmeta::Substr &in) {
    row.field = in.field;
    row.expr = in.expr;
    row.srcfield = in.srcfield;
}

// --- ssim2mysql.FSubstr..Uninit
void ssim2mysql::FSubstr_Uninit(ssim2mysql::FSubstr& substr) {
    ssim2mysql::FSubstr &row = substr; (void)row;
    ssim2mysql::FField* p_field = ssim2mysql::ind_field_Find(row.field);
    if (p_field)  {
        c_substr_Remove(*p_field, row);// remove substr from index c_substr
    }
}

// --- ssim2mysql.FSubstr..Print
// print string representation of ssim2mysql::FSubstr to string LHS, no header -- cprint:ssim2mysql.FSubstr.String
void ssim2mysql::FSubstr_Print(ssim2mysql::FSubstr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "ssim2mysql.FSubstr";

    algo::Smallstr100_Print(row.field, temp);
    PrintAttrSpaceReset(str,"field", temp);

    dmmeta::CppExpr_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr100_Print(row.srcfield, temp);
    PrintAttrSpaceReset(str,"srcfield", temp);
}

// --- ssim2mysql.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ssim2mysql::value_ToCstr(const ssim2mysql::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ssim2mysql_FieldId_value      : ret = "value";  break;
    }
    return ret;
}

// --- ssim2mysql.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ssim2mysql::value_Print(const ssim2mysql::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ssim2mysql.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ssim2mysql::value_SetStrptrMaybe(ssim2mysql::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,ssim2mysql_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ssim2mysql.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ssim2mysql::value_SetStrptr(ssim2mysql::FieldId& parent, algo::strptr rhs, ssim2mysql_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ssim2mysql.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ssim2mysql::value_ReadStrptrMaybe(ssim2mysql::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ssim2mysql.FieldId..ReadStrptrMaybe
// Read fields of ssim2mysql::FieldId from an ascii string.
// The format of the string is the format of the ssim2mysql::FieldId's only field
bool ssim2mysql::FieldId_ReadStrptrMaybe(ssim2mysql::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ssim2mysql.FieldId..Print
// print string representation of ssim2mysql::FieldId to string LHS, no header -- cprint:ssim2mysql.FieldId.String
void ssim2mysql::FieldId_Print(ssim2mysql::FieldId & row, algo::cstring &str) {
    ssim2mysql::value_Print(row, str);
}

// --- ssim2mysql.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* ssim2mysql::value_ToCstr(const ssim2mysql::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case ssim2mysql_TableId_dmmeta_Ctype: ret = "dmmeta.Ctype";  break;
        case ssim2mysql_TableId_dmmeta_Field: ret = "dmmeta.Field";  break;
        case ssim2mysql_TableId_dmmeta_Ns  : ret = "dmmeta.Ns";  break;
        case ssim2mysql_TableId_dmmeta_Sqltype: ret = "dmmeta.Sqltype";  break;
        case ssim2mysql_TableId_dmmeta_Ssimfile: ret = "dmmeta.Ssimfile";  break;
        case ssim2mysql_TableId_dmmeta_Substr: ret = "dmmeta.Substr";  break;
    }
    return ret;
}

// --- ssim2mysql.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void ssim2mysql::value_Print(const ssim2mysql::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- ssim2mysql.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool ssim2mysql::value_SetStrptrMaybe(ssim2mysql::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Field); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_field); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Substr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_substr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"qltype",6)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Sqltype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"qltype",6)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_sqltype); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_Ssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,ssim2mysql_TableId_dmmeta_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- ssim2mysql.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void ssim2mysql::value_SetStrptr(ssim2mysql::TableId& parent, algo::strptr rhs, ssim2mysql_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- ssim2mysql.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool ssim2mysql::value_ReadStrptrMaybe(ssim2mysql::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- ssim2mysql.TableId..ReadStrptrMaybe
// Read fields of ssim2mysql::TableId from an ascii string.
// The format of the string is the format of the ssim2mysql::TableId's only field
bool ssim2mysql::TableId_ReadStrptrMaybe(ssim2mysql::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- ssim2mysql.TableId..Print
// print string representation of ssim2mysql::TableId to string LHS, no header -- cprint:ssim2mysql.TableId.String
void ssim2mysql::TableId_Print(ssim2mysql::TableId & row, algo::cstring &str) {
    ssim2mysql::value_Print(row, str);
}

// --- ssim2mysql...SizeCheck
inline static void ssim2mysql::SizeCheck() {
}

// --- ssim2mysql...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        lib_mysql::FDb_Init();
        ssim2mysql::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        ssim2mysql::ReadArgv(); // dmmeta.main:ssim2mysql
        ssim2mysql::Main(); // user-defined main
    } catch(algo_lib::ErrorX &x) {
        prerr("ssim2mysql.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        ssim2mysql::FDb_Uninit();
        lib_mysql::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- ssim2mysql...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
