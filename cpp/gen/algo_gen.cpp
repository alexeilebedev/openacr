//
// cpp/gen/algo_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace algo { // gen:ns_print_proto
    // func:algo.FileFlags.append.ReadStrptrMaybe
    inline static bool   append_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.read.ReadStrptrMaybe
    inline static bool   read_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.write.ReadStrptrMaybe
    inline static bool   write_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags._throw.ReadStrptrMaybe
    inline static bool   _throw_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.temp.ReadStrptrMaybe
    inline static bool   temp_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.overlap.ReadStrptrMaybe
    inline static bool   overlap_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.linear.ReadStrptrMaybe
    inline static bool   linear_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.FileFlags.printerr.ReadStrptrMaybe
    inline static bool   printerr_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.IOEvtFlags.read.ReadStrptrMaybe
    inline static bool   read_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.IOEvtFlags.write.ReadStrptrMaybe
    inline static bool   write_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.IOEvtFlags.eof.ReadStrptrMaybe
    inline static bool   eof_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.IOEvtFlags.err.ReadStrptrMaybe
    inline static bool   err_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.NumParseFlags.err.ReadStrptrMaybe
    inline static bool   err_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.NumParseFlags.ok.ReadStrptrMaybe
    inline static bool   ok_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.NumParseFlags.neg.ReadStrptrMaybe
    inline static bool   neg_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.NumParseFlags.overflow.ReadStrptrMaybe
    inline static bool   overflow_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo.NumParseFlags.hex.ReadStrptrMaybe
    inline static bool   hex_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // func:algo...SizeCheck
    inline static void   SizeCheck();
} // gen:ns_print_proto

// --- algo.cstring.ch.Eq
bool algo::ch_Eq(const algo::cstring& parent,const algo::cstring &rhs) {
    int len = ch_N(parent);
    if (len != ch_N(rhs)) {
        return false;
    }
    for (int i = 0; i < len; i++) {
        if (!(parent.ch_elems[i] == rhs.ch_elems[i])) {
            return false;
        }
    }
    return true;
}

// --- algo.cstring.ch.Cmp
int algo::ch_Cmp(algo::cstring& parent, algo::cstring &rhs) {
    int len = i32_Min(ch_N(parent), ch_N(rhs));
    int retval = 0;
    for (int i = 0; i < len; i++) {
        retval = char_Cmp(parent.ch_elems[i], rhs.ch_elems[i]);
        if (retval != 0) {
            return retval;
        }
    }
    return i32_Cmp(ch_N(parent), ch_N(rhs));
}

// --- algo.cstring.ch.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char> algo::ch_Addary(algo::cstring& parent, algo::aryptr<char> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ch_elems && rhs.elems < parent.ch_elems + parent.ch_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.cstring.ch  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ch_Reserve(parent, nnew); // reserve space
    int at = parent.ch_n;
    memcpy(parent.ch_elems + at, rhs.elems, nnew * sizeof(char));
    parent.ch_n += nnew;
    return algo::aryptr<char>(parent.ch_elems + at, nnew);
}

// --- algo.cstring.ch.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char& algo::ch_Alloc(algo::cstring& parent) {
    ch_Reserve(parent, 1);
    int n  = parent.ch_n;
    int at = n;
    char *elems = parent.ch_elems;
    new (elems + at) char(0); // construct new element, default initializer
    parent.ch_n = n+1;
    return elems[at];
}

// --- algo.cstring.ch.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char& algo::ch_AllocAt(algo::cstring& parent, int at) {
    ch_Reserve(parent, 1);
    int n  = parent.ch_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.cstring.ch  comment:'index out of range'");
    }
    char *elems = parent.ch_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(char));
    new (elems + at) char(0); // construct element, default initializer
    parent.ch_n = n+1;
    return elems[at];
}

// --- algo.cstring.ch.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::ch_AllocN(algo::cstring& parent, int n_elems) {
    ch_Reserve(parent, n_elems);
    int old_n  = parent.ch_n;
    int new_n = old_n + n_elems;
    char *elems = parent.ch_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.ch_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.cstring.ch.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ch_Remove(algo::cstring& parent, u32 i) {
    u32 lim = parent.ch_n;
    char *elems = parent.ch_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(char) * (lim - (i + 1)));
        parent.ch_n = lim - 1;
    }
}

// --- algo.cstring.ch.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ch_RemoveLast(algo::cstring& parent) {
    u64 n = parent.ch_n;
    if (n > 0) {
        n -= 1;
        parent.ch_n = n;
    }
}

// --- algo.cstring.ch.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ch_AbsReserve(algo::cstring& parent, int n) {
    u32 old_max  = parent.ch_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::lpool_ReallocMem(parent.ch_elems, old_max * sizeof(char), new_max * sizeof(char));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.cstring.ch  comment:'out of memory'");
        }
        parent.ch_elems = (char*)new_mem;
        parent.ch_max = new_max;
    }
}

// --- algo.cstring.ch.Print
// Convert ch to a string.
// Array is printed as a regular string.
void algo::ch_Print(algo::cstring& parent, algo::cstring &rhs) {
    rhs << ch_Getary(parent);
}

// --- algo.cstring.ch.Setary
// Copy contents of RHS to PARENT.
void algo::ch_Setary(algo::cstring& parent, algo::cstring &rhs) {
    ch_RemoveAll(parent);
    int nnew = rhs.ch_n;
    ch_Reserve(parent, nnew); // reserve space
    memcpy(parent.ch_elems, rhs.ch_elems, nnew * sizeof(char));
    parent.ch_n = nnew;
}

// --- algo.cstring.ch.Setary2
// Copy specified array into ch, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ch_Setary(algo::cstring& parent, const algo::aryptr<char> &rhs) {
    ch_RemoveAll(parent);
    ch_Addary(parent, rhs);
}

// --- algo.cstring.ch.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::ch_AllocNVal(algo::cstring& parent, int n_elems, const char& val) {
    ch_Reserve(parent, n_elems);
    int old_n  = parent.ch_n;
    int new_n = old_n + n_elems;
    char *elems = parent.ch_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.ch_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.cstring.ch.ReadStrptrMaybe
// The array is replaced with the input string. Function always succeeds.
bool algo::ch_ReadStrptrMaybe(algo::cstring& parent, algo::strptr in_str) {
    bool retval = true;
    ch_RemoveAll(parent);
    ch_Addary(parent,in_str);
    return retval;
}

// --- algo.cstring..Uninit
void algo::cstring_Uninit(algo::cstring& parent) {
    algo::cstring &row = parent; (void)row;

    // algo.cstring.ch.Uninit (Tary)  //
    // remove all elements from algo.cstring.ch
    ch_RemoveAll(parent);
    // free memory for Tary algo.cstring.ch
    algo_lib::lpool_FreeMem(parent.ch_elems, sizeof(char)*parent.ch_max); // (algo.cstring.ch)
}

// --- algo.cstring..AssignOp
algo::cstring& algo::cstring::operator =(const algo::cstring &rhs) {
    ch_Setary(*this, ch_Getary(const_cast<algo::cstring&>(rhs)));
    return *this;
}

// --- algo.cstring..CopyCtor
 algo::cstring::cstring(const algo::cstring &rhs) {
    ch_elems 	= 0; // (algo.cstring.ch)
    ch_n     	= 0; // (algo.cstring.ch)
    ch_max   	= 0; // (algo.cstring.ch)
    ch_Setary(*this, ch_Getary(const_cast<algo::cstring&>(rhs)));
}

// --- algo.Bool.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Bool& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Bool_N                   : ret = "N";  break;
        case algo_Bool_Y                   : ret = "Y";  break;
    }
    return ret;
}

// --- algo.Bool.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Bool& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Bool.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Bool& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case '0': {
                    value_SetEnum(parent,algo_Bool_0); ret = true; break;
                }
                case '1': {
                    value_SetEnum(parent,algo_Bool_1); ret = true; break;
                }
                case 'N': {
                    value_SetEnum(parent,algo_Bool_N); ret = true; break;
                }
                case 'Y': {
                    value_SetEnum(parent,algo_Bool_Y); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('n','o'): {
                    value_SetEnum(parent,algo_Bool_no); ret = true; break;
                }
                case LE_STR2('o','n'): {
                    value_SetEnum(parent,algo_Bool_on); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('o','f','f'): {
                    value_SetEnum(parent,algo_Bool_off); ret = true; break;
                }
                case LE_STR3('y','e','s'): {
                    value_SetEnum(parent,algo_Bool_yes); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_Bool_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_Bool_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Bool.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Bool& parent, algo::strptr rhs, algo_BoolEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.ByteAry.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u8> algo::ary_Addary(algo::ByteAry& parent, algo::aryptr<u8> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.ByteAry.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    memcpy(parent.ary_elems + at, rhs.elems, nnew * sizeof(u8));
    parent.ary_n += nnew;
    return algo::aryptr<u8>(parent.ary_elems + at, nnew);
}

// --- algo.ByteAry.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& algo::ary_Alloc(algo::ByteAry& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u8 *elems = parent.ary_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.ByteAry.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& algo::ary_AllocAt(algo::ByteAry& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.ByteAry.ary  comment:'index out of range'");
    }
    u8 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.ByteAry.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> algo::ary_AllocN(algo::ByteAry& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.ary_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.ary_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- algo.ByteAry.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ary_Remove(algo::ByteAry& parent, u32 i) {
    u32 lim = parent.ary_n;
    u8 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo.ByteAry.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ary_RemoveLast(algo::ByteAry& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- algo.ByteAry.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ary_AbsReserve(algo::ByteAry& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.ByteAry.ary  comment:'out of memory'");
        }
        parent.ary_elems = (u8*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- algo.ByteAry.ary.Print
// Convert ary to a string.
// Array is printed as a regular string.
void algo::ary_Print(algo::ByteAry& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(ary_Getary(parent));
}

// --- algo.ByteAry.ary.Setary
// Copy contents of RHS to PARENT.
void algo::ary_Setary(algo::ByteAry& parent, algo::ByteAry &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    memcpy(parent.ary_elems, rhs.ary_elems, nnew * sizeof(u8));
    parent.ary_n = nnew;
}

// --- algo.ByteAry.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ary_Setary(algo::ByteAry& parent, const algo::aryptr<u8> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- algo.ByteAry.ary.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> algo::ary_AllocNVal(algo::ByteAry& parent, int n_elems, const u8& val) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.ary_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.ary_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- algo.ByteAry.ary.ReadStrptrMaybe
// The array is replaced with the input string. Function always succeeds.
bool algo::ary_ReadStrptrMaybe(algo::ByteAry& parent, algo::strptr in_str) {
    bool retval = true;
    ary_RemoveAll(parent);
    ary_Addary(parent,algo::strptr_ToMemptr(in_str));
    return retval;
}

// --- algo.ByteAry..Uninit
void algo::ByteAry_Uninit(algo::ByteAry& parent) {
    algo::ByteAry &row = parent; (void)row;

    // algo.ByteAry.ary.Uninit (Tary)  //
    // remove all elements from algo.ByteAry.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo.ByteAry.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(u8)*parent.ary_max); // (algo.ByteAry.ary)
}

// --- algo.ByteAry..AssignOp
algo::ByteAry& algo::ByteAry::operator =(const algo::ByteAry &rhs) {
    ary_Setary(*this, ary_Getary(const_cast<algo::ByteAry&>(rhs)));
    return *this;
}

// --- algo.ByteAry..CopyCtor
 algo::ByteAry::ByteAry(const algo::ByteAry &rhs) {
    ary_elems 	= 0; // (algo.ByteAry.ary)
    ary_n     	= 0; // (algo.ByteAry.ary)
    ary_max   	= 0; // (algo.ByteAry.ary)
    ary_Setary(*this, ary_Getary(const_cast<algo::ByteAry&>(rhs)));
}

// --- algo.Charset.ch.Print
// Convert ch to a string.
// The separator character is ','.
void algo::ch_Print(algo::Charset& parent, algo::cstring &rhs) {
    ind_beg(Charset_ch_curs,ch_elem,parent) {
        if (ind_curs(ch_elem).index > 0) {
            rhs << ',';
        }
        u64_Print(ch_elem, rhs);
    }ind_end;
}

// --- algo.Charset.ch.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Charset& parent, algo::strptr in_str) {
    bool retval = true;
    for (int i=0; in_str != "" && i < 8; i++) {
        algo::strptr token;
        algo::NextSep(in_str, ',', token);
        retval = u64_ReadStrptrMaybe(parent.ch_elems[i], token);
        if (!retval) {
            break;
        }
    }
    return retval;
}

// --- algo.Charset.ch_bitcurs.Next
// proceed to next item
void algo::Charset_ch_bitcurs_Next(Charset_ch_bitcurs &curs) {
    ++curs.bit;
    int index = curs.bit / 64;
    int offset = curs.bit % 64;
    for (; index < curs.n_elems; ++index, offset = 0) {
        u64 rest = curs.elems[index] >> offset;
        if (rest) {
            offset += algo::u64_BitScanForward(rest);
            break;
        }
    }
    curs.bit = index * 64 + offset;
}

// --- algo.Smallstr150.ch.Print
void algo::ch_Print(algo::Smallstr150& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr150.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr150& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 150) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 150");
    }
    return retval;
}

// --- algo.Smallstr150.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr150& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 150);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr150..Hash
u32 algo::Smallstr150_Hash(u32 prev, const algo::Smallstr150& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr150..ReadStrptrMaybe
// Read fields of algo::Smallstr150 from an ascii string.
// The format of the string is the format of the algo::Smallstr150's only field
bool algo::Smallstr150_ReadStrptrMaybe(algo::Smallstr150 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr150..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr150.String  printfmt:Raw
void algo::Smallstr150_Print(algo::Smallstr150& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Comment..ReadStrptrMaybe
// Read fields of algo::Comment from an ascii string.
// The format of the string is the format of the algo::Comment's only field
bool algo::Comment_ReadStrptrMaybe(algo::Comment &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::Smallstr150_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.Comment..Print
// print string representation of ROW to string STR
// cfmt:algo.Comment.String  printfmt:Raw
void algo::Comment_Print(algo::Comment& row, algo::cstring& str) {
    algo::Smallstr150_Print(row.value, str);
}

// --- algo.Smallstr250.ch.Print
void algo::ch_Print(algo::Smallstr250& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr250.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr250& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 250) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 250");
    }
    return retval;
}

// --- algo.Smallstr250.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr250& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 250);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr250..Hash
u32 algo::Smallstr250_Hash(u32 prev, const algo::Smallstr250& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr250..ReadStrptrMaybe
// Read fields of algo::Smallstr250 from an ascii string.
// The format of the string is the format of the algo::Smallstr250's only field
bool algo::Smallstr250_ReadStrptrMaybe(algo::Smallstr250 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr250..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr250.String  printfmt:Raw
void algo::Smallstr250_Print(algo::Smallstr250& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.CppExpr..ReadStrptrMaybe
// Read fields of algo::CppExpr from an ascii string.
// The format of the string is the format of the algo::CppExpr's only field
bool algo::CppExpr_ReadStrptrMaybe(algo::CppExpr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::Smallstr250_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.CppExpr..Print
// print string representation of ROW to string STR
// cfmt:algo.CppExpr.String  printfmt:Raw
void algo::CppExpr_Print(algo::CppExpr& row, algo::cstring& str) {
    algo::Smallstr250_Print(row.value, str);
}

// --- algo.DirEntry..Init
// Set all fields to initial values.
void algo::DirEntry_Init(algo::DirEntry& parent) {
    parent.mode = u64(0);
    parent.size = u64(0);
    parent.eof = bool(false);
    parent.match = bool(false);
    parent.is_dir = bool(false);
    parent.dir_handle = NULL;
}

// --- algo.DirEntry..Uninit
void algo::DirEntry_Uninit(algo::DirEntry& parent) {
    algo::DirEntry &row = parent; (void)row;
    dir_handle_Cleanup(parent); // dmmeta.fcleanup:algo.DirEntry.dir_handle
}

// --- algo.DryrunQ..Print
// print string representation of ROW to string STR
// cfmt:algo.DryrunQ.String  printfmt:Raw
void algo::DryrunQ_Print(algo::DryrunQ row, algo::cstring& str) {
    bool_Print(row.value, str);
}

// --- algo.EchoQ.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::EchoQ& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_EchoQ_true               : ret = "true";  break;
        case algo_EchoQ_false              : ret = "false";  break;
    }
    return ret;
}

// --- algo.EchoQ.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::EchoQ& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.EchoQ.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::EchoQ& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_EchoQ_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_EchoQ_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.EchoQ.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::EchoQ& parent, algo::strptr rhs, algo_EchoQEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.EchoQ..Print
// print string representation of ROW to string STR
// cfmt:algo.EchoQ.String  printfmt:Raw
void algo::EchoQ_Print(algo::EchoQ row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.Errns.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Errns& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Errns_unix               : ret = "unix";  break;
        case algo_Errns_win                : ret = "win";  break;
    }
    return ret;
}

// --- algo.Errns.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Errns& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Errns.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Errns& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('w','i','n'): {
                    value_SetEnum(parent,algo_Errns_win); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('u','n','i','x'): {
                    value_SetEnum(parent,algo_Errns_unix); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Errns.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Errns& parent, algo::strptr rhs, algo_ErrnsEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FailokQ.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::FailokQ& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_FailokQ_true             : ret = "true";  break;
        case algo_FailokQ_false            : ret = "false";  break;
    }
    return ret;
}

// --- algo.FailokQ.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::FailokQ& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.FailokQ.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::FailokQ& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_FailokQ_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_FailokQ_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.FailokQ.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::FailokQ& parent, algo::strptr rhs, algo_FailokQEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FailokQ..Print
// print string representation of ROW to string STR
// cfmt:algo.FailokQ.String  printfmt:Raw
void algo::FailokQ_Print(algo::FailokQ row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_FieldId_name             : ret = "name";  break;
        case algo_FieldId_value            : ret = "value";  break;
        case algo_FieldId_ch               : ret = "ch";  break;
        case algo_FieldId_exponent         : ret = "exponent";  break;
        case algo_FieldId_mantissa         : ret = "mantissa";  break;
        case algo_FieldId_append           : ret = "append";  break;
        case algo_FieldId_read             : ret = "read";  break;
        case algo_FieldId_write            : ret = "write";  break;
        case algo_FieldId__throw           : ret = "_throw";  break;
        case algo_FieldId_temp             : ret = "temp";  break;
        case algo_FieldId_overlap          : ret = "overlap";  break;
        case algo_FieldId_linear           : ret = "linear";  break;
        case algo_FieldId_printerr         : ret = "printerr";  break;
        case algo_FieldId_eof              : ret = "eof";  break;
        case algo_FieldId_err              : ret = "err";  break;
        case algo_FieldId_x                : ret = "x";  break;
        case algo_FieldId_y                : ret = "y";  break;
        case algo_FieldId_ip_host          : ret = "ip_host";  break;
        case algo_FieldId_mask             : ret = "mask";  break;
        case algo_FieldId_ok               : ret = "ok";  break;
        case algo_FieldId_neg              : ret = "neg";  break;
        case algo_FieldId_overflow         : ret = "overflow";  break;
        case algo_FieldId_hex              : ret = "hex";  break;
        case algo_FieldId_sha1sig          : ret = "sha1sig";  break;
        case algo_FieldId_ary              : ret = "ary";  break;
        case algo_FieldId_attrs            : ret = "attrs";  break;
        case algo_FieldId_head             : ret = "head";  break;
        case algo_FieldId_protocol         : ret = "protocol";  break;
        case algo_FieldId_username         : ret = "username";  break;
        case algo_FieldId_password         : ret = "password";  break;
        case algo_FieldId_server           : ret = "server";  break;
        case algo_FieldId_dir              : ret = "dir";  break;
        case algo_FieldId_port             : ret = "port";  break;
        case algo_FieldId_source_addr_host : ret = "source_addr_host";  break;
        case algo_FieldId_host             : ret = "host";  break;
    }
    return ret;
}

// --- algo.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'x': {
                    value_SetEnum(parent,algo_FieldId_x); ret = true; break;
                }
                case 'y': {
                    value_SetEnum(parent,algo_FieldId_y); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('c','h'): {
                    value_SetEnum(parent,algo_FieldId_ch); ret = true; break;
                }
                case LE_STR2('o','k'): {
                    value_SetEnum(parent,algo_FieldId_ok); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','r','y'): {
                    value_SetEnum(parent,algo_FieldId_ary); ret = true; break;
                }
                case LE_STR3('d','i','r'): {
                    value_SetEnum(parent,algo_FieldId_dir); ret = true; break;
                }
                case LE_STR3('e','o','f'): {
                    value_SetEnum(parent,algo_FieldId_eof); ret = true; break;
                }
                case LE_STR3('e','r','r'): {
                    value_SetEnum(parent,algo_FieldId_err); ret = true; break;
                }
                case LE_STR3('h','e','x'): {
                    value_SetEnum(parent,algo_FieldId_hex); ret = true; break;
                }
                case LE_STR3('n','e','g'): {
                    value_SetEnum(parent,algo_FieldId_neg); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('h','e','a','d'): {
                    value_SetEnum(parent,algo_FieldId_head); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,algo_FieldId_host); ret = true; break;
                }
                case LE_STR4('m','a','s','k'): {
                    value_SetEnum(parent,algo_FieldId_mask); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,algo_FieldId_name); ret = true; break;
                }
                case LE_STR4('p','o','r','t'): {
                    value_SetEnum(parent,algo_FieldId_port); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,algo_FieldId_read); ret = true; break;
                }
                case LE_STR4('t','e','m','p'): {
                    value_SetEnum(parent,algo_FieldId_temp); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','t','t','r','s'): {
                    value_SetEnum(parent,algo_FieldId_attrs); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,algo_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,algo_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('_','t','h','r','o','w'): {
                    value_SetEnum(parent,algo_FieldId__throw); ret = true; break;
                }
                case LE_STR6('a','p','p','e','n','d'): {
                    value_SetEnum(parent,algo_FieldId_append); ret = true; break;
                }
                case LE_STR6('l','i','n','e','a','r'): {
                    value_SetEnum(parent,algo_FieldId_linear); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,algo_FieldId_server); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('i','p','_','h','o','s','t'): {
                    value_SetEnum(parent,algo_FieldId_ip_host); ret = true; break;
                }
                case LE_STR7('o','v','e','r','l','a','p'): {
                    value_SetEnum(parent,algo_FieldId_overlap); ret = true; break;
                }
                case LE_STR7('s','h','a','1','s','i','g'): {
                    value_SetEnum(parent,algo_FieldId_sha1sig); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('e','x','p','o','n','e','n','t'): {
                    value_SetEnum(parent,algo_FieldId_exponent); ret = true; break;
                }
                case LE_STR8('m','a','n','t','i','s','s','a'): {
                    value_SetEnum(parent,algo_FieldId_mantissa); ret = true; break;
                }
                case LE_STR8('o','v','e','r','f','l','o','w'): {
                    value_SetEnum(parent,algo_FieldId_overflow); ret = true; break;
                }
                case LE_STR8('p','a','s','s','w','o','r','d'): {
                    value_SetEnum(parent,algo_FieldId_password); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','e','r','r'): {
                    value_SetEnum(parent,algo_FieldId_printerr); ret = true; break;
                }
                case LE_STR8('p','r','o','t','o','c','o','l'): {
                    value_SetEnum(parent,algo_FieldId_protocol); ret = true; break;
                }
                case LE_STR8('u','s','e','r','n','a','m','e'): {
                    value_SetEnum(parent,algo_FieldId_username); ret = true; break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','o','u','r','c','e','_','a'): {
                    if (memcmp(rhs.elems+8,"ddr_host",8)==0) { value_SetEnum(parent,algo_FieldId_source_addr_host); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::FieldId& parent, algo::strptr rhs, algo_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.FieldId..ReadStrptrMaybe
// Read fields of algo::FieldId from an ascii string.
// The format of the string is the format of the algo::FieldId's only field
bool algo::FieldId_ReadStrptrMaybe(algo::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.FieldId..Print
// print string representation of ROW to string STR
// cfmt:algo.FieldId.String  printfmt:Raw
void algo::FieldId_Print(algo::FieldId& row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.Fildes..ReadStrptrMaybe
// Read fields of algo::Fildes from an ascii string.
// The format of the string is the format of the algo::Fildes's only field
bool algo::Fildes_ReadStrptrMaybe(algo::Fildes &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.Fildes..Print
// print string representation of ROW to string STR
// cfmt:algo.Fildes.String  printfmt:Raw
void algo::Fildes_Print(algo::Fildes& row, algo::cstring& str) {
    i32_Print(row.value, str);
}

// --- algo.FileFlags.append.ReadStrptrMaybe
inline static bool algo::append_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool append_tmp;
    retval = bool_ReadStrptrMaybe(append_tmp, in_str);
    if (retval) {
        append_Set(parent, append_tmp);
    }
    return retval;
}

// --- algo.FileFlags.read.ReadStrptrMaybe
inline static bool algo::read_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- algo.FileFlags.write.ReadStrptrMaybe
inline static bool algo::write_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- algo.FileFlags._throw.ReadStrptrMaybe
inline static bool algo::_throw_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool _throw_tmp;
    retval = bool_ReadStrptrMaybe(_throw_tmp, in_str);
    if (retval) {
        _throw_Set(parent, _throw_tmp);
    }
    return retval;
}

// --- algo.FileFlags.temp.ReadStrptrMaybe
inline static bool algo::temp_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool temp_tmp;
    retval = bool_ReadStrptrMaybe(temp_tmp, in_str);
    if (retval) {
        temp_Set(parent, temp_tmp);
    }
    return retval;
}

// --- algo.FileFlags.overlap.ReadStrptrMaybe
inline static bool algo::overlap_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool overlap_tmp;
    retval = bool_ReadStrptrMaybe(overlap_tmp, in_str);
    if (retval) {
        overlap_Set(parent, overlap_tmp);
    }
    return retval;
}

// --- algo.FileFlags.linear.ReadStrptrMaybe
inline static bool algo::linear_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool linear_tmp;
    retval = bool_ReadStrptrMaybe(linear_tmp, in_str);
    if (retval) {
        linear_Set(parent, linear_tmp);
    }
    return retval;
}

// --- algo.FileFlags.printerr.ReadStrptrMaybe
inline static bool algo::printerr_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool printerr_tmp;
    retval = bool_ReadStrptrMaybe(printerr_tmp, in_str);
    if (retval) {
        printerr_Set(parent, printerr_tmp);
    }
    return retval;
}

// --- algo.FileFlags..ReadFieldMaybe
bool algo::FileFlags_ReadFieldMaybe(algo::FileFlags& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case algo_FieldId_value: {
            retval = u32_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case algo_FieldId_append: {
            retval = append_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_read: {
            retval = read_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_write: {
            retval = write_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId__throw: {
            retval = _throw_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_temp: {
            retval = temp_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_overlap: {
            retval = overlap_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_linear: {
            retval = linear_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_printerr: {
            retval = printerr_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.FileFlags..ReadStrptrMaybe
// Read fields of algo::FileFlags from an ascii string.
bool algo::FileFlags_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    append_Set(parent, false);
    read_Set(parent, false);
    write_Set(parent, false);
    _throw_Set(parent, false);
    temp_Set(parent, false);
    overlap_Set(parent, false);
    linear_Set(parent, false);
    printerr_Set(parent, false);
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_append: {
                        append_Set(parent, true);
                    } break;
                    case algo_FieldId_read: {
                        read_Set(parent, true);
                    } break;
                    case algo_FieldId_write: {
                        write_Set(parent, true);
                    } break;
                    case algo_FieldId__throw: {
                        _throw_Set(parent, true);
                    } break;
                    case algo_FieldId_temp: {
                        temp_Set(parent, true);
                    } break;
                    case algo_FieldId_overlap: {
                        overlap_Set(parent, true);
                    } break;
                    case algo_FieldId_linear: {
                        linear_Set(parent, true);
                    } break;
                    case algo_FieldId_printerr: {
                        printerr_Set(parent, true);
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.FileFlags..Print
// print string representation of ROW to string STR
// cfmt:algo.FileFlags.String  printfmt:Bitset
void algo::FileFlags_Print(algo::FileFlags& row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (append_Get(row)) {
        str << ls << "append";
    }
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (_throw_Get(row)) {
        str << ls << "_throw";
    }
    if (temp_Get(row)) {
        str << ls << "temp";
    }
    if (overlap_Get(row)) {
        str << ls << "overlap";
    }
    if (linear_Get(row)) {
        str << ls << "linear";
    }
    if (printerr_Get(row)) {
        str << ls << "printerr";
    }
}

// --- algo.FileFlags..GetAnon
algo::strptr algo::FileFlags_GetAnon(algo::FileFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.I32Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec1& parent, double val) {
    double intval = val * 10;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec1.value.Print
void algo::value_Print(algo::I32Dec1& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.I32Dec1..ReadStrptrMaybe
// Read fields of algo::I32Dec1 from an ascii string.
// The format of the string is the format of the algo::I32Dec1's only field
bool algo::I32Dec1_ReadStrptrMaybe(algo::I32Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec1..Print
// print string representation of ROW to string STR
// cfmt:algo.I32Dec1.String  printfmt:Raw
void algo::I32Dec1_Print(algo::I32Dec1 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec2& parent, double val) {
    double intval = val * 100;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec2.value.Print
void algo::value_Print(algo::I32Dec2& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.I32Dec2..ReadStrptrMaybe
// Read fields of algo::I32Dec2 from an ascii string.
// The format of the string is the format of the algo::I32Dec2's only field
bool algo::I32Dec2_ReadStrptrMaybe(algo::I32Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec2..Print
// print string representation of ROW to string STR
// cfmt:algo.I32Dec2.String  printfmt:Raw
void algo::I32Dec2_Print(algo::I32Dec2 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec3& parent, double val) {
    double intval = val * 1000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec3.value.Print
void algo::value_Print(algo::I32Dec3& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.I32Dec3..ReadStrptrMaybe
// Read fields of algo::I32Dec3 from an ascii string.
// The format of the string is the format of the algo::I32Dec3's only field
bool algo::I32Dec3_ReadStrptrMaybe(algo::I32Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec3..Print
// print string representation of ROW to string STR
// cfmt:algo.I32Dec3.String  printfmt:Raw
void algo::I32Dec3_Print(algo::I32Dec3 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec4& parent, double val) {
    double intval = val * 10000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec4.value.Print
void algo::value_Print(algo::I32Dec4& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.I32Dec4..ReadStrptrMaybe
// Read fields of algo::I32Dec4 from an ascii string.
// The format of the string is the format of the algo::I32Dec4's only field
bool algo::I32Dec4_ReadStrptrMaybe(algo::I32Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec4..Print
// print string representation of ROW to string STR
// cfmt:algo.I32Dec4.String  printfmt:Raw
void algo::I32Dec4_Print(algo::I32Dec4 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec5& parent, double val) {
    double intval = val * 100000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec5.value.Print
void algo::value_Print(algo::I32Dec5& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.I32Dec5..ReadStrptrMaybe
// Read fields of algo::I32Dec5 from an ascii string.
// The format of the string is the format of the algo::I32Dec5's only field
bool algo::I32Dec5_ReadStrptrMaybe(algo::I32Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec5..Print
// print string representation of ROW to string STR
// cfmt:algo.I32Dec5.String  printfmt:Raw
void algo::I32Dec5_Print(algo::I32Dec5 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec1& parent, double val) {
    double intval = val * 10;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec1.value.Print
void algo::value_Print(algo::I64Dec1& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.I64Dec1..ReadStrptrMaybe
// Read fields of algo::I64Dec1 from an ascii string.
// The format of the string is the format of the algo::I64Dec1's only field
bool algo::I64Dec1_ReadStrptrMaybe(algo::I64Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec1..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec1.String  printfmt:Raw
void algo::I64Dec1_Print(algo::I64Dec1 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec10.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec10& parent, double val) {
    double intval = val * 10000000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec10.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec10& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 10) { // ignore digits after 10'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 10) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec10.value.Print
void algo::value_Print(algo::I64Dec10& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 10, value_start, true);
}

// --- algo.I64Dec10..ReadStrptrMaybe
// Read fields of algo::I64Dec10 from an ascii string.
// The format of the string is the format of the algo::I64Dec10's only field
bool algo::I64Dec10_ReadStrptrMaybe(algo::I64Dec10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec10..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec10.String  printfmt:Raw
void algo::I64Dec10_Print(algo::I64Dec10 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec2& parent, double val) {
    double intval = val * 100;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec2.value.Print
void algo::value_Print(algo::I64Dec2& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.I64Dec2..ReadStrptrMaybe
// Read fields of algo::I64Dec2 from an ascii string.
// The format of the string is the format of the algo::I64Dec2's only field
bool algo::I64Dec2_ReadStrptrMaybe(algo::I64Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec2..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec2.String  printfmt:Raw
void algo::I64Dec2_Print(algo::I64Dec2 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec3& parent, double val) {
    double intval = val * 1000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec3.value.Print
void algo::value_Print(algo::I64Dec3& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.I64Dec3..ReadStrptrMaybe
// Read fields of algo::I64Dec3 from an ascii string.
// The format of the string is the format of the algo::I64Dec3's only field
bool algo::I64Dec3_ReadStrptrMaybe(algo::I64Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec3..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec3.String  printfmt:Raw
void algo::I64Dec3_Print(algo::I64Dec3 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec4& parent, double val) {
    double intval = val * 10000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec4.value.Print
void algo::value_Print(algo::I64Dec4& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.I64Dec4..ReadStrptrMaybe
// Read fields of algo::I64Dec4 from an ascii string.
// The format of the string is the format of the algo::I64Dec4's only field
bool algo::I64Dec4_ReadStrptrMaybe(algo::I64Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec4..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec4.String  printfmt:Raw
void algo::I64Dec4_Print(algo::I64Dec4 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec5& parent, double val) {
    double intval = val * 100000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec5.value.Print
void algo::value_Print(algo::I64Dec5& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.I64Dec5..ReadStrptrMaybe
// Read fields of algo::I64Dec5 from an ascii string.
// The format of the string is the format of the algo::I64Dec5's only field
bool algo::I64Dec5_ReadStrptrMaybe(algo::I64Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec5..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec5.String  printfmt:Raw
void algo::I64Dec5_Print(algo::I64Dec5 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec6.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec6& parent, double val) {
    double intval = val * 1000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec6.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec6& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 6) { // ignore digits after 6'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 6) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec6.value.Print
void algo::value_Print(algo::I64Dec6& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 6, value_start, true);
}

// --- algo.I64Dec6..ReadStrptrMaybe
// Read fields of algo::I64Dec6 from an ascii string.
// The format of the string is the format of the algo::I64Dec6's only field
bool algo::I64Dec6_ReadStrptrMaybe(algo::I64Dec6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec6..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec6.String  printfmt:Raw
void algo::I64Dec6_Print(algo::I64Dec6 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec7.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec7& parent, double val) {
    double intval = val * 10000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec7.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec7& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 7) { // ignore digits after 7'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 7) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec7.value.Print
void algo::value_Print(algo::I64Dec7& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 7, value_start, true);
}

// --- algo.I64Dec7..ReadStrptrMaybe
// Read fields of algo::I64Dec7 from an ascii string.
// The format of the string is the format of the algo::I64Dec7's only field
bool algo::I64Dec7_ReadStrptrMaybe(algo::I64Dec7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec7..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec7.String  printfmt:Raw
void algo::I64Dec7_Print(algo::I64Dec7 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec8.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec8& parent, double val) {
    double intval = val * 100000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec8.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec8& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 8) { // ignore digits after 8'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 8) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec8.value.Print
void algo::value_Print(algo::I64Dec8& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 8, value_start, true);
}

// --- algo.I64Dec8..ReadStrptrMaybe
// Read fields of algo::I64Dec8 from an ascii string.
// The format of the string is the format of the algo::I64Dec8's only field
bool algo::I64Dec8_ReadStrptrMaybe(algo::I64Dec8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec8..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec8.String  printfmt:Raw
void algo::I64Dec8_Print(algo::I64Dec8 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec9.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec9& parent, double val) {
    double intval = val * 1000000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec9.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec9& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 9) { // ignore digits after 9'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 9) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec9.value.Print
void algo::value_Print(algo::I64Dec9& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 9, value_start, true);
}

// --- algo.I64Dec9..ReadStrptrMaybe
// Read fields of algo::I64Dec9 from an ascii string.
// The format of the string is the format of the algo::I64Dec9's only field
bool algo::I64Dec9_ReadStrptrMaybe(algo::I64Dec9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec9..Print
// print string representation of ROW to string STR
// cfmt:algo.I64Dec9.String  printfmt:Raw
void algo::I64Dec9_Print(algo::I64Dec9 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.IOEvtFlags.read.ReadStrptrMaybe
inline static bool algo::read_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.write.ReadStrptrMaybe
inline static bool algo::write_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.eof.ReadStrptrMaybe
inline static bool algo::eof_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool eof_tmp;
    retval = bool_ReadStrptrMaybe(eof_tmp, in_str);
    if (retval) {
        eof_Set(parent, eof_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.err.ReadStrptrMaybe
inline static bool algo::err_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool err_tmp;
    retval = bool_ReadStrptrMaybe(err_tmp, in_str);
    if (retval) {
        err_Set(parent, err_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags..ReadFieldMaybe
bool algo::IOEvtFlags_ReadFieldMaybe(algo::IOEvtFlags& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case algo_FieldId_value: {
            retval = u32_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case algo_FieldId_read: {
            retval = read_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_write: {
            retval = write_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_eof: {
            retval = eof_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_err: {
            retval = err_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.IOEvtFlags..ReadStrptrMaybe
// Read fields of algo::IOEvtFlags from an ascii string.
bool algo::IOEvtFlags_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    read_Set(parent, false);
    write_Set(parent, false);
    eof_Set(parent, false);
    err_Set(parent, false);
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_read: {
                        read_Set(parent, true);
                    } break;
                    case algo_FieldId_write: {
                        write_Set(parent, true);
                    } break;
                    case algo_FieldId_eof: {
                        eof_Set(parent, true);
                    } break;
                    case algo_FieldId_err: {
                        err_Set(parent, true);
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.IOEvtFlags..Print
// print string representation of ROW to string STR
// cfmt:algo.IOEvtFlags.String  printfmt:Bitset
void algo::IOEvtFlags_Print(algo::IOEvtFlags& row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (eof_Get(row)) {
        str << ls << "eof";
    }
    if (err_Get(row)) {
        str << ls << "err";
    }
}

// --- algo.IOEvtFlags..GetAnon
algo::strptr algo::IOEvtFlags_GetAnon(algo::IOEvtFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.IPoint..ReadFieldMaybe
bool algo::IPoint_ReadFieldMaybe(algo::IPoint& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case algo_FieldId_x: {
            retval = i32_ReadStrptrMaybe(parent.x, strval);
            break;
        }
        case algo_FieldId_y: {
            retval = i32_ReadStrptrMaybe(parent.y, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.IPoint..ReadStrptrMaybe
// Read fields of algo::IPoint from an ascii string.
// The format of the string is a string with separated values
bool algo::IPoint_ReadStrptrMaybe(algo::IPoint &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, ' ', value);
    retval = retval && i32_ReadStrptrMaybe(parent.x, value);

    value = in_str;
    retval = retval && i32_ReadStrptrMaybe(parent.y, value);
    return retval;
}

// --- algo.IPoint..Print
// print string representation of ROW to string STR
// cfmt:algo.IPoint.String  printfmt:Sep
void algo::IPoint_Print(algo::IPoint& row, algo::cstring& str) {
    i32_Print(row.x, str);
    str << ' ';
    i32_Print(row.y, str);
}

// --- algo.Smallstr50.ch.Print
void algo::ch_Print(algo::Smallstr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.Smallstr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr50& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr50..Hash
u32 algo::Smallstr50_Hash(u32 prev, const algo::Smallstr50& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr50..ReadStrptrMaybe
// Read fields of algo::Smallstr50 from an ascii string.
// The format of the string is the format of the algo::Smallstr50's only field
bool algo::Smallstr50_ReadStrptrMaybe(algo::Smallstr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr50..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr50.String  printfmt:Raw
void algo::Smallstr50_Print(algo::Smallstr50& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Imdb..Print
// print string representation of ROW to string STR
// cfmt:algo.Imdb.String  printfmt:Tuple
void algo::Imdb_Print(algo::Imdb& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "algo.Imdb";

    algo::Smallstr50_Print(row.imdb, temp);
    PrintAttrSpaceReset(str,"imdb", temp);





    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- algo.ImrowPtr..Print
// print string representation of ROW to string STR
// cfmt:algo.ImrowPtr.String  printfmt:Raw
void algo::ImrowPtr_Print(algo::ImrowPtr& row, algo::cstring& str) {
    u64_Print(row.value, str);
}

// --- algo.Smallstr100.ch.Print
void algo::ch_Print(algo::Smallstr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.Smallstr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr100& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr100..Hash
u32 algo::Smallstr100_Hash(u32 prev, const algo::Smallstr100& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr100..ReadStrptrMaybe
// Read fields of algo::Smallstr100 from an ascii string.
// The format of the string is the format of the algo::Smallstr100's only field
bool algo::Smallstr100_ReadStrptrMaybe(algo::Smallstr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr100..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr100.String  printfmt:Raw
void algo::Smallstr100_Print(algo::Smallstr100& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Imtable..Print
// print string representation of ROW to string STR
// cfmt:algo.Imtable.String  printfmt:Tuple
void algo::Imtable_Print(algo::Imtable& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "algo.Imtable";

    algo::Smallstr50_Print(row.imtable, temp);
    PrintAttrSpaceReset(str,"imtable", temp);

    algo::Smallstr100_Print(row.elem_type, temp);
    PrintAttrSpaceReset(str,"elem_type", temp);





    i32_Print(row.size, temp);
    PrintAttrSpaceReset(str,"size", temp);

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- algo.LineBuf.buf.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char> algo::buf_Addary(algo::LineBuf& parent, algo::aryptr<char> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.buf_elems && rhs.elems < parent.buf_elems + parent.buf_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.LineBuf.buf  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    buf_Reserve(parent, nnew); // reserve space
    int at = parent.buf_n;
    memcpy(parent.buf_elems + at, rhs.elems, nnew * sizeof(char));
    parent.buf_n += nnew;
    return algo::aryptr<char>(parent.buf_elems + at, nnew);
}

// --- algo.LineBuf.buf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char& algo::buf_Alloc(algo::LineBuf& parent) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    int at = n;
    char *elems = parent.buf_elems;
    new (elems + at) char(0); // construct new element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- algo.LineBuf.buf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char& algo::buf_AllocAt(algo::LineBuf& parent, int at) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.LineBuf.buf  comment:'index out of range'");
    }
    char *elems = parent.buf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(char));
    new (elems + at) char(0); // construct element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- algo.LineBuf.buf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::buf_AllocN(algo::LineBuf& parent, int n_elems) {
    buf_Reserve(parent, n_elems);
    int old_n  = parent.buf_n;
    int new_n = old_n + n_elems;
    char *elems = parent.buf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.buf_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.LineBuf.buf.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::buf_Remove(algo::LineBuf& parent, u32 i) {
    u32 lim = parent.buf_n;
    char *elems = parent.buf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(char) * (lim - (i + 1)));
        parent.buf_n = lim - 1;
    }
}

// --- algo.LineBuf.buf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::buf_RemoveLast(algo::LineBuf& parent) {
    u64 n = parent.buf_n;
    if (n > 0) {
        n -= 1;
        parent.buf_n = n;
    }
}

// --- algo.LineBuf.buf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::buf_AbsReserve(algo::LineBuf& parent, int n) {
    u32 old_max  = parent.buf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.buf_elems, old_max * sizeof(char), new_max * sizeof(char));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.LineBuf.buf  comment:'out of memory'");
        }
        parent.buf_elems = (char*)new_mem;
        parent.buf_max = new_max;
    }
}

// --- algo.LineBuf.buf.Print
// Convert buf to a string.
// Array is printed as a regular string.
void algo::buf_Print(algo::LineBuf& parent, algo::cstring &rhs) {
    rhs << buf_Getary(parent);
}

// --- algo.LineBuf.buf.Setary
// Copy contents of RHS to PARENT.
void algo::buf_Setary(algo::LineBuf& parent, algo::LineBuf &rhs) {
    buf_RemoveAll(parent);
    int nnew = rhs.buf_n;
    buf_Reserve(parent, nnew); // reserve space
    memcpy(parent.buf_elems, rhs.buf_elems, nnew * sizeof(char));
    parent.buf_n = nnew;
}

// --- algo.LineBuf.buf.Setary2
// Copy specified array into buf, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::buf_Setary(algo::LineBuf& parent, const algo::aryptr<char> &rhs) {
    buf_RemoveAll(parent);
    buf_Addary(parent, rhs);
}

// --- algo.LineBuf.buf.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::buf_AllocNVal(algo::LineBuf& parent, int n_elems, const char& val) {
    buf_Reserve(parent, n_elems);
    int old_n  = parent.buf_n;
    int new_n = old_n + n_elems;
    char *elems = parent.buf_elems;
    memset(elems + old_n, val, new_n - old_n); // initialize new space
    parent.buf_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.LineBuf.buf.ReadStrptrMaybe
// The array is replaced with the input string. Function always succeeds.
bool algo::buf_ReadStrptrMaybe(algo::LineBuf& parent, algo::strptr in_str) {
    bool retval = true;
    buf_RemoveAll(parent);
    buf_Addary(parent,in_str);
    return retval;
}

// --- algo.LineBuf..Uninit
void algo::LineBuf_Uninit(algo::LineBuf& parent) {
    algo::LineBuf &row = parent; (void)row;

    // algo.LineBuf.buf.Uninit (Tary)  //
    // remove all elements from algo.LineBuf.buf
    buf_RemoveAll(parent);
    // free memory for Tary algo.LineBuf.buf
    algo_lib::malloc_FreeMem(parent.buf_elems, sizeof(char)*parent.buf_max); // (algo.LineBuf.buf)
}

// --- algo.LineBuf..AssignOp
algo::LineBuf& algo::LineBuf::operator =(const algo::LineBuf &rhs) {
    buf_Setary(*this, buf_Getary(const_cast<algo::LineBuf&>(rhs)));
    incoming = rhs.incoming;
    implied_eof = rhs.implied_eof;
    eof = rhs.eof;
    return *this;
}

// --- algo.LineBuf..CopyCtor
 algo::LineBuf::LineBuf(const algo::LineBuf &rhs)
    : incoming(rhs.incoming)
    , implied_eof(rhs.implied_eof)
    , eof(rhs.eof)
 {
    buf_elems 	= 0; // (algo.LineBuf.buf)
    buf_n     	= 0; // (algo.LineBuf.buf)
    buf_max   	= 0; // (algo.LineBuf.buf)
    buf_Setary(*this, buf_Getary(const_cast<algo::LineBuf&>(rhs)));
}

// --- algo.LnumStr10_U64.ch.Print
void algo::ch_Print(algo::LnumStr10_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr10_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr10_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.LnumStr10_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr10_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 10 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr10_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr10_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum16(str, ok);
        and_ok &= (ok != 0);
    }
    return u64(val);
}

// --- algo.LnumStr10_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr10_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr10_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr10_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr10_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr10_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 10;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr10_U64..Hash
u32 algo::LnumStr10_U64_Hash(u32 prev, const algo::LnumStr10_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr10_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr10_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr10_U64's only field
bool algo::LnumStr10_U64_ReadStrptrMaybe(algo::LnumStr10_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr10_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr10_U64.String  printfmt:Raw
void algo::LnumStr10_U64_Print(algo::LnumStr10_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr11_U64.ch.Print
void algo::ch_Print(algo::LnumStr11_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr11_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr11_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.LnumStr11_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr11_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 11 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr11_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr11_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum16(str, ok);
        and_ok &= (ok != 0);
    }
    return u64(val);
}

// --- algo.LnumStr11_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr11_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr11_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr11_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr11_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr11_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 11;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr11_U64..Hash
u32 algo::LnumStr11_U64_Hash(u32 prev, const algo::LnumStr11_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr11_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr11_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr11_U64's only field
bool algo::LnumStr11_U64_ReadStrptrMaybe(algo::LnumStr11_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr11_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr11_U64.String  printfmt:Raw
void algo::LnumStr11_U64_Print(algo::LnumStr11_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr12_U64.ch.Print
void algo::ch_Print(algo::LnumStr12_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr12_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr12_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.LnumStr12_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr12_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 12 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr12_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr12_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum16(str, ok);
        and_ok &= (ok != 0);
    }
    return u64(val);
}

// --- algo.LnumStr12_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr12_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr12_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr12_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr12_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr12_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 12;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr12_U64..Hash
u32 algo::LnumStr12_U64_Hash(u32 prev, const algo::LnumStr12_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr12_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr12_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr12_U64's only field
bool algo::LnumStr12_U64_ReadStrptrMaybe(algo::LnumStr12_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr12_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr12_U64.String  printfmt:Raw
void algo::LnumStr12_U64_Print(algo::LnumStr12_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr13_U64_Base36.ch.Print
void algo::ch_Print(algo::LnumStr13_U64_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr13_U64_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr13_U64_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 13) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 13");
    }
    return retval;
}

// --- algo.LnumStr13_U64_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr13_U64_Base36& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 13);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 13 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr13_U64_Base36.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr13_U64_Base36& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*36 + digit;
        and_ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr13_U64_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr13_U64_Base36& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr13_U64_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr13_U64_Base36& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr13_U64_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr13_U64_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 13;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Hash
u32 algo::LnumStr13_U64_Base36_Hash(u32 prev, const algo::LnumStr13_U64_Base36& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr13_U64_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr13_U64_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr13_U64_Base36's only field
bool algo::LnumStr13_U64_Base36_ReadStrptrMaybe(algo::LnumStr13_U64_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr13_U64_Base36.String  printfmt:Raw
void algo::LnumStr13_U64_Base36_Print(algo::LnumStr13_U64_Base36& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr16_U64_Base16.ch.Print
void algo::ch_Print(algo::LnumStr16_U64_Base16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr16_U64_Base16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr16_U64_Base16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.LnumStr16_U64_Base16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr16_U64_Base16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 16 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr16_U64_Base16.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr16_U64_Base16& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 16-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 16-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        val = val*16 + digit;
    }
    and_ok &= val <= 0XFFFFFFFFFFFFFFFF;
    return u64(val);
}

// --- algo.LnumStr16_U64_Base16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr16_U64_Base16& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr16_U64_Base16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr16_U64_Base16& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr16_U64_Base16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr16_U64_Base16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 16);
        val = val / 16;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 16;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Hash
u32 algo::LnumStr16_U64_Base16_Hash(u32 prev, const algo::LnumStr16_U64_Base16& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr16_U64_Base16..ReadStrptrMaybe
// Read fields of algo::LnumStr16_U64_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr16_U64_Base16's only field
bool algo::LnumStr16_U64_Base16_ReadStrptrMaybe(algo::LnumStr16_U64_Base16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr16_U64_Base16.String  printfmt:Raw
void algo::LnumStr16_U64_Base16_Print(algo::LnumStr16_U64_Base16& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr1_U32.ch.Print
void algo::ch_Print(algo::LnumStr1_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr1_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr1_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.LnumStr1_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr1_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 1 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr1_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr1_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum4(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr1_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr1_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr1_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr1_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr1_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr1_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 1;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr1_U32..Hash
u32 algo::LnumStr1_U32_Hash(u32 prev, const algo::LnumStr1_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr1_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr1_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr1_U32's only field
bool algo::LnumStr1_U32_ReadStrptrMaybe(algo::LnumStr1_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr1_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr1_U32.String  printfmt:Raw
void algo::LnumStr1_U32_Print(algo::LnumStr1_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr20_U64.ch.Print
void algo::ch_Print(algo::LnumStr20_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr20_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr20_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LnumStr20_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr20_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr20_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr20_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            and_ok = false;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        and_ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr20_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr20_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr20_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr20_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr20_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr20_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr20_U64..Hash
u32 algo::LnumStr20_U64_Hash(u32 prev, const algo::LnumStr20_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr20_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr20_U64's only field
bool algo::LnumStr20_U64_ReadStrptrMaybe(algo::LnumStr20_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr20_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr20_U64.String  printfmt:Raw
void algo::LnumStr20_U64_Print(algo::LnumStr20_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr22_U64.ch.Print
void algo::ch_Print(algo::LnumStr22_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr22_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr22_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 22) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 22");
    }
    return retval;
}

// --- algo.LnumStr22_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr22_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 22);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 22 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr22_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr22_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            and_ok = false;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        and_ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr22_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr22_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr22_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr22_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr22_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr22_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 22;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr22_U64..Hash
u32 algo::LnumStr22_U64_Hash(u32 prev, const algo::LnumStr22_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr22_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr22_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr22_U64's only field
bool algo::LnumStr22_U64_ReadStrptrMaybe(algo::LnumStr22_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr22_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr22_U64.String  printfmt:Raw
void algo::LnumStr22_U64_Print(algo::LnumStr22_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr2_U32.ch.Print
void algo::ch_Print(algo::LnumStr2_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr2_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr2_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.LnumStr2_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr2_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 2 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr2_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr2_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum4(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr2_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr2_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr2_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr2_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr2_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr2_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 2;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr2_U32..Hash
u32 algo::LnumStr2_U32_Hash(u32 prev, const algo::LnumStr2_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr2_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr2_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr2_U32's only field
bool algo::LnumStr2_U32_ReadStrptrMaybe(algo::LnumStr2_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr2_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr2_U32.String  printfmt:Raw
void algo::LnumStr2_U32_Print(algo::LnumStr2_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr3_U32.ch.Print
void algo::ch_Print(algo::LnumStr3_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr3_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr3_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LnumStr3_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr3_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr3_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr3_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum4(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr3_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr3_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr3_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr3_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr3_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr3_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 3;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr3_U32..Hash
u32 algo::LnumStr3_U32_Hash(u32 prev, const algo::LnumStr3_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr3_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr3_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr3_U32's only field
bool algo::LnumStr3_U32_ReadStrptrMaybe(algo::LnumStr3_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr3_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr3_U32.String  printfmt:Raw
void algo::LnumStr3_U32_Print(algo::LnumStr3_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr4_U32.ch.Print
void algo::ch_Print(algo::LnumStr4_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr4_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr4_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.LnumStr4_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr4_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 4 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr4_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr4_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum4(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr4_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr4_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr4_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr4_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr4_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr4_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 4;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr4_U32..Hash
u32 algo::LnumStr4_U32_Hash(u32 prev, const algo::LnumStr4_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr4_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr4_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr4_U32's only field
bool algo::LnumStr4_U32_ReadStrptrMaybe(algo::LnumStr4_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr4_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr4_U32.String  printfmt:Raw
void algo::LnumStr4_U32_Print(algo::LnumStr4_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr5_U32.ch.Print
void algo::ch_Print(algo::LnumStr5_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr5_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr5_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LnumStr5_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr5_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr5_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr5_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr5_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr5_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr5_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr5_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr5_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr5_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr5_U32..Hash
u32 algo::LnumStr5_U32_Hash(u32 prev, const algo::LnumStr5_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr5_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr5_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32's only field
bool algo::LnumStr5_U32_ReadStrptrMaybe(algo::LnumStr5_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr5_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr5_U32.String  printfmt:Raw
void algo::LnumStr5_U32_Print(algo::LnumStr5_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr5_U32_Base36.ch.Print
void algo::ch_Print(algo::LnumStr5_U32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr5_U32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr5_U32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LnumStr5_U32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr5_U32_Base36& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr5_U32_Base36.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr5_U32_Base36& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        val = val*36 + digit;
    }
    return u32(val);
}

// --- algo.LnumStr5_U32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr5_U32_Base36& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr5_U32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr5_U32_Base36& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr5_U32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr5_U32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Hash
u32 algo::LnumStr5_U32_Base36_Hash(u32 prev, const algo::LnumStr5_U32_Base36& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr5_U32_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr5_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32_Base36's only field
bool algo::LnumStr5_U32_Base36_ReadStrptrMaybe(algo::LnumStr5_U32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr5_U32_Base36.String  printfmt:Raw
void algo::LnumStr5_U32_Base36_Print(algo::LnumStr5_U32_Base36& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr6_U32.ch.Print
void algo::ch_Print(algo::LnumStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LnumStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr6_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr6_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr6_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr6_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr6_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr6_U32..Hash
u32 algo::LnumStr6_U32_Hash(u32 prev, const algo::LnumStr6_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr6_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr6_U32's only field
bool algo::LnumStr6_U32_ReadStrptrMaybe(algo::LnumStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr6_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr6_U32.String  printfmt:Raw
void algo::LnumStr6_U32_Print(algo::LnumStr6_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr7_U32.ch.Print
void algo::ch_Print(algo::LnumStr7_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr7_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr7_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LnumStr7_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr7_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr7_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr7_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr7_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr7_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr7_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr7_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr7_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr7_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr7_U32..Hash
u32 algo::LnumStr7_U32_Hash(u32 prev, const algo::LnumStr7_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr7_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr7_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32's only field
bool algo::LnumStr7_U32_ReadStrptrMaybe(algo::LnumStr7_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr7_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr7_U32.String  printfmt:Raw
void algo::LnumStr7_U32_Print(algo::LnumStr7_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr7_U32_Base36.ch.Print
void algo::ch_Print(algo::LnumStr7_U32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr7_U32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr7_U32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LnumStr7_U32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr7_U32_Base36& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr7_U32_Base36.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr7_U32_Base36& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        val = val*36 + digit;
    }
    and_ok &= val <= 0XFFFFFFFF;
    return u32(val);
}

// --- algo.LnumStr7_U32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr7_U32_Base36& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr7_U32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr7_U32_Base36& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr7_U32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr7_U32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Hash
u32 algo::LnumStr7_U32_Base36_Hash(u32 prev, const algo::LnumStr7_U32_Base36& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr7_U32_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr7_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32_Base36's only field
bool algo::LnumStr7_U32_Base36_ReadStrptrMaybe(algo::LnumStr7_U32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr7_U32_Base36.String  printfmt:Raw
void algo::LnumStr7_U32_Base36_Print(algo::LnumStr7_U32_Base36& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U32.ch.Print
void algo::ch_Print(algo::LnumStr8_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr8_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr8_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr8_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr8_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U32..Hash
u32 algo::LnumStr8_U32_Hash(u32 prev, const algo::LnumStr8_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32's only field
bool algo::LnumStr8_U32_ReadStrptrMaybe(algo::LnumStr8_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr8_U32.String  printfmt:Raw
void algo::LnumStr8_U32_Print(algo::LnumStr8_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U32_Base16.ch.Print
void algo::ch_Print(algo::LnumStr8_U32_Base16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U32_Base16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U32_Base16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U32_Base16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U32_Base16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U32_Base16.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr8_U32_Base16& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 16-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 16-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        val = val*16 + digit;
    }
    and_ok &= val <= 0XFFFFFFFF;
    return u32(val);
}

// --- algo.LnumStr8_U32_Base16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr8_U32_Base16& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U32_Base16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U32_Base16& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr8_U32_Base16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U32_Base16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 16);
        val = val / 16;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Hash
u32 algo::LnumStr8_U32_Base16_Hash(u32 prev, const algo::LnumStr8_U32_Base16& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U32_Base16..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U32_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32_Base16's only field
bool algo::LnumStr8_U32_Base16_ReadStrptrMaybe(algo::LnumStr8_U32_Base16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr8_U32_Base16.String  printfmt:Raw
void algo::LnumStr8_U32_Base16_Print(algo::LnumStr8_U32_Base16& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U64.ch.Print
void algo::ch_Print(algo::LnumStr8_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr8_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u64(val);
}

// --- algo.LnumStr8_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr8_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr8_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U64..Hash
u32 algo::LnumStr8_U64_Hash(u32 prev, const algo::LnumStr8_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U64's only field
bool algo::LnumStr8_U64_ReadStrptrMaybe(algo::LnumStr8_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr8_U64.String  printfmt:Raw
void algo::LnumStr8_U64_Print(algo::LnumStr8_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr9_U32.ch.Print
void algo::ch_Print(algo::LnumStr9_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr9_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr9_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LnumStr9_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr9_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr9_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LnumStr9_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum16(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LnumStr9_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr9_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr9_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr9_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr9_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr9_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 9;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr9_U32..Hash
u32 algo::LnumStr9_U32_Hash(u32 prev, const algo::LnumStr9_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr9_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr9_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U32's only field
bool algo::LnumStr9_U32_ReadStrptrMaybe(algo::LnumStr9_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr9_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr9_U32.String  printfmt:Raw
void algo::LnumStr9_U32_Print(algo::LnumStr9_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr9_U64.ch.Print
void algo::ch_Print(algo::LnumStr9_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr9_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr9_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LnumStr9_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr9_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr9_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LnumStr9_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum16(str, ok);
        and_ok &= (ok != 0);
    }
    return u64(val);
}

// --- algo.LnumStr9_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr9_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr9_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr9_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LnumStr9_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr9_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 9;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr9_U64..Hash
u32 algo::LnumStr9_U64_Hash(u32 prev, const algo::LnumStr9_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr9_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr9_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U64's only field
bool algo::LnumStr9_U64_ReadStrptrMaybe(algo::LnumStr9_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr9_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LnumStr9_U64.String  printfmt:Raw
void algo::LnumStr9_U64_Print(algo::LnumStr9_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr10.ch.Print
void algo::ch_Print(algo::LspaceStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.LspaceStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr10& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 10 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr10..Hash
u32 algo::LspaceStr10_Hash(u32 prev, const algo::LspaceStr10& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr10..ReadStrptrMaybe
// Read fields of algo::LspaceStr10 from an ascii string.
// The format of the string is the format of the algo::LspaceStr10's only field
bool algo::LspaceStr10_ReadStrptrMaybe(algo::LspaceStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr10..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr10.String  printfmt:Raw
void algo::LspaceStr10_Print(algo::LspaceStr10& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr12.ch.Print
void algo::ch_Print(algo::LspaceStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.LspaceStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr12& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 12 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr12..Hash
u32 algo::LspaceStr12_Hash(u32 prev, const algo::LspaceStr12& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr12..ReadStrptrMaybe
// Read fields of algo::LspaceStr12 from an ascii string.
// The format of the string is the format of the algo::LspaceStr12's only field
bool algo::LspaceStr12_ReadStrptrMaybe(algo::LspaceStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr12..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr12.String  printfmt:Raw
void algo::LspaceStr12_Print(algo::LspaceStr12& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr14.ch.Print
void algo::ch_Print(algo::LspaceStr14& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr14.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr14& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 14) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 14");
    }
    return retval;
}

// --- algo.LspaceStr14.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr14& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 14);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 14 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr14..Hash
u32 algo::LspaceStr14_Hash(u32 prev, const algo::LspaceStr14& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr14..ReadStrptrMaybe
// Read fields of algo::LspaceStr14 from an ascii string.
// The format of the string is the format of the algo::LspaceStr14's only field
bool algo::LspaceStr14_ReadStrptrMaybe(algo::LspaceStr14 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr14..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr14.String  printfmt:Raw
void algo::LspaceStr14_Print(algo::LspaceStr14& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr15.ch.Print
void algo::ch_Print(algo::LspaceStr15& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr15.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr15& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 15) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 15");
    }
    return retval;
}

// --- algo.LspaceStr15.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr15& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 15);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 15 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr15..Hash
u32 algo::LspaceStr15_Hash(u32 prev, const algo::LspaceStr15& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr15..ReadStrptrMaybe
// Read fields of algo::LspaceStr15 from an ascii string.
// The format of the string is the format of the algo::LspaceStr15's only field
bool algo::LspaceStr15_ReadStrptrMaybe(algo::LspaceStr15 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr15..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr15.String  printfmt:Raw
void algo::LspaceStr15_Print(algo::LspaceStr15& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr20_I64.ch.Print
void algo::ch_Print(algo::LspaceStr20_I64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr20_I64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr20_I64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LspaceStr20_I64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr20_I64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr20_I64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
i64 algo::ch_Getnum(algo::LspaceStr20_I64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            and_ok = false;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        and_ok &= (val <= r1);
        val = r1;
    }
    i64 ret = is_neg ? -val : val;
    return i64(ret);
}

// --- algo.LspaceStr20_I64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i64 algo::ch_GetnumDflt(algo::LspaceStr20_I64& parent, i64 dflt) {
    bool ok = true;
    i64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr20_I64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr20_I64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr20_I64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr20_I64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr20_I64..Hash
u32 algo::LspaceStr20_I64_Hash(u32 prev, const algo::LspaceStr20_I64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr20_I64..ReadStrptrMaybe
// Read fields of algo::LspaceStr20_I64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_I64's only field
bool algo::LspaceStr20_I64_ReadStrptrMaybe(algo::LspaceStr20_I64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr20_I64..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr20_I64.String  printfmt:Raw
void algo::LspaceStr20_I64_Print(algo::LspaceStr20_I64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr20_U64.ch.Print
void algo::ch_Print(algo::LspaceStr20_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr20_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr20_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LspaceStr20_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr20_U64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr20_U64.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u64 algo::ch_Getnum(algo::LspaceStr20_U64& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            and_ok = false;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        and_ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LspaceStr20_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LspaceStr20_U64& parent, u64 dflt) {
    bool ok = true;
    u64 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr20_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr20_U64& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr20_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr20_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr20_U64..Hash
u32 algo::LspaceStr20_U64_Hash(u32 prev, const algo::LspaceStr20_U64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr20_U64..ReadStrptrMaybe
// Read fields of algo::LspaceStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_U64's only field
bool algo::LspaceStr20_U64_ReadStrptrMaybe(algo::LspaceStr20_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr20_U64..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr20_U64.String  printfmt:Raw
void algo::LspaceStr20_U64_Print(algo::LspaceStr20_U64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr3.ch.Print
void algo::ch_Print(algo::LspaceStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LspaceStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr3& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr3..Hash
u32 algo::LspaceStr3_Hash(u32 prev, const algo::LspaceStr3& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr3..ReadStrptrMaybe
// Read fields of algo::LspaceStr3 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3's only field
bool algo::LspaceStr3_ReadStrptrMaybe(algo::LspaceStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr3..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr3.String  printfmt:Raw
void algo::LspaceStr3_Print(algo::LspaceStr3& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr3_I16.ch.Print
void algo::ch_Print(algo::LspaceStr3_I16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr3_I16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr3_I16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LspaceStr3_I16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr3_I16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr3_I16.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
i16 algo::ch_Getnum(algo::LspaceStr3_I16& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum4(str, ok);
        and_ok &= (ok != 0);
    }
    i64 ret = is_neg ? -val : val;
    return i16(ret);
}

// --- algo.LspaceStr3_I16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i16 algo::ch_GetnumDflt(algo::LspaceStr3_I16& parent, i16 dflt) {
    bool ok = true;
    i16 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr3_I16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr3_I16& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr3_I16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr3_I16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    length = algo::u16_FmtBuf(val, (u8*)buf + charpos);
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 3;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr3_I16..Hash
u32 algo::LspaceStr3_I16_Hash(u32 prev, const algo::LspaceStr3_I16& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr3_I16..ReadStrptrMaybe
// Read fields of algo::LspaceStr3_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3_I16's only field
bool algo::LspaceStr3_I16_ReadStrptrMaybe(algo::LspaceStr3_I16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr3_I16..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr3_I16.String  printfmt:Raw
void algo::LspaceStr3_I16_Print(algo::LspaceStr3_I16& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr4.ch.Print
void algo::ch_Print(algo::LspaceStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.LspaceStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr4& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 4 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr4..Hash
u32 algo::LspaceStr4_Hash(u32 prev, const algo::LspaceStr4& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr4..ReadStrptrMaybe
// Read fields of algo::LspaceStr4 from an ascii string.
// The format of the string is the format of the algo::LspaceStr4's only field
bool algo::LspaceStr4_ReadStrptrMaybe(algo::LspaceStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr4..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr4.String  printfmt:Raw
void algo::LspaceStr4_Print(algo::LspaceStr4& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr5.ch.Print
void algo::ch_Print(algo::LspaceStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LspaceStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr5& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr5..Hash
u32 algo::LspaceStr5_Hash(u32 prev, const algo::LspaceStr5& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr5..ReadStrptrMaybe
// Read fields of algo::LspaceStr5 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5's only field
bool algo::LspaceStr5_ReadStrptrMaybe(algo::LspaceStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr5..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr5.String  printfmt:Raw
void algo::LspaceStr5_Print(algo::LspaceStr5& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr5_I16.ch.Print
void algo::ch_Print(algo::LspaceStr5_I16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr5_I16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr5_I16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LspaceStr5_I16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr5_I16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr5_I16.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u16 algo::ch_Getnum(algo::LspaceStr5_I16& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    and_ok &= val <= 0XFFFF;
    return u16(val);
}

// --- algo.LspaceStr5_I16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u16 algo::ch_GetnumDflt(algo::LspaceStr5_I16& parent, u16 dflt) {
    bool ok = true;
    u16 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr5_I16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr5_I16& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr5_I16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr5_I16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u16_FmtBuf(val, (u8*)buf + charpos);
    //pad string with 0s up to min_length
    while (charpos > 0 && length < 5) {
        buf[--charpos] = '0';
        ++length;
    }
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr5_I16..Hash
u32 algo::LspaceStr5_I16_Hash(u32 prev, const algo::LspaceStr5_I16& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr5_I16..ReadStrptrMaybe
// Read fields of algo::LspaceStr5_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5_I16's only field
bool algo::LspaceStr5_I16_ReadStrptrMaybe(algo::LspaceStr5_I16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr5_I16..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr5_I16.String  printfmt:Raw
void algo::LspaceStr5_I16_Print(algo::LspaceStr5_I16& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr6.ch.Print
void algo::ch_Print(algo::LspaceStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LspaceStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr6& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr6..Hash
u32 algo::LspaceStr6_Hash(u32 prev, const algo::LspaceStr6& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr6..ReadStrptrMaybe
// Read fields of algo::LspaceStr6 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6's only field
bool algo::LspaceStr6_ReadStrptrMaybe(algo::LspaceStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr6..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr6.String  printfmt:Raw
void algo::LspaceStr6_Print(algo::LspaceStr6& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr6_U32.ch.Print
void algo::ch_Print(algo::LspaceStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LspaceStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr6_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr6_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::LspaceStr6_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.LspaceStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LspaceStr6_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr6_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr6_U32..Hash
u32 algo::LspaceStr6_U32_Hash(u32 prev, const algo::LspaceStr6_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr6_U32..ReadStrptrMaybe
// Read fields of algo::LspaceStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6_U32's only field
bool algo::LspaceStr6_U32_ReadStrptrMaybe(algo::LspaceStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr6_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr6_U32.String  printfmt:Raw
void algo::LspaceStr6_U32_Print(algo::LspaceStr6_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr7_I32_Base36.ch.Print
void algo::ch_Print(algo::LspaceStr7_I32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr7_I32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LspaceStr7_I32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr7_I32_Base36& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr7_I32_Base36.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
i32 algo::ch_Getnum(algo::LspaceStr7_I32_Base36& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            and_ok = false;
        }
        val = val*36 + digit;
    }
    i64 ret = is_neg ? -val : val;
    and_ok &= ret >= i64(0XFFFFFFFF80000000) && ret <= i64(0X7FFFFFFF);
    return i32(ret);
}

// --- algo.LspaceStr7_I32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i32 algo::ch_GetnumDflt(algo::LspaceStr7_I32_Base36& parent, i32 dflt) {
    bool ok = true;
    i32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr7_I32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr7_I32_Base36& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.LspaceStr7_I32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr7_I32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Hash
u32 algo::LspaceStr7_I32_Base36_Hash(u32 prev, const algo::LspaceStr7_I32_Base36& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr7_I32_Base36..ReadStrptrMaybe
// Read fields of algo::LspaceStr7_I32_Base36 from an ascii string.
// The format of the string is the format of the algo::LspaceStr7_I32_Base36's only field
bool algo::LspaceStr7_I32_Base36_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr7_I32_Base36.String  printfmt:Raw
void algo::LspaceStr7_I32_Base36_Print(algo::LspaceStr7_I32_Base36& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr8.ch.Print
void algo::ch_Print(algo::LspaceStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LspaceStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr8& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr8..Hash
u32 algo::LspaceStr8_Hash(u32 prev, const algo::LspaceStr8& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr8..ReadStrptrMaybe
// Read fields of algo::LspaceStr8 from an ascii string.
// The format of the string is the format of the algo::LspaceStr8's only field
bool algo::LspaceStr8_ReadStrptrMaybe(algo::LspaceStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr8..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr8.String  printfmt:Raw
void algo::LspaceStr8_Print(algo::LspaceStr8& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr9.ch.Print
void algo::ch_Print(algo::LspaceStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LspaceStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr9& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr9..Hash
u32 algo::LspaceStr9_Hash(u32 prev, const algo::LspaceStr9& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr9..ReadStrptrMaybe
// Read fields of algo::LspaceStr9 from an ascii string.
// The format of the string is the format of the algo::LspaceStr9's only field
bool algo::LspaceStr9_ReadStrptrMaybe(algo::LspaceStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr9..Print
// print string representation of ROW to string STR
// cfmt:algo.LspaceStr9.String  printfmt:Raw
void algo::LspaceStr9_Print(algo::LspaceStr9& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Md5Digest.value.Print
// Convert value to a string.
// Array is printed as a regular string.
void algo::value_Print(algo::Md5Digest& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(value_Getary(parent));
}

// --- algo.Md5Digest.value.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::Md5Digest& parent, algo::strptr in_str) {
    bool retval = true;
    i32 newlen = i32_Min(in_str.n_elems, 16);
    memcpy(parent.value_elems, in_str.elems, newlen);
    return retval;
}

// --- algo.Md5Digest..ReadStrptrMaybe
// Read fields of algo::Md5Digest from an ascii string.
// The format of the string is the format of the algo::Md5Digest's only field
bool algo::Md5Digest_ReadStrptrMaybe(algo::Md5Digest &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Md5Digest..Print
// print string representation of ROW to string STR
// cfmt:algo.Md5Digest.String  printfmt:Raw
void algo::Md5Digest_Print(algo::Md5Digest row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.Month.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Month& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Month_January            : ret = "January";  break;
        case algo_Month_February           : ret = "February";  break;
        case algo_Month_March              : ret = "March";  break;
        case algo_Month_April              : ret = "April";  break;
        case algo_Month_May                : ret = "May";  break;
        case algo_Month_June               : ret = "June";  break;
        case algo_Month_July               : ret = "July";  break;
        case algo_Month_August             : ret = "August";  break;
        case algo_Month_September          : ret = "September";  break;
        case algo_Month_October            : ret = "October";  break;
        case algo_Month_November           : ret = "November";  break;
        case algo_Month_December           : ret = "December";  break;
        case algo_Month_None               : ret = "None";  break;
    }
    return ret;
}

// --- algo.Month.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Month& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Month.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Month& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('M','a','y'): {
                    value_SetEnum(parent,algo_Month_May); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('J','u','l','y'): {
                    value_SetEnum(parent,algo_Month_July); ret = true; break;
                }
                case LE_STR4('J','u','n','e'): {
                    value_SetEnum(parent,algo_Month_June); ret = true; break;
                }
                case LE_STR4('N','o','n','e'): {
                    value_SetEnum(parent,algo_Month_None); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('A','p','r','i','l'): {
                    value_SetEnum(parent,algo_Month_April); ret = true; break;
                }
                case LE_STR5('M','a','r','c','h'): {
                    value_SetEnum(parent,algo_Month_March); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('A','u','g','u','s','t'): {
                    value_SetEnum(parent,algo_Month_August); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('J','a','n','u','a','r','y'): {
                    value_SetEnum(parent,algo_Month_January); ret = true; break;
                }
                case LE_STR7('O','c','t','o','b','e','r'): {
                    value_SetEnum(parent,algo_Month_October); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('D','e','c','e','m','b','e','r'): {
                    value_SetEnum(parent,algo_Month_December); ret = true; break;
                }
                case LE_STR8('F','e','b','r','u','a','r','y'): {
                    value_SetEnum(parent,algo_Month_February); ret = true; break;
                }
                case LE_STR8('N','o','v','e','m','b','e','r'): {
                    value_SetEnum(parent,algo_Month_November); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('S','e','p','t','e','m','b','e'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,algo_Month_September); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Month.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Month& parent, algo::strptr rhs, algo_MonthEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.Month.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::Month& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.Month..ReadStrptrMaybe
// Read fields of algo::Month from an ascii string.
// The format of the string is the format of the algo::Month's only field
bool algo::Month_ReadStrptrMaybe(algo::Month &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Month..Print
// print string representation of ROW to string STR
// cfmt:algo.Month.String  printfmt:Raw
void algo::Month_Print(algo::Month row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.NumParseFlags.err.ReadStrptrMaybe
inline static bool algo::err_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool err_tmp;
    retval = bool_ReadStrptrMaybe(err_tmp, in_str);
    if (retval) {
        err_Set(parent, err_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.ok.ReadStrptrMaybe
inline static bool algo::ok_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool ok_tmp;
    retval = bool_ReadStrptrMaybe(ok_tmp, in_str);
    if (retval) {
        ok_Set(parent, ok_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.neg.ReadStrptrMaybe
inline static bool algo::neg_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool neg_tmp;
    retval = bool_ReadStrptrMaybe(neg_tmp, in_str);
    if (retval) {
        neg_Set(parent, neg_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.overflow.ReadStrptrMaybe
inline static bool algo::overflow_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool overflow_tmp;
    retval = bool_ReadStrptrMaybe(overflow_tmp, in_str);
    if (retval) {
        overflow_Set(parent, overflow_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.hex.ReadStrptrMaybe
inline static bool algo::hex_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool hex_tmp;
    retval = bool_ReadStrptrMaybe(hex_tmp, in_str);
    if (retval) {
        hex_Set(parent, hex_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags..ReadFieldMaybe
bool algo::NumParseFlags_ReadFieldMaybe(algo::NumParseFlags& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case algo_FieldId_value: {
            retval = u32_ReadStrptrMaybe(parent.value, strval);
            break;
        }
        case algo_FieldId_err: {
            retval = err_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_ok: {
            retval = ok_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_neg: {
            retval = neg_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_overflow: {
            retval = overflow_ReadStrptrMaybe(parent, strval);
            break;
        }
        case algo_FieldId_hex: {
            retval = hex_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.NumParseFlags..ReadStrptrMaybe
// Read fields of algo::NumParseFlags from an ascii string.
bool algo::NumParseFlags_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    // Clear affected bits first)
    err_Set(parent, false);
    ok_Set(parent, false);
    neg_Set(parent, false);
    overflow_Set(parent, false);
    hex_Set(parent, false);
    // Read ','-separated list of bools
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_err: {
                        err_Set(parent, true);
                    } break;
                    case algo_FieldId_ok: {
                        ok_Set(parent, true);
                    } break;
                    case algo_FieldId_neg: {
                        neg_Set(parent, true);
                    } break;
                    case algo_FieldId_overflow: {
                        overflow_Set(parent, true);
                    } break;
                    case algo_FieldId_hex: {
                        hex_Set(parent, true);
                    } break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.NumParseFlags..Print
// print string representation of ROW to string STR
// cfmt:algo.NumParseFlags.String  printfmt:Bitset
void algo::NumParseFlags_Print(algo::NumParseFlags& row, algo::cstring& str) {
    algo::ListSep ls(",");
    if (err_Get(row)) {
        str << ls << "err";
    }
    if (ok_Get(row)) {
        str << ls << "ok";
    }
    if (neg_Get(row)) {
        str << ls << "neg";
    }
    if (overflow_Get(row)) {
        str << ls << "overflow";
    }
    if (hex_Get(row)) {
        str << ls << "hex";
    }
}

// --- algo.NumParseFlags..GetAnon
algo::strptr algo::NumParseFlags_GetAnon(algo::NumParseFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.RnullStr1.ch.Print
void algo::ch_Print(algo::RnullStr1& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr1.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr1& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.RnullStr1.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr1& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 1; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr1..Hash
u32 algo::RnullStr1_Hash(u32 prev, algo::RnullStr1 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr1..ReadStrptrMaybe
// Read fields of algo::RnullStr1 from an ascii string.
// The format of the string is the format of the algo::RnullStr1's only field
bool algo::RnullStr1_ReadStrptrMaybe(algo::RnullStr1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr1..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr1.String  printfmt:Raw
void algo::RnullStr1_Print(algo::RnullStr1 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr10.ch.Print
void algo::ch_Print(algo::RnullStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.RnullStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr10& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 10; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr10..Hash
u32 algo::RnullStr10_Hash(u32 prev, algo::RnullStr10 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr10..ReadStrptrMaybe
// Read fields of algo::RnullStr10 from an ascii string.
// The format of the string is the format of the algo::RnullStr10's only field
bool algo::RnullStr10_ReadStrptrMaybe(algo::RnullStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr10..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr10.String  printfmt:Raw
void algo::RnullStr10_Print(algo::RnullStr10 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr100.ch.Print
void algo::ch_Print(algo::RnullStr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.RnullStr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr100& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 100; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr100..Hash
u32 algo::RnullStr100_Hash(u32 prev, const algo::RnullStr100& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr100..ReadStrptrMaybe
// Read fields of algo::RnullStr100 from an ascii string.
// The format of the string is the format of the algo::RnullStr100's only field
bool algo::RnullStr100_ReadStrptrMaybe(algo::RnullStr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr100..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr100.String  printfmt:Raw
void algo::RnullStr100_Print(algo::RnullStr100& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr1000.ch.Print
void algo::ch_Print(algo::RnullStr1000& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr1000.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr1000& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1000) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1000");
    }
    return retval;
}

// --- algo.RnullStr1000.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr1000& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 1000);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 1000; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr1000..Hash
u32 algo::RnullStr1000_Hash(u32 prev, const algo::RnullStr1000& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr1000..ReadStrptrMaybe
// Read fields of algo::RnullStr1000 from an ascii string.
// The format of the string is the format of the algo::RnullStr1000's only field
bool algo::RnullStr1000_ReadStrptrMaybe(algo::RnullStr1000 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr1000..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr1000.String  printfmt:Raw
void algo::RnullStr1000_Print(algo::RnullStr1000& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr11.ch.Print
void algo::ch_Print(algo::RnullStr11& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr11.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr11& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.RnullStr11.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr11& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 11; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr11..Hash
u32 algo::RnullStr11_Hash(u32 prev, const algo::RnullStr11& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr11..ReadStrptrMaybe
// Read fields of algo::RnullStr11 from an ascii string.
// The format of the string is the format of the algo::RnullStr11's only field
bool algo::RnullStr11_ReadStrptrMaybe(algo::RnullStr11 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr11..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr11.String  printfmt:Raw
void algo::RnullStr11_Print(algo::RnullStr11& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr12.ch.Print
void algo::ch_Print(algo::RnullStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.RnullStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr12& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 12; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr12..Hash
u32 algo::RnullStr12_Hash(u32 prev, const algo::RnullStr12& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr12..ReadStrptrMaybe
// Read fields of algo::RnullStr12 from an ascii string.
// The format of the string is the format of the algo::RnullStr12's only field
bool algo::RnullStr12_ReadStrptrMaybe(algo::RnullStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr12..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr12.String  printfmt:Raw
void algo::RnullStr12_Print(algo::RnullStr12& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr129.ch.Print
void algo::ch_Print(algo::RnullStr129& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr129.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr129& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 129) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 129");
    }
    return retval;
}

// --- algo.RnullStr129.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr129& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 129);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 129; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr129..Hash
u32 algo::RnullStr129_Hash(u32 prev, const algo::RnullStr129& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr129..ReadStrptrMaybe
// Read fields of algo::RnullStr129 from an ascii string.
// The format of the string is the format of the algo::RnullStr129's only field
bool algo::RnullStr129_ReadStrptrMaybe(algo::RnullStr129 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr129..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr129.String  printfmt:Raw
void algo::RnullStr129_Print(algo::RnullStr129& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr13.ch.Print
void algo::ch_Print(algo::RnullStr13& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr13.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr13& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 13) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 13");
    }
    return retval;
}

// --- algo.RnullStr13.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr13& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 13);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 13; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr13..Hash
u32 algo::RnullStr13_Hash(u32 prev, const algo::RnullStr13& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr13..ReadStrptrMaybe
// Read fields of algo::RnullStr13 from an ascii string.
// The format of the string is the format of the algo::RnullStr13's only field
bool algo::RnullStr13_ReadStrptrMaybe(algo::RnullStr13 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr13..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr13.String  printfmt:Raw
void algo::RnullStr13_Print(algo::RnullStr13& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr14.ch.Print
void algo::ch_Print(algo::RnullStr14& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr14.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr14& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 14) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 14");
    }
    return retval;
}

// --- algo.RnullStr14.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr14& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 14);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 14; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr14..Hash
u32 algo::RnullStr14_Hash(u32 prev, const algo::RnullStr14& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr14..ReadStrptrMaybe
// Read fields of algo::RnullStr14 from an ascii string.
// The format of the string is the format of the algo::RnullStr14's only field
bool algo::RnullStr14_ReadStrptrMaybe(algo::RnullStr14 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr14..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr14.String  printfmt:Raw
void algo::RnullStr14_Print(algo::RnullStr14& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr15.ch.Print
void algo::ch_Print(algo::RnullStr15& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr15.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr15& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 15) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 15");
    }
    return retval;
}

// --- algo.RnullStr15.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr15& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 15);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 15; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr15..Hash
u32 algo::RnullStr15_Hash(u32 prev, const algo::RnullStr15& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr15..ReadStrptrMaybe
// Read fields of algo::RnullStr15 from an ascii string.
// The format of the string is the format of the algo::RnullStr15's only field
bool algo::RnullStr15_ReadStrptrMaybe(algo::RnullStr15 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr15..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr15.String  printfmt:Raw
void algo::RnullStr15_Print(algo::RnullStr15& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr151.ch.Print
void algo::ch_Print(algo::RnullStr151& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr151.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr151& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 151) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 151");
    }
    return retval;
}

// --- algo.RnullStr151.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr151& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 151);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 151; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr151..Hash
u32 algo::RnullStr151_Hash(u32 prev, const algo::RnullStr151& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr151..ReadStrptrMaybe
// Read fields of algo::RnullStr151 from an ascii string.
// The format of the string is the format of the algo::RnullStr151's only field
bool algo::RnullStr151_ReadStrptrMaybe(algo::RnullStr151 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr151..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr151.String  printfmt:Raw
void algo::RnullStr151_Print(algo::RnullStr151& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr16.ch.Print
void algo::ch_Print(algo::RnullStr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.RnullStr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 16; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr16..Hash
u32 algo::RnullStr16_Hash(u32 prev, algo::RnullStr16 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr16..ReadStrptrMaybe
// Read fields of algo::RnullStr16 from an ascii string.
// The format of the string is the format of the algo::RnullStr16's only field
bool algo::RnullStr16_ReadStrptrMaybe(algo::RnullStr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr16..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr16.String  printfmt:Raw
void algo::RnullStr16_Print(algo::RnullStr16 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr17.ch.Print
void algo::ch_Print(algo::RnullStr17& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr17.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr17& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 17) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 17");
    }
    return retval;
}

// --- algo.RnullStr17.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr17& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 17);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 17; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr17..Hash
u32 algo::RnullStr17_Hash(u32 prev, const algo::RnullStr17& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr17..ReadStrptrMaybe
// Read fields of algo::RnullStr17 from an ascii string.
// The format of the string is the format of the algo::RnullStr17's only field
bool algo::RnullStr17_ReadStrptrMaybe(algo::RnullStr17 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr17..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr17.String  printfmt:Raw
void algo::RnullStr17_Print(algo::RnullStr17& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr18.ch.Print
void algo::ch_Print(algo::RnullStr18& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr18.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr18& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 18) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 18");
    }
    return retval;
}

// --- algo.RnullStr18.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr18& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 18);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 18; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr18..Hash
u32 algo::RnullStr18_Hash(u32 prev, algo::RnullStr18 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr18..ReadStrptrMaybe
// Read fields of algo::RnullStr18 from an ascii string.
// The format of the string is the format of the algo::RnullStr18's only field
bool algo::RnullStr18_ReadStrptrMaybe(algo::RnullStr18 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr18..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr18.String  printfmt:Raw
void algo::RnullStr18_Print(algo::RnullStr18 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr19.ch.Print
void algo::ch_Print(algo::RnullStr19& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr19.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr19& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 19) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 19");
    }
    return retval;
}

// --- algo.RnullStr19.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr19& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 19);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 19; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr19..Hash
u32 algo::RnullStr19_Hash(u32 prev, const algo::RnullStr19& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr19..ReadStrptrMaybe
// Read fields of algo::RnullStr19 from an ascii string.
// The format of the string is the format of the algo::RnullStr19's only field
bool algo::RnullStr19_ReadStrptrMaybe(algo::RnullStr19 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr19..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr19.String  printfmt:Raw
void algo::RnullStr19_Print(algo::RnullStr19& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr2.ch.Print
void algo::ch_Print(algo::RnullStr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.RnullStr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr2& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 2; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr2..Hash
u32 algo::RnullStr2_Hash(u32 prev, algo::RnullStr2 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr2..ReadStrptrMaybe
// Read fields of algo::RnullStr2 from an ascii string.
// The format of the string is the format of the algo::RnullStr2's only field
bool algo::RnullStr2_ReadStrptrMaybe(algo::RnullStr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr2..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr2.String  printfmt:Raw
void algo::RnullStr2_Print(algo::RnullStr2 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr20.ch.Print
void algo::ch_Print(algo::RnullStr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.RnullStr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr20& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 20; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr20..Hash
u32 algo::RnullStr20_Hash(u32 prev, algo::RnullStr20 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr20..ReadStrptrMaybe
// Read fields of algo::RnullStr20 from an ascii string.
// The format of the string is the format of the algo::RnullStr20's only field
bool algo::RnullStr20_ReadStrptrMaybe(algo::RnullStr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr20..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr20.String  printfmt:Raw
void algo::RnullStr20_Print(algo::RnullStr20 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr21.ch.Print
void algo::ch_Print(algo::RnullStr21& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr21.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr21& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 21) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 21");
    }
    return retval;
}

// --- algo.RnullStr21.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr21& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 21);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 21; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr21..Hash
u32 algo::RnullStr21_Hash(u32 prev, const algo::RnullStr21& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr21..ReadStrptrMaybe
// Read fields of algo::RnullStr21 from an ascii string.
// The format of the string is the format of the algo::RnullStr21's only field
bool algo::RnullStr21_ReadStrptrMaybe(algo::RnullStr21 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr21..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr21.String  printfmt:Raw
void algo::RnullStr21_Print(algo::RnullStr21& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr24.ch.Print
void algo::ch_Print(algo::RnullStr24& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr24.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr24& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 24) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 24");
    }
    return retval;
}

// --- algo.RnullStr24.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr24& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 24);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 24; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr24..Hash
u32 algo::RnullStr24_Hash(u32 prev, const algo::RnullStr24& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr24..ReadStrptrMaybe
// Read fields of algo::RnullStr24 from an ascii string.
// The format of the string is the format of the algo::RnullStr24's only field
bool algo::RnullStr24_ReadStrptrMaybe(algo::RnullStr24 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr24..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr24.String  printfmt:Raw
void algo::RnullStr24_Print(algo::RnullStr24& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr25.ch.Print
void algo::ch_Print(algo::RnullStr25& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr25.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr25& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 25) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 25");
    }
    return retval;
}

// --- algo.RnullStr25.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr25& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 25);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 25; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr25..Hash
u32 algo::RnullStr25_Hash(u32 prev, const algo::RnullStr25& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr25..ReadStrptrMaybe
// Read fields of algo::RnullStr25 from an ascii string.
// The format of the string is the format of the algo::RnullStr25's only field
bool algo::RnullStr25_ReadStrptrMaybe(algo::RnullStr25 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr25..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr25.String  printfmt:Raw
void algo::RnullStr25_Print(algo::RnullStr25& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr28.ch.Print
void algo::ch_Print(algo::RnullStr28& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr28.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr28& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 28) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 28");
    }
    return retval;
}

// --- algo.RnullStr28.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr28& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 28);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 28; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr28..Hash
u32 algo::RnullStr28_Hash(u32 prev, const algo::RnullStr28& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr28..ReadStrptrMaybe
// Read fields of algo::RnullStr28 from an ascii string.
// The format of the string is the format of the algo::RnullStr28's only field
bool algo::RnullStr28_ReadStrptrMaybe(algo::RnullStr28 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr28..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr28.String  printfmt:Raw
void algo::RnullStr28_Print(algo::RnullStr28& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr3.ch.Print
void algo::ch_Print(algo::RnullStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.RnullStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr3& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 3; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr3..Hash
u32 algo::RnullStr3_Hash(u32 prev, algo::RnullStr3 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr3..ReadStrptrMaybe
// Read fields of algo::RnullStr3 from an ascii string.
// The format of the string is the format of the algo::RnullStr3's only field
bool algo::RnullStr3_ReadStrptrMaybe(algo::RnullStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr3..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr3.String  printfmt:Raw
void algo::RnullStr3_Print(algo::RnullStr3 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr30.ch.Print
void algo::ch_Print(algo::RnullStr30& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr30.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr30& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 30) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 30");
    }
    return retval;
}

// --- algo.RnullStr30.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr30& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 30);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 30; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr30..Hash
u32 algo::RnullStr30_Hash(u32 prev, algo::RnullStr30 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr30..ReadStrptrMaybe
// Read fields of algo::RnullStr30 from an ascii string.
// The format of the string is the format of the algo::RnullStr30's only field
bool algo::RnullStr30_ReadStrptrMaybe(algo::RnullStr30 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr30..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr30.String  printfmt:Raw
void algo::RnullStr30_Print(algo::RnullStr30 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr32.ch.Print
void algo::ch_Print(algo::RnullStr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.RnullStr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 32; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr32..Hash
u32 algo::RnullStr32_Hash(u32 prev, algo::RnullStr32 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr32..ReadStrptrMaybe
// Read fields of algo::RnullStr32 from an ascii string.
// The format of the string is the format of the algo::RnullStr32's only field
bool algo::RnullStr32_ReadStrptrMaybe(algo::RnullStr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr32..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr32.String  printfmt:Raw
void algo::RnullStr32_Print(algo::RnullStr32 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr33.ch.Print
void algo::ch_Print(algo::RnullStr33& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr33.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr33& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 33) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 33");
    }
    return retval;
}

// --- algo.RnullStr33.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr33& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 33);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 33; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr33..Hash
u32 algo::RnullStr33_Hash(u32 prev, const algo::RnullStr33& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr33..ReadStrptrMaybe
// Read fields of algo::RnullStr33 from an ascii string.
// The format of the string is the format of the algo::RnullStr33's only field
bool algo::RnullStr33_ReadStrptrMaybe(algo::RnullStr33 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr33..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr33.String  printfmt:Raw
void algo::RnullStr33_Print(algo::RnullStr33& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr35.ch.Print
void algo::ch_Print(algo::RnullStr35& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr35.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr35& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 35) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 35");
    }
    return retval;
}

// --- algo.RnullStr35.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr35& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 35);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 35; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr35..Hash
u32 algo::RnullStr35_Hash(u32 prev, const algo::RnullStr35& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr35..ReadStrptrMaybe
// Read fields of algo::RnullStr35 from an ascii string.
// The format of the string is the format of the algo::RnullStr35's only field
bool algo::RnullStr35_ReadStrptrMaybe(algo::RnullStr35 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr35..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr35.String  printfmt:Raw
void algo::RnullStr35_Print(algo::RnullStr35& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr36.ch.Print
void algo::ch_Print(algo::RnullStr36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 36) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 36");
    }
    return retval;
}

// --- algo.RnullStr36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr36& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 36);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 36; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr36..Hash
u32 algo::RnullStr36_Hash(u32 prev, const algo::RnullStr36& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr36..ReadStrptrMaybe
// Read fields of algo::RnullStr36 from an ascii string.
// The format of the string is the format of the algo::RnullStr36's only field
bool algo::RnullStr36_ReadStrptrMaybe(algo::RnullStr36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr36..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr36.String  printfmt:Raw
void algo::RnullStr36_Print(algo::RnullStr36& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr4.ch.Print
void algo::ch_Print(algo::RnullStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.RnullStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr4& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 4; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr4..Hash
u32 algo::RnullStr4_Hash(u32 prev, algo::RnullStr4 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr4..ReadStrptrMaybe
// Read fields of algo::RnullStr4 from an ascii string.
// The format of the string is the format of the algo::RnullStr4's only field
bool algo::RnullStr4_ReadStrptrMaybe(algo::RnullStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr4..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr4.String  printfmt:Raw
void algo::RnullStr4_Print(algo::RnullStr4 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr40.ch.Print
void algo::ch_Print(algo::RnullStr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.RnullStr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr40& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 40; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr40..Hash
u32 algo::RnullStr40_Hash(u32 prev, const algo::RnullStr40& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr40..ReadStrptrMaybe
// Read fields of algo::RnullStr40 from an ascii string.
// The format of the string is the format of the algo::RnullStr40's only field
bool algo::RnullStr40_ReadStrptrMaybe(algo::RnullStr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr40..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr40.String  printfmt:Raw
void algo::RnullStr40_Print(algo::RnullStr40& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr41.ch.Print
void algo::ch_Print(algo::RnullStr41& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr41.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr41& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 41) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 41");
    }
    return retval;
}

// --- algo.RnullStr41.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr41& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 41);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 41; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr41..Hash
u32 algo::RnullStr41_Hash(u32 prev, const algo::RnullStr41& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr41..ReadStrptrMaybe
// Read fields of algo::RnullStr41 from an ascii string.
// The format of the string is the format of the algo::RnullStr41's only field
bool algo::RnullStr41_ReadStrptrMaybe(algo::RnullStr41 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr41..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr41.String  printfmt:Raw
void algo::RnullStr41_Print(algo::RnullStr41& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr43.ch.Print
void algo::ch_Print(algo::RnullStr43& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr43.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr43& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 43) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 43");
    }
    return retval;
}

// --- algo.RnullStr43.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr43& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 43);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 43; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr43..Hash
u32 algo::RnullStr43_Hash(u32 prev, const algo::RnullStr43& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr43..ReadStrptrMaybe
// Read fields of algo::RnullStr43 from an ascii string.
// The format of the string is the format of the algo::RnullStr43's only field
bool algo::RnullStr43_ReadStrptrMaybe(algo::RnullStr43 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr43..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr43.String  printfmt:Raw
void algo::RnullStr43_Print(algo::RnullStr43& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr44.ch.Print
void algo::ch_Print(algo::RnullStr44& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr44.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr44& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 44) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 44");
    }
    return retval;
}

// --- algo.RnullStr44.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr44& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 44);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 44; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr44..Hash
u32 algo::RnullStr44_Hash(u32 prev, const algo::RnullStr44& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr44..ReadStrptrMaybe
// Read fields of algo::RnullStr44 from an ascii string.
// The format of the string is the format of the algo::RnullStr44's only field
bool algo::RnullStr44_ReadStrptrMaybe(algo::RnullStr44 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr44..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr44.String  printfmt:Raw
void algo::RnullStr44_Print(algo::RnullStr44& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr48.ch.Print
void algo::ch_Print(algo::RnullStr48& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr48.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr48& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 48) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 48");
    }
    return retval;
}

// --- algo.RnullStr48.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr48& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 48);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 48; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr48..Hash
u32 algo::RnullStr48_Hash(u32 prev, const algo::RnullStr48& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr48..ReadStrptrMaybe
// Read fields of algo::RnullStr48 from an ascii string.
// The format of the string is the format of the algo::RnullStr48's only field
bool algo::RnullStr48_ReadStrptrMaybe(algo::RnullStr48 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr48..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr48.String  printfmt:Raw
void algo::RnullStr48_Print(algo::RnullStr48& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr5.ch.Print
void algo::ch_Print(algo::RnullStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.RnullStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr5& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 5; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr5..Hash
u32 algo::RnullStr5_Hash(u32 prev, algo::RnullStr5 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr5..ReadStrptrMaybe
// Read fields of algo::RnullStr5 from an ascii string.
// The format of the string is the format of the algo::RnullStr5's only field
bool algo::RnullStr5_ReadStrptrMaybe(algo::RnullStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr5..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr5.String  printfmt:Raw
void algo::RnullStr5_Print(algo::RnullStr5 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr50.ch.Print
void algo::ch_Print(algo::RnullStr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.RnullStr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr50& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 50; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr50..Hash
u32 algo::RnullStr50_Hash(u32 prev, const algo::RnullStr50& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr50..ReadStrptrMaybe
// Read fields of algo::RnullStr50 from an ascii string.
// The format of the string is the format of the algo::RnullStr50's only field
bool algo::RnullStr50_ReadStrptrMaybe(algo::RnullStr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr50..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr50.String  printfmt:Raw
void algo::RnullStr50_Print(algo::RnullStr50& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr54.ch.Print
void algo::ch_Print(algo::RnullStr54& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr54.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr54& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 54) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 54");
    }
    return retval;
}

// --- algo.RnullStr54.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr54& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 54);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 54; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr54..Hash
u32 algo::RnullStr54_Hash(u32 prev, const algo::RnullStr54& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr54..ReadStrptrMaybe
// Read fields of algo::RnullStr54 from an ascii string.
// The format of the string is the format of the algo::RnullStr54's only field
bool algo::RnullStr54_ReadStrptrMaybe(algo::RnullStr54 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr54..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr54.String  printfmt:Raw
void algo::RnullStr54_Print(algo::RnullStr54& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr55.ch.Print
void algo::ch_Print(algo::RnullStr55& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr55.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr55& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 55) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 55");
    }
    return retval;
}

// --- algo.RnullStr55.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr55& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 55);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 55; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr55..Hash
u32 algo::RnullStr55_Hash(u32 prev, const algo::RnullStr55& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr55..ReadStrptrMaybe
// Read fields of algo::RnullStr55 from an ascii string.
// The format of the string is the format of the algo::RnullStr55's only field
bool algo::RnullStr55_ReadStrptrMaybe(algo::RnullStr55 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr55..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr55.String  printfmt:Raw
void algo::RnullStr55_Print(algo::RnullStr55& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr6.ch.Print
void algo::ch_Print(algo::RnullStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RnullStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr6& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr6..Hash
u32 algo::RnullStr6_Hash(u32 prev, algo::RnullStr6 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr6..ReadStrptrMaybe
// Read fields of algo::RnullStr6 from an ascii string.
// The format of the string is the format of the algo::RnullStr6's only field
bool algo::RnullStr6_ReadStrptrMaybe(algo::RnullStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr6..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr6.String  printfmt:Raw
void algo::RnullStr6_Print(algo::RnullStr6 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr60.ch.Print
void algo::ch_Print(algo::RnullStr60& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr60.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr60& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 60) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 60");
    }
    return retval;
}

// --- algo.RnullStr60.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr60& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 60);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 60; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr60..Hash
u32 algo::RnullStr60_Hash(u32 prev, const algo::RnullStr60& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr60..ReadStrptrMaybe
// Read fields of algo::RnullStr60 from an ascii string.
// The format of the string is the format of the algo::RnullStr60's only field
bool algo::RnullStr60_ReadStrptrMaybe(algo::RnullStr60 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr60..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr60.String  printfmt:Raw
void algo::RnullStr60_Print(algo::RnullStr60& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr62.ch.Print
void algo::ch_Print(algo::RnullStr62& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr62.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr62& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 62) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 62");
    }
    return retval;
}

// --- algo.RnullStr62.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr62& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 62);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 62; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr62..Hash
u32 algo::RnullStr62_Hash(u32 prev, const algo::RnullStr62& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr62..ReadStrptrMaybe
// Read fields of algo::RnullStr62 from an ascii string.
// The format of the string is the format of the algo::RnullStr62's only field
bool algo::RnullStr62_ReadStrptrMaybe(algo::RnullStr62 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr62..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr62.String  printfmt:Raw
void algo::RnullStr62_Print(algo::RnullStr62& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr66.ch.Print
void algo::ch_Print(algo::RnullStr66& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr66.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr66& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 66) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 66");
    }
    return retval;
}

// --- algo.RnullStr66.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr66& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 66);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 66; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr66..Hash
u32 algo::RnullStr66_Hash(u32 prev, const algo::RnullStr66& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr66..ReadStrptrMaybe
// Read fields of algo::RnullStr66 from an ascii string.
// The format of the string is the format of the algo::RnullStr66's only field
bool algo::RnullStr66_ReadStrptrMaybe(algo::RnullStr66 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr66..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr66.String  printfmt:Raw
void algo::RnullStr66_Print(algo::RnullStr66& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr6_U32.ch.Print
void algo::ch_Print(algo::RnullStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RnullStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr6_U32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr6_U32.ch.Getnum
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
u32 algo::ch_Getnum(algo::RnullStr6_U32& parent, bool &and_ok) {
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        u32 ok = 1;
        val = aParseNum8(str, ok);
        and_ok &= (ok != 0);
    }
    return u32(val);
}

// --- algo.RnullStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::RnullStr6_U32& parent, u32 dflt) {
    bool ok = true;
    u32 result = ch_Getnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.RnullStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::RnullStr6_U32& parent, bool &out_ok) {
    out_ok = true;
    i64 result = ch_Getnum(parent, out_ok);
    return result;
}

// --- algo.RnullStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::RnullStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.RnullStr6_U32..Hash
u32 algo::RnullStr6_U32_Hash(u32 prev, const algo::RnullStr6_U32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr6_U32..ReadStrptrMaybe
// Read fields of algo::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the algo::RnullStr6_U32's only field
bool algo::RnullStr6_U32_ReadStrptrMaybe(algo::RnullStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr6_U32..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr6_U32.String  printfmt:Raw
void algo::RnullStr6_U32_Print(algo::RnullStr6_U32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr7.ch.Print
void algo::ch_Print(algo::RnullStr7& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr7.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr7& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.RnullStr7.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr7& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 7; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr7..Hash
u32 algo::RnullStr7_Hash(u32 prev, algo::RnullStr7 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr7..ReadStrptrMaybe
// Read fields of algo::RnullStr7 from an ascii string.
// The format of the string is the format of the algo::RnullStr7's only field
bool algo::RnullStr7_ReadStrptrMaybe(algo::RnullStr7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr7..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr7.String  printfmt:Raw
void algo::RnullStr7_Print(algo::RnullStr7 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr8.ch.Print
void algo::ch_Print(algo::RnullStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.RnullStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr8& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 8; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr8..Hash
u32 algo::RnullStr8_Hash(u32 prev, algo::RnullStr8 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr8..ReadStrptrMaybe
// Read fields of algo::RnullStr8 from an ascii string.
// The format of the string is the format of the algo::RnullStr8's only field
bool algo::RnullStr8_ReadStrptrMaybe(algo::RnullStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr8..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr8.String  printfmt:Raw
void algo::RnullStr8_Print(algo::RnullStr8 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr80.ch.Print
void algo::ch_Print(algo::RnullStr80& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr80.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr80& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 80) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 80");
    }
    return retval;
}

// --- algo.RnullStr80.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr80& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 80);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 80; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr80..Hash
u32 algo::RnullStr80_Hash(u32 prev, const algo::RnullStr80& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr80..ReadStrptrMaybe
// Read fields of algo::RnullStr80 from an ascii string.
// The format of the string is the format of the algo::RnullStr80's only field
bool algo::RnullStr80_ReadStrptrMaybe(algo::RnullStr80 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr80..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr80.String  printfmt:Raw
void algo::RnullStr80_Print(algo::RnullStr80& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr9.ch.Print
void algo::ch_Print(algo::RnullStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.RnullStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr9& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 9; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr9..Hash
u32 algo::RnullStr9_Hash(u32 prev, const algo::RnullStr9& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr9..ReadStrptrMaybe
// Read fields of algo::RnullStr9 from an ascii string.
// The format of the string is the format of the algo::RnullStr9's only field
bool algo::RnullStr9_ReadStrptrMaybe(algo::RnullStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr9..Print
// print string representation of ROW to string STR
// cfmt:algo.RnullStr9.String  printfmt:Raw
void algo::RnullStr9_Print(algo::RnullStr9& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr10.ch.Print
void algo::ch_Print(algo::RspaceStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.RspaceStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr10& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 10; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr10..Hash
u32 algo::RspaceStr10_Hash(u32 prev, algo::RspaceStr10 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr10..ReadStrptrMaybe
// Read fields of algo::RspaceStr10 from an ascii string.
// The format of the string is the format of the algo::RspaceStr10's only field
bool algo::RspaceStr10_ReadStrptrMaybe(algo::RspaceStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr10..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr10.String  printfmt:Raw
void algo::RspaceStr10_Print(algo::RspaceStr10 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr100.ch.Print
void algo::ch_Print(algo::RspaceStr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.RspaceStr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr100& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 100; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr100..Hash
u32 algo::RspaceStr100_Hash(u32 prev, const algo::RspaceStr100& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr100..ReadStrptrMaybe
// Read fields of algo::RspaceStr100 from an ascii string.
// The format of the string is the format of the algo::RspaceStr100's only field
bool algo::RspaceStr100_ReadStrptrMaybe(algo::RspaceStr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr100..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr100.String  printfmt:Raw
void algo::RspaceStr100_Print(algo::RspaceStr100& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr11.ch.Print
void algo::ch_Print(algo::RspaceStr11& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr11.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr11& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.RspaceStr11.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr11& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 11; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr11..Hash
u32 algo::RspaceStr11_Hash(u32 prev, const algo::RspaceStr11& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr11..ReadStrptrMaybe
// Read fields of algo::RspaceStr11 from an ascii string.
// The format of the string is the format of the algo::RspaceStr11's only field
bool algo::RspaceStr11_ReadStrptrMaybe(algo::RspaceStr11 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr11..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr11.String  printfmt:Raw
void algo::RspaceStr11_Print(algo::RspaceStr11& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr12.ch.Print
void algo::ch_Print(algo::RspaceStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.RspaceStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr12& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 12; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr12..Hash
u32 algo::RspaceStr12_Hash(u32 prev, algo::RspaceStr12 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr12..ReadStrptrMaybe
// Read fields of algo::RspaceStr12 from an ascii string.
// The format of the string is the format of the algo::RspaceStr12's only field
bool algo::RspaceStr12_ReadStrptrMaybe(algo::RspaceStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr12..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr12.String  printfmt:Raw
void algo::RspaceStr12_Print(algo::RspaceStr12 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr128.ch.Print
void algo::ch_Print(algo::RspaceStr128& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr128.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr128& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 128) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 128");
    }
    return retval;
}

// --- algo.RspaceStr128.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr128& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 128);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 128; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr128..Hash
u32 algo::RspaceStr128_Hash(u32 prev, algo::RspaceStr128 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr128..ReadStrptrMaybe
// Read fields of algo::RspaceStr128 from an ascii string.
// The format of the string is the format of the algo::RspaceStr128's only field
bool algo::RspaceStr128_ReadStrptrMaybe(algo::RspaceStr128 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr128..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr128.String  printfmt:Raw
void algo::RspaceStr128_Print(algo::RspaceStr128 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr14.ch.Print
void algo::ch_Print(algo::RspaceStr14& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr14.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr14& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 14) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 14");
    }
    return retval;
}

// --- algo.RspaceStr14.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr14& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 14);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 14; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr14..Hash
u32 algo::RspaceStr14_Hash(u32 prev, algo::RspaceStr14 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr14..ReadStrptrMaybe
// Read fields of algo::RspaceStr14 from an ascii string.
// The format of the string is the format of the algo::RspaceStr14's only field
bool algo::RspaceStr14_ReadStrptrMaybe(algo::RspaceStr14 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr14..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr14.String  printfmt:Raw
void algo::RspaceStr14_Print(algo::RspaceStr14 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr15.ch.Print
void algo::ch_Print(algo::RspaceStr15& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr15.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr15& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 15) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 15");
    }
    return retval;
}

// --- algo.RspaceStr15.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr15& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 15);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 15; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr15..Hash
u32 algo::RspaceStr15_Hash(u32 prev, algo::RspaceStr15 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr15..ReadStrptrMaybe
// Read fields of algo::RspaceStr15 from an ascii string.
// The format of the string is the format of the algo::RspaceStr15's only field
bool algo::RspaceStr15_ReadStrptrMaybe(algo::RspaceStr15 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr15..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr15.String  printfmt:Raw
void algo::RspaceStr15_Print(algo::RspaceStr15 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr16.ch.Print
void algo::ch_Print(algo::RspaceStr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.RspaceStr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 16; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr16..Hash
u32 algo::RspaceStr16_Hash(u32 prev, algo::RspaceStr16 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr16..ReadStrptrMaybe
// Read fields of algo::RspaceStr16 from an ascii string.
// The format of the string is the format of the algo::RspaceStr16's only field
bool algo::RspaceStr16_ReadStrptrMaybe(algo::RspaceStr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr16..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr16.String  printfmt:Raw
void algo::RspaceStr16_Print(algo::RspaceStr16 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr18.ch.Print
void algo::ch_Print(algo::RspaceStr18& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr18.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr18& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 18) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 18");
    }
    return retval;
}

// --- algo.RspaceStr18.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr18& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 18);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 18; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr18..Hash
u32 algo::RspaceStr18_Hash(u32 prev, algo::RspaceStr18 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr18..ReadStrptrMaybe
// Read fields of algo::RspaceStr18 from an ascii string.
// The format of the string is the format of the algo::RspaceStr18's only field
bool algo::RspaceStr18_ReadStrptrMaybe(algo::RspaceStr18 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr18..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr18.String  printfmt:Raw
void algo::RspaceStr18_Print(algo::RspaceStr18 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr2.ch.Print
void algo::ch_Print(algo::RspaceStr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.RspaceStr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr2& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 2; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr2..Hash
u32 algo::RspaceStr2_Hash(u32 prev, algo::RspaceStr2 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr2..ReadStrptrMaybe
// Read fields of algo::RspaceStr2 from an ascii string.
// The format of the string is the format of the algo::RspaceStr2's only field
bool algo::RspaceStr2_ReadStrptrMaybe(algo::RspaceStr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr2..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr2.String  printfmt:Raw
void algo::RspaceStr2_Print(algo::RspaceStr2 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr20.ch.Print
void algo::ch_Print(algo::RspaceStr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.RspaceStr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr20& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 20; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr20..Hash
u32 algo::RspaceStr20_Hash(u32 prev, algo::RspaceStr20 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr20..ReadStrptrMaybe
// Read fields of algo::RspaceStr20 from an ascii string.
// The format of the string is the format of the algo::RspaceStr20's only field
bool algo::RspaceStr20_ReadStrptrMaybe(algo::RspaceStr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr20..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr20.String  printfmt:Raw
void algo::RspaceStr20_Print(algo::RspaceStr20 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr200.ch.Print
void algo::ch_Print(algo::RspaceStr200& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr200.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr200& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 200) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 200");
    }
    return retval;
}

// --- algo.RspaceStr200.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr200& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 200);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 200; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr200..Hash
u32 algo::RspaceStr200_Hash(u32 prev, const algo::RspaceStr200& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr200..ReadStrptrMaybe
// Read fields of algo::RspaceStr200 from an ascii string.
// The format of the string is the format of the algo::RspaceStr200's only field
bool algo::RspaceStr200_ReadStrptrMaybe(algo::RspaceStr200 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr200..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr200.String  printfmt:Raw
void algo::RspaceStr200_Print(algo::RspaceStr200& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr21.ch.Print
void algo::ch_Print(algo::RspaceStr21& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr21.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr21& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 21) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 21");
    }
    return retval;
}

// --- algo.RspaceStr21.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr21& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 21);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 21; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr21..Hash
u32 algo::RspaceStr21_Hash(u32 prev, const algo::RspaceStr21& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr21..ReadStrptrMaybe
// Read fields of algo::RspaceStr21 from an ascii string.
// The format of the string is the format of the algo::RspaceStr21's only field
bool algo::RspaceStr21_ReadStrptrMaybe(algo::RspaceStr21 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr21..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr21.String  printfmt:Raw
void algo::RspaceStr21_Print(algo::RspaceStr21& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr24.ch.Print
void algo::ch_Print(algo::RspaceStr24& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr24.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr24& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 24) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 24");
    }
    return retval;
}

// --- algo.RspaceStr24.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr24& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 24);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 24; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr24..Hash
u32 algo::RspaceStr24_Hash(u32 prev, algo::RspaceStr24 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr24..ReadStrptrMaybe
// Read fields of algo::RspaceStr24 from an ascii string.
// The format of the string is the format of the algo::RspaceStr24's only field
bool algo::RspaceStr24_ReadStrptrMaybe(algo::RspaceStr24 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr24..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr24.String  printfmt:Raw
void algo::RspaceStr24_Print(algo::RspaceStr24 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr240.ch.Print
void algo::ch_Print(algo::RspaceStr240& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr240.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr240& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 240) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 240");
    }
    return retval;
}

// --- algo.RspaceStr240.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr240& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 240);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 240; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr240..Hash
u32 algo::RspaceStr240_Hash(u32 prev, const algo::RspaceStr240& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr240..ReadStrptrMaybe
// Read fields of algo::RspaceStr240 from an ascii string.
// The format of the string is the format of the algo::RspaceStr240's only field
bool algo::RspaceStr240_ReadStrptrMaybe(algo::RspaceStr240 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr240..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr240.String  printfmt:Raw
void algo::RspaceStr240_Print(algo::RspaceStr240& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr25.ch.Print
void algo::ch_Print(algo::RspaceStr25& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr25.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr25& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 25) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 25");
    }
    return retval;
}

// --- algo.RspaceStr25.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr25& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 25);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 25; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr25..Hash
u32 algo::RspaceStr25_Hash(u32 prev, algo::RspaceStr25 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr25..ReadStrptrMaybe
// Read fields of algo::RspaceStr25 from an ascii string.
// The format of the string is the format of the algo::RspaceStr25's only field
bool algo::RspaceStr25_ReadStrptrMaybe(algo::RspaceStr25 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr25..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr25.String  printfmt:Raw
void algo::RspaceStr25_Print(algo::RspaceStr25 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr26.ch.Print
void algo::ch_Print(algo::RspaceStr26& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr26.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr26& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 26) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 26");
    }
    return retval;
}

// --- algo.RspaceStr26.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr26& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 26);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 26; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr26..Hash
u32 algo::RspaceStr26_Hash(u32 prev, const algo::RspaceStr26& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr26..ReadStrptrMaybe
// Read fields of algo::RspaceStr26 from an ascii string.
// The format of the string is the format of the algo::RspaceStr26's only field
bool algo::RspaceStr26_ReadStrptrMaybe(algo::RspaceStr26 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr26..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr26.String  printfmt:Raw
void algo::RspaceStr26_Print(algo::RspaceStr26& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr3.ch.Print
void algo::ch_Print(algo::RspaceStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.RspaceStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr3& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 3; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr3..Hash
u32 algo::RspaceStr3_Hash(u32 prev, algo::RspaceStr3 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr3..ReadStrptrMaybe
// Read fields of algo::RspaceStr3 from an ascii string.
// The format of the string is the format of the algo::RspaceStr3's only field
bool algo::RspaceStr3_ReadStrptrMaybe(algo::RspaceStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr3..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr3.String  printfmt:Raw
void algo::RspaceStr3_Print(algo::RspaceStr3 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr31.ch.Print
void algo::ch_Print(algo::RspaceStr31& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr31.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr31& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 31) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 31");
    }
    return retval;
}

// --- algo.RspaceStr31.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr31& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 31);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 31; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr31..Hash
u32 algo::RspaceStr31_Hash(u32 prev, const algo::RspaceStr31& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr31..ReadStrptrMaybe
// Read fields of algo::RspaceStr31 from an ascii string.
// The format of the string is the format of the algo::RspaceStr31's only field
bool algo::RspaceStr31_ReadStrptrMaybe(algo::RspaceStr31 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr31..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr31.String  printfmt:Raw
void algo::RspaceStr31_Print(algo::RspaceStr31& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr32.ch.Print
void algo::ch_Print(algo::RspaceStr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.RspaceStr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 32; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr32..Hash
u32 algo::RspaceStr32_Hash(u32 prev, algo::RspaceStr32 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr32..ReadStrptrMaybe
// Read fields of algo::RspaceStr32 from an ascii string.
// The format of the string is the format of the algo::RspaceStr32's only field
bool algo::RspaceStr32_ReadStrptrMaybe(algo::RspaceStr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr32..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr32.String  printfmt:Raw
void algo::RspaceStr32_Print(algo::RspaceStr32 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr4.ch.Print
void algo::ch_Print(algo::RspaceStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.RspaceStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr4& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 4; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr4..Hash
u32 algo::RspaceStr4_Hash(u32 prev, algo::RspaceStr4 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr4..ReadStrptrMaybe
// Read fields of algo::RspaceStr4 from an ascii string.
// The format of the string is the format of the algo::RspaceStr4's only field
bool algo::RspaceStr4_ReadStrptrMaybe(algo::RspaceStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr4..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr4.String  printfmt:Raw
void algo::RspaceStr4_Print(algo::RspaceStr4 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr40.ch.Print
void algo::ch_Print(algo::RspaceStr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.RspaceStr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr40& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 40; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr40..Hash
u32 algo::RspaceStr40_Hash(u32 prev, algo::RspaceStr40 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr40..ReadStrptrMaybe
// Read fields of algo::RspaceStr40 from an ascii string.
// The format of the string is the format of the algo::RspaceStr40's only field
bool algo::RspaceStr40_ReadStrptrMaybe(algo::RspaceStr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr40..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr40.String  printfmt:Raw
void algo::RspaceStr40_Print(algo::RspaceStr40 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr5.ch.Print
void algo::ch_Print(algo::RspaceStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.RspaceStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr5& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 5; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr5..Hash
u32 algo::RspaceStr5_Hash(u32 prev, algo::RspaceStr5 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr5..ReadStrptrMaybe
// Read fields of algo::RspaceStr5 from an ascii string.
// The format of the string is the format of the algo::RspaceStr5's only field
bool algo::RspaceStr5_ReadStrptrMaybe(algo::RspaceStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr5..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr5.String  printfmt:Raw
void algo::RspaceStr5_Print(algo::RspaceStr5 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr50.ch.Print
void algo::ch_Print(algo::RspaceStr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.RspaceStr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr50& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 50; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr50..Hash
u32 algo::RspaceStr50_Hash(u32 prev, algo::RspaceStr50 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr50..ReadStrptrMaybe
// Read fields of algo::RspaceStr50 from an ascii string.
// The format of the string is the format of the algo::RspaceStr50's only field
bool algo::RspaceStr50_ReadStrptrMaybe(algo::RspaceStr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr50..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr50.String  printfmt:Raw
void algo::RspaceStr50_Print(algo::RspaceStr50 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr6.ch.Print
void algo::ch_Print(algo::RspaceStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RspaceStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr6& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr6..Hash
u32 algo::RspaceStr6_Hash(u32 prev, algo::RspaceStr6 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr6..ReadStrptrMaybe
// Read fields of algo::RspaceStr6 from an ascii string.
// The format of the string is the format of the algo::RspaceStr6's only field
bool algo::RspaceStr6_ReadStrptrMaybe(algo::RspaceStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr6..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr6.String  printfmt:Raw
void algo::RspaceStr6_Print(algo::RspaceStr6 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr64.ch.Print
void algo::ch_Print(algo::RspaceStr64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 64) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 64");
    }
    return retval;
}

// --- algo.RspaceStr64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr64& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 64);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 64; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr64..Hash
u32 algo::RspaceStr64_Hash(u32 prev, const algo::RspaceStr64& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr64..ReadStrptrMaybe
// Read fields of algo::RspaceStr64 from an ascii string.
// The format of the string is the format of the algo::RspaceStr64's only field
bool algo::RspaceStr64_ReadStrptrMaybe(algo::RspaceStr64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr64..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr64.String  printfmt:Raw
void algo::RspaceStr64_Print(algo::RspaceStr64& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr7.ch.Print
void algo::ch_Print(algo::RspaceStr7& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr7.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr7& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.RspaceStr7.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr7& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 7; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr7..Hash
u32 algo::RspaceStr7_Hash(u32 prev, algo::RspaceStr7 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr7..ReadStrptrMaybe
// Read fields of algo::RspaceStr7 from an ascii string.
// The format of the string is the format of the algo::RspaceStr7's only field
bool algo::RspaceStr7_ReadStrptrMaybe(algo::RspaceStr7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr7..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr7.String  printfmt:Raw
void algo::RspaceStr7_Print(algo::RspaceStr7 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr75.ch.Print
void algo::ch_Print(algo::RspaceStr75& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr75.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr75& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 75) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 75");
    }
    return retval;
}

// --- algo.RspaceStr75.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr75& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 75);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 75; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr75..Hash
u32 algo::RspaceStr75_Hash(u32 prev, algo::RspaceStr75 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr75..ReadStrptrMaybe
// Read fields of algo::RspaceStr75 from an ascii string.
// The format of the string is the format of the algo::RspaceStr75's only field
bool algo::RspaceStr75_ReadStrptrMaybe(algo::RspaceStr75 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr75..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr75.String  printfmt:Raw
void algo::RspaceStr75_Print(algo::RspaceStr75 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr8.ch.Print
void algo::ch_Print(algo::RspaceStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.RspaceStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr8& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 8; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr8..Hash
u32 algo::RspaceStr8_Hash(u32 prev, algo::RspaceStr8 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr8..ReadStrptrMaybe
// Read fields of algo::RspaceStr8 from an ascii string.
// The format of the string is the format of the algo::RspaceStr8's only field
bool algo::RspaceStr8_ReadStrptrMaybe(algo::RspaceStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr8..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr8.String  printfmt:Raw
void algo::RspaceStr8_Print(algo::RspaceStr8 row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr9.ch.Print
void algo::ch_Print(algo::RspaceStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.RspaceStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr9& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 9; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr9..Hash
u32 algo::RspaceStr9_Hash(u32 prev, const algo::RspaceStr9& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr9..ReadStrptrMaybe
// Read fields of algo::RspaceStr9 from an ascii string.
// The format of the string is the format of the algo::RspaceStr9's only field
bool algo::RspaceStr9_ReadStrptrMaybe(algo::RspaceStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr9..Print
// print string representation of ROW to string STR
// cfmt:algo.RspaceStr9.String  printfmt:Raw
void algo::RspaceStr9_Print(algo::RspaceStr9& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.SchedTime..ReadStrptrMaybe
// Read fields of algo::SchedTime from an ascii string.
// The format of the string is the format of the algo::SchedTime's only field
bool algo::SchedTime_ReadStrptrMaybe(algo::SchedTime &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u64_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.SchedTime..Print
// print string representation of ROW to string STR
// cfmt:algo.SchedTime.String  printfmt:Raw
void algo::SchedTime_Print(algo::SchedTime row, algo::cstring& str) {
    u64_Print(row.value, str);
}

// --- algo.SeqType..ReadStrptrMaybe
// Read fields of algo::SeqType from an ascii string.
// The format of the string is the format of the algo::SeqType's only field
bool algo::SeqType_ReadStrptrMaybe(algo::SeqType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u64_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.SeqType..Print
// print string representation of ROW to string STR
// cfmt:algo.SeqType.String  printfmt:Raw
void algo::SeqType_Print(algo::SeqType row, algo::cstring& str) {
    u64_Print(row.value, str);
}

// --- algo.Sha1sig.sha1sig.Eq
bool algo::sha1sig_Eq(algo::Sha1sig& parent, algo::Sha1sig &rhs) {
    int len = 20;
    for (int i = 0; i < len; i++) {
        if (!(parent.sha1sig_elems[i] == sha1sig_qFind(rhs,i))) {
            return false;
        }
    }
    return true;
}

// --- algo.Sha1sig.sha1sig.Cmp
int algo::sha1sig_Cmp(algo::Sha1sig& parent, algo::Sha1sig &rhs) {
    int len = 20;
    int retval = 0;
    for (int i = 0; i < len; i++) {
        retval = u8_Cmp(parent.sha1sig_elems[i], sha1sig_qFind(rhs,i));
        if (retval != 0) {
            return retval;
        }
    }
    return 0;
}

// --- algo.Sha1sig.sha1sig.Print
// Convert sha1sig to a string.
// Array is printed as a regular string.
void algo::sha1sig_Print(algo::Sha1sig& parent, algo::cstring &rhs) {
    rhs << algo::memptr_ToStrptr(sha1sig_Getary(parent));
}

// --- algo.Sha1sig.sha1sig.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::sha1sig_ReadStrptrMaybe(algo::Sha1sig& parent, algo::strptr in_str) {
    bool retval = true;
    i32 newlen = i32_Min(in_str.n_elems, 20);
    memcpy(parent.sha1sig_elems, in_str.elems, newlen);
    return retval;
}

// --- algo.Smallstr1.ch.Print
void algo::ch_Print(algo::Smallstr1& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr1.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr1& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.Smallstr1.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr1& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr1..Hash
u32 algo::Smallstr1_Hash(u32 prev, const algo::Smallstr1& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr1..ReadStrptrMaybe
// Read fields of algo::Smallstr1 from an ascii string.
// The format of the string is the format of the algo::Smallstr1's only field
bool algo::Smallstr1_ReadStrptrMaybe(algo::Smallstr1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr1..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr1.String  printfmt:Raw
void algo::Smallstr1_Print(algo::Smallstr1& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr10.ch.Print
void algo::ch_Print(algo::Smallstr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.Smallstr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr10& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr10..Hash
u32 algo::Smallstr10_Hash(u32 prev, const algo::Smallstr10& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr10..ReadStrptrMaybe
// Read fields of algo::Smallstr10 from an ascii string.
// The format of the string is the format of the algo::Smallstr10's only field
bool algo::Smallstr10_ReadStrptrMaybe(algo::Smallstr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr10..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr10.String  printfmt:Raw
void algo::Smallstr10_Print(algo::Smallstr10& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr16.ch.Print
void algo::ch_Print(algo::Smallstr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.Smallstr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr16& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr16..Hash
u32 algo::Smallstr16_Hash(u32 prev, const algo::Smallstr16& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr16..ReadStrptrMaybe
// Read fields of algo::Smallstr16 from an ascii string.
// The format of the string is the format of the algo::Smallstr16's only field
bool algo::Smallstr16_ReadStrptrMaybe(algo::Smallstr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr16..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr16.String  printfmt:Raw
void algo::Smallstr16_Print(algo::Smallstr16& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr2.ch.Print
void algo::ch_Print(algo::Smallstr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.Smallstr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr2& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr2..Hash
u32 algo::Smallstr2_Hash(u32 prev, const algo::Smallstr2& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr2..ReadStrptrMaybe
// Read fields of algo::Smallstr2 from an ascii string.
// The format of the string is the format of the algo::Smallstr2's only field
bool algo::Smallstr2_ReadStrptrMaybe(algo::Smallstr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr2..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr2.String  printfmt:Raw
void algo::Smallstr2_Print(algo::Smallstr2& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr20.ch.Print
void algo::ch_Print(algo::Smallstr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.Smallstr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr20& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr20..Hash
u32 algo::Smallstr20_Hash(u32 prev, const algo::Smallstr20& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr20..ReadStrptrMaybe
// Read fields of algo::Smallstr20 from an ascii string.
// The format of the string is the format of the algo::Smallstr20's only field
bool algo::Smallstr20_ReadStrptrMaybe(algo::Smallstr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr20..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr20.String  printfmt:Raw
void algo::Smallstr20_Print(algo::Smallstr20& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr200.ch.Print
void algo::ch_Print(algo::Smallstr200& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr200.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr200& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 200) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 200");
    }
    return retval;
}

// --- algo.Smallstr200.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr200& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 200);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr200..Hash
u32 algo::Smallstr200_Hash(u32 prev, const algo::Smallstr200& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr200..ReadStrptrMaybe
// Read fields of algo::Smallstr200 from an ascii string.
// The format of the string is the format of the algo::Smallstr200's only field
bool algo::Smallstr200_ReadStrptrMaybe(algo::Smallstr200 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr200..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr200.String  printfmt:Raw
void algo::Smallstr200_Print(algo::Smallstr200& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr25.ch.Print
void algo::ch_Print(algo::Smallstr25& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr25.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr25& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 25) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 25");
    }
    return retval;
}

// --- algo.Smallstr25.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr25& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 25);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr25..Hash
u32 algo::Smallstr25_Hash(u32 prev, const algo::Smallstr25& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr25..ReadStrptrMaybe
// Read fields of algo::Smallstr25 from an ascii string.
// The format of the string is the format of the algo::Smallstr25's only field
bool algo::Smallstr25_ReadStrptrMaybe(algo::Smallstr25 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr25..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr25.String  printfmt:Raw
void algo::Smallstr25_Print(algo::Smallstr25& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr3.ch.Print
void algo::ch_Print(algo::Smallstr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.Smallstr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr3& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr3..Hash
u32 algo::Smallstr3_Hash(u32 prev, const algo::Smallstr3& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr3..ReadStrptrMaybe
// Read fields of algo::Smallstr3 from an ascii string.
// The format of the string is the format of the algo::Smallstr3's only field
bool algo::Smallstr3_ReadStrptrMaybe(algo::Smallstr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr3..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr3.String  printfmt:Raw
void algo::Smallstr3_Print(algo::Smallstr3& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr30.ch.Print
void algo::ch_Print(algo::Smallstr30& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr30.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr30& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 30) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 30");
    }
    return retval;
}

// --- algo.Smallstr30.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr30& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 30);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr30..Hash
u32 algo::Smallstr30_Hash(u32 prev, const algo::Smallstr30& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr30..ReadStrptrMaybe
// Read fields of algo::Smallstr30 from an ascii string.
// The format of the string is the format of the algo::Smallstr30's only field
bool algo::Smallstr30_ReadStrptrMaybe(algo::Smallstr30 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr30..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr30.String  printfmt:Raw
void algo::Smallstr30_Print(algo::Smallstr30& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr32.ch.Print
void algo::ch_Print(algo::Smallstr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.Smallstr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr32& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr32..Hash
u32 algo::Smallstr32_Hash(u32 prev, const algo::Smallstr32& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr32..ReadStrptrMaybe
// Read fields of algo::Smallstr32 from an ascii string.
// The format of the string is the format of the algo::Smallstr32's only field
bool algo::Smallstr32_ReadStrptrMaybe(algo::Smallstr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr32..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr32.String  printfmt:Raw
void algo::Smallstr32_Print(algo::Smallstr32& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr4.ch.Print
void algo::ch_Print(algo::Smallstr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.Smallstr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr4& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr4..Hash
u32 algo::Smallstr4_Hash(u32 prev, const algo::Smallstr4& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr4..ReadStrptrMaybe
// Read fields of algo::Smallstr4 from an ascii string.
// The format of the string is the format of the algo::Smallstr4's only field
bool algo::Smallstr4_ReadStrptrMaybe(algo::Smallstr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr4..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr4.String  printfmt:Raw
void algo::Smallstr4_Print(algo::Smallstr4& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr40.ch.Print
void algo::ch_Print(algo::Smallstr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.Smallstr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr40& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr40..Hash
u32 algo::Smallstr40_Hash(u32 prev, const algo::Smallstr40& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr40..ReadStrptrMaybe
// Read fields of algo::Smallstr40 from an ascii string.
// The format of the string is the format of the algo::Smallstr40's only field
bool algo::Smallstr40_ReadStrptrMaybe(algo::Smallstr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr40..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr40.String  printfmt:Raw
void algo::Smallstr40_Print(algo::Smallstr40& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr5.ch.Print
void algo::ch_Print(algo::Smallstr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.Smallstr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr5& parent, const algo::strptr& rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr5..Hash
u32 algo::Smallstr5_Hash(u32 prev, const algo::Smallstr5& rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr5..ReadStrptrMaybe
// Read fields of algo::Smallstr5 from an ascii string.
// The format of the string is the format of the algo::Smallstr5's only field
bool algo::Smallstr5_ReadStrptrMaybe(algo::Smallstr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr5..Print
// print string representation of ROW to string STR
// cfmt:algo.Smallstr5.String  printfmt:Raw
void algo::Smallstr5_Print(algo::Smallstr5& row, algo::cstring& str) {
    algo::ch_Print(row, str);
}

// --- algo.StringAry.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> algo::ary_Addary(algo::StringAry& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.StringAry.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.ary_elems + at + i) algo::cstring(rhs[i]);
        parent.ary_n++;
    }
    return algo::aryptr<algo::cstring>(parent.ary_elems + at, nnew);
}

// --- algo.StringAry.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& algo::ary_Alloc(algo::StringAry& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    algo::cstring *elems = parent.ary_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.StringAry.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& algo::ary_AllocAt(algo::StringAry& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.StringAry.ary  comment:'index out of range'");
    }
    algo::cstring *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.StringAry.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> algo::ary_AllocN(algo::StringAry& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.ary_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- algo.StringAry.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ary_Remove(algo::StringAry& parent, u32 i) {
    u32 lim = parent.ary_n;
    algo::cstring *elems = parent.ary_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo.StringAry.ary.RemoveAll
void algo::ary_RemoveAll(algo::StringAry& parent) {
    u32 n = parent.ary_n;
    while (n > 0) {
        n -= 1;
        parent.ary_elems[n].~cstring();
        parent.ary_n = n;
    }
}

// --- algo.StringAry.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ary_RemoveLast(algo::StringAry& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        ary_qFind(parent, u64(n)).~cstring();
        parent.ary_n = n;
    }
}

// --- algo.StringAry.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ary_AbsReserve(algo::StringAry& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.StringAry.ary  comment:'out of memory'");
        }
        parent.ary_elems = (algo::cstring*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- algo.StringAry.ary.Setary
// Copy contents of RHS to PARENT.
void algo::ary_Setary(algo::StringAry& parent, algo::StringAry &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.ary_elems + i) algo::cstring(ary_qFind(rhs, i));
        parent.ary_n = i + 1;
    }
}

// --- algo.StringAry.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ary_Setary(algo::StringAry& parent, const algo::aryptr<algo::cstring> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- algo.StringAry.ary.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> algo::ary_AllocNVal(algo::StringAry& parent, int n_elems, const algo::cstring& val) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.ary_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- algo.StringAry.ary.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool algo::ary_ReadStrptrMaybe(algo::StringAry& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = ary_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        ary_RemoveLast(parent);
    }
    return retval;
}

// --- algo.StringAry..ReadStrptrMaybe
// Read fields of algo::StringAry from an ascii string.
// The format of the string is the format of the algo::StringAry's only field
bool algo::StringAry_ReadStrptrMaybe(algo::StringAry &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && ary_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.StringAry..Uninit
void algo::StringAry_Uninit(algo::StringAry& parent) {
    algo::StringAry &row = parent; (void)row;

    // algo.StringAry.ary.Uninit (Tary)  //
    // remove all elements from algo.StringAry.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo.StringAry.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(algo::cstring)*parent.ary_max); // (algo.StringAry.ary)
}

// --- algo.StringAry..Print
// print string representation of ROW to string STR
// cfmt:algo.StringAry.String  printfmt:Raw
void algo::StringAry_Print(algo::StringAry& row, algo::cstring& str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- algo.StringAry..AssignOp
algo::StringAry& algo::StringAry::operator =(const algo::StringAry &rhs) {
    ary_Setary(*this, ary_Getary(const_cast<algo::StringAry&>(rhs)));
    return *this;
}

// --- algo.StringAry..CopyCtor
 algo::StringAry::StringAry(const algo::StringAry &rhs) {
    ary_elems 	= 0; // (algo.StringAry.ary)
    ary_n     	= 0; // (algo.StringAry.ary)
    ary_max   	= 0; // (algo.StringAry.ary)
    ary_Setary(*this, ary_Getary(const_cast<algo::StringAry&>(rhs)));
}

// --- algo.TermStyle.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::TermStyle& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_TermStyle_default        : ret = "default";  break;
        case algo_TermStyle_red            : ret = "red";  break;
        case algo_TermStyle_green          : ret = "green";  break;
        case algo_TermStyle_blue           : ret = "blue";  break;
        case algo_TermStyle_bold           : ret = "bold";  break;
    }
    return ret;
}

// --- algo.TermStyle.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::TermStyle& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.TermStyle.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('r','e','d'): {
                    value_SetEnum(parent,algo_TermStyle_red); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','l','u','e'): {
                    value_SetEnum(parent,algo_TermStyle_blue); ret = true; break;
                }
                case LE_STR4('b','o','l','d'): {
                    value_SetEnum(parent,algo_TermStyle_bold); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('g','r','e','e','n'): {
                    value_SetEnum(parent,algo_TermStyle_green); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('d','e','f','a','u','l','t'): {
                    value_SetEnum(parent,algo_TermStyle_default); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.TermStyle.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::TermStyle& parent, algo::strptr rhs, algo_TermStyleEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.TermStyle.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.TermStyle..ReadStrptrMaybe
// Read fields of algo::TermStyle from an ascii string.
// The format of the string is the format of the algo::TermStyle's only field
bool algo::TermStyle_ReadStrptrMaybe(algo::TermStyle &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.TermStyle..Print
// print string representation of ROW to string STR
// cfmt:algo.TermStyle.String  printfmt:Raw
void algo::TermStyle_Print(algo::TermStyle row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.TextJust.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::TextJust& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_TextJust_j_right         : ret = "j_right";  break;
        case algo_TextJust_j_left          : ret = "j_left";  break;
        case algo_TextJust_j_center        : ret = "j_center";  break;
    }
    return ret;
}

// --- algo.TextJust.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::TextJust& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.TextJust.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('j','_','l','e','f','t'): {
                    value_SetEnum(parent,algo_TextJust_j_left); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('j','_','r','i','g','h','t'): {
                    value_SetEnum(parent,algo_TextJust_j_right); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('j','_','c','e','n','t','e','r'): {
                    value_SetEnum(parent,algo_TextJust_j_center); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.TextJust.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::TextJust& parent, algo::strptr rhs, algo_TextJustEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.TextJust.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.TextJust..ReadStrptrMaybe
// Read fields of algo::TextJust from an ascii string.
// The format of the string is the format of the algo::TextJust's only field
bool algo::TextJust_ReadStrptrMaybe(algo::TextJust &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.TextJust..Print
// print string representation of ROW to string STR
// cfmt:algo.TextJust.String  printfmt:Raw
void algo::TextJust_Print(algo::TextJust row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.TstampCache..Init
// Set all fields to initial values.
void algo::TstampCache_Init(algo::TstampCache& parent) {
    parent.sec_location = i8(0);
    parent.min_location = i8(0);
    parent.nano_location = i8(0);
    parent.nano_size = i8(0);
    parent.cacheable = bool(false);
    parent.gmtQ = bool(false);
}

// --- algo.Tuple.attrs.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::Attr> algo::attrs_Addary(algo::Tuple& parent, algo::aryptr<algo::Attr> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.attrs_elems && rhs.elems < parent.attrs_elems + parent.attrs_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.Tuple.attrs  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    attrs_Reserve(parent, nnew); // reserve space
    int at = parent.attrs_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.attrs_elems + at + i) algo::Attr(rhs[i]);
        parent.attrs_n++;
    }
    return algo::aryptr<algo::Attr>(parent.attrs_elems + at, nnew);
}

// --- algo.Tuple.attrs.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::Attr& algo::attrs_Alloc(algo::Tuple& parent) {
    attrs_Reserve(parent, 1);
    int n  = parent.attrs_n;
    int at = n;
    algo::Attr *elems = parent.attrs_elems;
    new (elems + at) algo::Attr(); // construct new element, default initializer
    parent.attrs_n = n+1;
    return elems[at];
}

// --- algo.Tuple.attrs.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::Attr& algo::attrs_AllocAt(algo::Tuple& parent, int at) {
    attrs_Reserve(parent, 1);
    int n  = parent.attrs_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Tuple.attrs  comment:'index out of range'");
    }
    algo::Attr *elems = parent.attrs_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::Attr));
    new (elems + at) algo::Attr(); // construct element, default initializer
    parent.attrs_n = n+1;
    return elems[at];
}

// --- algo.Tuple.attrs.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::Attr> algo::attrs_AllocN(algo::Tuple& parent, int n_elems) {
    attrs_Reserve(parent, n_elems);
    int old_n  = parent.attrs_n;
    int new_n = old_n + n_elems;
    algo::Attr *elems = parent.attrs_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::Attr(); // construct new element, default initialize
    }
    parent.attrs_n = new_n;
    return algo::aryptr<algo::Attr>(elems + old_n, n_elems);
}

// --- algo.Tuple.attrs.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::attrs_Remove(algo::Tuple& parent, u32 i) {
    u32 lim = parent.attrs_n;
    algo::Attr *elems = parent.attrs_elems;
    if (i < lim) {
        elems[i].~Attr(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::Attr) * (lim - (i + 1)));
        parent.attrs_n = lim - 1;
    }
}

// --- algo.Tuple.attrs.RemoveAll
void algo::attrs_RemoveAll(algo::Tuple& parent) {
    u32 n = parent.attrs_n;
    while (n > 0) {
        n -= 1;
        parent.attrs_elems[n].~Attr();
        parent.attrs_n = n;
    }
}

// --- algo.Tuple.attrs.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::attrs_RemoveLast(algo::Tuple& parent) {
    u64 n = parent.attrs_n;
    if (n > 0) {
        n -= 1;
        attrs_qFind(parent, u64(n)).~Attr();
        parent.attrs_n = n;
    }
}

// --- algo.Tuple.attrs.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::attrs_AbsReserve(algo::Tuple& parent, int n) {
    u32 old_max  = parent.attrs_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.attrs_elems, old_max * sizeof(algo::Attr), new_max * sizeof(algo::Attr));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Tuple.attrs  comment:'out of memory'");
        }
        parent.attrs_elems = (algo::Attr*)new_mem;
        parent.attrs_max = new_max;
    }
}

// --- algo.Tuple.attrs.Setary
// Copy contents of RHS to PARENT.
void algo::attrs_Setary(algo::Tuple& parent, algo::Tuple &rhs) {
    attrs_RemoveAll(parent);
    int nnew = rhs.attrs_n;
    attrs_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.attrs_elems + i) algo::Attr(attrs_qFind(rhs, i));
        parent.attrs_n = i + 1;
    }
}

// --- algo.Tuple.attrs.Setary2
// Copy specified array into attrs, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::attrs_Setary(algo::Tuple& parent, const algo::aryptr<algo::Attr> &rhs) {
    attrs_RemoveAll(parent);
    attrs_Addary(parent, rhs);
}

// --- algo.Tuple.attrs.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::Attr> algo::attrs_AllocNVal(algo::Tuple& parent, int n_elems, const algo::Attr& val) {
    attrs_Reserve(parent, n_elems);
    int old_n  = parent.attrs_n;
    int new_n = old_n + n_elems;
    algo::Attr *elems = parent.attrs_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::Attr(val);
    }
    parent.attrs_n = new_n;
    return algo::aryptr<algo::Attr>(elems + old_n, n_elems);
}

// --- algo.Tuple.attrs.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool algo::attrs_ReadStrptrMaybe(algo::Tuple& parent, algo::strptr in_str) {
    bool retval = true;
    algo::Attr &elem = attrs_Alloc(parent);
    retval = algo::Attr_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        attrs_RemoveLast(parent);
    }
    return retval;
}

// --- algo.Tuple..Uninit
void algo::Tuple_Uninit(algo::Tuple& parent) {
    algo::Tuple &row = parent; (void)row;

    // algo.Tuple.attrs.Uninit (Tary)  //Array of attributes
    // remove all elements from algo.Tuple.attrs
    attrs_RemoveAll(parent);
    // free memory for Tary algo.Tuple.attrs
    algo_lib::malloc_FreeMem(parent.attrs_elems, sizeof(algo::Attr)*parent.attrs_max); // (algo.Tuple.attrs)
}

// --- algo.Tuple..AssignOp
algo::Tuple& algo::Tuple::operator =(const algo::Tuple &rhs) {
    attrs_Setary(*this, attrs_Getary(const_cast<algo::Tuple&>(rhs)));
    head = rhs.head;
    return *this;
}

// --- algo.Tuple..CopyCtor
 algo::Tuple::Tuple(const algo::Tuple &rhs)
    : head(rhs.head)
 {
    attrs_elems 	= 0; // (algo.Tuple.attrs)
    attrs_n     	= 0; // (algo.Tuple.attrs)
    attrs_max   	= 0; // (algo.Tuple.attrs)
    attrs_Setary(*this, attrs_Getary(const_cast<algo::Tuple&>(rhs)));
}

// --- algo.U16Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U16Dec2& parent, double val) {
    double intval = val * 100;
    u16 minval = u16(0ULL);
    u16 maxval = u16(65535ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U16Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U16Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U16Dec2.value.Print
void algo::value_Print(algo::U16Dec2& parent, cstring &outstr) {
    u16 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U16Dec2..ReadStrptrMaybe
// Read fields of algo::U16Dec2 from an ascii string.
// The format of the string is the format of the algo::U16Dec2's only field
bool algo::U16Dec2_ReadStrptrMaybe(algo::U16Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U16Dec2..Print
// print string representation of ROW to string STR
// cfmt:algo.U16Dec2.String  printfmt:Raw
void algo::U16Dec2_Print(algo::U16Dec2 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec1& parent, double val) {
    double intval = val * 10;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec1.value.Print
void algo::value_Print(algo::U32Dec1& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.U32Dec1..ReadStrptrMaybe
// Read fields of algo::U32Dec1 from an ascii string.
// The format of the string is the format of the algo::U32Dec1's only field
bool algo::U32Dec1_ReadStrptrMaybe(algo::U32Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec1..Print
// print string representation of ROW to string STR
// cfmt:algo.U32Dec1.String  printfmt:Raw
void algo::U32Dec1_Print(algo::U32Dec1 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec2& parent, double val) {
    double intval = val * 100;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec2.value.Print
void algo::value_Print(algo::U32Dec2& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U32Dec2..ReadStrptrMaybe
// Read fields of algo::U32Dec2 from an ascii string.
// The format of the string is the format of the algo::U32Dec2's only field
bool algo::U32Dec2_ReadStrptrMaybe(algo::U32Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec2..Print
// print string representation of ROW to string STR
// cfmt:algo.U32Dec2.String  printfmt:Raw
void algo::U32Dec2_Print(algo::U32Dec2 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec3& parent, double val) {
    double intval = val * 1000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec3.value.Print
void algo::value_Print(algo::U32Dec3& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.U32Dec3..ReadStrptrMaybe
// Read fields of algo::U32Dec3 from an ascii string.
// The format of the string is the format of the algo::U32Dec3's only field
bool algo::U32Dec3_ReadStrptrMaybe(algo::U32Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec3..Print
// print string representation of ROW to string STR
// cfmt:algo.U32Dec3.String  printfmt:Raw
void algo::U32Dec3_Print(algo::U32Dec3 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec4& parent, double val) {
    double intval = val * 10000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec4.value.Print
void algo::value_Print(algo::U32Dec4& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.U32Dec4..ReadStrptrMaybe
// Read fields of algo::U32Dec4 from an ascii string.
// The format of the string is the format of the algo::U32Dec4's only field
bool algo::U32Dec4_ReadStrptrMaybe(algo::U32Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec4..Print
// print string representation of ROW to string STR
// cfmt:algo.U32Dec4.String  printfmt:Raw
void algo::U32Dec4_Print(algo::U32Dec4 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec5& parent, double val) {
    double intval = val * 100000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec5.value.Print
void algo::value_Print(algo::U32Dec5& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.U32Dec5..ReadStrptrMaybe
// Read fields of algo::U32Dec5 from an ascii string.
// The format of the string is the format of the algo::U32Dec5's only field
bool algo::U32Dec5_ReadStrptrMaybe(algo::U32Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec5..Print
// print string representation of ROW to string STR
// cfmt:algo.U32Dec5.String  printfmt:Raw
void algo::U32Dec5_Print(algo::U32Dec5 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Ary.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u64> algo::ary_Addary(algo::U64Ary& parent, algo::aryptr<u64> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.U64Ary.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    memcpy(parent.ary_elems + at, rhs.elems, nnew * sizeof(u64));
    parent.ary_n += nnew;
    return algo::aryptr<u64>(parent.ary_elems + at, nnew);
}

// --- algo.U64Ary.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u64& algo::ary_Alloc(algo::U64Ary& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u64 *elems = parent.ary_elems;
    new (elems + at) u64(0); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.U64Ary.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u64& algo::ary_AllocAt(algo::U64Ary& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.U64Ary.ary  comment:'index out of range'");
    }
    u64 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u64));
    new (elems + at) u64(0); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.U64Ary.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64> algo::ary_AllocN(algo::U64Ary& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u64 *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u64(0); // construct new element, default initialize
    }
    parent.ary_n = new_n;
    return algo::aryptr<u64>(elems + old_n, n_elems);
}

// --- algo.U64Ary.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ary_Remove(algo::U64Ary& parent, u32 i) {
    u32 lim = parent.ary_n;
    u64 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u64) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo.U64Ary.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ary_RemoveLast(algo::U64Ary& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- algo.U64Ary.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ary_AbsReserve(algo::U64Ary& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(u64), new_max * sizeof(u64));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.U64Ary.ary  comment:'out of memory'");
        }
        parent.ary_elems = (u64*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- algo.U64Ary.ary.Setary
// Copy contents of RHS to PARENT.
void algo::ary_Setary(algo::U64Ary& parent, algo::U64Ary &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.ary_elems + i) u64(ary_qFind(rhs, i));
        parent.ary_n = i + 1;
    }
}

// --- algo.U64Ary.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ary_Setary(algo::U64Ary& parent, const algo::aryptr<u64> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- algo.U64Ary.ary.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64> algo::ary_AllocNVal(algo::U64Ary& parent, int n_elems, const u64& val) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u64 *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u64(val);
    }
    parent.ary_n = new_n;
    return algo::aryptr<u64>(elems + old_n, n_elems);
}

// --- algo.U64Ary.ary.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool algo::ary_ReadStrptrMaybe(algo::U64Ary& parent, algo::strptr in_str) {
    bool retval = true;
    u64 &elem = ary_Alloc(parent);
    retval = u64_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        ary_RemoveLast(parent);
    }
    return retval;
}

// --- algo.U64Ary..Uninit
void algo::U64Ary_Uninit(algo::U64Ary& parent) {
    algo::U64Ary &row = parent; (void)row;

    // algo.U64Ary.ary.Uninit (Tary)  //Array of u64 values
    // remove all elements from algo.U64Ary.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo.U64Ary.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(u64)*parent.ary_max); // (algo.U64Ary.ary)
}

// --- algo.U64Ary..AssignOp
algo::U64Ary& algo::U64Ary::operator =(const algo::U64Ary &rhs) {
    ary_Setary(*this, ary_Getary(const_cast<algo::U64Ary&>(rhs)));
    return *this;
}

// --- algo.U64Ary..CopyCtor
 algo::U64Ary::U64Ary(const algo::U64Ary &rhs) {
    ary_elems 	= 0; // (algo.U64Ary.ary)
    ary_n     	= 0; // (algo.U64Ary.ary)
    ary_max   	= 0; // (algo.U64Ary.ary)
    ary_Setary(*this, ary_Getary(const_cast<algo::U64Ary&>(rhs)));
}

// --- algo.U64Dec10.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec10& parent, double val) {
    double intval = val * 10000000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec10.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec10& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 10) { // ignore digits after 10'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 10) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec10.value.Print
void algo::value_Print(algo::U64Dec10& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 10, value_start, true);
}

// --- algo.U64Dec10..ReadStrptrMaybe
// Read fields of algo::U64Dec10 from an ascii string.
// The format of the string is the format of the algo::U64Dec10's only field
bool algo::U64Dec10_ReadStrptrMaybe(algo::U64Dec10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec10..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec10.String  printfmt:Raw
void algo::U64Dec10_Print(algo::U64Dec10 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec2& parent, double val) {
    double intval = val * 100;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec2.value.Print
void algo::value_Print(algo::U64Dec2& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U64Dec2..ReadStrptrMaybe
// Read fields of algo::U64Dec2 from an ascii string.
// The format of the string is the format of the algo::U64Dec2's only field
bool algo::U64Dec2_ReadStrptrMaybe(algo::U64Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec2..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec2.String  printfmt:Raw
void algo::U64Dec2_Print(algo::U64Dec2 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec4& parent, double val) {
    double intval = val * 10000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec4.value.Print
void algo::value_Print(algo::U64Dec4& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.U64Dec4..ReadStrptrMaybe
// Read fields of algo::U64Dec4 from an ascii string.
// The format of the string is the format of the algo::U64Dec4's only field
bool algo::U64Dec4_ReadStrptrMaybe(algo::U64Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec4..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec4.String  printfmt:Raw
void algo::U64Dec4_Print(algo::U64Dec4 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec5& parent, double val) {
    double intval = val * 100000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec5.value.Print
void algo::value_Print(algo::U64Dec5& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.U64Dec5..ReadStrptrMaybe
// Read fields of algo::U64Dec5 from an ascii string.
// The format of the string is the format of the algo::U64Dec5's only field
bool algo::U64Dec5_ReadStrptrMaybe(algo::U64Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec5..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec5.String  printfmt:Raw
void algo::U64Dec5_Print(algo::U64Dec5 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec6.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec6& parent, double val) {
    double intval = val * 1000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec6.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec6& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 6) { // ignore digits after 6'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 6) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec6.value.Print
void algo::value_Print(algo::U64Dec6& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 6, value_start, true);
}

// --- algo.U64Dec6..ReadStrptrMaybe
// Read fields of algo::U64Dec6 from an ascii string.
// The format of the string is the format of the algo::U64Dec6's only field
bool algo::U64Dec6_ReadStrptrMaybe(algo::U64Dec6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec6..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec6.String  printfmt:Raw
void algo::U64Dec6_Print(algo::U64Dec6 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec7.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec7& parent, double val) {
    double intval = val * 10000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec7.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec7& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 7) { // ignore digits after 7'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 7) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec7.value.Print
void algo::value_Print(algo::U64Dec7& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 7, value_start, true);
}

// --- algo.U64Dec7..ReadStrptrMaybe
// Read fields of algo::U64Dec7 from an ascii string.
// The format of the string is the format of the algo::U64Dec7's only field
bool algo::U64Dec7_ReadStrptrMaybe(algo::U64Dec7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec7..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec7.String  printfmt:Raw
void algo::U64Dec7_Print(algo::U64Dec7 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec8.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec8& parent, double val) {
    double intval = val * 100000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec8.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec8& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 8) { // ignore digits after 8'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 8) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec8.value.Print
void algo::value_Print(algo::U64Dec8& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 8, value_start, true);
}

// --- algo.U64Dec8..ReadStrptrMaybe
// Read fields of algo::U64Dec8 from an ascii string.
// The format of the string is the format of the algo::U64Dec8's only field
bool algo::U64Dec8_ReadStrptrMaybe(algo::U64Dec8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec8..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec8.String  printfmt:Raw
void algo::U64Dec8_Print(algo::U64Dec8 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec9.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec9& parent, double val) {
    double intval = val * 1000000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec9.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec9& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 9) { // ignore digits after 9'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 9) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec9.value.Print
void algo::value_Print(algo::U64Dec9& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 9, value_start, true);
}

// --- algo.U64Dec9..ReadStrptrMaybe
// Read fields of algo::U64Dec9 from an ascii string.
// The format of the string is the format of the algo::U64Dec9's only field
bool algo::U64Dec9_ReadStrptrMaybe(algo::U64Dec9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec9..Print
// print string representation of ROW to string STR
// cfmt:algo.U64Dec9.String  printfmt:Raw
void algo::U64Dec9_Print(algo::U64Dec9 row, algo::cstring& str) {
    algo::value_Print(row, str);
}

// --- algo...ForAllStrings
// Test string conversion
void algo::ForAllStrings(void (*fcn)(algo::StringDesc&) ) {
    algo::StringDesc desc;
    // fill out descriptor for numstr:algo.LnumStr10_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr10_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr10_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr10_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr10_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr10_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 10;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr11_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr11_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr11_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr11_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr11_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr11_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 11;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr12_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr12_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr12_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr12_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr12_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr12_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 12;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr13_U64_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr13_U64_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr13_U64_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr13_U64_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr13_U64_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr13_U64_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 13;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr16_U64_Base16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr16_U64_Base16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr16_U64_Base16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr16_U64_Base16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr16_U64_Base16&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr16_U64_Base16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 16;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 16;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr1_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr1_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr1_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr1_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr1_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr1_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 1;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr20_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr20_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr20_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr20_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr20_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr20_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr22_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr22_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr22_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr22_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr22_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr22_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 22;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr2_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr2_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr2_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr2_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr2_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr2_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 2;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr3_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr3_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr3_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr3_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr3_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr3_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 3;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr4_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr4_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr4_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr4_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr4_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr4_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 4;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr5_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr5_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr5_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr5_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr5_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr5_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr5_U32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr5_U32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr5_U32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr5_U32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr5_U32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr5_U32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr6_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr7_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr7_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr7_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr7_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr7_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr7_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr7_U32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr7_U32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr7_U32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr7_U32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr7_U32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr7_U32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U32_Base16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U32_Base16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U32_Base16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U32_Base16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U32_Base16&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U32_Base16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 16;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr9_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr9_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr9_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr9_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr9_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr9_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 9;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr9_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr9_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr9_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr9_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr9_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr9_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 9;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr20_I64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr20_I64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr20_I64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr20_I64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr20_I64&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr20_I64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = i64(0X7FFFFFFFFFFFFFFF);
        desc.numtype_min = i64(0X8000000000000001);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr20_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr20_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr20_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr20_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr20_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr20_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr3_I16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr3_I16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr3_I16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr3_I16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr3_I16&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr3_I16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 3;
        desc.numtype_max = i64(0X7FFF);
        desc.numtype_min = i64(0XFFFFFFFFFFFF8000);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr5_I16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr5_I16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr5_I16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr5_I16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr5_I16&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr5_I16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 5;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr6_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr7_I32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr7_I32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr7_I32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr7_I32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr7_I32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr7_I32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 36;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = i64(0X7FFFFFFF);
        desc.numtype_min = i64(0XFFFFFFFF80000000);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.RnullStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::RnullStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::RnullStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::RnullStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::RnullStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.RnullStr6_U32.ch";
        desc.strtype     = "rightpad";
        desc.pad         = 0;
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
}

// --- algo...SizeCheck
inline static void algo::SizeCheck() {
}

// --- algo...StaticCheck
void algo::StaticCheck() {
    algo_assert(sizeof(algo::ImdbInsertStrptrMaybeFcn) == 8); // csize:algo.ImdbInsertStrptrMaybeFcn
    algo_assert(sizeof(algo::ImdbStepFcn) == 8); // csize:algo.ImdbStepFcn
    algo_assert(sizeof(algo::ImdbMainLoopFcn) == 8); // csize:algo.ImdbMainLoopFcn
    algo_assert(sizeof(algo::ImdbGetTraceFcn) == 8); // csize:algo.ImdbGetTraceFcn
    algo_assert(sizeof(algo::ImrowNItemsFcn) == 8); // csize:algo.ImrowNItemsFcn
    algo_assert(sizeof(algo::ImrowPrintFcn) == 8); // csize:algo.ImrowPrintFcn
    algo_assert(sizeof(algo::ImrowRowidFindFcn) == 8); // csize:algo.ImrowRowidFindFcn
    algo_assert(sizeof(algo::ImrowXrefXFcn) == 8); // csize:algo.ImrowXrefXFcn
    algo_assert(sizeof(algo::strptr) == 16); // csize:algo.strptr
    algo_assert(sizeof(algo::PrlogFcn) == 8); // csize:algo.PrlogFcn
    algo_assert(sizeof(algo::memptr) == 16); // csize:algo.memptr
    algo_assert(_offset_of(algo::UnTime, value) + sizeof(((algo::UnTime*)0)->value) == sizeof(algo::UnTime));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::Errcode*)0)->value)*8 >= 40);
    algo_assert(_offset_of(algo::FieldId, value) + sizeof(((algo::FieldId*)0)->value) == sizeof(algo::FieldId));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::FileFlags*)0)->value)*8 >= 10);
    algo_assert(_offset_of(algo::I64Dec4, value) + sizeof(((algo::I64Dec4*)0)->value) == sizeof(algo::I64Dec4));
    algo_assert(_offset_of(algo::I64Dec5, value) + sizeof(((algo::I64Dec5*)0)->value) == sizeof(algo::I64Dec5));
    algo_assert(_offset_of(algo::I64Dec8, value) + sizeof(((algo::I64Dec8*)0)->value) == sizeof(algo::I64Dec8));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::IOEvtFlags*)0)->value)*8 >= 4);
    // check that bitfield fits width
    algo_assert(sizeof(((algo::NumParseFlags*)0)->value)*8 >= 5);
    algo_assert(_offset_of(algo::SchedTime, value) + sizeof(((algo::SchedTime*)0)->value) == sizeof(algo::SchedTime));
    algo_assert(_offset_of(algo::SeqType, value) + sizeof(((algo::SeqType*)0)->value) == sizeof(algo::SeqType));
    algo_assert(_offset_of(algo::U16Dec2, value) + sizeof(((algo::U16Dec2*)0)->value) == sizeof(algo::U16Dec2));
    algo_assert(_offset_of(algo::U32Dec1, value) + sizeof(((algo::U32Dec1*)0)->value) == sizeof(algo::U32Dec1));
    algo_assert(_offset_of(algo::U64Dec2, value) + sizeof(((algo::U64Dec2*)0)->value) == sizeof(algo::U64Dec2));
    algo_assert(_offset_of(algo::U64Dec4, value) + sizeof(((algo::U64Dec4*)0)->value) == sizeof(algo::U64Dec4));
    algo_assert(_offset_of(algo::U64Dec8, value) + sizeof(((algo::U64Dec8*)0)->value) == sizeof(algo::U64Dec8));
    algo_assert(_offset_of(algo::UnDiff, value) + sizeof(((algo::UnDiff*)0)->value) == sizeof(algo::UnDiff));
    algo_assert(_offset_of(algo::UnixTime, value) + sizeof(((algo::UnixTime*)0)->value) == sizeof(algo::UnixTime));
    algo_assert(_offset_of(algo::WDiff, value) + sizeof(((algo::WDiff*)0)->value) == sizeof(algo::WDiff));
    algo_assert(_offset_of(algo::WTime, value) + sizeof(((algo::WTime*)0)->value) == sizeof(algo::WTime));
}
