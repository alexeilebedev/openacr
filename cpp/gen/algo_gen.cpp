//
// cpp/gen/algo_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace algo {
    static bool          append_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          read_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          write_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          _throw_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          temp_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          overlap_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          linear_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          printerr_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          read_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          write_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          eof_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          err_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr10_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr11_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr12_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr13_U64_Base36& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr16_U64_Base16& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr1_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr20_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr22_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr2_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr3_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr4_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr5_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr5_U32_Base36& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr6_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr7_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr7_U32_Base36& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr8_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr8_U32_Base16& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr8_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LnumStr9_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LnumStr9_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static i64           ch_qGetnum(algo::LspaceStr20_I64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u64           ch_qGetnum(algo::LspaceStr20_U64& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static i16           ch_qGetnum(algo::LspaceStr3_I16& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u16           ch_qGetnum(algo::LspaceStr5_I16& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::LspaceStr6_U32& parent, u32 &ok) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static i32           ch_qGetnum(algo::LspaceStr7_I32_Base36& parent, u32 &ok) __attribute__((nothrow));
    static bool          err_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          ok_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          neg_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          overflow_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    static bool          hex_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) __attribute__((nothrow));
    // Convert field to numeric value. If the value is too large
    // for the target type, the result is undefined.
    // The special case of an empty string is evaluated to zero.
    static u32           ch_qGetnum(algo::RnullStr6_U32& parent, u32 &ok) __attribute__((nothrow));
    static void          SizeCheck();
} // end namespace algo
algo::cstring& algo::cstring::operator =(const algo::strptr &rhs) {
    algo::ch_Setary(*this, rhs);
    return *this;
}

algo::cstring::cstring(const algo::cstring &rhs) {
    cstring_Init(*this);
    algo::ch_Setary(*this, (algo::cstring&)rhs);
}


// --- algo.cstring.ch.Eq
bool algo::ch_Eq(const algo::cstring& error,const algo::cstring &rhs) {
    int len = ch_N(error);
    if (len != ch_N(rhs)) {
        return false;
    }
    for (int i = 0; i < len; i++) {
        if (!(error.ch_elems[i] == rhs.ch_elems[i])) {
            return false;
        }
    }
    return true;
}

// --- algo.cstring.ch.Cmp
int algo::ch_Cmp(algo::cstring& error, algo::cstring &rhs) {
    int len = i32_Min(ch_N(error), ch_N(rhs));
    int retval = 0;
    for (int i = 0; i < len; i++) {
        retval = char_Cmp(error.ch_elems[i], rhs.ch_elems[i]);
        if (retval != 0) {
            return retval;
        }
    }
    return i32_Cmp(ch_N(error), ch_N(rhs));
}

// --- algo.cstring.ch.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char> algo::ch_Addary(algo::cstring& error, algo::aryptr<char> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= error.ch_elems && rhs.elems < error.ch_elems + error.ch_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.cstring.ch  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ch_Reserve(error, nnew); // reserve space
    int at = error.ch_n;
    memcpy(error.ch_elems + at, rhs.elems, nnew * sizeof(char));
    error.ch_n += nnew;
    return algo::aryptr<char>(error.ch_elems + at, nnew);
}

// --- algo.cstring.ch.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char& algo::ch_Alloc(algo::cstring& error) {
    ch_Reserve(error, 1);
    int n  = error.ch_n;
    int at = n;
    char *elems = error.ch_elems;
    new (elems + at) char(0); // construct new element, default initializer
    error.ch_n = n+1;
    return elems[at];
}

// --- algo.cstring.ch.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char& algo::ch_AllocAt(algo::cstring& error, int at) {
    ch_Reserve(error, 1);
    int n  = error.ch_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.cstring.ch  comment:'index out of range'");
    }
    char *elems = error.ch_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(char));
    new (elems + at) char(0); // construct element, default initializer
    error.ch_n = n+1;
    return elems[at];
}

// --- algo.cstring.ch.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::ch_AllocN(algo::cstring& error, int n_elems) {
    ch_Reserve(error, n_elems);
    int old_n  = error.ch_n;
    int new_n = old_n + n_elems;
    char *elems = error.ch_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    error.ch_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.cstring.ch.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ch_Remove(algo::cstring& error, u32 i) {
    u32 lim = error.ch_n;
    char *elems = error.ch_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(char) * (lim - (i + 1)));
        error.ch_n = lim - 1;
    }
}

// --- algo.cstring.ch.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ch_RemoveLast(algo::cstring& error) {
    u64 n = error.ch_n;
    if (n > 0) {
        n -= 1;
        error.ch_n = n;
    }
}

// --- algo.cstring.ch.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ch_AbsReserve(algo::cstring& error, int n) {
    u32 old_max  = error.ch_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::lpool_ReallocMem(error.ch_elems, old_max * sizeof(char), new_max * sizeof(char));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.cstring.ch  comment:'out of memory'");
        }
        error.ch_elems = (char*)new_mem;
        error.ch_max = new_max;
    }
}

// --- algo.cstring.ch.Setary
// Copy contents of RHS to PARENT.
void algo::ch_Setary(algo::cstring& error, algo::cstring &rhs) {
    ch_RemoveAll(error);
    int nnew = rhs.ch_n;
    ch_Reserve(error, nnew); // reserve space
    memcpy(error.ch_elems, rhs.ch_elems, nnew * sizeof(char));
    error.ch_n = nnew;
}

// --- algo.cstring.ch.Setary2
// Copy specified array into ch, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ch_Setary(algo::cstring& error, const algo::aryptr<char> &rhs) {
    ch_RemoveAll(error);
    ch_Addary(error, rhs);
}

// --- algo.cstring..Uninit
void algo::cstring_Uninit(algo::cstring& error) {
    algo::cstring &row = error; (void)row;

    // algo.cstring.ch.Uninit (Tary)  //
    // remove all elements from algo.cstring.ch
    ch_RemoveAll(error);
    // free memory for Tary algo.cstring.ch
    algo_lib::lpool_FreeMem(error.ch_elems, sizeof(char)*error.ch_max); // (algo.cstring.ch)
}

// --- algo.ArgProto..ReadFieldMaybe
bool algo::ArgProto_ReadFieldMaybe(algo::ArgProto &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_name: retval = algo::cstring_ReadStrptrMaybe(parent.name, strval); break;
        case algo_FieldId_type: retval = algo::cstring_ReadStrptrMaybe(parent.type, strval); break;
        case algo_FieldId_value: retval = algo::cstring_ReadStrptrMaybe(parent.value, strval); break;
        case algo_FieldId_optional: retval = bool_ReadStrptrMaybe(parent.optional, strval); break;
        case algo_FieldId_anon: retval = bool_ReadStrptrMaybe(parent.anon, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.ArgProto..ReadStrptrMaybe
// Read fields of algo::ArgProto from an ascii string.
// The format of the string is an ssim Tuple
bool algo::ArgProto_ReadStrptrMaybe(algo::ArgProto &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "algo.ArgProto");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ArgProto_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- algo.ArgProto..Print
// print string representation of algo::ArgProto to string LHS, no header -- cprint:algo.ArgProto.String
void algo::ArgProto_Print(algo::ArgProto & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.ArgProto";

    algo::cstring_Print(row.name, temp);
    PrintAttrSpaceReset(str,"name", temp);

    algo::cstring_Print(row.type, temp);
    PrintAttrSpaceReset(str,"type", temp);

    algo::cstring_Print(row.value, temp);
    PrintAttrSpaceReset(str,"value", temp);

    bool_Print(row.optional, temp);
    PrintAttrSpaceReset(str,"optional", temp);

    bool_Print(row.anon, temp);
    PrintAttrSpaceReset(str,"anon", temp);
}

// --- algo.Tuple.attrs.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::Attr> algo::attrs_Addary(algo::Tuple& parent, algo::aryptr<algo::Attr> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.attrs_elems && rhs.elems < parent.attrs_elems + parent.attrs_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.Tuple.attrs  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    attrs_Reserve(parent, nnew); // reserve space
    int at = parent.attrs_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.attrs_elems + at + i) algo::Attr(rhs[i]);
        parent.attrs_n++;
    }
    return algo::aryptr<algo::Attr>(parent.attrs_elems + at, nnew);
}

// --- algo.Tuple.attrs.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::Attr& algo::attrs_Alloc(algo::Tuple& parent) {
    attrs_Reserve(parent, 1);
    int n  = parent.attrs_n;
    int at = n;
    algo::Attr *elems = parent.attrs_elems;
    new (elems + at) algo::Attr(); // construct new element, default initializer
    parent.attrs_n = n+1;
    return elems[at];
}

// --- algo.Tuple.attrs.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::Attr& algo::attrs_AllocAt(algo::Tuple& parent, int at) {
    attrs_Reserve(parent, 1);
    int n  = parent.attrs_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Tuple.attrs  comment:'index out of range'");
    }
    algo::Attr *elems = parent.attrs_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::Attr));
    new (elems + at) algo::Attr(); // construct element, default initializer
    parent.attrs_n = n+1;
    return elems[at];
}

// --- algo.Tuple.attrs.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::Attr> algo::attrs_AllocN(algo::Tuple& parent, int n_elems) {
    attrs_Reserve(parent, n_elems);
    int old_n  = parent.attrs_n;
    int new_n = old_n + n_elems;
    algo::Attr *elems = parent.attrs_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::Attr(); // construct new element, default initialize
    }
    parent.attrs_n = new_n;
    return algo::aryptr<algo::Attr>(elems + old_n, n_elems);
}

// --- algo.Tuple.attrs.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::attrs_Remove(algo::Tuple& parent, u32 i) {
    u32 lim = parent.attrs_n;
    algo::Attr *elems = parent.attrs_elems;
    if (i < lim) {
        elems[i].~Attr(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::Attr) * (lim - (i + 1)));
        parent.attrs_n = lim - 1;
    }
}

// --- algo.Tuple.attrs.RemoveAll
void algo::attrs_RemoveAll(algo::Tuple& parent) {
    u32 n = parent.attrs_n;
    while (n > 0) {
        n -= 1;
        parent.attrs_elems[n].~Attr();
        parent.attrs_n = n;
    }
}

// --- algo.Tuple.attrs.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::attrs_RemoveLast(algo::Tuple& parent) {
    u64 n = parent.attrs_n;
    if (n > 0) {
        n -= 1;
        attrs_qFind(parent, u64(n)).~Attr();
        parent.attrs_n = n;
    }
}

// --- algo.Tuple.attrs.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::attrs_AbsReserve(algo::Tuple& parent, int n) {
    u32 old_max  = parent.attrs_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.attrs_elems, old_max * sizeof(algo::Attr), new_max * sizeof(algo::Attr));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Tuple.attrs  comment:'out of memory'");
        }
        parent.attrs_elems = (algo::Attr*)new_mem;
        parent.attrs_max = new_max;
    }
}

// --- algo.Tuple.attrs.Setary
// Copy contents of RHS to PARENT.
void algo::attrs_Setary(algo::Tuple& parent, algo::Tuple &rhs) {
    attrs_RemoveAll(parent);
    int nnew = rhs.attrs_n;
    attrs_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.attrs_elems + i) algo::Attr(attrs_qFind(rhs, i));
        parent.attrs_n = i + 1;
    }
}

// --- algo.Tuple.attrs.Setary2
// Copy specified array into attrs, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::attrs_Setary(algo::Tuple& parent, const algo::aryptr<algo::Attr> &rhs) {
    attrs_RemoveAll(parent);
    attrs_Addary(parent, rhs);
}

// --- algo.Tuple..Uninit
void algo::Tuple_Uninit(algo::Tuple& parent) {
    algo::Tuple &row = parent; (void)row;

    // algo.Tuple.attrs.Uninit (Tary)  //
    // remove all elements from algo.Tuple.attrs
    attrs_RemoveAll(parent);
    // free memory for Tary algo.Tuple.attrs
    algo_lib::malloc_FreeMem(parent.attrs_elems, sizeof(algo::Attr)*parent.attrs_max); // (algo.Tuple.attrs)
}

// --- algo.Argtuple.proto.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::ArgProto& algo::proto_Alloc(algo::Argtuple& parent) {
    proto_Reserve(parent, 1);
    int n  = parent.proto_n;
    int at = n;
    algo::ArgProto *elems = parent.proto_elems;
    new (elems + at) algo::ArgProto(); // construct new element, default initializer
    parent.proto_n = n+1;
    return elems[at];
}

// --- algo.Argtuple.proto.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::ArgProto& algo::proto_AllocAt(algo::Argtuple& parent, int at) {
    proto_Reserve(parent, 1);
    int n  = parent.proto_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Argtuple.proto  comment:'index out of range'");
    }
    algo::ArgProto *elems = parent.proto_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::ArgProto));
    new (elems + at) algo::ArgProto(); // construct element, default initializer
    parent.proto_n = n+1;
    return elems[at];
}

// --- algo.Argtuple.proto.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::ArgProto> algo::proto_AllocN(algo::Argtuple& parent, int n_elems) {
    proto_Reserve(parent, n_elems);
    int old_n  = parent.proto_n;
    int new_n = old_n + n_elems;
    algo::ArgProto *elems = parent.proto_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::ArgProto(); // construct new element, default initialize
    }
    parent.proto_n = new_n;
    return algo::aryptr<algo::ArgProto>(elems + old_n, n_elems);
}

// --- algo.Argtuple.proto.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::proto_Remove(algo::Argtuple& parent, u32 i) {
    u32 lim = parent.proto_n;
    algo::ArgProto *elems = parent.proto_elems;
    if (i < lim) {
        elems[i].~ArgProto(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::ArgProto) * (lim - (i + 1)));
        parent.proto_n = lim - 1;
    }
}

// --- algo.Argtuple.proto.RemoveAll
void algo::proto_RemoveAll(algo::Argtuple& parent) {
    u32 n = parent.proto_n;
    while (n > 0) {
        n -= 1;
        parent.proto_elems[n].~ArgProto();
        parent.proto_n = n;
    }
}

// --- algo.Argtuple.proto.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::proto_RemoveLast(algo::Argtuple& parent) {
    u64 n = parent.proto_n;
    if (n > 0) {
        n -= 1;
        proto_qFind(parent, u64(n)).~ArgProto();
        parent.proto_n = n;
    }
}

// --- algo.Argtuple.proto.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::proto_AbsReserve(algo::Argtuple& parent, int n) {
    u32 old_max  = parent.proto_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.proto_elems, old_max * sizeof(algo::ArgProto), new_max * sizeof(algo::ArgProto));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Argtuple.proto  comment:'out of memory'");
        }
        parent.proto_elems = (algo::ArgProto*)new_mem;
        parent.proto_max = new_max;
    }
}

// --- algo.Argtuple.proto.Setary
// Copy contents of RHS to PARENT.
void algo::proto_Setary(algo::Argtuple& parent, algo::Argtuple &rhs) {
    proto_RemoveAll(parent);
    int nnew = rhs.proto_n;
    proto_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.proto_elems + i) algo::ArgProto(proto_qFind(rhs, i));
        parent.proto_n = i + 1;
    }
}

// --- algo.Argtuple.error.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& algo::error_Alloc(algo::Argtuple& parent) {
    error_Reserve(parent, 1);
    int n  = parent.error_n;
    int at = n;
    algo::cstring *elems = parent.error_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.error_n = n+1;
    return elems[at];
}

// --- algo.Argtuple.error.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& algo::error_AllocAt(algo::Argtuple& parent, int at) {
    error_Reserve(parent, 1);
    int n  = parent.error_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Argtuple.error  comment:'index out of range'");
    }
    algo::cstring *elems = parent.error_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.error_n = n+1;
    return elems[at];
}

// --- algo.Argtuple.error.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> algo::error_AllocN(algo::Argtuple& parent, int n_elems) {
    error_Reserve(parent, n_elems);
    int old_n  = parent.error_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.error_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.error_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- algo.Argtuple.error.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::error_Remove(algo::Argtuple& parent, u32 i) {
    u32 lim = parent.error_n;
    algo::cstring *elems = parent.error_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.error_n = lim - 1;
    }
}

// --- algo.Argtuple.error.RemoveAll
void algo::error_RemoveAll(algo::Argtuple& parent) {
    u32 n = parent.error_n;
    while (n > 0) {
        n -= 1;
        parent.error_elems[n].~cstring();
        parent.error_n = n;
    }
}

// --- algo.Argtuple.error.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::error_RemoveLast(algo::Argtuple& parent) {
    u64 n = parent.error_n;
    if (n > 0) {
        n -= 1;
        error_qFind(parent, u64(n)).~cstring();
        parent.error_n = n;
    }
}

// --- algo.Argtuple.error.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::error_AbsReserve(algo::Argtuple& parent, int n) {
    u32 old_max  = parent.error_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.error_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Argtuple.error  comment:'out of memory'");
        }
        parent.error_elems = (algo::cstring*)new_mem;
        parent.error_max = new_max;
    }
}

// --- algo.Argtuple.error.Setary
// Copy contents of RHS to PARENT.
void algo::error_Setary(algo::Argtuple& parent, algo::Argtuple &rhs) {
    error_RemoveAll(parent);
    int nnew = rhs.error_n;
    error_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.error_elems + i) algo::cstring(error_qFind(rhs, i));
        parent.error_n = i + 1;
    }
}

// --- algo.Argtuple..Init
// Set all fields to initial values.
void algo::Argtuple_Init(algo::Argtuple& parent) {
    parent.anon_idx = i32(0);
    parent.vararg = bool(false);
    parent.showsigs = bool(false);
    parent.endopt = bool(false);
    parent.proto_elems 	= 0; // (algo.Argtuple.proto)
    parent.proto_n     	= 0; // (algo.Argtuple.proto)
    parent.proto_max   	= 0; // (algo.Argtuple.proto)
    parent.error_elems 	= 0; // (algo.Argtuple.error)
    parent.error_n     	= 0; // (algo.Argtuple.error)
    parent.error_max   	= 0; // (algo.Argtuple.error)
    parent.doexit = bool(false);
    parent.exitcode = i32(0);
    parent.help = bool(false);
    parent.version = bool(false);
    parent.console = bool(false);
}

// --- algo.Argtuple..Uninit
void algo::Argtuple_Uninit(algo::Argtuple& parent) {
    algo::Argtuple &row = parent; (void)row;

    // algo.Argtuple.error.Uninit (Tary)  //Errors collected during parsing
    // remove all elements from algo.Argtuple.error
    error_RemoveAll(parent);
    // free memory for Tary algo.Argtuple.error
    algo_lib::malloc_FreeMem(parent.error_elems, sizeof(algo::cstring)*parent.error_max); // (algo.Argtuple.error)

    // algo.Argtuple.proto.Uninit (Tary)  //
    // remove all elements from algo.Argtuple.proto
    proto_RemoveAll(parent);
    // free memory for Tary algo.Argtuple.proto
    algo_lib::malloc_FreeMem(parent.proto_elems, sizeof(algo::ArgProto)*parent.proto_max); // (algo.Argtuple.proto)
}

// --- algo.Argtuple..Print
// print string representation of algo::Argtuple to string LHS, no header -- cprint:algo.Argtuple.String
void algo::Argtuple_Print(algo::Argtuple & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.Argtuple";

    i32_Print(row.anon_idx, temp);
    PrintAttrSpaceReset(str,"anon_idx", temp);

    bool_Print(row.vararg, temp);
    PrintAttrSpaceReset(str,"vararg", temp);

    bool_Print(row.showsigs, temp);
    PrintAttrSpaceReset(str,"showsigs", temp);

    bool_Print(row.endopt, temp);
    PrintAttrSpaceReset(str,"endopt", temp);

    algo::Tuple_Print(row.tuple, temp);
    PrintAttrSpaceReset(str,"tuple", temp);

    algo::cstring_Print(row.output, temp);
    PrintAttrSpaceReset(str,"output", temp);

    bool_Print(row.doexit, temp);
    PrintAttrSpaceReset(str,"doexit", temp);

    i32_Print(row.exitcode, temp);
    PrintAttrSpaceReset(str,"exitcode", temp);

    bool_Print(row.help, temp);
    PrintAttrSpaceReset(str,"help", temp);

    bool_Print(row.version, temp);
    PrintAttrSpaceReset(str,"version", temp);

    bool_Print(row.console, temp);
    PrintAttrSpaceReset(str,"console", temp);
}

// --- algo.Arrsimp.out.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& algo::out_Alloc(algo::Arrsimp& parent) {
    out_Reserve(parent, 1);
    int n  = parent.out_n;
    int at = n;
    i32 *elems = parent.out_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    parent.out_n = n+1;
    return elems[at];
}

// --- algo.Arrsimp.out.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& algo::out_AllocAt(algo::Arrsimp& parent, int at) {
    out_Reserve(parent, 1);
    int n  = parent.out_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Arrsimp.out  comment:'index out of range'");
    }
    i32 *elems = parent.out_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    parent.out_n = n+1;
    return elems[at];
}

// --- algo.Arrsimp.out.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> algo::out_AllocN(algo::Arrsimp& parent, int n_elems) {
    out_Reserve(parent, n_elems);
    int old_n  = parent.out_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.out_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    parent.out_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- algo.Arrsimp.out.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::out_Remove(algo::Arrsimp& parent, u32 i) {
    u32 lim = parent.out_n;
    i32 *elems = parent.out_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        parent.out_n = lim - 1;
    }
}

// --- algo.Arrsimp.out.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::out_RemoveLast(algo::Arrsimp& parent) {
    u64 n = parent.out_n;
    if (n > 0) {
        n -= 1;
        parent.out_n = n;
    }
}

// --- algo.Arrsimp.out.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::out_AbsReserve(algo::Arrsimp& parent, int n) {
    u32 old_max  = parent.out_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.out_elems, old_max * sizeof(i32), new_max * sizeof(i32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Arrsimp.out  comment:'out of memory'");
        }
        parent.out_elems = (i32*)new_mem;
        parent.out_max = new_max;
    }
}

// --- algo.Arrsimp.out.Setary
// Copy contents of RHS to PARENT.
void algo::out_Setary(algo::Arrsimp& parent, algo::Arrsimp &rhs) {
    out_RemoveAll(parent);
    int nnew = rhs.out_n;
    out_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.out_elems + i) i32(out_qFind(rhs, i));
        parent.out_n = i + 1;
    }
}

// --- algo.Arrsimp.stack.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::i32_Range& algo::stack_Alloc(algo::Arrsimp& parent) {
    stack_Reserve(parent, 1);
    int n  = parent.stack_n;
    int at = n;
    algo::i32_Range *elems = parent.stack_elems;
    new (elems + at) algo::i32_Range(); // construct new element, default initializer
    parent.stack_n = n+1;
    return elems[at];
}

// --- algo.Arrsimp.stack.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::i32_Range& algo::stack_AllocAt(algo::Arrsimp& parent, int at) {
    stack_Reserve(parent, 1);
    int n  = parent.stack_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.Arrsimp.stack  comment:'index out of range'");
    }
    algo::i32_Range *elems = parent.stack_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::i32_Range));
    new (elems + at) algo::i32_Range(); // construct element, default initializer
    parent.stack_n = n+1;
    return elems[at];
}

// --- algo.Arrsimp.stack.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::i32_Range> algo::stack_AllocN(algo::Arrsimp& parent, int n_elems) {
    stack_Reserve(parent, n_elems);
    int old_n  = parent.stack_n;
    int new_n = old_n + n_elems;
    algo::i32_Range *elems = parent.stack_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::i32_Range(); // construct new element, default initialize
    }
    parent.stack_n = new_n;
    return algo::aryptr<algo::i32_Range>(elems + old_n, n_elems);
}

// --- algo.Arrsimp.stack.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::stack_Remove(algo::Arrsimp& parent, u32 i) {
    u32 lim = parent.stack_n;
    algo::i32_Range *elems = parent.stack_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(algo::i32_Range) * (lim - (i + 1)));
        parent.stack_n = lim - 1;
    }
}

// --- algo.Arrsimp.stack.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::stack_RemoveLast(algo::Arrsimp& parent) {
    u64 n = parent.stack_n;
    if (n > 0) {
        n -= 1;
        parent.stack_n = n;
    }
}

// --- algo.Arrsimp.stack.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::stack_AbsReserve(algo::Arrsimp& parent, int n) {
    u32 old_max  = parent.stack_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.stack_elems, old_max * sizeof(algo::i32_Range), new_max * sizeof(algo::i32_Range));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.Arrsimp.stack  comment:'out of memory'");
        }
        parent.stack_elems = (algo::i32_Range*)new_mem;
        parent.stack_max = new_max;
    }
}

// --- algo.Arrsimp.stack.Setary
// Copy contents of RHS to PARENT.
void algo::stack_Setary(algo::Arrsimp& parent, algo::Arrsimp &rhs) {
    stack_RemoveAll(parent);
    int nnew = rhs.stack_n;
    stack_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.stack_elems + i) algo::i32_Range(stack_qFind(rhs, i));
        parent.stack_n = i + 1;
    }
}

// --- algo.Arrsimp..Uninit
void algo::Arrsimp_Uninit(algo::Arrsimp& parent) {
    algo::Arrsimp &row = parent; (void)row;

    // algo.Arrsimp.stack.Uninit (Tary)  //
    // remove all elements from algo.Arrsimp.stack
    stack_RemoveAll(parent);
    // free memory for Tary algo.Arrsimp.stack
    algo_lib::malloc_FreeMem(parent.stack_elems, sizeof(algo::i32_Range)*parent.stack_max); // (algo.Arrsimp.stack)

    // algo.Arrsimp.out.Uninit (Tary)  //
    // remove all elements from algo.Arrsimp.out
    out_RemoveAll(parent);
    // free memory for Tary algo.Arrsimp.out
    algo_lib::malloc_FreeMem(parent.out_elems, sizeof(i32)*parent.out_max); // (algo.Arrsimp.out)
}

// --- algo.Bool.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Bool& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Bool_N                   : ret = "N";  break;
        case algo_Bool_Y                   : ret = "Y";  break;
    }
    return ret;
}

// --- algo.Bool.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Bool& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Bool.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Bool& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case '0': {
                    value_SetEnum(parent,algo_Bool_0); ret = true; break;
                }
                case '1': {
                    value_SetEnum(parent,algo_Bool_1); ret = true; break;
                }
                case 'N': {
                    value_SetEnum(parent,algo_Bool_N); ret = true; break;
                }
                case 'Y': {
                    value_SetEnum(parent,algo_Bool_Y); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('n','o'): {
                    value_SetEnum(parent,algo_Bool_no); ret = true; break;
                }
                case LE_STR2('o','n'): {
                    value_SetEnum(parent,algo_Bool_on); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('o','f','f'): {
                    value_SetEnum(parent,algo_Bool_off); ret = true; break;
                }
                case LE_STR3('y','e','s'): {
                    value_SetEnum(parent,algo_Bool_yes); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_Bool_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_Bool_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Bool.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Bool& parent, algo::strptr rhs, algo_BoolEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.ByteAry.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u8> algo::ary_Addary(algo::ByteAry& parent, algo::aryptr<u8> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.ByteAry.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    memcpy(parent.ary_elems + at, rhs.elems, nnew * sizeof(u8));
    parent.ary_n += nnew;
    return algo::aryptr<u8>(parent.ary_elems + at, nnew);
}

// --- algo.ByteAry.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8& algo::ary_Alloc(algo::ByteAry& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u8 *elems = parent.ary_elems;
    new (elems + at) u8(0); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.ByteAry.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8& algo::ary_AllocAt(algo::ByteAry& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.ByteAry.ary  comment:'index out of range'");
    }
    u8 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u8));
    new (elems + at) u8(0); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.ByteAry.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8> algo::ary_AllocN(algo::ByteAry& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u8 *elems = parent.ary_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.ary_n = new_n;
    return algo::aryptr<u8>(elems + old_n, n_elems);
}

// --- algo.ByteAry.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ary_Remove(algo::ByteAry& parent, u32 i) {
    u32 lim = parent.ary_n;
    u8 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u8) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo.ByteAry.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ary_RemoveLast(algo::ByteAry& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- algo.ByteAry.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ary_AbsReserve(algo::ByteAry& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(u8), new_max * sizeof(u8));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.ByteAry.ary  comment:'out of memory'");
        }
        parent.ary_elems = (u8*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- algo.ByteAry.ary.Setary
// Copy contents of RHS to PARENT.
void algo::ary_Setary(algo::ByteAry& parent, algo::ByteAry &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    memcpy(parent.ary_elems, rhs.ary_elems, nnew * sizeof(u8));
    parent.ary_n = nnew;
}

// --- algo.ByteAry.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ary_Setary(algo::ByteAry& parent, const algo::aryptr<u8> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- algo.ByteAry..Uninit
void algo::ByteAry_Uninit(algo::ByteAry& parent) {
    algo::ByteAry &row = parent; (void)row;

    // algo.ByteAry.ary.Uninit (Tary)  //
    // remove all elements from algo.ByteAry.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo.ByteAry.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(u8)*parent.ary_max); // (algo.ByteAry.ary)
}

// --- algo.Charset.ch.Print
// Convert ch to a string. Parent's separator is used.
void algo::ch_Print(algo::Charset& parent, algo::cstring &lhs) {
    int len = 8;
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            lhs << ',';
        }
        u64_Print(parent.ch_elems[i], lhs);
    }
}

// --- algo.Charset.ch.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Charset& parent, algo::strptr in_str) {
    bool retval = true;
    for (int i=0; in_str != "" && i < ch_Max(parent); i++) {
        algo::strptr token;
        algo::NextSep(in_str, ',', token);
        retval = u64_ReadStrptrMaybe(parent.ch_elems[i], token);
        if (!retval) {
            break;
        }
    }
    return retval;
}

// --- algo.Smallstr150.ch.Print
void algo::ch_Print(algo::Smallstr150& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr150.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr150& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 150) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 150");
    }
    return retval;
}

// --- algo.Smallstr150.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr150& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 150);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr150..Hash
u32 algo::Smallstr150_Hash(u32 prev, const algo::Smallstr150 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr150..ReadStrptrMaybe
// Read fields of algo::Smallstr150 from an ascii string.
// The format of the string is the format of the algo::Smallstr150's only field
bool algo::Smallstr150_ReadStrptrMaybe(algo::Smallstr150 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr150..Print
// print string representation of algo::Smallstr150 to string LHS, no header -- cprint:algo.Smallstr150.String
void algo::Smallstr150_Print(algo::Smallstr150 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Comment..ReadStrptrMaybe
// Read fields of algo::Comment from an ascii string.
// The format of the string is the format of the algo::Comment's only field
bool algo::Comment_ReadStrptrMaybe(algo::Comment &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::Smallstr150_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.Comment..Print
// print string representation of algo::Comment to string LHS, no header -- cprint:algo.Comment.String
void algo::Comment_Print(algo::Comment & row, algo::cstring &str) {
    algo::Smallstr150_Print(row.value, str);
}

// --- algo.Dbbox..ReadFieldMaybe
bool algo::Dbbox_ReadFieldMaybe(algo::Dbbox &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_min: retval = double_ReadStrptrMaybe(parent.min, strval); break;
        case algo_FieldId_max: retval = double_ReadStrptrMaybe(parent.max, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.Dbbox..ReadStrptrMaybe
// Read fields of algo::Dbbox from an ascii string.
// The format of the string is an ssim Tuple
bool algo::Dbbox_ReadStrptrMaybe(algo::Dbbox &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "algo.Dbbox");
    int anon_idx = 0;
    ind_beg(algo::Attr_curs, attr, in_str) {
        if (ch_N(attr.name) == 0) {
            attr.name = Dbbox_GetAnon(parent, anon_idx++);
        }
        retval = retval && Dbbox_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- algo.Dbbox..Print
// print string representation of algo::Dbbox to string LHS, no header -- cprint:algo.Dbbox.String
void algo::Dbbox_Print(algo::Dbbox & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.Dbbox";

    double_Print(row.min, temp);
    PrintAttrSpaceReset(str,"", temp);

    double_Print(row.max, temp);
    PrintAttrSpaceReset(str,"", temp);
}

// --- algo.Dbbox..GetAnon
algo::strptr algo::Dbbox_GetAnon(algo::Dbbox &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("min", 3);
        case(1): return strptr("max", 3);
        default: return algo::strptr();
    }
}

// --- algo.DirEntry..Init
// Set all fields to initial values.
void algo::DirEntry_Init(algo::DirEntry& parent) {
    parent.mode = u64(0);
    parent.size = u64(0);
    parent.eof = bool(false);
    parent.match = bool(false);
    parent.is_dir = bool(false);
    parent.dir_handle = NULL;
}

// --- algo.DirEntry..Uninit
void algo::DirEntry_Uninit(algo::DirEntry& parent) {
    algo::DirEntry &row = parent; (void)row;
    dir_handle_Cleanup(parent); // dmmeta.fcleanup:algo.DirEntry.dir_handle
}

// --- algo.DryrunQ..Print
// print string representation of algo::DryrunQ to string LHS, no header -- cprint:algo.DryrunQ.String
void algo::DryrunQ_Print(algo::DryrunQ row, algo::cstring &str) {
    bool_Print(row.value, str);
}

// --- algo.EchoQ.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::EchoQ& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_EchoQ_true               : ret = "true";  break;
        case algo_EchoQ_false              : ret = "false";  break;
    }
    return ret;
}

// --- algo.EchoQ.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::EchoQ& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.EchoQ.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::EchoQ& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_EchoQ_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_EchoQ_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.EchoQ.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::EchoQ& parent, algo::strptr rhs, algo_EchoQEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.EchoQ..Print
// print string representation of algo::EchoQ to string LHS, no header -- cprint:algo.EchoQ.String
void algo::EchoQ_Print(algo::EchoQ row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.Errns.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Errns& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Errns_unix               : ret = "unix";  break;
        case algo_Errns_win                : ret = "win";  break;
    }
    return ret;
}

// --- algo.Errns.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Errns& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Errns.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Errns& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('w','i','n'): {
                    value_SetEnum(parent,algo_Errns_win); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('u','n','i','x'): {
                    value_SetEnum(parent,algo_Errns_unix); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Errns.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Errns& parent, algo::strptr rhs, algo_ErrnsEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FailokQ.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::FailokQ& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_FailokQ_true             : ret = "true";  break;
        case algo_FailokQ_false            : ret = "false";  break;
    }
    return ret;
}

// --- algo.FailokQ.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::FailokQ& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.FailokQ.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::FailokQ& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('t','r','u','e'): {
                    value_SetEnum(parent,algo_FailokQ_true); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','a','l','s','e'): {
                    value_SetEnum(parent,algo_FailokQ_false); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.FailokQ.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::FailokQ& parent, algo::strptr rhs, algo_FailokQEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FailokQ..Print
// print string representation of algo::FailokQ to string LHS, no header -- cprint:algo.FailokQ.String
void algo::FailokQ_Print(algo::FailokQ row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_FieldId_name             : ret = "name";  break;
        case algo_FieldId_type             : ret = "type";  break;
        case algo_FieldId_value            : ret = "value";  break;
        case algo_FieldId_optional         : ret = "optional";  break;
        case algo_FieldId_anon             : ret = "anon";  break;
        case algo_FieldId_ch               : ret = "ch";  break;
        case algo_FieldId_min              : ret = "min";  break;
        case algo_FieldId_max              : ret = "max";  break;
        case algo_FieldId_append           : ret = "append";  break;
        case algo_FieldId_read             : ret = "read";  break;
        case algo_FieldId_write            : ret = "write";  break;
        case algo_FieldId__throw           : ret = "_throw";  break;
        case algo_FieldId_temp             : ret = "temp";  break;
        case algo_FieldId_overlap          : ret = "overlap";  break;
        case algo_FieldId_linear           : ret = "linear";  break;
        case algo_FieldId_printerr         : ret = "printerr";  break;
        case algo_FieldId_eof              : ret = "eof";  break;
        case algo_FieldId_err              : ret = "err";  break;
        case algo_FieldId_x                : ret = "x";  break;
        case algo_FieldId_y                : ret = "y";  break;
        case algo_FieldId_ip_host          : ret = "ip_host";  break;
        case algo_FieldId_mask             : ret = "mask";  break;
        case algo_FieldId_ok               : ret = "ok";  break;
        case algo_FieldId_neg              : ret = "neg";  break;
        case algo_FieldId_overflow         : ret = "overflow";  break;
        case algo_FieldId_hex              : ret = "hex";  break;
        case algo_FieldId_sha1sig          : ret = "sha1sig";  break;
        case algo_FieldId_attrs            : ret = "attrs";  break;
        case algo_FieldId_head             : ret = "head";  break;
        case algo_FieldId_protocol         : ret = "protocol";  break;
        case algo_FieldId_username         : ret = "username";  break;
        case algo_FieldId_password         : ret = "password";  break;
        case algo_FieldId_server           : ret = "server";  break;
        case algo_FieldId_dir              : ret = "dir";  break;
        case algo_FieldId_port             : ret = "port";  break;
        case algo_FieldId_source_addr_host : ret = "source_addr_host";  break;
        case algo_FieldId_host             : ret = "host";  break;
    }
    return ret;
}

// --- algo.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'x': {
                    value_SetEnum(parent,algo_FieldId_x); ret = true; break;
                }
                case 'y': {
                    value_SetEnum(parent,algo_FieldId_y); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('c','h'): {
                    value_SetEnum(parent,algo_FieldId_ch); ret = true; break;
                }
                case LE_STR2('o','k'): {
                    value_SetEnum(parent,algo_FieldId_ok); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('d','i','r'): {
                    value_SetEnum(parent,algo_FieldId_dir); ret = true; break;
                }
                case LE_STR3('e','o','f'): {
                    value_SetEnum(parent,algo_FieldId_eof); ret = true; break;
                }
                case LE_STR3('e','r','r'): {
                    value_SetEnum(parent,algo_FieldId_err); ret = true; break;
                }
                case LE_STR3('h','e','x'): {
                    value_SetEnum(parent,algo_FieldId_hex); ret = true; break;
                }
                case LE_STR3('m','a','x'): {
                    value_SetEnum(parent,algo_FieldId_max); ret = true; break;
                }
                case LE_STR3('m','i','n'): {
                    value_SetEnum(parent,algo_FieldId_min); ret = true; break;
                }
                case LE_STR3('n','e','g'): {
                    value_SetEnum(parent,algo_FieldId_neg); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','n','o','n'): {
                    value_SetEnum(parent,algo_FieldId_anon); ret = true; break;
                }
                case LE_STR4('h','e','a','d'): {
                    value_SetEnum(parent,algo_FieldId_head); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,algo_FieldId_host); ret = true; break;
                }
                case LE_STR4('m','a','s','k'): {
                    value_SetEnum(parent,algo_FieldId_mask); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,algo_FieldId_name); ret = true; break;
                }
                case LE_STR4('p','o','r','t'): {
                    value_SetEnum(parent,algo_FieldId_port); ret = true; break;
                }
                case LE_STR4('r','e','a','d'): {
                    value_SetEnum(parent,algo_FieldId_read); ret = true; break;
                }
                case LE_STR4('t','e','m','p'): {
                    value_SetEnum(parent,algo_FieldId_temp); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,algo_FieldId_type); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','t','t','r','s'): {
                    value_SetEnum(parent,algo_FieldId_attrs); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,algo_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,algo_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('_','t','h','r','o','w'): {
                    value_SetEnum(parent,algo_FieldId__throw); ret = true; break;
                }
                case LE_STR6('a','p','p','e','n','d'): {
                    value_SetEnum(parent,algo_FieldId_append); ret = true; break;
                }
                case LE_STR6('l','i','n','e','a','r'): {
                    value_SetEnum(parent,algo_FieldId_linear); ret = true; break;
                }
                case LE_STR6('s','e','r','v','e','r'): {
                    value_SetEnum(parent,algo_FieldId_server); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('i','p','_','h','o','s','t'): {
                    value_SetEnum(parent,algo_FieldId_ip_host); ret = true; break;
                }
                case LE_STR7('o','v','e','r','l','a','p'): {
                    value_SetEnum(parent,algo_FieldId_overlap); ret = true; break;
                }
                case LE_STR7('s','h','a','1','s','i','g'): {
                    value_SetEnum(parent,algo_FieldId_sha1sig); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('o','p','t','i','o','n','a','l'): {
                    value_SetEnum(parent,algo_FieldId_optional); ret = true; break;
                }
                case LE_STR8('o','v','e','r','f','l','o','w'): {
                    value_SetEnum(parent,algo_FieldId_overflow); ret = true; break;
                }
                case LE_STR8('p','a','s','s','w','o','r','d'): {
                    value_SetEnum(parent,algo_FieldId_password); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','e','r','r'): {
                    value_SetEnum(parent,algo_FieldId_printerr); ret = true; break;
                }
                case LE_STR8('p','r','o','t','o','c','o','l'): {
                    value_SetEnum(parent,algo_FieldId_protocol); ret = true; break;
                }
                case LE_STR8('u','s','e','r','n','a','m','e'): {
                    value_SetEnum(parent,algo_FieldId_username); ret = true; break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','o','u','r','c','e','_','a'): {
                    if (memcmp(rhs.elems+8,"ddr_host",8)==0) { value_SetEnum(parent,algo_FieldId_source_addr_host); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::FieldId& parent, algo::strptr rhs, algo_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.FieldId..ReadStrptrMaybe
// Read fields of algo::FieldId from an ascii string.
// The format of the string is the format of the algo::FieldId's only field
bool algo::FieldId_ReadStrptrMaybe(algo::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.FieldId..Print
// print string representation of algo::FieldId to string LHS, no header -- cprint:algo.FieldId.String
void algo::FieldId_Print(algo::FieldId & row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.FileFlags.append.ReadStrptrMaybe
inline static bool algo::append_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool append_tmp;
    retval = bool_ReadStrptrMaybe(append_tmp, in_str);
    if (retval) {
        append_Set(parent, append_tmp);
    }
    return retval;
}

// --- algo.FileFlags.read.ReadStrptrMaybe
inline static bool algo::read_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- algo.FileFlags.write.ReadStrptrMaybe
inline static bool algo::write_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- algo.FileFlags._throw.ReadStrptrMaybe
inline static bool algo::_throw_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool _throw_tmp;
    retval = bool_ReadStrptrMaybe(_throw_tmp, in_str);
    if (retval) {
        _throw_Set(parent, _throw_tmp);
    }
    return retval;
}

// --- algo.FileFlags.temp.ReadStrptrMaybe
inline static bool algo::temp_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool temp_tmp;
    retval = bool_ReadStrptrMaybe(temp_tmp, in_str);
    if (retval) {
        temp_Set(parent, temp_tmp);
    }
    return retval;
}

// --- algo.FileFlags.overlap.ReadStrptrMaybe
inline static bool algo::overlap_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool overlap_tmp;
    retval = bool_ReadStrptrMaybe(overlap_tmp, in_str);
    if (retval) {
        overlap_Set(parent, overlap_tmp);
    }
    return retval;
}

// --- algo.FileFlags.linear.ReadStrptrMaybe
inline static bool algo::linear_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool linear_tmp;
    retval = bool_ReadStrptrMaybe(linear_tmp, in_str);
    if (retval) {
        linear_Set(parent, linear_tmp);
    }
    return retval;
}

// --- algo.FileFlags.printerr.ReadStrptrMaybe
inline static bool algo::printerr_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool printerr_tmp;
    retval = bool_ReadStrptrMaybe(printerr_tmp, in_str);
    if (retval) {
        printerr_Set(parent, printerr_tmp);
    }
    return retval;
}

// --- algo.FileFlags..ReadFieldMaybe
bool algo::FileFlags_ReadFieldMaybe(algo::FileFlags &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_value: retval = u32_ReadStrptrMaybe(parent.value, strval); break;
        case algo_FieldId_append: retval = append_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_read: retval = read_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_write: retval = write_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId__throw: retval = _throw_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_temp: retval = temp_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_overlap: retval = overlap_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_linear: retval = linear_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_printerr: retval = printerr_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.FileFlags..ReadStrptrMaybe
// Read fields of algo::FileFlags from an ascii string.
bool algo::FileFlags_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str) {
    bool retval = true;
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_append: append_Set(parent,true); break;
                    case algo_FieldId_read: read_Set(parent,true); break;
                    case algo_FieldId_write: write_Set(parent,true); break;
                    case algo_FieldId__throw: _throw_Set(parent,true); break;
                    case algo_FieldId_temp: temp_Set(parent,true); break;
                    case algo_FieldId_overlap: overlap_Set(parent,true); break;
                    case algo_FieldId_linear: linear_Set(parent,true); break;
                    case algo_FieldId_printerr: printerr_Set(parent,true); break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.FileFlags..Print
// print string representation of algo::FileFlags to string LHS, no header -- cprint:algo.FileFlags.String
void algo::FileFlags_Print(algo::FileFlags & row, algo::cstring &str) {
    algo::ListSep ls(",");
    if (append_Get(row)) {
        str << ls << "append";
    }
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (_throw_Get(row)) {
        str << ls << "_throw";
    }
    if (temp_Get(row)) {
        str << ls << "temp";
    }
    if (overlap_Get(row)) {
        str << ls << "overlap";
    }
    if (linear_Get(row)) {
        str << ls << "linear";
    }
    if (printerr_Get(row)) {
        str << ls << "printerr";
    }
}

// --- algo.FileFlags..GetAnon
algo::strptr algo::FileFlags_GetAnon(algo::FileFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.I32Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec1& parent, double val) {
    double intval = val * 10;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec1.value.Print
void algo::value_Print(algo::I32Dec1& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.I32Dec1..ReadStrptrMaybe
// Read fields of algo::I32Dec1 from an ascii string.
// The format of the string is the format of the algo::I32Dec1's only field
bool algo::I32Dec1_ReadStrptrMaybe(algo::I32Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec1..Print
// print string representation of algo::I32Dec1 to string LHS, no header -- cprint:algo.I32Dec1.String
void algo::I32Dec1_Print(algo::I32Dec1 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec2& parent, double val) {
    double intval = val * 100;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec2.value.Print
void algo::value_Print(algo::I32Dec2& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.I32Dec2..ReadStrptrMaybe
// Read fields of algo::I32Dec2 from an ascii string.
// The format of the string is the format of the algo::I32Dec2's only field
bool algo::I32Dec2_ReadStrptrMaybe(algo::I32Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec2..Print
// print string representation of algo::I32Dec2 to string LHS, no header -- cprint:algo.I32Dec2.String
void algo::I32Dec2_Print(algo::I32Dec2 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec3& parent, double val) {
    double intval = val * 1000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec3.value.Print
void algo::value_Print(algo::I32Dec3& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.I32Dec3..ReadStrptrMaybe
// Read fields of algo::I32Dec3 from an ascii string.
// The format of the string is the format of the algo::I32Dec3's only field
bool algo::I32Dec3_ReadStrptrMaybe(algo::I32Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec3..Print
// print string representation of algo::I32Dec3 to string LHS, no header -- cprint:algo.I32Dec3.String
void algo::I32Dec3_Print(algo::I32Dec3 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec4& parent, double val) {
    double intval = val * 10000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec4.value.Print
void algo::value_Print(algo::I32Dec4& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.I32Dec4..ReadStrptrMaybe
// Read fields of algo::I32Dec4 from an ascii string.
// The format of the string is the format of the algo::I32Dec4's only field
bool algo::I32Dec4_ReadStrptrMaybe(algo::I32Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec4..Print
// print string representation of algo::I32Dec4 to string LHS, no header -- cprint:algo.I32Dec4.String
void algo::I32Dec4_Print(algo::I32Dec4 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I32Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I32Dec5& parent, double val) {
    double intval = val * 100000;
    i32 minval = i32(-2147483648LL);
    i32 maxval = i32(2147483647LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I32Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I32Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 2147483647LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -2147483648LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I32Dec5.value.Print
void algo::value_Print(algo::I32Dec5& parent, cstring &outstr) {
    i32 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.I32Dec5..ReadStrptrMaybe
// Read fields of algo::I32Dec5 from an ascii string.
// The format of the string is the format of the algo::I32Dec5's only field
bool algo::I32Dec5_ReadStrptrMaybe(algo::I32Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I32Dec5..Print
// print string representation of algo::I32Dec5 to string LHS, no header -- cprint:algo.I32Dec5.String
void algo::I32Dec5_Print(algo::I32Dec5 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec1& parent, double val) {
    double intval = val * 10;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec1.value.Print
void algo::value_Print(algo::I64Dec1& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.I64Dec1..ReadStrptrMaybe
// Read fields of algo::I64Dec1 from an ascii string.
// The format of the string is the format of the algo::I64Dec1's only field
bool algo::I64Dec1_ReadStrptrMaybe(algo::I64Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec1..Print
// print string representation of algo::I64Dec1 to string LHS, no header -- cprint:algo.I64Dec1.String
void algo::I64Dec1_Print(algo::I64Dec1 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec10.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec10& parent, double val) {
    double intval = val * 10000000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec10.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec10& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 10) { // ignore digits after 10'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 10) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec10.value.Print
void algo::value_Print(algo::I64Dec10& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 10, value_start, true);
}

// --- algo.I64Dec10..ReadStrptrMaybe
// Read fields of algo::I64Dec10 from an ascii string.
// The format of the string is the format of the algo::I64Dec10's only field
bool algo::I64Dec10_ReadStrptrMaybe(algo::I64Dec10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec10..Print
// print string representation of algo::I64Dec10 to string LHS, no header -- cprint:algo.I64Dec10.String
void algo::I64Dec10_Print(algo::I64Dec10 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec2& parent, double val) {
    double intval = val * 100;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec2.value.Print
void algo::value_Print(algo::I64Dec2& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.I64Dec2..ReadStrptrMaybe
// Read fields of algo::I64Dec2 from an ascii string.
// The format of the string is the format of the algo::I64Dec2's only field
bool algo::I64Dec2_ReadStrptrMaybe(algo::I64Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec2..Print
// print string representation of algo::I64Dec2 to string LHS, no header -- cprint:algo.I64Dec2.String
void algo::I64Dec2_Print(algo::I64Dec2 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec3& parent, double val) {
    double intval = val * 1000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec3.value.Print
void algo::value_Print(algo::I64Dec3& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.I64Dec3..ReadStrptrMaybe
// Read fields of algo::I64Dec3 from an ascii string.
// The format of the string is the format of the algo::I64Dec3's only field
bool algo::I64Dec3_ReadStrptrMaybe(algo::I64Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec3..Print
// print string representation of algo::I64Dec3 to string LHS, no header -- cprint:algo.I64Dec3.String
void algo::I64Dec3_Print(algo::I64Dec3 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec4& parent, double val) {
    double intval = val * 10000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec4.value.Print
void algo::value_Print(algo::I64Dec4& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.I64Dec4..ReadStrptrMaybe
// Read fields of algo::I64Dec4 from an ascii string.
// The format of the string is the format of the algo::I64Dec4's only field
bool algo::I64Dec4_ReadStrptrMaybe(algo::I64Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec4..Print
// print string representation of algo::I64Dec4 to string LHS, no header -- cprint:algo.I64Dec4.String
void algo::I64Dec4_Print(algo::I64Dec4 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec5& parent, double val) {
    double intval = val * 100000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec5.value.Print
void algo::value_Print(algo::I64Dec5& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.I64Dec5..ReadStrptrMaybe
// Read fields of algo::I64Dec5 from an ascii string.
// The format of the string is the format of the algo::I64Dec5's only field
bool algo::I64Dec5_ReadStrptrMaybe(algo::I64Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec5..Print
// print string representation of algo::I64Dec5 to string LHS, no header -- cprint:algo.I64Dec5.String
void algo::I64Dec5_Print(algo::I64Dec5 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec6.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec6& parent, double val) {
    double intval = val * 1000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec6.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec6& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 6) { // ignore digits after 6'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 6) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec6.value.Print
void algo::value_Print(algo::I64Dec6& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 6, value_start, true);
}

// --- algo.I64Dec6..ReadStrptrMaybe
// Read fields of algo::I64Dec6 from an ascii string.
// The format of the string is the format of the algo::I64Dec6's only field
bool algo::I64Dec6_ReadStrptrMaybe(algo::I64Dec6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec6..Print
// print string representation of algo::I64Dec6 to string LHS, no header -- cprint:algo.I64Dec6.String
void algo::I64Dec6_Print(algo::I64Dec6 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec7.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec7& parent, double val) {
    double intval = val * 10000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec7.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec7& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 7) { // ignore digits after 7'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 7) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec7.value.Print
void algo::value_Print(algo::I64Dec7& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 7, value_start, true);
}

// --- algo.I64Dec7..ReadStrptrMaybe
// Read fields of algo::I64Dec7 from an ascii string.
// The format of the string is the format of the algo::I64Dec7's only field
bool algo::I64Dec7_ReadStrptrMaybe(algo::I64Dec7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec7..Print
// print string representation of algo::I64Dec7 to string LHS, no header -- cprint:algo.I64Dec7.String
void algo::I64Dec7_Print(algo::I64Dec7 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec8.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec8& parent, double val) {
    double intval = val * 100000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec8.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec8& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 8) { // ignore digits after 8'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 8) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec8.value.Print
void algo::value_Print(algo::I64Dec8& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 8, value_start, true);
}

// --- algo.I64Dec8..ReadStrptrMaybe
// Read fields of algo::I64Dec8 from an ascii string.
// The format of the string is the format of the algo::I64Dec8's only field
bool algo::I64Dec8_ReadStrptrMaybe(algo::I64Dec8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec8..Print
// print string representation of algo::I64Dec8 to string LHS, no header -- cprint:algo.I64Dec8.String
void algo::I64Dec8_Print(algo::I64Dec8 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.I64Dec9.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::I64Dec9& parent, double val) {
    double intval = val * 1000000000;
    i64 minval = i64(-9223372036854775807LL);
    i64 maxval = i64(9223372036854775807LL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.I64Dec9.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::I64Dec9& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 9) { // ignore digits after 9'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 9) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    i64 final_val = val;
    ok &= val <= 9223372036854775807LL; // u->i coversion, check limits
    if (neg) {
        final_val = -final_val;
        ok &= final_val >= -9223372036854775807LL;
    }
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.I64Dec9.value.Print
void algo::value_Print(algo::I64Dec9& parent, cstring &outstr) {
    i64 value = parent.value;
    ch_Reserve(outstr, 64);
    if (value < 0) {
        ch_Alloc(outstr) = '-';
        value = -value;
    }
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 9, value_start, true);
}

// --- algo.I64Dec9..ReadStrptrMaybe
// Read fields of algo::I64Dec9 from an ascii string.
// The format of the string is the format of the algo::I64Dec9's only field
bool algo::I64Dec9_ReadStrptrMaybe(algo::I64Dec9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.I64Dec9..Print
// print string representation of algo::I64Dec9 to string LHS, no header -- cprint:algo.I64Dec9.String
void algo::I64Dec9_Print(algo::I64Dec9 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.IOEvtFlags.read.ReadStrptrMaybe
inline static bool algo::read_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool read_tmp;
    retval = bool_ReadStrptrMaybe(read_tmp, in_str);
    if (retval) {
        read_Set(parent, read_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.write.ReadStrptrMaybe
inline static bool algo::write_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool write_tmp;
    retval = bool_ReadStrptrMaybe(write_tmp, in_str);
    if (retval) {
        write_Set(parent, write_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.eof.ReadStrptrMaybe
inline static bool algo::eof_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool eof_tmp;
    retval = bool_ReadStrptrMaybe(eof_tmp, in_str);
    if (retval) {
        eof_Set(parent, eof_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags.err.ReadStrptrMaybe
inline static bool algo::err_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool err_tmp;
    retval = bool_ReadStrptrMaybe(err_tmp, in_str);
    if (retval) {
        err_Set(parent, err_tmp);
    }
    return retval;
}

// --- algo.IOEvtFlags..ReadFieldMaybe
bool algo::IOEvtFlags_ReadFieldMaybe(algo::IOEvtFlags &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_value: retval = u32_ReadStrptrMaybe(parent.value, strval); break;
        case algo_FieldId_read: retval = read_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_write: retval = write_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_eof: retval = eof_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_err: retval = err_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.IOEvtFlags..ReadStrptrMaybe
// Read fields of algo::IOEvtFlags from an ascii string.
bool algo::IOEvtFlags_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str) {
    bool retval = true;
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_read: read_Set(parent,true); break;
                    case algo_FieldId_write: write_Set(parent,true); break;
                    case algo_FieldId_eof: eof_Set(parent,true); break;
                    case algo_FieldId_err: err_Set(parent,true); break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.IOEvtFlags..Print
// print string representation of algo::IOEvtFlags to string LHS, no header -- cprint:algo.IOEvtFlags.String
void algo::IOEvtFlags_Print(algo::IOEvtFlags & row, algo::cstring &str) {
    algo::ListSep ls(",");
    if (read_Get(row)) {
        str << ls << "read";
    }
    if (write_Get(row)) {
        str << ls << "write";
    }
    if (eof_Get(row)) {
        str << ls << "eof";
    }
    if (err_Get(row)) {
        str << ls << "err";
    }
}

// --- algo.IOEvtFlags..GetAnon
algo::strptr algo::IOEvtFlags_GetAnon(algo::IOEvtFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.IPoint..ReadFieldMaybe
bool algo::IPoint_ReadFieldMaybe(algo::IPoint &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_x: retval = i32_ReadStrptrMaybe(parent.x, strval); break;
        case algo_FieldId_y: retval = i32_ReadStrptrMaybe(parent.y, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.IPoint..ReadStrptrMaybe
// Read fields of algo::IPoint from an ascii string.
// The format of the string is a string with separated values
bool algo::IPoint_ReadStrptrMaybe(algo::IPoint &parent, algo::strptr in_str) {
    bool retval = true;
    algo::strptr value;

    algo::NextSep(in_str, ' ', value);
    retval = retval && i32_ReadStrptrMaybe(parent.x, value);

    value = in_str;
    retval = retval && i32_ReadStrptrMaybe(parent.y, value);
    return retval;
}

// --- algo.IPoint..Print
// print string representation of algo::IPoint to string LHS, no header -- cprint:algo.IPoint.String
void algo::IPoint_Print(algo::IPoint & row, algo::cstring &str) {
    i32_Print(row.x, str);
    str << ' ';
    i32_Print(row.y, str);
}

// --- algo.Smallstr50.ch.Print
void algo::ch_Print(algo::Smallstr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.Smallstr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr50& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr50..Hash
u32 algo::Smallstr50_Hash(u32 prev, const algo::Smallstr50 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr50..ReadStrptrMaybe
// Read fields of algo::Smallstr50 from an ascii string.
// The format of the string is the format of the algo::Smallstr50's only field
bool algo::Smallstr50_ReadStrptrMaybe(algo::Smallstr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr50..Print
// print string representation of algo::Smallstr50 to string LHS, no header -- cprint:algo.Smallstr50.String
void algo::Smallstr50_Print(algo::Smallstr50 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Imdb..Print
// print string representation of algo::Imdb to string LHS, no header -- cprint:algo.Imdb.String
void algo::Imdb_Print(algo::Imdb & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.Imdb";

    algo::Smallstr50_Print(row.imdb, temp);
    PrintAttrSpaceReset(str,"imdb", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- algo.ImrowPtr..Print
// print string representation of algo::ImrowPtr to string LHS, no header -- cprint:algo.ImrowPtr.String
void algo::ImrowPtr_Print(algo::ImrowPtr & row, algo::cstring &str) {
    u64_Print(row.value, str);
}

// --- algo.Imtable..Print
// print string representation of algo::Imtable to string LHS, no header -- cprint:algo.Imtable.String
void algo::Imtable_Print(algo::Imtable & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.Imtable";

    algo::Smallstr50_Print(row.imtable, temp);
    PrintAttrSpaceReset(str,"imtable", temp);

    algo::Smallstr50_Print(row.elem_type, temp);
    PrintAttrSpaceReset(str,"elem_type", temp);

    i32_Print(row.size, temp);
    PrintAttrSpaceReset(str,"size", temp);

    algo::Smallstr50_Print(row.ssimfile, temp);
    PrintAttrSpaceReset(str,"ssimfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- algo.LineBuf.buf.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char> algo::buf_Addary(algo::LineBuf& parent, algo::aryptr<char> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.buf_elems && rhs.elems < parent.buf_elems + parent.buf_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.LineBuf.buf  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    buf_Reserve(parent, nnew); // reserve space
    int at = parent.buf_n;
    memcpy(parent.buf_elems + at, rhs.elems, nnew * sizeof(char));
    parent.buf_n += nnew;
    return algo::aryptr<char>(parent.buf_elems + at, nnew);
}

// --- algo.LineBuf.buf.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char& algo::buf_Alloc(algo::LineBuf& parent) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    int at = n;
    char *elems = parent.buf_elems;
    new (elems + at) char(0); // construct new element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- algo.LineBuf.buf.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char& algo::buf_AllocAt(algo::LineBuf& parent, int at) {
    buf_Reserve(parent, 1);
    int n  = parent.buf_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.LineBuf.buf  comment:'index out of range'");
    }
    char *elems = parent.buf_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(char));
    new (elems + at) char(0); // construct element, default initializer
    parent.buf_n = n+1;
    return elems[at];
}

// --- algo.LineBuf.buf.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char> algo::buf_AllocN(algo::LineBuf& parent, int n_elems) {
    buf_Reserve(parent, n_elems);
    int old_n  = parent.buf_n;
    int new_n = old_n + n_elems;
    char *elems = parent.buf_elems;
    memset(elems + old_n, 0, new_n - old_n); // initialize new space
    parent.buf_n = new_n;
    return algo::aryptr<char>(elems + old_n, n_elems);
}

// --- algo.LineBuf.buf.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::buf_Remove(algo::LineBuf& parent, u32 i) {
    u32 lim = parent.buf_n;
    char *elems = parent.buf_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(char) * (lim - (i + 1)));
        parent.buf_n = lim - 1;
    }
}

// --- algo.LineBuf.buf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::buf_RemoveLast(algo::LineBuf& parent) {
    u64 n = parent.buf_n;
    if (n > 0) {
        n -= 1;
        parent.buf_n = n;
    }
}

// --- algo.LineBuf.buf.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::buf_AbsReserve(algo::LineBuf& parent, int n) {
    u32 old_max  = parent.buf_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.buf_elems, old_max * sizeof(char), new_max * sizeof(char));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.LineBuf.buf  comment:'out of memory'");
        }
        parent.buf_elems = (char*)new_mem;
        parent.buf_max = new_max;
    }
}

// --- algo.LineBuf.buf.Setary
// Copy contents of RHS to PARENT.
void algo::buf_Setary(algo::LineBuf& parent, algo::LineBuf &rhs) {
    buf_RemoveAll(parent);
    int nnew = rhs.buf_n;
    buf_Reserve(parent, nnew); // reserve space
    memcpy(parent.buf_elems, rhs.buf_elems, nnew * sizeof(char));
    parent.buf_n = nnew;
}

// --- algo.LineBuf.buf.Setary2
// Copy specified array into buf, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::buf_Setary(algo::LineBuf& parent, const algo::aryptr<char> &rhs) {
    buf_RemoveAll(parent);
    buf_Addary(parent, rhs);
}

// --- algo.LineBuf..Uninit
void algo::LineBuf_Uninit(algo::LineBuf& parent) {
    algo::LineBuf &row = parent; (void)row;

    // algo.LineBuf.buf.Uninit (Tary)  //
    // remove all elements from algo.LineBuf.buf
    buf_RemoveAll(parent);
    // free memory for Tary algo.LineBuf.buf
    algo_lib::malloc_FreeMem(parent.buf_elems, sizeof(char)*parent.buf_max); // (algo.LineBuf.buf)
}

// --- algo.LnumStr10_U64.ch.Print
void algo::ch_Print(algo::LnumStr10_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr10_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr10_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.LnumStr10_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr10_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 10 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr10_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr10_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum16(str, ok);
    }
    return u64(val);
}

// --- algo.LnumStr10_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr10_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr10_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr10_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr10_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr10_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 10;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr10_U64..Hash
u32 algo::LnumStr10_U64_Hash(u32 prev, const algo::LnumStr10_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr10_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr10_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr10_U64's only field
bool algo::LnumStr10_U64_ReadStrptrMaybe(algo::LnumStr10_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr10_U64..Print
// print string representation of algo::LnumStr10_U64 to string LHS, no header -- cprint:algo.LnumStr10_U64.String
void algo::LnumStr10_U64_Print(algo::LnumStr10_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr11_U64.ch.Print
void algo::ch_Print(algo::LnumStr11_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr11_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr11_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.LnumStr11_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr11_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 11 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr11_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr11_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum16(str, ok);
    }
    return u64(val);
}

// --- algo.LnumStr11_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr11_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr11_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr11_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr11_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr11_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 11;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr11_U64..Hash
u32 algo::LnumStr11_U64_Hash(u32 prev, const algo::LnumStr11_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr11_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr11_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr11_U64's only field
bool algo::LnumStr11_U64_ReadStrptrMaybe(algo::LnumStr11_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr11_U64..Print
// print string representation of algo::LnumStr11_U64 to string LHS, no header -- cprint:algo.LnumStr11_U64.String
void algo::LnumStr11_U64_Print(algo::LnumStr11_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr12_U64.ch.Print
void algo::ch_Print(algo::LnumStr12_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr12_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr12_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.LnumStr12_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr12_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 12 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr12_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr12_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum16(str, ok);
    }
    return u64(val);
}

// --- algo.LnumStr12_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr12_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr12_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr12_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr12_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr12_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 12;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr12_U64..Hash
u32 algo::LnumStr12_U64_Hash(u32 prev, const algo::LnumStr12_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr12_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr12_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr12_U64's only field
bool algo::LnumStr12_U64_ReadStrptrMaybe(algo::LnumStr12_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr12_U64..Print
// print string representation of algo::LnumStr12_U64 to string LHS, no header -- cprint:algo.LnumStr12_U64.String
void algo::LnumStr12_U64_Print(algo::LnumStr12_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr13_U64_Base36.ch.Print
void algo::ch_Print(algo::LnumStr13_U64_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr13_U64_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr13_U64_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 13) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 13");
    }
    return retval;
}

// --- algo.LnumStr13_U64_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr13_U64_Base36& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 13);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 13 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr13_U64_Base36.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr13_U64_Base36& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*36 + digit;
        ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr13_U64_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr13_U64_Base36& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr13_U64_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr13_U64_Base36& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr13_U64_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr13_U64_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 13;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Hash
u32 algo::LnumStr13_U64_Base36_Hash(u32 prev, const algo::LnumStr13_U64_Base36 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr13_U64_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr13_U64_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr13_U64_Base36's only field
bool algo::LnumStr13_U64_Base36_ReadStrptrMaybe(algo::LnumStr13_U64_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Print
// print string representation of algo::LnumStr13_U64_Base36 to string LHS, no header -- cprint:algo.LnumStr13_U64_Base36.String
void algo::LnumStr13_U64_Base36_Print(algo::LnumStr13_U64_Base36 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr16_U64_Base16.ch.Print
void algo::ch_Print(algo::LnumStr16_U64_Base16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr16_U64_Base16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr16_U64_Base16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.LnumStr16_U64_Base16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr16_U64_Base16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 16 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr16_U64_Base16.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr16_U64_Base16& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 16-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 16-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        val = val*16 + digit;
    }
    ok &= val <= 0XFFFFFFFFFFFFFFFF;
    return u64(val);
}

// --- algo.LnumStr16_U64_Base16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr16_U64_Base16& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr16_U64_Base16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr16_U64_Base16& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr16_U64_Base16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr16_U64_Base16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 16);
        val = val / 16;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 16;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Hash
u32 algo::LnumStr16_U64_Base16_Hash(u32 prev, const algo::LnumStr16_U64_Base16 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr16_U64_Base16..ReadStrptrMaybe
// Read fields of algo::LnumStr16_U64_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr16_U64_Base16's only field
bool algo::LnumStr16_U64_Base16_ReadStrptrMaybe(algo::LnumStr16_U64_Base16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Print
// print string representation of algo::LnumStr16_U64_Base16 to string LHS, no header -- cprint:algo.LnumStr16_U64_Base16.String
void algo::LnumStr16_U64_Base16_Print(algo::LnumStr16_U64_Base16 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr1_U32.ch.Print
void algo::ch_Print(algo::LnumStr1_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr1_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr1_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.LnumStr1_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr1_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 1 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr1_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr1_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum4(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr1_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr1_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr1_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr1_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr1_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr1_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 1;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr1_U32..Hash
u32 algo::LnumStr1_U32_Hash(u32 prev, const algo::LnumStr1_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr1_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr1_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr1_U32's only field
bool algo::LnumStr1_U32_ReadStrptrMaybe(algo::LnumStr1_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr1_U32..Print
// print string representation of algo::LnumStr1_U32 to string LHS, no header -- cprint:algo.LnumStr1_U32.String
void algo::LnumStr1_U32_Print(algo::LnumStr1_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr20_U64.ch.Print
void algo::ch_Print(algo::LnumStr20_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr20_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr20_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LnumStr20_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr20_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr20_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr20_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            ok = 0;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr20_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr20_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr20_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr20_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr20_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr20_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr20_U64..Hash
u32 algo::LnumStr20_U64_Hash(u32 prev, const algo::LnumStr20_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr20_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr20_U64's only field
bool algo::LnumStr20_U64_ReadStrptrMaybe(algo::LnumStr20_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr20_U64..Print
// print string representation of algo::LnumStr20_U64 to string LHS, no header -- cprint:algo.LnumStr20_U64.String
void algo::LnumStr20_U64_Print(algo::LnumStr20_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr22_U64.ch.Print
void algo::ch_Print(algo::LnumStr22_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr22_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr22_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 22) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 22");
    }
    return retval;
}

// --- algo.LnumStr22_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr22_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 22);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 22 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr22_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr22_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            ok = 0;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LnumStr22_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr22_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr22_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr22_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr22_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr22_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 22;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr22_U64..Hash
u32 algo::LnumStr22_U64_Hash(u32 prev, const algo::LnumStr22_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr22_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr22_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr22_U64's only field
bool algo::LnumStr22_U64_ReadStrptrMaybe(algo::LnumStr22_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr22_U64..Print
// print string representation of algo::LnumStr22_U64 to string LHS, no header -- cprint:algo.LnumStr22_U64.String
void algo::LnumStr22_U64_Print(algo::LnumStr22_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr2_U32.ch.Print
void algo::ch_Print(algo::LnumStr2_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr2_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr2_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.LnumStr2_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr2_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 2 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr2_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr2_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum4(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr2_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr2_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr2_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr2_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr2_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr2_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 2;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr2_U32..Hash
u32 algo::LnumStr2_U32_Hash(u32 prev, const algo::LnumStr2_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr2_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr2_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr2_U32's only field
bool algo::LnumStr2_U32_ReadStrptrMaybe(algo::LnumStr2_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr2_U32..Print
// print string representation of algo::LnumStr2_U32 to string LHS, no header -- cprint:algo.LnumStr2_U32.String
void algo::LnumStr2_U32_Print(algo::LnumStr2_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr3_U32.ch.Print
void algo::ch_Print(algo::LnumStr3_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr3_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr3_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LnumStr3_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr3_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr3_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr3_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum4(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr3_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr3_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr3_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr3_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr3_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr3_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 3;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr3_U32..Hash
u32 algo::LnumStr3_U32_Hash(u32 prev, const algo::LnumStr3_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr3_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr3_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr3_U32's only field
bool algo::LnumStr3_U32_ReadStrptrMaybe(algo::LnumStr3_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr3_U32..Print
// print string representation of algo::LnumStr3_U32 to string LHS, no header -- cprint:algo.LnumStr3_U32.String
void algo::LnumStr3_U32_Print(algo::LnumStr3_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr4_U32.ch.Print
void algo::ch_Print(algo::LnumStr4_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr4_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr4_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.LnumStr4_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr4_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 4 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr4_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr4_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum4(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr4_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr4_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr4_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr4_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr4_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr4_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 4;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr4_U32..Hash
u32 algo::LnumStr4_U32_Hash(u32 prev, const algo::LnumStr4_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr4_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr4_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr4_U32's only field
bool algo::LnumStr4_U32_ReadStrptrMaybe(algo::LnumStr4_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr4_U32..Print
// print string representation of algo::LnumStr4_U32 to string LHS, no header -- cprint:algo.LnumStr4_U32.String
void algo::LnumStr4_U32_Print(algo::LnumStr4_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr5_U32.ch.Print
void algo::ch_Print(algo::LnumStr5_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr5_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr5_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LnumStr5_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr5_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr5_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr5_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr5_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr5_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr5_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr5_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr5_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr5_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr5_U32..Hash
u32 algo::LnumStr5_U32_Hash(u32 prev, const algo::LnumStr5_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr5_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr5_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32's only field
bool algo::LnumStr5_U32_ReadStrptrMaybe(algo::LnumStr5_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr5_U32..Print
// print string representation of algo::LnumStr5_U32 to string LHS, no header -- cprint:algo.LnumStr5_U32.String
void algo::LnumStr5_U32_Print(algo::LnumStr5_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr5_U32_Base36.ch.Print
void algo::ch_Print(algo::LnumStr5_U32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr5_U32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr5_U32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LnumStr5_U32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr5_U32_Base36& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr5_U32_Base36.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr5_U32_Base36& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        val = val*36 + digit;
    }
    return u32(val);
}

// --- algo.LnumStr5_U32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr5_U32_Base36& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr5_U32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr5_U32_Base36& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr5_U32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr5_U32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Hash
u32 algo::LnumStr5_U32_Base36_Hash(u32 prev, const algo::LnumStr5_U32_Base36 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr5_U32_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr5_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32_Base36's only field
bool algo::LnumStr5_U32_Base36_ReadStrptrMaybe(algo::LnumStr5_U32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Print
// print string representation of algo::LnumStr5_U32_Base36 to string LHS, no header -- cprint:algo.LnumStr5_U32_Base36.String
void algo::LnumStr5_U32_Base36_Print(algo::LnumStr5_U32_Base36 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr6_U32.ch.Print
void algo::ch_Print(algo::LnumStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LnumStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr6_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr6_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr6_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr6_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr6_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr6_U32..Hash
u32 algo::LnumStr6_U32_Hash(u32 prev, const algo::LnumStr6_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr6_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr6_U32's only field
bool algo::LnumStr6_U32_ReadStrptrMaybe(algo::LnumStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr6_U32..Print
// print string representation of algo::LnumStr6_U32 to string LHS, no header -- cprint:algo.LnumStr6_U32.String
void algo::LnumStr6_U32_Print(algo::LnumStr6_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr7_U32.ch.Print
void algo::ch_Print(algo::LnumStr7_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr7_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr7_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LnumStr7_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr7_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr7_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr7_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr7_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr7_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr7_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr7_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr7_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr7_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr7_U32..Hash
u32 algo::LnumStr7_U32_Hash(u32 prev, const algo::LnumStr7_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr7_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr7_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32's only field
bool algo::LnumStr7_U32_ReadStrptrMaybe(algo::LnumStr7_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr7_U32..Print
// print string representation of algo::LnumStr7_U32 to string LHS, no header -- cprint:algo.LnumStr7_U32.String
void algo::LnumStr7_U32_Print(algo::LnumStr7_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr7_U32_Base36.ch.Print
void algo::ch_Print(algo::LnumStr7_U32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr7_U32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr7_U32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LnumStr7_U32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr7_U32_Base36& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr7_U32_Base36.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr7_U32_Base36& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        val = val*36 + digit;
    }
    ok &= val <= 0XFFFFFFFF;
    return u32(val);
}

// --- algo.LnumStr7_U32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr7_U32_Base36& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr7_U32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr7_U32_Base36& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr7_U32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr7_U32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Hash
u32 algo::LnumStr7_U32_Base36_Hash(u32 prev, const algo::LnumStr7_U32_Base36 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr7_U32_Base36..ReadStrptrMaybe
// Read fields of algo::LnumStr7_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32_Base36's only field
bool algo::LnumStr7_U32_Base36_ReadStrptrMaybe(algo::LnumStr7_U32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Print
// print string representation of algo::LnumStr7_U32_Base36 to string LHS, no header -- cprint:algo.LnumStr7_U32_Base36.String
void algo::LnumStr7_U32_Base36_Print(algo::LnumStr7_U32_Base36 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U32.ch.Print
void algo::ch_Print(algo::LnumStr8_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr8_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr8_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr8_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr8_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U32..Hash
u32 algo::LnumStr8_U32_Hash(u32 prev, const algo::LnumStr8_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32's only field
bool algo::LnumStr8_U32_ReadStrptrMaybe(algo::LnumStr8_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U32..Print
// print string representation of algo::LnumStr8_U32 to string LHS, no header -- cprint:algo.LnumStr8_U32.String
void algo::LnumStr8_U32_Print(algo::LnumStr8_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U32_Base16.ch.Print
void algo::ch_Print(algo::LnumStr8_U32_Base16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U32_Base16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U32_Base16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U32_Base16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U32_Base16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U32_Base16.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr8_U32_Base16& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 16-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 16-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        val = val*16 + digit;
    }
    ok &= val <= 0XFFFFFFFF;
    return u32(val);
}

// --- algo.LnumStr8_U32_Base16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr8_U32_Base16& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U32_Base16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U32_Base16& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr8_U32_Base16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U32_Base16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 16);
        val = val / 16;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Hash
u32 algo::LnumStr8_U32_Base16_Hash(u32 prev, const algo::LnumStr8_U32_Base16 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U32_Base16..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U32_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32_Base16's only field
bool algo::LnumStr8_U32_Base16_ReadStrptrMaybe(algo::LnumStr8_U32_Base16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Print
// print string representation of algo::LnumStr8_U32_Base16 to string LHS, no header -- cprint:algo.LnumStr8_U32_Base16.String
void algo::LnumStr8_U32_Base16_Print(algo::LnumStr8_U32_Base16 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr8_U64.ch.Print
void algo::ch_Print(algo::LnumStr8_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr8_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr8_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LnumStr8_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr8_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr8_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr8_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u64(val);
}

// --- algo.LnumStr8_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr8_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr8_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr8_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr8_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr8_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 8;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr8_U64..Hash
u32 algo::LnumStr8_U64_Hash(u32 prev, const algo::LnumStr8_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr8_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr8_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U64's only field
bool algo::LnumStr8_U64_ReadStrptrMaybe(algo::LnumStr8_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr8_U64..Print
// print string representation of algo::LnumStr8_U64 to string LHS, no header -- cprint:algo.LnumStr8_U64.String
void algo::LnumStr8_U64_Print(algo::LnumStr8_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr9_U32.ch.Print
void algo::ch_Print(algo::LnumStr9_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr9_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr9_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LnumStr9_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr9_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr9_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LnumStr9_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum16(str, ok);
    }
    return u32(val);
}

// --- algo.LnumStr9_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LnumStr9_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr9_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr9_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr9_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr9_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 9;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr9_U32..Hash
u32 algo::LnumStr9_U32_Hash(u32 prev, const algo::LnumStr9_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr9_U32..ReadStrptrMaybe
// Read fields of algo::LnumStr9_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U32's only field
bool algo::LnumStr9_U32_ReadStrptrMaybe(algo::LnumStr9_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr9_U32..Print
// print string representation of algo::LnumStr9_U32 to string LHS, no header -- cprint:algo.LnumStr9_U32.String
void algo::LnumStr9_U32_Print(algo::LnumStr9_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LnumStr9_U64.ch.Print
void algo::ch_Print(algo::LnumStr9_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LnumStr9_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LnumStr9_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LnumStr9_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LnumStr9_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = '0';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LnumStr9_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LnumStr9_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum16(str, ok);
    }
    return u64(val);
}

// --- algo.LnumStr9_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LnumStr9_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LnumStr9_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LnumStr9_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LnumStr9_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LnumStr9_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 9;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LnumStr9_U64..Hash
u32 algo::LnumStr9_U64_Hash(u32 prev, const algo::LnumStr9_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LnumStr9_U64..ReadStrptrMaybe
// Read fields of algo::LnumStr9_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U64's only field
bool algo::LnumStr9_U64_ReadStrptrMaybe(algo::LnumStr9_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LnumStr9_U64..Print
// print string representation of algo::LnumStr9_U64 to string LHS, no header -- cprint:algo.LnumStr9_U64.String
void algo::LnumStr9_U64_Print(algo::LnumStr9_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LogcatId..ReadStrptrMaybe
// Read fields of algo::LogcatId from an ascii string.
// The format of the string is the format of the algo::LogcatId's only field
bool algo::LogcatId_ReadStrptrMaybe(algo::LogcatId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && i32_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.LogcatId..Print
// print string representation of algo::LogcatId to string LHS, no header -- cprint:algo.LogcatId.String
void algo::LogcatId_Print(algo::LogcatId row, algo::cstring &str) {
    i32_Print(row.value, str);
}

// --- algo.LogcatKey..ReadStrptrMaybe
// Read fields of algo::LogcatKey from an ascii string.
// The format of the string is the format of the algo::LogcatKey's only field
bool algo::LogcatKey_ReadStrptrMaybe(algo::LogcatKey &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::Smallstr50_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.LogcatKey..Print
// print string representation of algo::LogcatKey to string LHS, no header -- cprint:algo.LogcatKey.String
void algo::LogcatKey_Print(algo::LogcatKey & row, algo::cstring &str) {
    algo::Smallstr50_Print(row.value, str);
}

// --- algo.SchedTime..ReadStrptrMaybe
// Read fields of algo::SchedTime from an ascii string.
// The format of the string is the format of the algo::SchedTime's only field
bool algo::SchedTime_ReadStrptrMaybe(algo::SchedTime &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u64_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.SchedTime..Print
// print string representation of algo::SchedTime to string LHS, no header -- cprint:algo.SchedTime.String
void algo::SchedTime_Print(algo::SchedTime row, algo::cstring &str) {
    u64_Print(row.value, str);
}

// --- algo.Smallstr200.ch.Print
void algo::ch_Print(algo::Smallstr200& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr200.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr200& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 200) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 200");
    }
    return retval;
}

// --- algo.Smallstr200.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr200& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 200);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr200..Hash
u32 algo::Smallstr200_Hash(u32 prev, const algo::Smallstr200 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr200..ReadStrptrMaybe
// Read fields of algo::Smallstr200 from an ascii string.
// The format of the string is the format of the algo::Smallstr200's only field
bool algo::Smallstr200_ReadStrptrMaybe(algo::Smallstr200 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr200..Print
// print string representation of algo::Smallstr200 to string LHS, no header -- cprint:algo.Smallstr200.String
void algo::Smallstr200_Print(algo::Smallstr200 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Logmsg..Print
// print string representation of algo::Logmsg to string LHS, no header -- cprint:algo.Logmsg.String
void algo::Logmsg_Print(algo::Logmsg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo.Logmsg";

    u64_Print(row.logmsg, temp);
    PrintAttrSpaceReset(str,"logmsg", temp);

    algo::SchedTime_Print(row.time, temp);
    PrintAttrSpaceReset(str,"time", temp);

    bool_Print(row.err, temp);
    PrintAttrSpaceReset(str,"err", temp);

    bool_Print(row.part, temp);
    PrintAttrSpaceReset(str,"part", temp);

    algo::Smallstr200_Print(row.text, temp);
    PrintAttrSpaceReset(str,"text", temp);
}

// --- algo.LspaceStr10.ch.Print
void algo::ch_Print(algo::LspaceStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.LspaceStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr10& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 10 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr10..Hash
u32 algo::LspaceStr10_Hash(u32 prev, const algo::LspaceStr10 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr10..ReadStrptrMaybe
// Read fields of algo::LspaceStr10 from an ascii string.
// The format of the string is the format of the algo::LspaceStr10's only field
bool algo::LspaceStr10_ReadStrptrMaybe(algo::LspaceStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr10..Print
// print string representation of algo::LspaceStr10 to string LHS, no header -- cprint:algo.LspaceStr10.String
void algo::LspaceStr10_Print(algo::LspaceStr10 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr12.ch.Print
void algo::ch_Print(algo::LspaceStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.LspaceStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr12& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 12 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr12..Hash
u32 algo::LspaceStr12_Hash(u32 prev, const algo::LspaceStr12 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr12..ReadStrptrMaybe
// Read fields of algo::LspaceStr12 from an ascii string.
// The format of the string is the format of the algo::LspaceStr12's only field
bool algo::LspaceStr12_ReadStrptrMaybe(algo::LspaceStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr12..Print
// print string representation of algo::LspaceStr12 to string LHS, no header -- cprint:algo.LspaceStr12.String
void algo::LspaceStr12_Print(algo::LspaceStr12 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr14.ch.Print
void algo::ch_Print(algo::LspaceStr14& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr14.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr14& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 14) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 14");
    }
    return retval;
}

// --- algo.LspaceStr14.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr14& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 14);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 14 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr14..Hash
u32 algo::LspaceStr14_Hash(u32 prev, const algo::LspaceStr14 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr14..ReadStrptrMaybe
// Read fields of algo::LspaceStr14 from an ascii string.
// The format of the string is the format of the algo::LspaceStr14's only field
bool algo::LspaceStr14_ReadStrptrMaybe(algo::LspaceStr14 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr14..Print
// print string representation of algo::LspaceStr14 to string LHS, no header -- cprint:algo.LspaceStr14.String
void algo::LspaceStr14_Print(algo::LspaceStr14 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr15.ch.Print
void algo::ch_Print(algo::LspaceStr15& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr15.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr15& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 15) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 15");
    }
    return retval;
}

// --- algo.LspaceStr15.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr15& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 15);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 15 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr15..Hash
u32 algo::LspaceStr15_Hash(u32 prev, const algo::LspaceStr15 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr15..ReadStrptrMaybe
// Read fields of algo::LspaceStr15 from an ascii string.
// The format of the string is the format of the algo::LspaceStr15's only field
bool algo::LspaceStr15_ReadStrptrMaybe(algo::LspaceStr15 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr15..Print
// print string representation of algo::LspaceStr15 to string LHS, no header -- cprint:algo.LspaceStr15.String
void algo::LspaceStr15_Print(algo::LspaceStr15 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr20_I64.ch.Print
void algo::ch_Print(algo::LspaceStr20_I64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr20_I64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr20_I64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LspaceStr20_I64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr20_I64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr20_I64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static i64 algo::ch_qGetnum(algo::LspaceStr20_I64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            ok = 0;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        ok &= (val <= r1);
        val = r1;
    }
    i64 ret = is_neg ? -val : val;
    return i64(ret);
}

// --- algo.LspaceStr20_I64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i64 algo::ch_GetnumDflt(algo::LspaceStr20_I64& parent, i64 dflt) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr20_I64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr20_I64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr20_I64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr20_I64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr20_I64..Hash
u32 algo::LspaceStr20_I64_Hash(u32 prev, const algo::LspaceStr20_I64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr20_I64..ReadStrptrMaybe
// Read fields of algo::LspaceStr20_I64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_I64's only field
bool algo::LspaceStr20_I64_ReadStrptrMaybe(algo::LspaceStr20_I64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr20_I64..Print
// print string representation of algo::LspaceStr20_I64 to string LHS, no header -- cprint:algo.LspaceStr20_I64.String
void algo::LspaceStr20_I64_Print(algo::LspaceStr20_I64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr20_U64.ch.Print
void algo::ch_Print(algo::LspaceStr20_U64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr20_U64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr20_U64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.LspaceStr20_U64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr20_U64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 20 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr20_U64.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u64 algo::ch_qGetnum(algo::LspaceStr20_U64& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else {
            ok = 0;
        }
        // Check for 64-bit overflow inside the loop
        u64 r1 = val*10 + digit;
        ok &= (val <= r1);
        val = r1;
    }
    return u64(val);
}

// --- algo.LspaceStr20_U64.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64 algo::ch_GetnumDflt(algo::LspaceStr20_U64& parent, u64 dflt) {
    u32 ok = 1;
    u64 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr20_U64.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr20_U64& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr20_U64.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr20_U64& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u64_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 20;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr20_U64..Hash
u32 algo::LspaceStr20_U64_Hash(u32 prev, const algo::LspaceStr20_U64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr20_U64..ReadStrptrMaybe
// Read fields of algo::LspaceStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_U64's only field
bool algo::LspaceStr20_U64_ReadStrptrMaybe(algo::LspaceStr20_U64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr20_U64..Print
// print string representation of algo::LspaceStr20_U64 to string LHS, no header -- cprint:algo.LspaceStr20_U64.String
void algo::LspaceStr20_U64_Print(algo::LspaceStr20_U64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr3.ch.Print
void algo::ch_Print(algo::LspaceStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LspaceStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr3& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr3..Hash
u32 algo::LspaceStr3_Hash(u32 prev, const algo::LspaceStr3 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr3..ReadStrptrMaybe
// Read fields of algo::LspaceStr3 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3's only field
bool algo::LspaceStr3_ReadStrptrMaybe(algo::LspaceStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr3..Print
// print string representation of algo::LspaceStr3 to string LHS, no header -- cprint:algo.LspaceStr3.String
void algo::LspaceStr3_Print(algo::LspaceStr3 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr3_I16.ch.Print
void algo::ch_Print(algo::LspaceStr3_I16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr3_I16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr3_I16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.LspaceStr3_I16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr3_I16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 3 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr3_I16.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static i16 algo::ch_qGetnum(algo::LspaceStr3_I16& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum4(str, ok);
    }
    i64 ret = is_neg ? -val : val;
    return i16(ret);
}

// --- algo.LspaceStr3_I16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i16 algo::ch_GetnumDflt(algo::LspaceStr3_I16& parent, i16 dflt) {
    u32 ok = 1;
    i16 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr3_I16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr3_I16& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr3_I16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr3_I16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    length = algo::u16_FmtBuf(val, (u8*)buf + charpos);
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 3;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr3_I16..Hash
u32 algo::LspaceStr3_I16_Hash(u32 prev, const algo::LspaceStr3_I16 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr3_I16..ReadStrptrMaybe
// Read fields of algo::LspaceStr3_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3_I16's only field
bool algo::LspaceStr3_I16_ReadStrptrMaybe(algo::LspaceStr3_I16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr3_I16..Print
// print string representation of algo::LspaceStr3_I16 to string LHS, no header -- cprint:algo.LspaceStr3_I16.String
void algo::LspaceStr3_I16_Print(algo::LspaceStr3_I16 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr4.ch.Print
void algo::ch_Print(algo::LspaceStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.LspaceStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr4& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 4 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr4..Hash
u32 algo::LspaceStr4_Hash(u32 prev, const algo::LspaceStr4 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr4..ReadStrptrMaybe
// Read fields of algo::LspaceStr4 from an ascii string.
// The format of the string is the format of the algo::LspaceStr4's only field
bool algo::LspaceStr4_ReadStrptrMaybe(algo::LspaceStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr4..Print
// print string representation of algo::LspaceStr4 to string LHS, no header -- cprint:algo.LspaceStr4.String
void algo::LspaceStr4_Print(algo::LspaceStr4 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr5.ch.Print
void algo::ch_Print(algo::LspaceStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LspaceStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr5& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr5..Hash
u32 algo::LspaceStr5_Hash(u32 prev, const algo::LspaceStr5 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr5..ReadStrptrMaybe
// Read fields of algo::LspaceStr5 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5's only field
bool algo::LspaceStr5_ReadStrptrMaybe(algo::LspaceStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr5..Print
// print string representation of algo::LspaceStr5 to string LHS, no header -- cprint:algo.LspaceStr5.String
void algo::LspaceStr5_Print(algo::LspaceStr5 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr5_I16.ch.Print
void algo::ch_Print(algo::LspaceStr5_I16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr5_I16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr5_I16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.LspaceStr5_I16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr5_I16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 5 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr5_I16.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u16 algo::ch_qGetnum(algo::LspaceStr5_I16& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    ok &= val <= 0XFFFF;
    return u16(val);
}

// --- algo.LspaceStr5_I16.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u16 algo::ch_GetnumDflt(algo::LspaceStr5_I16& parent, u16 dflt) {
    u32 ok = 1;
    u16 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr5_I16.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr5_I16& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr5_I16.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr5_I16& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u16_FmtBuf(val, (u8*)buf + charpos);
    //pad string with 0s up to min_length
    while (charpos > 0 && length < 5) {
        buf[--charpos] = '0';
        ++length;
    }
    bool retval = length <= 5;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr5_I16..Hash
u32 algo::LspaceStr5_I16_Hash(u32 prev, const algo::LspaceStr5_I16 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr5_I16..ReadStrptrMaybe
// Read fields of algo::LspaceStr5_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5_I16's only field
bool algo::LspaceStr5_I16_ReadStrptrMaybe(algo::LspaceStr5_I16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr5_I16..Print
// print string representation of algo::LspaceStr5_I16 to string LHS, no header -- cprint:algo.LspaceStr5_I16.String
void algo::LspaceStr5_I16_Print(algo::LspaceStr5_I16 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr6.ch.Print
void algo::ch_Print(algo::LspaceStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LspaceStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr6& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr6..Hash
u32 algo::LspaceStr6_Hash(u32 prev, const algo::LspaceStr6 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr6..ReadStrptrMaybe
// Read fields of algo::LspaceStr6 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6's only field
bool algo::LspaceStr6_ReadStrptrMaybe(algo::LspaceStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr6..Print
// print string representation of algo::LspaceStr6 to string LHS, no header -- cprint:algo.LspaceStr6.String
void algo::LspaceStr6_Print(algo::LspaceStr6 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr6_U32.ch.Print
void algo::ch_Print(algo::LspaceStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.LspaceStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr6_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 6 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr6_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::LspaceStr6_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.LspaceStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::LspaceStr6_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr6_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr6_U32..Hash
u32 algo::LspaceStr6_U32_Hash(u32 prev, const algo::LspaceStr6_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr6_U32..ReadStrptrMaybe
// Read fields of algo::LspaceStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6_U32's only field
bool algo::LspaceStr6_U32_ReadStrptrMaybe(algo::LspaceStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr6_U32..Print
// print string representation of algo::LspaceStr6_U32 to string LHS, no header -- cprint:algo.LspaceStr6_U32.String
void algo::LspaceStr6_U32_Print(algo::LspaceStr6_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr7_I32_Base36.ch.Print
void algo::ch_Print(algo::LspaceStr7_I32_Base36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr7_I32_Base36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.LspaceStr7_I32_Base36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr7_I32_Base36& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 7 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr7_I32_Base36.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static i32 algo::ch_qGetnum(algo::LspaceStr7_I32_Base36& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    bool is_neg = (str.n_elems > 0) && (str.elems[0] == '-');
    if (is_neg) {
        str.elems++;
        str.n_elems--;
    }
    for (int i = 0; i < str.n_elems; i++) {
        char ch = str.elems[i];
        int digit = ch;
        if (ch >= '0' && ch < '0' + 10) {
            digit -= '0';
        } else if (ch >= 'a' && ch <= 'a' + 36-10) {
            digit = digit - 'a' + 10;
        } else if (ch >= 'A' && ch <= 'A' + 36-10) {
            digit = digit - 'A' + 10;
        } else {
            ok = 0;
        }
        val = val*36 + digit;
    }
    i64 ret = is_neg ? -val : val;
    ok &= ret >= i64(0XFFFFFFFF80000000) && ret <= i64(0X7FFFFFFF);
    return i32(ret);
}

// --- algo.LspaceStr7_I32_Base36.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i32 algo::ch_GetnumDflt(algo::LspaceStr7_I32_Base36& parent, i32 dflt) {
    u32 ok = 1;
    i32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.LspaceStr7_I32_Base36.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::LspaceStr7_I32_Base36& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.LspaceStr7_I32_Base36.ch.SetnumMaybe
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::LspaceStr7_I32_Base36& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = (rhs < 0 ? -rhs : rhs);
    charpos = sizeof(buf);
    do {
        u32 rem = u32(val % 36);
        val = val / 36;
        char ch;
        ch = rem < 10 ? char('0' + rem) : char('A' + rem - 10);
        buf[--charpos] = ch;
    } while (val != 0);
    length = sizeof(buf) - charpos;
    if (rhs < 0) {
        if (charpos > 0 && buf[charpos] != '0') {
            --charpos;
            ++length;
        }
        buf[charpos] = '-';
    }
    bool retval = length <= 7;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Hash
u32 algo::LspaceStr7_I32_Base36_Hash(u32 prev, const algo::LspaceStr7_I32_Base36 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr7_I32_Base36..ReadStrptrMaybe
// Read fields of algo::LspaceStr7_I32_Base36 from an ascii string.
// The format of the string is the format of the algo::LspaceStr7_I32_Base36's only field
bool algo::LspaceStr7_I32_Base36_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Print
// print string representation of algo::LspaceStr7_I32_Base36 to string LHS, no header -- cprint:algo.LspaceStr7_I32_Base36.String
void algo::LspaceStr7_I32_Base36_Print(algo::LspaceStr7_I32_Base36 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr8.ch.Print
void algo::ch_Print(algo::LspaceStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.LspaceStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr8& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 8 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr8..Hash
u32 algo::LspaceStr8_Hash(u32 prev, const algo::LspaceStr8 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr8..ReadStrptrMaybe
// Read fields of algo::LspaceStr8 from an ascii string.
// The format of the string is the format of the algo::LspaceStr8's only field
bool algo::LspaceStr8_ReadStrptrMaybe(algo::LspaceStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr8..Print
// print string representation of algo::LspaceStr8 to string LHS, no header -- cprint:algo.LspaceStr8.String
void algo::LspaceStr8_Print(algo::LspaceStr8 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.LspaceStr9.ch.Print
void algo::ch_Print(algo::LspaceStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.LspaceStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::LspaceStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.LspaceStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::LspaceStr9& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; j < 9 - len; j++) {
        parent.ch[j] = ' ';
    }
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
}

// --- algo.LspaceStr9..Hash
u32 algo::LspaceStr9_Hash(u32 prev, const algo::LspaceStr9 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.LspaceStr9..ReadStrptrMaybe
// Read fields of algo::LspaceStr9 from an ascii string.
// The format of the string is the format of the algo::LspaceStr9's only field
bool algo::LspaceStr9_ReadStrptrMaybe(algo::LspaceStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.LspaceStr9..Print
// print string representation of algo::LspaceStr9 to string LHS, no header -- cprint:algo.LspaceStr9.String
void algo::LspaceStr9_Print(algo::LspaceStr9 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Md5Digest.value.Print
// Convert value to a string. Parent's separator is used.
void algo::value_Print(algo::Md5Digest& parent, algo::cstring &lhs) {
    int len = 16;
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            lhs << ':';
        }
        u8_Print(parent.value_elems[i], lhs);
    }
}

// --- algo.Md5Digest.value.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::Md5Digest& parent, algo::strptr in_str) {
    bool retval = true;
    for (int i=0; in_str != "" && i < value_Max(parent); i++) {
        algo::strptr token;
        algo::NextSep(in_str, ':', token);
        retval = u8_ReadStrptrMaybe(parent.value_elems[i], token);
        if (!retval) {
            break;
        }
    }
    return retval;
}

// --- algo.Md5Digest..ReadStrptrMaybe
// Read fields of algo::Md5Digest from an ascii string.
// The format of the string is the format of the algo::Md5Digest's only field
bool algo::Md5Digest_ReadStrptrMaybe(algo::Md5Digest &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Md5Digest..Print
// print string representation of algo::Md5Digest to string LHS, no header -- cprint:algo.Md5Digest.String
void algo::Md5Digest_Print(algo::Md5Digest row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.Month.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::Month& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_Month_January            : ret = "January";  break;
        case algo_Month_February           : ret = "February";  break;
        case algo_Month_March              : ret = "March";  break;
        case algo_Month_April              : ret = "April";  break;
        case algo_Month_May                : ret = "May";  break;
        case algo_Month_June               : ret = "June";  break;
        case algo_Month_July               : ret = "July";  break;
        case algo_Month_August             : ret = "August";  break;
        case algo_Month_September          : ret = "September";  break;
        case algo_Month_October            : ret = "October";  break;
        case algo_Month_November           : ret = "November";  break;
        case algo_Month_December           : ret = "December";  break;
        case algo_Month_None               : ret = "None";  break;
    }
    return ret;
}

// --- algo.Month.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::Month& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.Month.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::Month& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('M','a','y'): {
                    value_SetEnum(parent,algo_Month_May); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('J','u','l','y'): {
                    value_SetEnum(parent,algo_Month_July); ret = true; break;
                }
                case LE_STR4('J','u','n','e'): {
                    value_SetEnum(parent,algo_Month_June); ret = true; break;
                }
                case LE_STR4('N','o','n','e'): {
                    value_SetEnum(parent,algo_Month_None); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('A','p','r','i','l'): {
                    value_SetEnum(parent,algo_Month_April); ret = true; break;
                }
                case LE_STR5('M','a','r','c','h'): {
                    value_SetEnum(parent,algo_Month_March); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('A','u','g','u','s','t'): {
                    value_SetEnum(parent,algo_Month_August); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('J','a','n','u','a','r','y'): {
                    value_SetEnum(parent,algo_Month_January); ret = true; break;
                }
                case LE_STR7('O','c','t','o','b','e','r'): {
                    value_SetEnum(parent,algo_Month_October); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('D','e','c','e','m','b','e','r'): {
                    value_SetEnum(parent,algo_Month_December); ret = true; break;
                }
                case LE_STR8('F','e','b','r','u','a','r','y'): {
                    value_SetEnum(parent,algo_Month_February); ret = true; break;
                }
                case LE_STR8('N','o','v','e','m','b','e','r'): {
                    value_SetEnum(parent,algo_Month_November); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('S','e','p','t','e','m','b','e'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,algo_Month_September); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.Month.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::Month& parent, algo::strptr rhs, algo_MonthEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.Month.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::Month& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.Month..ReadStrptrMaybe
// Read fields of algo::Month from an ascii string.
// The format of the string is the format of the algo::Month's only field
bool algo::Month_ReadStrptrMaybe(algo::Month &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Month..Print
// print string representation of algo::Month to string LHS, no header -- cprint:algo.Month.String
void algo::Month_Print(algo::Month row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.NormTxttbl.start.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& algo::start_Alloc(algo::NormTxttbl& parent) {
    start_Reserve(parent, 1);
    int n  = parent.start_n;
    int at = n;
    i32 *elems = parent.start_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    parent.start_n = n+1;
    return elems[at];
}

// --- algo.NormTxttbl.start.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& algo::start_AllocAt(algo::NormTxttbl& parent, int at) {
    start_Reserve(parent, 1);
    int n  = parent.start_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.NormTxttbl.start  comment:'index out of range'");
    }
    i32 *elems = parent.start_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    parent.start_n = n+1;
    return elems[at];
}

// --- algo.NormTxttbl.start.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> algo::start_AllocN(algo::NormTxttbl& parent, int n_elems) {
    start_Reserve(parent, n_elems);
    int old_n  = parent.start_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.start_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    parent.start_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- algo.NormTxttbl.start.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::start_Remove(algo::NormTxttbl& parent, u32 i) {
    u32 lim = parent.start_n;
    i32 *elems = parent.start_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        parent.start_n = lim - 1;
    }
}

// --- algo.NormTxttbl.start.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::start_RemoveLast(algo::NormTxttbl& parent) {
    u64 n = parent.start_n;
    if (n > 0) {
        n -= 1;
        parent.start_n = n;
    }
}

// --- algo.NormTxttbl.start.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::start_AbsReserve(algo::NormTxttbl& parent, int n) {
    u32 old_max  = parent.start_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.start_elems, old_max * sizeof(i32), new_max * sizeof(i32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.NormTxttbl.start  comment:'out of memory'");
        }
        parent.start_elems = (i32*)new_mem;
        parent.start_max = new_max;
    }
}

// --- algo.NormTxttbl.start.Setary
// Copy contents of RHS to PARENT.
void algo::start_Setary(algo::NormTxttbl& parent, algo::NormTxttbl &rhs) {
    start_RemoveAll(parent);
    int nnew = rhs.start_n;
    start_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.start_elems + i) i32(start_qFind(rhs, i));
        parent.start_n = i + 1;
    }
}

// --- algo.NormTxttbl..Uninit
void algo::NormTxttbl_Uninit(algo::NormTxttbl& parent) {
    algo::NormTxttbl &row = parent; (void)row;

    // algo.NormTxttbl.start.Uninit (Tary)  //
    // remove all elements from algo.NormTxttbl.start
    start_RemoveAll(parent);
    // free memory for Tary algo.NormTxttbl.start
    algo_lib::malloc_FreeMem(parent.start_elems, sizeof(i32)*parent.start_max); // (algo.NormTxttbl.start)
}

// --- algo.NumParseFlags.err.ReadStrptrMaybe
inline static bool algo::err_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool err_tmp;
    retval = bool_ReadStrptrMaybe(err_tmp, in_str);
    if (retval) {
        err_Set(parent, err_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.ok.ReadStrptrMaybe
inline static bool algo::ok_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool ok_tmp;
    retval = bool_ReadStrptrMaybe(ok_tmp, in_str);
    if (retval) {
        ok_Set(parent, ok_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.neg.ReadStrptrMaybe
inline static bool algo::neg_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool neg_tmp;
    retval = bool_ReadStrptrMaybe(neg_tmp, in_str);
    if (retval) {
        neg_Set(parent, neg_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.overflow.ReadStrptrMaybe
inline static bool algo::overflow_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool overflow_tmp;
    retval = bool_ReadStrptrMaybe(overflow_tmp, in_str);
    if (retval) {
        overflow_Set(parent, overflow_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags.hex.ReadStrptrMaybe
inline static bool algo::hex_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    bool hex_tmp;
    retval = bool_ReadStrptrMaybe(hex_tmp, in_str);
    if (retval) {
        hex_Set(parent, hex_tmp);
    }
    return retval;
}

// --- algo.NumParseFlags..ReadFieldMaybe
bool algo::NumParseFlags_ReadFieldMaybe(algo::NumParseFlags &parent, algo::strptr field, algo::strptr strval) {
    algo::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_FieldId_value: retval = u32_ReadStrptrMaybe(parent.value, strval); break;
        case algo_FieldId_err: retval = err_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_ok: retval = ok_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_neg: retval = neg_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_overflow: retval = overflow_ReadStrptrMaybe(parent, strval); break;
        case algo_FieldId_hex: retval = hex_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo.NumParseFlags..ReadStrptrMaybe
// Read fields of algo::NumParseFlags from an ascii string.
bool algo::NumParseFlags_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str) {
    bool retval = true;
    while (ch_N(in_str)) {
        strptr field_name;
        algo::NextSep(in_str,',',field_name);
        field_name = algo::Trimmed(field_name);
        if (ch_N(field_name)) {
            algo::FieldId field_id;
            bool ok = algo::value_SetStrptrMaybe(field_id,field_name);
            if (ok) {
                switch (field_id) {
                    case algo_FieldId_err: err_Set(parent,true); break;
                    case algo_FieldId_ok: ok_Set(parent,true); break;
                    case algo_FieldId_neg: neg_Set(parent,true); break;
                    case algo_FieldId_overflow: overflow_Set(parent,true); break;
                    case algo_FieldId_hex: hex_Set(parent,true); break;
                    default: ok = false; break;
                }
            }
            if (!ok) {
                algo_lib::AppendErrtext("bitfld",field_name);
                retval = false;
            }
        }
    }
    return retval;
}

// --- algo.NumParseFlags..Print
// print string representation of algo::NumParseFlags to string LHS, no header -- cprint:algo.NumParseFlags.String
void algo::NumParseFlags_Print(algo::NumParseFlags & row, algo::cstring &str) {
    algo::ListSep ls(",");
    if (err_Get(row)) {
        str << ls << "err";
    }
    if (ok_Get(row)) {
        str << ls << "ok";
    }
    if (neg_Get(row)) {
        str << ls << "neg";
    }
    if (overflow_Get(row)) {
        str << ls << "overflow";
    }
    if (hex_Get(row)) {
        str << ls << "hex";
    }
}

// --- algo.NumParseFlags..GetAnon
algo::strptr algo::NumParseFlags_GetAnon(algo::NumParseFlags &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("value", 5);
        default: return algo::strptr();
    }
}

// --- algo.Protocol.proto.StaticCheck
void algo::StaticCheck() {
    algo_assert(sizeof(algo::ImdbInsertStrptrMaybeFcn) == 8); // csize:algo.ImdbInsertStrptrMaybeFcn
    algo_assert(sizeof(algo::ImdbStepFcn) == 8); // csize:algo.ImdbStepFcn
    algo_assert(sizeof(algo::ImdbMainLoopFcn) == 8); // csize:algo.ImdbMainLoopFcn
    algo_assert(sizeof(algo::ImdbGetTraceFcn) == 8); // csize:algo.ImdbGetTraceFcn
    algo_assert(sizeof(algo::ImrowNItemsFcn) == 8); // csize:algo.ImrowNItemsFcn
    algo_assert(sizeof(algo::ImrowPrintFcn) == 8); // csize:algo.ImrowPrintFcn
    algo_assert(sizeof(algo::ImrowRowidFindFcn) == 8); // csize:algo.ImrowRowidFindFcn
    algo_assert(sizeof(algo::ImrowXrefXFcn) == 8); // csize:algo.ImrowXrefXFcn
    algo_assert(sizeof(algo::strptr) == 16); // csize:algo.strptr
    algo_assert(sizeof(algo::memptr) == 16); // csize:algo.memptr
    algo_assert(_offset_of(algo::UnTime, value) + sizeof(((algo::UnTime*)0)->value) == sizeof(algo::UnTime));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::Errcode*)0)->value)*8 >= 40);
    algo_assert(_offset_of(algo::FieldId, value) + sizeof(((algo::FieldId*)0)->value) == sizeof(algo::FieldId));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::FileFlags*)0)->value)*8 >= 10);
    algo_assert(_offset_of(algo::I64Dec5, value) + sizeof(((algo::I64Dec5*)0)->value) == sizeof(algo::I64Dec5));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::IOEvtFlags*)0)->value)*8 >= 4);
    algo_assert(_offset_of(algo::SchedTime, value) + sizeof(((algo::SchedTime*)0)->value) == sizeof(algo::SchedTime));
    // check that bitfield fits width
    algo_assert(sizeof(((algo::NumParseFlags*)0)->value)*8 >= 5);
    algo_assert(_offset_of(algo::SeqType, value) + sizeof(((algo::SeqType*)0)->value) == sizeof(algo::SeqType));
    algo_assert(_offset_of(algo::U16Dec2, value) + sizeof(((algo::U16Dec2*)0)->value) == sizeof(algo::U16Dec2));
    algo_assert(_offset_of(algo::U32Dec1, value) + sizeof(((algo::U32Dec1*)0)->value) == sizeof(algo::U32Dec1));
    algo_assert(_offset_of(algo::U64Dec2, value) + sizeof(((algo::U64Dec2*)0)->value) == sizeof(algo::U64Dec2));
    algo_assert(_offset_of(algo::UnDiff, value) + sizeof(((algo::UnDiff*)0)->value) == sizeof(algo::UnDiff));
    algo_assert(_offset_of(algo::UnixTime, value) + sizeof(((algo::UnixTime*)0)->value) == sizeof(algo::UnixTime));
    algo_assert(_offset_of(algo::WDiff, value) + sizeof(((algo::WDiff*)0)->value) == sizeof(algo::WDiff));
    algo_assert(_offset_of(algo::WTime, value) + sizeof(((algo::WTime*)0)->value) == sizeof(algo::WTime));
}

// --- algo.RnullStr1.ch.Print
void algo::ch_Print(algo::RnullStr1& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr1.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr1& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.RnullStr1.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr1& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 1; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr1..Hash
u32 algo::RnullStr1_Hash(u32 prev, algo::RnullStr1 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr1..ReadStrptrMaybe
// Read fields of algo::RnullStr1 from an ascii string.
// The format of the string is the format of the algo::RnullStr1's only field
bool algo::RnullStr1_ReadStrptrMaybe(algo::RnullStr1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr1..Print
// print string representation of algo::RnullStr1 to string LHS, no header -- cprint:algo.RnullStr1.String
void algo::RnullStr1_Print(algo::RnullStr1 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr10.ch.Print
void algo::ch_Print(algo::RnullStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.RnullStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr10& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 10; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr10..Hash
u32 algo::RnullStr10_Hash(u32 prev, algo::RnullStr10 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr10..ReadStrptrMaybe
// Read fields of algo::RnullStr10 from an ascii string.
// The format of the string is the format of the algo::RnullStr10's only field
bool algo::RnullStr10_ReadStrptrMaybe(algo::RnullStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr10..Print
// print string representation of algo::RnullStr10 to string LHS, no header -- cprint:algo.RnullStr10.String
void algo::RnullStr10_Print(algo::RnullStr10 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr100.ch.Print
void algo::ch_Print(algo::RnullStr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.RnullStr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr100& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 100; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr100..Hash
u32 algo::RnullStr100_Hash(u32 prev, const algo::RnullStr100 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr100..ReadStrptrMaybe
// Read fields of algo::RnullStr100 from an ascii string.
// The format of the string is the format of the algo::RnullStr100's only field
bool algo::RnullStr100_ReadStrptrMaybe(algo::RnullStr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr100..Print
// print string representation of algo::RnullStr100 to string LHS, no header -- cprint:algo.RnullStr100.String
void algo::RnullStr100_Print(algo::RnullStr100 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr1000.ch.Print
void algo::ch_Print(algo::RnullStr1000& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr1000.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr1000& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1000) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1000");
    }
    return retval;
}

// --- algo.RnullStr1000.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr1000& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 1000);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 1000; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr1000..Hash
u32 algo::RnullStr1000_Hash(u32 prev, const algo::RnullStr1000 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr1000..ReadStrptrMaybe
// Read fields of algo::RnullStr1000 from an ascii string.
// The format of the string is the format of the algo::RnullStr1000's only field
bool algo::RnullStr1000_ReadStrptrMaybe(algo::RnullStr1000 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr1000..Print
// print string representation of algo::RnullStr1000 to string LHS, no header -- cprint:algo.RnullStr1000.String
void algo::RnullStr1000_Print(algo::RnullStr1000 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr11.ch.Print
void algo::ch_Print(algo::RnullStr11& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr11.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr11& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.RnullStr11.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr11& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 11; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr11..Hash
u32 algo::RnullStr11_Hash(u32 prev, const algo::RnullStr11 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr11..ReadStrptrMaybe
// Read fields of algo::RnullStr11 from an ascii string.
// The format of the string is the format of the algo::RnullStr11's only field
bool algo::RnullStr11_ReadStrptrMaybe(algo::RnullStr11 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr11..Print
// print string representation of algo::RnullStr11 to string LHS, no header -- cprint:algo.RnullStr11.String
void algo::RnullStr11_Print(algo::RnullStr11 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr12.ch.Print
void algo::ch_Print(algo::RnullStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.RnullStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr12& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 12; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr12..Hash
u32 algo::RnullStr12_Hash(u32 prev, const algo::RnullStr12 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr12..ReadStrptrMaybe
// Read fields of algo::RnullStr12 from an ascii string.
// The format of the string is the format of the algo::RnullStr12's only field
bool algo::RnullStr12_ReadStrptrMaybe(algo::RnullStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr12..Print
// print string representation of algo::RnullStr12 to string LHS, no header -- cprint:algo.RnullStr12.String
void algo::RnullStr12_Print(algo::RnullStr12 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr129.ch.Print
void algo::ch_Print(algo::RnullStr129& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr129.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr129& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 129) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 129");
    }
    return retval;
}

// --- algo.RnullStr129.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr129& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 129);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 129; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr129..Hash
u32 algo::RnullStr129_Hash(u32 prev, const algo::RnullStr129 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr129..ReadStrptrMaybe
// Read fields of algo::RnullStr129 from an ascii string.
// The format of the string is the format of the algo::RnullStr129's only field
bool algo::RnullStr129_ReadStrptrMaybe(algo::RnullStr129 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr129..Print
// print string representation of algo::RnullStr129 to string LHS, no header -- cprint:algo.RnullStr129.String
void algo::RnullStr129_Print(algo::RnullStr129 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr13.ch.Print
void algo::ch_Print(algo::RnullStr13& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr13.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr13& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 13) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 13");
    }
    return retval;
}

// --- algo.RnullStr13.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr13& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 13);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 13; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr13..Hash
u32 algo::RnullStr13_Hash(u32 prev, const algo::RnullStr13 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr13..ReadStrptrMaybe
// Read fields of algo::RnullStr13 from an ascii string.
// The format of the string is the format of the algo::RnullStr13's only field
bool algo::RnullStr13_ReadStrptrMaybe(algo::RnullStr13 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr13..Print
// print string representation of algo::RnullStr13 to string LHS, no header -- cprint:algo.RnullStr13.String
void algo::RnullStr13_Print(algo::RnullStr13 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr14.ch.Print
void algo::ch_Print(algo::RnullStr14& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr14.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr14& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 14) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 14");
    }
    return retval;
}

// --- algo.RnullStr14.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr14& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 14);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 14; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr14..Hash
u32 algo::RnullStr14_Hash(u32 prev, const algo::RnullStr14 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr14..ReadStrptrMaybe
// Read fields of algo::RnullStr14 from an ascii string.
// The format of the string is the format of the algo::RnullStr14's only field
bool algo::RnullStr14_ReadStrptrMaybe(algo::RnullStr14 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr14..Print
// print string representation of algo::RnullStr14 to string LHS, no header -- cprint:algo.RnullStr14.String
void algo::RnullStr14_Print(algo::RnullStr14 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr15.ch.Print
void algo::ch_Print(algo::RnullStr15& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr15.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr15& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 15) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 15");
    }
    return retval;
}

// --- algo.RnullStr15.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr15& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 15);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 15; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr15..Hash
u32 algo::RnullStr15_Hash(u32 prev, const algo::RnullStr15 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr15..ReadStrptrMaybe
// Read fields of algo::RnullStr15 from an ascii string.
// The format of the string is the format of the algo::RnullStr15's only field
bool algo::RnullStr15_ReadStrptrMaybe(algo::RnullStr15 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr15..Print
// print string representation of algo::RnullStr15 to string LHS, no header -- cprint:algo.RnullStr15.String
void algo::RnullStr15_Print(algo::RnullStr15 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr151.ch.Print
void algo::ch_Print(algo::RnullStr151& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr151.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr151& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 151) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 151");
    }
    return retval;
}

// --- algo.RnullStr151.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr151& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 151);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 151; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr151..Hash
u32 algo::RnullStr151_Hash(u32 prev, const algo::RnullStr151 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr151..ReadStrptrMaybe
// Read fields of algo::RnullStr151 from an ascii string.
// The format of the string is the format of the algo::RnullStr151's only field
bool algo::RnullStr151_ReadStrptrMaybe(algo::RnullStr151 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr151..Print
// print string representation of algo::RnullStr151 to string LHS, no header -- cprint:algo.RnullStr151.String
void algo::RnullStr151_Print(algo::RnullStr151 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr16.ch.Print
void algo::ch_Print(algo::RnullStr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.RnullStr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 16; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr16..Hash
u32 algo::RnullStr16_Hash(u32 prev, algo::RnullStr16 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr16..ReadStrptrMaybe
// Read fields of algo::RnullStr16 from an ascii string.
// The format of the string is the format of the algo::RnullStr16's only field
bool algo::RnullStr16_ReadStrptrMaybe(algo::RnullStr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr16..Print
// print string representation of algo::RnullStr16 to string LHS, no header -- cprint:algo.RnullStr16.String
void algo::RnullStr16_Print(algo::RnullStr16 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr17.ch.Print
void algo::ch_Print(algo::RnullStr17& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr17.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr17& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 17) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 17");
    }
    return retval;
}

// --- algo.RnullStr17.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr17& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 17);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 17; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr17..Hash
u32 algo::RnullStr17_Hash(u32 prev, const algo::RnullStr17 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr17..ReadStrptrMaybe
// Read fields of algo::RnullStr17 from an ascii string.
// The format of the string is the format of the algo::RnullStr17's only field
bool algo::RnullStr17_ReadStrptrMaybe(algo::RnullStr17 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr17..Print
// print string representation of algo::RnullStr17 to string LHS, no header -- cprint:algo.RnullStr17.String
void algo::RnullStr17_Print(algo::RnullStr17 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr18.ch.Print
void algo::ch_Print(algo::RnullStr18& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr18.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr18& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 18) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 18");
    }
    return retval;
}

// --- algo.RnullStr18.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr18& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 18);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 18; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr18..Hash
u32 algo::RnullStr18_Hash(u32 prev, algo::RnullStr18 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr18..ReadStrptrMaybe
// Read fields of algo::RnullStr18 from an ascii string.
// The format of the string is the format of the algo::RnullStr18's only field
bool algo::RnullStr18_ReadStrptrMaybe(algo::RnullStr18 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr18..Print
// print string representation of algo::RnullStr18 to string LHS, no header -- cprint:algo.RnullStr18.String
void algo::RnullStr18_Print(algo::RnullStr18 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr19.ch.Print
void algo::ch_Print(algo::RnullStr19& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr19.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr19& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 19) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 19");
    }
    return retval;
}

// --- algo.RnullStr19.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr19& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 19);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 19; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr19..Hash
u32 algo::RnullStr19_Hash(u32 prev, const algo::RnullStr19 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr19..ReadStrptrMaybe
// Read fields of algo::RnullStr19 from an ascii string.
// The format of the string is the format of the algo::RnullStr19's only field
bool algo::RnullStr19_ReadStrptrMaybe(algo::RnullStr19 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr19..Print
// print string representation of algo::RnullStr19 to string LHS, no header -- cprint:algo.RnullStr19.String
void algo::RnullStr19_Print(algo::RnullStr19 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr2.ch.Print
void algo::ch_Print(algo::RnullStr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.RnullStr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr2& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 2; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr2..Hash
u32 algo::RnullStr2_Hash(u32 prev, algo::RnullStr2 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr2..ReadStrptrMaybe
// Read fields of algo::RnullStr2 from an ascii string.
// The format of the string is the format of the algo::RnullStr2's only field
bool algo::RnullStr2_ReadStrptrMaybe(algo::RnullStr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr2..Print
// print string representation of algo::RnullStr2 to string LHS, no header -- cprint:algo.RnullStr2.String
void algo::RnullStr2_Print(algo::RnullStr2 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr20.ch.Print
void algo::ch_Print(algo::RnullStr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.RnullStr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr20& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 20; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr20..Hash
u32 algo::RnullStr20_Hash(u32 prev, algo::RnullStr20 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr20..ReadStrptrMaybe
// Read fields of algo::RnullStr20 from an ascii string.
// The format of the string is the format of the algo::RnullStr20's only field
bool algo::RnullStr20_ReadStrptrMaybe(algo::RnullStr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr20..Print
// print string representation of algo::RnullStr20 to string LHS, no header -- cprint:algo.RnullStr20.String
void algo::RnullStr20_Print(algo::RnullStr20 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr21.ch.Print
void algo::ch_Print(algo::RnullStr21& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr21.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr21& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 21) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 21");
    }
    return retval;
}

// --- algo.RnullStr21.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr21& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 21);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 21; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr21..Hash
u32 algo::RnullStr21_Hash(u32 prev, const algo::RnullStr21 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr21..ReadStrptrMaybe
// Read fields of algo::RnullStr21 from an ascii string.
// The format of the string is the format of the algo::RnullStr21's only field
bool algo::RnullStr21_ReadStrptrMaybe(algo::RnullStr21 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr21..Print
// print string representation of algo::RnullStr21 to string LHS, no header -- cprint:algo.RnullStr21.String
void algo::RnullStr21_Print(algo::RnullStr21 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr24.ch.Print
void algo::ch_Print(algo::RnullStr24& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr24.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr24& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 24) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 24");
    }
    return retval;
}

// --- algo.RnullStr24.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr24& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 24);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 24; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr24..Hash
u32 algo::RnullStr24_Hash(u32 prev, const algo::RnullStr24 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr24..ReadStrptrMaybe
// Read fields of algo::RnullStr24 from an ascii string.
// The format of the string is the format of the algo::RnullStr24's only field
bool algo::RnullStr24_ReadStrptrMaybe(algo::RnullStr24 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr24..Print
// print string representation of algo::RnullStr24 to string LHS, no header -- cprint:algo.RnullStr24.String
void algo::RnullStr24_Print(algo::RnullStr24 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr25.ch.Print
void algo::ch_Print(algo::RnullStr25& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr25.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr25& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 25) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 25");
    }
    return retval;
}

// --- algo.RnullStr25.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr25& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 25);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 25; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr25..Hash
u32 algo::RnullStr25_Hash(u32 prev, const algo::RnullStr25 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr25..ReadStrptrMaybe
// Read fields of algo::RnullStr25 from an ascii string.
// The format of the string is the format of the algo::RnullStr25's only field
bool algo::RnullStr25_ReadStrptrMaybe(algo::RnullStr25 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr25..Print
// print string representation of algo::RnullStr25 to string LHS, no header -- cprint:algo.RnullStr25.String
void algo::RnullStr25_Print(algo::RnullStr25 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr28.ch.Print
void algo::ch_Print(algo::RnullStr28& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr28.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr28& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 28) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 28");
    }
    return retval;
}

// --- algo.RnullStr28.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr28& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 28);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 28; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr28..Hash
u32 algo::RnullStr28_Hash(u32 prev, const algo::RnullStr28 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr28..ReadStrptrMaybe
// Read fields of algo::RnullStr28 from an ascii string.
// The format of the string is the format of the algo::RnullStr28's only field
bool algo::RnullStr28_ReadStrptrMaybe(algo::RnullStr28 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr28..Print
// print string representation of algo::RnullStr28 to string LHS, no header -- cprint:algo.RnullStr28.String
void algo::RnullStr28_Print(algo::RnullStr28 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr3.ch.Print
void algo::ch_Print(algo::RnullStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.RnullStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr3& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 3; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr3..Hash
u32 algo::RnullStr3_Hash(u32 prev, algo::RnullStr3 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr3..ReadStrptrMaybe
// Read fields of algo::RnullStr3 from an ascii string.
// The format of the string is the format of the algo::RnullStr3's only field
bool algo::RnullStr3_ReadStrptrMaybe(algo::RnullStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr3..Print
// print string representation of algo::RnullStr3 to string LHS, no header -- cprint:algo.RnullStr3.String
void algo::RnullStr3_Print(algo::RnullStr3 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr30.ch.Print
void algo::ch_Print(algo::RnullStr30& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr30.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr30& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 30) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 30");
    }
    return retval;
}

// --- algo.RnullStr30.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr30& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 30);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 30; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr30..Hash
u32 algo::RnullStr30_Hash(u32 prev, algo::RnullStr30 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr30..ReadStrptrMaybe
// Read fields of algo::RnullStr30 from an ascii string.
// The format of the string is the format of the algo::RnullStr30's only field
bool algo::RnullStr30_ReadStrptrMaybe(algo::RnullStr30 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr30..Print
// print string representation of algo::RnullStr30 to string LHS, no header -- cprint:algo.RnullStr30.String
void algo::RnullStr30_Print(algo::RnullStr30 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr32.ch.Print
void algo::ch_Print(algo::RnullStr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.RnullStr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 32; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr32..Hash
u32 algo::RnullStr32_Hash(u32 prev, algo::RnullStr32 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr32..ReadStrptrMaybe
// Read fields of algo::RnullStr32 from an ascii string.
// The format of the string is the format of the algo::RnullStr32's only field
bool algo::RnullStr32_ReadStrptrMaybe(algo::RnullStr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr32..Print
// print string representation of algo::RnullStr32 to string LHS, no header -- cprint:algo.RnullStr32.String
void algo::RnullStr32_Print(algo::RnullStr32 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr33.ch.Print
void algo::ch_Print(algo::RnullStr33& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr33.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr33& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 33) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 33");
    }
    return retval;
}

// --- algo.RnullStr33.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr33& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 33);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 33; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr33..Hash
u32 algo::RnullStr33_Hash(u32 prev, const algo::RnullStr33 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr33..ReadStrptrMaybe
// Read fields of algo::RnullStr33 from an ascii string.
// The format of the string is the format of the algo::RnullStr33's only field
bool algo::RnullStr33_ReadStrptrMaybe(algo::RnullStr33 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr33..Print
// print string representation of algo::RnullStr33 to string LHS, no header -- cprint:algo.RnullStr33.String
void algo::RnullStr33_Print(algo::RnullStr33 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr35.ch.Print
void algo::ch_Print(algo::RnullStr35& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr35.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr35& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 35) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 35");
    }
    return retval;
}

// --- algo.RnullStr35.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr35& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 35);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 35; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr35..Hash
u32 algo::RnullStr35_Hash(u32 prev, const algo::RnullStr35 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr35..ReadStrptrMaybe
// Read fields of algo::RnullStr35 from an ascii string.
// The format of the string is the format of the algo::RnullStr35's only field
bool algo::RnullStr35_ReadStrptrMaybe(algo::RnullStr35 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr35..Print
// print string representation of algo::RnullStr35 to string LHS, no header -- cprint:algo.RnullStr35.String
void algo::RnullStr35_Print(algo::RnullStr35 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr36.ch.Print
void algo::ch_Print(algo::RnullStr36& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr36.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr36& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 36) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 36");
    }
    return retval;
}

// --- algo.RnullStr36.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr36& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 36);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 36; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr36..Hash
u32 algo::RnullStr36_Hash(u32 prev, const algo::RnullStr36 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr36..ReadStrptrMaybe
// Read fields of algo::RnullStr36 from an ascii string.
// The format of the string is the format of the algo::RnullStr36's only field
bool algo::RnullStr36_ReadStrptrMaybe(algo::RnullStr36 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr36..Print
// print string representation of algo::RnullStr36 to string LHS, no header -- cprint:algo.RnullStr36.String
void algo::RnullStr36_Print(algo::RnullStr36 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr4.ch.Print
void algo::ch_Print(algo::RnullStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.RnullStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr4& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 4; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr4..Hash
u32 algo::RnullStr4_Hash(u32 prev, algo::RnullStr4 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr4..ReadStrptrMaybe
// Read fields of algo::RnullStr4 from an ascii string.
// The format of the string is the format of the algo::RnullStr4's only field
bool algo::RnullStr4_ReadStrptrMaybe(algo::RnullStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr4..Print
// print string representation of algo::RnullStr4 to string LHS, no header -- cprint:algo.RnullStr4.String
void algo::RnullStr4_Print(algo::RnullStr4 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr40.ch.Print
void algo::ch_Print(algo::RnullStr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.RnullStr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr40& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 40; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr40..Hash
u32 algo::RnullStr40_Hash(u32 prev, const algo::RnullStr40 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr40..ReadStrptrMaybe
// Read fields of algo::RnullStr40 from an ascii string.
// The format of the string is the format of the algo::RnullStr40's only field
bool algo::RnullStr40_ReadStrptrMaybe(algo::RnullStr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr40..Print
// print string representation of algo::RnullStr40 to string LHS, no header -- cprint:algo.RnullStr40.String
void algo::RnullStr40_Print(algo::RnullStr40 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr41.ch.Print
void algo::ch_Print(algo::RnullStr41& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr41.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr41& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 41) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 41");
    }
    return retval;
}

// --- algo.RnullStr41.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr41& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 41);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 41; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr41..Hash
u32 algo::RnullStr41_Hash(u32 prev, const algo::RnullStr41 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr41..ReadStrptrMaybe
// Read fields of algo::RnullStr41 from an ascii string.
// The format of the string is the format of the algo::RnullStr41's only field
bool algo::RnullStr41_ReadStrptrMaybe(algo::RnullStr41 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr41..Print
// print string representation of algo::RnullStr41 to string LHS, no header -- cprint:algo.RnullStr41.String
void algo::RnullStr41_Print(algo::RnullStr41 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr43.ch.Print
void algo::ch_Print(algo::RnullStr43& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr43.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr43& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 43) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 43");
    }
    return retval;
}

// --- algo.RnullStr43.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr43& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 43);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 43; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr43..Hash
u32 algo::RnullStr43_Hash(u32 prev, const algo::RnullStr43 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr43..ReadStrptrMaybe
// Read fields of algo::RnullStr43 from an ascii string.
// The format of the string is the format of the algo::RnullStr43's only field
bool algo::RnullStr43_ReadStrptrMaybe(algo::RnullStr43 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr43..Print
// print string representation of algo::RnullStr43 to string LHS, no header -- cprint:algo.RnullStr43.String
void algo::RnullStr43_Print(algo::RnullStr43 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr44.ch.Print
void algo::ch_Print(algo::RnullStr44& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr44.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr44& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 44) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 44");
    }
    return retval;
}

// --- algo.RnullStr44.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr44& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 44);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 44; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr44..Hash
u32 algo::RnullStr44_Hash(u32 prev, const algo::RnullStr44 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr44..ReadStrptrMaybe
// Read fields of algo::RnullStr44 from an ascii string.
// The format of the string is the format of the algo::RnullStr44's only field
bool algo::RnullStr44_ReadStrptrMaybe(algo::RnullStr44 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr44..Print
// print string representation of algo::RnullStr44 to string LHS, no header -- cprint:algo.RnullStr44.String
void algo::RnullStr44_Print(algo::RnullStr44 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr48.ch.Print
void algo::ch_Print(algo::RnullStr48& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr48.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr48& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 48) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 48");
    }
    return retval;
}

// --- algo.RnullStr48.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr48& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 48);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 48; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr48..Hash
u32 algo::RnullStr48_Hash(u32 prev, const algo::RnullStr48 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr48..ReadStrptrMaybe
// Read fields of algo::RnullStr48 from an ascii string.
// The format of the string is the format of the algo::RnullStr48's only field
bool algo::RnullStr48_ReadStrptrMaybe(algo::RnullStr48 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr48..Print
// print string representation of algo::RnullStr48 to string LHS, no header -- cprint:algo.RnullStr48.String
void algo::RnullStr48_Print(algo::RnullStr48 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr5.ch.Print
void algo::ch_Print(algo::RnullStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.RnullStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr5& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 5; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr5..Hash
u32 algo::RnullStr5_Hash(u32 prev, algo::RnullStr5 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr5..ReadStrptrMaybe
// Read fields of algo::RnullStr5 from an ascii string.
// The format of the string is the format of the algo::RnullStr5's only field
bool algo::RnullStr5_ReadStrptrMaybe(algo::RnullStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr5..Print
// print string representation of algo::RnullStr5 to string LHS, no header -- cprint:algo.RnullStr5.String
void algo::RnullStr5_Print(algo::RnullStr5 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr50.ch.Print
void algo::ch_Print(algo::RnullStr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.RnullStr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr50& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 50; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr50..Hash
u32 algo::RnullStr50_Hash(u32 prev, const algo::RnullStr50 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr50..ReadStrptrMaybe
// Read fields of algo::RnullStr50 from an ascii string.
// The format of the string is the format of the algo::RnullStr50's only field
bool algo::RnullStr50_ReadStrptrMaybe(algo::RnullStr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr50..Print
// print string representation of algo::RnullStr50 to string LHS, no header -- cprint:algo.RnullStr50.String
void algo::RnullStr50_Print(algo::RnullStr50 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr54.ch.Print
void algo::ch_Print(algo::RnullStr54& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr54.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr54& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 54) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 54");
    }
    return retval;
}

// --- algo.RnullStr54.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr54& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 54);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 54; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr54..Hash
u32 algo::RnullStr54_Hash(u32 prev, const algo::RnullStr54 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr54..ReadStrptrMaybe
// Read fields of algo::RnullStr54 from an ascii string.
// The format of the string is the format of the algo::RnullStr54's only field
bool algo::RnullStr54_ReadStrptrMaybe(algo::RnullStr54 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr54..Print
// print string representation of algo::RnullStr54 to string LHS, no header -- cprint:algo.RnullStr54.String
void algo::RnullStr54_Print(algo::RnullStr54 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr55.ch.Print
void algo::ch_Print(algo::RnullStr55& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr55.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr55& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 55) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 55");
    }
    return retval;
}

// --- algo.RnullStr55.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr55& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 55);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 55; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr55..Hash
u32 algo::RnullStr55_Hash(u32 prev, const algo::RnullStr55 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr55..ReadStrptrMaybe
// Read fields of algo::RnullStr55 from an ascii string.
// The format of the string is the format of the algo::RnullStr55's only field
bool algo::RnullStr55_ReadStrptrMaybe(algo::RnullStr55 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr55..Print
// print string representation of algo::RnullStr55 to string LHS, no header -- cprint:algo.RnullStr55.String
void algo::RnullStr55_Print(algo::RnullStr55 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr6.ch.Print
void algo::ch_Print(algo::RnullStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RnullStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr6& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr6..Hash
u32 algo::RnullStr6_Hash(u32 prev, algo::RnullStr6 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr6..ReadStrptrMaybe
// Read fields of algo::RnullStr6 from an ascii string.
// The format of the string is the format of the algo::RnullStr6's only field
bool algo::RnullStr6_ReadStrptrMaybe(algo::RnullStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr6..Print
// print string representation of algo::RnullStr6 to string LHS, no header -- cprint:algo.RnullStr6.String
void algo::RnullStr6_Print(algo::RnullStr6 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr60.ch.Print
void algo::ch_Print(algo::RnullStr60& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr60.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr60& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 60) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 60");
    }
    return retval;
}

// --- algo.RnullStr60.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr60& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 60);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 60; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr60..Hash
u32 algo::RnullStr60_Hash(u32 prev, const algo::RnullStr60 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr60..ReadStrptrMaybe
// Read fields of algo::RnullStr60 from an ascii string.
// The format of the string is the format of the algo::RnullStr60's only field
bool algo::RnullStr60_ReadStrptrMaybe(algo::RnullStr60 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr60..Print
// print string representation of algo::RnullStr60 to string LHS, no header -- cprint:algo.RnullStr60.String
void algo::RnullStr60_Print(algo::RnullStr60 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr62.ch.Print
void algo::ch_Print(algo::RnullStr62& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr62.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr62& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 62) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 62");
    }
    return retval;
}

// --- algo.RnullStr62.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr62& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 62);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 62; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr62..Hash
u32 algo::RnullStr62_Hash(u32 prev, const algo::RnullStr62 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr62..ReadStrptrMaybe
// Read fields of algo::RnullStr62 from an ascii string.
// The format of the string is the format of the algo::RnullStr62's only field
bool algo::RnullStr62_ReadStrptrMaybe(algo::RnullStr62 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr62..Print
// print string representation of algo::RnullStr62 to string LHS, no header -- cprint:algo.RnullStr62.String
void algo::RnullStr62_Print(algo::RnullStr62 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr66.ch.Print
void algo::ch_Print(algo::RnullStr66& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr66.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr66& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 66) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 66");
    }
    return retval;
}

// --- algo.RnullStr66.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr66& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 66);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 66; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr66..Hash
u32 algo::RnullStr66_Hash(u32 prev, const algo::RnullStr66 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr66..ReadStrptrMaybe
// Read fields of algo::RnullStr66 from an ascii string.
// The format of the string is the format of the algo::RnullStr66's only field
bool algo::RnullStr66_ReadStrptrMaybe(algo::RnullStr66 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr66..Print
// print string representation of algo::RnullStr66 to string LHS, no header -- cprint:algo.RnullStr66.String
void algo::RnullStr66_Print(algo::RnullStr66 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr6_U32.ch.Print
void algo::ch_Print(algo::RnullStr6_U32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr6_U32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr6_U32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RnullStr6_U32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr6_U32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr6_U32.ch.qGetnum
// Convert field to numeric value. If the value is too large
// for the target type, the result is undefined.
// The special case of an empty string is evaluated to zero.
static u32 algo::ch_qGetnum(algo::RnullStr6_U32& parent, u32 &ok) {
    (void)ok;
    u64 val = 0;
    algo::strptr str = ch_Getary(parent);
    if (elems_N(str)>0) { // empty string maps to zero
        val = aParseNum8(str, ok);
    }
    return u32(val);
}

// --- algo.RnullStr6_U32.ch.GetnumDflt
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32 algo::ch_GetnumDflt(algo::RnullStr6_U32& parent, u32 dflt) {
    u32 ok = 1;
    u32 result = ch_qGetnum(parent, ok);
    return ok ? result : dflt;
}

// --- algo.RnullStr6_U32.ch.Geti64
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64 algo::ch_Geti64(algo::RnullStr6_U32& parent, bool &out_ok) {
    u32 ok = 1;
    i64 result = ch_qGetnum(parent, ok);
    out_ok = ok != 0;
    return result;
}

// --- algo.RnullStr6_U32.ch.SetnumMaybe
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool algo::ch_SetnumMaybe(algo::RnullStr6_U32& parent, i64 rhs) {
    char buf[128];
    int length = 0;
    int charpos = 64;
    u64 val = rhs;
    length = algo::u32_FmtBuf(val, (u8*)buf + charpos);
    bool retval = length <= 6;
    if (retval) {
        ch_SetStrptr(parent, algo::strptr(buf + charpos, length));
    }
    return retval;
}

// --- algo.RnullStr6_U32..Hash
u32 algo::RnullStr6_U32_Hash(u32 prev, const algo::RnullStr6_U32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr6_U32..ReadStrptrMaybe
// Read fields of algo::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the algo::RnullStr6_U32's only field
bool algo::RnullStr6_U32_ReadStrptrMaybe(algo::RnullStr6_U32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr6_U32..Print
// print string representation of algo::RnullStr6_U32 to string LHS, no header -- cprint:algo.RnullStr6_U32.String
void algo::RnullStr6_U32_Print(algo::RnullStr6_U32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr7.ch.Print
void algo::ch_Print(algo::RnullStr7& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr7.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr7& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.RnullStr7.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr7& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 7; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr7..Hash
u32 algo::RnullStr7_Hash(u32 prev, algo::RnullStr7 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr7..ReadStrptrMaybe
// Read fields of algo::RnullStr7 from an ascii string.
// The format of the string is the format of the algo::RnullStr7's only field
bool algo::RnullStr7_ReadStrptrMaybe(algo::RnullStr7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr7..Print
// print string representation of algo::RnullStr7 to string LHS, no header -- cprint:algo.RnullStr7.String
void algo::RnullStr7_Print(algo::RnullStr7 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr8.ch.Print
void algo::ch_Print(algo::RnullStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.RnullStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr8& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 8; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr8..Hash
u32 algo::RnullStr8_Hash(u32 prev, algo::RnullStr8 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr8..ReadStrptrMaybe
// Read fields of algo::RnullStr8 from an ascii string.
// The format of the string is the format of the algo::RnullStr8's only field
bool algo::RnullStr8_ReadStrptrMaybe(algo::RnullStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr8..Print
// print string representation of algo::RnullStr8 to string LHS, no header -- cprint:algo.RnullStr8.String
void algo::RnullStr8_Print(algo::RnullStr8 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr80.ch.Print
void algo::ch_Print(algo::RnullStr80& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr80.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr80& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 80) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 80");
    }
    return retval;
}

// --- algo.RnullStr80.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr80& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 80);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 80; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr80..Hash
u32 algo::RnullStr80_Hash(u32 prev, const algo::RnullStr80 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr80..ReadStrptrMaybe
// Read fields of algo::RnullStr80 from an ascii string.
// The format of the string is the format of the algo::RnullStr80's only field
bool algo::RnullStr80_ReadStrptrMaybe(algo::RnullStr80 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr80..Print
// print string representation of algo::RnullStr80 to string LHS, no header -- cprint:algo.RnullStr80.String
void algo::RnullStr80_Print(algo::RnullStr80 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RnullStr9.ch.Print
void algo::ch_Print(algo::RnullStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RnullStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RnullStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.RnullStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RnullStr9& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 9; j++) {
        parent.ch[j] = 0;
    }
}

// --- algo.RnullStr9..Hash
u32 algo::RnullStr9_Hash(u32 prev, const algo::RnullStr9 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RnullStr9..ReadStrptrMaybe
// Read fields of algo::RnullStr9 from an ascii string.
// The format of the string is the format of the algo::RnullStr9's only field
bool algo::RnullStr9_ReadStrptrMaybe(algo::RnullStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RnullStr9..Print
// print string representation of algo::RnullStr9 to string LHS, no header -- cprint:algo.RnullStr9.String
void algo::RnullStr9_Print(algo::RnullStr9 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr10.ch.Print
void algo::ch_Print(algo::RspaceStr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.RspaceStr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr10& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 10; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr10..Hash
u32 algo::RspaceStr10_Hash(u32 prev, const algo::RspaceStr10 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr10..ReadStrptrMaybe
// Read fields of algo::RspaceStr10 from an ascii string.
// The format of the string is the format of the algo::RspaceStr10's only field
bool algo::RspaceStr10_ReadStrptrMaybe(algo::RspaceStr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr10..Print
// print string representation of algo::RspaceStr10 to string LHS, no header -- cprint:algo.RspaceStr10.String
void algo::RspaceStr10_Print(algo::RspaceStr10 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr100.ch.Print
void algo::ch_Print(algo::RspaceStr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.RspaceStr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr100& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 100; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr100..Hash
u32 algo::RspaceStr100_Hash(u32 prev, const algo::RspaceStr100 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr100..ReadStrptrMaybe
// Read fields of algo::RspaceStr100 from an ascii string.
// The format of the string is the format of the algo::RspaceStr100's only field
bool algo::RspaceStr100_ReadStrptrMaybe(algo::RspaceStr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr100..Print
// print string representation of algo::RspaceStr100 to string LHS, no header -- cprint:algo.RspaceStr100.String
void algo::RspaceStr100_Print(algo::RspaceStr100 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr11.ch.Print
void algo::ch_Print(algo::RspaceStr11& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr11.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr11& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 11) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 11");
    }
    return retval;
}

// --- algo.RspaceStr11.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr11& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 11);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 11; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr11..Hash
u32 algo::RspaceStr11_Hash(u32 prev, const algo::RspaceStr11 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr11..ReadStrptrMaybe
// Read fields of algo::RspaceStr11 from an ascii string.
// The format of the string is the format of the algo::RspaceStr11's only field
bool algo::RspaceStr11_ReadStrptrMaybe(algo::RspaceStr11 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr11..Print
// print string representation of algo::RspaceStr11 to string LHS, no header -- cprint:algo.RspaceStr11.String
void algo::RspaceStr11_Print(algo::RspaceStr11 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr12.ch.Print
void algo::ch_Print(algo::RspaceStr12& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr12.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr12& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 12) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 12");
    }
    return retval;
}

// --- algo.RspaceStr12.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr12& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 12);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 12; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr12..Hash
u32 algo::RspaceStr12_Hash(u32 prev, algo::RspaceStr12 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr12..ReadStrptrMaybe
// Read fields of algo::RspaceStr12 from an ascii string.
// The format of the string is the format of the algo::RspaceStr12's only field
bool algo::RspaceStr12_ReadStrptrMaybe(algo::RspaceStr12 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr12..Print
// print string representation of algo::RspaceStr12 to string LHS, no header -- cprint:algo.RspaceStr12.String
void algo::RspaceStr12_Print(algo::RspaceStr12 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr16.ch.Print
void algo::ch_Print(algo::RspaceStr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.RspaceStr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 16; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr16..Hash
u32 algo::RspaceStr16_Hash(u32 prev, algo::RspaceStr16 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr16..ReadStrptrMaybe
// Read fields of algo::RspaceStr16 from an ascii string.
// The format of the string is the format of the algo::RspaceStr16's only field
bool algo::RspaceStr16_ReadStrptrMaybe(algo::RspaceStr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr16..Print
// print string representation of algo::RspaceStr16 to string LHS, no header -- cprint:algo.RspaceStr16.String
void algo::RspaceStr16_Print(algo::RspaceStr16 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr2.ch.Print
void algo::ch_Print(algo::RspaceStr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.RspaceStr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr2& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 2; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr2..Hash
u32 algo::RspaceStr2_Hash(u32 prev, algo::RspaceStr2 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr2..ReadStrptrMaybe
// Read fields of algo::RspaceStr2 from an ascii string.
// The format of the string is the format of the algo::RspaceStr2's only field
bool algo::RspaceStr2_ReadStrptrMaybe(algo::RspaceStr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr2..Print
// print string representation of algo::RspaceStr2 to string LHS, no header -- cprint:algo.RspaceStr2.String
void algo::RspaceStr2_Print(algo::RspaceStr2 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr20.ch.Print
void algo::ch_Print(algo::RspaceStr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.RspaceStr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr20& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 20; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr20..Hash
u32 algo::RspaceStr20_Hash(u32 prev, const algo::RspaceStr20 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr20..ReadStrptrMaybe
// Read fields of algo::RspaceStr20 from an ascii string.
// The format of the string is the format of the algo::RspaceStr20's only field
bool algo::RspaceStr20_ReadStrptrMaybe(algo::RspaceStr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr20..Print
// print string representation of algo::RspaceStr20 to string LHS, no header -- cprint:algo.RspaceStr20.String
void algo::RspaceStr20_Print(algo::RspaceStr20 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr200.ch.Print
void algo::ch_Print(algo::RspaceStr200& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr200.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr200& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 200) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 200");
    }
    return retval;
}

// --- algo.RspaceStr200.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr200& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 200);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 200; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr200..Hash
u32 algo::RspaceStr200_Hash(u32 prev, const algo::RspaceStr200 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr200..ReadStrptrMaybe
// Read fields of algo::RspaceStr200 from an ascii string.
// The format of the string is the format of the algo::RspaceStr200's only field
bool algo::RspaceStr200_ReadStrptrMaybe(algo::RspaceStr200 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr200..Print
// print string representation of algo::RspaceStr200 to string LHS, no header -- cprint:algo.RspaceStr200.String
void algo::RspaceStr200_Print(algo::RspaceStr200 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr21.ch.Print
void algo::ch_Print(algo::RspaceStr21& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr21.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr21& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 21) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 21");
    }
    return retval;
}

// --- algo.RspaceStr21.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr21& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 21);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 21; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr21..Hash
u32 algo::RspaceStr21_Hash(u32 prev, const algo::RspaceStr21 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr21..ReadStrptrMaybe
// Read fields of algo::RspaceStr21 from an ascii string.
// The format of the string is the format of the algo::RspaceStr21's only field
bool algo::RspaceStr21_ReadStrptrMaybe(algo::RspaceStr21 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr21..Print
// print string representation of algo::RspaceStr21 to string LHS, no header -- cprint:algo.RspaceStr21.String
void algo::RspaceStr21_Print(algo::RspaceStr21 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr24.ch.Print
void algo::ch_Print(algo::RspaceStr24& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr24.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr24& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 24) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 24");
    }
    return retval;
}

// --- algo.RspaceStr24.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr24& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 24);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 24; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr24..Hash
u32 algo::RspaceStr24_Hash(u32 prev, algo::RspaceStr24 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr24..ReadStrptrMaybe
// Read fields of algo::RspaceStr24 from an ascii string.
// The format of the string is the format of the algo::RspaceStr24's only field
bool algo::RspaceStr24_ReadStrptrMaybe(algo::RspaceStr24 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr24..Print
// print string representation of algo::RspaceStr24 to string LHS, no header -- cprint:algo.RspaceStr24.String
void algo::RspaceStr24_Print(algo::RspaceStr24 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr240.ch.Print
void algo::ch_Print(algo::RspaceStr240& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr240.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr240& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 240) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 240");
    }
    return retval;
}

// --- algo.RspaceStr240.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr240& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 240);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 240; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr240..Hash
u32 algo::RspaceStr240_Hash(u32 prev, const algo::RspaceStr240 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr240..ReadStrptrMaybe
// Read fields of algo::RspaceStr240 from an ascii string.
// The format of the string is the format of the algo::RspaceStr240's only field
bool algo::RspaceStr240_ReadStrptrMaybe(algo::RspaceStr240 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr240..Print
// print string representation of algo::RspaceStr240 to string LHS, no header -- cprint:algo.RspaceStr240.String
void algo::RspaceStr240_Print(algo::RspaceStr240 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr26.ch.Print
void algo::ch_Print(algo::RspaceStr26& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr26.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr26& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 26) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 26");
    }
    return retval;
}

// --- algo.RspaceStr26.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr26& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 26);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 26; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr26..Hash
u32 algo::RspaceStr26_Hash(u32 prev, const algo::RspaceStr26 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr26..ReadStrptrMaybe
// Read fields of algo::RspaceStr26 from an ascii string.
// The format of the string is the format of the algo::RspaceStr26's only field
bool algo::RspaceStr26_ReadStrptrMaybe(algo::RspaceStr26 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr26..Print
// print string representation of algo::RspaceStr26 to string LHS, no header -- cprint:algo.RspaceStr26.String
void algo::RspaceStr26_Print(algo::RspaceStr26 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr3.ch.Print
void algo::ch_Print(algo::RspaceStr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.RspaceStr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr3& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 3; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr3..Hash
u32 algo::RspaceStr3_Hash(u32 prev, algo::RspaceStr3 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr3..ReadStrptrMaybe
// Read fields of algo::RspaceStr3 from an ascii string.
// The format of the string is the format of the algo::RspaceStr3's only field
bool algo::RspaceStr3_ReadStrptrMaybe(algo::RspaceStr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr3..Print
// print string representation of algo::RspaceStr3 to string LHS, no header -- cprint:algo.RspaceStr3.String
void algo::RspaceStr3_Print(algo::RspaceStr3 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr31.ch.Print
void algo::ch_Print(algo::RspaceStr31& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr31.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr31& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 31) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 31");
    }
    return retval;
}

// --- algo.RspaceStr31.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr31& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 31);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 31; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr31..Hash
u32 algo::RspaceStr31_Hash(u32 prev, const algo::RspaceStr31 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr31..ReadStrptrMaybe
// Read fields of algo::RspaceStr31 from an ascii string.
// The format of the string is the format of the algo::RspaceStr31's only field
bool algo::RspaceStr31_ReadStrptrMaybe(algo::RspaceStr31 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr31..Print
// print string representation of algo::RspaceStr31 to string LHS, no header -- cprint:algo.RspaceStr31.String
void algo::RspaceStr31_Print(algo::RspaceStr31 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr32.ch.Print
void algo::ch_Print(algo::RspaceStr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.RspaceStr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 32; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr32..Hash
u32 algo::RspaceStr32_Hash(u32 prev, const algo::RspaceStr32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr32..ReadStrptrMaybe
// Read fields of algo::RspaceStr32 from an ascii string.
// The format of the string is the format of the algo::RspaceStr32's only field
bool algo::RspaceStr32_ReadStrptrMaybe(algo::RspaceStr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr32..Print
// print string representation of algo::RspaceStr32 to string LHS, no header -- cprint:algo.RspaceStr32.String
void algo::RspaceStr32_Print(algo::RspaceStr32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr4.ch.Print
void algo::ch_Print(algo::RspaceStr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.RspaceStr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr4& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 4; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr4..Hash
u32 algo::RspaceStr4_Hash(u32 prev, algo::RspaceStr4 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr4..ReadStrptrMaybe
// Read fields of algo::RspaceStr4 from an ascii string.
// The format of the string is the format of the algo::RspaceStr4's only field
bool algo::RspaceStr4_ReadStrptrMaybe(algo::RspaceStr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr4..Print
// print string representation of algo::RspaceStr4 to string LHS, no header -- cprint:algo.RspaceStr4.String
void algo::RspaceStr4_Print(algo::RspaceStr4 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr40.ch.Print
void algo::ch_Print(algo::RspaceStr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.RspaceStr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr40& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 40; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr40..Hash
u32 algo::RspaceStr40_Hash(u32 prev, const algo::RspaceStr40 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr40..ReadStrptrMaybe
// Read fields of algo::RspaceStr40 from an ascii string.
// The format of the string is the format of the algo::RspaceStr40's only field
bool algo::RspaceStr40_ReadStrptrMaybe(algo::RspaceStr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr40..Print
// print string representation of algo::RspaceStr40 to string LHS, no header -- cprint:algo.RspaceStr40.String
void algo::RspaceStr40_Print(algo::RspaceStr40 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr5.ch.Print
void algo::ch_Print(algo::RspaceStr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.RspaceStr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr5& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 5; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr5..Hash
u32 algo::RspaceStr5_Hash(u32 prev, algo::RspaceStr5 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr5..ReadStrptrMaybe
// Read fields of algo::RspaceStr5 from an ascii string.
// The format of the string is the format of the algo::RspaceStr5's only field
bool algo::RspaceStr5_ReadStrptrMaybe(algo::RspaceStr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr5..Print
// print string representation of algo::RspaceStr5 to string LHS, no header -- cprint:algo.RspaceStr5.String
void algo::RspaceStr5_Print(algo::RspaceStr5 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr50.ch.Print
void algo::ch_Print(algo::RspaceStr50& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr50.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr50& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 50) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 50");
    }
    return retval;
}

// --- algo.RspaceStr50.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr50& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 50);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 50; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr50..Hash
u32 algo::RspaceStr50_Hash(u32 prev, const algo::RspaceStr50 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr50..ReadStrptrMaybe
// Read fields of algo::RspaceStr50 from an ascii string.
// The format of the string is the format of the algo::RspaceStr50's only field
bool algo::RspaceStr50_ReadStrptrMaybe(algo::RspaceStr50 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr50..Print
// print string representation of algo::RspaceStr50 to string LHS, no header -- cprint:algo.RspaceStr50.String
void algo::RspaceStr50_Print(algo::RspaceStr50 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr6.ch.Print
void algo::ch_Print(algo::RspaceStr6& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr6.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr6& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 6) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 6");
    }
    return retval;
}

// --- algo.RspaceStr6.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr6& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 6);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 6; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr6..Hash
u32 algo::RspaceStr6_Hash(u32 prev, algo::RspaceStr6 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr6..ReadStrptrMaybe
// Read fields of algo::RspaceStr6 from an ascii string.
// The format of the string is the format of the algo::RspaceStr6's only field
bool algo::RspaceStr6_ReadStrptrMaybe(algo::RspaceStr6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr6..Print
// print string representation of algo::RspaceStr6 to string LHS, no header -- cprint:algo.RspaceStr6.String
void algo::RspaceStr6_Print(algo::RspaceStr6 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr64.ch.Print
void algo::ch_Print(algo::RspaceStr64& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr64.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr64& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 64) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 64");
    }
    return retval;
}

// --- algo.RspaceStr64.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr64& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 64);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 64; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr64..Hash
u32 algo::RspaceStr64_Hash(u32 prev, const algo::RspaceStr64 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr64..ReadStrptrMaybe
// Read fields of algo::RspaceStr64 from an ascii string.
// The format of the string is the format of the algo::RspaceStr64's only field
bool algo::RspaceStr64_ReadStrptrMaybe(algo::RspaceStr64 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr64..Print
// print string representation of algo::RspaceStr64 to string LHS, no header -- cprint:algo.RspaceStr64.String
void algo::RspaceStr64_Print(algo::RspaceStr64 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr7.ch.Print
void algo::ch_Print(algo::RspaceStr7& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr7.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr7& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 7) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 7");
    }
    return retval;
}

// --- algo.RspaceStr7.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr7& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 7);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 7; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr7..Hash
u32 algo::RspaceStr7_Hash(u32 prev, algo::RspaceStr7 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr7..ReadStrptrMaybe
// Read fields of algo::RspaceStr7 from an ascii string.
// The format of the string is the format of the algo::RspaceStr7's only field
bool algo::RspaceStr7_ReadStrptrMaybe(algo::RspaceStr7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr7..Print
// print string representation of algo::RspaceStr7 to string LHS, no header -- cprint:algo.RspaceStr7.String
void algo::RspaceStr7_Print(algo::RspaceStr7 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr8.ch.Print
void algo::ch_Print(algo::RspaceStr8& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr8.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr8& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 8) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 8");
    }
    return retval;
}

// --- algo.RspaceStr8.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr8& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 8);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 8; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr8..Hash
u32 algo::RspaceStr8_Hash(u32 prev, algo::RspaceStr8 rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr8..ReadStrptrMaybe
// Read fields of algo::RspaceStr8 from an ascii string.
// The format of the string is the format of the algo::RspaceStr8's only field
bool algo::RspaceStr8_ReadStrptrMaybe(algo::RspaceStr8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr8..Print
// print string representation of algo::RspaceStr8 to string LHS, no header -- cprint:algo.RspaceStr8.String
void algo::RspaceStr8_Print(algo::RspaceStr8 row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.RspaceStr9.ch.Print
void algo::ch_Print(algo::RspaceStr9& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.RspaceStr9.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::RspaceStr9& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 9) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 9");
    }
    return retval;
}

// --- algo.RspaceStr9.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::RspaceStr9& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 9);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    for (; j < 9; j++) {
        parent.ch[j] = ' ';
    }
}

// --- algo.RspaceStr9..Hash
u32 algo::RspaceStr9_Hash(u32 prev, const algo::RspaceStr9 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.RspaceStr9..ReadStrptrMaybe
// Read fields of algo::RspaceStr9 from an ascii string.
// The format of the string is the format of the algo::RspaceStr9's only field
bool algo::RspaceStr9_ReadStrptrMaybe(algo::RspaceStr9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.RspaceStr9..Print
// print string representation of algo::RspaceStr9 to string LHS, no header -- cprint:algo.RspaceStr9.String
void algo::RspaceStr9_Print(algo::RspaceStr9 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.SeqType..ReadStrptrMaybe
// Read fields of algo::SeqType from an ascii string.
// The format of the string is the format of the algo::SeqType's only field
bool algo::SeqType_ReadStrptrMaybe(algo::SeqType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && u64_ReadStrptrMaybe(parent.value, in_str);
    return retval;
}

// --- algo.SeqType..Print
// print string representation of algo::SeqType to string LHS, no header -- cprint:algo.SeqType.String
void algo::SeqType_Print(algo::SeqType row, algo::cstring &str) {
    u64_Print(row.value, str);
}

// --- algo.Sha1sig.sha1sig.Eq
bool algo::sha1sig_Eq(const algo::Sha1sig& parent, const algo::Sha1sig &rhs) {
    int len = 20;
    for (int i = 0; i < len; i++) {
        if (!(parent.sha1sig_elems[i] == rhs.sha1sig_elems[i])) {
            return false;
        }
    }
    return true;
}

// --- algo.Sha1sig.sha1sig.Cmp
int algo::sha1sig_Cmp(algo::Sha1sig& parent, algo::Sha1sig &rhs) {
    int len = 20;
    int retval = 0;
    for (int i = 0; i < len; i++) {
        retval = u8_Cmp(parent.sha1sig_elems[i], rhs.sha1sig_elems[i]);
        if (retval != 0) {
            return retval;
        }
    }
    return 0;
}

// --- algo.Sha1sig.sha1sig.Print
// Convert sha1sig to a string. Parent's separator is used.
void algo::sha1sig_Print(algo::Sha1sig& parent, algo::cstring &lhs) {
    int len = 20;
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            lhs << ':';
        }
        u8_Print(parent.sha1sig_elems[i], lhs);
    }
}

// --- algo.Sha1sig.sha1sig.ReadStrptrMaybe
// Read array from string
// Convert string to field. Return success value
bool algo::sha1sig_ReadStrptrMaybe(algo::Sha1sig& parent, algo::strptr in_str) {
    bool retval = true;
    for (int i=0; in_str != "" && i < sha1sig_Max(parent); i++) {
        algo::strptr token;
        algo::NextSep(in_str, ':', token);
        retval = u8_ReadStrptrMaybe(parent.sha1sig_elems[i], token);
        if (!retval) {
            break;
        }
    }
    return retval;
}

// --- algo.Smallstr1.ch.Print
void algo::ch_Print(algo::Smallstr1& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr1.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr1& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 1) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 1");
    }
    return retval;
}

// --- algo.Smallstr1.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr1& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 1);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr1..Hash
u32 algo::Smallstr1_Hash(u32 prev, const algo::Smallstr1 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr1..ReadStrptrMaybe
// Read fields of algo::Smallstr1 from an ascii string.
// The format of the string is the format of the algo::Smallstr1's only field
bool algo::Smallstr1_ReadStrptrMaybe(algo::Smallstr1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr1..Print
// print string representation of algo::Smallstr1 to string LHS, no header -- cprint:algo.Smallstr1.String
void algo::Smallstr1_Print(algo::Smallstr1 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr10.ch.Print
void algo::ch_Print(algo::Smallstr10& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr10.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr10& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 10) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 10");
    }
    return retval;
}

// --- algo.Smallstr10.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr10& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 10);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr10..Hash
u32 algo::Smallstr10_Hash(u32 prev, const algo::Smallstr10 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr10..ReadStrptrMaybe
// Read fields of algo::Smallstr10 from an ascii string.
// The format of the string is the format of the algo::Smallstr10's only field
bool algo::Smallstr10_ReadStrptrMaybe(algo::Smallstr10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr10..Print
// print string representation of algo::Smallstr10 to string LHS, no header -- cprint:algo.Smallstr10.String
void algo::Smallstr10_Print(algo::Smallstr10 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr100.ch.Print
void algo::ch_Print(algo::Smallstr100& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr100.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr100& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 100) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 100");
    }
    return retval;
}

// --- algo.Smallstr100.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr100& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 100);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr100..Hash
u32 algo::Smallstr100_Hash(u32 prev, const algo::Smallstr100 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr100..ReadStrptrMaybe
// Read fields of algo::Smallstr100 from an ascii string.
// The format of the string is the format of the algo::Smallstr100's only field
bool algo::Smallstr100_ReadStrptrMaybe(algo::Smallstr100 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr100..Print
// print string representation of algo::Smallstr100 to string LHS, no header -- cprint:algo.Smallstr100.String
void algo::Smallstr100_Print(algo::Smallstr100 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr16.ch.Print
void algo::ch_Print(algo::Smallstr16& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr16.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr16& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 16) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 16");
    }
    return retval;
}

// --- algo.Smallstr16.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr16& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 16);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr16..Hash
u32 algo::Smallstr16_Hash(u32 prev, const algo::Smallstr16 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr16..ReadStrptrMaybe
// Read fields of algo::Smallstr16 from an ascii string.
// The format of the string is the format of the algo::Smallstr16's only field
bool algo::Smallstr16_ReadStrptrMaybe(algo::Smallstr16 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr16..Print
// print string representation of algo::Smallstr16 to string LHS, no header -- cprint:algo.Smallstr16.String
void algo::Smallstr16_Print(algo::Smallstr16 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr2.ch.Print
void algo::ch_Print(algo::Smallstr2& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr2.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr2& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 2) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 2");
    }
    return retval;
}

// --- algo.Smallstr2.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr2& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 2);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr2..Hash
u32 algo::Smallstr2_Hash(u32 prev, const algo::Smallstr2 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr2..ReadStrptrMaybe
// Read fields of algo::Smallstr2 from an ascii string.
// The format of the string is the format of the algo::Smallstr2's only field
bool algo::Smallstr2_ReadStrptrMaybe(algo::Smallstr2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr2..Print
// print string representation of algo::Smallstr2 to string LHS, no header -- cprint:algo.Smallstr2.String
void algo::Smallstr2_Print(algo::Smallstr2 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr20.ch.Print
void algo::ch_Print(algo::Smallstr20& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr20.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr20& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 20) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 20");
    }
    return retval;
}

// --- algo.Smallstr20.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr20& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 20);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr20..Hash
u32 algo::Smallstr20_Hash(u32 prev, const algo::Smallstr20 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr20..ReadStrptrMaybe
// Read fields of algo::Smallstr20 from an ascii string.
// The format of the string is the format of the algo::Smallstr20's only field
bool algo::Smallstr20_ReadStrptrMaybe(algo::Smallstr20 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr20..Print
// print string representation of algo::Smallstr20 to string LHS, no header -- cprint:algo.Smallstr20.String
void algo::Smallstr20_Print(algo::Smallstr20 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr25.ch.Print
void algo::ch_Print(algo::Smallstr25& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr25.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr25& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 25) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 25");
    }
    return retval;
}

// --- algo.Smallstr25.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr25& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 25);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr25..Hash
u32 algo::Smallstr25_Hash(u32 prev, const algo::Smallstr25 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr25..ReadStrptrMaybe
// Read fields of algo::Smallstr25 from an ascii string.
// The format of the string is the format of the algo::Smallstr25's only field
bool algo::Smallstr25_ReadStrptrMaybe(algo::Smallstr25 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr25..Print
// print string representation of algo::Smallstr25 to string LHS, no header -- cprint:algo.Smallstr25.String
void algo::Smallstr25_Print(algo::Smallstr25 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr250.ch.Print
void algo::ch_Print(algo::Smallstr250& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr250.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr250& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 250) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 250");
    }
    return retval;
}

// --- algo.Smallstr250.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr250& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 250);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr250..Hash
u32 algo::Smallstr250_Hash(u32 prev, const algo::Smallstr250 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr250..ReadStrptrMaybe
// Read fields of algo::Smallstr250 from an ascii string.
// The format of the string is the format of the algo::Smallstr250's only field
bool algo::Smallstr250_ReadStrptrMaybe(algo::Smallstr250 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr250..Print
// print string representation of algo::Smallstr250 to string LHS, no header -- cprint:algo.Smallstr250.String
void algo::Smallstr250_Print(algo::Smallstr250 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr3.ch.Print
void algo::ch_Print(algo::Smallstr3& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr3.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr3& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 3) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 3");
    }
    return retval;
}

// --- algo.Smallstr3.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr3& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 3);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr3..Hash
u32 algo::Smallstr3_Hash(u32 prev, const algo::Smallstr3 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr3..ReadStrptrMaybe
// Read fields of algo::Smallstr3 from an ascii string.
// The format of the string is the format of the algo::Smallstr3's only field
bool algo::Smallstr3_ReadStrptrMaybe(algo::Smallstr3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr3..Print
// print string representation of algo::Smallstr3 to string LHS, no header -- cprint:algo.Smallstr3.String
void algo::Smallstr3_Print(algo::Smallstr3 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr30.ch.Print
void algo::ch_Print(algo::Smallstr30& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr30.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr30& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 30) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 30");
    }
    return retval;
}

// --- algo.Smallstr30.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr30& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 30);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr30..Hash
u32 algo::Smallstr30_Hash(u32 prev, const algo::Smallstr30 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr30..ReadStrptrMaybe
// Read fields of algo::Smallstr30 from an ascii string.
// The format of the string is the format of the algo::Smallstr30's only field
bool algo::Smallstr30_ReadStrptrMaybe(algo::Smallstr30 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr30..Print
// print string representation of algo::Smallstr30 to string LHS, no header -- cprint:algo.Smallstr30.String
void algo::Smallstr30_Print(algo::Smallstr30 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr32.ch.Print
void algo::ch_Print(algo::Smallstr32& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr32.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr32& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 32) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 32");
    }
    return retval;
}

// --- algo.Smallstr32.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr32& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 32);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr32..Hash
u32 algo::Smallstr32_Hash(u32 prev, const algo::Smallstr32 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr32..ReadStrptrMaybe
// Read fields of algo::Smallstr32 from an ascii string.
// The format of the string is the format of the algo::Smallstr32's only field
bool algo::Smallstr32_ReadStrptrMaybe(algo::Smallstr32 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr32..Print
// print string representation of algo::Smallstr32 to string LHS, no header -- cprint:algo.Smallstr32.String
void algo::Smallstr32_Print(algo::Smallstr32 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr4.ch.Print
void algo::ch_Print(algo::Smallstr4& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr4.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr4& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 4) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 4");
    }
    return retval;
}

// --- algo.Smallstr4.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr4& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 4);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr4..Hash
u32 algo::Smallstr4_Hash(u32 prev, const algo::Smallstr4 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr4..ReadStrptrMaybe
// Read fields of algo::Smallstr4 from an ascii string.
// The format of the string is the format of the algo::Smallstr4's only field
bool algo::Smallstr4_ReadStrptrMaybe(algo::Smallstr4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr4..Print
// print string representation of algo::Smallstr4 to string LHS, no header -- cprint:algo.Smallstr4.String
void algo::Smallstr4_Print(algo::Smallstr4 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr40.ch.Print
void algo::ch_Print(algo::Smallstr40& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr40.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr40& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 40) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 40");
    }
    return retval;
}

// --- algo.Smallstr40.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr40& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 40);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr40..Hash
u32 algo::Smallstr40_Hash(u32 prev, const algo::Smallstr40 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr40..ReadStrptrMaybe
// Read fields of algo::Smallstr40 from an ascii string.
// The format of the string is the format of the algo::Smallstr40's only field
bool algo::Smallstr40_ReadStrptrMaybe(algo::Smallstr40 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr40..Print
// print string representation of algo::Smallstr40 to string LHS, no header -- cprint:algo.Smallstr40.String
void algo::Smallstr40_Print(algo::Smallstr40 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.Smallstr5.ch.Print
void algo::ch_Print(algo::Smallstr5& parent, algo::cstring &out) {
    ch_Addary(out, ch_Getary(parent));
}

// --- algo.Smallstr5.ch.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::ch_ReadStrptrMaybe(algo::Smallstr5& parent, algo::strptr rhs) {
    bool retval = false;
    if (rhs.n_elems <= 5) {
        ch_SetStrptr(parent, rhs);
        retval = true;
    } else {
        algo_lib::SaveBadTag("comment","text too long, limit 5");
    }
    return retval;
}

// --- algo.Smallstr5.ch.SetStrptr
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void algo::ch_SetStrptr(algo::Smallstr5& parent, const algo::strptr &rhs) {
    int len = i32_Min(rhs.n_elems, 5);
    char *rhs_elems = rhs.elems;
    int i = 0;
    int j = 0;
    for (; i < len; i++, j++) {
        parent.ch[j] = rhs_elems[i];
    }
    parent.n_ch       = u8(len);
}

// --- algo.Smallstr5..Hash
u32 algo::Smallstr5_Hash(u32 prev, const algo::Smallstr5 & rhs) {
    algo::strptr ch_strptr = ch_Getary(rhs);
    prev = ::strptr_Hash(prev, ch_strptr);
    return prev;
}

// --- algo.Smallstr5..ReadStrptrMaybe
// Read fields of algo::Smallstr5 from an ascii string.
// The format of the string is the format of the algo::Smallstr5's only field
bool algo::Smallstr5_ReadStrptrMaybe(algo::Smallstr5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::ch_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.Smallstr5..Print
// print string representation of algo::Smallstr5 to string LHS, no header -- cprint:algo.Smallstr5.String
void algo::Smallstr5_Print(algo::Smallstr5 & row, algo::cstring &str) {
    algo::ch_Print(row, str);
}

// --- algo.TermStyle.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::TermStyle& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_TermStyle_default        : ret = "default";  break;
        case algo_TermStyle_red            : ret = "red";  break;
        case algo_TermStyle_green          : ret = "green";  break;
        case algo_TermStyle_blue           : ret = "blue";  break;
        case algo_TermStyle_bold           : ret = "bold";  break;
    }
    return ret;
}

// --- algo.TermStyle.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::TermStyle& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.TermStyle.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('r','e','d'): {
                    value_SetEnum(parent,algo_TermStyle_red); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','l','u','e'): {
                    value_SetEnum(parent,algo_TermStyle_blue); ret = true; break;
                }
                case LE_STR4('b','o','l','d'): {
                    value_SetEnum(parent,algo_TermStyle_bold); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('g','r','e','e','n'): {
                    value_SetEnum(parent,algo_TermStyle_green); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('d','e','f','a','u','l','t'): {
                    value_SetEnum(parent,algo_TermStyle_default); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.TermStyle.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::TermStyle& parent, algo::strptr rhs, algo_TermStyleEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.TermStyle.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.TermStyle..ReadStrptrMaybe
// Read fields of algo::TermStyle from an ascii string.
// The format of the string is the format of the algo::TermStyle's only field
bool algo::TermStyle_ReadStrptrMaybe(algo::TermStyle &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.TermStyle..Print
// print string representation of algo::TermStyle to string LHS, no header -- cprint:algo.TermStyle.String
void algo::TermStyle_Print(algo::TermStyle row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.TextJust.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo::value_ToCstr(const algo::TextJust& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_TextJust_j_right         : ret = "j_right";  break;
        case algo_TextJust_j_left          : ret = "j_left";  break;
        case algo_TextJust_j_center        : ret = "j_center";  break;
    }
    return ret;
}

// --- algo.TextJust.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo::value_Print(const algo::TextJust& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo.TextJust.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo::value_SetStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('j','_','l','e','f','t'): {
                    value_SetEnum(parent,algo_TextJust_j_left); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('j','_','r','i','g','h','t'): {
                    value_SetEnum(parent,algo_TextJust_j_right); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('j','_','c','e','n','t','e','r'): {
                    value_SetEnum(parent,algo_TextJust_j_center); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo.TextJust.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo::value_SetStrptr(algo::TextJust& parent, algo::strptr rhs, algo_TextJustEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo.TextJust.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo::value_ReadStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo.TextJust..ReadStrptrMaybe
// Read fields of algo::TextJust from an ascii string.
// The format of the string is the format of the algo::TextJust's only field
bool algo::TextJust_ReadStrptrMaybe(algo::TextJust &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.TextJust..Print
// print string representation of algo::TextJust to string LHS, no header -- cprint:algo.TextJust.String
void algo::TextJust_Print(algo::TextJust row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.TstampCache..Init
// Set all fields to initial values.
void algo::TstampCache_Init(algo::TstampCache& parent) {
    parent.sec_location = i8(0);
    parent.min_location = i8(0);
    parent.nano_location = i8(0);
    parent.nano_size = i8(0);
    parent.cacheable = bool(false);
    parent.gmtQ = bool(false);
}

// --- algo.U16Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U16Dec2& parent, double val) {
    double intval = val * 100;
    u16 minval = u16(0ULL);
    u16 maxval = u16(65535ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U16Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U16Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U16Dec2.value.Print
void algo::value_Print(algo::U16Dec2& parent, cstring &outstr) {
    u16 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U16Dec2..ReadStrptrMaybe
// Read fields of algo::U16Dec2 from an ascii string.
// The format of the string is the format of the algo::U16Dec2's only field
bool algo::U16Dec2_ReadStrptrMaybe(algo::U16Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U16Dec2..Print
// print string representation of algo::U16Dec2 to string LHS, no header -- cprint:algo.U16Dec2.String
void algo::U16Dec2_Print(algo::U16Dec2 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec1.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec1& parent, double val) {
    double intval = val * 10;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec1.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec1& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 1) { // ignore digits after 1'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 1) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec1.value.Print
void algo::value_Print(algo::U32Dec1& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 1, value_start, true);
}

// --- algo.U32Dec1..ReadStrptrMaybe
// Read fields of algo::U32Dec1 from an ascii string.
// The format of the string is the format of the algo::U32Dec1's only field
bool algo::U32Dec1_ReadStrptrMaybe(algo::U32Dec1 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec1..Print
// print string representation of algo::U32Dec1 to string LHS, no header -- cprint:algo.U32Dec1.String
void algo::U32Dec1_Print(algo::U32Dec1 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec2& parent, double val) {
    double intval = val * 100;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec2.value.Print
void algo::value_Print(algo::U32Dec2& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U32Dec2..ReadStrptrMaybe
// Read fields of algo::U32Dec2 from an ascii string.
// The format of the string is the format of the algo::U32Dec2's only field
bool algo::U32Dec2_ReadStrptrMaybe(algo::U32Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec2..Print
// print string representation of algo::U32Dec2 to string LHS, no header -- cprint:algo.U32Dec2.String
void algo::U32Dec2_Print(algo::U32Dec2 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec3.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec3& parent, double val) {
    double intval = val * 1000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec3.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec3& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 3) { // ignore digits after 3'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 3) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec3.value.Print
void algo::value_Print(algo::U32Dec3& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 3, value_start, true);
}

// --- algo.U32Dec3..ReadStrptrMaybe
// Read fields of algo::U32Dec3 from an ascii string.
// The format of the string is the format of the algo::U32Dec3's only field
bool algo::U32Dec3_ReadStrptrMaybe(algo::U32Dec3 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec3..Print
// print string representation of algo::U32Dec3 to string LHS, no header -- cprint:algo.U32Dec3.String
void algo::U32Dec3_Print(algo::U32Dec3 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec4& parent, double val) {
    double intval = val * 10000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec4.value.Print
void algo::value_Print(algo::U32Dec4& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.U32Dec4..ReadStrptrMaybe
// Read fields of algo::U32Dec4 from an ascii string.
// The format of the string is the format of the algo::U32Dec4's only field
bool algo::U32Dec4_ReadStrptrMaybe(algo::U32Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec4..Print
// print string representation of algo::U32Dec4 to string LHS, no header -- cprint:algo.U32Dec4.String
void algo::U32Dec4_Print(algo::U32Dec4 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U32Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U32Dec5& parent, double val) {
    double intval = val * 100000;
    u32 minval = u32(0ULL);
    u32 maxval = u32(4294967295ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U32Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U32Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U32Dec5.value.Print
void algo::value_Print(algo::U32Dec5& parent, cstring &outstr) {
    u32 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.U32Dec5..ReadStrptrMaybe
// Read fields of algo::U32Dec5 from an ascii string.
// The format of the string is the format of the algo::U32Dec5's only field
bool algo::U32Dec5_ReadStrptrMaybe(algo::U32Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U32Dec5..Print
// print string representation of algo::U32Dec5 to string LHS, no header -- cprint:algo.U32Dec5.String
void algo::U32Dec5_Print(algo::U32Dec5 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Ary.ary.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u64> algo::ary_Addary(algo::U64Ary& parent, algo::aryptr<u64> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.ary_elems && rhs.elems < parent.ary_elems + parent.ary_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("algo.tary_alias  field:algo.U64Ary.ary  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    ary_Reserve(parent, nnew); // reserve space
    int at = parent.ary_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.ary_elems + at + i) u64(rhs[i]);
        parent.ary_n++;
    }
    return algo::aryptr<u64>(parent.ary_elems + at, nnew);
}

// --- algo.U64Ary.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u64& algo::ary_Alloc(algo::U64Ary& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u64 *elems = parent.ary_elems;
    new (elems + at) u64(0); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.U64Ary.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u64& algo::ary_AllocAt(algo::U64Ary& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo.bad_alloc_at  field:algo.U64Ary.ary  comment:'index out of range'");
    }
    u64 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u64));
    new (elems + at) u64(0); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo.U64Ary.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64> algo::ary_AllocN(algo::U64Ary& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u64 *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u64(0); // construct new element, default initialize
    }
    parent.ary_n = new_n;
    return algo::aryptr<u64>(elems + old_n, n_elems);
}

// --- algo.U64Ary.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo::ary_Remove(algo::U64Ary& parent, u32 i) {
    u32 lim = parent.ary_n;
    u64 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u64) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo.U64Ary.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo::ary_RemoveLast(algo::U64Ary& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- algo.U64Ary.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo::ary_AbsReserve(algo::U64Ary& parent, int n) {
    u32 old_max  = parent.ary_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.ary_elems, old_max * sizeof(u64), new_max * sizeof(u64));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo.tary_nomem  field:algo.U64Ary.ary  comment:'out of memory'");
        }
        parent.ary_elems = (u64*)new_mem;
        parent.ary_max = new_max;
    }
}

// --- algo.U64Ary.ary.Setary
// Copy contents of RHS to PARENT.
void algo::ary_Setary(algo::U64Ary& parent, algo::U64Ary &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.ary_elems + i) u64(ary_qFind(rhs, i));
        parent.ary_n = i + 1;
    }
}

// --- algo.U64Ary.ary.Setary2
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void algo::ary_Setary(algo::U64Ary& parent, const algo::aryptr<u64> &rhs) {
    ary_RemoveAll(parent);
    ary_Addary(parent, rhs);
}

// --- algo.U64Ary..Uninit
void algo::U64Ary_Uninit(algo::U64Ary& parent) {
    algo::U64Ary &row = parent; (void)row;

    // algo.U64Ary.ary.Uninit (Tary)  //Array of u64 values
    // remove all elements from algo.U64Ary.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo.U64Ary.ary
    algo_lib::malloc_FreeMem(parent.ary_elems, sizeof(u64)*parent.ary_max); // (algo.U64Ary.ary)
}

// --- algo.U64Dec10.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec10& parent, double val) {
    double intval = val * 10000000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec10.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec10& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 10) { // ignore digits after 10'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 10) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec10.value.Print
void algo::value_Print(algo::U64Dec10& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 10, value_start, true);
}

// --- algo.U64Dec10..ReadStrptrMaybe
// Read fields of algo::U64Dec10 from an ascii string.
// The format of the string is the format of the algo::U64Dec10's only field
bool algo::U64Dec10_ReadStrptrMaybe(algo::U64Dec10 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec10..Print
// print string representation of algo::U64Dec10 to string LHS, no header -- cprint:algo.U64Dec10.String
void algo::U64Dec10_Print(algo::U64Dec10 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec2.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec2& parent, double val) {
    double intval = val * 100;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec2.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec2& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 2) { // ignore digits after 2'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 2) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec2.value.Print
void algo::value_Print(algo::U64Dec2& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 2, value_start, true);
}

// --- algo.U64Dec2..ReadStrptrMaybe
// Read fields of algo::U64Dec2 from an ascii string.
// The format of the string is the format of the algo::U64Dec2's only field
bool algo::U64Dec2_ReadStrptrMaybe(algo::U64Dec2 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec2..Print
// print string representation of algo::U64Dec2 to string LHS, no header -- cprint:algo.U64Dec2.String
void algo::U64Dec2_Print(algo::U64Dec2 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec4.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec4& parent, double val) {
    double intval = val * 10000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec4.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec4& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 4) { // ignore digits after 4'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 4) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec4.value.Print
void algo::value_Print(algo::U64Dec4& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 4, value_start, true);
}

// --- algo.U64Dec4..ReadStrptrMaybe
// Read fields of algo::U64Dec4 from an ascii string.
// The format of the string is the format of the algo::U64Dec4's only field
bool algo::U64Dec4_ReadStrptrMaybe(algo::U64Dec4 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec4..Print
// print string representation of algo::U64Dec4 to string LHS, no header -- cprint:algo.U64Dec4.String
void algo::U64Dec4_Print(algo::U64Dec4 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec5.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec5& parent, double val) {
    double intval = val * 100000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec5.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec5& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 5) { // ignore digits after 5'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 5) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec5.value.Print
void algo::value_Print(algo::U64Dec5& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 5, value_start, true);
}

// --- algo.U64Dec5..ReadStrptrMaybe
// Read fields of algo::U64Dec5 from an ascii string.
// The format of the string is the format of the algo::U64Dec5's only field
bool algo::U64Dec5_ReadStrptrMaybe(algo::U64Dec5 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec5..Print
// print string representation of algo::U64Dec5 to string LHS, no header -- cprint:algo.U64Dec5.String
void algo::U64Dec5_Print(algo::U64Dec5 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec6.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec6& parent, double val) {
    double intval = val * 1000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec6.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec6& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 6) { // ignore digits after 6'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 6) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec6.value.Print
void algo::value_Print(algo::U64Dec6& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 6, value_start, true);
}

// --- algo.U64Dec6..ReadStrptrMaybe
// Read fields of algo::U64Dec6 from an ascii string.
// The format of the string is the format of the algo::U64Dec6's only field
bool algo::U64Dec6_ReadStrptrMaybe(algo::U64Dec6 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec6..Print
// print string representation of algo::U64Dec6 to string LHS, no header -- cprint:algo.U64Dec6.String
void algo::U64Dec6_Print(algo::U64Dec6 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec7.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec7& parent, double val) {
    double intval = val * 10000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec7.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec7& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 7) { // ignore digits after 7'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 7) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec7.value.Print
void algo::value_Print(algo::U64Dec7& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 7, value_start, true);
}

// --- algo.U64Dec7..ReadStrptrMaybe
// Read fields of algo::U64Dec7 from an ascii string.
// The format of the string is the format of the algo::U64Dec7's only field
bool algo::U64Dec7_ReadStrptrMaybe(algo::U64Dec7 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec7..Print
// print string representation of algo::U64Dec7 to string LHS, no header -- cprint:algo.U64Dec7.String
void algo::U64Dec7_Print(algo::U64Dec7 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec8.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec8& parent, double val) {
    double intval = val * 100000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec8.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec8& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 8) { // ignore digits after 8'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 8) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec8.value.Print
void algo::value_Print(algo::U64Dec8& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 8, value_start, true);
}

// --- algo.U64Dec8..ReadStrptrMaybe
// Read fields of algo::U64Dec8 from an ascii string.
// The format of the string is the format of the algo::U64Dec8's only field
bool algo::U64Dec8_ReadStrptrMaybe(algo::U64Dec8 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec8..Print
// print string representation of algo::U64Dec8 to string LHS, no header -- cprint:algo.U64Dec8.String
void algo::U64Dec8_Print(algo::U64Dec8 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo.U64Dec9.value.SetDoubleMaybe
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool algo::value_SetDoubleMaybe(algo::U64Dec9& parent, double val) {
    double intval = val * 1000000000;
    u64 minval = u64(0ULL);
    u64 maxval = u64(18446744073709551615ULL);
    bool retval = intval >= minval;
    retval &= intval < maxval;
    if (retval) {
        intval = intval + (val > 0 ? 0.5 : -0.5);
        parent.value = intval; // set underlying field.
    }
    return retval;
}

// --- algo.U64Dec9.value.ReadStrptrMaybe
bool algo::value_ReadStrptrMaybe(algo::U64Dec9& parent, algo::strptr in) {
    int index = 0;
    int neg = false;
    // skip leading sign
    if (index < in.n_elems && (in.elems[index] == '+' || in.elems[index] == '-')) {
        neg = in.elems[index]=='-';
        index++;
    };
    // parse digits
    u64 val = 0;
    int ndot = 0; // number of . encountered
    int nfrac = 0; // read up to NFRAC digits after .; if not found, fill in
    bool ok = true;// overflow or bad char
    for (; index < in.n_elems; index++) {
        char c = in.elems[index];
        if (c == '.') {
            ok &= ndot == 0; // max 1 dot
            ndot++;
        } else if (algo_lib::DigitCharQ(c)) {
            if (nfrac < 9) { // ignore digits after 9'th
                u64 newval = val*10 + (c-'0');
                ok &= newval >= val;
                val = newval;
                nfrac += ndot>0;
            }
        } else {
            ok = false; // unknown char
        }
    }
    while (nfrac < 9) {// insert missing
        u64 newval = val*10;
        ok &= newval >= val;
        val = newval;
        nfrac++;
    }
    u64 final_val = val;
    ok &= !neg;
    if (ok) {
        parent.value = final_val;// store value
    }
    return ok;
}

// --- algo.U64Dec9.value.Print
void algo::value_Print(algo::U64Dec9& parent, cstring &outstr) {
    u64 value = parent.value;
    ch_Reserve(outstr, 64);
    u8 *value_start = (u8*)(outstr.ch_elems + outstr.ch_n);
    outstr.ch_n += algo::u64_FmtBufDec(value, 9, value_start, true);
}

// --- algo.U64Dec9..ReadStrptrMaybe
// Read fields of algo::U64Dec9 from an ascii string.
// The format of the string is the format of the algo::U64Dec9's only field
bool algo::U64Dec9_ReadStrptrMaybe(algo::U64Dec9 &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo.U64Dec9..Print
// print string representation of algo::U64Dec9 to string LHS, no header -- cprint:algo.U64Dec9.String
void algo::U64Dec9_Print(algo::U64Dec9 row, algo::cstring &str) {
    algo::value_Print(row, str);
}

// --- algo...ForAllStrings
// Test string conversion
void algo::ForAllStrings(void (*fcn)(algo::StringDesc&) ) {
    algo::StringDesc desc;
    // fill out descriptor for numstr:algo.LnumStr10_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr10_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr10_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr10_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr10_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr10_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 10;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr11_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr11_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr11_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr11_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr11_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr11_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 11;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr12_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr12_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr12_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr12_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr12_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr12_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 12;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr13_U64_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr13_U64_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr13_U64_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr13_U64_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr13_U64_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr13_U64_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 13;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr16_U64_Base16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr16_U64_Base16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr16_U64_Base16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr16_U64_Base16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr16_U64_Base16&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr16_U64_Base16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 16;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 16;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr1_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr1_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr1_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr1_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr1_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr1_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 1;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr20_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr20_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr20_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr20_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr20_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr20_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr22_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr22_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr22_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr22_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr22_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr22_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 22;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr2_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr2_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr2_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr2_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr2_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr2_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 2;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr3_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr3_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr3_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr3_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr3_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr3_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 3;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr4_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr4_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr4_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr4_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr4_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr4_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 4;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr5_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr5_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr5_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr5_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr5_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr5_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr5_U32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr5_U32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr5_U32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr5_U32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr5_U32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr5_U32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr6_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr7_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr7_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr7_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr7_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr7_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr7_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr7_U32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr7_U32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr7_U32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr7_U32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr7_U32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr7_U32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 36;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U32_Base16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U32_Base16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U32_Base16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U32_Base16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U32_Base16&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U32_Base16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 16;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr8_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr8_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr8_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr8_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr8_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr8_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 8;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr9_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr9_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr9_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr9_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr9_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr9_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 9;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LnumStr9_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LnumStr9_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LnumStr9_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LnumStr9_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LnumStr9_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LnumStr9_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = '0';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 9;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr20_I64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr20_I64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr20_I64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr20_I64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr20_I64&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr20_I64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = i64(0X7FFFFFFFFFFFFFFF);
        desc.numtype_min = i64(0X8000000000000001);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr20_U64.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr20_U64&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr20_U64&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr20_U64&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr20_U64&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr20_U64.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 20;
        desc.numtype_max = 0XFFFFFFFFFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr3_I16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr3_I16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr3_I16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr3_I16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr3_I16&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr3_I16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 3;
        desc.numtype_max = i64(0X7FFF);
        desc.numtype_min = i64(0XFFFFFFFFFFFF8000);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr5_I16.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr5_I16&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr5_I16&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr5_I16&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr5_I16&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr5_I16.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 5;
        desc.max_length  = 5;
        desc.numtype_max = 0XFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr6_U32.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.LspaceStr7_I32_Base36.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::LspaceStr7_I32_Base36&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::LspaceStr7_I32_Base36&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::LspaceStr7_I32_Base36&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::LspaceStr7_I32_Base36&)>(ch_Getary));
        desc.smallstr    = "algo.LspaceStr7_I32_Base36.ch";
        desc.strtype     = "leftpad";
        desc.pad         = ' ';
        desc.base        = 36;
        desc.issigned    = true;
        desc.min_length  = 1;
        desc.max_length  = 7;
        desc.numtype_max = i64(0X7FFFFFFF);
        desc.numtype_min = i64(0XFFFFFFFF80000000);
        fcn(desc); // call test function
    }
    // fill out descriptor for numstr:algo.RnullStr6_U32.ch
    {
        desc.Geti64      = Geti64Fcn(static_cast<i64(*)(algo::RnullStr6_U32&,bool&)>(ch_Geti64));
        desc.SetnumMaybe = SetnumFcn(static_cast<bool(*)(algo::RnullStr6_U32&,i64)>(ch_SetnumMaybe));
        desc.Init        = InitFcn(static_cast<void(*)(algo::RnullStr6_U32&)>(ch_Init));
        desc.Getary      = GetaryFcn(static_cast<algo::aryptr<char>(*)(const algo::RnullStr6_U32&)>(ch_Getary));
        desc.smallstr    = "algo.RnullStr6_U32.ch";
        desc.strtype     = "rightpad";
        desc.pad         = 0;
        desc.base        = 10;
        desc.issigned    = false;
        desc.min_length  = 1;
        desc.max_length  = 6;
        desc.numtype_max = 0XFFFFFFFF;
        desc.numtype_min = 0X0;
        fcn(desc); // call test function
    }
}

// --- algo...SizeCheck
inline static void algo::SizeCheck() {
}
