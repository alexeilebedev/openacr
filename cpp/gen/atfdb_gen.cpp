//
// cpp/gen/atfdb_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/atfdb_gen.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace atfdb {
    static void          SizeCheck();
} // end namespace atfdb

// --- atfdb.Amctest..ReadFieldMaybe
bool atfdb::Amctest_ReadFieldMaybe(atfdb::Amctest &parent, algo::strptr field, algo::strptr strval) {
    atfdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atfdb_FieldId_amctest: retval = algo::Smallstr50_ReadStrptrMaybe(parent.amctest, strval); break;
        case atfdb_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atfdb.Amctest..ReadStrptrMaybe
// Read fields of atfdb::Amctest from an ascii string.
// The format of the string is an ssim Tuple
bool atfdb::Amctest_ReadStrptrMaybe(atfdb::Amctest &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atfdb.amctest") || algo::StripTypeTag(in_str, "atfdb.Amctest");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Amctest_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atfdb.Amctest..Print
// print string representation of atfdb::Amctest to string LHS, no header -- cprint:atfdb.Amctest.String
void atfdb::Amctest_Print(atfdb::Amctest & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atfdb.amctest";

    algo::Smallstr50_Print(row.amctest, temp);
    PrintAttrSpaceReset(str,"amctest", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atfdb.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* atfdb::value_ToCstr(const atfdb::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case atfdb_FieldId_amctest         : ret = "amctest";  break;
        case atfdb_FieldId_comment         : ret = "comment";  break;
        case atfdb_FieldId_normcheck       : ret = "normcheck";  break;
        case atfdb_FieldId_unittest        : ret = "unittest";  break;
        case atfdb_FieldId_target          : ret = "target";  break;
        case atfdb_FieldId_testname        : ret = "testname";  break;
        case atfdb_FieldId_value           : ret = "value";  break;
    }
    return ret;
}

// --- atfdb.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void atfdb::value_Print(const atfdb::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- atfdb.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool atfdb::value_SetStrptrMaybe(atfdb::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 5: {
            switch (u64(ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,atfdb_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,atfdb_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','m','c','t','e','s','t'): {
                    value_SetEnum(parent,atfdb_FieldId_amctest); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,atfdb_FieldId_comment); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('t','e','s','t','n','a','m','e'): {
                    value_SetEnum(parent,atfdb_FieldId_testname); ret = true; break;
                }
                case LE_STR8('u','n','i','t','t','e','s','t'): {
                    value_SetEnum(parent,atfdb_FieldId_unittest); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('n','o','r','m','c','h','e','c'): {
                    if (memcmp(rhs.elems+8,"k",1)==0) { value_SetEnum(parent,atfdb_FieldId_normcheck); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- atfdb.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void atfdb::value_SetStrptr(atfdb::FieldId& parent, algo::strptr rhs, atfdb_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- atfdb.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool atfdb::value_ReadStrptrMaybe(atfdb::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- atfdb.FieldId..ReadStrptrMaybe
// Read fields of atfdb::FieldId from an ascii string.
// The format of the string is the format of the atfdb::FieldId's only field
bool atfdb::FieldId_ReadStrptrMaybe(atfdb::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && atfdb::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- atfdb.FieldId..Print
// print string representation of atfdb::FieldId to string LHS, no header -- cprint:atfdb.FieldId.String
void atfdb::FieldId_Print(atfdb::FieldId & row, algo::cstring &str) {
    atfdb::value_Print(row, str);
}

// --- atfdb.Normcheck..ReadFieldMaybe
bool atfdb::Normcheck_ReadFieldMaybe(atfdb::Normcheck &parent, algo::strptr field, algo::strptr strval) {
    atfdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atfdb_FieldId_normcheck: retval = algo::Smallstr50_ReadStrptrMaybe(parent.normcheck, strval); break;
        case atfdb_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atfdb.Normcheck..ReadStrptrMaybe
// Read fields of atfdb::Normcheck from an ascii string.
// The format of the string is an ssim Tuple
bool atfdb::Normcheck_ReadStrptrMaybe(atfdb::Normcheck &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atfdb.normcheck") || algo::StripTypeTag(in_str, "atfdb.Normcheck");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Normcheck_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atfdb.Normcheck..Print
// print string representation of atfdb::Normcheck to string LHS, no header -- cprint:atfdb.Normcheck.String
void atfdb::Normcheck_Print(atfdb::Normcheck & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atfdb.normcheck";

    algo::Smallstr50_Print(row.normcheck, temp);
    PrintAttrSpaceReset(str,"normcheck", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atfdb.Unittest.target.Get
algo::Smallstr16 atfdb::target_Get(atfdb::Unittest& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.unittest, ".RL"));
    return ret;
}

// --- atfdb.Unittest.target.Get2
algo::Smallstr16 atfdb::Unittest_target_Get(strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- atfdb.Unittest.testname.Get
algo::Smallstr50 atfdb::testname_Get(atfdb::Unittest& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.unittest, ".RR"));
    return ret;
}

// --- atfdb.Unittest.testname.Get2
algo::Smallstr50 atfdb::Unittest_testname_Get(strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- atfdb.Unittest..Concat_target_testname
tempstr atfdb::Unittest_Concat_target_testname( const algo::strptr& target ,const algo::strptr& testname ) {
    return tempstr() << target <<'.'<< testname ;
}

// --- atfdb.Unittest..ReadFieldMaybe
bool atfdb::Unittest_ReadFieldMaybe(atfdb::Unittest &parent, algo::strptr field, algo::strptr strval) {
    atfdb::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case atfdb_FieldId_unittest: retval = algo::Smallstr50_ReadStrptrMaybe(parent.unittest, strval); break;
        case atfdb_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- atfdb.Unittest..ReadStrptrMaybe
// Read fields of atfdb::Unittest from an ascii string.
// The format of the string is an ssim Tuple
bool atfdb::Unittest_ReadStrptrMaybe(atfdb::Unittest &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "atfdb.unittest") || algo::StripTypeTag(in_str, "atfdb.Unittest");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Unittest_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- atfdb.Unittest..ReadTupleMaybe
// Read fields of atfdb::Unittest from attributes of ascii tuple TUPLE
bool atfdb::Unittest_ReadTupleMaybe(atfdb::Unittest &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = Unittest_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- atfdb.Unittest..Print
// print string representation of atfdb::Unittest to string LHS, no header -- cprint:atfdb.Unittest.String
void atfdb::Unittest_Print(atfdb::Unittest & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "atfdb.unittest";

    algo::Smallstr50_Print(row.unittest, temp);
    PrintAttrSpaceReset(str,"unittest", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- atfdb...SizeCheck
inline static void atfdb::SizeCheck() {
}
