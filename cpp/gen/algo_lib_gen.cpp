//
// cpp/gen/algo_lib_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude
algo_lib::_db_bh_timehook_curs::~_db_bh_timehook_curs() {
    algo_lib::lpool_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

#include <sys/wait.h>
#include <sys/mman.h>
namespace algo_lib {
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_timehook_Downheap(algo_lib::FTimehook& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_timehook_Upheap(algo_lib::FTimehook& row, int idx) __attribute__((nothrow));
    static bool          bh_timehook_ElemLt(algo_lib::FTimehook &a, algo_lib::FTimehook &b) __attribute__((nothrow));
    static void          _db_bh_timehook_curs_Add(_db_bh_timehook_curs &curs, algo_lib::FTimehook& row);
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Extract next character from STR and advance IDX
    static u64           sortkey_Nextchar(const algo_lib::FTxtrow& txtrow, strptr &str, int &idx) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_txtrow_Swap(algo_lib::FTxtrow* &elem_a, algo_lib::FTxtrow* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_txtrow_Rotleft(algo_lib::FTxtrow* &elem_a, algo_lib::FTxtrow* &elem_b, algo_lib::FTxtrow* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_txtrow_Lt(algo_lib::FTxtrow &elem_a, algo_lib::FTxtrow &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_txtrow_IntInsertionSort(algo_lib::FTxtrow* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_txtrow_IntHeapSort(algo_lib::FTxtrow* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_txtrow_IntQuickSort(algo_lib::FTxtrow* *elems, int n, int depth) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          ch_class_Swap(algo::i32_Range &elem_a, algo::i32_Range &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          ch_class_Rotleft(algo::i32_Range &elem_a, algo::i32_Range &elem_b, algo::i32_Range &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          ch_class_Lt(algo::i32_Range &elem_a, algo::i32_Range &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          ch_class_IntInsertionSort(algo::i32_Range *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          ch_class_IntHeapSort(algo::i32_Range *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          ch_class_IntQuickSort(algo::i32_Range *elems, int n, int depth) __attribute__((nothrow));
    static void          SizeCheck();
} // end namespace algo_lib

// --- algo_lib.Bitset.ary.ExpandBits
// Make sure the array supports at least NBITS bits.
// This function is the same as AllocBit(NBITS - 1) assuming NBITS > 0;
void algo_lib::ary_ExpandBits(algo_lib::Bitset& parent, u32 n_bits) {
    u64 n_elems = (n_bits+63) >> 6;
    while (true) {
        u64 n = ary_N(parent);
        if (n_elems <= n) break;
        ary_Alloc(parent) = 0; // keep stretching
    }
}

// --- algo_lib.Bitset.ary.AllocBit
// Make sure all bits up to and including #BIT_IDX exist
// New values are initialized with zero.
void algo_lib::ary_AllocBit(algo_lib::Bitset& parent, u32 bit_idx) {
    ary_ExpandBits(parent, bit_idx + 1);
}

// --- algo_lib.Bitset.ary.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u64& algo_lib::ary_Alloc(algo_lib::Bitset& parent) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    int at = n;
    u64 *elems = parent.ary_elems;
    new (elems + at) u64(0); // construct new element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo_lib.Bitset.ary.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u64& algo_lib::ary_AllocAt(algo_lib::Bitset& parent, int at) {
    ary_Reserve(parent, 1);
    int n  = parent.ary_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.Bitset.ary  comment:'index out of range'");
    }
    u64 *elems = parent.ary_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(u64));
    new (elems + at) u64(0); // construct element, default initializer
    parent.ary_n = n+1;
    return elems[at];
}

// --- algo_lib.Bitset.ary.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64> algo_lib::ary_AllocN(algo_lib::Bitset& parent, int n_elems) {
    ary_Reserve(parent, n_elems);
    int old_n  = parent.ary_n;
    int new_n = old_n + n_elems;
    u64 *elems = parent.ary_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) u64(0); // construct new element, default initialize
    }
    parent.ary_n = new_n;
    return algo::aryptr<u64>(elems + old_n, n_elems);
}

// --- algo_lib.Bitset.ary.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::ary_Remove(algo_lib::Bitset& parent, u32 i) {
    u32 lim = parent.ary_n;
    u64 *elems = parent.ary_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(u64) * (lim - (i + 1)));
        parent.ary_n = lim - 1;
    }
}

// --- algo_lib.Bitset.ary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::ary_RemoveLast(algo_lib::Bitset& parent) {
    u64 n = parent.ary_n;
    if (n > 0) {
        n -= 1;
        parent.ary_n = n;
    }
}

// --- algo_lib.Bitset.ary.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::ary_AbsReserve(algo_lib::Bitset& parent, int n) {
    u32 old_max  = parent.ary_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(parent.ary_elems, old_max * sizeof(u64), new_max * sizeof(u64));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.Bitset.ary  comment:'out of memory'");
    }
    parent.ary_elems = (u64*)new_mem;
    parent.ary_max = new_max;
}

// --- algo_lib.Bitset.ary.Setary
// Copy contents of RHS to PARENT.
void algo_lib::ary_Setary(algo_lib::Bitset& parent, algo_lib::Bitset &rhs) {
    ary_RemoveAll(parent);
    int nnew = rhs.ary_n;
    ary_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.ary_elems + i) u64(ary_qFind(rhs, i));
        parent.ary_n = i + 1;
    }
}

// --- algo_lib.Bitset..Uninit
void algo_lib::Bitset_Uninit(algo_lib::Bitset& parent) {
    algo_lib::Bitset &row = parent; (void)row;

    // algo_lib.Bitset.ary.Uninit (Tary)  //
    // remove all elements from algo_lib.Bitset.ary
    ary_RemoveAll(parent);
    // free memory for Tary algo_lib.Bitset.ary
    algo_lib::lpool_FreeMem(parent.ary_elems, sizeof(u64)*parent.ary_max); // (algo_lib.Bitset.ary)
}

// --- algo_lib.Cmdline..ReadFieldMaybe
bool algo_lib::Cmdline_ReadFieldMaybe(algo_lib::Cmdline &parent, algo::strptr field, algo::strptr strval) {
    algo_lib::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case algo_lib_FieldId_verbose: retval = u8_ReadStrptrMaybe(parent.verbose, strval); break;
        case algo_lib_FieldId_debug: retval = u8_ReadStrptrMaybe(parent.debug, strval); break;
        case algo_lib_FieldId_help: retval = bool_ReadStrptrMaybe(parent.help, strval); break;
        case algo_lib_FieldId_version: retval = bool_ReadStrptrMaybe(parent.version, strval); break;
        case algo_lib_FieldId_sig: retval = bool_ReadStrptrMaybe(parent.sig, strval); break;
        case algo_lib_FieldId_signature: retval = bool_ReadStrptrMaybe(parent.signature, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- algo_lib.Cmdline..ReadTupleMaybe
// Read fields of algo_lib::Cmdline from attributes of ascii tuple TUPLE
bool algo_lib::Cmdline_ReadTupleMaybe(algo_lib::Cmdline &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = Cmdline_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- algo_lib.CsvParse.ary_tok.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::strptr& algo_lib::ary_tok_Alloc(algo_lib::CsvParse& parsecsv) {
    ary_tok_Reserve(parsecsv, 1);
    int n  = parsecsv.ary_tok_n;
    int at = n;
    algo::strptr *elems = parsecsv.ary_tok_elems;
    new (elems + at) algo::strptr(); // construct new element, default initializer
    parsecsv.ary_tok_n = n+1;
    return elems[at];
}

// --- algo_lib.CsvParse.ary_tok.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::strptr& algo_lib::ary_tok_AllocAt(algo_lib::CsvParse& parsecsv, int at) {
    ary_tok_Reserve(parsecsv, 1);
    int n  = parsecsv.ary_tok_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.CsvParse.ary_tok  comment:'index out of range'");
    }
    algo::strptr *elems = parsecsv.ary_tok_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::strptr));
    new (elems + at) algo::strptr(); // construct element, default initializer
    parsecsv.ary_tok_n = n+1;
    return elems[at];
}

// --- algo_lib.CsvParse.ary_tok.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::strptr> algo_lib::ary_tok_AllocN(algo_lib::CsvParse& parsecsv, int n_elems) {
    ary_tok_Reserve(parsecsv, n_elems);
    int old_n  = parsecsv.ary_tok_n;
    int new_n = old_n + n_elems;
    algo::strptr *elems = parsecsv.ary_tok_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::strptr(); // construct new element, default initialize
    }
    parsecsv.ary_tok_n = new_n;
    return algo::aryptr<algo::strptr>(elems + old_n, n_elems);
}

// --- algo_lib.CsvParse.ary_tok.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::ary_tok_Remove(algo_lib::CsvParse& parsecsv, u32 i) {
    u32 lim = parsecsv.ary_tok_n;
    algo::strptr *elems = parsecsv.ary_tok_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(algo::strptr) * (lim - (i + 1)));
        parsecsv.ary_tok_n = lim - 1;
    }
}

// --- algo_lib.CsvParse.ary_tok.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::ary_tok_RemoveLast(algo_lib::CsvParse& parsecsv) {
    u64 n = parsecsv.ary_tok_n;
    if (n > 0) {
        n -= 1;
        parsecsv.ary_tok_n = n;
    }
}

// --- algo_lib.CsvParse.ary_tok.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::ary_tok_AbsReserve(algo_lib::CsvParse& parsecsv, int n) {
    u32 old_max  = parsecsv.ary_tok_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(parsecsv.ary_tok_elems, old_max * sizeof(algo::strptr), new_max * sizeof(algo::strptr));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.CsvParse.ary_tok  comment:'out of memory'");
    }
    parsecsv.ary_tok_elems = (algo::strptr*)new_mem;
    parsecsv.ary_tok_max = new_max;
}

// --- algo_lib.CsvParse.ary_tok.Setary
// Copy contents of RHS to PARENT.
void algo_lib::ary_tok_Setary(algo_lib::CsvParse& parsecsv, algo_lib::CsvParse &rhs) {
    ary_tok_RemoveAll(parsecsv);
    int nnew = rhs.ary_tok_n;
    ary_tok_Reserve(parsecsv, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parsecsv.ary_tok_elems + i) algo::strptr(ary_tok_qFind(rhs, i));
        parsecsv.ary_tok_n = i + 1;
    }
}

// --- algo_lib.CsvParse..Uninit
void algo_lib::CsvParse_Uninit(algo_lib::CsvParse& parsecsv) {
    algo_lib::CsvParse &row = parsecsv; (void)row;

    // algo_lib.CsvParse.ary_tok.Uninit (Tary)  //Output: array of tokens
    // remove all elements from algo_lib.CsvParse.ary_tok
    ary_tok_RemoveAll(parsecsv);
    // free memory for Tary algo_lib.CsvParse.ary_tok
    algo_lib::lpool_FreeMem(parsecsv.ary_tok_elems, sizeof(algo::strptr)*parsecsv.ary_tok_max); // (algo_lib.CsvParse.ary_tok)
}

// --- algo_lib.CsvParse..Print
// print string representation of algo_lib::CsvParse to string LHS, no header -- cprint:algo_lib.CsvParse.String
void algo_lib::CsvParse_Print(algo_lib::CsvParse & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.CsvParse";

    char_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);
}

// --- algo_lib.FFildes..Uninit
void algo_lib::FFildes_Uninit(algo_lib::FFildes& fildes) {
    algo_lib::FFildes &row = fildes; (void)row;
    fd_Cleanup(fildes); // dmmeta.fcleanup:algo_lib.FFildes.fd
}

// --- algo_lib.FFildes..Print
// print string representation of algo_lib::FFildes to string LHS, no header -- cprint:algo_lib.FFildes.String
void algo_lib::FFildes_Print(algo_lib::FFildes & row, algo::cstring &str) {
    (void)row;//only to avoid -Wunused-parameter
    (void)str;//only to avoid -Wunused-parameter
}

// --- algo_lib.FLockfile..Uninit
void algo_lib::FLockfile_Uninit(algo_lib::FLockfile& parent) {
    algo_lib::FLockfile &row = parent; (void)row;
    fildes_Cleanup(parent); // dmmeta.fcleanup:algo_lib.FLockfile.fildes
}

// --- algo_lib.FTimehook..Uninit
void algo_lib::FTimehook_Uninit(algo_lib::FTimehook& timehook) {
    algo_lib::FTimehook &row = timehook; (void)row;
    bh_timehook_Remove(row); // remove timehook from index bh_timehook
}

// --- algo_lib.FImdb.msghdr.CopyOut
// Copy fields out of row
void algo_lib::imdb_CopyOut(algo_lib::FImdb &row, algo::Imdb &out) {
    out.imdb = row.imdb;
    out.InsertStrptrMaybe = row.InsertStrptrMaybe;
    out.Step = row.Step;
    out.MainLoop = row.MainLoop;
    out.GetTrace = row.GetTrace;
    out.comment = row.comment;
}

// --- algo_lib.FImdb.msghdr.CopyIn
// Copy fields in to row
void algo_lib::imdb_CopyIn(algo_lib::FImdb &row, algo::Imdb &in) {
    row.imdb = in.imdb;
    row.InsertStrptrMaybe = in.InsertStrptrMaybe;
    row.Step = in.Step;
    row.MainLoop = in.MainLoop;
    row.GetTrace = in.GetTrace;
    row.comment = in.comment;
}

// --- algo_lib.FImdb..Uninit
void algo_lib::FImdb_Uninit(algo_lib::FImdb& imdb) {
    algo_lib::FImdb &row = imdb; (void)row;
    ind_imdb_Remove(row); // remove imdb from index ind_imdb
}

// --- algo_lib.trace..Init
// Set all fields to initial values.
void algo_lib::trace_Init(algo_lib::trace& parent) {
    parent.n_mmap = u64(0);
    parent.n_sbrk = u64(0);
    parent.tot_insert_err = u64(0);
    parent.tot_selfcheck_err = u64(0);
    parent.tot_update_err = u64(0);
    parent.step_bh_timehook = u64(0);
    parent.step_bh_timehook_cycles = u64(0);
    parent.step_giveup_time = u64(0);
    parent.step_giveup_time_cycles = u64(0);
    parent.alloc__db_malloc = u64(0);
    parent.del__db_malloc = u64(0);
}

// --- algo_lib.trace..Print
// print string representation of algo_lib::trace to string LHS, no header -- cprint:algo_lib.trace.String
void algo_lib::trace_Print(algo_lib::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.trace";

    u64_Print(row.n_mmap, temp);
    PrintAttrSpaceReset(str,"n_mmap", temp);

    u64_Print(row.n_sbrk, temp);
    PrintAttrSpaceReset(str,"n_sbrk", temp);

    u64_Print(row.tot_insert_err, temp);
    PrintAttrSpaceReset(str,"tot_insert_err", temp);

    u64_Print(row.tot_selfcheck_err, temp);
    PrintAttrSpaceReset(str,"tot_selfcheck_err", temp);

    u64_Print(row.tot_update_err, temp);
    PrintAttrSpaceReset(str,"tot_update_err", temp);

    u64_Print(row.step_bh_timehook, temp);
    PrintAttrSpaceReset(str,"step_bh_timehook", temp);

    u64_Print(row.step_bh_timehook_cycles, temp);
    PrintAttrSpaceReset(str,"step_bh_timehook_cycles", temp);

    u64_Print(row.step_giveup_time, temp);
    PrintAttrSpaceReset(str,"step_giveup_time", temp);

    u64_Print(row.step_giveup_time_cycles, temp);
    PrintAttrSpaceReset(str,"step_giveup_time_cycles", temp);

    u64_Print(row.alloc__db_malloc, temp);
    PrintAttrSpaceReset(str,"alloc__db_malloc", temp);

    u64_Print(row.del__db_malloc, temp);
    PrintAttrSpaceReset(str,"del__db_malloc", temp);
}

// --- algo_lib.FDb.sbrk.AllocMem
// Allocate a new piece of memory at least SIZE bytes long.
// If out of memory, return NULL
// Newly allocated memory is initialized to zeros
void* algo_lib::sbrk_AllocMem(u32 size) {
    void *ret = MAP_FAILED;
#if defined(__MACH__) || __FreeBSD__>0
    ret = malloc(size);
#else
    u32 bigsize = 1024*2048;
    if (size >= bigsize) { // big block -- will be registered
        size = (size + bigsize - 1) / bigsize * bigsize;
        int prot = PROT_READ | PROT_WRITE;
        int flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE;
        bool use_huge = _db.sbrk_huge_alloc + size < _db.sbrk_huge_limit;
        if (use_huge) {
            ret = mmap(0x0, size, prot, flags | MAP_HUGETLB, 0, 0); // try huge pages
        }
        // linux huge page handling is buggy -- MAP_POPULATE doesn't guarantee
        // that pages are there. subsequent page fault may cause a SIGBUS.
        // fortunately there is a way to detect this condition using mlock.
        if (use_huge && ret != MAP_FAILED) {
            int rc = mlock(ret, size);
            if (rc!=0) {
                munmap(ret,size);
                ret=MAP_FAILED;
            } else {
                _db.sbrk_huge_alloc += size;
            }
        }
        if (ret == MAP_FAILED) { // try regular mmap
            _db.sbrk_huge_limit = 0; // don't try huge pages again
            ret = mmap(0x0, size, prot, flags, 0, 0);
        } else {
            ++algo_lib::_db.trace.n_mmap; // mmap counter
        }
    } else {
        if (ret == MAP_FAILED) { // default method
            ret = sbrk(size);
            ++algo_lib::_db.trace.n_sbrk; // update global counter
        }
    }
    if (ret == (void*)-1) { // sbrk returns -1 on error
        ret = NULL;
    }
#endif
    if (ret && _db.sbrk_zeromem) {
        memset(ret,0,size); // touch all bytes in the new memory block
    }
    return ret;
}

// --- algo_lib.FDb.sbrk.FreeMem
void algo_lib::sbrk_FreeMem(void *mem, u32 size) {
#if defined(__MACH__) || __FreeBSD__>0
    free(mem);
    (void)size;
#else
    u32 bigsize = 1024*2048;
    if (size >= bigsize) {
        munmap((void*)mem, size);
    }
#endif
}

// --- algo_lib.FDb.lpool.FreeMem
// Free block of memory previously returned by Lpool.
void algo_lib::lpool_FreeMem(void *mem, u64 size) {
    if (mem) {
        size = u64_Max(size,16); // enforce alignment
        u64 cell = u64_BitScanReverse(size-1) + 1;
        lpool_Lpblock *temp = (lpool_Lpblock*)mem; // push  singly linked list
        temp->next = _db.lpool_free[cell];
        _db.lpool_free[cell] = temp;
    }
}

// --- algo_lib.FDb.lpool.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void* algo_lib::lpool_AllocMem(u64 size) {
    size     = u64_Max(size,16); // enforce alignment
    u64 cell = u64_BitScanReverse(size-1)+1;
    u64 i    = cell;
    u8 *retval = NULL;
    // try to find a block that's at least as large as required.
    // if found, remove from free list
    for (; i < 31; i++) {
        lpool_Lpblock *blk = _db.lpool_free[i];
        if (blk) {
            _db.lpool_free[i] = blk->next;
            retval = (u8*)blk;
            break;
        }
    }
    // if suitable size block is not found, create a new one
    // by requesting a block from the base allocator.
    if (UNLIKELY(!retval)) {
        i = u64_Max(cell, 21); // 2MB min -- allow huge page to be used
        retval = (u8*)algo_lib::sbrk_AllocMem(1<<i);
    }
    if (LIKELY(retval)) {
        // if block is more than 2x as large as needed, return the upper half to the free
        // list (repeatedly). meanwhile, retval doesn't change.
        while (i > cell) {
            i--;
            int half = 1<<i;
            lpool_Lpblock *blk = (lpool_Lpblock*)(retval + half);
            blk->next = _db.lpool_free[i];
            _db.lpool_free[i] = blk;
        }
    }
    return retval;
}

// --- algo_lib.FDb.lpool.ReserveBuffers
// Add N buffers of some size to the free store
bool algo_lib::lpool_ReserveBuffers(int nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 16);
    for (int i = 0; i < nbuf; i++) {
        u64     cell = u64_BitScanReverse(bufsize-1)+1;
        u64     size = 1ULL<<cell;
        lpool_Lpblock *temp = (lpool_Lpblock*)algo_lib::sbrk_AllocMem(size);
        if (temp == NULL) {
            retval = false;
            break;// why continue?
        } else {
            temp->next = _db.lpool_free[cell];
            _db.lpool_free[cell] = temp;
        }
    }
    return retval;
}

// --- algo_lib.FDb.lpool.ReallocMem
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void* algo_lib::lpool_ReallocMem(void *oldmem, u64 old_size, u64 new_size) {
    void* ret = oldmem;
    if (new_size != old_size) {
        ret = lpool_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            lpool_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- algo_lib.FDb.fildes.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::fildes_XrefMaybe(algo_lib::FFildes &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb._db.Step
// Main step
void algo_lib::Step() {
    bh_timehook_Call();
    giveup_time_Call();
}

// --- algo_lib.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void algo_lib::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("algo_lib", algo_lib::InsertStrptrMaybe, algo_lib::Step, NULL, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "algo_lib.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(algo_lib::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)algo_lib::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'algo_lib.Input'  signature:'ddc07e859e7056e1a824df1ad0e6d08e12e89849'");
}

// --- algo_lib.FDb._db.StaticCheck
void algo_lib::StaticCheck() {
    algo_assert(sizeof(algo_lib::_db_h_fatalerror_hook) == 8); // csize:algo_lib._db_h_fatalerror_hook
    algo_assert(sizeof(algo_lib::iohook_callback_hook) == 8); // csize:algo_lib.iohook_callback_hook
    algo_assert(sizeof(algo_lib::timehook_hook_hook) == 8); // csize:algo_lib.timehook_hook_hook
    algo_assert(_offset_of(algo_lib::trace, del__db_malloc) + sizeof(((algo_lib::trace*)0)->del__db_malloc) == sizeof(algo_lib::trace));
    algo_assert(_offset_of(algo_lib::FieldId, value) + sizeof(((algo_lib::FieldId*)0)->value) == sizeof(algo_lib::FieldId));
}

// --- algo_lib.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool algo_lib::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    algo_lib::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case algo_lib_TableId_dmmeta_Dispsigcheck: { // finput:algo_lib.FDb.dispsigcheck
            dmmeta::Dispsigcheck elem;
            retval = dmmeta::Dispsigcheck_ReadStrptrMaybe(elem, str);
            retval = retval && dispsigcheck_InputMaybe(elem);
            break;
        }
        default:
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- algo_lib.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool algo_lib::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {

        NULL};
        retval = algo_lib::DoLoadTuples(root, algo_lib::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- algo_lib.FDb._db.Init
void algo_lib::Init() {
    algo_lib::_db.last_signal             = 0;
    ary_beg(cstring, str, algo_lib::temp_strings_Getary()) {
        ch_Reserve(str, 256);
    }ary_end;
    algo_lib::_db.n_temp = algo_lib::temp_strings_N();
    algo_lib::bh_timehook_Reserve(32);
    algo_lib::InitCpuHz();
    algo_lib::_db.eol          = true;
}

// --- algo_lib.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool algo_lib::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, algo_lib::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- algo_lib.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- algo_lib.FDb.imtable.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FImtable& algo_lib::imtable_Alloc() {
    algo_lib::FImtable* row = imtable_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.imtable  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.imtable.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FImtable* algo_lib::imtable_AllocMaybe() {
    algo_lib::FImtable *row = (algo_lib::FImtable*)imtable_AllocMem();
    if (row) {
        new (row) algo_lib::FImtable; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.imtable.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
algo_lib::FImtable* algo_lib::imtable_InsertMaybe(const algo::Imtable &value) {
    algo_lib::FImtable *row = &imtable_Alloc(); // if out of memory, process dies. if input error, return NULL.
    imtable_CopyIn(*row,const_cast<algo::Imtable&>(value));
    bool ok = imtable_XrefMaybe(*row); // this may return false
    if (!ok) {
        imtable_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- algo_lib.FDb.imtable.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* algo_lib::imtable_AllocMem() {
    u64 new_nelems     = _db.imtable_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    algo_lib::FImtable*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.imtable_lary[bsr];
        if (!lev) {
            lev=(algo_lib::FImtable*)algo_lib::lpool_AllocMem(sizeof(algo_lib::FImtable) * (u64(1)<<bsr));
            _db.imtable_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.imtable_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- algo_lib.FDb.imtable.RemoveAll
// Remove all elements from Lary
void algo_lib::imtable_RemoveAll() {
    for (u64 n = _db.imtable_n; n>0; ) {
        n--;
        imtable_qFind(u64(n)).~FImtable(); // destroy last element
        _db.imtable_n = n;
    }
}

// --- algo_lib.FDb.imtable.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::imtable_RemoveLast() {
    u64 n = _db.imtable_n;
    if (n > 0) {
        n -= 1;
        imtable_qFind(u64(n)).~FImtable();
        _db.imtable_n = n;
    }
}

// --- algo_lib.FDb.imtable.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::imtable_XrefMaybe(algo_lib::FImtable &row) {
    bool retval = true;
    (void)row;
    // insert imtable into index ind_imtable
    if (true) { // user-defined insert condition
        bool success = ind_imtable_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "algo_lib.duplicate_key  xref:algo_lib.FDb.ind_imtable"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- algo_lib.FDb.ind_imtable.Find
// Find row by key. Return NULL if not found.
algo_lib::FImtable* algo_lib::ind_imtable_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_imtable_buckets_n - 1);
    algo_lib::FImtable* *e = &_db.ind_imtable_buckets_elems[index];
    algo_lib::FImtable* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).imtable == key;
        if (done) break;
        e         = &ret->ind_imtable_next;
    } while (true);
    return ret;
}

// --- algo_lib.FDb.ind_imtable.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
algo_lib::FImtable& algo_lib::ind_imtable_GetOrCreate(const algo::strptr& key) {
    algo_lib::FImtable* ret = ind_imtable_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &imtable_Alloc();
        (*ret).imtable = key;
        bool good = imtable_XrefMaybe(*ret);
        if (!good) {
            imtable_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- algo_lib.FDb.ind_imtable.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool algo_lib::ind_imtable_InsertMaybe(algo_lib::FImtable& row) {
    ind_imtable_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_imtable_next == (algo_lib::FImtable*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.imtable) & (_db.ind_imtable_buckets_n - 1);
        algo_lib::FImtable* *prev = &_db.ind_imtable_buckets_elems[index];
        do {
            algo_lib::FImtable* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).imtable == row.imtable) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_imtable_next;
        } while (true);
        if (retval) {
            row.ind_imtable_next = *prev;
            _db.ind_imtable_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- algo_lib.FDb.ind_imtable.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void algo_lib::ind_imtable_Remove(algo_lib::FImtable& row) {
    if (LIKELY(row.ind_imtable_next != (algo_lib::FImtable*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.imtable) & (_db.ind_imtable_buckets_n - 1);
        algo_lib::FImtable* *prev = &_db.ind_imtable_buckets_elems[index]; // addr of pointer to current element
        while (algo_lib::FImtable *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_imtable_next; // unlink (singly linked list)
                _db.ind_imtable_n--;
                row.ind_imtable_next = (algo_lib::FImtable*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_imtable_next;
        }
    }
}

// --- algo_lib.FDb.ind_imtable.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void algo_lib::ind_imtable_Reserve(int n) {
    u32 old_nbuckets = _db.ind_imtable_buckets_n;
    u32 new_nelems   = _db.ind_imtable_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(algo_lib::FImtable*);
        u32 new_size = new_nbuckets * sizeof(algo_lib::FImtable*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        algo_lib::FImtable* *new_buckets = (algo_lib::FImtable**)algo_lib::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FDb.ind_imtable");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_imtable_buckets_n; i++) {
            algo_lib::FImtable* elem = _db.ind_imtable_buckets_elems[i];
            while (elem) {
                algo_lib::FImtable &row        = *elem;
                algo_lib::FImtable* next       = row.ind_imtable_next;
                u32 index          = Smallstr50_Hash(0, row.imtable) & (new_nbuckets-1);
                row.ind_imtable_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::lpool_FreeMem(_db.ind_imtable_buckets_elems, old_size);
        _db.ind_imtable_buckets_elems = new_buckets;
        _db.ind_imtable_buckets_n = new_nbuckets;
    }
}

// --- algo_lib.FDb.iohook.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::iohook_XrefMaybe(algo_lib::FIohook &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.timehook.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::timehook_XrefMaybe(algo_lib::FTimehook &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.replscope.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::replscope_XrefMaybe(algo_lib::Replscope &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.error.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::ErrorX& algo_lib::error_Alloc() {
    algo_lib::ErrorX* row = error_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.error  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.error.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::ErrorX* algo_lib::error_AllocMaybe() {
    algo_lib::ErrorX *row = (algo_lib::ErrorX*)error_AllocMem(sizeof(algo_lib::ErrorX));
    if (row) {
        new (row) algo_lib::ErrorX; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.error.Delete
// Remove row from all global and cross indices, then deallocate row
void algo_lib::error_Delete(algo_lib::ErrorX &row) {
    int length = sizeof(algo_lib::ErrorX);
    row.~ErrorX();
    error_FreeMem(&row, length);
}

// --- algo_lib.FDb.error.AllocMem
// Allocate n bytes. If no memory available, return NULL.
void* algo_lib::error_AllocMem(size_t n) {
    void* mem = malloc(n);
    ++algo_lib::_db.trace.alloc__db_malloc; // update global malloc counter
    return mem;
}

// --- algo_lib.FDb.error.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void algo_lib::error_FreeMem(void *mem, size_t n) {
    (void)n;
    if (mem) {
        ++algo_lib::_db.trace.del__db_malloc; // update global malloc counter
        free(mem);
    }
}

// --- algo_lib.FDb.error.ReallocMem
// Reallocate n bytes. If the call fails, return value is NULL.
// In this case, original MEM pointer is untouched.
void* algo_lib::error_ReallocMem(void *mem, size_t old_size, size_t new_size) {
    (void)old_size;
    algo_lib::_db.trace.alloc__db_malloc += old_size == 0; // update global malloc counter
    algo_lib::_db.trace.del__db_malloc += new_size == 0; // update global malloc counter
    void* new_mem = realloc(mem, new_size);
    return new_mem;
}

// --- algo_lib.FDb.error.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::error_XrefMaybe(algo_lib::ErrorX &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.parsecsv.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::parsecsv_XrefMaybe(algo_lib::CsvParse &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.regxparse.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::regxparse_XrefMaybe(algo_lib::RegxParse &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.regx.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::regx_XrefMaybe(algo_lib::Regx &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.tabulate.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::tabulate_XrefMaybe(algo_lib::Tabulate &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.bh_timehook.Dealloc
// Remove all elements from heap and free memory used by the array.
void algo_lib::bh_timehook_Dealloc() {
    bh_timehook_RemoveAll();
    algo_lib::lpool_FreeMem(_db.bh_timehook_elems, sizeof(algo_lib::FTimehook*)*_db.bh_timehook_max);
    _db.bh_timehook_max   = 0;
    _db.bh_timehook_elems = NULL;
}

// --- algo_lib.FDb.bh_timehook.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int algo_lib::bh_timehook_Downheap(algo_lib::FTimehook& row, int idx) {
    algo_lib::FTimehook* *elems = _db.bh_timehook_elems;
    int n = _db.bh_timehook_n;
    int child = idx*2+1;
    while (child < n) {
        algo_lib::FTimehook* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            algo_lib::FTimehook* q = elems[rchild]; // right child
            if (bh_timehook_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_timehook_ElemLt(*p,row)) {
            break;
        }
        p->bh_timehook_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- algo_lib.FDb.bh_timehook.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void algo_lib::bh_timehook_Insert(algo_lib::FTimehook& row) {
    if (LIKELY(row.bh_timehook_idx == -1)) {
        bh_timehook_Reserve(1);
        int n = _db.bh_timehook_n;
        _db.bh_timehook_n = n + 1;
        int new_idx = bh_timehook_Upheap(row, n);
        row.bh_timehook_idx = new_idx;
        _db.bh_timehook_elems[new_idx] = &row;
        if (new_idx==0) {
            bh_timehook_FirstChanged();
        }
    }
}

// --- algo_lib.FDb.bh_timehook.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// If first item of the is changed, update fstep:algo_lib.FDb.bh_timehook
i32 algo_lib::bh_timehook_Reheap(algo_lib::FTimehook& row) {
    int old_idx = row.bh_timehook_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_timehook_Reserve(1);
        old_idx = _db.bh_timehook_n++;
    }
    int new_idx = bh_timehook_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_timehook_Downheap(row, old_idx);
    }
    row.bh_timehook_idx = new_idx;
    _db.bh_timehook_elems[new_idx] = &row;
    bool changed = new_idx==0 || old_idx==0;
    if (changed) {
        bh_timehook_FirstChanged();
    }
    return new_idx;
}

// --- algo_lib.FDb.bh_timehook.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// Update fstep:algo_lib.FDb.bh_timehook
i32 algo_lib::bh_timehook_ReheapFirst() {
    algo_lib::FTimehook &row = *_db.bh_timehook_elems[0];
    i32 new_idx = bh_timehook_Downheap(row, 0);
    row.bh_timehook_idx = new_idx;
    _db.bh_timehook_elems[new_idx] = &row;
    if (new_idx != 0) {
        bh_timehook_FirstChanged();
    }
    return new_idx;
}

// --- algo_lib.FDb.bh_timehook.Remove
// Remove element from index. If element is not in index, do nothing.
void algo_lib::bh_timehook_Remove(algo_lib::FTimehook& row) {
    if (bh_timehook_InBheapQ(row)) {
        int old_idx = row.bh_timehook_idx;
        if (_db.bh_timehook_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_timehook_idx = -1;           // mark not in heap
            i32 n = _db.bh_timehook_n - 1; // index of last element in heap
            _db.bh_timehook_n = n;         // decrease count
            if (old_idx != n) {
                algo_lib::FTimehook *elem = _db.bh_timehook_elems[n];
                int new_idx = bh_timehook_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_timehook_Downheap(*elem, old_idx);
                }
                elem->bh_timehook_idx = new_idx;
                _db.bh_timehook_elems[new_idx] = elem;
            }
            if (old_idx == 0) {
                bh_timehook_FirstChanged();
            }
        }
    }
}

// --- algo_lib.FDb.bh_timehook.RemoveAll
// Remove all elements from binary heap
void algo_lib::bh_timehook_RemoveAll() {
    int n = _db.bh_timehook_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_timehook_elems[i]->bh_timehook_idx = -1; // mark not-in-heap
    }
    _db.bh_timehook_n = 0;
    if (n > 0) {
        bh_timehook_FirstChanged();
    }
}

// --- algo_lib.FDb.bh_timehook.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
algo_lib::FTimehook* algo_lib::bh_timehook_RemoveFirst() {
    algo_lib::FTimehook *row = NULL;
    if (_db.bh_timehook_n > 0) {
        row = _db.bh_timehook_elems[0];
        row->bh_timehook_idx = -1;           // mark not in heap
        i32 n = _db.bh_timehook_n - 1; // index of last element in heap
        _db.bh_timehook_n = n;         // decrease count
        if (n) {
            algo_lib::FTimehook &elem = *_db.bh_timehook_elems[n];
            int new_idx = bh_timehook_Downheap(elem, 0);
            elem.bh_timehook_idx = new_idx;
            _db.bh_timehook_elems[new_idx] = &elem;
        }
        bh_timehook_FirstChanged();
    }
    return row;
}

// --- algo_lib.FDb.bh_timehook.Reserve
// Reserve space in index for N more elements
void algo_lib::bh_timehook_Reserve(int n) {
    i32 old_max = _db.bh_timehook_max;
    if (UNLIKELY(_db.bh_timehook_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(algo_lib::FTimehook*);
        u32 new_size = new_max * sizeof(algo_lib::FTimehook*);
        void *new_mem = algo_lib::lpool_ReallocMem(_db.bh_timehook_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FDb.bh_timehook");
        }
        _db.bh_timehook_elems = (algo_lib::FTimehook**)new_mem;
        _db.bh_timehook_max = new_max;
    }
}

// --- algo_lib.FDb.bh_timehook.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int algo_lib::bh_timehook_Upheap(algo_lib::FTimehook& row, int idx) {
    algo_lib::FTimehook* *elems = _db.bh_timehook_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        algo_lib::FTimehook* p = elems[j];
        if (!bh_timehook_ElemLt(row, *p)) {
            break;
        }
        p->bh_timehook_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- algo_lib.FDb.bh_timehook.ElemLt
inline static bool algo_lib::bh_timehook_ElemLt(algo_lib::FTimehook &a, algo_lib::FTimehook &b) {
    (void)_db;
    return time_Lt(a, b);
}

// --- algo_lib.FDb.bh_timehook.FirstChanged
// First element of index changed.
void algo_lib::bh_timehook_FirstChanged() {
}

// --- algo_lib.FDb.bh_timehook.UpdateCycles
// Update cycles count from previous clock capture
void algo_lib::bh_timehook_UpdateCycles() {
    u64 cur_cycles                      = get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++algo_lib::_db.trace.step_bh_timehook;
    algo_lib::_db.trace.step_bh_timehook_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = SchedTime(cur_cycles);
}

// --- algo_lib.FDb.dispsigcheck.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FDispsigcheck& algo_lib::dispsigcheck_Alloc() {
    algo_lib::FDispsigcheck* row = dispsigcheck_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.dispsigcheck  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.dispsigcheck.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FDispsigcheck* algo_lib::dispsigcheck_AllocMaybe() {
    algo_lib::FDispsigcheck *row = (algo_lib::FDispsigcheck*)dispsigcheck_AllocMem();
    if (row) {
        new (row) algo_lib::FDispsigcheck; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.dispsigcheck.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
algo_lib::FDispsigcheck* algo_lib::dispsigcheck_InsertMaybe(const dmmeta::Dispsigcheck &value) {
    algo_lib::FDispsigcheck *row = &dispsigcheck_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispsigcheck_CopyIn(*row,const_cast<dmmeta::Dispsigcheck&>(value));
    bool ok = dispsigcheck_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispsigcheck_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- algo_lib.FDb.dispsigcheck.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* algo_lib::dispsigcheck_AllocMem() {
    u64 new_nelems     = _db.dispsigcheck_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    algo_lib::FDispsigcheck*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispsigcheck_lary[bsr];
        if (!lev) {
            lev=(algo_lib::FDispsigcheck*)algo_lib::lpool_AllocMem(sizeof(algo_lib::FDispsigcheck) * (u64(1)<<bsr));
            _db.dispsigcheck_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispsigcheck_n = new_nelems;
        ret = lev + index;
    }
    return ret;
}

// --- algo_lib.FDb.dispsigcheck.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::dispsigcheck_RemoveLast() {
    u64 n = _db.dispsigcheck_n;
    if (n > 0) {
        n -= 1;
        dispsigcheck_qFind(u64(n)).~FDispsigcheck();
        _db.dispsigcheck_n = n;
    }
}

// --- algo_lib.FDb.dispsigcheck.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::dispsigcheck_XrefMaybe(algo_lib::FDispsigcheck &row) {
    bool retval = true;
    (void)row;
    // insert dispsigcheck into index ind_dispsigcheck
    if (true) { // user-defined insert condition
        bool success = ind_dispsigcheck_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "algo_lib.duplicate_key  xref:algo_lib.FDb.ind_dispsigcheck"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- algo_lib.FDb.ind_dispsigcheck.Find
// Find row by key. Return NULL if not found.
algo_lib::FDispsigcheck* algo_lib::ind_dispsigcheck_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_dispsigcheck_buckets_n - 1);
    algo_lib::FDispsigcheck* *e = &_db.ind_dispsigcheck_buckets_elems[index];
    algo_lib::FDispsigcheck* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).dispsig == key;
        if (done) break;
        e         = &ret->ind_dispsigcheck_next;
    } while (true);
    return ret;
}

// --- algo_lib.FDb.ind_dispsigcheck.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
algo_lib::FDispsigcheck& algo_lib::ind_dispsigcheck_GetOrCreate(const algo::strptr& key) {
    algo_lib::FDispsigcheck* ret = ind_dispsigcheck_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &dispsigcheck_Alloc();
        (*ret).dispsig = key;
        bool good = dispsigcheck_XrefMaybe(*ret);
        if (!good) {
            dispsigcheck_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- algo_lib.FDb.ind_dispsigcheck.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool algo_lib::ind_dispsigcheck_InsertMaybe(algo_lib::FDispsigcheck& row) {
    ind_dispsigcheck_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_dispsigcheck_next == (algo_lib::FDispsigcheck*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.dispsig) & (_db.ind_dispsigcheck_buckets_n - 1);
        algo_lib::FDispsigcheck* *prev = &_db.ind_dispsigcheck_buckets_elems[index];
        do {
            algo_lib::FDispsigcheck* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).dispsig == row.dispsig) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_dispsigcheck_next;
        } while (true);
        if (retval) {
            row.ind_dispsigcheck_next = *prev;
            _db.ind_dispsigcheck_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- algo_lib.FDb.ind_dispsigcheck.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void algo_lib::ind_dispsigcheck_Remove(algo_lib::FDispsigcheck& row) {
    if (LIKELY(row.ind_dispsigcheck_next != (algo_lib::FDispsigcheck*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.dispsig) & (_db.ind_dispsigcheck_buckets_n - 1);
        algo_lib::FDispsigcheck* *prev = &_db.ind_dispsigcheck_buckets_elems[index]; // addr of pointer to current element
        while (algo_lib::FDispsigcheck *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_dispsigcheck_next; // unlink (singly linked list)
                _db.ind_dispsigcheck_n--;
                row.ind_dispsigcheck_next = (algo_lib::FDispsigcheck*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_dispsigcheck_next;
        }
    }
}

// --- algo_lib.FDb.ind_dispsigcheck.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void algo_lib::ind_dispsigcheck_Reserve(int n) {
    u32 old_nbuckets = _db.ind_dispsigcheck_buckets_n;
    u32 new_nelems   = _db.ind_dispsigcheck_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(algo_lib::FDispsigcheck*);
        u32 new_size = new_nbuckets * sizeof(algo_lib::FDispsigcheck*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        algo_lib::FDispsigcheck* *new_buckets = (algo_lib::FDispsigcheck**)algo_lib::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FDb.ind_dispsigcheck");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_dispsigcheck_buckets_n; i++) {
            algo_lib::FDispsigcheck* elem = _db.ind_dispsigcheck_buckets_elems[i];
            while (elem) {
                algo_lib::FDispsigcheck &row        = *elem;
                algo_lib::FDispsigcheck* next       = row.ind_dispsigcheck_next;
                u32 index          = Smallstr50_Hash(0, row.dispsig) & (new_nbuckets-1);
                row.ind_dispsigcheck_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::lpool_FreeMem(_db.ind_dispsigcheck_buckets_elems, old_size);
        _db.ind_dispsigcheck_buckets_elems = new_buckets;
        _db.ind_dispsigcheck_buckets_n = new_nbuckets;
    }
}

// --- algo_lib.FDb.imdb.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FImdb& algo_lib::imdb_Alloc() {
    algo_lib::FImdb* row = imdb_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.imdb  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.imdb.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FImdb* algo_lib::imdb_AllocMaybe() {
    algo_lib::FImdb *row = (algo_lib::FImdb*)imdb_AllocMem();
    if (row) {
        new (row) algo_lib::FImdb; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.imdb.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
algo_lib::FImdb* algo_lib::imdb_InsertMaybe(const algo::Imdb &value) {
    algo_lib::FImdb *row = &imdb_Alloc(); // if out of memory, process dies. if input error, return NULL.
    imdb_CopyIn(*row,const_cast<algo::Imdb&>(value));
    bool ok = imdb_XrefMaybe(*row); // this may return false
    if (!ok) {
        imdb_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- algo_lib.FDb.imdb.RemoveAll
// Destroy all elements of Inlary
void algo_lib::imdb_RemoveAll() {
    for (u64 n = _db.imdb_n; n>0; ) {
        n--;
        reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data)[n].~FImdb(); // destroy last element
        _db.imdb_n=n;
    }
}

// --- algo_lib.FDb.imdb.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::imdb_RemoveLast() {
    u64 n = _db.imdb_n;
    if (n > 0) {
        n -= 1;
        reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data)[n].~FImdb();
        _db.imdb_n = n;
    }
}

// --- algo_lib.FDb.imdb.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::imdb_XrefMaybe(algo_lib::FImdb &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.ind_imdb.Find
// Find row by key. Return NULL if not found.
algo_lib::FImdb* algo_lib::ind_imdb_Find(const algo::strptr& key) {
    u32 index = Smallstr50_Hash(0, key) & (_db.ind_imdb_buckets_n - 1);
    algo_lib::FImdb* *e = &_db.ind_imdb_buckets_elems[index];
    algo_lib::FImdb* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).imdb == key;
        if (done) break;
        e         = &ret->ind_imdb_next;
    } while (true);
    return ret;
}

// --- algo_lib.FDb.ind_imdb.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
algo_lib::FImdb& algo_lib::ind_imdb_GetOrCreate(const algo::strptr& key) {
    algo_lib::FImdb* ret = ind_imdb_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &imdb_Alloc();
        (*ret).imdb = key;
        bool good = imdb_XrefMaybe(*ret);
        if (!good) {
            imdb_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    return *ret;
}

// --- algo_lib.FDb.ind_imdb.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool algo_lib::ind_imdb_InsertMaybe(algo_lib::FImdb& row) {
    ind_imdb_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_imdb_next == (algo_lib::FImdb*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.imdb) & (_db.ind_imdb_buckets_n - 1);
        algo_lib::FImdb* *prev = &_db.ind_imdb_buckets_elems[index];
        do {
            algo_lib::FImdb* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).imdb == row.imdb) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_imdb_next;
        } while (true);
        if (retval) {
            row.ind_imdb_next = *prev;
            _db.ind_imdb_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- algo_lib.FDb.ind_imdb.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void algo_lib::ind_imdb_Remove(algo_lib::FImdb& row) {
    if (LIKELY(row.ind_imdb_next != (algo_lib::FImdb*)-1)) {// check if in hash already
        u32 index = Smallstr50_Hash(0, row.imdb) & (_db.ind_imdb_buckets_n - 1);
        algo_lib::FImdb* *prev = &_db.ind_imdb_buckets_elems[index]; // addr of pointer to current element
        while (algo_lib::FImdb *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_imdb_next; // unlink (singly linked list)
                _db.ind_imdb_n--;
                row.ind_imdb_next = (algo_lib::FImdb*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_imdb_next;
        }
    }
}

// --- algo_lib.FDb.ind_imdb.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void algo_lib::ind_imdb_Reserve(int n) {
    u32 old_nbuckets = _db.ind_imdb_buckets_n;
    u32 new_nelems   = _db.ind_imdb_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(algo_lib::FImdb*);
        u32 new_size = new_nbuckets * sizeof(algo_lib::FImdb*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        algo_lib::FImdb* *new_buckets = (algo_lib::FImdb**)algo_lib::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FDb.ind_imdb");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_imdb_buckets_n; i++) {
            algo_lib::FImdb* elem = _db.ind_imdb_buckets_elems[i];
            while (elem) {
                algo_lib::FImdb &row        = *elem;
                algo_lib::FImdb* next       = row.ind_imdb_next;
                u32 index          = Smallstr50_Hash(0, row.imdb) & (new_nbuckets-1);
                row.ind_imdb_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::lpool_FreeMem(_db.ind_imdb_buckets_elems, old_size);
        _db.ind_imdb_buckets_elems = new_buckets;
        _db.ind_imdb_buckets_n = new_nbuckets;
    }
}

// --- algo_lib.FDb.malloc.AllocMem
// Allocate n bytes. If no memory available, return NULL.
void* algo_lib::malloc_AllocMem(size_t n) {
    void* mem = malloc(n);
    ++algo_lib::_db.trace.alloc__db_malloc; // update global malloc counter
    return mem;
}

// --- algo_lib.FDb.malloc.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void algo_lib::malloc_FreeMem(void *mem, size_t n) {
    (void)n;
    if (mem) {
        ++algo_lib::_db.trace.del__db_malloc; // update global malloc counter
        free(mem);
    }
}

// --- algo_lib.FDb.malloc.ReallocMem
// Reallocate n bytes. If the call fails, return value is NULL.
// In this case, original MEM pointer is untouched.
void* algo_lib::malloc_ReallocMem(void *mem, size_t old_size, size_t new_size) {
    (void)old_size;
    algo_lib::_db.trace.alloc__db_malloc += old_size == 0; // update global malloc counter
    algo_lib::_db.trace.del__db_malloc += new_size == 0; // update global malloc counter
    void* new_mem = realloc(mem, new_size);
    return new_mem;
}

// --- algo_lib.FDb.txtcell.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FTxtcell& algo_lib::txtcell_Alloc() {
    algo_lib::FTxtcell* row = txtcell_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.txtcell  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.txtcell.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FTxtcell* algo_lib::txtcell_AllocMaybe() {
    algo_lib::FTxtcell *row = (algo_lib::FTxtcell*)txtcell_AllocMem();
    if (row) {
        new (row) algo_lib::FTxtcell; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.txtcell.Delete
// Remove row from all global and cross indices, then deallocate row
void algo_lib::txtcell_Delete(algo_lib::FTxtcell &row) {
    row.~FTxtcell();
    txtcell_FreeMem(row);
}

// --- algo_lib.FDb.txtcell.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* algo_lib::txtcell_AllocMem() {
    algo_lib::FTxtcell *row = _db.txtcell_free;
    if (UNLIKELY(!row)) {
        txtcell_Reserve(1);
        row = _db.txtcell_free;
    }
    if (row) {
        _db.txtcell_free = row->txtcell_next;
    }
    return row;
}

// --- algo_lib.FDb.txtcell.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void algo_lib::txtcell_FreeMem(algo_lib::FTxtcell &row) {
    if (UNLIKELY(row.txtcell_next != (algo_lib::FTxtcell*)-1)) {
        FatalErrorExit("algo_lib.tpool_double_delete  pool:algo_lib.FDb.txtcell  comment:'double deletion caught'");
    }
    row.txtcell_next = _db.txtcell_free; // insert into free list
    _db.txtcell_free  = &row;
}

// --- algo_lib.FDb.txtcell.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 algo_lib::txtcell_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.txtcell_blocksize; // underlying allocator is probably Lpool
        u64 reserved = txtcell_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- algo_lib.FDb.txtcell.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 algo_lib::txtcell_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(algo_lib::FTxtcell)) {
        algo_lib::FTxtcell *mem = (algo_lib::FTxtcell*)algo_lib::lpool_AllocMem(size);
        ret = mem ? size / sizeof(algo_lib::FTxtcell) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].txtcell_next = _db.txtcell_free;
            _db.txtcell_free = mem+i;
        }
    }
    return ret;
}

// --- algo_lib.FDb.txtcell.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::txtcell_XrefMaybe(algo_lib::FTxtcell &row) {
    bool retval = true;
    (void)row;
    algo_lib::FTxtrow* p_p_txtrow = row.p_txtrow;
    if (UNLIKELY(!p_p_txtrow)) {
        algo_lib::ResetErrtext() << "algo_lib.null_ref  xref:algo_lib.FTxtrow.c_txtcell";
        return false;
    }
    // insert txtcell into index c_txtcell
    if (true) { // user-defined insert condition
        c_txtcell_Insert(*p_p_txtrow, row);
    }
    return retval;
}

// --- algo_lib.FDb.txtrow.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FTxtrow& algo_lib::txtrow_Alloc() {
    algo_lib::FTxtrow* row = txtrow_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.txtrow  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.txtrow.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FTxtrow* algo_lib::txtrow_AllocMaybe() {
    algo_lib::FTxtrow *row = (algo_lib::FTxtrow*)txtrow_AllocMem();
    if (row) {
        new (row) algo_lib::FTxtrow; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.txtrow.Delete
// Remove row from all global and cross indices, then deallocate row
void algo_lib::txtrow_Delete(algo_lib::FTxtrow &row) {
    row.~FTxtrow();
    txtrow_FreeMem(row);
}

// --- algo_lib.FDb.txtrow.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* algo_lib::txtrow_AllocMem() {
    algo_lib::FTxtrow *row = _db.txtrow_free;
    if (UNLIKELY(!row)) {
        txtrow_Reserve(1);
        row = _db.txtrow_free;
    }
    if (row) {
        _db.txtrow_free = row->txtrow_next;
    }
    return row;
}

// --- algo_lib.FDb.txtrow.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void algo_lib::txtrow_FreeMem(algo_lib::FTxtrow &row) {
    if (UNLIKELY(row.txtrow_next != (algo_lib::FTxtrow*)-1)) {
        FatalErrorExit("algo_lib.tpool_double_delete  pool:algo_lib.FDb.txtrow  comment:'double deletion caught'");
    }
    row.txtrow_next = _db.txtrow_free; // insert into free list
    _db.txtrow_free  = &row;
}

// --- algo_lib.FDb.txtrow.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 algo_lib::txtrow_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.txtrow_blocksize; // underlying allocator is probably Lpool
        u64 reserved = txtrow_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- algo_lib.FDb.txtrow.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 algo_lib::txtrow_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(algo_lib::FTxtrow)) {
        algo_lib::FTxtrow *mem = (algo_lib::FTxtrow*)algo_lib::lpool_AllocMem(size);
        ret = mem ? size / sizeof(algo_lib::FTxtrow) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].txtrow_next = _db.txtrow_free;
            _db.txtrow_free = mem+i;
        }
    }
    return ret;
}

// --- algo_lib.FDb.txtrow.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::txtrow_XrefMaybe(algo_lib::FTxtrow &row) {
    bool retval = true;
    (void)row;
    algo_lib::FTxttbl* p_p_txttbl = row.p_txttbl;
    if (UNLIKELY(!p_p_txttbl)) {
        algo_lib::ResetErrtext() << "algo_lib.null_ref  xref:algo_lib.FTxttbl.c_txtrow";
        return false;
    }
    // insert txtrow into index c_txtrow
    if (true) { // user-defined insert condition
        c_txtrow_Insert(*p_p_txttbl, row);
    }
    return retval;
}

// --- algo_lib.FDb.txttbl.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::txttbl_XrefMaybe(algo_lib::FTxttbl &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.FDb.tempfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::tempfile_XrefMaybe(algo_lib::FTempfile &row) {
    bool retval = true;
    (void)row;
    // insert tempfile into index zd_tempfile
    if (true) { // user-defined insert condition
        zd_tempfile_Insert(row);
    }
    return retval;
}

// --- algo_lib.FDb.zd_tempfile.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void algo_lib::zd_tempfile_Insert(algo_lib::FTempfile& row) {
    if (!zd_tempfile_InLlistQ(row)) {
        algo_lib::FTempfile* old_tail = _db.zd_tempfile_tail;
        row.zd_tempfile_next = NULL;
        row.zd_tempfile_prev = old_tail;
        _db.zd_tempfile_tail = &row;
        algo_lib::FTempfile **new_row_a = &old_tail->zd_tempfile_next;
        algo_lib::FTempfile **new_row_b = &_db.zd_tempfile_head;
        algo_lib::FTempfile **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_tempfile_n++;
    }
}

// --- algo_lib.FDb.zd_tempfile.Remove
// Remove element from index. If element is not in index, do nothing.
void algo_lib::zd_tempfile_Remove(algo_lib::FTempfile& row) {
    if (zd_tempfile_InLlistQ(row)) {
        algo_lib::FTempfile* old_head       = _db.zd_tempfile_head;
        (void)old_head; // in case it's not used
        algo_lib::FTempfile* prev = row.zd_tempfile_prev;
        algo_lib::FTempfile* next = row.zd_tempfile_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        algo_lib::FTempfile **new_next_a = &prev->zd_tempfile_next;
        algo_lib::FTempfile **new_next_b = &_db.zd_tempfile_head;
        algo_lib::FTempfile **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        algo_lib::FTempfile **new_prev_a = &next->zd_tempfile_prev;
        algo_lib::FTempfile **new_prev_b = &_db.zd_tempfile_tail;
        algo_lib::FTempfile **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_tempfile_n--;
        row.zd_tempfile_next=(algo_lib::FTempfile*)-1; // not-in-list
    }
}

// --- algo_lib.FDb.zd_tempfile.RemoveAll
// Empty the index. (The rows are not deleted)
void algo_lib::zd_tempfile_RemoveAll() {
    algo_lib::FTempfile* row = _db.zd_tempfile_head;
    _db.zd_tempfile_head = NULL;
    _db.zd_tempfile_tail = NULL;
    _db.zd_tempfile_n = 0;
    while (row) {
        algo_lib::FTempfile* row_next = row->zd_tempfile_next;
        row->zd_tempfile_next  = (algo_lib::FTempfile*)-1;
        row->zd_tempfile_prev  = NULL;
        row = row_next;
    }
}

// --- algo_lib.FDb.zd_tempfile.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
algo_lib::FTempfile* algo_lib::zd_tempfile_RemoveFirst() {
    algo_lib::FTempfile *row = NULL;
    row = _db.zd_tempfile_head;
    if (row) {
        algo_lib::FTempfile *next = row->zd_tempfile_next;
        _db.zd_tempfile_head = next;
        algo_lib::FTempfile **new_end_a = &next->zd_tempfile_prev;
        algo_lib::FTempfile **new_end_b = &_db.zd_tempfile_tail;
        algo_lib::FTempfile **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_tempfile_n--;
        row->zd_tempfile_next = (algo_lib::FTempfile*)-1; // mark as not-in-list
    }
    return row;
}

// --- algo_lib.FDb.replvar.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
algo_lib::FReplvar& algo_lib::replvar_Alloc() {
    algo_lib::FReplvar* row = replvar_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("algo_lib.out_of_mem  field:algo_lib.FDb.replvar  comment:'Alloc failed'");
    }
    return *row;
}

// --- algo_lib.FDb.replvar.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
algo_lib::FReplvar* algo_lib::replvar_AllocMaybe() {
    algo_lib::FReplvar *row = (algo_lib::FReplvar*)replvar_AllocMem();
    if (row) {
        new (row) algo_lib::FReplvar; // call constructor
    }
    return row;
}

// --- algo_lib.FDb.replvar.Delete
// Remove row from all global and cross indices, then deallocate row
void algo_lib::replvar_Delete(algo_lib::FReplvar &row) {
    row.~FReplvar();
    replvar_FreeMem(row);
}

// --- algo_lib.FDb.replvar.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* algo_lib::replvar_AllocMem() {
    algo_lib::FReplvar *row = _db.replvar_free;
    if (UNLIKELY(!row)) {
        replvar_Reserve(1);
        row = _db.replvar_free;
    }
    if (row) {
        _db.replvar_free = row->replvar_next;
    }
    return row;
}

// --- algo_lib.FDb.replvar.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void algo_lib::replvar_FreeMem(algo_lib::FReplvar &row) {
    if (UNLIKELY(row.replvar_next != (algo_lib::FReplvar*)-1)) {
        FatalErrorExit("algo_lib.tpool_double_delete  pool:algo_lib.FDb.replvar  comment:'double deletion caught'");
    }
    row.replvar_next = _db.replvar_free; // insert into free list
    _db.replvar_free  = &row;
}

// --- algo_lib.FDb.replvar.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 algo_lib::replvar_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.replvar_blocksize; // underlying allocator is probably Lpool
        u64 reserved = replvar_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- algo_lib.FDb.replvar.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 algo_lib::replvar_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(algo_lib::FReplvar)) {
        algo_lib::FReplvar *mem = (algo_lib::FReplvar*)algo_lib::lpool_AllocMem(size);
        ret = mem ? size / sizeof(algo_lib::FReplvar) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].replvar_next = _db.replvar_free;
            _db.replvar_free = mem+i;
        }
    }
    return ret;
}

// --- algo_lib.FDb.replvar.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::replvar_XrefMaybe(algo_lib::FReplvar &row) {
    bool retval = true;
    (void)row;
    algo_lib::Replscope* p_p_replscope = row.p_replscope;
    if (UNLIKELY(!p_p_replscope)) {
        algo_lib::ResetErrtext() << "algo_lib.null_ref  xref:algo_lib.Replscope.ind_replvar";
        return false;
    }
    // insert replvar into index ind_replvar
    if (true) { // user-defined insert condition
        bool success = ind_replvar_InsertMaybe(*p_p_replscope, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "algo_lib.duplicate_key  xref:algo_lib.Replscope.ind_replvar"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- algo_lib.FDb.giveup_time.UpdateCycles
// Update cycles count from previous clock capture
void algo_lib::giveup_time_UpdateCycles() {
    u64 cur_cycles                      = get_cycles();
    u64 prev_cycles                     = algo_lib::_db.clock.value;
    ++algo_lib::_db.trace.step_giveup_time;
    algo_lib::_db.trace.step_giveup_time_cycles  += cur_cycles - prev_cycles;
    algo_lib::_db.clock                 = SchedTime(cur_cycles);
}

// --- algo_lib.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr algo_lib::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- algo_lib.FDb.trace.N
// Function return 1
inline static i32 algo_lib::trace_N() {
    return 1;
}

// --- algo_lib.FDb.bh_timehook_curs.Add
static void algo_lib::_db_bh_timehook_curs_Add(_db_bh_timehook_curs &curs, algo_lib::FTimehook& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    algo_lib::FTimehook* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        algo_lib::FTimehook* p = elems[j];
        if (!bh_timehook_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- algo_lib.FDb.bh_timehook_curs.Reserve
void algo_lib::_db_bh_timehook_curs_Reserve(_db_bh_timehook_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_timehook_N();
        curs.temp_elems   = (algo_lib::FTimehook**)algo_lib::lpool_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("algo_lib.cursor_out_of_memory  func:algo_lib.FDb.bh_timehook_curs.Reserve");
        }
        curs.temp_max       = bh_timehook_N();
    }
}

// --- algo_lib.FDb.bh_timehook_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void algo_lib::_db_bh_timehook_curs_Reset(_db_bh_timehook_curs &curs, algo_lib::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_timehook_curs_Reserve(curs, bh_timehook_N());
    curs.temp_n = 0;
    if (parent.bh_timehook_n > 0) {
        algo_lib::FTimehook &first = *parent.bh_timehook_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- algo_lib.FDb.bh_timehook_curs.Next
// Advance cursor.
void algo_lib::_db_bh_timehook_curs_Next(_db_bh_timehook_curs &curs) {
    algo_lib::FTimehook* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        algo_lib::FTimehook* dead = elems[0];
        int i       = 0;
        algo_lib::FTimehook* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            algo_lib::FTimehook* choose = last;
            int l         = i*2+1;
            if (l<n) {
                algo_lib::FTimehook* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                algo_lib::FTimehook* er = elems[r];
                if (bh_timehook_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_timehook_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_timehook_idx;
        i = (index*2+1);
        if (i < bh_timehook_N()) {
            algo_lib::FTimehook &elem = *curs.parent->bh_timehook_elems[i];
            _db_bh_timehook_curs_Add(curs, elem);
        }
        if (i+1 < bh_timehook_N()) {
            algo_lib::FTimehook &elem = *curs.parent->bh_timehook_elems[i + 1];
            _db_bh_timehook_curs_Add(curs, elem);
        }
    }
}

// --- algo_lib.FDb..Init
// Set all fields to initial values.
void algo_lib::FDb_Init() {
    _db.sbrk_huge_limit = 0;
    _db.sbrk_huge_alloc = 0;
    _db.sbrk_zeromem = false;
    memset(_db.lpool_free, 0, sizeof(_db.lpool_free));
    _db.limit = algo::SchedTime(0x7fffffffffffffff);
    _db.clocks_to_ms = double(0.0);
    _db.n_iohook = u32(0);
    _db.hz = double(0.0);
    _db.exit_code = i32(0);
    _db.clocks_to_ns = double(0.0);
    _db.n_temp = u32(0);
    _db.last_signal = u32(0);
    _db.eol = bool(false);
    _db.cpu_hz = u64(0);
    (void)Charset_ReadStrptrMaybe(_db.ArgvIdent, "a-zA-Z0-9_");
    (void)Charset_ReadStrptrMaybe(_db.BashQuotesafe, "a-zA-Z0-9_^%@./-");
    (void)Charset_ReadStrptrPlain(_db.RegxSqlSpecial, "$.|?*+(){}^\\[]#");
    (void)Charset_ReadStrptrPlain(_db.SsimBreakName, "[]{}()\t \r\n:");
    (void)Charset_ReadStrptrPlain(_db.SsimBreakValue, "[]{}()\t \r\n");
    (void)Charset_ReadStrptrMaybe(_db.SsimQuotesafe, "a-zA-Z0-9_;&*^%$@.!:,+/-");
    algo_lib::_db.last_signal             = 0;
    ary_beg(cstring, str, algo_lib::temp_strings_Getary()) {
        ch_Reserve(str, 256);
    }ary_end;
    algo_lib::_db.n_temp = algo_lib::temp_strings_N();
    algo_lib::bh_timehook_Reserve(32);
    algo_lib::InitCpuHz();
    algo_lib::_db.eol          = true;
    // initialize LAry imtable (algo_lib.FDb.imtable)
    _db.imtable_n = 0;
    memset(_db.imtable_lary, 0, sizeof(_db.imtable_lary)); // zero out all level pointers
    algo_lib::FImtable* imtable_first = (algo_lib::FImtable*)algo_lib::lpool_AllocMem(sizeof(algo_lib::FImtable) * (u64(1)<<4));
    if (!imtable_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.imtable_lary[i]  = imtable_first;
        imtable_first    += 1ULL<<i;
    }
    // initialize hash table for algo_lib::FImtable;
    _db.ind_imtable_n             	= 0; // (algo_lib.FDb.ind_imtable)
    _db.ind_imtable_buckets_n     	= 4; // (algo_lib.FDb.ind_imtable)
    _db.ind_imtable_buckets_elems 	= (algo_lib::FImtable**)algo_lib::lpool_AllocMem(sizeof(algo_lib::FImtable*)*_db.ind_imtable_buckets_n); // initial buckets (algo_lib.FDb.ind_imtable)
    if (!_db.ind_imtable_buckets_elems) {
        FatalErrorExit("out of memory"); // (algo_lib.FDb.ind_imtable)
    }
    memset(_db.ind_imtable_buckets_elems, 0, sizeof(algo_lib::FImtable*)*_db.ind_imtable_buckets_n); // (algo_lib.FDb.ind_imtable)
    _db.bh_timehook_max   	= 0; // (algo_lib.FDb.bh_timehook)
    _db.bh_timehook_n     	= 0; // (algo_lib.FDb.bh_timehook)
    _db.bh_timehook_elems 	= NULL; // (algo_lib.FDb.bh_timehook)
    _db.epoll_fd = i32(-1);
    _db.c_timehook = NULL;
    // initialize LAry dispsigcheck (algo_lib.FDb.dispsigcheck)
    _db.dispsigcheck_n = 0;
    memset(_db.dispsigcheck_lary, 0, sizeof(_db.dispsigcheck_lary)); // zero out all level pointers
    algo_lib::FDispsigcheck* dispsigcheck_first = (algo_lib::FDispsigcheck*)algo_lib::lpool_AllocMem(sizeof(algo_lib::FDispsigcheck) * (u64(1)<<4));
    if (!dispsigcheck_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispsigcheck_lary[i]  = dispsigcheck_first;
        dispsigcheck_first    += 1ULL<<i;
    }
    // initialize hash table for algo_lib::FDispsigcheck;
    _db.ind_dispsigcheck_n             	= 0; // (algo_lib.FDb.ind_dispsigcheck)
    _db.ind_dispsigcheck_buckets_n     	= 4; // (algo_lib.FDb.ind_dispsigcheck)
    _db.ind_dispsigcheck_buckets_elems 	= (algo_lib::FDispsigcheck**)algo_lib::lpool_AllocMem(sizeof(algo_lib::FDispsigcheck*)*_db.ind_dispsigcheck_buckets_n); // initial buckets (algo_lib.FDb.ind_dispsigcheck)
    if (!_db.ind_dispsigcheck_buckets_elems) {
        FatalErrorExit("out of memory"); // (algo_lib.FDb.ind_dispsigcheck)
    }
    memset(_db.ind_dispsigcheck_buckets_elems, 0, sizeof(algo_lib::FDispsigcheck*)*_db.ind_dispsigcheck_buckets_n); // (algo_lib.FDb.ind_dispsigcheck)
    _db.imdb_n = 0; // imdb: initialize count
    // initialize hash table for algo_lib::FImdb;
    _db.ind_imdb_n             	= 0; // (algo_lib.FDb.ind_imdb)
    _db.ind_imdb_buckets_n     	= 4; // (algo_lib.FDb.ind_imdb)
    _db.ind_imdb_buckets_elems 	= (algo_lib::FImdb**)algo_lib::lpool_AllocMem(sizeof(algo_lib::FImdb*)*_db.ind_imdb_buckets_n); // initial buckets (algo_lib.FDb.ind_imdb)
    if (!_db.ind_imdb_buckets_elems) {
        FatalErrorExit("out of memory"); // (algo_lib.FDb.ind_imdb)
    }
    memset(_db.ind_imdb_buckets_elems, 0, sizeof(algo_lib::FImdb*)*_db.ind_imdb_buckets_n); // (algo_lib.FDb.ind_imdb)
    // txtcell: initialize Tpool
    _db.txtcell_free      = NULL;
    _db.txtcell_blocksize = BumpToPow2(64 * sizeof(algo_lib::FTxtcell)); // allocate 64-127 elements at a time
    // txtrow: initialize Tpool
    _db.txtrow_free      = NULL;
    _db.txtrow_blocksize = BumpToPow2(64 * sizeof(algo_lib::FTxtrow)); // allocate 64-127 elements at a time
    _db.argc = i32(0);
    _db.argv = NULL;
    _db.zd_tempfile_head = NULL; // (algo_lib.FDb.zd_tempfile)
    _db.zd_tempfile_n = 0; // (algo_lib.FDb.zd_tempfile)
    _db.zd_tempfile_tail = NULL; // (algo_lib.FDb.zd_tempfile)
    // replvar: initialize Tpool
    _db.replvar_free      = NULL;
    _db.replvar_blocksize = BumpToPow2(64 * sizeof(algo_lib::FReplvar)); // allocate 64-127 elements at a time
    _db.giveup_count = u64(0);
    _db.stringtofile_nwrite = u32(0);
    _db.giveup_time = bool(true);
    _db.sleep_roundup = bool(false);
    _db.last_sleep_clocks = u64(0);
    _db.show_insert_err_lim = u32(0);
    (void)Charset_ReadStrptrMaybe(_db.Urlsafe, "0-9a-zA-Z_.~");

    algo_lib::InitReflection();
    _db.h_fatalerror = NULL;
    _db.h_fatalerror_ctx = 0;
}

// --- algo_lib.FDb..Uninit
void algo_lib::FDb_Uninit() {
    algo_lib::FDb &row = _db; (void)row;

    // algo_lib.FDb.ind_imdb.Uninit (Thash)  //
    // skip destruction of ind_imdb in global scope

    // algo_lib.FDb.imdb.Uninit (Inlary)  //
    // skip destruction in global scope

    // algo_lib.FDb.ind_dispsigcheck.Uninit (Thash)  //
    // skip destruction of ind_dispsigcheck in global scope

    // algo_lib.FDb.dispsigcheck.Uninit (Lary)  //
    // skip destruction in global scope

    // algo_lib.FDb.bh_timehook.Uninit (Bheap)  //Binary heap of time-based callbacks
    // skip destruction in global scope

    // algo_lib.FDb.ind_imtable.Uninit (Thash)  //
    // skip destruction of ind_imtable in global scope

    // algo_lib.FDb.imtable.Uninit (Lary)  //Array of all in-memory tables linked into this process
    // skip destruction in global scope
}

// --- algo_lib.FDispsigcheck.msghdr.CopyOut
// Copy fields out of row
void algo_lib::dispsigcheck_CopyOut(algo_lib::FDispsigcheck &row, dmmeta::Dispsigcheck &out) {
    out.dispsig = row.dispsig;
    out.signature = row.signature;
}

// --- algo_lib.FDispsigcheck.msghdr.CopyIn
// Copy fields in to row
void algo_lib::dispsigcheck_CopyIn(algo_lib::FDispsigcheck &row, dmmeta::Dispsigcheck &in) {
    row.dispsig = in.dispsig;
    row.signature = in.signature;
}

// --- algo_lib.FDispsigcheck..Uninit
void algo_lib::FDispsigcheck_Uninit(algo_lib::FDispsigcheck& dispsigcheck) {
    algo_lib::FDispsigcheck &row = dispsigcheck; (void)row;
    ind_dispsigcheck_Remove(row); // remove dispsigcheck from index ind_dispsigcheck
}

// --- algo_lib.FDispsigcheck..Print
// print string representation of algo_lib::FDispsigcheck to string LHS, no header -- cprint:algo_lib.FDispsigcheck.String
void algo_lib::FDispsigcheck_Print(algo_lib::FDispsigcheck & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.FDispsigcheck";

    algo::Smallstr50_Print(row.dispsig, temp);
    PrintAttrSpaceReset(str,"dispsig", temp);

    algo::Sha1sig_Print(row.signature, temp);
    PrintAttrSpaceReset(str,"signature", temp);
}

// --- algo_lib.FImtable.msghdr.CopyOut
// Copy fields out of row
void algo_lib::imtable_CopyOut(algo_lib::FImtable &row, algo::Imtable &out) {
    out.imtable = row.imtable;
    out.elem_type = row.elem_type;
    out.c_RowidFind = row.c_RowidFind;
    out.XrefX = row.XrefX;
    out.NItems = row.NItems;
    out.Print = row.Print;
    out.size = row.size;
    out.ssimfile = row.ssimfile;
    out.comment = row.comment;
}

// --- algo_lib.FImtable.msghdr.CopyIn
// Copy fields in to row
void algo_lib::imtable_CopyIn(algo_lib::FImtable &row, algo::Imtable &in) {
    row.imtable = in.imtable;
    row.elem_type = in.elem_type;
    row.c_RowidFind = in.c_RowidFind;
    row.XrefX = in.XrefX;
    row.NItems = in.NItems;
    row.Print = in.Print;
    row.size = in.size;
    row.ssimfile = in.ssimfile;
    row.comment = in.comment;
}

// --- algo_lib.FImtable..Uninit
void algo_lib::FImtable_Uninit(algo_lib::FImtable& imtable) {
    algo_lib::FImtable &row = imtable; (void)row;
    ind_imtable_Remove(row); // remove imtable from index ind_imtable
}

// --- algo_lib.FIohook..Uninit
void algo_lib::FIohook_Uninit(algo_lib::FIohook& iohook) {
    algo_lib::FIohook &row = iohook; (void)row;
    fildes_Cleanup(iohook); // dmmeta.fcleanup:algo_lib.FIohook.fildes
}

// --- algo_lib.FReplvar..Uninit
void algo_lib::FReplvar_Uninit(algo_lib::FReplvar& replvar) {
    algo_lib::FReplvar &row = replvar; (void)row;
    algo_lib::Replscope* p_p_replscope = row.p_replscope;
    if (p_p_replscope)  {
        ind_replvar_Remove(*p_p_replscope, row);// remove replvar from index ind_replvar
    }
}

// --- algo_lib.FTempfile..Uninit
void algo_lib::FTempfile_Uninit(algo_lib::FTempfile& tempfile) {
    algo_lib::FTempfile &row = tempfile; (void)row;
    zd_tempfile_Remove(row); // remove tempfile from index zd_tempfile
    fildes_Cleanup(tempfile); // dmmeta.fcleanup:algo_lib.FTempfile.fildes
}

// --- algo_lib.FTxtcell..Uninit
void algo_lib::FTxtcell_Uninit(algo_lib::FTxtcell& txtcell) {
    algo_lib::FTxtcell &row = txtcell; (void)row;
    algo_lib::FTxtrow* p_p_txtrow = row.p_txtrow;
    if (p_p_txtrow)  {
        c_txtcell_Remove(*p_p_txtrow, row);// remove txtcell from index c_txtcell
    }
}

// --- algo_lib.FTxtrow.sortkey.Nextchar
// Extract next character from STR and advance IDX
inline static u64 algo_lib::sortkey_Nextchar(const algo_lib::FTxtrow& txtrow, strptr &str, int &idx) {
    (void)txtrow;
    int i = idx;
    u64 ch = str.elems[i];
    i++;
    // downcase the char for case-insensitive comparison
    if (ch >= 'A' && ch <= 'Z') {
        ch = ch - 'A' + 'a';
    }
    // detect number in string and eat it up into CH.
    // (this only works for base-10 numbers
    // Digits are sorted before chars
    if (unsigned(ch - '0') < 10) {
        while(i < str.n_elems) { // resulting char sorts before ascii 47
            unsigned dig = str.elems[i] - '0';
            if (dig >= 10) break;
            ch = ch * 10 + dig;
            i++;
        }
    } else if (ch > '9') {
        // create space between '0'..'9' for 15-digit numbers
        ch += 1000000000000000LL;
    }
    idx = i;
    return ch;
}

// --- algo_lib.FTxtrow.sortkey.Cmp
// Compare two fields.
// Comparison uses version sort (detect embedded integers).
// Comparison is case-insensitive.
i32 algo_lib::sortkey_Cmp(algo_lib::FTxtrow& txtrow, algo_lib::FTxtrow &rhs) {
    i32 retval = 0;
    int idx_a = 0;
    int idx_b = 0;
    strptr str_a = ch_Getary(txtrow.sortkey);
    strptr str_b = ch_Getary(rhs.sortkey);
    int n_a   = elems_N(str_a);
    int n_b   = elems_N(str_b);
    retval    = i32_Cmp(n_a,n_b);
    while (idx_a < n_a && idx_b < n_b) {
        u64 ch_a = sortkey_Nextchar(txtrow, str_a, idx_a);
        u64 ch_b = sortkey_Nextchar(rhs, str_b, idx_b);
        if (ch_a != ch_b) {
            retval = (ch_a > ch_b)*2-1;
            break;
        }
    }
    return retval;
}

// --- algo_lib.FTxtrow.c_txtcell.Cascdel
// Delete all elements pointed to by the index.
void algo_lib::c_txtcell_Cascdel(algo_lib::FTxtrow& txtrow) {
    // Clear c_txtcell_n so that calls to algo_lib.FTxtrow.c_txtcell.Remove do not have to scan
    // the array for pointers or shift anything.
    // This is somewhat of a hack.
    i32 n = txtrow.c_txtcell_n;
    txtrow.c_txtcell_n = 0;
    for (i32 i = n - 1; i >= 0; i--) {
        algo_lib::FTxtcell &row = *txtrow.c_txtcell_elems[i];
        row.txtrow_c_txtcell_in_ary = false;
        txtcell_Delete(row);
    }
}

// --- algo_lib.FTxtrow.c_txtcell.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void algo_lib::c_txtcell_Insert(algo_lib::FTxtrow& txtrow, algo_lib::FTxtcell& row) {
    if (bool_Update(row.txtrow_c_txtcell_in_ary,true)) {
        // reserve space
        c_txtcell_Reserve(txtrow, 1);
        u32 n  = txtrow.c_txtcell_n;
        u32 at = n;
        algo_lib::FTxtcell* *elems = txtrow.c_txtcell_elems;
        elems[at] = &row;
        txtrow.c_txtcell_n = n+1;

    }
}

// --- algo_lib.FTxtrow.c_txtcell.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool algo_lib::c_txtcell_InsertMaybe(algo_lib::FTxtrow& txtrow, algo_lib::FTxtcell& row) {
    bool retval = !row.txtrow_c_txtcell_in_ary;
    c_txtcell_Insert(txtrow,row); // check is performed in _Insert again
    return retval;
}

// --- algo_lib.FTxtrow.c_txtcell.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void algo_lib::c_txtcell_Remove(algo_lib::FTxtrow& txtrow, algo_lib::FTxtcell& row) {
    if (bool_Update(row.txtrow_c_txtcell_in_ary,false)) {
        int lim = txtrow.c_txtcell_n;
        algo_lib::FTxtcell* *elems = txtrow.c_txtcell_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            algo_lib::FTxtcell* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(algo_lib::FTxtcell*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                txtrow.c_txtcell_n = lim - 1;
                break;
            }
        }
    }
}

// --- algo_lib.FTxtrow.c_txtcell.Reserve
// Reserve space in index for N more elements;
void algo_lib::c_txtcell_Reserve(algo_lib::FTxtrow& txtrow, u32 n) {
    u32 old_max = txtrow.c_txtcell_max;
    if (UNLIKELY(txtrow.c_txtcell_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(algo_lib::FTxtcell*);
        u32 new_size = new_max * sizeof(algo_lib::FTxtcell*);
        void *new_mem = algo_lib::lpool_ReallocMem(txtrow.c_txtcell_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FTxtrow.c_txtcell");
        }
        txtrow.c_txtcell_elems = (algo_lib::FTxtcell**)new_mem;
        txtrow.c_txtcell_max = new_max;
    }
}

// --- algo_lib.FTxtrow..Uninit
void algo_lib::FTxtrow_Uninit(algo_lib::FTxtrow& txtrow) {
    algo_lib::FTxtrow &row = txtrow; (void)row;
    c_txtcell_Cascdel(txtrow); // dmmeta.cascdel:algo_lib.FTxtrow.c_txtcell
    algo_lib::FTxttbl* p_p_txttbl = row.p_txttbl;
    if (p_p_txttbl)  {
        c_txtrow_Remove(*p_p_txttbl, row);// remove txtrow from index c_txtrow
    }

    // algo_lib.FTxtrow.c_txtcell.Uninit (Ptrary)  //
    algo_lib::lpool_FreeMem(txtrow.c_txtcell_elems, sizeof(algo_lib::FTxtcell*)*txtrow.c_txtcell_max); // (algo_lib.FTxtrow.c_txtcell)
}

// --- algo_lib.FTxttbl.c_txtrow.Cascdel
// Delete all elements pointed to by the index.
void algo_lib::c_txtrow_Cascdel(algo_lib::FTxttbl& txttbl) {
    // Clear c_txtrow_n so that calls to algo_lib.FTxttbl.c_txtrow.Remove do not have to scan
    // the array for pointers or shift anything.
    // This is somewhat of a hack.
    i32 n = txttbl.c_txtrow_n;
    txttbl.c_txtrow_n = 0;
    for (i32 i = n - 1; i >= 0; i--) {
        algo_lib::FTxtrow &row = *txttbl.c_txtrow_elems[i];
        row.txttbl_c_txtrow_in_ary = false;
        txtrow_Delete(row);
    }
}

// --- algo_lib.FTxttbl.c_txtrow.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void algo_lib::c_txtrow_Insert(algo_lib::FTxttbl& txttbl, algo_lib::FTxtrow& row) {
    if (bool_Update(row.txttbl_c_txtrow_in_ary,true)) {
        // reserve space
        c_txtrow_Reserve(txttbl, 1);
        u32 n  = txttbl.c_txtrow_n;
        u32 at = n;
        algo_lib::FTxtrow* *elems = txttbl.c_txtrow_elems;
        elems[at] = &row;
        txttbl.c_txtrow_n = n+1;

    }
}

// --- algo_lib.FTxttbl.c_txtrow.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool algo_lib::c_txtrow_InsertMaybe(algo_lib::FTxttbl& txttbl, algo_lib::FTxtrow& row) {
    bool retval = !row.txttbl_c_txtrow_in_ary;
    c_txtrow_Insert(txttbl,row); // check is performed in _Insert again
    return retval;
}

// --- algo_lib.FTxttbl.c_txtrow.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void algo_lib::c_txtrow_Remove(algo_lib::FTxttbl& txttbl, algo_lib::FTxtrow& row) {
    if (bool_Update(row.txttbl_c_txtrow_in_ary,false)) {
        int lim = txttbl.c_txtrow_n;
        algo_lib::FTxtrow* *elems = txttbl.c_txtrow_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            algo_lib::FTxtrow* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(algo_lib::FTxtrow*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                txttbl.c_txtrow_n = lim - 1;
                break;
            }
        }
    }
}

// --- algo_lib.FTxttbl.c_txtrow.Reserve
// Reserve space in index for N more elements;
void algo_lib::c_txtrow_Reserve(algo_lib::FTxttbl& txttbl, u32 n) {
    u32 old_max = txttbl.c_txtrow_max;
    if (UNLIKELY(txttbl.c_txtrow_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(algo_lib::FTxtrow*);
        u32 new_size = new_max * sizeof(algo_lib::FTxtrow*);
        void *new_mem = algo_lib::lpool_ReallocMem(txttbl.c_txtrow_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.FTxttbl.c_txtrow");
        }
        txttbl.c_txtrow_elems = (algo_lib::FTxtrow**)new_mem;
        txttbl.c_txtrow_max = new_max;
    }
}

// --- algo_lib.FTxttbl.c_txtrow.Swap
// Swap values elem_a and elem_b
inline static void algo_lib::c_txtrow_Swap(algo_lib::FTxtrow* &elem_a, algo_lib::FTxtrow* &elem_b) {
    algo_lib::FTxtrow *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- algo_lib.FTxttbl.c_txtrow.Rotleft
// Left circular shift of three-tuple
inline static void algo_lib::c_txtrow_Rotleft(algo_lib::FTxtrow* &elem_a, algo_lib::FTxtrow* &elem_b, algo_lib::FTxtrow* &elem_c) {
    algo_lib::FTxtrow *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- algo_lib.FTxttbl.c_txtrow.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool algo_lib::c_txtrow_Lt(algo_lib::FTxtrow &elem_a, algo_lib::FTxtrow &elem_b) {
    bool ret;
    ret = sortkey_Lt(elem_a, elem_b);
    return ret;
}

// --- algo_lib.FTxttbl.c_txtrow.SortedQ
// Verify whether array is sorted
bool algo_lib::c_txtrow_SortedQ(algo_lib::FTxttbl& txttbl) {
    algo_lib::FTxtrow* *elems = c_txtrow_Getary(txttbl).elems;
    int n = c_txtrow_N(txttbl);
    for (int i = 1; i < n; i++) {
        if (c_txtrow_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- algo_lib.FTxttbl.c_txtrow.IntInsertionSort
// Internal insertion sort
static void algo_lib::c_txtrow_IntInsertionSort(algo_lib::FTxtrow* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        algo_lib::FTxtrow *tmp = elems[i];
        // shift elements up by one
        if (c_txtrow_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_txtrow_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- algo_lib.FTxttbl.c_txtrow.IntHeapSort
// Internal heap sort
static void algo_lib::c_txtrow_IntHeapSort(algo_lib::FTxtrow* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_txtrow_Lt(*elems[j], *elems[k])) {
            c_txtrow_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_txtrow_Lt(*elems[l], *elems[l+1]);
            if (c_txtrow_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_txtrow_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_txtrow_Swap(elems[i],elems[k]);
        }
    }
}

// --- algo_lib.FTxttbl.c_txtrow.IntQuickSort
// Quick sort engine
static void algo_lib::c_txtrow_IntQuickSort(algo_lib::FTxtrow* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_txtrow_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_txtrow_Lt(*elems[pp], *elems[pi])) {
            c_txtrow_Swap(elems[pi], elems[pp]);
        }
        if (c_txtrow_Lt(*elems[pj], *elems[pp])) {
            if (c_txtrow_Lt(*elems[pj], *elems[pi])) {
                c_txtrow_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_txtrow_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_txtrow_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        algo_lib::FTxtrow *pivot = elems[pj];
        for(;;){
            while (c_txtrow_Lt(*elems[++pi], *pivot)) {
            }
            while (c_txtrow_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_txtrow_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_txtrow_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_txtrow_IntInsertionSort(elems,n);
}

// --- algo_lib.FTxttbl.c_txtrow.InsertionSort
// Insertion sort
void algo_lib::c_txtrow_InsertionSort(algo_lib::FTxttbl& txttbl) {
    algo_lib::FTxtrow* *elems = c_txtrow_Getary(txttbl).elems;
    int n = c_txtrow_N(txttbl);
    c_txtrow_IntInsertionSort(elems, n);
}

// --- algo_lib.FTxttbl.c_txtrow.HeapSort
// Heap sort
void algo_lib::c_txtrow_HeapSort(algo_lib::FTxttbl& txttbl) {
    algo_lib::FTxtrow* *elems = c_txtrow_Getary(txttbl).elems;
    int n = c_txtrow_N(txttbl);
    c_txtrow_IntHeapSort(elems, n);
}

// --- algo_lib.FTxttbl.c_txtrow.QuickSort
// Quick sort
void algo_lib::c_txtrow_QuickSort(algo_lib::FTxttbl& txttbl) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = CeilingLog2(u32(c_txtrow_N(txttbl) + 1)) + 3;
    algo_lib::FTxtrow* *elems = c_txtrow_Getary(txttbl).elems;
    int n = c_txtrow_N(txttbl);
    c_txtrow_IntQuickSort(elems, n, max_depth);
}

// --- algo_lib.FTxttbl..Uninit
void algo_lib::FTxttbl_Uninit(algo_lib::FTxttbl& txttbl) {
    algo_lib::FTxttbl &row = txttbl; (void)row;
    c_txtrow_Cascdel(txttbl); // dmmeta.cascdel:algo_lib.FTxttbl.c_txtrow

    // algo_lib.FTxttbl.c_txtrow.Uninit (Ptrary)  //Array of cells
    algo_lib::lpool_FreeMem(txttbl.c_txtrow_elems, sizeof(algo_lib::FTxtrow*)*txttbl.c_txtrow_max); // (algo_lib.FTxttbl.c_txtrow)
}

// --- algo_lib.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo_lib::value_ToCstr(const algo_lib::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_lib_FieldId_verbose      : ret = "verbose";  break;
        case algo_lib_FieldId_debug        : ret = "debug";  break;
        case algo_lib_FieldId_help         : ret = "help";  break;
        case algo_lib_FieldId_version      : ret = "version";  break;
        case algo_lib_FieldId_sig          : ret = "sig";  break;
        case algo_lib_FieldId_signature    : ret = "signature";  break;
        case algo_lib_FieldId_expr         : ret = "expr";  break;
        case algo_lib_FieldId_state        : ret = "state";  break;
        case algo_lib_FieldId_front        : ret = "front";  break;
        case algo_lib_FieldId_next_front   : ret = "next_front";  break;
        case algo_lib_FieldId_accept       : ret = "accept";  break;
        case algo_lib_FieldId_start        : ret = "start";  break;
        case algo_lib_FieldId_parseerror   : ret = "parseerror";  break;
        case algo_lib_FieldId_accepts_all  : ret = "accepts_all";  break;
        case algo_lib_FieldId_value        : ret = "value";  break;
    }
    return ret;
}

// --- algo_lib.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo_lib::value_Print(const algo_lib::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo_lib.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo_lib::value_SetStrptrMaybe(algo_lib::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('s','i','g'): {
                    value_SetEnum(parent,algo_lib_FieldId_sig); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(ReadLE32(rhs.elems))) {
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,algo_lib_FieldId_expr); ret = true; break;
                }
                case LE_STR4('h','e','l','p'): {
                    value_SetEnum(parent,algo_lib_FieldId_help); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('d','e','b','u','g'): {
                    value_SetEnum(parent,algo_lib_FieldId_debug); ret = true; break;
                }
                case LE_STR5('f','r','o','n','t'): {
                    value_SetEnum(parent,algo_lib_FieldId_front); ret = true; break;
                }
                case LE_STR5('s','t','a','r','t'): {
                    value_SetEnum(parent,algo_lib_FieldId_start); ret = true; break;
                }
                case LE_STR5('s','t','a','t','e'): {
                    value_SetEnum(parent,algo_lib_FieldId_state); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,algo_lib_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','c','c','e','p','t'): {
                    value_SetEnum(parent,algo_lib_FieldId_accept); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('v','e','r','b','o','s','e'): {
                    value_SetEnum(parent,algo_lib_FieldId_verbose); ret = true; break;
                }
                case LE_STR7('v','e','r','s','i','o','n'): {
                    value_SetEnum(parent,algo_lib_FieldId_version); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('s','i','g','n','a','t','u','r'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,algo_lib_FieldId_signature); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('n','e','x','t','_','f','r','o'): {
                    if (memcmp(rhs.elems+8,"nt",2)==0) { value_SetEnum(parent,algo_lib_FieldId_next_front); ret = true; break; }
                    break;
                }
                case LE_STR8('p','a','r','s','e','e','r','r'): {
                    if (memcmp(rhs.elems+8,"or",2)==0) { value_SetEnum(parent,algo_lib_FieldId_parseerror); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('a','c','c','e','p','t','s','_'): {
                    if (memcmp(rhs.elems+8,"all",3)==0) { value_SetEnum(parent,algo_lib_FieldId_accepts_all); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo_lib.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo_lib::value_SetStrptr(algo_lib::FieldId& parent, algo::strptr rhs, algo_lib_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo_lib.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo_lib::value_ReadStrptrMaybe(algo_lib::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo_lib.FieldId..ReadStrptrMaybe
// Read fields of algo_lib::FieldId from an ascii string.
// The format of the string is the format of the algo_lib::FieldId's only field
bool algo_lib::FieldId_ReadStrptrMaybe(algo_lib::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo_lib::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo_lib.FieldId..Print
// print string representation of algo_lib::FieldId to string LHS, no header -- cprint:algo_lib.FieldId.String
void algo_lib::FieldId_Print(algo_lib::FieldId & row, algo::cstring &str) {
    algo_lib::value_Print(row, str);
}

// --- algo_lib.InTextFile.temp_buf.RemoveAll
// Destroy all elements of Inlary
void algo_lib::temp_buf_RemoveAll(algo_lib::InTextFile& parent) {
    parent.temp_buf_n = 0;
}

// --- algo_lib.InTextFile.temp_buf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::temp_buf_RemoveLast(algo_lib::InTextFile& parent) {
    u64 n = parent.temp_buf_n;
    if (n > 0) {
        n -= 1;
        parent.temp_buf_n = n;
    }
}

// --- algo_lib.InTextFile..Init
// Set all fields to initial values.
void algo_lib::InTextFile_Init(algo_lib::InTextFile& parent) {
    parent.own_fd = bool(true);
    parent.temp_buf_n = 0; // temp_buf: initialize count
}

// --- algo_lib.InTextFile..Uninit
void algo_lib::InTextFile_Uninit(algo_lib::InTextFile& parent) {
    algo_lib::InTextFile &row = parent; (void)row;
    file_Cleanup(parent); // dmmeta.fcleanup:algo_lib.InTextFile.file

    // algo_lib.InTextFile.temp_buf.Uninit (Inlary)  //
    temp_buf_RemoveAll(parent);
}

// --- algo_lib.Mmap..Uninit
void algo_lib::Mmap_Uninit(algo_lib::Mmap& parent) {
    algo_lib::Mmap &row = parent; (void)row;
    mem_Cleanup(parent); // dmmeta.fcleanup:algo_lib.Mmap.mem
}

// --- algo_lib.Regx.state.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo_lib::RegxState& algo_lib::state_Alloc(algo_lib::Regx& regx) {
    state_Reserve(regx, 1);
    int n  = regx.state_n;
    int at = n;
    algo_lib::RegxState *elems = regx.state_elems;
    new (elems + at) algo_lib::RegxState(); // construct new element, default initializer
    regx.state_n = n+1;
    return elems[at];
}

// --- algo_lib.Regx.state.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo_lib::RegxState& algo_lib::state_AllocAt(algo_lib::Regx& regx, int at) {
    state_Reserve(regx, 1);
    int n  = regx.state_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.Regx.state  comment:'index out of range'");
    }
    algo_lib::RegxState *elems = regx.state_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo_lib::RegxState));
    new (elems + at) algo_lib::RegxState(); // construct element, default initializer
    regx.state_n = n+1;
    return elems[at];
}

// --- algo_lib.Regx.state.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo_lib::RegxState> algo_lib::state_AllocN(algo_lib::Regx& regx, int n_elems) {
    state_Reserve(regx, n_elems);
    int old_n  = regx.state_n;
    int new_n = old_n + n_elems;
    algo_lib::RegxState *elems = regx.state_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo_lib::RegxState(); // construct new element, default initialize
    }
    regx.state_n = new_n;
    return algo::aryptr<algo_lib::RegxState>(elems + old_n, n_elems);
}

// --- algo_lib.Regx.state.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::state_Remove(algo_lib::Regx& regx, u32 i) {
    u32 lim = regx.state_n;
    algo_lib::RegxState *elems = regx.state_elems;
    if (i < lim) {
        elems[i].~RegxState(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo_lib::RegxState) * (lim - (i + 1)));
        regx.state_n = lim - 1;
    }
}

// --- algo_lib.Regx.state.RemoveAll
void algo_lib::state_RemoveAll(algo_lib::Regx& regx) {
    u32 n = regx.state_n;
    while (n > 0) {
        n -= 1;
        regx.state_elems[n].~RegxState();
        regx.state_n = n;
    }
}

// --- algo_lib.Regx.state.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::state_RemoveLast(algo_lib::Regx& regx) {
    u64 n = regx.state_n;
    if (n > 0) {
        n -= 1;
        state_qFind(regx, u64(n)).~RegxState();
        regx.state_n = n;
    }
}

// --- algo_lib.Regx.state.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::state_AbsReserve(algo_lib::Regx& regx, int n) {
    u32 old_max  = regx.state_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(regx.state_elems, old_max * sizeof(algo_lib::RegxState), new_max * sizeof(algo_lib::RegxState));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.Regx.state  comment:'out of memory'");
    }
    regx.state_elems = (algo_lib::RegxState*)new_mem;
    regx.state_max = new_max;
}

// --- algo_lib.Regx.state.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::state_XrefMaybe(algo_lib::RegxState &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.Regx..Uninit
void algo_lib::Regx_Uninit(algo_lib::Regx& regx) {
    algo_lib::Regx &row = regx; (void)row;

    // algo_lib.Regx.state.Uninit (Tary)  //Array of states
    // remove all elements from algo_lib.Regx.state
    state_RemoveAll(regx);
    // free memory for Tary algo_lib.Regx.state
    algo_lib::lpool_FreeMem(regx.state_elems, sizeof(algo_lib::RegxState)*regx.state_max); // (algo_lib.Regx.state)
}

// --- algo_lib.RegxToken.type.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo_lib::type_ToCstr(const algo_lib::RegxToken& parent) {
    const char *ret = NULL;
    switch(type_GetEnum(parent)) {
        case algo_lib_RegxToken_type_expr  : ret = "expr";  break;
        case algo_lib_RegxToken_type_or    : ret = "or";  break;
        case algo_lib_RegxToken_type_lparen: ret = "lparen";  break;
    }
    return ret;
}

// --- algo_lib.RegxToken.type.Print
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void algo_lib::type_Print(const algo_lib::RegxToken& parent, algo::cstring &lhs) {
    const char *strval = type_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.type;
    }
}

// --- algo_lib.RegxToken.type.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo_lib::type_SetStrptrMaybe(algo_lib::RegxToken& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(ReadLE16(rhs.elems))) {
                case LE_STR2('o','r'): {
                    type_SetEnum(parent,algo_lib_RegxToken_type_or); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(ReadLE32(rhs.elems))) {
                case LE_STR4('e','x','p','r'): {
                    type_SetEnum(parent,algo_lib_RegxToken_type_expr); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(ReadLE32(rhs.elems))|(u64(ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('l','p','a','r','e','n'): {
                    type_SetEnum(parent,algo_lib_RegxToken_type_lparen); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo_lib.RegxToken.type.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo_lib::type_SetStrptr(algo_lib::RegxToken& parent, algo::strptr rhs, algo_lib_RegxToken_type_Enum dflt) {
    if (!type_SetStrptrMaybe(parent,rhs)) type_SetEnum(parent,dflt);
}

// --- algo_lib.RegxParse.ary_expr.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo_lib::RegxExpr& algo_lib::ary_expr_Alloc(algo_lib::RegxParse& regxparse) {
    ary_expr_Reserve(regxparse, 1);
    int n  = regxparse.ary_expr_n;
    int at = n;
    algo_lib::RegxExpr *elems = regxparse.ary_expr_elems;
    new (elems + at) algo_lib::RegxExpr(); // construct new element, default initializer
    regxparse.ary_expr_n = n+1;
    return elems[at];
}

// --- algo_lib.RegxParse.ary_expr.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo_lib::RegxExpr& algo_lib::ary_expr_AllocAt(algo_lib::RegxParse& regxparse, int at) {
    ary_expr_Reserve(regxparse, 1);
    int n  = regxparse.ary_expr_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.RegxParse.ary_expr  comment:'index out of range'");
    }
    algo_lib::RegxExpr *elems = regxparse.ary_expr_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo_lib::RegxExpr));
    new (elems + at) algo_lib::RegxExpr(); // construct element, default initializer
    regxparse.ary_expr_n = n+1;
    return elems[at];
}

// --- algo_lib.RegxParse.ary_expr.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo_lib::RegxExpr> algo_lib::ary_expr_AllocN(algo_lib::RegxParse& regxparse, int n_elems) {
    ary_expr_Reserve(regxparse, n_elems);
    int old_n  = regxparse.ary_expr_n;
    int new_n = old_n + n_elems;
    algo_lib::RegxExpr *elems = regxparse.ary_expr_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo_lib::RegxExpr(); // construct new element, default initialize
    }
    regxparse.ary_expr_n = new_n;
    return algo::aryptr<algo_lib::RegxExpr>(elems + old_n, n_elems);
}

// --- algo_lib.RegxParse.ary_expr.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::ary_expr_Remove(algo_lib::RegxParse& regxparse, u32 i) {
    u32 lim = regxparse.ary_expr_n;
    algo_lib::RegxExpr *elems = regxparse.ary_expr_elems;
    if (i < lim) {
        elems[i].~RegxExpr(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo_lib::RegxExpr) * (lim - (i + 1)));
        regxparse.ary_expr_n = lim - 1;
    }
}

// --- algo_lib.RegxParse.ary_expr.RemoveAll
void algo_lib::ary_expr_RemoveAll(algo_lib::RegxParse& regxparse) {
    u32 n = regxparse.ary_expr_n;
    while (n > 0) {
        n -= 1;
        regxparse.ary_expr_elems[n].~RegxExpr();
        regxparse.ary_expr_n = n;
    }
}

// --- algo_lib.RegxParse.ary_expr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::ary_expr_RemoveLast(algo_lib::RegxParse& regxparse) {
    u64 n = regxparse.ary_expr_n;
    if (n > 0) {
        n -= 1;
        ary_expr_qFind(regxparse, u64(n)).~RegxExpr();
        regxparse.ary_expr_n = n;
    }
}

// --- algo_lib.RegxParse.ary_expr.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::ary_expr_AbsReserve(algo_lib::RegxParse& regxparse, int n) {
    u32 old_max  = regxparse.ary_expr_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(regxparse.ary_expr_elems, old_max * sizeof(algo_lib::RegxExpr), new_max * sizeof(algo_lib::RegxExpr));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.RegxParse.ary_expr  comment:'out of memory'");
    }
    regxparse.ary_expr_elems = (algo_lib::RegxExpr*)new_mem;
    regxparse.ary_expr_max = new_max;
}

// --- algo_lib.RegxParse.ary_expr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool algo_lib::ary_expr_XrefMaybe(algo_lib::RegxExpr &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- algo_lib.RegxParse..Uninit
void algo_lib::RegxParse_Uninit(algo_lib::RegxParse& regxparse) {
    algo_lib::RegxParse &row = regxparse; (void)row;

    // algo_lib.RegxParse.ary_expr.Uninit (Tary)  //Output expression array
    // remove all elements from algo_lib.RegxParse.ary_expr
    ary_expr_RemoveAll(regxparse);
    // free memory for Tary algo_lib.RegxParse.ary_expr
    algo_lib::lpool_FreeMem(regxparse.ary_expr_elems, sizeof(algo_lib::RegxExpr)*regxparse.ary_expr_max); // (algo_lib.RegxParse.ary_expr)
}

// --- algo_lib.RegxParse..Print
// print string representation of algo_lib::RegxParse to string LHS, no header -- cprint:algo_lib.RegxParse.String
void algo_lib::RegxParse_Print(algo_lib::RegxParse & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.RegxParse";
    (void)row;//only to avoid -Wunused-parameter
}

// --- algo_lib.RegxState.ch_class.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::i32_Range& algo_lib::ch_class_Alloc(algo_lib::RegxState& state) {
    ch_class_Reserve(state, 1);
    int n  = state.ch_class_n;
    int at = n;
    algo::i32_Range *elems = state.ch_class_elems;
    new (elems + at) algo::i32_Range(); // construct new element, default initializer
    state.ch_class_n = n+1;
    return elems[at];
}

// --- algo_lib.RegxState.ch_class.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::i32_Range& algo_lib::ch_class_AllocAt(algo_lib::RegxState& state, int at) {
    ch_class_Reserve(state, 1);
    int n  = state.ch_class_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.RegxState.ch_class  comment:'index out of range'");
    }
    algo::i32_Range *elems = state.ch_class_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::i32_Range));
    new (elems + at) algo::i32_Range(); // construct element, default initializer
    state.ch_class_n = n+1;
    return elems[at];
}

// --- algo_lib.RegxState.ch_class.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::i32_Range> algo_lib::ch_class_AllocN(algo_lib::RegxState& state, int n_elems) {
    ch_class_Reserve(state, n_elems);
    int old_n  = state.ch_class_n;
    int new_n = old_n + n_elems;
    algo::i32_Range *elems = state.ch_class_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::i32_Range(); // construct new element, default initialize
    }
    state.ch_class_n = new_n;
    return algo::aryptr<algo::i32_Range>(elems + old_n, n_elems);
}

// --- algo_lib.RegxState.ch_class.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::ch_class_Remove(algo_lib::RegxState& state, u32 i) {
    u32 lim = state.ch_class_n;
    algo::i32_Range *elems = state.ch_class_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(algo::i32_Range) * (lim - (i + 1)));
        state.ch_class_n = lim - 1;
    }
}

// --- algo_lib.RegxState.ch_class.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::ch_class_RemoveLast(algo_lib::RegxState& state) {
    u64 n = state.ch_class_n;
    if (n > 0) {
        n -= 1;
        state.ch_class_n = n;
    }
}

// --- algo_lib.RegxState.ch_class.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::ch_class_AbsReserve(algo_lib::RegxState& state, int n) {
    u32 old_max  = state.ch_class_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(state.ch_class_elems, old_max * sizeof(algo::i32_Range), new_max * sizeof(algo::i32_Range));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.RegxState.ch_class  comment:'out of memory'");
    }
    state.ch_class_elems = (algo::i32_Range*)new_mem;
    state.ch_class_max = new_max;
}

// --- algo_lib.RegxState.ch_class.Setary
// Copy contents of RHS to PARENT.
void algo_lib::ch_class_Setary(algo_lib::RegxState& state, algo_lib::RegxState &rhs) {
    ch_class_RemoveAll(state);
    int nnew = rhs.ch_class_n;
    ch_class_Reserve(state, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (state.ch_class_elems + i) algo::i32_Range(ch_class_qFind(rhs, i));
        state.ch_class_n = i + 1;
    }
}

// --- algo_lib.RegxState.ch_class.Swap
// Swap values elem_a and elem_b
inline static void algo_lib::ch_class_Swap(algo::i32_Range &elem_a, algo::i32_Range &elem_b) {
    u8 temp[sizeof(algo::i32_Range)];
    memcpy(&temp  , &elem_a, sizeof(algo::i32_Range));
    memcpy(&elem_a, &elem_b, sizeof(algo::i32_Range));
    memcpy(&elem_b, &temp  , sizeof(algo::i32_Range));
}

// --- algo_lib.RegxState.ch_class.Rotleft
// Left circular shift of three-tuple
inline static void algo_lib::ch_class_Rotleft(algo::i32_Range &elem_a, algo::i32_Range &elem_b, algo::i32_Range &elem_c) {
    u8 temp[sizeof(algo::i32_Range)];
    memcpy(&temp, &elem_a   , sizeof(algo::i32_Range));
    memcpy(&elem_a   , &elem_b   , sizeof(algo::i32_Range));
    memcpy(&elem_b   , &elem_c   , sizeof(algo::i32_Range));
    memcpy(&elem_c   , &temp, sizeof(algo::i32_Range));
}

// --- algo_lib.RegxState.ch_class.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool algo_lib::ch_class_Lt(algo::i32_Range &elem_a, algo::i32_Range &elem_b) {
    bool ret;
    ret = elem_a.beg < elem_b.beg;
    return ret;
}

// --- algo_lib.RegxState.ch_class.SortedQ
// Verify whether array is sorted
bool algo_lib::ch_class_SortedQ(algo_lib::RegxState& state) {
    algo::i32_Range *elems = ch_class_Getary(state).elems;
    int n = ch_class_N(state);
    for (int i = 1; i < n; i++) {
        if (ch_class_Lt(elems[i], elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- algo_lib.RegxState.ch_class.IntInsertionSort
// Internal insertion sort
static void algo_lib::ch_class_IntInsertionSort(algo::i32_Range *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        // find the spot for ith element.
        while (j>0 && ch_class_Lt(elems[i], elems[j-1])) {
            j--;
        }
        if (j<i) {
            u8 tmp[sizeof(algo::i32_Range)];
            memcpy (tmp                       , &elems[i], sizeof(algo::i32_Range)      );
            memmove(&elems[j+1], &elems[j], sizeof(algo::i32_Range)*(i-j));
            memcpy (&elems[j]  , tmp                     , sizeof(algo::i32_Range)      );
        }
    }
}

// --- algo_lib.RegxState.ch_class.IntHeapSort
// Internal heap sort
static void algo_lib::ch_class_IntHeapSort(algo::i32_Range *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (ch_class_Lt(elems[j], elems[k])) {
            ch_class_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && ch_class_Lt(elems[l], elems[l+1]);
            if (ch_class_Lt(elems[l], elems[i])) {
                break;
            }
            ch_class_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            ch_class_Swap(elems[i],elems[k]);
        }
    }
}

// --- algo_lib.RegxState.ch_class.IntQuickSort
// Quick sort engine
static void algo_lib::ch_class_IntQuickSort(algo::i32_Range *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            ch_class_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (ch_class_Lt(elems[pp], elems[pi])) {
            ch_class_Swap(elems[pi], elems[pp]);
        }
        if (ch_class_Lt(elems[pj], elems[pp])) {
            if (ch_class_Lt(elems[pj], elems[pi])) {
                ch_class_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                ch_class_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        ch_class_Swap(elems[--pj], elems[pp]);
        // reference to pivot
        algo::i32_Range &pivot = elems[pj];
        for(;;){
            while (ch_class_Lt(elems[++pi], pivot)) {
            }
            while (ch_class_Lt(pivot, elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            ch_class_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        ch_class_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    ch_class_IntInsertionSort(elems,n);
}

// --- algo_lib.RegxState.ch_class.InsertionSort
// Insertion sort
void algo_lib::ch_class_InsertionSort(algo_lib::RegxState& state) {
    algo::i32_Range *elems = ch_class_Getary(state).elems;
    int n = ch_class_N(state);
    ch_class_IntInsertionSort(elems, n);
}

// --- algo_lib.RegxState.ch_class.HeapSort
// Heap sort
void algo_lib::ch_class_HeapSort(algo_lib::RegxState& state) {
    algo::i32_Range *elems = ch_class_Getary(state).elems;
    int n = ch_class_N(state);
    ch_class_IntHeapSort(elems, n);
}

// --- algo_lib.RegxState.ch_class.QuickSort
// Quick sort
void algo_lib::ch_class_QuickSort(algo_lib::RegxState& state) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = CeilingLog2(u32(ch_class_N(state) + 1)) + 3;
    algo::i32_Range *elems = ch_class_Getary(state).elems;
    int n = ch_class_N(state);
    ch_class_IntQuickSort(elems, n, max_depth);
}

// --- algo_lib.RegxState..Uninit
void algo_lib::RegxState_Uninit(algo_lib::RegxState& state) {
    algo_lib::RegxState &row = state; (void)row;

    // algo_lib.RegxState.ch_class.Uninit (Tary)  //What to match
    // remove all elements from algo_lib.RegxState.ch_class
    ch_class_RemoveAll(state);
    // free memory for Tary algo_lib.RegxState.ch_class
    algo_lib::lpool_FreeMem(state.ch_class_elems, sizeof(algo::i32_Range)*state.ch_class_max); // (algo_lib.RegxState.ch_class)
}

// --- algo_lib.Replscope.ind_replvar.Cascdel
// Delete all rows reachable through the hash index
void algo_lib::ind_replvar_Cascdel(algo_lib::Replscope& replscope) {
    if (replscope.ind_replvar_n) {
        for (int i = 0; i < replscope.ind_replvar_buckets_n; i++) {
            algo_lib::FReplvar *elem = replscope.ind_replvar_buckets_elems[i];
            while (elem) {
                algo_lib::FReplvar *next = elem->ind_replvar_next;
                replvar_Delete(*elem);
                elem = next;
            }
        }
    }
}

// --- algo_lib.Replscope.ind_replvar.Find
// Find row by key. Return NULL if not found.
algo_lib::FReplvar* algo_lib::ind_replvar_Find(algo_lib::Replscope& replscope, const algo::strptr& key) {
    u32 index = cstring_Hash(0, key) & (replscope.ind_replvar_buckets_n - 1);
    algo_lib::FReplvar* *e = &replscope.ind_replvar_buckets_elems[index];
    algo_lib::FReplvar* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).key == key;
        if (done) break;
        e         = &ret->ind_replvar_next;
    } while (true);
    return ret;
}

// --- algo_lib.Replscope.ind_replvar.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool algo_lib::ind_replvar_InsertMaybe(algo_lib::Replscope& replscope, algo_lib::FReplvar& row) {
    ind_replvar_Reserve(replscope, 1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_replvar_next == (algo_lib::FReplvar*)-1)) {// check if in hash already
        u32 index = cstring_Hash(0, row.key) & (replscope.ind_replvar_buckets_n - 1);
        algo_lib::FReplvar* *prev = &replscope.ind_replvar_buckets_elems[index];
        do {
            algo_lib::FReplvar* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).key == row.key) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_replvar_next;
        } while (true);
        if (retval) {
            row.ind_replvar_next = *prev;
            replscope.ind_replvar_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- algo_lib.Replscope.ind_replvar.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void algo_lib::ind_replvar_Remove(algo_lib::Replscope& replscope, algo_lib::FReplvar& row) {
    if (LIKELY(row.ind_replvar_next != (algo_lib::FReplvar*)-1)) {// check if in hash already
        u32 index = cstring_Hash(0, row.key) & (replscope.ind_replvar_buckets_n - 1);
        algo_lib::FReplvar* *prev = &replscope.ind_replvar_buckets_elems[index]; // addr of pointer to current element
        while (algo_lib::FReplvar *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_replvar_next; // unlink (singly linked list)
                replscope.ind_replvar_n--;
                row.ind_replvar_next = (algo_lib::FReplvar*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_replvar_next;
        }
    }
}

// --- algo_lib.Replscope.ind_replvar.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void algo_lib::ind_replvar_Reserve(algo_lib::Replscope& replscope, int n) {
    u32 old_nbuckets = replscope.ind_replvar_buckets_n;
    u32 new_nelems   = replscope.ind_replvar_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(algo_lib::FReplvar*);
        u32 new_size = new_nbuckets * sizeof(algo_lib::FReplvar*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        algo_lib::FReplvar* *new_buckets = (algo_lib::FReplvar**)algo_lib::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("algo_lib.out_of_memory  field:algo_lib.Replscope.ind_replvar");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < replscope.ind_replvar_buckets_n; i++) {
            algo_lib::FReplvar* elem = replscope.ind_replvar_buckets_elems[i];
            while (elem) {
                algo_lib::FReplvar &row        = *elem;
                algo_lib::FReplvar* next       = row.ind_replvar_next;
                u32 index          = cstring_Hash(0, row.key) & (new_nbuckets-1);
                row.ind_replvar_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        algo_lib::lpool_FreeMem(replscope.ind_replvar_buckets_elems, old_size);
        replscope.ind_replvar_buckets_elems = new_buckets;
        replscope.ind_replvar_buckets_n = new_nbuckets;
    }
}

// --- algo_lib.Replscope.ind_replvar_curs.Reset
void algo_lib::replscope_ind_replvar_curs_Reset(replscope_ind_replvar_curs &curs, algo_lib::Replscope &parent) {
    curs.bucket = 0;
    curs.parent = &parent;
    curs.prow = &parent.ind_replvar_buckets_elems[0]; // hash never has zero buckets
    while (!*curs.prow) {
        curs.bucket += 1;
        if (curs.bucket == parent.ind_replvar_buckets_n) break;
        curs.prow = &parent.ind_replvar_buckets_elems[curs.bucket];
    }
}

// --- algo_lib.Replscope..Init
// Set all fields to initial values.
void algo_lib::Replscope_Init(algo_lib::Replscope& replscope) {
    replscope.eatcomma = bool(true);
    replscope.fatal = bool(false);
    // initialize hash table for algo_lib::FReplvar;
    replscope.ind_replvar_n             	= 0; // (algo_lib.Replscope.ind_replvar)
    replscope.ind_replvar_buckets_n     	= 4; // (algo_lib.Replscope.ind_replvar)
    replscope.ind_replvar_buckets_elems 	= (algo_lib::FReplvar**)algo_lib::lpool_AllocMem(sizeof(algo_lib::FReplvar*)*replscope.ind_replvar_buckets_n); // initial buckets (algo_lib.Replscope.ind_replvar)
    if (!replscope.ind_replvar_buckets_elems) {
        FatalErrorExit("out of memory"); // (algo_lib.Replscope.ind_replvar)
    }
    memset(replscope.ind_replvar_buckets_elems, 0, sizeof(algo_lib::FReplvar*)*replscope.ind_replvar_buckets_n); // (algo_lib.Replscope.ind_replvar)
}

// --- algo_lib.Replscope..Uninit
void algo_lib::Replscope_Uninit(algo_lib::Replscope& replscope) {
    algo_lib::Replscope &row = replscope; (void)row;
    ind_replvar_Cascdel(replscope); // dmmeta.cascdel:algo_lib.Replscope.ind_replvar
    ind_replvar_Cleanup(replscope); // dmmeta.fcleanup:algo_lib.Replscope.ind_replvar

    // algo_lib.Replscope.ind_replvar.Uninit (Thash)  //
    algo_lib::lpool_FreeMem(replscope.ind_replvar_buckets_elems, sizeof(algo_lib::FReplvar*)*replscope.ind_replvar_buckets_n); // (algo_lib.Replscope.ind_replvar)
}

// --- algo_lib.Replscope..Print
// print string representation of algo_lib::Replscope to string LHS, no header -- cprint:algo_lib.Replscope.String
void algo_lib::Replscope_Print(algo_lib::Replscope & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.Replscope";

    bool_Print(row.eatcomma, temp);
    PrintAttrSpaceReset(str,"eatcomma", temp);

    bool_Print(row.fatal, temp);
    PrintAttrSpaceReset(str,"fatal", temp);
}

// --- algo_lib.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* algo_lib::value_ToCstr(const algo_lib::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case algo_lib_TableId_dmmeta_Dispsigcheck: ret = "dmmeta.Dispsigcheck";  break;
    }
    return ret;
}

// --- algo_lib.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void algo_lib::value_Print(const algo_lib::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- algo_lib.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool algo_lib::value_SetStrptrMaybe(algo_lib::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 19: {
            switch (ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"ispsigcheck",11)==0) { value_SetEnum(parent,algo_lib_TableId_dmmeta_Dispsigcheck); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- algo_lib.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void algo_lib::value_SetStrptr(algo_lib::TableId& parent, algo::strptr rhs, algo_lib_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- algo_lib.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool algo_lib::value_ReadStrptrMaybe(algo_lib::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- algo_lib.TableId..ReadStrptrMaybe
// Read fields of algo_lib::TableId from an ascii string.
// The format of the string is the format of the algo_lib::TableId's only field
bool algo_lib::TableId_ReadStrptrMaybe(algo_lib::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && algo_lib::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- algo_lib.TableId..Print
// print string representation of algo_lib::TableId to string LHS, no header -- cprint:algo_lib.TableId.String
void algo_lib::TableId_Print(algo_lib::TableId & row, algo::cstring &str) {
    algo_lib::value_Print(row, str);
}

// --- algo_lib.Tabulate.width.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& algo_lib::width_Alloc(algo_lib::Tabulate& tabulate) {
    width_Reserve(tabulate, 1);
    int n  = tabulate.width_n;
    int at = n;
    i32 *elems = tabulate.width_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    tabulate.width_n = n+1;
    return elems[at];
}

// --- algo_lib.Tabulate.width.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& algo_lib::width_AllocAt(algo_lib::Tabulate& tabulate, int at) {
    width_Reserve(tabulate, 1);
    int n  = tabulate.width_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("algo_lib.bad_alloc_at  field:algo_lib.Tabulate.width  comment:'index out of range'");
    }
    i32 *elems = tabulate.width_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    tabulate.width_n = n+1;
    return elems[at];
}

// --- algo_lib.Tabulate.width.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> algo_lib::width_AllocN(algo_lib::Tabulate& tabulate, int n_elems) {
    width_Reserve(tabulate, n_elems);
    int old_n  = tabulate.width_n;
    int new_n = old_n + n_elems;
    i32 *elems = tabulate.width_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    tabulate.width_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- algo_lib.Tabulate.width.Remove
// Remove item by index. If index outside of range, do nothing.
void algo_lib::width_Remove(algo_lib::Tabulate& tabulate, u32 i) {
    u32 lim = tabulate.width_n;
    i32 *elems = tabulate.width_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        tabulate.width_n = lim - 1;
    }
}

// --- algo_lib.Tabulate.width.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void algo_lib::width_RemoveLast(algo_lib::Tabulate& tabulate) {
    u64 n = tabulate.width_n;
    if (n > 0) {
        n -= 1;
        tabulate.width_n = n;
    }
}

// --- algo_lib.Tabulate.width.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void algo_lib::width_AbsReserve(algo_lib::Tabulate& tabulate, int n) {
    u32 old_max  = tabulate.width_max;
    u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
    void *new_mem = algo_lib::lpool_ReallocMem(tabulate.width_elems, old_max * sizeof(i32), new_max * sizeof(i32));
    if (UNLIKELY(!new_mem)) {
        FatalErrorExit("algo_lib.tary_nomem  field:algo_lib.Tabulate.width  comment:'out of memory'");
    }
    tabulate.width_elems = (i32*)new_mem;
    tabulate.width_max = new_max;
}

// --- algo_lib.Tabulate.width.Setary
// Copy contents of RHS to PARENT.
void algo_lib::width_Setary(algo_lib::Tabulate& tabulate, algo_lib::Tabulate &rhs) {
    width_RemoveAll(tabulate);
    int nnew = rhs.width_n;
    width_Reserve(tabulate, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (tabulate.width_elems + i) i32(width_qFind(rhs, i));
        tabulate.width_n = i + 1;
    }
}

// --- algo_lib.Tabulate..Uninit
void algo_lib::Tabulate_Uninit(algo_lib::Tabulate& tabulate) {
    algo_lib::Tabulate &row = tabulate; (void)row;

    // algo_lib.Tabulate.width.Uninit (Tary)  //
    // remove all elements from algo_lib.Tabulate.width
    width_RemoveAll(tabulate);
    // free memory for Tary algo_lib.Tabulate.width
    algo_lib::lpool_FreeMem(tabulate.width_elems, sizeof(i32)*tabulate.width_max); // (algo_lib.Tabulate.width)
}

// --- algo_lib.Tabulate..Print
// print string representation of algo_lib::Tabulate to string LHS, no header -- cprint:algo_lib.Tabulate.String
void algo_lib::Tabulate_Print(algo_lib::Tabulate & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "algo_lib.Tabulate";

    algo::cstring_Print(row.temp, temp);
    PrintAttrSpaceReset(str,"temp", temp);
}

// --- algo_lib...SizeCheck
inline static void algo_lib::SizeCheck() {
}
