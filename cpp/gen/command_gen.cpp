//
// cpp/gen/command_gen.cpp
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace command { // gen:ns_print_proto
    // func:command...SizeCheck
    static void          SizeCheck();
} // gen:ns_print_proto

// --- command.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::value_ToCstr(const command::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case command_FieldId_target        : ret = "target";  break;
        case command_FieldId_in            : ret = "in";  break;
        case command_FieldId_out_dir       : ret = "out_dir";  break;
        case command_FieldId_cfg           : ret = "cfg";  break;
        case command_FieldId_compiler      : ret = "compiler";  break;
        case command_FieldId_uname         : ret = "uname";  break;
        case command_FieldId_arch          : ret = "arch";  break;
        case command_FieldId_ood           : ret = "ood";  break;
        case command_FieldId_list          : ret = "list";  break;
        case command_FieldId_listincl      : ret = "listincl";  break;
        case command_FieldId_build         : ret = "build";  break;
        case command_FieldId_preproc       : ret = "preproc";  break;
        case command_FieldId_clean         : ret = "clean";  break;
        case command_FieldId_dry_run       : ret = "dry_run";  break;
        case command_FieldId_maxjobs       : ret = "maxjobs";  break;
        case command_FieldId_printcmd      : ret = "printcmd";  break;
        case command_FieldId_force         : ret = "force";  break;
        case command_FieldId_install       : ret = "install";  break;
        case command_FieldId_coverity      : ret = "coverity";  break;
        case command_FieldId_package       : ret = "package";  break;
        case command_FieldId_maxerr        : ret = "maxerr";  break;
        case command_FieldId_disas         : ret = "disas";  break;
        case command_FieldId_report        : ret = "report";  break;
        case command_FieldId_jcdb          : ret = "jcdb";  break;
        case command_FieldId_cache         : ret = "cache";  break;
        case command_FieldId_readme        : ret = "readme";  break;
        case command_FieldId_ns            : ret = "ns";  break;
        case command_FieldId_section       : ret = "section";  break;
        case command_FieldId_update        : ret = "update";  break;
        case command_FieldId_check         : ret = "check";  break;
        case command_FieldId_link          : ret = "link";  break;
        case command_FieldId_anchor        : ret = "anchor";  break;
        case command_FieldId_print         : ret = "print";  break;
        case command_FieldId_query         : ret = "query";  break;
        case command_FieldId_where         : ret = "where";  break;
        case command_FieldId_del           : ret = "del";  break;
        case command_FieldId_sel           : ret = "sel";  break;
        case command_FieldId_insert        : ret = "insert";  break;
        case command_FieldId_replace       : ret = "replace";  break;
        case command_FieldId_merge         : ret = "merge";  break;
        case command_FieldId_unused        : ret = "unused";  break;
        case command_FieldId_trunc         : ret = "trunc";  break;
        case command_FieldId_selerr        : ret = "selerr";  break;
        case command_FieldId_maxshow       : ret = "maxshow";  break;
        case command_FieldId_write         : ret = "write";  break;
        case command_FieldId_rename        : ret = "rename";  break;
        case command_FieldId_nup           : ret = "nup";  break;
        case command_FieldId_ndown         : ret = "ndown";  break;
        case command_FieldId_l             : ret = "l";  break;
        case command_FieldId_xref          : ret = "xref";  break;
        case command_FieldId_fldfunc       : ret = "fldfunc";  break;
        case command_FieldId_maxgroup      : ret = "maxgroup";  break;
        case command_FieldId_pretty        : ret = "pretty";  break;
        case command_FieldId_tree          : ret = "tree";  break;
        case command_FieldId_loose         : ret = "loose";  break;
        case command_FieldId_my            : ret = "my";  break;
        case command_FieldId_schema        : ret = "schema";  break;
        case command_FieldId_e             : ret = "e";  break;
        case command_FieldId_t             : ret = "t";  break;
        case command_FieldId_g             : ret = "g";  break;
        case command_FieldId_x             : ret = "x";  break;
        case command_FieldId_rowid         : ret = "rowid";  break;
        case command_FieldId_cmt           : ret = "cmt";  break;
        case command_FieldId_cmd           : ret = "cmd";  break;
        case command_FieldId_field         : ret = "field";  break;
        case command_FieldId_regxof        : ret = "regxof";  break;
        case command_FieldId_meta          : ret = "meta";  break;
        case command_FieldId_data          : ret = "data";  break;
        case command_FieldId_line          : ret = "line";  break;
        case command_FieldId_point         : ret = "point";  break;
        case command_FieldId_type          : ret = "type";  break;
        case command_FieldId_debug_log     : ret = "debug_log";  break;
        case command_FieldId_arg           : ret = "arg";  break;
        case command_FieldId_write_ours    : ret = "write_ours";  break;
        case command_FieldId_msize         : ret = "msize";  break;
        case command_FieldId_create        : ret = "create";  break;
        case command_FieldId_finput        : ret = "finput";  break;
        case command_FieldId_foutput       : ret = "foutput";  break;
        case command_FieldId_srcfile       : ret = "srcfile";  break;
        case command_FieldId_gstatic       : ret = "gstatic";  break;
        case command_FieldId_indexed       : ret = "indexed";  break;
        case command_FieldId_nstype        : ret = "nstype";  break;
        case command_FieldId_ctype         : ret = "ctype";  break;
        case command_FieldId_pooltype      : ret = "pooltype";  break;
        case command_FieldId_ssimfile      : ret = "ssimfile";  break;
        case command_FieldId_subset        : ret = "subset";  break;
        case command_FieldId_subset2       : ret = "subset2";  break;
        case command_FieldId_separator     : ret = "separator";  break;
        case command_FieldId_dflt          : ret = "dflt";  break;
        case command_FieldId_anon          : ret = "anon";  break;
        case command_FieldId_bigend        : ret = "bigend";  break;
        case command_FieldId_cascdel       : ret = "cascdel";  break;
        case command_FieldId_before        : ret = "before";  break;
        case command_FieldId_substr        : ret = "substr";  break;
        case command_FieldId_alias         : ret = "alias";  break;
        case command_FieldId_srcfield      : ret = "srcfield";  break;
        case command_FieldId_fstep         : ret = "fstep";  break;
        case command_FieldId_inscond       : ret = "inscond";  break;
        case command_FieldId_reftype       : ret = "reftype";  break;
        case command_FieldId_hashfld       : ret = "hashfld";  break;
        case command_FieldId_sortfld       : ret = "sortfld";  break;
        case command_FieldId_unittest      : ret = "unittest";  break;
        case command_FieldId_citest        : ret = "citest";  break;
        case command_FieldId_cppfunc       : ret = "cppfunc";  break;
        case command_FieldId_via           : ret = "via";  break;
        case command_FieldId_comment       : ret = "comment";  break;
        case command_FieldId_sandbox       : ret = "sandbox";  break;
        case command_FieldId_test          : ret = "test";  break;
        case command_FieldId_showcpp       : ret = "showcpp";  break;
        case command_FieldId_msgtype       : ret = "msgtype";  break;
        case command_FieldId_anonfld       : ret = "anonfld";  break;
        case command_FieldId_sigcheck      : ret = "sigcheck";  break;
        case command_FieldId_data_dir      : ret = "data_dir";  break;
        case command_FieldId_related       : ret = "related";  break;
        case command_FieldId_notssimfile   : ret = "notssimfile";  break;
        case command_FieldId_checkable     : ret = "checkable";  break;
        case command_FieldId_r             : ret = "r";  break;
        case command_FieldId_nsdb          : ret = "nsdb";  break;
        case command_FieldId_fkey          : ret = "fkey";  break;
        case command_FieldId_start         : ret = "start";  break;
        case command_FieldId_stop          : ret = "stop";  break;
        case command_FieldId_abort         : ret = "abort";  break;
        case command_FieldId_shell         : ret = "shell";  break;
        case command_FieldId_serv          : ret = "serv";  break;
        case command_FieldId_in_dir        : ret = "in_dir";  break;
        case command_FieldId_proto         : ret = "proto";  break;
        case command_FieldId_trace         : ret = "trace";  break;
        case command_FieldId_key           : ret = "key";  break;
        case command_FieldId_include       : ret = "include";  break;
        case command_FieldId_dot           : ret = "dot";  break;
        case command_FieldId_xns           : ret = "xns";  break;
        case command_FieldId_noinput       : ret = "noinput";  break;
        case command_FieldId_render        : ret = "render";  break;
        case command_FieldId_id            : ret = "id";  break;
        case command_FieldId_file_prefix   : ret = "file_prefix";  break;
        case command_FieldId_nchild        : ret = "nchild";  break;
        case command_FieldId_blocking      : ret = "blocking";  break;
        case command_FieldId_nmsg          : ret = "nmsg";  break;
        case command_FieldId_timeout       : ret = "timeout";  break;
        case command_FieldId_recvdelay_ns  : ret = "recvdelay_ns";  break;
        case command_FieldId_senddelay_ns  : ret = "senddelay_ns";  break;
        case command_FieldId_msgsize_min   : ret = "msgsize_min";  break;
        case command_FieldId_msgsize_max   : ret = "msgsize_max";  break;
        case command_FieldId_bufsize       : ret = "bufsize";  break;
        case command_FieldId_recvdelay     : ret = "recvdelay";  break;
        case command_FieldId_pkgdata       : ret = "pkgdata";  break;
        case command_FieldId_diff          : ret = "diff";  break;
        case command_FieldId_push          : ret = "push";  break;
        case command_FieldId_remove        : ret = "remove";  break;
        case command_FieldId_origin        : ret = "origin";  break;
        case command_FieldId_ref           : ret = "ref";  break;
        case command_FieldId_showrec       : ret = "showrec";  break;
        case command_FieldId_showfile      : ret = "showfile";  break;
        case command_FieldId_R             : ret = "R";  break;
        case command_FieldId_reset         : ret = "reset";  break;
        case command_FieldId_checkclean    : ret = "checkclean";  break;
        case command_FieldId_stat          : ret = "stat";  break;
        case command_FieldId_annotate      : ret = "annotate";  break;
        case command_FieldId_data_in       : ret = "data_in";  break;
        case command_FieldId_binpath       : ret = "binpath";  break;
        case command_FieldId_amctest       : ret = "amctest";  break;
        case command_FieldId_dofork        : ret = "dofork";  break;
        case command_FieldId_q             : ret = "q";  break;
        case command_FieldId_cijob         : ret = "cijob";  break;
        case command_FieldId_capture       : ret = "capture";  break;
        case command_FieldId_exec          : ret = "exec";  break;
        case command_FieldId_astr          : ret = "astr";  break;
        case command_FieldId_anum          : ret = "anum";  break;
        case command_FieldId_adbl          : ret = "adbl";  break;
        case command_FieldId_aflag         : ret = "aflag";  break;
        case command_FieldId_str           : ret = "str";  break;
        case command_FieldId_num           : ret = "num";  break;
        case command_FieldId_dbl           : ret = "dbl";  break;
        case command_FieldId_flag          : ret = "flag";  break;
        case command_FieldId_dstr          : ret = "dstr";  break;
        case command_FieldId_dnum          : ret = "dnum";  break;
        case command_FieldId_ddbl          : ret = "ddbl";  break;
        case command_FieldId_dflag         : ret = "dflag";  break;
        case command_FieldId_mstr          : ret = "mstr";  break;
        case command_FieldId_mnum          : ret = "mnum";  break;
        case command_FieldId_mdbl          : ret = "mdbl";  break;
        case command_FieldId_amnum         : ret = "amnum";  break;
        case command_FieldId_fconst        : ret = "fconst";  break;
        case command_FieldId_cconst        : ret = "cconst";  break;
        case command_FieldId_dregx         : ret = "dregx";  break;
        case command_FieldId_dpkey         : ret = "dpkey";  break;
        case command_FieldId_comptest      : ret = "comptest";  break;
        case command_FieldId_mdbg          : ret = "mdbg";  break;
        case command_FieldId_run           : ret = "run";  break;
        case command_FieldId_printinput    : ret = "printinput";  break;
        case command_FieldId_normalize     : ret = "normalize";  break;
        case command_FieldId_covcapture    : ret = "covcapture";  break;
        case command_FieldId_covcheck      : ret = "covcheck";  break;
        case command_FieldId_compdir       : ret = "compdir";  break;
        case command_FieldId_check_untracked: ret = "check_untracked";  break;
        case command_FieldId_memcheck      : ret = "memcheck";  break;
        case command_FieldId_callgrind     : ret = "callgrind";  break;
        case command_FieldId_stream        : ret = "stream";  break;
        case command_FieldId_i             : ret = "i";  break;
        case command_FieldId_b             : ret = "b";  break;
        case command_FieldId_covdir        : ret = "covdir";  break;
        case command_FieldId_logfile       : ret = "logfile";  break;
        case command_FieldId_runcmd        : ret = "runcmd";  break;
        case command_FieldId_exclude       : ret = "exclude";  break;
        case command_FieldId_mergepath     : ret = "mergepath";  break;
        case command_FieldId_gcov          : ret = "gcov";  break;
        case command_FieldId_ssim          : ret = "ssim";  break;
        case command_FieldId_xmlpretty     : ret = "xmlpretty";  break;
        case command_FieldId_summary       : ret = "summary";  break;
        case command_FieldId_reprofile     : ret = "reprofile";  break;
        case command_FieldId_args          : ret = "args";  break;
        case command_FieldId_inputfile     : ret = "inputfile";  break;
        case command_FieldId_fuzzstrat     : ret = "fuzzstrat";  break;
        case command_FieldId_seed          : ret = "seed";  break;
        case command_FieldId_testprob      : ret = "testprob";  break;
        case command_FieldId_gtblacttst    : ret = "gtblacttst";  break;
        case command_FieldId_mr            : ret = "mr";  break;
        case command_FieldId_note          : ret = "note";  break;
        case command_FieldId_skip_init     : ret = "skip_init";  break;
        case command_FieldId_skip_git_init : ret = "skip_git_init";  break;
        case command_FieldId_ncmd          : ret = "ncmd";  break;
        case command_FieldId_nofork        : ret = "nofork";  break;
        case command_FieldId_perf_secs     : ret = "perf_secs";  break;
        case command_FieldId_pertest_timeout: ret = "pertest_timeout";  break;
        case command_FieldId_stats         : ret = "stats";  break;
        case command_FieldId_enable        : ret = "enable";  break;
        case command_FieldId_disable       : ret = "disable";  break;
        case command_FieldId_gc            : ret = "gc";  break;
        case command_FieldId_dir           : ret = "dir";  break;
        case command_FieldId_hitrate       : ret = "hitrate";  break;
        case command_FieldId_after         : ret = "after";  break;
        case command_FieldId_selector      : ret = "selector";  break;
        case command_FieldId_fields        : ret = "fields";  break;
        case command_FieldId_accept        : ret = "accept";  break;
        case command_FieldId_approve       : ret = "approve";  break;
        case command_FieldId_needs_work    : ret = "needs_work";  break;
        case command_FieldId_authdir       : ret = "authdir";  break;
        case command_FieldId_gitdir        : ret = "gitdir";  break;
        case command_FieldId_show_gitlab_system_notes: ret = "show_gitlab_system_notes";  break;
        case command_FieldId_attach        : ret = "attach";  break;
        case command_FieldId_catchthrow    : ret = "catchthrow";  break;
        case command_FieldId_tui           : ret = "tui";  break;
        case command_FieldId_bcmd          : ret = "bcmd";  break;
        case command_FieldId_emacs         : ret = "emacs";  break;
        case command_FieldId_manywin       : ret = "manywin";  break;
        case command_FieldId_follow_child  : ret = "follow_child";  break;
        case command_FieldId_py            : ret = "py";  break;
        case command_FieldId_writessimfile : ret = "writessimfile";  break;
        case command_FieldId_url           : ret = "url";  break;
        case command_FieldId_tables        : ret = "tables";  break;
        case command_FieldId_nologo        : ret = "nologo";  break;
        case command_FieldId_baddbok       : ret = "baddbok";  break;
        case command_FieldId_move          : ret = "move";  break;
        case command_FieldId_dedup         : ret = "dedup";  break;
        case command_FieldId_commit        : ret = "commit";  break;
        case command_FieldId_undo          : ret = "undo";  break;
        case command_FieldId_hash          : ret = "hash";  break;
        case command_FieldId_expr          : ret = "expr";  break;
        case command_FieldId_style         : ret = "style";  break;
        case command_FieldId_match         : ret = "match";  break;
        case command_FieldId_string        : ret = "string";  break;
        case command_FieldId_show          : ret = "show";  break;
        case command_FieldId_name          : ret = "name";  break;
        case command_FieldId_files         : ret = "files";  break;
        case command_FieldId_refs          : ret = "refs";  break;
        case command_FieldId_body          : ret = "body";  break;
        case command_FieldId_targsrc       : ret = "targsrc";  break;
        case command_FieldId_func          : ret = "func";  break;
        case command_FieldId_nextfile      : ret = "nextfile";  break;
        case command_FieldId_other         : ret = "other";  break;
        case command_FieldId_updateproto   : ret = "updateproto";  break;
        case command_FieldId_listfunc      : ret = "listfunc";  break;
        case command_FieldId_iffy          : ret = "iffy";  break;
        case command_FieldId_gen           : ret = "gen";  break;
        case command_FieldId_showloc       : ret = "showloc";  break;
        case command_FieldId_showstatic    : ret = "showstatic";  break;
        case command_FieldId_showsortkey   : ret = "showsortkey";  break;
        case command_FieldId_sortname      : ret = "sortname";  break;
        case command_FieldId_baddecl       : ret = "baddecl";  break;
        case command_FieldId_indent        : ret = "indent";  break;
        case command_FieldId_update_copyright: ret = "update_copyright";  break;
        case command_FieldId_scriptfile    : ret = "scriptfile";  break;
        case command_FieldId_linelim       : ret = "linelim";  break;
        case command_FieldId_strayfile     : ret = "strayfile";  break;
        case command_FieldId_badchar       : ret = "badchar";  break;
        case command_FieldId_badline       : ret = "badline";  break;
        case command_FieldId_expand        : ret = "expand";  break;
        case command_FieldId_ignoreQuote   : ret = "ignoreQuote";  break;
        case command_FieldId_maxpacket     : ret = "maxpacket";  break;
        case command_FieldId_db            : ret = "db";  break;
        case command_FieldId_createdb      : ret = "createdb";  break;
        case command_FieldId_typetag       : ret = "typetag";  break;
        case command_FieldId_format        : ret = "format";  break;
        case command_FieldId_tocamelcase   : ret = "tocamelcase";  break;
        case command_FieldId_tolowerunder  : ret = "tolowerunder";  break;
        case command_FieldId_pathcomp      : ret = "pathcomp";  break;
        case command_FieldId_fname         : ret = "fname";  break;
        case command_FieldId_outseparator  : ret = "outseparator";  break;
        case command_FieldId_header        : ret = "header";  break;
        case command_FieldId_prefer_signed : ret = "prefer_signed";  break;
        case command_FieldId_value         : ret = "value";  break;
    }
    return ret;
}

// --- command.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void command::value_Print(const command::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- command.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'R': {
                    value_SetEnum(parent,command_FieldId_R); ret = true; break;
                }
                case 'b': {
                    value_SetEnum(parent,command_FieldId_b); ret = true; break;
                }
                case 'e': {
                    value_SetEnum(parent,command_FieldId_e); ret = true; break;
                }
                case 'g': {
                    value_SetEnum(parent,command_FieldId_g); ret = true; break;
                }
                case 'i': {
                    value_SetEnum(parent,command_FieldId_i); ret = true; break;
                }
                case 'l': {
                    value_SetEnum(parent,command_FieldId_l); ret = true; break;
                }
                case 'q': {
                    value_SetEnum(parent,command_FieldId_q); ret = true; break;
                }
                case 'r': {
                    value_SetEnum(parent,command_FieldId_r); ret = true; break;
                }
                case 't': {
                    value_SetEnum(parent,command_FieldId_t); ret = true; break;
                }
                case 'x': {
                    value_SetEnum(parent,command_FieldId_x); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('d','b'): {
                    value_SetEnum(parent,command_FieldId_db); ret = true; break;
                }
                case LE_STR2('g','c'): {
                    value_SetEnum(parent,command_FieldId_gc); ret = true; break;
                }
                case LE_STR2('i','d'): {
                    value_SetEnum(parent,command_FieldId_id); ret = true; break;
                }
                case LE_STR2('i','n'): {
                    value_SetEnum(parent,command_FieldId_in); ret = true; break;
                }
                case LE_STR2('m','r'): {
                    value_SetEnum(parent,command_FieldId_mr); ret = true; break;
                }
                case LE_STR2('m','y'): {
                    value_SetEnum(parent,command_FieldId_my); ret = true; break;
                }
                case LE_STR2('n','s'): {
                    value_SetEnum(parent,command_FieldId_ns); ret = true; break;
                }
                case LE_STR2('p','y'): {
                    value_SetEnum(parent,command_FieldId_py); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','r','g'): {
                    value_SetEnum(parent,command_FieldId_arg); ret = true; break;
                }
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,command_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('c','m','d'): {
                    value_SetEnum(parent,command_FieldId_cmd); ret = true; break;
                }
                case LE_STR3('c','m','t'): {
                    value_SetEnum(parent,command_FieldId_cmt); ret = true; break;
                }
                case LE_STR3('d','b','l'): {
                    value_SetEnum(parent,command_FieldId_dbl); ret = true; break;
                }
                case LE_STR3('d','e','l'): {
                    value_SetEnum(parent,command_FieldId_del); ret = true; break;
                }
                case LE_STR3('d','i','r'): {
                    value_SetEnum(parent,command_FieldId_dir); ret = true; break;
                }
                case LE_STR3('d','o','t'): {
                    value_SetEnum(parent,command_FieldId_dot); ret = true; break;
                }
                case LE_STR3('g','e','n'): {
                    value_SetEnum(parent,command_FieldId_gen); ret = true; break;
                }
                case LE_STR3('k','e','y'): {
                    value_SetEnum(parent,command_FieldId_key); ret = true; break;
                }
                case LE_STR3('n','u','m'): {
                    value_SetEnum(parent,command_FieldId_num); ret = true; break;
                }
                case LE_STR3('n','u','p'): {
                    value_SetEnum(parent,command_FieldId_nup); ret = true; break;
                }
                case LE_STR3('o','o','d'): {
                    value_SetEnum(parent,command_FieldId_ood); ret = true; break;
                }
                case LE_STR3('r','e','f'): {
                    value_SetEnum(parent,command_FieldId_ref); ret = true; break;
                }
                case LE_STR3('r','u','n'): {
                    value_SetEnum(parent,command_FieldId_run); ret = true; break;
                }
                case LE_STR3('s','e','l'): {
                    value_SetEnum(parent,command_FieldId_sel); ret = true; break;
                }
                case LE_STR3('s','t','r'): {
                    value_SetEnum(parent,command_FieldId_str); ret = true; break;
                }
                case LE_STR3('t','u','i'): {
                    value_SetEnum(parent,command_FieldId_tui); ret = true; break;
                }
                case LE_STR3('u','r','l'): {
                    value_SetEnum(parent,command_FieldId_url); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,command_FieldId_via); ret = true; break;
                }
                case LE_STR3('x','n','s'): {
                    value_SetEnum(parent,command_FieldId_xns); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','d','b','l'): {
                    value_SetEnum(parent,command_FieldId_adbl); ret = true; break;
                }
                case LE_STR4('a','n','o','n'): {
                    value_SetEnum(parent,command_FieldId_anon); ret = true; break;
                }
                case LE_STR4('a','n','u','m'): {
                    value_SetEnum(parent,command_FieldId_anum); ret = true; break;
                }
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,command_FieldId_arch); ret = true; break;
                }
                case LE_STR4('a','r','g','s'): {
                    value_SetEnum(parent,command_FieldId_args); ret = true; break;
                }
                case LE_STR4('a','s','t','r'): {
                    value_SetEnum(parent,command_FieldId_astr); ret = true; break;
                }
                case LE_STR4('b','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_bcmd); ret = true; break;
                }
                case LE_STR4('b','o','d','y'): {
                    value_SetEnum(parent,command_FieldId_body); ret = true; break;
                }
                case LE_STR4('d','a','t','a'): {
                    value_SetEnum(parent,command_FieldId_data); ret = true; break;
                }
                case LE_STR4('d','d','b','l'): {
                    value_SetEnum(parent,command_FieldId_ddbl); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,command_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('d','i','f','f'): {
                    value_SetEnum(parent,command_FieldId_diff); ret = true; break;
                }
                case LE_STR4('d','n','u','m'): {
                    value_SetEnum(parent,command_FieldId_dnum); ret = true; break;
                }
                case LE_STR4('d','s','t','r'): {
                    value_SetEnum(parent,command_FieldId_dstr); ret = true; break;
                }
                case LE_STR4('e','x','e','c'): {
                    value_SetEnum(parent,command_FieldId_exec); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,command_FieldId_expr); ret = true; break;
                }
                case LE_STR4('f','k','e','y'): {
                    value_SetEnum(parent,command_FieldId_fkey); ret = true; break;
                }
                case LE_STR4('f','l','a','g'): {
                    value_SetEnum(parent,command_FieldId_flag); ret = true; break;
                }
                case LE_STR4('f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_func); ret = true; break;
                }
                case LE_STR4('g','c','o','v'): {
                    value_SetEnum(parent,command_FieldId_gcov); ret = true; break;
                }
                case LE_STR4('h','a','s','h'): {
                    value_SetEnum(parent,command_FieldId_hash); ret = true; break;
                }
                case LE_STR4('i','f','f','y'): {
                    value_SetEnum(parent,command_FieldId_iffy); ret = true; break;
                }
                case LE_STR4('j','c','d','b'): {
                    value_SetEnum(parent,command_FieldId_jcdb); ret = true; break;
                }
                case LE_STR4('l','i','n','e'): {
                    value_SetEnum(parent,command_FieldId_line); ret = true; break;
                }
                case LE_STR4('l','i','n','k'): {
                    value_SetEnum(parent,command_FieldId_link); ret = true; break;
                }
                case LE_STR4('l','i','s','t'): {
                    value_SetEnum(parent,command_FieldId_list); ret = true; break;
                }
                case LE_STR4('m','d','b','g'): {
                    value_SetEnum(parent,command_FieldId_mdbg); ret = true; break;
                }
                case LE_STR4('m','d','b','l'): {
                    value_SetEnum(parent,command_FieldId_mdbl); ret = true; break;
                }
                case LE_STR4('m','e','t','a'): {
                    value_SetEnum(parent,command_FieldId_meta); ret = true; break;
                }
                case LE_STR4('m','n','u','m'): {
                    value_SetEnum(parent,command_FieldId_mnum); ret = true; break;
                }
                case LE_STR4('m','o','v','e'): {
                    value_SetEnum(parent,command_FieldId_move); ret = true; break;
                }
                case LE_STR4('m','s','t','r'): {
                    value_SetEnum(parent,command_FieldId_mstr); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_name); ret = true; break;
                }
                case LE_STR4('n','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_ncmd); ret = true; break;
                }
                case LE_STR4('n','m','s','g'): {
                    value_SetEnum(parent,command_FieldId_nmsg); ret = true; break;
                }
                case LE_STR4('n','o','t','e'): {
                    value_SetEnum(parent,command_FieldId_note); ret = true; break;
                }
                case LE_STR4('n','s','d','b'): {
                    value_SetEnum(parent,command_FieldId_nsdb); ret = true; break;
                }
                case LE_STR4('p','u','s','h'): {
                    value_SetEnum(parent,command_FieldId_push); ret = true; break;
                }
                case LE_STR4('r','e','f','s'): {
                    value_SetEnum(parent,command_FieldId_refs); ret = true; break;
                }
                case LE_STR4('s','e','e','d'): {
                    value_SetEnum(parent,command_FieldId_seed); ret = true; break;
                }
                case LE_STR4('s','e','r','v'): {
                    value_SetEnum(parent,command_FieldId_serv); ret = true; break;
                }
                case LE_STR4('s','h','o','w'): {
                    value_SetEnum(parent,command_FieldId_show); ret = true; break;
                }
                case LE_STR4('s','s','i','m'): {
                    value_SetEnum(parent,command_FieldId_ssim); ret = true; break;
                }
                case LE_STR4('s','t','a','t'): {
                    value_SetEnum(parent,command_FieldId_stat); ret = true; break;
                }
                case LE_STR4('s','t','o','p'): {
                    value_SetEnum(parent,command_FieldId_stop); ret = true; break;
                }
                case LE_STR4('t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_test); ret = true; break;
                }
                case LE_STR4('t','r','e','e'): {
                    value_SetEnum(parent,command_FieldId_tree); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_type); ret = true; break;
                }
                case LE_STR4('u','n','d','o'): {
                    value_SetEnum(parent,command_FieldId_undo); ret = true; break;
                }
                case LE_STR4('x','r','e','f'): {
                    value_SetEnum(parent,command_FieldId_xref); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','b','o','r','t'): {
                    value_SetEnum(parent,command_FieldId_abort); ret = true; break;
                }
                case LE_STR5('a','f','l','a','g'): {
                    value_SetEnum(parent,command_FieldId_aflag); ret = true; break;
                }
                case LE_STR5('a','f','t','e','r'): {
                    value_SetEnum(parent,command_FieldId_after); ret = true; break;
                }
                case LE_STR5('a','l','i','a','s'): {
                    value_SetEnum(parent,command_FieldId_alias); ret = true; break;
                }
                case LE_STR5('a','m','n','u','m'): {
                    value_SetEnum(parent,command_FieldId_amnum); ret = true; break;
                }
                case LE_STR5('b','u','i','l','d'): {
                    value_SetEnum(parent,command_FieldId_build); ret = true; break;
                }
                case LE_STR5('c','a','c','h','e'): {
                    value_SetEnum(parent,command_FieldId_cache); ret = true; break;
                }
                case LE_STR5('c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_check); ret = true; break;
                }
                case LE_STR5('c','i','j','o','b'): {
                    value_SetEnum(parent,command_FieldId_cijob); ret = true; break;
                }
                case LE_STR5('c','l','e','a','n'): {
                    value_SetEnum(parent,command_FieldId_clean); ret = true; break;
                }
                case LE_STR5('c','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_ctype); ret = true; break;
                }
                case LE_STR5('d','e','d','u','p'): {
                    value_SetEnum(parent,command_FieldId_dedup); ret = true; break;
                }
                case LE_STR5('d','f','l','a','g'): {
                    value_SetEnum(parent,command_FieldId_dflag); ret = true; break;
                }
                case LE_STR5('d','i','s','a','s'): {
                    value_SetEnum(parent,command_FieldId_disas); ret = true; break;
                }
                case LE_STR5('d','p','k','e','y'): {
                    value_SetEnum(parent,command_FieldId_dpkey); ret = true; break;
                }
                case LE_STR5('d','r','e','g','x'): {
                    value_SetEnum(parent,command_FieldId_dregx); ret = true; break;
                }
                case LE_STR5('e','m','a','c','s'): {
                    value_SetEnum(parent,command_FieldId_emacs); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,command_FieldId_field); ret = true; break;
                }
                case LE_STR5('f','i','l','e','s'): {
                    value_SetEnum(parent,command_FieldId_files); ret = true; break;
                }
                case LE_STR5('f','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_fname); ret = true; break;
                }
                case LE_STR5('f','o','r','c','e'): {
                    value_SetEnum(parent,command_FieldId_force); ret = true; break;
                }
                case LE_STR5('f','s','t','e','p'): {
                    value_SetEnum(parent,command_FieldId_fstep); ret = true; break;
                }
                case LE_STR5('l','o','o','s','e'): {
                    value_SetEnum(parent,command_FieldId_loose); ret = true; break;
                }
                case LE_STR5('m','a','t','c','h'): {
                    value_SetEnum(parent,command_FieldId_match); ret = true; break;
                }
                case LE_STR5('m','e','r','g','e'): {
                    value_SetEnum(parent,command_FieldId_merge); ret = true; break;
                }
                case LE_STR5('m','s','i','z','e'): {
                    value_SetEnum(parent,command_FieldId_msize); ret = true; break;
                }
                case LE_STR5('n','d','o','w','n'): {
                    value_SetEnum(parent,command_FieldId_ndown); ret = true; break;
                }
                case LE_STR5('o','t','h','e','r'): {
                    value_SetEnum(parent,command_FieldId_other); ret = true; break;
                }
                case LE_STR5('p','o','i','n','t'): {
                    value_SetEnum(parent,command_FieldId_point); ret = true; break;
                }
                case LE_STR5('p','r','i','n','t'): {
                    value_SetEnum(parent,command_FieldId_print); ret = true; break;
                }
                case LE_STR5('p','r','o','t','o'): {
                    value_SetEnum(parent,command_FieldId_proto); ret = true; break;
                }
                case LE_STR5('q','u','e','r','y'): {
                    value_SetEnum(parent,command_FieldId_query); ret = true; break;
                }
                case LE_STR5('r','e','s','e','t'): {
                    value_SetEnum(parent,command_FieldId_reset); ret = true; break;
                }
                case LE_STR5('r','o','w','i','d'): {
                    value_SetEnum(parent,command_FieldId_rowid); ret = true; break;
                }
                case LE_STR5('s','h','e','l','l'): {
                    value_SetEnum(parent,command_FieldId_shell); ret = true; break;
                }
                case LE_STR5('s','t','a','r','t'): {
                    value_SetEnum(parent,command_FieldId_start); ret = true; break;
                }
                case LE_STR5('s','t','a','t','s'): {
                    value_SetEnum(parent,command_FieldId_stats); ret = true; break;
                }
                case LE_STR5('s','t','y','l','e'): {
                    value_SetEnum(parent,command_FieldId_style); ret = true; break;
                }
                case LE_STR5('t','r','a','c','e'): {
                    value_SetEnum(parent,command_FieldId_trace); ret = true; break;
                }
                case LE_STR5('t','r','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_trunc); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,command_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','h','e','r','e'): {
                    value_SetEnum(parent,command_FieldId_where); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,command_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','c','c','e','p','t'): {
                    value_SetEnum(parent,command_FieldId_accept); ret = true; break;
                }
                case LE_STR6('a','n','c','h','o','r'): {
                    value_SetEnum(parent,command_FieldId_anchor); ret = true; break;
                }
                case LE_STR6('a','t','t','a','c','h'): {
                    value_SetEnum(parent,command_FieldId_attach); ret = true; break;
                }
                case LE_STR6('b','e','f','o','r','e'): {
                    value_SetEnum(parent,command_FieldId_before); ret = true; break;
                }
                case LE_STR6('b','i','g','e','n','d'): {
                    value_SetEnum(parent,command_FieldId_bigend); ret = true; break;
                }
                case LE_STR6('c','c','o','n','s','t'): {
                    value_SetEnum(parent,command_FieldId_cconst); ret = true; break;
                }
                case LE_STR6('c','i','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_citest); ret = true; break;
                }
                case LE_STR6('c','o','m','m','i','t'): {
                    value_SetEnum(parent,command_FieldId_commit); ret = true; break;
                }
                case LE_STR6('c','o','v','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_covdir); ret = true; break;
                }
                case LE_STR6('c','r','e','a','t','e'): {
                    value_SetEnum(parent,command_FieldId_create); ret = true; break;
                }
                case LE_STR6('d','o','f','o','r','k'): {
                    value_SetEnum(parent,command_FieldId_dofork); ret = true; break;
                }
                case LE_STR6('e','n','a','b','l','e'): {
                    value_SetEnum(parent,command_FieldId_enable); ret = true; break;
                }
                case LE_STR6('e','x','p','a','n','d'): {
                    value_SetEnum(parent,command_FieldId_expand); ret = true; break;
                }
                case LE_STR6('f','c','o','n','s','t'): {
                    value_SetEnum(parent,command_FieldId_fconst); ret = true; break;
                }
                case LE_STR6('f','i','e','l','d','s'): {
                    value_SetEnum(parent,command_FieldId_fields); ret = true; break;
                }
                case LE_STR6('f','i','n','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_finput); ret = true; break;
                }
                case LE_STR6('f','o','r','m','a','t'): {
                    value_SetEnum(parent,command_FieldId_format); ret = true; break;
                }
                case LE_STR6('g','i','t','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_gitdir); ret = true; break;
                }
                case LE_STR6('h','e','a','d','e','r'): {
                    value_SetEnum(parent,command_FieldId_header); ret = true; break;
                }
                case LE_STR6('i','n','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_in_dir); ret = true; break;
                }
                case LE_STR6('i','n','d','e','n','t'): {
                    value_SetEnum(parent,command_FieldId_indent); ret = true; break;
                }
                case LE_STR6('i','n','s','e','r','t'): {
                    value_SetEnum(parent,command_FieldId_insert); ret = true; break;
                }
                case LE_STR6('m','a','x','e','r','r'): {
                    value_SetEnum(parent,command_FieldId_maxerr); ret = true; break;
                }
                case LE_STR6('n','c','h','i','l','d'): {
                    value_SetEnum(parent,command_FieldId_nchild); ret = true; break;
                }
                case LE_STR6('n','o','f','o','r','k'): {
                    value_SetEnum(parent,command_FieldId_nofork); ret = true; break;
                }
                case LE_STR6('n','o','l','o','g','o'): {
                    value_SetEnum(parent,command_FieldId_nologo); ret = true; break;
                }
                case LE_STR6('n','s','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_nstype); ret = true; break;
                }
                case LE_STR6('o','r','i','g','i','n'): {
                    value_SetEnum(parent,command_FieldId_origin); ret = true; break;
                }
                case LE_STR6('p','r','e','t','t','y'): {
                    value_SetEnum(parent,command_FieldId_pretty); ret = true; break;
                }
                case LE_STR6('r','e','a','d','m','e'): {
                    value_SetEnum(parent,command_FieldId_readme); ret = true; break;
                }
                case LE_STR6('r','e','g','x','o','f'): {
                    value_SetEnum(parent,command_FieldId_regxof); ret = true; break;
                }
                case LE_STR6('r','e','m','o','v','e'): {
                    value_SetEnum(parent,command_FieldId_remove); ret = true; break;
                }
                case LE_STR6('r','e','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_rename); ret = true; break;
                }
                case LE_STR6('r','e','n','d','e','r'): {
                    value_SetEnum(parent,command_FieldId_render); ret = true; break;
                }
                case LE_STR6('r','e','p','o','r','t'): {
                    value_SetEnum(parent,command_FieldId_report); ret = true; break;
                }
                case LE_STR6('r','u','n','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_runcmd); ret = true; break;
                }
                case LE_STR6('s','c','h','e','m','a'): {
                    value_SetEnum(parent,command_FieldId_schema); ret = true; break;
                }
                case LE_STR6('s','e','l','e','r','r'): {
                    value_SetEnum(parent,command_FieldId_selerr); ret = true; break;
                }
                case LE_STR6('s','t','r','e','a','m'): {
                    value_SetEnum(parent,command_FieldId_stream); ret = true; break;
                }
                case LE_STR6('s','t','r','i','n','g'): {
                    value_SetEnum(parent,command_FieldId_string); ret = true; break;
                }
                case LE_STR6('s','u','b','s','e','t'): {
                    value_SetEnum(parent,command_FieldId_subset); ret = true; break;
                }
                case LE_STR6('s','u','b','s','t','r'): {
                    value_SetEnum(parent,command_FieldId_substr); ret = true; break;
                }
                case LE_STR6('t','a','b','l','e','s'): {
                    value_SetEnum(parent,command_FieldId_tables); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,command_FieldId_target); ret = true; break;
                }
                case LE_STR6('u','n','u','s','e','d'): {
                    value_SetEnum(parent,command_FieldId_unused); ret = true; break;
                }
                case LE_STR6('u','p','d','a','t','e'): {
                    value_SetEnum(parent,command_FieldId_update); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','m','c','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_amctest); ret = true; break;
                }
                case LE_STR7('a','n','o','n','f','l','d'): {
                    value_SetEnum(parent,command_FieldId_anonfld); ret = true; break;
                }
                case LE_STR7('a','p','p','r','o','v','e'): {
                    value_SetEnum(parent,command_FieldId_approve); ret = true; break;
                }
                case LE_STR7('a','u','t','h','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_authdir); ret = true; break;
                }
                case LE_STR7('b','a','d','c','h','a','r'): {
                    value_SetEnum(parent,command_FieldId_badchar); ret = true; break;
                }
                case LE_STR7('b','a','d','d','b','o','k'): {
                    value_SetEnum(parent,command_FieldId_baddbok); ret = true; break;
                }
                case LE_STR7('b','a','d','d','e','c','l'): {
                    value_SetEnum(parent,command_FieldId_baddecl); ret = true; break;
                }
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,command_FieldId_badline); ret = true; break;
                }
                case LE_STR7('b','i','n','p','a','t','h'): {
                    value_SetEnum(parent,command_FieldId_binpath); ret = true; break;
                }
                case LE_STR7('b','u','f','s','i','z','e'): {
                    value_SetEnum(parent,command_FieldId_bufsize); ret = true; break;
                }
                case LE_STR7('c','a','p','t','u','r','e'): {
                    value_SetEnum(parent,command_FieldId_capture); ret = true; break;
                }
                case LE_STR7('c','a','s','c','d','e','l'): {
                    value_SetEnum(parent,command_FieldId_cascdel); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,command_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','m','p','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_compdir); ret = true; break;
                }
                case LE_STR7('c','p','p','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_cppfunc); ret = true; break;
                }
                case LE_STR7('d','a','t','a','_','i','n'): {
                    value_SetEnum(parent,command_FieldId_data_in); ret = true; break;
                }
                case LE_STR7('d','i','s','a','b','l','e'): {
                    value_SetEnum(parent,command_FieldId_disable); ret = true; break;
                }
                case LE_STR7('d','r','y','_','r','u','n'): {
                    value_SetEnum(parent,command_FieldId_dry_run); ret = true; break;
                }
                case LE_STR7('e','x','c','l','u','d','e'): {
                    value_SetEnum(parent,command_FieldId_exclude); ret = true; break;
                }
                case LE_STR7('f','l','d','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_fldfunc); ret = true; break;
                }
                case LE_STR7('f','o','u','t','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_foutput); ret = true; break;
                }
                case LE_STR7('g','s','t','a','t','i','c'): {
                    value_SetEnum(parent,command_FieldId_gstatic); ret = true; break;
                }
                case LE_STR7('h','a','s','h','f','l','d'): {
                    value_SetEnum(parent,command_FieldId_hashfld); ret = true; break;
                }
                case LE_STR7('h','i','t','r','a','t','e'): {
                    value_SetEnum(parent,command_FieldId_hitrate); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,command_FieldId_include); ret = true; break;
                }
                case LE_STR7('i','n','d','e','x','e','d'): {
                    value_SetEnum(parent,command_FieldId_indexed); ret = true; break;
                }
                case LE_STR7('i','n','s','c','o','n','d'): {
                    value_SetEnum(parent,command_FieldId_inscond); ret = true; break;
                }
                case LE_STR7('i','n','s','t','a','l','l'): {
                    value_SetEnum(parent,command_FieldId_install); ret = true; break;
                }
                case LE_STR7('l','i','n','e','l','i','m'): {
                    value_SetEnum(parent,command_FieldId_linelim); ret = true; break;
                }
                case LE_STR7('l','o','g','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_logfile); ret = true; break;
                }
                case LE_STR7('m','a','n','y','w','i','n'): {
                    value_SetEnum(parent,command_FieldId_manywin); ret = true; break;
                }
                case LE_STR7('m','a','x','j','o','b','s'): {
                    value_SetEnum(parent,command_FieldId_maxjobs); ret = true; break;
                }
                case LE_STR7('m','a','x','s','h','o','w'): {
                    value_SetEnum(parent,command_FieldId_maxshow); ret = true; break;
                }
                case LE_STR7('m','s','g','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_msgtype); ret = true; break;
                }
                case LE_STR7('n','o','i','n','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_noinput); ret = true; break;
                }
                case LE_STR7('o','u','t','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_out_dir); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,command_FieldId_package); ret = true; break;
                }
                case LE_STR7('p','k','g','d','a','t','a'): {
                    value_SetEnum(parent,command_FieldId_pkgdata); ret = true; break;
                }
                case LE_STR7('p','r','e','p','r','o','c'): {
                    value_SetEnum(parent,command_FieldId_preproc); ret = true; break;
                }
                case LE_STR7('r','e','f','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_reftype); ret = true; break;
                }
                case LE_STR7('r','e','l','a','t','e','d'): {
                    value_SetEnum(parent,command_FieldId_related); ret = true; break;
                }
                case LE_STR7('r','e','p','l','a','c','e'): {
                    value_SetEnum(parent,command_FieldId_replace); ret = true; break;
                }
                case LE_STR7('s','a','n','d','b','o','x'): {
                    value_SetEnum(parent,command_FieldId_sandbox); ret = true; break;
                }
                case LE_STR7('s','e','c','t','i','o','n'): {
                    value_SetEnum(parent,command_FieldId_section); ret = true; break;
                }
                case LE_STR7('s','h','o','w','c','p','p'): {
                    value_SetEnum(parent,command_FieldId_showcpp); ret = true; break;
                }
                case LE_STR7('s','h','o','w','l','o','c'): {
                    value_SetEnum(parent,command_FieldId_showloc); ret = true; break;
                }
                case LE_STR7('s','h','o','w','r','e','c'): {
                    value_SetEnum(parent,command_FieldId_showrec); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,command_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('s','u','b','s','e','t','2'): {
                    value_SetEnum(parent,command_FieldId_subset2); ret = true; break;
                }
                case LE_STR7('s','u','m','m','a','r','y'): {
                    value_SetEnum(parent,command_FieldId_summary); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,command_FieldId_targsrc); ret = true; break;
                }
                case LE_STR7('t','i','m','e','o','u','t'): {
                    value_SetEnum(parent,command_FieldId_timeout); ret = true; break;
                }
                case LE_STR7('t','y','p','e','t','a','g'): {
                    value_SetEnum(parent,command_FieldId_typetag); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','n','n','o','t','a','t','e'): {
                    value_SetEnum(parent,command_FieldId_annotate); ret = true; break;
                }
                case LE_STR8('b','l','o','c','k','i','n','g'): {
                    value_SetEnum(parent,command_FieldId_blocking); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,command_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('c','o','m','p','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_comptest); ret = true; break;
                }
                case LE_STR8('c','o','v','c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_covcheck); ret = true; break;
                }
                case LE_STR8('c','o','v','e','r','i','t','y'): {
                    value_SetEnum(parent,command_FieldId_coverity); ret = true; break;
                }
                case LE_STR8('c','r','e','a','t','e','d','b'): {
                    value_SetEnum(parent,command_FieldId_createdb); ret = true; break;
                }
                case LE_STR8('d','a','t','a','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_data_dir); ret = true; break;
                }
                case LE_STR8('l','i','s','t','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_listfunc); ret = true; break;
                }
                case LE_STR8('l','i','s','t','i','n','c','l'): {
                    value_SetEnum(parent,command_FieldId_listincl); ret = true; break;
                }
                case LE_STR8('m','a','x','g','r','o','u','p'): {
                    value_SetEnum(parent,command_FieldId_maxgroup); ret = true; break;
                }
                case LE_STR8('m','e','m','c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_memcheck); ret = true; break;
                }
                case LE_STR8('n','e','x','t','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_nextfile); ret = true; break;
                }
                case LE_STR8('p','a','t','h','c','o','m','p'): {
                    value_SetEnum(parent,command_FieldId_pathcomp); ret = true; break;
                }
                case LE_STR8('p','o','o','l','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_pooltype); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_printcmd); ret = true; break;
                }
                case LE_STR8('s','e','l','e','c','t','o','r'): {
                    value_SetEnum(parent,command_FieldId_selector); ret = true; break;
                }
                case LE_STR8('s','h','o','w','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_showfile); ret = true; break;
                }
                case LE_STR8('s','i','g','c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_sigcheck); ret = true; break;
                }
                case LE_STR8('s','o','r','t','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_sortname); ret = true; break;
                }
                case LE_STR8('s','r','c','f','i','e','l','d'): {
                    value_SetEnum(parent,command_FieldId_srcfield); ret = true; break;
                }
                case LE_STR8('s','s','i','m','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_ssimfile); ret = true; break;
                }
                case LE_STR8('t','e','s','t','p','r','o','b'): {
                    value_SetEnum(parent,command_FieldId_testprob); ret = true; break;
                }
                case LE_STR8('u','n','i','t','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_unittest); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','a','l','l','g','r','i','n'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,command_FieldId_callgrind); ret = true; break; }
                    break;
                }
                case LE_STR8('c','h','e','c','k','a','b','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_checkable); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','b','u','g','_','l','o'): {
                    if (memcmp(rhs.elems+8,"g",1)==0) { value_SetEnum(parent,command_FieldId_debug_log); ret = true; break; }
                    break;
                }
                case LE_STR8('f','u','z','z','s','t','r','a'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,command_FieldId_fuzzstrat); ret = true; break; }
                    break;
                }
                case LE_STR8('i','n','p','u','t','f','i','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_inputfile); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','x','p','a','c','k','e'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,command_FieldId_maxpacket); ret = true; break; }
                    break;
                }
                case LE_STR8('m','e','r','g','e','p','a','t'): {
                    if (memcmp(rhs.elems+8,"h",1)==0) { value_SetEnum(parent,command_FieldId_mergepath); ret = true; break; }
                    break;
                }
                case LE_STR8('n','o','r','m','a','l','i','z'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_normalize); ret = true; break; }
                    break;
                }
                case LE_STR8('p','e','r','f','_','s','e','c'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,command_FieldId_perf_secs); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','c','v','d','e','l','a'): {
                    if (memcmp(rhs.elems+8,"y",1)==0) { value_SetEnum(parent,command_FieldId_recvdelay); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','p','r','o','f','i','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_reprofile); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','p','a','r','a','t','o'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,command_FieldId_separator); ret = true; break; }
                    break;
                }
                case LE_STR8('s','k','i','p','_','i','n','i'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,command_FieldId_skip_init); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','a','y','f','i','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_strayfile); ret = true; break; }
                    break;
                }
                case LE_STR8('x','m','l','p','r','e','t','t'): {
                    if (memcmp(rhs.elems+8,"y",1)==0) { value_SetEnum(parent,command_FieldId_xmlpretty); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','a','t','c','h','t','h','r'): {
                    if (memcmp(rhs.elems+8,"ow",2)==0) { value_SetEnum(parent,command_FieldId_catchthrow); ret = true; break; }
                    break;
                }
                case LE_STR8('c','h','e','c','k','c','l','e'): {
                    if (memcmp(rhs.elems+8,"an",2)==0) { value_SetEnum(parent,command_FieldId_checkclean); ret = true; break; }
                    break;
                }
                case LE_STR8('c','o','v','c','a','p','t','u'): {
                    if (memcmp(rhs.elems+8,"re",2)==0) { value_SetEnum(parent,command_FieldId_covcapture); ret = true; break; }
                    break;
                }
                case LE_STR8('g','t','b','l','a','c','t','t'): {
                    if (memcmp(rhs.elems+8,"st",2)==0) { value_SetEnum(parent,command_FieldId_gtblacttst); ret = true; break; }
                    break;
                }
                case LE_STR8('n','e','e','d','s','_','w','o'): {
                    if (memcmp(rhs.elems+8,"rk",2)==0) { value_SetEnum(parent,command_FieldId_needs_work); ret = true; break; }
                    break;
                }
                case LE_STR8('p','r','i','n','t','i','n','p'): {
                    if (memcmp(rhs.elems+8,"ut",2)==0) { value_SetEnum(parent,command_FieldId_printinput); ret = true; break; }
                    break;
                }
                case LE_STR8('s','c','r','i','p','t','f','i'): {
                    if (memcmp(rhs.elems+8,"le",2)==0) { value_SetEnum(parent,command_FieldId_scriptfile); ret = true; break; }
                    break;
                }
                case LE_STR8('s','h','o','w','s','t','a','t'): {
                    if (memcmp(rhs.elems+8,"ic",2)==0) { value_SetEnum(parent,command_FieldId_showstatic); ret = true; break; }
                    break;
                }
                case LE_STR8('w','r','i','t','e','_','o','u'): {
                    if (memcmp(rhs.elems+8,"rs",2)==0) { value_SetEnum(parent,command_FieldId_write_ours); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','i','l','e','_','p','r','e'): {
                    if (memcmp(rhs.elems+8,"fix",3)==0) { value_SetEnum(parent,command_FieldId_file_prefix); ret = true; break; }
                    break;
                }
                case LE_STR8('i','g','n','o','r','e','Q','u'): {
                    if (memcmp(rhs.elems+8,"ote",3)==0) { value_SetEnum(parent,command_FieldId_ignoreQuote); ret = true; break; }
                    break;
                }
                case LE_STR8('m','s','g','s','i','z','e','_'): {
                    if (memcmp(rhs.elems+8,"min",3)==0) { value_SetEnum(parent,command_FieldId_msgsize_min); ret = true; break; }
                    if (memcmp(rhs.elems+8,"max",3)==0) { value_SetEnum(parent,command_FieldId_msgsize_max); ret = true; break; }
                    break;
                }
                case LE_STR8('n','o','t','s','s','i','m','f'): {
                    if (memcmp(rhs.elems+8,"ile",3)==0) { value_SetEnum(parent,command_FieldId_notssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('s','h','o','w','s','o','r','t'): {
                    if (memcmp(rhs.elems+8,"key",3)==0) { value_SetEnum(parent,command_FieldId_showsortkey); ret = true; break; }
                    break;
                }
                case LE_STR8('t','o','c','a','m','e','l','c'): {
                    if (memcmp(rhs.elems+8,"ase",3)==0) { value_SetEnum(parent,command_FieldId_tocamelcase); ret = true; break; }
                    break;
                }
                case LE_STR8('u','p','d','a','t','e','p','r'): {
                    if (memcmp(rhs.elems+8,"oto",3)==0) { value_SetEnum(parent,command_FieldId_updateproto); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','o','l','l','o','w','_','c'): {
                    if (memcmp(rhs.elems+8,"hild",4)==0) { value_SetEnum(parent,command_FieldId_follow_child); ret = true; break; }
                    break;
                }
                case LE_STR8('o','u','t','s','e','p','a','r'): {
                    if (memcmp(rhs.elems+8,"ator",4)==0) { value_SetEnum(parent,command_FieldId_outseparator); ret = true; break; }
                    break;
                }
                case LE_STR8('r','e','c','v','d','e','l','a'): {
                    if (memcmp(rhs.elems+8,"y_ns",4)==0) { value_SetEnum(parent,command_FieldId_recvdelay_ns); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','n','d','d','e','l','a'): {
                    if (memcmp(rhs.elems+8,"y_ns",4)==0) { value_SetEnum(parent,command_FieldId_senddelay_ns); ret = true; break; }
                    break;
                }
                case LE_STR8('t','o','l','o','w','e','r','u'): {
                    if (memcmp(rhs.elems+8,"nder",4)==0) { value_SetEnum(parent,command_FieldId_tolowerunder); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','r','e','f','e','r','_','s'): {
                    if (memcmp(rhs.elems+8,"igned",5)==0) { value_SetEnum(parent,command_FieldId_prefer_signed); ret = true; break; }
                    break;
                }
                case LE_STR8('s','k','i','p','_','g','i','t'): {
                    if (memcmp(rhs.elems+8,"_init",5)==0) { value_SetEnum(parent,command_FieldId_skip_git_init); ret = true; break; }
                    break;
                }
                case LE_STR8('w','r','i','t','e','s','s','i'): {
                    if (memcmp(rhs.elems+8,"mfile",5)==0) { value_SetEnum(parent,command_FieldId_writessimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','e','c','k','_','u','n'): {
                    if (memcmp(rhs.elems+8,"tracked",7)==0) { value_SetEnum(parent,command_FieldId_check_untracked); ret = true; break; }
                    break;
                }
                case LE_STR8('p','e','r','t','e','s','t','_'): {
                    if (memcmp(rhs.elems+8,"timeout",7)==0) { value_SetEnum(parent,command_FieldId_pertest_timeout); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('u','p','d','a','t','e','_','c'): {
                    if (memcmp(rhs.elems+8,"opyright",8)==0) { value_SetEnum(parent,command_FieldId_update_copyright); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 24: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','h','o','w','_','g','i','t'): {
                    if (memcmp(rhs.elems+8,"lab_system_notes",16)==0) { value_SetEnum(parent,command_FieldId_show_gitlab_system_notes); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::value_SetStrptr(command::FieldId& parent, algo::strptr rhs, command_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- command.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::value_ReadStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- command.FieldId..ReadStrptrMaybe
// Read fields of command::FieldId from an ascii string.
// The format of the string is the format of the command::FieldId's only field
bool command::FieldId_ReadStrptrMaybe(command::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- command.FieldId..Print
// print string representation of ROW to string STR
// cfmt:command.FieldId.String  printfmt:Raw
void command::FieldId_Print(command::FieldId& row, algo::cstring& str) {
    command::value_Print(row, str);
}

// --- command.Protocol.proto.StaticCheck
void command::StaticCheck() {
    algo_assert(_offset_of(command::FieldId, value) + sizeof(((command::FieldId*)0)->value) == sizeof(command::FieldId));
}

// --- command.abt.target.Print
// Print back to string
void command::target_Print(command::abt& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.abt.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::abt& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.target, in, true);
    return retval;
}

// --- command.abt.disas.Print
// Print back to string
void command::disas_Print(command::abt& parent, algo::cstring &out) {
    Regx_Print(parent.disas, out);
}

// --- command.abt.disas.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::disas_ReadStrptrMaybe(command::abt& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.disas, in, false);
    return retval;
}

// --- command.abt.cache.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::cache_ToCstr(const command::abt& parent) {
    const char *ret = NULL;
    switch(cache_GetEnum(parent)) {
        case command_abt_cache_auto        : ret = "auto";  break;
        case command_abt_cache_none        : ret = "none";  break;
        case command_abt_cache_gcache      : ret = "gcache";  break;
        case command_abt_cache_gcache_force: ret = "gcache-force";  break;
        case command_abt_cache_ccache      : ret = "ccache";  break;
    }
    return ret;
}

// --- command.abt.cache.Print
// Convert cache to a string. First, attempt conversion to a known string.
// If no string matches, print cache as a numeric value.
void command::cache_Print(const command::abt& parent, algo::cstring &lhs) {
    const char *strval = cache_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.cache;
    }
}

// --- command.abt.cache.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::cache_SetStrptrMaybe(command::abt& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','u','t','o'): {
                    cache_SetEnum(parent,command_abt_cache_auto); ret = true; break;
                }
                case LE_STR4('n','o','n','e'): {
                    cache_SetEnum(parent,command_abt_cache_none); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('c','c','a','c','h','e'): {
                    cache_SetEnum(parent,command_abt_cache_ccache); ret = true; break;
                }
                case LE_STR6('g','c','a','c','h','e'): {
                    cache_SetEnum(parent,command_abt_cache_gcache); ret = true; break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','c','a','c','h','e','-','f'): {
                    if (memcmp(rhs.elems+8,"orce",4)==0) { cache_SetEnum(parent,command_abt_cache_gcache_force); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.abt.cache.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::cache_SetStrptr(command::abt& parent, algo::strptr rhs, command_abt_cache_Enum dflt) {
    if (!cache_SetStrptrMaybe(parent,rhs)) cache_SetEnum(parent,dflt);
}

// --- command.abt.cache.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::cache_ReadStrptrMaybe(command::abt& parent, algo::strptr rhs) {
    bool retval = false;
    retval = cache_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.cache,rhs);
    }
    return retval;
}

// --- command.abt..ReadFieldMaybe
bool command::abt_ReadFieldMaybe(command::abt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_target: {
            retval = target_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_out_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.out_dir, strval);
            break;
        }
        case command_FieldId_cfg: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval);
            break;
        }
        case command_FieldId_compiler: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval);
            break;
        }
        case command_FieldId_uname: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval);
            break;
        }
        case command_FieldId_arch: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval);
            break;
        }
        case command_FieldId_ood: {
            retval = bool_ReadStrptrMaybe(parent.ood, strval);
            break;
        }
        case command_FieldId_list: {
            retval = bool_ReadStrptrMaybe(parent.list, strval);
            break;
        }
        case command_FieldId_listincl: {
            retval = bool_ReadStrptrMaybe(parent.listincl, strval);
            break;
        }
        case command_FieldId_build: {
            retval = bool_ReadStrptrMaybe(parent.build, strval);
            break;
        }
        case command_FieldId_preproc: {
            retval = bool_ReadStrptrMaybe(parent.preproc, strval);
            break;
        }
        case command_FieldId_clean: {
            retval = bool_ReadStrptrMaybe(parent.clean, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        case command_FieldId_maxjobs: {
            retval = i32_ReadStrptrMaybe(parent.maxjobs, strval);
            break;
        }
        case command_FieldId_printcmd: {
            retval = bool_ReadStrptrMaybe(parent.printcmd, strval);
            break;
        }
        case command_FieldId_force: {
            retval = bool_ReadStrptrMaybe(parent.force, strval);
            break;
        }
        case command_FieldId_install: {
            retval = bool_ReadStrptrMaybe(parent.install, strval);
            break;
        }
        case command_FieldId_coverity: {
            retval = bool_ReadStrptrMaybe(parent.coverity, strval);
            break;
        }
        case command_FieldId_package: {
            retval = algo::cstring_ReadStrptrMaybe(parent.package, strval);
            break;
        }
        case command_FieldId_maxerr: {
            retval = u32_ReadStrptrMaybe(parent.maxerr, strval);
            break;
        }
        case command_FieldId_disas: {
            retval = disas_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_jcdb: {
            retval = algo::cstring_ReadStrptrMaybe(parent.jcdb, strval);
            break;
        }
        case command_FieldId_cache: {
            retval = cache_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.abt..ReadTupleMaybe
// Read fields of command::abt from attributes of ascii tuple TUPLE
bool command::abt_ReadTupleMaybe(command::abt &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = abt_GetAnon(parent, anon_idx++);
        }
        retval = abt_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.abt..Init
// Set all fields to initial values.
void command::abt_Init(command::abt& parent) {
    Regx_ReadSql(parent.target, "", true);
    parent.in = algo::strptr("data");
    parent.out_dir = algo::strptr("");
    parent.cfg = algo::strptr("");
    parent.compiler = algo::strptr("");
    parent.uname = algo::strptr("");
    parent.arch = algo::strptr("");
    parent.ood = bool(false);
    parent.list = bool(false);
    parent.listincl = bool(false);
    parent.build = bool(false);
    parent.preproc = bool(false);
    parent.clean = bool(false);
    parent.dry_run = bool(false);
    parent.maxjobs = i32(0);
    parent.printcmd = bool(false);
    parent.force = bool(false);
    parent.install = bool(false);
    parent.coverity = bool(false);
    parent.package = algo::strptr("");
    parent.maxerr = u32(100);
    Regx_ReadSql(parent.disas, "", true);
    parent.report = bool(true);
    parent.jcdb = algo::strptr("");
    parent.cache = u8(0);
}

// --- command.abt..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::abt_ToCmdline(command::abt& row) {
    tempstr ret;
    ret << "bin/abt ";
    abt_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.abt..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.abt.Argv  printfmt:Auto
void command::abt_PrintArgv(command::abt& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    command::target_Print(const_cast<command::abt&>(row), temp);
    str << " -target:";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.out_dir == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.out_dir, temp);
        str << " -out_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cfg == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.cfg, temp);
        str << " -cfg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.compiler == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.compiler, temp);
        str << " -compiler:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.uname == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.uname, temp);
        str << " -uname:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arch == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.arch, temp);
        str << " -arch:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ood == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ood, temp);
        str << " -ood:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.listincl == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.listincl, temp);
        str << " -listincl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.build == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.build, temp);
        str << " -build:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.preproc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.preproc, temp);
        str << " -preproc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.clean == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.clean, temp);
        str << " -clean:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.printcmd == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.printcmd, temp);
        str << " -printcmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.force == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.force, temp);
        str << " -force:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.coverity == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.coverity, temp);
        str << " -coverity:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.package == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.package, temp);
        str << " -package:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxerr == 100)) {
        ch_RemoveAll(temp);
        u32_Print(row.maxerr, temp);
        str << " -maxerr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.disas.expr == "")) {
        ch_RemoveAll(temp);
        command::disas_Print(const_cast<command::abt&>(row), temp);
        str << " -disas:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.jcdb == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.jcdb, temp);
        str << " -jcdb:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cache == 0)) {
        ch_RemoveAll(temp);
        command::cache_Print(const_cast<command::abt&>(row), temp);
        str << " -cache:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.abt..GetAnon
algo::strptr command::abt_GetAnon(command::abt &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        default: return algo::strptr();
    }
}

// --- command.abt..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::abt_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_target: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_out_dir: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_cfg: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_compiler: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_uname: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_arch: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_ood: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_list: { // bool: no argument required but value may be specified as ood:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_listincl: { // bool: no argument required but value may be specified as list:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_build: { // bool: no argument required but value may be specified as listincl:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_preproc: { // bool: no argument required but value may be specified as build:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_clean: { // bool: no argument required but value may be specified as preproc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as clean:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_maxjobs: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
        } break;
        case command_FieldId_printcmd: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_force: { // bool: no argument required but value may be specified as printcmd:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_install: { // bool: no argument required but value may be specified as force:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_coverity: { // bool: no argument required but value may be specified as install:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_package: { // bool: no argument required but value may be specified as coverity:Y
            *out_anon = false;
        } break;
        case command_FieldId_maxerr: { // bool: no argument required but value may be specified as coverity:Y
            *out_anon = false;
        } break;
        case command_FieldId_disas: { // bool: no argument required but value may be specified as coverity:Y
            *out_anon = false;
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as coverity:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_jcdb: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
        } break;
        case command_FieldId_cache: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.abt_md.readme.Print
// Print back to string
void command::readme_Print(command::abt_md& parent, algo::cstring &out) {
    Regx_Print(parent.readme, out);
}

// --- command.abt_md.readme.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::readme_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.readme, in, true);
    return retval;
}

// --- command.abt_md.ns.Print
// Print back to string
void command::ns_Print(command::abt_md& parent, algo::cstring &out) {
    Regx_Print(parent.ns, out);
}

// --- command.abt_md.ns.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ns_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.ns, in, true);
    return retval;
}

// --- command.abt_md.section.Print
// Print back to string
void command::section_Print(command::abt_md& parent, algo::cstring &out) {
    Regx_Print(parent.section, out);
}

// --- command.abt_md.section.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::section_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.section, in, true);
    return retval;
}

// --- command.abt_md..ReadFieldMaybe
bool command::abt_md_ReadFieldMaybe(command::abt_md& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_readme: {
            retval = readme_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_ns: {
            retval = ns_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_section: {
            retval = section_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_update: {
            retval = bool_ReadStrptrMaybe(parent.update, strval);
            break;
        }
        case command_FieldId_check: {
            retval = bool_ReadStrptrMaybe(parent.check, strval);
            break;
        }
        case command_FieldId_link: {
            retval = bool_ReadStrptrMaybe(parent.link, strval);
            break;
        }
        case command_FieldId_anchor: {
            retval = bool_ReadStrptrMaybe(parent.anchor, strval);
            break;
        }
        case command_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.abt_md..ReadTupleMaybe
// Read fields of command::abt_md from attributes of ascii tuple TUPLE
bool command::abt_md_ReadTupleMaybe(command::abt_md &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = abt_md_GetAnon(parent, anon_idx++);
        }
        retval = abt_md_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.abt_md..Init
// Set all fields to initial values.
void command::abt_md_Init(command::abt_md& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.readme, "%", true);
    Regx_ReadSql(parent.ns, "", true);
    Regx_ReadSql(parent.section, "%", true);
    parent.update = bool(true);
    parent.check = bool(false);
    parent.link = bool(false);
    parent.anchor = bool(false);
    parent.print = bool(false);
    parent.dry_run = bool(false);
}

// --- command.abt_md..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::abt_md_ToCmdline(command::abt_md& row) {
    tempstr ret;
    ret << "bin/abt_md ";
    abt_md_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.abt_md..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.abt_md.Argv  printfmt:Tuple
void command::abt_md_PrintArgv(command::abt_md& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::readme_Print(const_cast<command::abt_md&>(row), temp);
    str << " -readme:";
    strptr_PrintBash(temp,str);
    if (!(row.ns.expr == "")) {
        ch_RemoveAll(temp);
        command::ns_Print(const_cast<command::abt_md&>(row), temp);
        str << " -ns:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::section_Print(const_cast<command::abt_md&>(row), temp);
    str << " -section:";
    strptr_PrintBash(temp,str);
    if (!(row.update == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.update, temp);
        str << " -update:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.link == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.link, temp);
        str << " -link:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.anchor == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.anchor, temp);
        str << " -anchor:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.print == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.print, temp);
        str << " -print:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.abt_md..GetAnon
algo::strptr command::abt_md_GetAnon(command::abt_md &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("readme", 6);
        case(1): return strptr("section", 7);
        default: return algo::strptr();
    }
}

// --- command.abt_md..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::abt_md_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_readme: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_ns: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_section: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_update: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check: { // bool: no argument required but value may be specified as update:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_link: { // bool: no argument required but value may be specified as check:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_anchor: { // bool: no argument required but value may be specified as link:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_print: { // bool: no argument required but value may be specified as anchor:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.abt_md_proc.abt_md.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::abt_md_Start(command::abt_md_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(abt_md_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(abt_md_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= abt_md_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.abt_md_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.abt_md_proc.abt_md.StartRead
// Start subprocess & Read output
algo::Fildes command::abt_md_StartRead(command::abt_md_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    abt_md_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.abt_md_proc.abt_md.Kill
// Kill subprocess and wait
void command::abt_md_Kill(command::abt_md_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        abt_md_Wait(parent);
    }
}

// --- command.abt_md_proc.abt_md.Wait
// Wait for subprocess to return
void command::abt_md_Wait(command::abt_md_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.abt_md_proc.abt_md.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::abt_md_Exec(command::abt_md_proc& parent) {
    abt_md_Start(parent);
    abt_md_Wait(parent);
    return parent.status;
}

// --- command.abt_md_proc.abt_md.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::abt_md_ExecX(command::abt_md_proc& parent) {
    int rc = abt_md_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",abt_md_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.abt_md_proc.abt_md.Execv
// Call execv()
// Call execv with specified parameters
int command::abt_md_Execv(command::abt_md_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    abt_md_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.abt_md_proc.abt_md.ToCmdline
algo::tempstr command::abt_md_ToCmdline(command::abt_md_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::abt_md_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.abt_md_proc.abt_md.ToArgv
// Form array from the command line
void command::abt_md_ToArgv(command::abt_md_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.readme.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-readme:";
        command::readme_Print(parent.cmd, *arg);
    }

    if (parent.cmd.ns.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ns:";
        command::ns_Print(parent.cmd, *arg);
    }

    if (parent.cmd.section.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-section:";
        command::section_Print(parent.cmd, *arg);
    }

    if (parent.cmd.update != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-update:";
        bool_Print(parent.cmd.update, *arg);
    }

    if (parent.cmd.check != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check:";
        bool_Print(parent.cmd.check, *arg);
    }

    if (parent.cmd.link != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-link:";
        bool_Print(parent.cmd.link, *arg);
    }

    if (parent.cmd.anchor != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-anchor:";
        bool_Print(parent.cmd.anchor, *arg);
    }

    if (parent.cmd.print != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-print:";
        bool_Print(parent.cmd.print, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.abt_md_proc..Uninit
void command::abt_md_proc_Uninit(command::abt_md_proc& parent) {
    command::abt_md_proc &row = parent; (void)row;

    // command.abt_md_proc.abt_md.Uninit (Exec)  //
    abt_md_Kill(parent); // kill child, ensure forward progress
}

// --- command.abt_proc.abt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::abt_Start(command::abt_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(abt_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(abt_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= abt_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.abt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.abt_proc.abt.StartRead
// Start subprocess & Read output
algo::Fildes command::abt_StartRead(command::abt_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    abt_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.abt_proc.abt.Kill
// Kill subprocess and wait
void command::abt_Kill(command::abt_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        abt_Wait(parent);
    }
}

// --- command.abt_proc.abt.Wait
// Wait for subprocess to return
void command::abt_Wait(command::abt_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.abt_proc.abt.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::abt_Exec(command::abt_proc& parent) {
    abt_Start(parent);
    abt_Wait(parent);
    return parent.status;
}

// --- command.abt_proc.abt.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::abt_ExecX(command::abt_proc& parent) {
    int rc = abt_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",abt_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.abt_proc.abt.Execv
// Call execv()
// Call execv with specified parameters
int command::abt_Execv(command::abt_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    abt_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.abt_proc.abt.ToCmdline
algo::tempstr command::abt_ToCmdline(command::abt_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::abt_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.abt_proc.abt.ToArgv
// Form array from the command line
void command::abt_ToArgv(command::abt_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.target.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        command::target_Print(parent.cmd, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.out_dir != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-out_dir:";
        cstring_Print(parent.cmd.out_dir, *arg);
    }

    if (parent.cmd.cfg != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cfg:";
        Smallstr50_Print(parent.cmd.cfg, *arg);
    }

    if (parent.cmd.compiler != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-compiler:";
        Smallstr50_Print(parent.cmd.compiler, *arg);
    }

    if (parent.cmd.uname != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-uname:";
        Smallstr50_Print(parent.cmd.uname, *arg);
    }

    if (parent.cmd.arch != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-arch:";
        Smallstr50_Print(parent.cmd.arch, *arg);
    }

    if (parent.cmd.ood != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ood:";
        bool_Print(parent.cmd.ood, *arg);
    }

    if (parent.cmd.list != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-list:";
        bool_Print(parent.cmd.list, *arg);
    }

    if (parent.cmd.listincl != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-listincl:";
        bool_Print(parent.cmd.listincl, *arg);
    }

    if (parent.cmd.build != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-build:";
        bool_Print(parent.cmd.build, *arg);
    }

    if (parent.cmd.preproc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-preproc:";
        bool_Print(parent.cmd.preproc, *arg);
    }

    if (parent.cmd.clean != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-clean:";
        bool_Print(parent.cmd.clean, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }

    if (parent.cmd.maxjobs != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxjobs:";
        i32_Print(parent.cmd.maxjobs, *arg);
    }

    if (parent.cmd.printcmd != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-printcmd:";
        bool_Print(parent.cmd.printcmd, *arg);
    }

    if (parent.cmd.force != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-force:";
        bool_Print(parent.cmd.force, *arg);
    }

    if (parent.cmd.install != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-install:";
        bool_Print(parent.cmd.install, *arg);
    }

    if (parent.cmd.coverity != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-coverity:";
        bool_Print(parent.cmd.coverity, *arg);
    }

    if (parent.cmd.package != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-package:";
        cstring_Print(parent.cmd.package, *arg);
    }

    if (parent.cmd.maxerr != 100) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxerr:";
        u32_Print(parent.cmd.maxerr, *arg);
    }

    if (parent.cmd.disas.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-disas:";
        command::disas_Print(parent.cmd, *arg);
    }

    if (parent.cmd.report != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.jcdb != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-jcdb:";
        cstring_Print(parent.cmd.jcdb, *arg);
    }

    if (parent.cmd.cache != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cache:";
        command::cache_Print(parent.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.abt_proc..Uninit
void command::abt_proc_Uninit(command::abt_proc& parent) {
    command::abt_proc &row = parent; (void)row;

    // command.abt_proc.abt.Uninit (Exec)  //
    abt_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr.where.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::where_Addary(command::acr& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.where_elems && rhs.elems < parent.where_elems + parent.where_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.acr.where  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    where_Reserve(parent, nnew); // reserve space
    int at = parent.where_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.where_elems + at + i) algo::cstring(rhs[i]);
        parent.where_n++;
    }
    return algo::aryptr<algo::cstring>(parent.where_elems + at, nnew);
}

// --- command.acr.where.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::where_Alloc(command::acr& parent) {
    where_Reserve(parent, 1);
    int n  = parent.where_n;
    int at = n;
    algo::cstring *elems = parent.where_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.where_n = n+1;
    return elems[at];
}

// --- command.acr.where.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::where_AllocAt(command::acr& parent, int at) {
    where_Reserve(parent, 1);
    int n  = parent.where_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.acr.where  comment:'index out of range'");
    }
    algo::cstring *elems = parent.where_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.where_n = n+1;
    return elems[at];
}

// --- command.acr.where.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::where_AllocN(command::acr& parent, int n_elems) {
    where_Reserve(parent, n_elems);
    int old_n  = parent.where_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.where_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.where_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr.where.Remove
// Remove item by index. If index outside of range, do nothing.
void command::where_Remove(command::acr& parent, u32 i) {
    u32 lim = parent.where_n;
    algo::cstring *elems = parent.where_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.where_n = lim - 1;
    }
}

// --- command.acr.where.RemoveAll
void command::where_RemoveAll(command::acr& parent) {
    u32 n = parent.where_n;
    while (n > 0) {
        n -= 1;
        parent.where_elems[n].~cstring();
        parent.where_n = n;
    }
}

// --- command.acr.where.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::where_RemoveLast(command::acr& parent) {
    u64 n = parent.where_n;
    if (n > 0) {
        n -= 1;
        where_qFind(parent, u64(n)).~cstring();
        parent.where_n = n;
    }
}

// --- command.acr.where.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::where_AbsReserve(command::acr& parent, int n) {
    u32 old_max  = parent.where_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.where_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.acr.where  comment:'out of memory'");
        }
        parent.where_elems = (algo::cstring*)new_mem;
        parent.where_max = new_max;
    }
}

// --- command.acr.where.Setary
// Copy contents of RHS to PARENT.
void command::where_Setary(command::acr& parent, command::acr &rhs) {
    where_RemoveAll(parent);
    int nnew = rhs.where_n;
    where_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.where_elems + i) algo::cstring(where_qFind(rhs, i));
        parent.where_n = i + 1;
    }
}

// --- command.acr.where.Setary2
// Copy specified array into where, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::where_Setary(command::acr& parent, const algo::aryptr<algo::cstring> &rhs) {
    where_RemoveAll(parent);
    where_Addary(parent, rhs);
}

// --- command.acr.where.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::where_AllocNVal(command::acr& parent, int n_elems, const algo::cstring& val) {
    where_Reserve(parent, n_elems);
    int old_n  = parent.where_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.where_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.where_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr.where.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::where_ReadStrptrMaybe(command::acr& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = where_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        where_RemoveLast(parent);
    }
    return retval;
}

// --- command.acr.field.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::field_Addary(command::acr& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.field_elems && rhs.elems < parent.field_elems + parent.field_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.acr.field  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    field_Reserve(parent, nnew); // reserve space
    int at = parent.field_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.field_elems + at + i) algo::cstring(rhs[i]);
        parent.field_n++;
    }
    return algo::aryptr<algo::cstring>(parent.field_elems + at, nnew);
}

// --- command.acr.field.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::field_Alloc(command::acr& parent) {
    field_Reserve(parent, 1);
    int n  = parent.field_n;
    int at = n;
    algo::cstring *elems = parent.field_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.field_n = n+1;
    return elems[at];
}

// --- command.acr.field.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::field_AllocAt(command::acr& parent, int at) {
    field_Reserve(parent, 1);
    int n  = parent.field_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.acr.field  comment:'index out of range'");
    }
    algo::cstring *elems = parent.field_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.field_n = n+1;
    return elems[at];
}

// --- command.acr.field.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::field_AllocN(command::acr& parent, int n_elems) {
    field_Reserve(parent, n_elems);
    int old_n  = parent.field_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.field_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.field_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr.field.Remove
// Remove item by index. If index outside of range, do nothing.
void command::field_Remove(command::acr& parent, u32 i) {
    u32 lim = parent.field_n;
    algo::cstring *elems = parent.field_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.field_n = lim - 1;
    }
}

// --- command.acr.field.RemoveAll
void command::field_RemoveAll(command::acr& parent) {
    u32 n = parent.field_n;
    while (n > 0) {
        n -= 1;
        parent.field_elems[n].~cstring();
        parent.field_n = n;
    }
}

// --- command.acr.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::field_RemoveLast(command::acr& parent) {
    u64 n = parent.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(parent, u64(n)).~cstring();
        parent.field_n = n;
    }
}

// --- command.acr.field.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::field_AbsReserve(command::acr& parent, int n) {
    u32 old_max  = parent.field_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.field_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.acr.field  comment:'out of memory'");
        }
        parent.field_elems = (algo::cstring*)new_mem;
        parent.field_max = new_max;
    }
}

// --- command.acr.field.Setary
// Copy contents of RHS to PARENT.
void command::field_Setary(command::acr& parent, command::acr &rhs) {
    field_RemoveAll(parent);
    int nnew = rhs.field_n;
    field_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.field_elems + i) algo::cstring(field_qFind(rhs, i));
        parent.field_n = i + 1;
    }
}

// --- command.acr.field.Setary2
// Copy specified array into field, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::field_Setary(command::acr& parent, const algo::aryptr<algo::cstring> &rhs) {
    field_RemoveAll(parent);
    field_Addary(parent, rhs);
}

// --- command.acr.field.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::field_AllocNVal(command::acr& parent, int n_elems, const algo::cstring& val) {
    field_Reserve(parent, n_elems);
    int old_n  = parent.field_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.field_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.field_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr.field.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::field_ReadStrptrMaybe(command::acr& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = field_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        field_RemoveLast(parent);
    }
    return retval;
}

// --- command.acr..ReadFieldMaybe
bool command::acr_ReadFieldMaybe(command::acr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_query: {
            retval = algo::cstring_ReadStrptrMaybe(parent.query, strval);
            break;
        }
        case command_FieldId_where: {
            retval = where_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_del: {
            retval = bool_ReadStrptrMaybe(parent.del, strval);
            break;
        }
        case command_FieldId_sel: {
            retval = bool_ReadStrptrMaybe(parent.sel, strval);
            break;
        }
        case command_FieldId_insert: {
            retval = bool_ReadStrptrMaybe(parent.insert, strval);
            break;
        }
        case command_FieldId_replace: {
            retval = bool_ReadStrptrMaybe(parent.replace, strval);
            break;
        }
        case command_FieldId_update: {
            retval = bool_ReadStrptrMaybe(parent.update, strval);
            break;
        }
        case command_FieldId_merge: {
            retval = bool_ReadStrptrMaybe(parent.merge, strval);
            break;
        }
        case command_FieldId_unused: {
            retval = bool_ReadStrptrMaybe(parent.unused, strval);
            break;
        }
        case command_FieldId_trunc: {
            retval = bool_ReadStrptrMaybe(parent.trunc, strval);
            break;
        }
        case command_FieldId_check: {
            retval = bool_ReadStrptrMaybe(parent.check, strval);
            break;
        }
        case command_FieldId_selerr: {
            retval = bool_ReadStrptrMaybe(parent.selerr, strval);
            break;
        }
        case command_FieldId_maxshow: {
            retval = i32_ReadStrptrMaybe(parent.maxshow, strval);
            break;
        }
        case command_FieldId_write: {
            retval = bool_ReadStrptrMaybe(parent.write, strval);
            break;
        }
        case command_FieldId_rename: {
            retval = algo::cstring_ReadStrptrMaybe(parent.rename, strval);
            break;
        }
        case command_FieldId_nup: {
            retval = i32_ReadStrptrMaybe(parent.nup, strval);
            break;
        }
        case command_FieldId_ndown: {
            retval = i32_ReadStrptrMaybe(parent.ndown, strval);
            break;
        }
        case command_FieldId_l: {
            retval = bool_ReadStrptrMaybe(parent.l, strval);
            break;
        }
        case command_FieldId_xref: {
            retval = bool_ReadStrptrMaybe(parent.xref, strval);
            break;
        }
        case command_FieldId_fldfunc: {
            retval = bool_ReadStrptrMaybe(parent.fldfunc, strval);
            break;
        }
        case command_FieldId_maxgroup: {
            retval = i32_ReadStrptrMaybe(parent.maxgroup, strval);
            break;
        }
        case command_FieldId_pretty: {
            retval = bool_ReadStrptrMaybe(parent.pretty, strval);
            break;
        }
        case command_FieldId_tree: {
            retval = bool_ReadStrptrMaybe(parent.tree, strval);
            break;
        }
        case command_FieldId_loose: {
            retval = bool_ReadStrptrMaybe(parent.loose, strval);
            break;
        }
        case command_FieldId_my: {
            retval = bool_ReadStrptrMaybe(parent.my, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
            break;
        }
        case command_FieldId_g: {
            retval = bool_ReadStrptrMaybe(parent.g, strval);
            break;
        }
        case command_FieldId_x: {
            retval = bool_ReadStrptrMaybe(parent.x, strval);
            break;
        }
        case command_FieldId_rowid: {
            retval = bool_ReadStrptrMaybe(parent.rowid, strval);
            break;
        }
        case command_FieldId_cmt: {
            retval = bool_ReadStrptrMaybe(parent.cmt, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case command_FieldId_cmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval);
            break;
        }
        case command_FieldId_field: {
            retval = field_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_regxof: {
            retval = algo::cstring_ReadStrptrMaybe(parent.regxof, strval);
            break;
        }
        case command_FieldId_meta: {
            retval = bool_ReadStrptrMaybe(parent.meta, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr..ReadTupleMaybe
// Read fields of command::acr from attributes of ascii tuple TUPLE
bool command::acr_ReadTupleMaybe(command::acr &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_GetAnon(parent, anon_idx++);
        }
        retval = acr_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr..Init
// Set all fields to initial values.
void command::acr_Init(command::acr& parent) {
    parent.query = algo::strptr("");
    parent.where_elems 	= 0; // (command.acr.where)
    parent.where_n     	= 0; // (command.acr.where)
    parent.where_max   	= 0; // (command.acr.where)
    parent.in = algo::strptr("data");
    parent.del = bool(false);
    parent.sel = bool(false);
    parent.insert = bool(false);
    parent.replace = bool(false);
    parent.update = bool(false);
    parent.merge = bool(false);
    parent.unused = bool(false);
    parent.trunc = bool(false);
    parent.check = bool(false);
    parent.selerr = bool(true);
    parent.maxshow = i32(100);
    parent.write = bool(false);
    parent.rename = algo::strptr("");
    parent.nup = i32(0);
    parent.ndown = i32(0);
    parent.l = bool(false);
    parent.xref = bool(false);
    parent.fldfunc = bool(false);
    parent.maxgroup = i32(25);
    parent.pretty = bool(true);
    parent.tree = bool(false);
    parent.loose = bool(false);
    parent.my = bool(false);
    parent.schema = algo::strptr("data");
    parent.e = bool(false);
    parent.t = bool(false);
    parent.g = bool(false);
    parent.x = bool(false);
    parent.rowid = bool(false);
    parent.cmt = bool(false);
    parent.report = bool(true);
    parent.print = bool(true);
    parent.cmd = algo::strptr("");
    parent.field_elems 	= 0; // (command.acr.field)
    parent.field_n     	= 0; // (command.acr.field)
    parent.field_max   	= 0; // (command.acr.field)
    parent.regxof = algo::strptr("");
    parent.meta = bool(false);
}

// --- command.acr..Uninit
void command::acr_Uninit(command::acr& parent) {
    command::acr &row = parent; (void)row;

    // command.acr.field.Uninit (Tary)  //Fields to select
    // remove all elements from command.acr.field
    field_RemoveAll(parent);
    // free memory for Tary command.acr.field
    algo_lib::malloc_FreeMem(parent.field_elems, sizeof(algo::cstring)*parent.field_max); // (command.acr.field)

    // command.acr.where.Uninit (Tary)  //Additional key:value pairs to match
    // remove all elements from command.acr.where
    where_RemoveAll(parent);
    // free memory for Tary command.acr.where
    algo_lib::malloc_FreeMem(parent.where_elems, sizeof(algo::cstring)*parent.where_max); // (command.acr.where)
}

// --- command.acr..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_ToCmdline(command::acr& row) {
    tempstr ret;
    ret << "bin/acr ";
    acr_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr.Argv  printfmt:Auto
void command::acr_PrintArgv(command::acr& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    cstring_Print(row.query, temp);
    str << " -query:";
    strptr_PrintBash(temp,str);
    ind_beg(acr_where_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -where:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.del == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.del, temp);
        str << " -del:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sel == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.sel, temp);
        str << " -sel:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.insert == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.insert, temp);
        str << " -insert:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.replace == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.replace, temp);
        str << " -replace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.update == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.update, temp);
        str << " -update:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.merge == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.merge, temp);
        str << " -merge:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.unused == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.unused, temp);
        str << " -unused:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.trunc, temp);
        str << " -trunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.selerr == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.selerr, temp);
        str << " -selerr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxshow == 100)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxshow, temp);
        str << " -maxshow:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rename == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.rename, temp);
        str << " -rename:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nup == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.nup, temp);
        str << " -nup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ndown == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.ndown, temp);
        str << " -ndown:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.l == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.l, temp);
        str << " -l:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxgroup == 25)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxgroup, temp);
        str << " -maxgroup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pretty == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.pretty, temp);
        str << " -pretty:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tree == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tree, temp);
        str << " -tree:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.loose == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.loose, temp);
        str << " -loose:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.my == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.my, temp);
        str << " -my:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.g == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.g, temp);
        str << " -g:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.x == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.x, temp);
        str << " -x:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rowid == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.rowid, temp);
        str << " -rowid:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmt == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.cmt, temp);
        str << " -cmt:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.print == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.print, temp);
        str << " -print:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cmd, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(acr_field_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.regxof == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.regxof, temp);
        str << " -regxof:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.meta == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.meta, temp);
        str << " -meta:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr..GetAnon
algo::strptr command::acr_GetAnon(command::acr &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("query", 5);
        default: return algo::strptr();
    }
}

// --- command.acr..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_query: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_where: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_del: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_sel: { // bool: no argument required but value may be specified as del:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_insert: { // bool: no argument required but value may be specified as sel:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_replace: { // bool: no argument required but value may be specified as insert:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_update: { // bool: no argument required but value may be specified as replace:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_merge: { // bool: no argument required but value may be specified as update:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_unused: { // bool: no argument required but value may be specified as merge:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_trunc: { // bool: no argument required but value may be specified as unused:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check: { // bool: no argument required but value may be specified as trunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_selerr: { // bool: no argument required but value may be specified as check:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_maxshow: { // bool: no argument required but value may be specified as selerr:Y
            *out_anon = false;
        } break;
        case command_FieldId_write: { // bool: no argument required but value may be specified as selerr:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_rename: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
        } break;
        case command_FieldId_nup: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
        } break;
        case command_FieldId_ndown: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
        } break;
        case command_FieldId_l: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_xref: { // bool: no argument required but value may be specified as l:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_fldfunc: { // bool: no argument required but value may be specified as xref:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_maxgroup: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
        } break;
        case command_FieldId_pretty: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_tree: { // bool: no argument required but value may be specified as pretty:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_loose: { // bool: no argument required but value may be specified as tree:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_my: { // bool: no argument required but value may be specified as loose:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_schema: { // bool: no argument required but value may be specified as my:Y
            *out_anon = false;
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as my:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_t: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_g: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_x: { // bool: no argument required but value may be specified as g:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_rowid: { // bool: no argument required but value may be specified as x:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_cmt: { // bool: no argument required but value may be specified as rowid:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as cmt:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_print: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_cmd: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
        } break;
        case command_FieldId_field: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
        } break;
        case command_FieldId_regxof: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
        } break;
        case command_FieldId_meta: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_compl..ReadFieldMaybe
bool command::acr_compl_ReadFieldMaybe(command::acr_compl& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_data: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_line: {
            retval = algo::cstring_ReadStrptrMaybe(parent.line, strval);
            break;
        }
        case command_FieldId_point: {
            retval = algo::cstring_ReadStrptrMaybe(parent.point, strval);
            break;
        }
        case command_FieldId_type: {
            retval = algo::cstring_ReadStrptrMaybe(parent.type, strval);
            break;
        }
        case command_FieldId_install: {
            retval = bool_ReadStrptrMaybe(parent.install, strval);
            break;
        }
        case command_FieldId_debug_log: {
            retval = algo::cstring_ReadStrptrMaybe(parent.debug_log, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_compl..ReadStrptrMaybe
// Read fields of command::acr_compl from an ascii string.
// The format of the string is an ssim Tuple
bool command::acr_compl_ReadStrptrMaybe(command::acr_compl &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "command.acr_compl");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && acr_compl_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- command.acr_compl..ReadTupleMaybe
// Read fields of command::acr_compl from attributes of ascii tuple TUPLE
bool command::acr_compl_ReadTupleMaybe(command::acr_compl &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = acr_compl_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_compl..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_compl_ToCmdline(command::acr_compl& row) {
    tempstr ret;
    ret << "bin/acr_compl ";
    acr_compl_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_compl..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr_compl.Argv  printfmt:Auto
void command::acr_compl_PrintArgv(command::acr_compl& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.data == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data, temp);
        str << " -data:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.line == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.line, temp);
        str << " -line:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.point == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.point, temp);
        str << " -point:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.type == "9")) {
        ch_RemoveAll(temp);
        cstring_Print(row.type, temp);
        str << " -type:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.debug_log == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.debug_log, temp);
        str << " -debug_log:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_compl..Print
// print string representation of ROW to string STR
// cfmt:command.acr_compl.String  printfmt:Tuple
void command::acr_compl_Print(command::acr_compl& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "command.acr_compl";

    algo::cstring_Print(row.data, temp);
    PrintAttrSpaceReset(str,"data", temp);

    algo::cstring_Print(row.schema, temp);
    PrintAttrSpaceReset(str,"schema", temp);

    algo::cstring_Print(row.line, temp);
    PrintAttrSpaceReset(str,"line", temp);

    algo::cstring_Print(row.point, temp);
    PrintAttrSpaceReset(str,"point", temp);

    algo::cstring_Print(row.type, temp);
    PrintAttrSpaceReset(str,"type", temp);

    bool_Print(row.install, temp);
    PrintAttrSpaceReset(str,"install", temp);

    algo::cstring_Print(row.debug_log, temp);
    PrintAttrSpaceReset(str,"debug_log", temp);
}

// --- command.acr_compl..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_compl_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_data: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_schema: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_line: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_point: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_type: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_install: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_debug_log: { // bool: no argument required but value may be specified as install:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_compl_proc.acr_compl.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_compl_Start(command::acr_compl_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_compl_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_compl_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_compl_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_compl_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_compl_proc.acr_compl.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_compl_StartRead(command::acr_compl_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_compl_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_compl_proc.acr_compl.Kill
// Kill subprocess and wait
void command::acr_compl_Kill(command::acr_compl_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_compl_Wait(parent);
    }
}

// --- command.acr_compl_proc.acr_compl.Wait
// Wait for subprocess to return
void command::acr_compl_Wait(command::acr_compl_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_compl_proc.acr_compl.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_compl_Exec(command::acr_compl_proc& parent) {
    acr_compl_Start(parent);
    acr_compl_Wait(parent);
    return parent.status;
}

// --- command.acr_compl_proc.acr_compl.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_compl_ExecX(command::acr_compl_proc& parent) {
    int rc = acr_compl_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_compl_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_compl_proc.acr_compl.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_compl_Execv(command::acr_compl_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_compl_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_compl_proc.acr_compl.ToCmdline
algo::tempstr command::acr_compl_ToCmdline(command::acr_compl_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_compl_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_compl_proc.acr_compl.ToArgv
// Form array from the command line
void command::acr_compl_ToArgv(command::acr_compl_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.data != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data:";
        cstring_Print(parent.cmd.data, *arg);
    }

    if (parent.cmd.schema != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        cstring_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.line != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-line:";
        cstring_Print(parent.cmd.line, *arg);
    }

    if (parent.cmd.point != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-point:";
        cstring_Print(parent.cmd.point, *arg);
    }

    if (parent.cmd.type != "9") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-type:";
        cstring_Print(parent.cmd.type, *arg);
    }

    if (parent.cmd.install != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-install:";
        bool_Print(parent.cmd.install, *arg);
    }

    if (parent.cmd.debug_log != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-debug_log:";
        cstring_Print(parent.cmd.debug_log, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_compl_proc..Uninit
void command::acr_compl_proc_Uninit(command::acr_compl_proc& parent) {
    command::acr_compl_proc &row = parent; (void)row;

    // command.acr_compl_proc.acr_compl.Uninit (Exec)  //
    acr_compl_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_dm.arg.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::arg_Addary(command::acr_dm& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.arg_elems && rhs.elems < parent.arg_elems + parent.arg_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.acr_dm.arg  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    arg_Reserve(parent, nnew); // reserve space
    int at = parent.arg_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.arg_elems + at + i) algo::cstring(rhs[i]);
        parent.arg_n++;
    }
    return algo::aryptr<algo::cstring>(parent.arg_elems + at, nnew);
}

// --- command.acr_dm.arg.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::arg_Alloc(command::acr_dm& parent) {
    arg_Reserve(parent, 1);
    int n  = parent.arg_n;
    int at = n;
    algo::cstring *elems = parent.arg_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.arg_n = n+1;
    return elems[at];
}

// --- command.acr_dm.arg.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::arg_AllocAt(command::acr_dm& parent, int at) {
    arg_Reserve(parent, 1);
    int n  = parent.arg_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.acr_dm.arg  comment:'index out of range'");
    }
    algo::cstring *elems = parent.arg_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.arg_n = n+1;
    return elems[at];
}

// --- command.acr_dm.arg.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::arg_AllocN(command::acr_dm& parent, int n_elems) {
    arg_Reserve(parent, n_elems);
    int old_n  = parent.arg_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.arg_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.arg_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr_dm.arg.Remove
// Remove item by index. If index outside of range, do nothing.
void command::arg_Remove(command::acr_dm& parent, u32 i) {
    u32 lim = parent.arg_n;
    algo::cstring *elems = parent.arg_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.arg_n = lim - 1;
    }
}

// --- command.acr_dm.arg.RemoveAll
void command::arg_RemoveAll(command::acr_dm& parent) {
    u32 n = parent.arg_n;
    while (n > 0) {
        n -= 1;
        parent.arg_elems[n].~cstring();
        parent.arg_n = n;
    }
}

// --- command.acr_dm.arg.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::arg_RemoveLast(command::acr_dm& parent) {
    u64 n = parent.arg_n;
    if (n > 0) {
        n -= 1;
        arg_qFind(parent, u64(n)).~cstring();
        parent.arg_n = n;
    }
}

// --- command.acr_dm.arg.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::arg_AbsReserve(command::acr_dm& parent, int n) {
    u32 old_max  = parent.arg_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.arg_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.acr_dm.arg  comment:'out of memory'");
        }
        parent.arg_elems = (algo::cstring*)new_mem;
        parent.arg_max = new_max;
    }
}

// --- command.acr_dm.arg.Setary
// Copy contents of RHS to PARENT.
void command::arg_Setary(command::acr_dm& parent, command::acr_dm &rhs) {
    arg_RemoveAll(parent);
    int nnew = rhs.arg_n;
    arg_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.arg_elems + i) algo::cstring(arg_qFind(rhs, i));
        parent.arg_n = i + 1;
    }
}

// --- command.acr_dm.arg.Setary2
// Copy specified array into arg, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::arg_Setary(command::acr_dm& parent, const algo::aryptr<algo::cstring> &rhs) {
    arg_RemoveAll(parent);
    arg_Addary(parent, rhs);
}

// --- command.acr_dm.arg.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::arg_AllocNVal(command::acr_dm& parent, int n_elems, const algo::cstring& val) {
    arg_Reserve(parent, n_elems);
    int old_n  = parent.arg_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.arg_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.arg_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.acr_dm.arg.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::arg_ReadStrptrMaybe(command::acr_dm& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = arg_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        arg_RemoveLast(parent);
    }
    return retval;
}

// --- command.acr_dm..ReadFieldMaybe
bool command::acr_dm_ReadFieldMaybe(command::acr_dm& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_arg: {
            retval = arg_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_write_ours: {
            retval = bool_ReadStrptrMaybe(parent.write_ours, strval);
            break;
        }
        case command_FieldId_msize: {
            retval = u8_ReadStrptrMaybe(parent.msize, strval);
            break;
        }
        case command_FieldId_rowid: {
            retval = bool_ReadStrptrMaybe(parent.rowid, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_dm..ReadTupleMaybe
// Read fields of command::acr_dm from attributes of ascii tuple TUPLE
bool command::acr_dm_ReadTupleMaybe(command::acr_dm &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_dm_GetAnon(parent, anon_idx++);
        }
        retval = acr_dm_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_dm..Uninit
void command::acr_dm_Uninit(command::acr_dm& parent) {
    command::acr_dm &row = parent; (void)row;

    // command.acr_dm.arg.Uninit (Tary)  //Files to merge: older ours theirs...
    // remove all elements from command.acr_dm.arg
    arg_RemoveAll(parent);
    // free memory for Tary command.acr_dm.arg
    algo_lib::malloc_FreeMem(parent.arg_elems, sizeof(algo::cstring)*parent.arg_max); // (command.acr_dm.arg)
}

// --- command.acr_dm..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_dm_ToCmdline(command::acr_dm& row) {
    tempstr ret;
    ret << "bin/acr_dm ";
    acr_dm_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_dm..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr_dm.Argv  printfmt:Tuple
void command::acr_dm_PrintArgv(command::acr_dm& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(acr_dm_arg_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -arg:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.write_ours == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write_ours, temp);
        str << " -write_ours:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.msize == 7)) {
        ch_RemoveAll(temp);
        u8_Print(row.msize, temp);
        str << " -msize:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rowid == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.rowid, temp);
        str << " -rowid:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_dm..GetAnon
algo::strptr command::acr_dm_GetAnon(command::acr_dm &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        default: return strptr("arg", 3);
    }
}

// --- command.acr_dm..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_dm_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_arg: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_write_ours: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_msize: { // bool: no argument required but value may be specified as write_ours:Y
            *out_anon = false;
        } break;
        case command_FieldId_rowid: { // bool: no argument required but value may be specified as write_ours:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_dm_proc.acr_dm.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_dm_Start(command::acr_dm_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_dm_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_dm_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_dm_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_dm_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_dm_proc.acr_dm.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_dm_StartRead(command::acr_dm_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_dm_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_dm_proc.acr_dm.Kill
// Kill subprocess and wait
void command::acr_dm_Kill(command::acr_dm_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_dm_Wait(parent);
    }
}

// --- command.acr_dm_proc.acr_dm.Wait
// Wait for subprocess to return
void command::acr_dm_Wait(command::acr_dm_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_dm_proc.acr_dm.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_dm_Exec(command::acr_dm_proc& parent) {
    acr_dm_Start(parent);
    acr_dm_Wait(parent);
    return parent.status;
}

// --- command.acr_dm_proc.acr_dm.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_dm_ExecX(command::acr_dm_proc& parent) {
    int rc = acr_dm_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_dm_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_dm_proc.acr_dm.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_dm_Execv(command::acr_dm_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_dm_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_dm_proc.acr_dm.ToCmdline
algo::tempstr command::acr_dm_ToCmdline(command::acr_dm_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_dm_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_dm_proc.acr_dm.ToArgv
// Form array from the command line
void command::acr_dm_ToArgv(command::acr_dm_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }
    ind_beg(command::acr_dm_arg_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-arg:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.write_ours != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write_ours:";
        bool_Print(parent.cmd.write_ours, *arg);
    }

    if (parent.cmd.msize != 7) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-msize:";
        u8_Print(parent.cmd.msize, *arg);
    }

    if (parent.cmd.rowid != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-rowid:";
        bool_Print(parent.cmd.rowid, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_dm_proc..Uninit
void command::acr_dm_proc_Uninit(command::acr_dm_proc& parent) {
    command::acr_dm_proc &row = parent; (void)row;

    // command.acr_dm_proc.acr_dm.Uninit (Exec)  //
    acr_dm_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_ed..ReadFieldMaybe
bool command::acr_ed_ReadFieldMaybe(command::acr_ed& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_create: {
            retval = bool_ReadStrptrMaybe(parent.create, strval);
            break;
        }
        case command_FieldId_del: {
            retval = bool_ReadStrptrMaybe(parent.del, strval);
            break;
        }
        case command_FieldId_rename: {
            retval = algo::cstring_ReadStrptrMaybe(parent.rename, strval);
            break;
        }
        case command_FieldId_finput: {
            retval = bool_ReadStrptrMaybe(parent.finput, strval);
            break;
        }
        case command_FieldId_foutput: {
            retval = bool_ReadStrptrMaybe(parent.foutput, strval);
            break;
        }
        case command_FieldId_srcfile: {
            retval = algo::cstring_ReadStrptrMaybe(parent.srcfile, strval);
            break;
        }
        case command_FieldId_gstatic: {
            retval = bool_ReadStrptrMaybe(parent.gstatic, strval);
            break;
        }
        case command_FieldId_indexed: {
            retval = bool_ReadStrptrMaybe(parent.indexed, strval);
            break;
        }
        case command_FieldId_target: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval);
            break;
        }
        case command_FieldId_nstype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval);
            break;
        }
        case command_FieldId_ctype: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case command_FieldId_pooltype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.pooltype, strval);
            break;
        }
        case command_FieldId_ssimfile: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval);
            break;
        }
        case command_FieldId_subset: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.subset, strval);
            break;
        }
        case command_FieldId_subset2: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.subset2, strval);
            break;
        }
        case command_FieldId_separator: {
            retval = algo::cstring_ReadStrptrMaybe(parent.separator, strval);
            break;
        }
        case command_FieldId_field: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval);
            break;
        }
        case command_FieldId_arg: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.arg, strval);
            break;
        }
        case command_FieldId_dflt: {
            retval = algo::cstring_ReadStrptrMaybe(parent.dflt, strval);
            break;
        }
        case command_FieldId_anon: {
            retval = bool_ReadStrptrMaybe(parent.anon, strval);
            break;
        }
        case command_FieldId_bigend: {
            retval = bool_ReadStrptrMaybe(parent.bigend, strval);
            break;
        }
        case command_FieldId_cascdel: {
            retval = bool_ReadStrptrMaybe(parent.cascdel, strval);
            break;
        }
        case command_FieldId_before: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.before, strval);
            break;
        }
        case command_FieldId_substr: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.substr, strval);
            break;
        }
        case command_FieldId_alias: {
            retval = bool_ReadStrptrMaybe(parent.alias, strval);
            break;
        }
        case command_FieldId_srcfield: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval);
            break;
        }
        case command_FieldId_fstep: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval);
            break;
        }
        case command_FieldId_inscond: {
            retval = algo::cstring_ReadStrptrMaybe(parent.inscond, strval);
            break;
        }
        case command_FieldId_reftype: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval);
            break;
        }
        case command_FieldId_hashfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.hashfld, strval);
            break;
        }
        case command_FieldId_sortfld: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval);
            break;
        }
        case command_FieldId_unittest: {
            retval = algo::cstring_ReadStrptrMaybe(parent.unittest, strval);
            break;
        }
        case command_FieldId_citest: {
            retval = algo::cstring_ReadStrptrMaybe(parent.citest, strval);
            break;
        }
        case command_FieldId_cppfunc: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cppfunc, strval);
            break;
        }
        case command_FieldId_xref: {
            retval = bool_ReadStrptrMaybe(parent.xref, strval);
            break;
        }
        case command_FieldId_via: {
            retval = algo::cstring_ReadStrptrMaybe(parent.via, strval);
            break;
        }
        case command_FieldId_write: {
            retval = bool_ReadStrptrMaybe(parent.write, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_comment: {
            retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval);
            break;
        }
        case command_FieldId_sandbox: {
            retval = bool_ReadStrptrMaybe(parent.sandbox, strval);
            break;
        }
        case command_FieldId_test: {
            retval = bool_ReadStrptrMaybe(parent.test, strval);
            break;
        }
        case command_FieldId_showcpp: {
            retval = bool_ReadStrptrMaybe(parent.showcpp, strval);
            break;
        }
        case command_FieldId_msgtype: {
            retval = algo::cstring_ReadStrptrMaybe(parent.msgtype, strval);
            break;
        }
        case command_FieldId_anonfld: {
            retval = bool_ReadStrptrMaybe(parent.anonfld, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_ed..ReadTupleMaybe
// Read fields of command::acr_ed from attributes of ascii tuple TUPLE
bool command::acr_ed_ReadTupleMaybe(command::acr_ed &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = acr_ed_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_ed..Init
// Set all fields to initial values.
void command::acr_ed_Init(command::acr_ed& parent) {
    parent.in = algo::strptr("data");
    parent.create = bool(false);
    parent.del = bool(false);
    parent.rename = algo::strptr("");
    parent.finput = bool(false);
    parent.foutput = bool(false);
    parent.srcfile = algo::strptr("");
    parent.gstatic = bool(false);
    parent.indexed = bool(false);
    parent.target = algo::strptr("");
    parent.nstype = algo::strptr("exe");
    parent.ctype = algo::strptr("");
    parent.pooltype = algo::strptr("");
    parent.ssimfile = algo::strptr("");
    parent.subset = algo::strptr("");
    parent.subset2 = algo::strptr("");
    parent.separator = algo::strptr(".");
    parent.field = algo::strptr("");
    parent.arg = algo::strptr("");
    parent.dflt = algo::strptr("");
    parent.anon = bool(false);
    parent.bigend = bool(false);
    parent.cascdel = bool(false);
    parent.before = algo::strptr("");
    parent.substr = algo::strptr("");
    parent.alias = bool(false);
    parent.srcfield = algo::strptr("");
    parent.fstep = algo::strptr("");
    parent.inscond = algo::strptr("true");
    parent.reftype = algo::strptr("");
    parent.hashfld = algo::strptr("");
    parent.sortfld = algo::strptr("");
    parent.unittest = algo::strptr("");
    parent.citest = algo::strptr("");
    parent.cppfunc = algo::strptr("");
    parent.xref = bool(false);
    parent.via = algo::strptr("");
    parent.write = bool(false);
    parent.e = bool(false);
    parent.comment = algo::strptr("");
    parent.sandbox = bool(false);
    parent.test = bool(false);
    parent.showcpp = bool(false);
    parent.msgtype = algo::strptr("");
    parent.anonfld = bool(false);
}

// --- command.acr_ed..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_ed_ToCmdline(command::acr_ed& row) {
    tempstr ret;
    ret << "bin/acr_ed ";
    acr_ed_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_ed..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr_ed.Argv  printfmt:Auto
void command::acr_ed_PrintArgv(command::acr_ed& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.create == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.create, temp);
        str << " -create:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.del == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.del, temp);
        str << " -del:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rename == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.rename, temp);
        str << " -rename:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.finput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.finput, temp);
        str << " -finput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.foutput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.foutput, temp);
        str << " -foutput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfile == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.srcfile, temp);
        str << " -srcfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gstatic == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gstatic, temp);
        str << " -gstatic:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.indexed == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.indexed, temp);
        str << " -indexed:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.target == "")) {
        ch_RemoveAll(temp);
        Smallstr16_Print(row.target, temp);
        str << " -target:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nstype == "exe")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.nstype, temp);
        str << " -nstype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ctype == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.ctype, temp);
        str << " -ctype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pooltype == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.pooltype, temp);
        str << " -pooltype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ssimfile == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.ssimfile, temp);
        str << " -ssimfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.subset == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.subset, temp);
        str << " -subset:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.subset2 == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.subset2, temp);
        str << " -subset2:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.separator == ".")) {
        ch_RemoveAll(temp);
        cstring_Print(row.separator, temp);
        str << " -separator:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.field == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.field, temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arg == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.arg, temp);
        str << " -arg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dflt == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dflt, temp);
        str << " -dflt:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.anon == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.anon, temp);
        str << " -anon:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.bigend == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.bigend, temp);
        str << " -bigend:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cascdel == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.cascdel, temp);
        str << " -cascdel:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.before == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.before, temp);
        str << " -before:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.substr == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.substr, temp);
        str << " -substr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.alias == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.alias, temp);
        str << " -alias:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfield == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.srcfield, temp);
        str << " -srcfield:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fstep == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.fstep, temp);
        str << " -fstep:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.inscond == "true")) {
        ch_RemoveAll(temp);
        cstring_Print(row.inscond, temp);
        str << " -inscond:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.reftype == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.reftype, temp);
        str << " -reftype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.hashfld == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.hashfld, temp);
        str << " -hashfld:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sortfld == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.sortfld, temp);
        str << " -sortfld:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.unittest == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.unittest, temp);
        str << " -unittest:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.citest == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.citest, temp);
        str << " -citest:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cppfunc == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cppfunc, temp);
        str << " -cppfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.via == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.via, temp);
        str << " -via:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.comment == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.comment, temp);
        str << " -comment:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sandbox == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.sandbox, temp);
        str << " -sandbox:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.test == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.test, temp);
        str << " -test:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showcpp == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showcpp, temp);
        str << " -showcpp:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.msgtype == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.msgtype, temp);
        str << " -msgtype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.anonfld == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.anonfld, temp);
        str << " -anonfld:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_ed..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_ed_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_create: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_del: { // bool: no argument required but value may be specified as create:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_rename: { // bool: no argument required but value may be specified as del:Y
            *out_anon = false;
        } break;
        case command_FieldId_finput: { // bool: no argument required but value may be specified as del:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_foutput: { // bool: no argument required but value may be specified as finput:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_srcfile: { // bool: no argument required but value may be specified as foutput:Y
            *out_anon = false;
        } break;
        case command_FieldId_gstatic: { // bool: no argument required but value may be specified as foutput:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_indexed: { // bool: no argument required but value may be specified as gstatic:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_target: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_nstype: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_ctype: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_pooltype: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_ssimfile: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_subset: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_subset2: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_separator: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_field: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_arg: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_dflt: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
        } break;
        case command_FieldId_anon: { // bool: no argument required but value may be specified as indexed:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_bigend: { // bool: no argument required but value may be specified as anon:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_cascdel: { // bool: no argument required but value may be specified as bigend:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_before: { // bool: no argument required but value may be specified as cascdel:Y
            *out_anon = false;
        } break;
        case command_FieldId_substr: { // bool: no argument required but value may be specified as cascdel:Y
            *out_anon = false;
        } break;
        case command_FieldId_alias: { // bool: no argument required but value may be specified as cascdel:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_srcfield: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_fstep: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_inscond: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_reftype: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_hashfld: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_sortfld: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_unittest: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_citest: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_cppfunc: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
        } break;
        case command_FieldId_xref: { // bool: no argument required but value may be specified as alias:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_via: { // bool: no argument required but value may be specified as xref:Y
            *out_anon = false;
        } break;
        case command_FieldId_write: { // bool: no argument required but value may be specified as xref:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_comment: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
        } break;
        case command_FieldId_sandbox: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_test: { // bool: no argument required but value may be specified as sandbox:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showcpp: { // bool: no argument required but value may be specified as test:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_msgtype: { // bool: no argument required but value may be specified as showcpp:Y
            *out_anon = false;
        } break;
        case command_FieldId_anonfld: { // bool: no argument required but value may be specified as showcpp:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_ed_proc.acr_ed.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_ed_Start(command::acr_ed_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_ed_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_ed_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_ed_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_ed_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_ed_proc.acr_ed.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_ed_StartRead(command::acr_ed_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_ed_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_ed_proc.acr_ed.Kill
// Kill subprocess and wait
void command::acr_ed_Kill(command::acr_ed_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_ed_Wait(parent);
    }
}

// --- command.acr_ed_proc.acr_ed.Wait
// Wait for subprocess to return
void command::acr_ed_Wait(command::acr_ed_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_ed_proc.acr_ed.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_ed_Exec(command::acr_ed_proc& parent) {
    acr_ed_Start(parent);
    acr_ed_Wait(parent);
    return parent.status;
}

// --- command.acr_ed_proc.acr_ed.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_ed_ExecX(command::acr_ed_proc& parent) {
    int rc = acr_ed_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_ed_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_ed_proc.acr_ed.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_ed_Execv(command::acr_ed_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_ed_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_ed_proc.acr_ed.ToCmdline
algo::tempstr command::acr_ed_ToCmdline(command::acr_ed_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_ed_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_ed_proc.acr_ed.ToArgv
// Form array from the command line
void command::acr_ed_ToArgv(command::acr_ed_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.create != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-create:";
        bool_Print(parent.cmd.create, *arg);
    }

    if (parent.cmd.del != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-del:";
        bool_Print(parent.cmd.del, *arg);
    }

    if (parent.cmd.rename != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-rename:";
        cstring_Print(parent.cmd.rename, *arg);
    }

    if (parent.cmd.finput != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-finput:";
        bool_Print(parent.cmd.finput, *arg);
    }

    if (parent.cmd.foutput != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-foutput:";
        bool_Print(parent.cmd.foutput, *arg);
    }

    if (parent.cmd.srcfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-srcfile:";
        cstring_Print(parent.cmd.srcfile, *arg);
    }

    if (parent.cmd.gstatic != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gstatic:";
        bool_Print(parent.cmd.gstatic, *arg);
    }

    if (parent.cmd.indexed != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-indexed:";
        bool_Print(parent.cmd.indexed, *arg);
    }

    if (parent.cmd.target != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        Smallstr16_Print(parent.cmd.target, *arg);
    }

    if (parent.cmd.nstype != "exe") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nstype:";
        Smallstr50_Print(parent.cmd.nstype, *arg);
    }

    if (parent.cmd.ctype != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ctype:";
        Smallstr100_Print(parent.cmd.ctype, *arg);
    }

    if (parent.cmd.pooltype != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pooltype:";
        Smallstr50_Print(parent.cmd.pooltype, *arg);
    }

    if (parent.cmd.ssimfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ssimfile:";
        Smallstr50_Print(parent.cmd.ssimfile, *arg);
    }

    if (parent.cmd.subset != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-subset:";
        Smallstr100_Print(parent.cmd.subset, *arg);
    }

    if (parent.cmd.subset2 != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-subset2:";
        Smallstr100_Print(parent.cmd.subset2, *arg);
    }

    if (parent.cmd.separator != ".") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-separator:";
        cstring_Print(parent.cmd.separator, *arg);
    }

    if (parent.cmd.field != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-field:";
        Smallstr100_Print(parent.cmd.field, *arg);
    }

    if (parent.cmd.arg != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-arg:";
        Smallstr100_Print(parent.cmd.arg, *arg);
    }

    if (parent.cmd.dflt != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dflt:";
        cstring_Print(parent.cmd.dflt, *arg);
    }

    if (parent.cmd.anon != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-anon:";
        bool_Print(parent.cmd.anon, *arg);
    }

    if (parent.cmd.bigend != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-bigend:";
        bool_Print(parent.cmd.bigend, *arg);
    }

    if (parent.cmd.cascdel != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cascdel:";
        bool_Print(parent.cmd.cascdel, *arg);
    }

    if (parent.cmd.before != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-before:";
        Smallstr100_Print(parent.cmd.before, *arg);
    }

    if (parent.cmd.substr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-substr:";
        Smallstr100_Print(parent.cmd.substr, *arg);
    }

    if (parent.cmd.alias != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-alias:";
        bool_Print(parent.cmd.alias, *arg);
    }

    if (parent.cmd.srcfield != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-srcfield:";
        Smallstr100_Print(parent.cmd.srcfield, *arg);
    }

    if (parent.cmd.fstep != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fstep:";
        Smallstr100_Print(parent.cmd.fstep, *arg);
    }

    if (parent.cmd.inscond != "true") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-inscond:";
        cstring_Print(parent.cmd.inscond, *arg);
    }

    if (parent.cmd.reftype != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-reftype:";
        Smallstr50_Print(parent.cmd.reftype, *arg);
    }

    if (parent.cmd.hashfld != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-hashfld:";
        Smallstr100_Print(parent.cmd.hashfld, *arg);
    }

    if (parent.cmd.sortfld != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-sortfld:";
        Smallstr100_Print(parent.cmd.sortfld, *arg);
    }

    if (parent.cmd.unittest != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-unittest:";
        cstring_Print(parent.cmd.unittest, *arg);
    }

    if (parent.cmd.citest != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-citest:";
        cstring_Print(parent.cmd.citest, *arg);
    }

    if (parent.cmd.cppfunc != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cppfunc:";
        cstring_Print(parent.cmd.cppfunc, *arg);
    }

    if (parent.cmd.xref != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-xref:";
        bool_Print(parent.cmd.xref, *arg);
    }

    if (parent.cmd.via != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-via:";
        cstring_Print(parent.cmd.via, *arg);
    }

    if (parent.cmd.write != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write:";
        bool_Print(parent.cmd.write, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.comment != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-comment:";
        cstring_Print(parent.cmd.comment, *arg);
    }

    if (parent.cmd.sandbox != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-sandbox:";
        bool_Print(parent.cmd.sandbox, *arg);
    }

    if (parent.cmd.test != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-test:";
        bool_Print(parent.cmd.test, *arg);
    }

    if (parent.cmd.showcpp != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showcpp:";
        bool_Print(parent.cmd.showcpp, *arg);
    }

    if (parent.cmd.msgtype != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-msgtype:";
        cstring_Print(parent.cmd.msgtype, *arg);
    }

    if (parent.cmd.anonfld != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-anonfld:";
        bool_Print(parent.cmd.anonfld, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_ed_proc..Uninit
void command::acr_ed_proc_Uninit(command::acr_ed_proc& parent) {
    command::acr_ed_proc &row = parent; (void)row;

    // command.acr_ed_proc.acr_ed.Uninit (Exec)  //
    acr_ed_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_in.ns.Print
// Print back to string
void command::ns_Print(command::acr_in& parent, algo::cstring &out) {
    Regx_Print(parent.ns, out);
}

// --- command.acr_in.ns.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ns_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.ns, in, true);
    return retval;
}

// --- command.acr_in.notssimfile.Print
// Print back to string
void command::notssimfile_Print(command::acr_in& parent, algo::cstring &out) {
    Regx_Print(parent.notssimfile, out);
}

// --- command.acr_in.notssimfile.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::notssimfile_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.notssimfile, in, true);
    return retval;
}

// --- command.acr_in.r.Print
// Print back to string
void command::r_Print(command::acr_in& parent, algo::cstring &out) {
    Regx_Print(parent.r, out);
}

// --- command.acr_in.r.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::r_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.r, in, true);
    return retval;
}

// --- command.acr_in..ReadFieldMaybe
bool command::acr_in_ReadFieldMaybe(command::acr_in& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_ns: {
            retval = ns_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_data: {
            retval = bool_ReadStrptrMaybe(parent.data, strval);
            break;
        }
        case command_FieldId_sigcheck: {
            retval = bool_ReadStrptrMaybe(parent.sigcheck, strval);
            break;
        }
        case command_FieldId_list: {
            retval = bool_ReadStrptrMaybe(parent.list, strval);
            break;
        }
        case command_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
            break;
        }
        case command_FieldId_data_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_related: {
            retval = algo::cstring_ReadStrptrMaybe(parent.related, strval);
            break;
        }
        case command_FieldId_notssimfile: {
            retval = notssimfile_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_checkable: {
            retval = bool_ReadStrptrMaybe(parent.checkable, strval);
            break;
        }
        case command_FieldId_r: {
            retval = r_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_in..ReadTupleMaybe
// Read fields of command::acr_in from attributes of ascii tuple TUPLE
bool command::acr_in_ReadTupleMaybe(command::acr_in &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_in_GetAnon(parent, anon_idx++);
        }
        retval = acr_in_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_in..Init
// Set all fields to initial values.
void command::acr_in_Init(command::acr_in& parent) {
    Regx_ReadSql(parent.ns, "", true);
    parent.data = bool(false);
    parent.sigcheck = bool(true);
    parent.list = bool(false);
    parent.t = bool(false);
    parent.data_dir = algo::strptr("data");
    parent.schema = algo::strptr("data");
    parent.related = algo::strptr("");
    Regx_ReadSql(parent.notssimfile, "", true);
    parent.checkable = bool(false);
    Regx_ReadSql(parent.r, "", true);
}

// --- command.acr_in..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_in_ToCmdline(command::acr_in& row) {
    tempstr ret;
    ret << "bin/acr_in ";
    acr_in_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_in..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr_in.Argv  printfmt:Auto
void command::acr_in_PrintArgv(command::acr_in& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    command::ns_Print(const_cast<command::acr_in&>(row), temp);
    str << " -ns:";
    strptr_PrintBash(temp,str);
    if (!(row.data == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.data, temp);
        str << " -data:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sigcheck == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.sigcheck, temp);
        str << " -sigcheck:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.related == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.related, temp);
        str << " -related:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.notssimfile.expr == "")) {
        ch_RemoveAll(temp);
        command::notssimfile_Print(const_cast<command::acr_in&>(row), temp);
        str << " -notssimfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.checkable == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.checkable, temp);
        str << " -checkable:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.r.expr == "")) {
        ch_RemoveAll(temp);
        command::r_Print(const_cast<command::acr_in&>(row), temp);
        str << " -r:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_in..GetAnon
algo::strptr command::acr_in_GetAnon(command::acr_in &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ns", 2);
        default: return algo::strptr();
    }
}

// --- command.acr_in..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_in_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_ns: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_data: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_sigcheck: { // bool: no argument required but value may be specified as data:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_list: { // bool: no argument required but value may be specified as sigcheck:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_t: { // bool: no argument required but value may be specified as list:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_data_dir: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
        } break;
        case command_FieldId_schema: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
        } break;
        case command_FieldId_related: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
        } break;
        case command_FieldId_notssimfile: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
        } break;
        case command_FieldId_checkable: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_r: { // bool: no argument required but value may be specified as checkable:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_in_proc.acr_in.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_in_Start(command::acr_in_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_in_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_in_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_in_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_in_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_in_proc.acr_in.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_in_StartRead(command::acr_in_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_in_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_in_proc.acr_in.Kill
// Kill subprocess and wait
void command::acr_in_Kill(command::acr_in_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_in_Wait(parent);
    }
}

// --- command.acr_in_proc.acr_in.Wait
// Wait for subprocess to return
void command::acr_in_Wait(command::acr_in_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_in_proc.acr_in.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_in_Exec(command::acr_in_proc& parent) {
    acr_in_Start(parent);
    acr_in_Wait(parent);
    return parent.status;
}

// --- command.acr_in_proc.acr_in.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_in_ExecX(command::acr_in_proc& parent) {
    int rc = acr_in_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_in_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_in_proc.acr_in.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_in_Execv(command::acr_in_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_in_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_in_proc.acr_in.ToCmdline
algo::tempstr command::acr_in_ToCmdline(command::acr_in_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_in_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_in_proc.acr_in.ToArgv
// Form array from the command line
void command::acr_in_ToArgv(command::acr_in_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.ns.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ns:";
        command::ns_Print(parent.cmd, *arg);
    }

    if (parent.cmd.data != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data:";
        bool_Print(parent.cmd.data, *arg);
    }

    if (parent.cmd.sigcheck != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-sigcheck:";
        bool_Print(parent.cmd.sigcheck, *arg);
    }

    if (parent.cmd.list != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-list:";
        bool_Print(parent.cmd.list, *arg);
    }

    if (parent.cmd.t != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-t:";
        bool_Print(parent.cmd.t, *arg);
    }

    if (parent.cmd.data_dir != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, *arg);
    }

    if (parent.cmd.schema != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        cstring_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.related != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-related:";
        cstring_Print(parent.cmd.related, *arg);
    }

    if (parent.cmd.notssimfile.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-notssimfile:";
        command::notssimfile_Print(parent.cmd, *arg);
    }

    if (parent.cmd.checkable != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-checkable:";
        bool_Print(parent.cmd.checkable, *arg);
    }

    if (parent.cmd.r.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-r:";
        command::r_Print(parent.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_in_proc..Uninit
void command::acr_in_proc_Uninit(command::acr_in_proc& parent) {
    command::acr_in_proc &row = parent; (void)row;

    // command.acr_in_proc.acr_in.Uninit (Exec)  //
    acr_in_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_my.nsdb.Print
// Print back to string
void command::nsdb_Print(command::acr_my& parent, algo::cstring &out) {
    Regx_Print(parent.nsdb, out);
}

// --- command.acr_my.nsdb.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::nsdb_ReadStrptrMaybe(command::acr_my& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.nsdb, in, true);
    return retval;
}

// --- command.acr_my..ReadFieldMaybe
bool command::acr_my_ReadFieldMaybe(command::acr_my& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_nsdb: {
            retval = nsdb_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_fldfunc: {
            retval = bool_ReadStrptrMaybe(parent.fldfunc, strval);
            break;
        }
        case command_FieldId_fkey: {
            retval = bool_ReadStrptrMaybe(parent.fkey, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_start: {
            retval = bool_ReadStrptrMaybe(parent.start, strval);
            break;
        }
        case command_FieldId_stop: {
            retval = bool_ReadStrptrMaybe(parent.stop, strval);
            break;
        }
        case command_FieldId_abort: {
            retval = bool_ReadStrptrMaybe(parent.abort, strval);
            break;
        }
        case command_FieldId_shell: {
            retval = bool_ReadStrptrMaybe(parent.shell, strval);
            break;
        }
        case command_FieldId_serv: {
            retval = bool_ReadStrptrMaybe(parent.serv, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_my..ReadTupleMaybe
// Read fields of command::acr_my from attributes of ascii tuple TUPLE
bool command::acr_my_ReadTupleMaybe(command::acr_my &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_my_GetAnon(parent, anon_idx++);
        }
        retval = acr_my_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_my..Init
// Set all fields to initial values.
void command::acr_my_Init(command::acr_my& parent) {
    Regx_ReadSql(parent.nsdb, "", true);
    parent.in = algo::strptr("data");
    parent.schema = algo::strptr("data");
    parent.fldfunc = bool(false);
    parent.fkey = bool(false);
    parent.e = bool(false);
    parent.start = bool(false);
    parent.stop = bool(false);
    parent.abort = bool(false);
    parent.shell = bool(false);
    parent.serv = bool(false);
}

// --- command.acr_my..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_my_ToCmdline(command::acr_my& row) {
    tempstr ret;
    ret << "bin/acr_my ";
    acr_my_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_my..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.acr_my.Argv  printfmt:Tuple
void command::acr_my_PrintArgv(command::acr_my& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    command::nsdb_Print(const_cast<command::acr_my&>(row), temp);
    str << " -nsdb:";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fkey, temp);
        str << " -fkey:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.start == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.start, temp);
        str << " -start:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stop == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stop, temp);
        str << " -stop:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.abort == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.abort, temp);
        str << " -abort:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.shell == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.shell, temp);
        str << " -shell:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.serv == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.serv, temp);
        str << " -serv:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_my..GetAnon
algo::strptr command::acr_my_GetAnon(command::acr_my &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("nsdb", 4);
        default: return algo::strptr();
    }
}

// --- command.acr_my..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::acr_my_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_nsdb: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_schema: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_fldfunc: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_fkey: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as fkey:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_start: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_stop: { // bool: no argument required but value may be specified as start:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_abort: { // bool: no argument required but value may be specified as stop:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_shell: { // bool: no argument required but value may be specified as abort:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_serv: { // bool: no argument required but value may be specified as shell:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.acr_my_proc.acr_my.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_my_Start(command::acr_my_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_my_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_my_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_my_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_my_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_my_proc.acr_my.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_my_StartRead(command::acr_my_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_my_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_my_proc.acr_my.Kill
// Kill subprocess and wait
void command::acr_my_Kill(command::acr_my_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_my_Wait(parent);
    }
}

// --- command.acr_my_proc.acr_my.Wait
// Wait for subprocess to return
void command::acr_my_Wait(command::acr_my_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_my_proc.acr_my.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_my_Exec(command::acr_my_proc& parent) {
    acr_my_Start(parent);
    acr_my_Wait(parent);
    return parent.status;
}

// --- command.acr_my_proc.acr_my.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_my_ExecX(command::acr_my_proc& parent) {
    int rc = acr_my_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_my_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_my_proc.acr_my.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_my_Execv(command::acr_my_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_my_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_my_proc.acr_my.ToCmdline
algo::tempstr command::acr_my_ToCmdline(command::acr_my_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_my_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_my_proc.acr_my.ToArgv
// Form array from the command line
void command::acr_my_ToArgv(command::acr_my_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.nsdb.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nsdb:";
        command::nsdb_Print(parent.cmd, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.schema != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        cstring_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.fldfunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, *arg);
    }

    if (parent.cmd.fkey != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fkey:";
        bool_Print(parent.cmd.fkey, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.start != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-start:";
        bool_Print(parent.cmd.start, *arg);
    }

    if (parent.cmd.stop != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-stop:";
        bool_Print(parent.cmd.stop, *arg);
    }

    if (parent.cmd.abort != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-abort:";
        bool_Print(parent.cmd.abort, *arg);
    }

    if (parent.cmd.shell != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-shell:";
        bool_Print(parent.cmd.shell, *arg);
    }

    if (parent.cmd.serv != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-serv:";
        bool_Print(parent.cmd.serv, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_my_proc..Uninit
void command::acr_my_proc_Uninit(command::acr_my_proc& parent) {
    command::acr_my_proc &row = parent; (void)row;

    // command.acr_my_proc.acr_my.Uninit (Exec)  //
    acr_my_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_proc.acr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_Start(command::acr_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_proc.acr.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_StartRead(command::acr_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_proc.acr.Kill
// Kill subprocess and wait
void command::acr_Kill(command::acr_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_Wait(parent);
    }
}

// --- command.acr_proc.acr.Wait
// Wait for subprocess to return
void command::acr_Wait(command::acr_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_proc.acr.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_Exec(command::acr_proc& parent) {
    acr_Start(parent);
    acr_Wait(parent);
    return parent.status;
}

// --- command.acr_proc.acr.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_ExecX(command::acr_proc& parent) {
    int rc = acr_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_proc.acr.Execv
// Call execv()
// Call execv with specified parameters
int command::acr_Execv(command::acr_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    acr_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.acr_proc.acr.ToCmdline
algo::tempstr command::acr_ToCmdline(command::acr_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_proc.acr.ToArgv
// Form array from the command line
void command::acr_ToArgv(command::acr_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.query != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-query:";
        cstring_Print(parent.cmd.query, *arg);
    }
    ind_beg(command::acr_where_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-where:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.del != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-del:";
        bool_Print(parent.cmd.del, *arg);
    }

    if (parent.cmd.sel != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-sel:";
        bool_Print(parent.cmd.sel, *arg);
    }

    if (parent.cmd.insert != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-insert:";
        bool_Print(parent.cmd.insert, *arg);
    }

    if (parent.cmd.replace != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-replace:";
        bool_Print(parent.cmd.replace, *arg);
    }

    if (parent.cmd.update != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-update:";
        bool_Print(parent.cmd.update, *arg);
    }

    if (parent.cmd.merge != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-merge:";
        bool_Print(parent.cmd.merge, *arg);
    }

    if (parent.cmd.unused != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-unused:";
        bool_Print(parent.cmd.unused, *arg);
    }

    if (parent.cmd.trunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-trunc:";
        bool_Print(parent.cmd.trunc, *arg);
    }

    if (parent.cmd.check != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check:";
        bool_Print(parent.cmd.check, *arg);
    }

    if (parent.cmd.selerr != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-selerr:";
        bool_Print(parent.cmd.selerr, *arg);
    }

    if (parent.cmd.maxshow != 100) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxshow:";
        i32_Print(parent.cmd.maxshow, *arg);
    }

    if (parent.cmd.write != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write:";
        bool_Print(parent.cmd.write, *arg);
    }

    if (parent.cmd.rename != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-rename:";
        cstring_Print(parent.cmd.rename, *arg);
    }

    if (parent.cmd.nup != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nup:";
        i32_Print(parent.cmd.nup, *arg);
    }

    if (parent.cmd.ndown != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ndown:";
        i32_Print(parent.cmd.ndown, *arg);
    }

    if (parent.cmd.l != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-l:";
        bool_Print(parent.cmd.l, *arg);
    }

    if (parent.cmd.xref != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-xref:";
        bool_Print(parent.cmd.xref, *arg);
    }

    if (parent.cmd.fldfunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, *arg);
    }

    if (parent.cmd.maxgroup != 25) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxgroup:";
        i32_Print(parent.cmd.maxgroup, *arg);
    }

    if (parent.cmd.pretty != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pretty:";
        bool_Print(parent.cmd.pretty, *arg);
    }

    if (parent.cmd.tree != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-tree:";
        bool_Print(parent.cmd.tree, *arg);
    }

    if (parent.cmd.loose != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-loose:";
        bool_Print(parent.cmd.loose, *arg);
    }

    if (parent.cmd.my != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-my:";
        bool_Print(parent.cmd.my, *arg);
    }

    if (parent.cmd.schema != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        cstring_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.t != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-t:";
        bool_Print(parent.cmd.t, *arg);
    }

    if (parent.cmd.g != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-g:";
        bool_Print(parent.cmd.g, *arg);
    }

    if (parent.cmd.x != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-x:";
        bool_Print(parent.cmd.x, *arg);
    }

    if (parent.cmd.rowid != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-rowid:";
        bool_Print(parent.cmd.rowid, *arg);
    }

    if (parent.cmd.cmt != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmt:";
        bool_Print(parent.cmd.cmt, *arg);
    }

    if (parent.cmd.report != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.print != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-print:";
        bool_Print(parent.cmd.print, *arg);
    }

    if (parent.cmd.cmd != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmd:";
        cstring_Print(parent.cmd.cmd, *arg);
    }
    ind_beg(command::acr_field_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-field:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.regxof != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-regxof:";
        cstring_Print(parent.cmd.regxof, *arg);
    }

    if (parent.cmd.meta != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-meta:";
        bool_Print(parent.cmd.meta, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.acr_proc..Uninit
void command::acr_proc_Uninit(command::acr_proc& parent) {
    command::acr_proc &row = parent; (void)row;

    // command.acr_proc.acr.Uninit (Exec)  //
    acr_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc.trace.Print
// Print back to string
void command::trace_Print(command::amc& parent, algo::cstring &out) {
    Regx_Print(parent.trace, out);
}

// --- command.amc.trace.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::trace_ReadStrptrMaybe(command::amc& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.trace, in, true);
    return retval;
}

// --- command.amc..ReadFieldMaybe
bool command::amc_ReadFieldMaybe(command::amc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in_dir, strval);
            break;
        }
        case command_FieldId_query: {
            retval = algo::cstring_ReadStrptrMaybe(parent.query, strval);
            break;
        }
        case command_FieldId_out_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.out_dir, strval);
            break;
        }
        case command_FieldId_proto: {
            retval = bool_ReadStrptrMaybe(parent.proto, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_trace: {
            retval = trace_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc..ReadTupleMaybe
// Read fields of command::amc from attributes of ascii tuple TUPLE
bool command::amc_ReadTupleMaybe(command::amc &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = amc_GetAnon(parent, anon_idx++);
        }
        retval = amc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc..Init
// Set all fields to initial values.
void command::amc_Init(command::amc& parent) {
    parent.in_dir = algo::strptr("data");
    parent.query = algo::strptr("");
    parent.out_dir = algo::strptr(".");
    parent.proto = bool(false);
    parent.report = bool(true);
    parent.e = bool(false);
    Regx_ReadSql(parent.trace, "", true);
}

// --- command.amc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_ToCmdline(command::amc& row) {
    tempstr ret;
    ret << "bin/amc ";
    amc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.amc.Argv  printfmt:Auto
void command::amc_PrintArgv(command::amc& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in_dir, temp);
        str << " -in_dir:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.query, temp);
    str << " -query:";
    strptr_PrintBash(temp,str);
    if (!(row.out_dir == ".")) {
        ch_RemoveAll(temp);
        cstring_Print(row.out_dir, temp);
        str << " -out_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.proto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.proto, temp);
        str << " -proto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trace.expr == "")) {
        ch_RemoveAll(temp);
        command::trace_Print(const_cast<command::amc&>(row), temp);
        str << " -trace:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc..GetAnon
algo::strptr command::amc_GetAnon(command::amc &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("query", 5);
        default: return algo::strptr();
    }
}

// --- command.amc..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::amc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in_dir: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_query: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_out_dir: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_proto: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as proto:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_trace: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.amc_gc.target.Print
// Print back to string
void command::target_Print(command::amc_gc& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.amc_gc.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.target, in, true);
    return retval;
}

// --- command.amc_gc.key.Print
// Print back to string
void command::key_Print(command::amc_gc& parent, algo::cstring &out) {
    Regx_Print(parent.key, out);
}

// --- command.amc_gc.key.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::key_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.key, in, true);
    return retval;
}

// --- command.amc_gc..ReadFieldMaybe
bool command::amc_gc_ReadFieldMaybe(command::amc_gc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_target: {
            retval = target_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_key: {
            retval = key_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_include: {
            retval = bool_ReadStrptrMaybe(parent.include, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc_gc..ReadTupleMaybe
// Read fields of command::amc_gc from attributes of ascii tuple TUPLE
bool command::amc_gc_ReadTupleMaybe(command::amc_gc &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = amc_gc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc_gc..Init
// Set all fields to initial values.
void command::amc_gc_Init(command::amc_gc& parent) {
    Regx_ReadSql(parent.target, "%", true);
    Regx_ReadSql(parent.key, "", true);
    parent.include = bool(false);
    parent.in = algo::strptr("data");
}

// --- command.amc_gc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_gc_ToCmdline(command::amc_gc& row) {
    tempstr ret;
    ret << "bin/amc_gc ";
    amc_gc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc_gc..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.amc_gc.Argv  printfmt:Tuple
void command::amc_gc_PrintArgv(command::amc_gc& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.target.expr == "%")) {
        ch_RemoveAll(temp);
        command::target_Print(const_cast<command::amc_gc&>(row), temp);
        str << " -target:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.key.expr == "")) {
        ch_RemoveAll(temp);
        command::key_Print(const_cast<command::amc_gc&>(row), temp);
        str << " -key:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.include == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.include, temp);
        str << " -include:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc_gc..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::amc_gc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_target: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_key: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_include: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_in: { // bool: no argument required but value may be specified as include:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.amc_gc_proc.amc_gc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_gc_Start(command::amc_gc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_gc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_gc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_gc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_gc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_gc_proc.amc_gc.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_gc_StartRead(command::amc_gc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_gc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_gc_proc.amc_gc.Kill
// Kill subprocess and wait
void command::amc_gc_Kill(command::amc_gc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_gc_Wait(parent);
    }
}

// --- command.amc_gc_proc.amc_gc.Wait
// Wait for subprocess to return
void command::amc_gc_Wait(command::amc_gc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_gc_proc.amc_gc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_gc_Exec(command::amc_gc_proc& parent) {
    amc_gc_Start(parent);
    amc_gc_Wait(parent);
    return parent.status;
}

// --- command.amc_gc_proc.amc_gc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_gc_ExecX(command::amc_gc_proc& parent) {
    int rc = amc_gc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_gc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_gc_proc.amc_gc.Execv
// Call execv()
// Call execv with specified parameters
int command::amc_gc_Execv(command::amc_gc_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    amc_gc_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.amc_gc_proc.amc_gc.ToCmdline
algo::tempstr command::amc_gc_ToCmdline(command::amc_gc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_gc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_gc_proc.amc_gc.ToArgv
// Form array from the command line
void command::amc_gc_ToArgv(command::amc_gc_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.target.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        command::target_Print(parent.cmd, *arg);
    }

    if (parent.cmd.key.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-key:";
        command::key_Print(parent.cmd, *arg);
    }

    if (parent.cmd.include != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-include:";
        bool_Print(parent.cmd.include, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.amc_gc_proc..Uninit
void command::amc_gc_proc_Uninit(command::amc_gc_proc& parent) {
    command::amc_gc_proc &row = parent; (void)row;

    // command.amc_gc_proc.amc_gc.Uninit (Exec)  //
    amc_gc_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc_proc.amc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_Start(command::amc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_proc.amc.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_StartRead(command::amc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_proc.amc.Kill
// Kill subprocess and wait
void command::amc_Kill(command::amc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_Wait(parent);
    }
}

// --- command.amc_proc.amc.Wait
// Wait for subprocess to return
void command::amc_Wait(command::amc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_proc.amc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_Exec(command::amc_proc& parent) {
    amc_Start(parent);
    amc_Wait(parent);
    return parent.status;
}

// --- command.amc_proc.amc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_ExecX(command::amc_proc& parent) {
    int rc = amc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_proc.amc.Execv
// Call execv()
// Call execv with specified parameters
int command::amc_Execv(command::amc_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    amc_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.amc_proc.amc.ToCmdline
algo::tempstr command::amc_ToCmdline(command::amc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_proc.amc.ToArgv
// Form array from the command line
void command::amc_ToArgv(command::amc_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in_dir != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in_dir:";
        cstring_Print(parent.cmd.in_dir, *arg);
    }

    if (parent.cmd.query != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-query:";
        cstring_Print(parent.cmd.query, *arg);
    }

    if (parent.cmd.out_dir != ".") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-out_dir:";
        cstring_Print(parent.cmd.out_dir, *arg);
    }

    if (parent.cmd.proto != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-proto:";
        bool_Print(parent.cmd.proto, *arg);
    }

    if (parent.cmd.report != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.trace.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-trace:";
        command::trace_Print(parent.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.amc_proc..Uninit
void command::amc_proc_Uninit(command::amc_proc& parent) {
    command::amc_proc &row = parent; (void)row;

    // command.amc_proc.amc.Uninit (Exec)  //
    amc_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc_vis.ctype.Print
// Print back to string
void command::ctype_Print(command::amc_vis& parent, algo::cstring &out) {
    Regx_Print(parent.ctype, out);
}

// --- command.amc_vis.ctype.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ctype_ReadStrptrMaybe(command::amc_vis& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.ctype, in, true);
    return retval;
}

// --- command.amc_vis..ReadFieldMaybe
bool command::amc_vis_ReadFieldMaybe(command::amc_vis& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_ctype: {
            retval = ctype_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_dot: {
            retval = algo::cstring_ReadStrptrMaybe(parent.dot, strval);
            break;
        }
        case command_FieldId_xref: {
            retval = bool_ReadStrptrMaybe(parent.xref, strval);
            break;
        }
        case command_FieldId_xns: {
            retval = bool_ReadStrptrMaybe(parent.xns, strval);
            break;
        }
        case command_FieldId_noinput: {
            retval = bool_ReadStrptrMaybe(parent.noinput, strval);
            break;
        }
        case command_FieldId_check: {
            retval = bool_ReadStrptrMaybe(parent.check, strval);
            break;
        }
        case command_FieldId_render: {
            retval = bool_ReadStrptrMaybe(parent.render, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc_vis..ReadTupleMaybe
// Read fields of command::amc_vis from attributes of ascii tuple TUPLE
bool command::amc_vis_ReadTupleMaybe(command::amc_vis &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = amc_vis_GetAnon(parent, anon_idx++);
        }
        retval = amc_vis_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc_vis..Init
// Set all fields to initial values.
void command::amc_vis_Init(command::amc_vis& parent) {
    Regx_ReadSql(parent.ctype, "%", true);
    parent.in = algo::strptr("data");
    parent.dot = algo::strptr("");
    parent.xref = bool(false);
    parent.xns = bool(false);
    parent.noinput = bool(false);
    parent.check = bool(false);
    parent.render = bool(true);
}

// --- command.amc_vis..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_vis_ToCmdline(command::amc_vis& row) {
    tempstr ret;
    ret << "bin/amc_vis ";
    amc_vis_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc_vis..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.amc_vis.Argv  printfmt:Auto
void command::amc_vis_PrintArgv(command::amc_vis& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    command::ctype_Print(const_cast<command::amc_vis&>(row), temp);
    str << " -ctype:";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dot == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dot, temp);
        str << " -dot:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xns == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xns, temp);
        str << " -xns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.noinput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.noinput, temp);
        str << " -noinput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.render == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.render, temp);
        str << " -render:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc_vis..GetAnon
algo::strptr command::amc_vis_GetAnon(command::amc_vis &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ctype", 5);
        default: return algo::strptr();
    }
}

// --- command.amc_vis..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::amc_vis_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_ctype: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_dot: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_xref: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_xns: { // bool: no argument required but value may be specified as xref:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_noinput: { // bool: no argument required but value may be specified as xns:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check: { // bool: no argument required but value may be specified as noinput:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_render: { // bool: no argument required but value may be specified as check:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.amc_vis_proc.amc_vis.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_vis_Start(command::amc_vis_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_vis_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_vis_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_vis_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_vis_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_vis_proc.amc_vis.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_vis_StartRead(command::amc_vis_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_vis_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_vis_proc.amc_vis.Kill
// Kill subprocess and wait
void command::amc_vis_Kill(command::amc_vis_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_vis_Wait(parent);
    }
}

// --- command.amc_vis_proc.amc_vis.Wait
// Wait for subprocess to return
void command::amc_vis_Wait(command::amc_vis_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_vis_proc.amc_vis.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_vis_Exec(command::amc_vis_proc& parent) {
    amc_vis_Start(parent);
    amc_vis_Wait(parent);
    return parent.status;
}

// --- command.amc_vis_proc.amc_vis.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_vis_ExecX(command::amc_vis_proc& parent) {
    int rc = amc_vis_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_vis_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_vis_proc.amc_vis.Execv
// Call execv()
// Call execv with specified parameters
int command::amc_vis_Execv(command::amc_vis_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    amc_vis_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.amc_vis_proc.amc_vis.ToCmdline
algo::tempstr command::amc_vis_ToCmdline(command::amc_vis_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_vis_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_vis_proc.amc_vis.ToArgv
// Form array from the command line
void command::amc_vis_ToArgv(command::amc_vis_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.ctype.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ctype:";
        command::ctype_Print(parent.cmd, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.dot != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dot:";
        cstring_Print(parent.cmd.dot, *arg);
    }

    if (parent.cmd.xref != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-xref:";
        bool_Print(parent.cmd.xref, *arg);
    }

    if (parent.cmd.xns != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-xns:";
        bool_Print(parent.cmd.xns, *arg);
    }

    if (parent.cmd.noinput != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-noinput:";
        bool_Print(parent.cmd.noinput, *arg);
    }

    if (parent.cmd.check != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check:";
        bool_Print(parent.cmd.check, *arg);
    }

    if (parent.cmd.render != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-render:";
        bool_Print(parent.cmd.render, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.amc_vis_proc..Uninit
void command::amc_vis_proc_Uninit(command::amc_vis_proc& parent) {
    command::amc_vis_proc &row = parent; (void)row;

    // command.amc_vis_proc.amc_vis.Uninit (Exec)  //
    amc_vis_Kill(parent); // kill child, ensure forward progress
}

// --- command.ams_cat..ReadFieldMaybe
bool command::ams_cat_ReadFieldMaybe(command::ams_cat& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ams_cat..ReadTupleMaybe
// Read fields of command::ams_cat from attributes of ascii tuple TUPLE
bool command::ams_cat_ReadTupleMaybe(command::ams_cat &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ams_cat_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ams_cat..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ams_cat_ToCmdline(command::ams_cat& row) {
    tempstr ret;
    ret << "bin/ams_cat ";
    ams_cat_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ams_cat..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.ams_cat.Argv  printfmt:Tuple
void command::ams_cat_PrintArgv(command::ams_cat& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ams_cat..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::ams_cat_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    (void)out_dflt;//only to avoid -Wunused-parameter
    return retval;
}

// --- command.ams_cat_proc.ams_cat.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ams_cat_Start(command::ams_cat_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ams_cat_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ams_cat_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ams_cat_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ams_cat_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ams_cat_proc.ams_cat.StartRead
// Start subprocess & Read output
algo::Fildes command::ams_cat_StartRead(command::ams_cat_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ams_cat_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ams_cat_proc.ams_cat.Kill
// Kill subprocess and wait
void command::ams_cat_Kill(command::ams_cat_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ams_cat_Wait(parent);
    }
}

// --- command.ams_cat_proc.ams_cat.Wait
// Wait for subprocess to return
void command::ams_cat_Wait(command::ams_cat_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ams_cat_proc.ams_cat.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ams_cat_Exec(command::ams_cat_proc& parent) {
    ams_cat_Start(parent);
    ams_cat_Wait(parent);
    return parent.status;
}

// --- command.ams_cat_proc.ams_cat.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ams_cat_ExecX(command::ams_cat_proc& parent) {
    int rc = ams_cat_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ams_cat_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ams_cat_proc.ams_cat.Execv
// Call execv()
// Call execv with specified parameters
int command::ams_cat_Execv(command::ams_cat_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    ams_cat_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.ams_cat_proc.ams_cat.ToCmdline
algo::tempstr command::ams_cat_ToCmdline(command::ams_cat_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ams_cat_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ams_cat_proc.ams_cat.ToArgv
// Form array from the command line
void command::ams_cat_ToArgv(command::ams_cat_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.ams_cat_proc..Uninit
void command::ams_cat_proc_Uninit(command::ams_cat_proc& parent) {
    command::ams_cat_proc &row = parent; (void)row;

    // command.ams_cat_proc.ams_cat.Uninit (Exec)  //
    ams_cat_Kill(parent); // kill child, ensure forward progress
}

// --- command.ams_sendtest.trace.Print
// Print back to string
void command::trace_Print(command::ams_sendtest& parent, algo::cstring &out) {
    Regx_Print(parent.trace, out);
}

// --- command.ams_sendtest.trace.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::trace_ReadStrptrMaybe(command::ams_sendtest& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.trace, in, true);
    return retval;
}

// --- command.ams_sendtest..ReadFieldMaybe
bool command::ams_sendtest_ReadFieldMaybe(command::ams_sendtest& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_id: {
            retval = i32_ReadStrptrMaybe(parent.id, strval);
            break;
        }
        case command_FieldId_file_prefix: {
            retval = algo::cstring_ReadStrptrMaybe(parent.file_prefix, strval);
            break;
        }
        case command_FieldId_nchild: {
            retval = i32_ReadStrptrMaybe(parent.nchild, strval);
            break;
        }
        case command_FieldId_blocking: {
            retval = bool_ReadStrptrMaybe(parent.blocking, strval);
            break;
        }
        case command_FieldId_nmsg: {
            retval = i32_ReadStrptrMaybe(parent.nmsg, strval);
            break;
        }
        case command_FieldId_trace: {
            retval = trace_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_timeout: {
            retval = i32_ReadStrptrMaybe(parent.timeout, strval);
            break;
        }
        case command_FieldId_recvdelay_ns: {
            retval = i64_ReadStrptrMaybe(parent.recvdelay_ns, strval);
            break;
        }
        case command_FieldId_senddelay_ns: {
            retval = i64_ReadStrptrMaybe(parent.senddelay_ns, strval);
            break;
        }
        case command_FieldId_msgsize_min: {
            retval = i32_ReadStrptrMaybe(parent.msgsize_min, strval);
            break;
        }
        case command_FieldId_msgsize_max: {
            retval = i32_ReadStrptrMaybe(parent.msgsize_max, strval);
            break;
        }
        case command_FieldId_bufsize: {
            retval = i32_ReadStrptrMaybe(parent.bufsize, strval);
            break;
        }
        case command_FieldId_recvdelay: {
            retval = i64_ReadStrptrMaybe(parent.recvdelay, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ams_sendtest..ReadTupleMaybe
// Read fields of command::ams_sendtest from attributes of ascii tuple TUPLE
bool command::ams_sendtest_ReadTupleMaybe(command::ams_sendtest &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ams_sendtest_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ams_sendtest..Init
// Set all fields to initial values.
void command::ams_sendtest_Init(command::ams_sendtest& parent) {
    parent.in = algo::strptr("data");
    parent.id = i32(0);
    parent.file_prefix = algo::strptr("");
    parent.nchild = i32(1);
    parent.blocking = bool(false);
    parent.nmsg = i32(1000);
    Regx_ReadSql(parent.trace, "", true);
    parent.timeout = i32(30);
    parent.recvdelay_ns = i64(0);
    parent.senddelay_ns = i64(0);
    parent.msgsize_min = i32(64);
    parent.msgsize_max = i32(1024);
    parent.bufsize = i32(32768);
    parent.recvdelay = i64(0);
}

// --- command.ams_sendtest..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ams_sendtest_ToCmdline(command::ams_sendtest& row) {
    tempstr ret;
    ret << "bin/ams_sendtest ";
    ams_sendtest_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ams_sendtest..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.ams_sendtest.Argv  printfmt:Tuple
void command::ams_sendtest_PrintArgv(command::ams_sendtest& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.id == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.id, temp);
        str << " -id:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.file_prefix == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.file_prefix, temp);
        str << " -file_prefix:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nchild == 1)) {
        ch_RemoveAll(temp);
        i32_Print(row.nchild, temp);
        str << " -nchild:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.blocking == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.blocking, temp);
        str << " -blocking:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nmsg == 1000)) {
        ch_RemoveAll(temp);
        i32_Print(row.nmsg, temp);
        str << " -nmsg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trace.expr == "")) {
        ch_RemoveAll(temp);
        command::trace_Print(const_cast<command::ams_sendtest&>(row), temp);
        str << " -trace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.timeout == 30)) {
        ch_RemoveAll(temp);
        i32_Print(row.timeout, temp);
        str << " -timeout:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.recvdelay_ns == 0)) {
        ch_RemoveAll(temp);
        i64_Print(row.recvdelay_ns, temp);
        str << " -recvdelay_ns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.senddelay_ns == 0)) {
        ch_RemoveAll(temp);
        i64_Print(row.senddelay_ns, temp);
        str << " -senddelay_ns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.msgsize_min == 64)) {
        ch_RemoveAll(temp);
        i32_Print(row.msgsize_min, temp);
        str << " -msgsize_min:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.msgsize_max == 1024)) {
        ch_RemoveAll(temp);
        i32_Print(row.msgsize_max, temp);
        str << " -msgsize_max:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.bufsize == 32768)) {
        ch_RemoveAll(temp);
        i32_Print(row.bufsize, temp);
        str << " -bufsize:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.recvdelay == 0)) {
        ch_RemoveAll(temp);
        i64_Print(row.recvdelay, temp);
        str << " -recvdelay:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ams_sendtest..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::ams_sendtest_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_id: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_file_prefix: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_nchild: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_blocking: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_nmsg: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_trace: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_timeout: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_recvdelay_ns: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_senddelay_ns: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_msgsize_min: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_msgsize_max: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_bufsize: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        case command_FieldId_recvdelay: { // bool: no argument required but value may be specified as blocking:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.ams_sendtest_proc.ams_sendtest.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ams_sendtest_Start(command::ams_sendtest_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ams_sendtest_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ams_sendtest_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ams_sendtest_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ams_sendtest_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ams_sendtest_proc.ams_sendtest.StartRead
// Start subprocess & Read output
algo::Fildes command::ams_sendtest_StartRead(command::ams_sendtest_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ams_sendtest_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ams_sendtest_proc.ams_sendtest.Kill
// Kill subprocess and wait
void command::ams_sendtest_Kill(command::ams_sendtest_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ams_sendtest_Wait(parent);
    }
}

// --- command.ams_sendtest_proc.ams_sendtest.Wait
// Wait for subprocess to return
void command::ams_sendtest_Wait(command::ams_sendtest_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ams_sendtest_proc.ams_sendtest.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ams_sendtest_Exec(command::ams_sendtest_proc& parent) {
    ams_sendtest_Start(parent);
    ams_sendtest_Wait(parent);
    return parent.status;
}

// --- command.ams_sendtest_proc.ams_sendtest.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ams_sendtest_ExecX(command::ams_sendtest_proc& parent) {
    int rc = ams_sendtest_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ams_sendtest_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ams_sendtest_proc.ams_sendtest.Execv
// Call execv()
// Call execv with specified parameters
int command::ams_sendtest_Execv(command::ams_sendtest_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    ams_sendtest_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.ams_sendtest_proc.ams_sendtest.ToCmdline
algo::tempstr command::ams_sendtest_ToCmdline(command::ams_sendtest_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ams_sendtest_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ams_sendtest_proc.ams_sendtest.ToArgv
// Form array from the command line
void command::ams_sendtest_ToArgv(command::ams_sendtest_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.id != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-id:";
        i32_Print(parent.cmd.id, *arg);
    }

    if (parent.cmd.file_prefix != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-file_prefix:";
        cstring_Print(parent.cmd.file_prefix, *arg);
    }

    if (parent.cmd.nchild != 1) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nchild:";
        i32_Print(parent.cmd.nchild, *arg);
    }

    if (parent.cmd.blocking != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-blocking:";
        bool_Print(parent.cmd.blocking, *arg);
    }

    if (parent.cmd.nmsg != 1000) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nmsg:";
        i32_Print(parent.cmd.nmsg, *arg);
    }

    if (parent.cmd.trace.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-trace:";
        command::trace_Print(parent.cmd, *arg);
    }

    if (parent.cmd.timeout != 30) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-timeout:";
        i32_Print(parent.cmd.timeout, *arg);
    }

    if (parent.cmd.recvdelay_ns != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-recvdelay_ns:";
        i64_Print(parent.cmd.recvdelay_ns, *arg);
    }

    if (parent.cmd.senddelay_ns != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-senddelay_ns:";
        i64_Print(parent.cmd.senddelay_ns, *arg);
    }

    if (parent.cmd.msgsize_min != 64) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-msgsize_min:";
        i32_Print(parent.cmd.msgsize_min, *arg);
    }

    if (parent.cmd.msgsize_max != 1024) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-msgsize_max:";
        i32_Print(parent.cmd.msgsize_max, *arg);
    }

    if (parent.cmd.bufsize != 32768) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-bufsize:";
        i32_Print(parent.cmd.bufsize, *arg);
    }

    if (parent.cmd.recvdelay != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-recvdelay:";
        i64_Print(parent.cmd.recvdelay, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.ams_sendtest_proc..Uninit
void command::ams_sendtest_proc_Uninit(command::ams_sendtest_proc& parent) {
    command::ams_sendtest_proc &row = parent; (void)row;

    // command.ams_sendtest_proc.ams_sendtest.Uninit (Exec)  //
    ams_sendtest_Kill(parent); // kill child, ensure forward progress
}

// --- command.apm.package.Print
// Print back to string
void command::package_Print(command::apm& parent, algo::cstring &out) {
    Regx_Print(parent.package, out);
}

// --- command.apm.package.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::package_ReadStrptrMaybe(command::apm& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.package, in, true);
    return retval;
}

// --- command.apm.ns.Print
// Print back to string
void command::ns_Print(command::apm& parent, algo::cstring &out) {
    Regx_Print(parent.ns, out);
}

// --- command.apm.ns.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ns_ReadStrptrMaybe(command::apm& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.ns, in, true);
    return retval;
}

// --- command.apm..ReadFieldMaybe
bool command::apm_ReadFieldMaybe(command::apm& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_pkgdata: {
            retval = algo::cstring_ReadStrptrMaybe(parent.pkgdata, strval);
            break;
        }
        case command_FieldId_package: {
            retval = package_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_ns: {
            retval = ns_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_install: {
            retval = bool_ReadStrptrMaybe(parent.install, strval);
            break;
        }
        case command_FieldId_update: {
            retval = bool_ReadStrptrMaybe(parent.update, strval);
            break;
        }
        case command_FieldId_list: {
            retval = bool_ReadStrptrMaybe(parent.list, strval);
            break;
        }
        case command_FieldId_diff: {
            retval = bool_ReadStrptrMaybe(parent.diff, strval);
            break;
        }
        case command_FieldId_push: {
            retval = bool_ReadStrptrMaybe(parent.push, strval);
            break;
        }
        case command_FieldId_check: {
            retval = bool_ReadStrptrMaybe(parent.check, strval);
            break;
        }
        case command_FieldId_remove: {
            retval = bool_ReadStrptrMaybe(parent.remove, strval);
            break;
        }
        case command_FieldId_origin: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.origin, strval);
            break;
        }
        case command_FieldId_ref: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.ref, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        case command_FieldId_showrec: {
            retval = bool_ReadStrptrMaybe(parent.showrec, strval);
            break;
        }
        case command_FieldId_showfile: {
            retval = bool_ReadStrptrMaybe(parent.showfile, strval);
            break;
        }
        case command_FieldId_R: {
            retval = bool_ReadStrptrMaybe(parent.R, strval);
            break;
        }
        case command_FieldId_l: {
            retval = bool_ReadStrptrMaybe(parent.l, strval);
            break;
        }
        case command_FieldId_reset: {
            retval = bool_ReadStrptrMaybe(parent.reset, strval);
            break;
        }
        case command_FieldId_checkclean: {
            retval = bool_ReadStrptrMaybe(parent.checkclean, strval);
            break;
        }
        case command_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
            break;
        }
        case command_FieldId_stat: {
            retval = bool_ReadStrptrMaybe(parent.stat, strval);
            break;
        }
        case command_FieldId_annotate: {
            retval = algo::cstring_ReadStrptrMaybe(parent.annotate, strval);
            break;
        }
        case command_FieldId_data_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data_in, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_binpath: {
            retval = algo::cstring_ReadStrptrMaybe(parent.binpath, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.apm..ReadTupleMaybe
// Read fields of command::apm from attributes of ascii tuple TUPLE
bool command::apm_ReadTupleMaybe(command::apm &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = apm_GetAnon(parent, anon_idx++);
        }
        retval = apm_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.apm..Init
// Set all fields to initial values.
void command::apm_Init(command::apm& parent) {
    parent.in = algo::strptr("data");
    parent.pkgdata = algo::strptr("");
    Regx_ReadSql(parent.package, "", true);
    Regx_ReadSql(parent.ns, "", true);
    parent.install = bool(false);
    parent.update = bool(false);
    parent.list = bool(false);
    parent.diff = bool(false);
    parent.push = bool(false);
    parent.check = bool(false);
    parent.remove = bool(false);
    parent.origin = algo::strptr("");
    parent.ref = algo::strptr("");
    parent.dry_run = bool(false);
    parent.showrec = bool(false);
    parent.showfile = bool(false);
    parent.R = bool(false);
    parent.l = bool(false);
    parent.reset = bool(false);
    parent.checkclean = bool(true);
    parent.t = bool(false);
    parent.stat = bool(false);
    parent.annotate = algo::strptr("");
    parent.data_in = algo::strptr("data");
    parent.e = bool(false);
    parent.binpath = algo::strptr("bin");
}

// --- command.apm..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::apm_ToCmdline(command::apm& row) {
    tempstr ret;
    ret << "bin/apm ";
    apm_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.apm..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.apm.Argv  printfmt:Tuple
void command::apm_PrintArgv(command::apm& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pkgdata == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.pkgdata, temp);
        str << " -pkgdata:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::package_Print(const_cast<command::apm&>(row), temp);
    str << " -package:";
    strptr_PrintBash(temp,str);
    if (!(row.ns.expr == "")) {
        ch_RemoveAll(temp);
        command::ns_Print(const_cast<command::apm&>(row), temp);
        str << " -ns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.update == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.update, temp);
        str << " -update:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.diff == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.diff, temp);
        str << " -diff:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.push == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.push, temp);
        str << " -push:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.remove == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.remove, temp);
        str << " -remove:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.origin == "")) {
        ch_RemoveAll(temp);
        Smallstr200_Print(row.origin, temp);
        str << " -origin:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ref == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.ref, temp);
        str << " -ref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showrec == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showrec, temp);
        str << " -showrec:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showfile == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showfile, temp);
        str << " -showfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.R == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.R, temp);
        str << " -R:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.l == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.l, temp);
        str << " -l:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.reset == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.reset, temp);
        str << " -reset:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.checkclean == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.checkclean, temp);
        str << " -checkclean:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stat == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stat, temp);
        str << " -stat:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.annotate == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.annotate, temp);
        str << " -annotate:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_in, temp);
        str << " -data_in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.binpath == "bin")) {
        ch_RemoveAll(temp);
        cstring_Print(row.binpath, temp);
        str << " -binpath:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.apm..GetAnon
algo::strptr command::apm_GetAnon(command::apm &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("package", 7);
        default: return algo::strptr();
    }
}

// --- command.apm..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::apm_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_pkgdata: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_package: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_ns: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_install: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_update: { // bool: no argument required but value may be specified as install:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_list: { // bool: no argument required but value may be specified as update:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_diff: { // bool: no argument required but value may be specified as list:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_push: { // bool: no argument required but value may be specified as diff:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check: { // bool: no argument required but value may be specified as push:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_remove: { // bool: no argument required but value may be specified as check:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_origin: { // bool: no argument required but value may be specified as remove:Y
            *out_anon = false;
        } break;
        case command_FieldId_ref: { // bool: no argument required but value may be specified as remove:Y
            *out_anon = false;
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as remove:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showrec: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showfile: { // bool: no argument required but value may be specified as showrec:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_R: { // bool: no argument required but value may be specified as showfile:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_l: { // bool: no argument required but value may be specified as R:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_reset: { // bool: no argument required but value may be specified as l:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_checkclean: { // bool: no argument required but value may be specified as reset:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_t: { // bool: no argument required but value may be specified as checkclean:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_stat: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_annotate: { // bool: no argument required but value may be specified as stat:Y
            *out_anon = false;
        } break;
        case command_FieldId_data_in: { // bool: no argument required but value may be specified as stat:Y
            *out_anon = false;
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as stat:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_binpath: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.apm_proc.apm.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::apm_Start(command::apm_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(apm_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(apm_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= apm_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.apm_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.apm_proc.apm.StartRead
// Start subprocess & Read output
algo::Fildes command::apm_StartRead(command::apm_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    apm_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.apm_proc.apm.Kill
// Kill subprocess and wait
void command::apm_Kill(command::apm_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        apm_Wait(parent);
    }
}

// --- command.apm_proc.apm.Wait
// Wait for subprocess to return
void command::apm_Wait(command::apm_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.apm_proc.apm.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::apm_Exec(command::apm_proc& parent) {
    apm_Start(parent);
    apm_Wait(parent);
    return parent.status;
}

// --- command.apm_proc.apm.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::apm_ExecX(command::apm_proc& parent) {
    int rc = apm_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",apm_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.apm_proc.apm.Execv
// Call execv()
// Call execv with specified parameters
int command::apm_Execv(command::apm_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    apm_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.apm_proc.apm.ToCmdline
algo::tempstr command::apm_ToCmdline(command::apm_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::apm_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.apm_proc.apm.ToArgv
// Form array from the command line
void command::apm_ToArgv(command::apm_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.pkgdata != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pkgdata:";
        cstring_Print(parent.cmd.pkgdata, *arg);
    }

    if (parent.cmd.package.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-package:";
        command::package_Print(parent.cmd, *arg);
    }

    if (parent.cmd.ns.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ns:";
        command::ns_Print(parent.cmd, *arg);
    }

    if (parent.cmd.install != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-install:";
        bool_Print(parent.cmd.install, *arg);
    }

    if (parent.cmd.update != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-update:";
        bool_Print(parent.cmd.update, *arg);
    }

    if (parent.cmd.list != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-list:";
        bool_Print(parent.cmd.list, *arg);
    }

    if (parent.cmd.diff != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-diff:";
        bool_Print(parent.cmd.diff, *arg);
    }

    if (parent.cmd.push != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-push:";
        bool_Print(parent.cmd.push, *arg);
    }

    if (parent.cmd.check != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check:";
        bool_Print(parent.cmd.check, *arg);
    }

    if (parent.cmd.remove != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-remove:";
        bool_Print(parent.cmd.remove, *arg);
    }

    if (parent.cmd.origin != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-origin:";
        Smallstr200_Print(parent.cmd.origin, *arg);
    }

    if (parent.cmd.ref != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ref:";
        Smallstr50_Print(parent.cmd.ref, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }

    if (parent.cmd.showrec != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showrec:";
        bool_Print(parent.cmd.showrec, *arg);
    }

    if (parent.cmd.showfile != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showfile:";
        bool_Print(parent.cmd.showfile, *arg);
    }

    if (parent.cmd.R != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-R:";
        bool_Print(parent.cmd.R, *arg);
    }

    if (parent.cmd.l != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-l:";
        bool_Print(parent.cmd.l, *arg);
    }

    if (parent.cmd.reset != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-reset:";
        bool_Print(parent.cmd.reset, *arg);
    }

    if (parent.cmd.checkclean != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-checkclean:";
        bool_Print(parent.cmd.checkclean, *arg);
    }

    if (parent.cmd.t != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-t:";
        bool_Print(parent.cmd.t, *arg);
    }

    if (parent.cmd.stat != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-stat:";
        bool_Print(parent.cmd.stat, *arg);
    }

    if (parent.cmd.annotate != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-annotate:";
        cstring_Print(parent.cmd.annotate, *arg);
    }

    if (parent.cmd.data_in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data_in:";
        cstring_Print(parent.cmd.data_in, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.binpath != "bin") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-binpath:";
        cstring_Print(parent.cmd.binpath, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.apm_proc..Uninit
void command::apm_proc_Uninit(command::apm_proc& parent) {
    command::apm_proc &row = parent; (void)row;

    // command.apm_proc.apm.Uninit (Exec)  //
    apm_Kill(parent); // kill child, ensure forward progress
}

// --- command.aqlite..ReadFieldMaybe
bool command::aqlite_ReadFieldMaybe(command::aqlite& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_data: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data, strval);
            break;
        }
        case command_FieldId_cmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.aqlite..ReadTupleMaybe
// Read fields of command::aqlite from attributes of ascii tuple TUPLE
bool command::aqlite_ReadTupleMaybe(command::aqlite &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = aqlite_GetAnon(parent, anon_idx++);
        }
        retval = aqlite_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.aqlite..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::aqlite_ToCmdline(command::aqlite& row) {
    tempstr ret;
    ret << "bin/aqlite ";
    aqlite_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.aqlite..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.aqlite.Argv  printfmt:Tuple
void command::aqlite_PrintArgv(command::aqlite& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data, temp);
        str << " -data:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.cmd, temp);
    str << " -cmd:";
    strptr_PrintBash(temp,str);
}

// --- command.aqlite..GetAnon
algo::strptr command::aqlite_GetAnon(command::aqlite &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("cmd", 3);
        default: return algo::strptr();
    }
}

// --- command.aqlite..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::aqlite_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_data: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_cmd: { // $comment
            *out_anon = true;
        } break;
        default:
        retval=-1; // unrecognized
    }
    (void)out_dflt;//only to avoid -Wunused-parameter
    return retval;
}

// --- command.aqlite_proc.aqlite.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::aqlite_Start(command::aqlite_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(aqlite_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(aqlite_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= aqlite_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.aqlite_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.aqlite_proc.aqlite.StartRead
// Start subprocess & Read output
algo::Fildes command::aqlite_StartRead(command::aqlite_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    aqlite_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.aqlite_proc.aqlite.Kill
// Kill subprocess and wait
void command::aqlite_Kill(command::aqlite_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        aqlite_Wait(parent);
    }
}

// --- command.aqlite_proc.aqlite.Wait
// Wait for subprocess to return
void command::aqlite_Wait(command::aqlite_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.aqlite_proc.aqlite.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::aqlite_Exec(command::aqlite_proc& parent) {
    aqlite_Start(parent);
    aqlite_Wait(parent);
    return parent.status;
}

// --- command.aqlite_proc.aqlite.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::aqlite_ExecX(command::aqlite_proc& parent) {
    int rc = aqlite_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",aqlite_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.aqlite_proc.aqlite.Execv
// Call execv()
// Call execv with specified parameters
int command::aqlite_Execv(command::aqlite_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    aqlite_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.aqlite_proc.aqlite.ToCmdline
algo::tempstr command::aqlite_ToCmdline(command::aqlite_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::aqlite_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.aqlite_proc.aqlite.ToArgv
// Form array from the command line
void command::aqlite_ToArgv(command::aqlite_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.data != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data:";
        cstring_Print(parent.cmd.data, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmd:";
        cstring_Print(parent.cmd.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.aqlite_proc..Uninit
void command::aqlite_proc_Uninit(command::aqlite_proc& parent) {
    command::aqlite_proc &row = parent; (void)row;

    // command.aqlite_proc.aqlite.Uninit (Exec)  //
    aqlite_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_amc.amctest.Print
// Print back to string
void command::amctest_Print(command::atf_amc& parent, algo::cstring &out) {
    Regx_Print(parent.amctest, out);
}

// --- command.atf_amc.amctest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::amctest_ReadStrptrMaybe(command::atf_amc& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.amctest, in, true);
    return retval;
}

// --- command.atf_amc..ReadFieldMaybe
bool command::atf_amc_ReadFieldMaybe(command::atf_amc& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_amctest: {
            retval = amctest_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_dofork: {
            retval = bool_ReadStrptrMaybe(parent.dofork, strval);
            break;
        }
        case command_FieldId_q: {
            retval = bool_ReadStrptrMaybe(parent.q, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_amc..ReadTupleMaybe
// Read fields of command::atf_amc from attributes of ascii tuple TUPLE
bool command::atf_amc_ReadTupleMaybe(command::atf_amc &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_amc_GetAnon(parent, anon_idx++);
        }
        retval = atf_amc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_amc..Init
// Set all fields to initial values.
void command::atf_amc_Init(command::atf_amc& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.amctest, "%", true);
    parent.dofork = bool(true);
    parent.q = bool(false);
}

// --- command.atf_amc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_amc_ToCmdline(command::atf_amc& row) {
    tempstr ret;
    ret << "bin/atf_amc ";
    atf_amc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_amc..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_amc.Argv  printfmt:Tuple
void command::atf_amc_PrintArgv(command::atf_amc& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::amctest_Print(const_cast<command::atf_amc&>(row), temp);
    str << " -amctest:";
    strptr_PrintBash(temp,str);
    if (!(row.dofork == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.dofork, temp);
        str << " -dofork:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.q == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.q, temp);
        str << " -q:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_amc..GetAnon
algo::strptr command::atf_amc_GetAnon(command::atf_amc &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("amctest", 7);
        default: return algo::strptr();
    }
}

// --- command.atf_amc..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_amc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_amctest: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_dofork: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_q: { // bool: no argument required but value may be specified as dofork:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_amc_proc.atf_amc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_amc_Start(command::atf_amc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_amc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_amc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_amc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_amc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_amc_proc.atf_amc.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_amc_StartRead(command::atf_amc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_amc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_amc_proc.atf_amc.Kill
// Kill subprocess and wait
void command::atf_amc_Kill(command::atf_amc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_amc_Wait(parent);
    }
}

// --- command.atf_amc_proc.atf_amc.Wait
// Wait for subprocess to return
void command::atf_amc_Wait(command::atf_amc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_amc_proc.atf_amc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_amc_Exec(command::atf_amc_proc& parent) {
    atf_amc_Start(parent);
    atf_amc_Wait(parent);
    return parent.status;
}

// --- command.atf_amc_proc.atf_amc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_amc_ExecX(command::atf_amc_proc& parent) {
    int rc = atf_amc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_amc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_amc_proc.atf_amc.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_amc_Execv(command::atf_amc_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_amc_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_amc_proc.atf_amc.ToCmdline
algo::tempstr command::atf_amc_ToCmdline(command::atf_amc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_amc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_amc_proc.atf_amc.ToArgv
// Form array from the command line
void command::atf_amc_ToArgv(command::atf_amc_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.amctest.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-amctest:";
        command::amctest_Print(parent.cmd, *arg);
    }

    if (parent.cmd.dofork != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dofork:";
        bool_Print(parent.cmd.dofork, *arg);
    }

    if (parent.cmd.q != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-q:";
        bool_Print(parent.cmd.q, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_amc_proc..Uninit
void command::atf_amc_proc_Uninit(command::atf_amc_proc& parent) {
    command::atf_amc_proc &row = parent; (void)row;

    // command.atf_amc_proc.atf_amc.Uninit (Exec)  //
    atf_amc_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_ci.citest.Print
// Print back to string
void command::citest_Print(command::atf_ci& parent, algo::cstring &out) {
    Regx_Print(parent.citest, out);
}

// --- command.atf_ci.citest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::citest_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.citest, in, true);
    return retval;
}

// --- command.atf_ci.cijob.Print
// Print back to string
void command::cijob_Print(command::atf_ci& parent, algo::cstring &out) {
    Regx_Print(parent.cijob, out);
}

// --- command.atf_ci.cijob.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::cijob_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.cijob, in, true);
    return retval;
}

// --- command.atf_ci..ReadFieldMaybe
bool command::atf_ci_ReadFieldMaybe(command::atf_ci& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_citest: {
            retval = citest_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_maxerr: {
            retval = i32_ReadStrptrMaybe(parent.maxerr, strval);
            break;
        }
        case command_FieldId_cijob: {
            retval = cijob_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_ci..ReadTupleMaybe
// Read fields of command::atf_ci from attributes of ascii tuple TUPLE
bool command::atf_ci_ReadTupleMaybe(command::atf_ci &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_ci_GetAnon(parent, anon_idx++);
        }
        retval = atf_ci_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_ci..Init
// Set all fields to initial values.
void command::atf_ci_Init(command::atf_ci& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.citest, "%", true);
    parent.maxerr = i32(0);
    Regx_ReadSql(parent.cijob, "%", true);
    parent.capture = bool(false);
}

// --- command.atf_ci..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_ci_ToCmdline(command::atf_ci& row) {
    tempstr ret;
    ret << "bin/atf_ci ";
    atf_ci_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_ci..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_ci.Argv  printfmt:Tuple
void command::atf_ci_PrintArgv(command::atf_ci& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::citest_Print(const_cast<command::atf_ci&>(row), temp);
    str << " -citest:";
    strptr_PrintBash(temp,str);
    if (!(row.maxerr == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxerr, temp);
        str << " -maxerr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cijob.expr == "%")) {
        ch_RemoveAll(temp);
        command::cijob_Print(const_cast<command::atf_ci&>(row), temp);
        str << " -cijob:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_ci..GetAnon
algo::strptr command::atf_ci_GetAnon(command::atf_ci &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("citest", 6);
        default: return algo::strptr();
    }
}

// --- command.atf_ci..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_ci_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_citest: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_maxerr: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_cijob: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_capture: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_ci_proc.atf_ci.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_ci_Start(command::atf_ci_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_ci_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_ci_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_ci_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_ci_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_ci_proc.atf_ci.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_ci_StartRead(command::atf_ci_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_ci_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_ci_proc.atf_ci.Kill
// Kill subprocess and wait
void command::atf_ci_Kill(command::atf_ci_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_ci_Wait(parent);
    }
}

// --- command.atf_ci_proc.atf_ci.Wait
// Wait for subprocess to return
void command::atf_ci_Wait(command::atf_ci_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_ci_proc.atf_ci.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_ci_Exec(command::atf_ci_proc& parent) {
    atf_ci_Start(parent);
    atf_ci_Wait(parent);
    return parent.status;
}

// --- command.atf_ci_proc.atf_ci.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_ci_ExecX(command::atf_ci_proc& parent) {
    int rc = atf_ci_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_ci_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_ci_proc.atf_ci.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_ci_Execv(command::atf_ci_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_ci_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_ci_proc.atf_ci.ToCmdline
algo::tempstr command::atf_ci_ToCmdline(command::atf_ci_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_ci_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_ci_proc.atf_ci.ToArgv
// Form array from the command line
void command::atf_ci_ToArgv(command::atf_ci_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.citest.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-citest:";
        command::citest_Print(parent.cmd, *arg);
    }

    if (parent.cmd.maxerr != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxerr:";
        i32_Print(parent.cmd.maxerr, *arg);
    }

    if (parent.cmd.cijob.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cijob:";
        command::cijob_Print(parent.cmd, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_ci_proc..Uninit
void command::atf_ci_proc_Uninit(command::atf_ci_proc& parent) {
    command::atf_ci_proc &row = parent; (void)row;

    // command.atf_ci_proc.atf_ci.Uninit (Exec)  //
    atf_ci_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_cmdline.mstr.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::mstr_Addary(command::atf_cmdline& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.mstr_elems && rhs.elems < parent.mstr_elems + parent.mstr_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.atf_cmdline.mstr  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    mstr_Reserve(parent, nnew); // reserve space
    int at = parent.mstr_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.mstr_elems + at + i) algo::cstring(rhs[i]);
        parent.mstr_n++;
    }
    return algo::aryptr<algo::cstring>(parent.mstr_elems + at, nnew);
}

// --- command.atf_cmdline.mstr.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::mstr_Alloc(command::atf_cmdline& parent) {
    mstr_Reserve(parent, 1);
    int n  = parent.mstr_n;
    int at = n;
    algo::cstring *elems = parent.mstr_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.mstr_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mstr.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::mstr_AllocAt(command::atf_cmdline& parent, int at) {
    mstr_Reserve(parent, 1);
    int n  = parent.mstr_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.atf_cmdline.mstr  comment:'index out of range'");
    }
    algo::cstring *elems = parent.mstr_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.mstr_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mstr.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::mstr_AllocN(command::atf_cmdline& parent, int n_elems) {
    mstr_Reserve(parent, n_elems);
    int old_n  = parent.mstr_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.mstr_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.mstr_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mstr.Remove
// Remove item by index. If index outside of range, do nothing.
void command::mstr_Remove(command::atf_cmdline& parent, u32 i) {
    u32 lim = parent.mstr_n;
    algo::cstring *elems = parent.mstr_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.mstr_n = lim - 1;
    }
}

// --- command.atf_cmdline.mstr.RemoveAll
void command::mstr_RemoveAll(command::atf_cmdline& parent) {
    u32 n = parent.mstr_n;
    while (n > 0) {
        n -= 1;
        parent.mstr_elems[n].~cstring();
        parent.mstr_n = n;
    }
}

// --- command.atf_cmdline.mstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::mstr_RemoveLast(command::atf_cmdline& parent) {
    u64 n = parent.mstr_n;
    if (n > 0) {
        n -= 1;
        mstr_qFind(parent, u64(n)).~cstring();
        parent.mstr_n = n;
    }
}

// --- command.atf_cmdline.mstr.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::mstr_AbsReserve(command::atf_cmdline& parent, int n) {
    u32 old_max  = parent.mstr_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.mstr_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.atf_cmdline.mstr  comment:'out of memory'");
        }
        parent.mstr_elems = (algo::cstring*)new_mem;
        parent.mstr_max = new_max;
    }
}

// --- command.atf_cmdline.mstr.Setary
// Copy contents of RHS to PARENT.
void command::mstr_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) {
    mstr_RemoveAll(parent);
    int nnew = rhs.mstr_n;
    mstr_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.mstr_elems + i) algo::cstring(mstr_qFind(rhs, i));
        parent.mstr_n = i + 1;
    }
}

// --- command.atf_cmdline.mstr.Setary2
// Copy specified array into mstr, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::mstr_Setary(command::atf_cmdline& parent, const algo::aryptr<algo::cstring> &rhs) {
    mstr_RemoveAll(parent);
    mstr_Addary(parent, rhs);
}

// --- command.atf_cmdline.mstr.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::mstr_AllocNVal(command::atf_cmdline& parent, int n_elems, const algo::cstring& val) {
    mstr_Reserve(parent, n_elems);
    int old_n  = parent.mstr_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.mstr_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.mstr_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mstr.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::mstr_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = mstr_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        mstr_RemoveLast(parent);
    }
    return retval;
}

// --- command.atf_cmdline.mnum.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<i32> command::mnum_Addary(command::atf_cmdline& parent, algo::aryptr<i32> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.mnum_elems && rhs.elems < parent.mnum_elems + parent.mnum_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.atf_cmdline.mnum  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    mnum_Reserve(parent, nnew); // reserve space
    int at = parent.mnum_n;
    memcpy(parent.mnum_elems + at, rhs.elems, nnew * sizeof(i32));
    parent.mnum_n += nnew;
    return algo::aryptr<i32>(parent.mnum_elems + at, nnew);
}

// --- command.atf_cmdline.mnum.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& command::mnum_Alloc(command::atf_cmdline& parent) {
    mnum_Reserve(parent, 1);
    int n  = parent.mnum_n;
    int at = n;
    i32 *elems = parent.mnum_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    parent.mnum_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mnum.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& command::mnum_AllocAt(command::atf_cmdline& parent, int at) {
    mnum_Reserve(parent, 1);
    int n  = parent.mnum_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.atf_cmdline.mnum  comment:'index out of range'");
    }
    i32 *elems = parent.mnum_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    parent.mnum_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mnum.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> command::mnum_AllocN(command::atf_cmdline& parent, int n_elems) {
    mnum_Reserve(parent, n_elems);
    int old_n  = parent.mnum_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.mnum_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    parent.mnum_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mnum.Remove
// Remove item by index. If index outside of range, do nothing.
void command::mnum_Remove(command::atf_cmdline& parent, u32 i) {
    u32 lim = parent.mnum_n;
    i32 *elems = parent.mnum_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        parent.mnum_n = lim - 1;
    }
}

// --- command.atf_cmdline.mnum.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::mnum_RemoveLast(command::atf_cmdline& parent) {
    u64 n = parent.mnum_n;
    if (n > 0) {
        n -= 1;
        parent.mnum_n = n;
    }
}

// --- command.atf_cmdline.mnum.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::mnum_AbsReserve(command::atf_cmdline& parent, int n) {
    u32 old_max  = parent.mnum_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.mnum_elems, old_max * sizeof(i32), new_max * sizeof(i32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.atf_cmdline.mnum  comment:'out of memory'");
        }
        parent.mnum_elems = (i32*)new_mem;
        parent.mnum_max = new_max;
    }
}

// --- command.atf_cmdline.mnum.Setary
// Copy contents of RHS to PARENT.
void command::mnum_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) {
    mnum_RemoveAll(parent);
    int nnew = rhs.mnum_n;
    mnum_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.mnum_elems + i) i32(mnum_qFind(rhs, i));
        parent.mnum_n = i + 1;
    }
}

// --- command.atf_cmdline.mnum.Setary2
// Copy specified array into mnum, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::mnum_Setary(command::atf_cmdline& parent, const algo::aryptr<i32> &rhs) {
    mnum_RemoveAll(parent);
    mnum_Addary(parent, rhs);
}

// --- command.atf_cmdline.mnum.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> command::mnum_AllocNVal(command::atf_cmdline& parent, int n_elems, const i32& val) {
    mnum_Reserve(parent, n_elems);
    int old_n  = parent.mnum_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.mnum_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(val);
    }
    parent.mnum_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mnum.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::mnum_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) {
    bool retval = true;
    i32 &elem = mnum_Alloc(parent);
    retval = i32_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        mnum_RemoveLast(parent);
    }
    return retval;
}

// --- command.atf_cmdline.mdbl.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<double> command::mdbl_Addary(command::atf_cmdline& parent, algo::aryptr<double> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.mdbl_elems && rhs.elems < parent.mdbl_elems + parent.mdbl_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.atf_cmdline.mdbl  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    mdbl_Reserve(parent, nnew); // reserve space
    int at = parent.mdbl_n;
    memcpy(parent.mdbl_elems + at, rhs.elems, nnew * sizeof(double));
    parent.mdbl_n += nnew;
    return algo::aryptr<double>(parent.mdbl_elems + at, nnew);
}

// --- command.atf_cmdline.mdbl.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
double& command::mdbl_Alloc(command::atf_cmdline& parent) {
    mdbl_Reserve(parent, 1);
    int n  = parent.mdbl_n;
    int at = n;
    double *elems = parent.mdbl_elems;
    new (elems + at) double(0.0); // construct new element, default initializer
    parent.mdbl_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mdbl.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
double& command::mdbl_AllocAt(command::atf_cmdline& parent, int at) {
    mdbl_Reserve(parent, 1);
    int n  = parent.mdbl_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.atf_cmdline.mdbl  comment:'index out of range'");
    }
    double *elems = parent.mdbl_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(double));
    new (elems + at) double(0.0); // construct element, default initializer
    parent.mdbl_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.mdbl.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<double> command::mdbl_AllocN(command::atf_cmdline& parent, int n_elems) {
    mdbl_Reserve(parent, n_elems);
    int old_n  = parent.mdbl_n;
    int new_n = old_n + n_elems;
    double *elems = parent.mdbl_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) double(0.0); // construct new element, default initialize
    }
    parent.mdbl_n = new_n;
    return algo::aryptr<double>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mdbl.Remove
// Remove item by index. If index outside of range, do nothing.
void command::mdbl_Remove(command::atf_cmdline& parent, u32 i) {
    u32 lim = parent.mdbl_n;
    double *elems = parent.mdbl_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(double) * (lim - (i + 1)));
        parent.mdbl_n = lim - 1;
    }
}

// --- command.atf_cmdline.mdbl.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::mdbl_RemoveLast(command::atf_cmdline& parent) {
    u64 n = parent.mdbl_n;
    if (n > 0) {
        n -= 1;
        parent.mdbl_n = n;
    }
}

// --- command.atf_cmdline.mdbl.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::mdbl_AbsReserve(command::atf_cmdline& parent, int n) {
    u32 old_max  = parent.mdbl_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.mdbl_elems, old_max * sizeof(double), new_max * sizeof(double));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.atf_cmdline.mdbl  comment:'out of memory'");
        }
        parent.mdbl_elems = (double*)new_mem;
        parent.mdbl_max = new_max;
    }
}

// --- command.atf_cmdline.mdbl.Setary
// Copy contents of RHS to PARENT.
void command::mdbl_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) {
    mdbl_RemoveAll(parent);
    int nnew = rhs.mdbl_n;
    mdbl_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.mdbl_elems + i) double(mdbl_qFind(rhs, i));
        parent.mdbl_n = i + 1;
    }
}

// --- command.atf_cmdline.mdbl.Setary2
// Copy specified array into mdbl, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::mdbl_Setary(command::atf_cmdline& parent, const algo::aryptr<double> &rhs) {
    mdbl_RemoveAll(parent);
    mdbl_Addary(parent, rhs);
}

// --- command.atf_cmdline.mdbl.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<double> command::mdbl_AllocNVal(command::atf_cmdline& parent, int n_elems, const double& val) {
    mdbl_Reserve(parent, n_elems);
    int old_n  = parent.mdbl_n;
    int new_n = old_n + n_elems;
    double *elems = parent.mdbl_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) double(val);
    }
    parent.mdbl_n = new_n;
    return algo::aryptr<double>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.mdbl.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::mdbl_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) {
    bool retval = true;
    double &elem = mdbl_Alloc(parent);
    retval = double_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        mdbl_RemoveLast(parent);
    }
    return retval;
}

// --- command.atf_cmdline.amnum.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<i32> command::amnum_Addary(command::atf_cmdline& parent, algo::aryptr<i32> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.amnum_elems && rhs.elems < parent.amnum_elems + parent.amnum_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.atf_cmdline.amnum  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    amnum_Reserve(parent, nnew); // reserve space
    int at = parent.amnum_n;
    memcpy(parent.amnum_elems + at, rhs.elems, nnew * sizeof(i32));
    parent.amnum_n += nnew;
    return algo::aryptr<i32>(parent.amnum_elems + at, nnew);
}

// --- command.atf_cmdline.amnum.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32& command::amnum_Alloc(command::atf_cmdline& parent) {
    amnum_Reserve(parent, 1);
    int n  = parent.amnum_n;
    int at = n;
    i32 *elems = parent.amnum_elems;
    new (elems + at) i32(0); // construct new element, default initializer
    parent.amnum_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.amnum.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32& command::amnum_AllocAt(command::atf_cmdline& parent, int at) {
    amnum_Reserve(parent, 1);
    int n  = parent.amnum_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.atf_cmdline.amnum  comment:'index out of range'");
    }
    i32 *elems = parent.amnum_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(i32));
    new (elems + at) i32(0); // construct element, default initializer
    parent.amnum_n = n+1;
    return elems[at];
}

// --- command.atf_cmdline.amnum.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> command::amnum_AllocN(command::atf_cmdline& parent, int n_elems) {
    amnum_Reserve(parent, n_elems);
    int old_n  = parent.amnum_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.amnum_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(0); // construct new element, default initialize
    }
    parent.amnum_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.amnum.Remove
// Remove item by index. If index outside of range, do nothing.
void command::amnum_Remove(command::atf_cmdline& parent, u32 i) {
    u32 lim = parent.amnum_n;
    i32 *elems = parent.amnum_elems;
    if (i < lim) {
        memmove(elems + i, elems + (i + 1), sizeof(i32) * (lim - (i + 1)));
        parent.amnum_n = lim - 1;
    }
}

// --- command.atf_cmdline.amnum.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::amnum_RemoveLast(command::atf_cmdline& parent) {
    u64 n = parent.amnum_n;
    if (n > 0) {
        n -= 1;
        parent.amnum_n = n;
    }
}

// --- command.atf_cmdline.amnum.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::amnum_AbsReserve(command::atf_cmdline& parent, int n) {
    u32 old_max  = parent.amnum_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.amnum_elems, old_max * sizeof(i32), new_max * sizeof(i32));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.atf_cmdline.amnum  comment:'out of memory'");
        }
        parent.amnum_elems = (i32*)new_mem;
        parent.amnum_max = new_max;
    }
}

// --- command.atf_cmdline.amnum.Setary
// Copy contents of RHS to PARENT.
void command::amnum_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) {
    amnum_RemoveAll(parent);
    int nnew = rhs.amnum_n;
    amnum_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.amnum_elems + i) i32(amnum_qFind(rhs, i));
        parent.amnum_n = i + 1;
    }
}

// --- command.atf_cmdline.amnum.Setary2
// Copy specified array into amnum, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::amnum_Setary(command::atf_cmdline& parent, const algo::aryptr<i32> &rhs) {
    amnum_RemoveAll(parent);
    amnum_Addary(parent, rhs);
}

// --- command.atf_cmdline.amnum.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32> command::amnum_AllocNVal(command::atf_cmdline& parent, int n_elems, const i32& val) {
    amnum_Reserve(parent, n_elems);
    int old_n  = parent.amnum_n;
    int new_n = old_n + n_elems;
    i32 *elems = parent.amnum_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) i32(val);
    }
    parent.amnum_n = new_n;
    return algo::aryptr<i32>(elems + old_n, n_elems);
}

// --- command.atf_cmdline.amnum.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::amnum_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) {
    bool retval = true;
    i32 &elem = amnum_Alloc(parent);
    retval = i32_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        amnum_RemoveLast(parent);
    }
    return retval;
}

// --- command.atf_cmdline.fconst.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::fconst_ToCstr(const command::atf_cmdline& parent) {
    const char *ret = NULL;
    switch(fconst_GetEnum(parent)) {
        case command_atf_cmdline_fconst_high: ret = "high";  break;
        case command_atf_cmdline_fconst_medium: ret = "medium";  break;
        case command_atf_cmdline_fconst_low: ret = "low";  break;
    }
    return ret;
}

// --- command.atf_cmdline.fconst.Print
// Convert fconst to a string. First, attempt conversion to a known string.
// If no string matches, print fconst as a numeric value.
void command::fconst_Print(const command::atf_cmdline& parent, algo::cstring &lhs) {
    const char *strval = fconst_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.fconst;
    }
}

// --- command.atf_cmdline.fconst.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::fconst_SetStrptrMaybe(command::atf_cmdline& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('l','o','w'): {
                    fconst_SetEnum(parent,command_atf_cmdline_fconst_low); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('h','i','g','h'): {
                    fconst_SetEnum(parent,command_atf_cmdline_fconst_high); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('m','e','d','i','u','m'): {
                    fconst_SetEnum(parent,command_atf_cmdline_fconst_medium); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.atf_cmdline.fconst.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::fconst_SetStrptr(command::atf_cmdline& parent, algo::strptr rhs, command_atf_cmdline_fconst_Enum dflt) {
    if (!fconst_SetStrptrMaybe(parent,rhs)) fconst_SetEnum(parent,dflt);
}

// --- command.atf_cmdline.fconst.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::fconst_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr rhs) {
    bool retval = false;
    retval = fconst_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.fconst,rhs);
    }
    return retval;
}

// --- command.atf_cmdline.dregx.Print
// Print back to string
void command::dregx_Print(command::atf_cmdline& parent, algo::cstring &out) {
    Regx_Print(parent.dregx, out);
}

// --- command.atf_cmdline.dregx.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::dregx_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.dregx, in, true);
    return retval;
}

// --- command.atf_cmdline..ReadFieldMaybe
bool command::atf_cmdline_ReadFieldMaybe(command::atf_cmdline& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_exec: {
            retval = bool_ReadStrptrMaybe(parent.exec, strval);
            break;
        }
        case command_FieldId_astr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.astr, strval);
            break;
        }
        case command_FieldId_anum: {
            retval = i32_ReadStrptrMaybe(parent.anum, strval);
            break;
        }
        case command_FieldId_adbl: {
            retval = double_ReadStrptrMaybe(parent.adbl, strval);
            break;
        }
        case command_FieldId_aflag: {
            retval = bool_ReadStrptrMaybe(parent.aflag, strval);
            break;
        }
        case command_FieldId_str: {
            retval = algo::cstring_ReadStrptrMaybe(parent.str, strval);
            break;
        }
        case command_FieldId_num: {
            retval = i32_ReadStrptrMaybe(parent.num, strval);
            break;
        }
        case command_FieldId_dbl: {
            retval = double_ReadStrptrMaybe(parent.dbl, strval);
            break;
        }
        case command_FieldId_flag: {
            retval = bool_ReadStrptrMaybe(parent.flag, strval);
            break;
        }
        case command_FieldId_dstr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.dstr, strval);
            break;
        }
        case command_FieldId_dnum: {
            retval = i32_ReadStrptrMaybe(parent.dnum, strval);
            break;
        }
        case command_FieldId_ddbl: {
            retval = double_ReadStrptrMaybe(parent.ddbl, strval);
            break;
        }
        case command_FieldId_dflag: {
            retval = bool_ReadStrptrMaybe(parent.dflag, strval);
            break;
        }
        case command_FieldId_mstr: {
            retval = mstr_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_mnum: {
            retval = mnum_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_mdbl: {
            retval = mdbl_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_amnum: {
            retval = amnum_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_fconst: {
            retval = fconst_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_cconst: {
            retval = algo::Month_ReadStrptrMaybe(parent.cconst, strval);
            break;
        }
        case command_FieldId_dregx: {
            retval = dregx_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_dpkey: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.dpkey, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_cmdline..ReadTupleMaybe
// Read fields of command::atf_cmdline from attributes of ascii tuple TUPLE
bool command::atf_cmdline_ReadTupleMaybe(command::atf_cmdline &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_cmdline_GetAnon(parent, anon_idx++);
        }
        retval = atf_cmdline_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_cmdline..Init
// Set all fields to initial values.
void command::atf_cmdline_Init(command::atf_cmdline& parent) {
    parent.in = algo::strptr("data");
    parent.exec = bool(false);
    parent.anum = i32(0);
    parent.adbl = double(0.0);
    parent.aflag = bool(false);
    parent.num = i32(0);
    parent.dbl = double(0.0);
    parent.flag = bool(false);
    parent.dstr = algo::strptr("blah");
    parent.dnum = i32(-33);
    parent.ddbl = double(0.0001);
    parent.dflag = bool(true);
    parent.mstr_elems 	= 0; // (command.atf_cmdline.mstr)
    parent.mstr_n     	= 0; // (command.atf_cmdline.mstr)
    parent.mstr_max   	= 0; // (command.atf_cmdline.mstr)
    parent.mnum_elems 	= 0; // (command.atf_cmdline.mnum)
    parent.mnum_n     	= 0; // (command.atf_cmdline.mnum)
    parent.mnum_max   	= 0; // (command.atf_cmdline.mnum)
    parent.mdbl_elems 	= 0; // (command.atf_cmdline.mdbl)
    parent.mdbl_n     	= 0; // (command.atf_cmdline.mdbl)
    parent.mdbl_max   	= 0; // (command.atf_cmdline.mdbl)
    parent.amnum_elems 	= 0; // (command.atf_cmdline.amnum)
    parent.amnum_n     	= 0; // (command.atf_cmdline.amnum)
    parent.amnum_max   	= 0; // (command.atf_cmdline.amnum)
    parent.fconst = u8(0);
    Regx_ReadSql(parent.dregx, "%", true);
    parent.dpkey = algo::strptr("");
}

// --- command.atf_cmdline..Uninit
void command::atf_cmdline_Uninit(command::atf_cmdline& parent) {
    command::atf_cmdline &row = parent; (void)row;

    // command.atf_cmdline.amnum.Uninit (Tary)  //Anon number array
    // remove all elements from command.atf_cmdline.amnum
    amnum_RemoveAll(parent);
    // free memory for Tary command.atf_cmdline.amnum
    algo_lib::malloc_FreeMem(parent.amnum_elems, sizeof(i32)*parent.amnum_max); // (command.atf_cmdline.amnum)

    // command.atf_cmdline.mdbl.Uninit (Tary)  //Double array
    // remove all elements from command.atf_cmdline.mdbl
    mdbl_RemoveAll(parent);
    // free memory for Tary command.atf_cmdline.mdbl
    algo_lib::malloc_FreeMem(parent.mdbl_elems, sizeof(double)*parent.mdbl_max); // (command.atf_cmdline.mdbl)

    // command.atf_cmdline.mnum.Uninit (Tary)  //Number array
    // remove all elements from command.atf_cmdline.mnum
    mnum_RemoveAll(parent);
    // free memory for Tary command.atf_cmdline.mnum
    algo_lib::malloc_FreeMem(parent.mnum_elems, sizeof(i32)*parent.mnum_max); // (command.atf_cmdline.mnum)

    // command.atf_cmdline.mstr.Uninit (Tary)  //String array
    // remove all elements from command.atf_cmdline.mstr
    mstr_RemoveAll(parent);
    // free memory for Tary command.atf_cmdline.mstr
    algo_lib::malloc_FreeMem(parent.mstr_elems, sizeof(algo::cstring)*parent.mstr_max); // (command.atf_cmdline.mstr)
}

// --- command.atf_cmdline..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_cmdline_ToCmdline(command::atf_cmdline& row) {
    tempstr ret;
    ret << "bin/atf_cmdline ";
    atf_cmdline_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_cmdline..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_cmdline.Argv  printfmt:Tuple
void command::atf_cmdline_PrintArgv(command::atf_cmdline& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.exec == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.exec, temp);
        str << " -exec:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.astr, temp);
    str << " -astr:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    i32_Print(row.anum, temp);
    str << " -anum:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    double_Print(row.adbl, temp);
    str << " -adbl:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    bool_Print(row.aflag, temp);
    str << " -aflag:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    cstring_Print(row.str, temp);
    str << " -str:";
    strptr_PrintBash(temp,str);
    if (!(row.num == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.num, temp);
        str << " -num:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dbl == 0.0)) {
        ch_RemoveAll(temp);
        double_Print(row.dbl, temp);
        str << " -dbl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.flag == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.flag, temp);
        str << " -flag:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dstr == "blah")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dstr, temp);
        str << " -dstr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dnum == -33)) {
        ch_RemoveAll(temp);
        i32_Print(row.dnum, temp);
        str << " -dnum:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ddbl == 0.0001)) {
        ch_RemoveAll(temp);
        double_Print(row.ddbl, temp);
        str << " -ddbl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dflag == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.dflag, temp);
        str << " -dflag:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(atf_cmdline_mstr_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -mstr:";
        strptr_PrintBash(temp,str);
    }ind_end;
    ind_beg(atf_cmdline_mnum_curs,value,row) {
        ch_RemoveAll(temp);
        i32_Print(value, temp);
        str << " -mnum:";
        strptr_PrintBash(temp,str);
    }ind_end;
    ind_beg(atf_cmdline_mdbl_curs,value,row) {
        ch_RemoveAll(temp);
        double_Print(value, temp);
        str << " -mdbl:";
        strptr_PrintBash(temp,str);
    }ind_end;
    ind_beg(atf_cmdline_amnum_curs,value,row) {
        ch_RemoveAll(temp);
        i32_Print(value, temp);
        str << " -amnum:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.fconst == 0)) {
        ch_RemoveAll(temp);
        command::fconst_Print(const_cast<command::atf_cmdline&>(row), temp);
        str << " -fconst:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    Month_Print(row.cconst, temp);
    str << " -cconst:";
    strptr_PrintBash(temp,str);
    if (!(row.dregx.expr == "%")) {
        ch_RemoveAll(temp);
        command::dregx_Print(const_cast<command::atf_cmdline&>(row), temp);
        str << " -dregx:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dpkey == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.dpkey, temp);
        str << " -dpkey:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_cmdline..GetAnon
algo::strptr command::atf_cmdline_GetAnon(command::atf_cmdline &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("astr", 4);
        case(1): return strptr("anum", 4);
        case(2): return strptr("adbl", 4);
        case(3): return strptr("aflag", 5);
        default: return strptr("amnum", 5);
    }
}

// --- command.atf_cmdline..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_cmdline_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_exec: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_astr: { // bool: no argument required but value may be specified as exec:Y
            *out_anon = true;
        } break;
        case command_FieldId_anum: { // bool: no argument required but value may be specified as exec:Y
            *out_anon = true;
        } break;
        case command_FieldId_adbl: { // bool: no argument required but value may be specified as exec:Y
            *out_anon = true;
        } break;
        case command_FieldId_aflag: { // bool: no argument required but value may be specified as exec:Y
            *out_anon = true;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_str: { // bool: no argument required but value may be specified as aflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_num: { // bool: no argument required but value may be specified as aflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_dbl: { // bool: no argument required but value may be specified as aflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_flag: { // bool: no argument required but value may be specified as aflag:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dstr: { // bool: no argument required but value may be specified as flag:Y
            *out_anon = false;
        } break;
        case command_FieldId_dnum: { // bool: no argument required but value may be specified as flag:Y
            *out_anon = false;
        } break;
        case command_FieldId_ddbl: { // bool: no argument required but value may be specified as flag:Y
            *out_anon = false;
        } break;
        case command_FieldId_dflag: { // bool: no argument required but value may be specified as flag:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_mstr: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_mnum: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_mdbl: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_amnum: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = true;
        } break;
        case command_FieldId_fconst: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_cconst: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_dregx: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        case command_FieldId_dpkey: { // bool: no argument required but value may be specified as dflag:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_cmdline_proc.atf_cmdline.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_cmdline_Start(command::atf_cmdline_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_cmdline_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_cmdline_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_cmdline_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_cmdline_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_cmdline_proc.atf_cmdline.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_cmdline_StartRead(command::atf_cmdline_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_cmdline_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_cmdline_proc.atf_cmdline.Kill
// Kill subprocess and wait
void command::atf_cmdline_Kill(command::atf_cmdline_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_cmdline_Wait(parent);
    }
}

// --- command.atf_cmdline_proc.atf_cmdline.Wait
// Wait for subprocess to return
void command::atf_cmdline_Wait(command::atf_cmdline_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_cmdline_proc.atf_cmdline.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_cmdline_Exec(command::atf_cmdline_proc& parent) {
    atf_cmdline_Start(parent);
    atf_cmdline_Wait(parent);
    return parent.status;
}

// --- command.atf_cmdline_proc.atf_cmdline.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_cmdline_ExecX(command::atf_cmdline_proc& parent) {
    int rc = atf_cmdline_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_cmdline_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_cmdline_proc.atf_cmdline.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_cmdline_Execv(command::atf_cmdline_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_cmdline_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_cmdline_proc.atf_cmdline.ToCmdline
algo::tempstr command::atf_cmdline_ToCmdline(command::atf_cmdline_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_cmdline_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_cmdline_proc.atf_cmdline.ToArgv
// Form array from the command line
void command::atf_cmdline_ToArgv(command::atf_cmdline_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.exec != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-exec:";
        bool_Print(parent.cmd.exec, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-astr:";
        cstring_Print(parent.cmd.astr, *arg);
    }

    if (parent.cmd.anum != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-anum:";
        i32_Print(parent.cmd.anum, *arg);
    }

    if (parent.cmd.adbl != 0.0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-adbl:";
        double_Print(parent.cmd.adbl, *arg);
    }

    if (parent.cmd.aflag != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-aflag:";
        bool_Print(parent.cmd.aflag, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-str:";
        cstring_Print(parent.cmd.str, *arg);
    }

    if (parent.cmd.num != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-num:";
        i32_Print(parent.cmd.num, *arg);
    }

    if (parent.cmd.dbl != 0.0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dbl:";
        double_Print(parent.cmd.dbl, *arg);
    }

    if (parent.cmd.flag != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-flag:";
        bool_Print(parent.cmd.flag, *arg);
    }

    if (parent.cmd.dstr != "blah") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dstr:";
        cstring_Print(parent.cmd.dstr, *arg);
    }

    if (parent.cmd.dnum != -33) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dnum:";
        i32_Print(parent.cmd.dnum, *arg);
    }

    if (parent.cmd.ddbl != 0.0001) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ddbl:";
        double_Print(parent.cmd.ddbl, *arg);
    }

    if (parent.cmd.dflag != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dflag:";
        bool_Print(parent.cmd.dflag, *arg);
    }
    ind_beg(command::atf_cmdline_mstr_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mstr:";
        cstring_Print(value, *arg);
    }ind_end;
    ind_beg(command::atf_cmdline_mnum_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mnum:";
        i32_Print(value, *arg);
    }ind_end;
    ind_beg(command::atf_cmdline_mdbl_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mdbl:";
        double_Print(value, *arg);
    }ind_end;
    ind_beg(command::atf_cmdline_amnum_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-amnum:";
        i32_Print(value, *arg);
    }ind_end;

    if (parent.cmd.fconst != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fconst:";
        command::fconst_Print(parent.cmd, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cconst:";
        Month_Print(parent.cmd.cconst, *arg);
    }

    if (parent.cmd.dregx.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dregx:";
        command::dregx_Print(parent.cmd, *arg);
    }

    if (parent.cmd.dpkey != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dpkey:";
        Smallstr100_Print(parent.cmd.dpkey, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_cmdline_proc..Uninit
void command::atf_cmdline_proc_Uninit(command::atf_cmdline_proc& parent) {
    command::atf_cmdline_proc &row = parent; (void)row;

    // command.atf_cmdline_proc.atf_cmdline.Uninit (Exec)  //
    atf_cmdline_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_comp.comptest.Print
// Print back to string
void command::comptest_Print(command::atf_comp& parent, algo::cstring &out) {
    Regx_Print(parent.comptest, out);
}

// --- command.atf_comp.comptest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::comptest_ReadStrptrMaybe(command::atf_comp& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.comptest, in, true);
    return retval;
}

// --- command.atf_comp..ReadFieldMaybe
bool command::atf_comp_ReadFieldMaybe(command::atf_comp& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_comptest: {
            retval = comptest_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_mdbg: {
            retval = bool_ReadStrptrMaybe(parent.mdbg, strval);
            break;
        }
        case command_FieldId_run: {
            retval = bool_ReadStrptrMaybe(parent.run, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        case command_FieldId_print: {
            retval = bool_ReadStrptrMaybe(parent.print, strval);
            break;
        }
        case command_FieldId_printinput: {
            retval = bool_ReadStrptrMaybe(parent.printinput, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_normalize: {
            retval = bool_ReadStrptrMaybe(parent.normalize, strval);
            break;
        }
        case command_FieldId_covcapture: {
            retval = bool_ReadStrptrMaybe(parent.covcapture, strval);
            break;
        }
        case command_FieldId_covcheck: {
            retval = bool_ReadStrptrMaybe(parent.covcheck, strval);
            break;
        }
        case command_FieldId_compdir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.compdir, strval);
            break;
        }
        case command_FieldId_cfg: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval);
            break;
        }
        case command_FieldId_check_untracked: {
            retval = bool_ReadStrptrMaybe(parent.check_untracked, strval);
            break;
        }
        case command_FieldId_maxerr: {
            retval = i32_ReadStrptrMaybe(parent.maxerr, strval);
            break;
        }
        case command_FieldId_build: {
            retval = bool_ReadStrptrMaybe(parent.build, strval);
            break;
        }
        case command_FieldId_ood: {
            retval = bool_ReadStrptrMaybe(parent.ood, strval);
            break;
        }
        case command_FieldId_memcheck: {
            retval = bool_ReadStrptrMaybe(parent.memcheck, strval);
            break;
        }
        case command_FieldId_force: {
            retval = bool_ReadStrptrMaybe(parent.force, strval);
            break;
        }
        case command_FieldId_callgrind: {
            retval = bool_ReadStrptrMaybe(parent.callgrind, strval);
            break;
        }
        case command_FieldId_maxjobs: {
            retval = i32_ReadStrptrMaybe(parent.maxjobs, strval);
            break;
        }
        case command_FieldId_stream: {
            retval = bool_ReadStrptrMaybe(parent.stream, strval);
            break;
        }
        case command_FieldId_i: {
            retval = bool_ReadStrptrMaybe(parent.i, strval);
            break;
        }
        case command_FieldId_write: {
            retval = bool_ReadStrptrMaybe(parent.write, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_b: {
            retval = algo::cstring_ReadStrptrMaybe(parent.b, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_comp..ReadTupleMaybe
// Read fields of command::atf_comp from attributes of ascii tuple TUPLE
bool command::atf_comp_ReadTupleMaybe(command::atf_comp &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_comp_GetAnon(parent, anon_idx++);
        }
        retval = atf_comp_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_comp..Init
// Set all fields to initial values.
void command::atf_comp_Init(command::atf_comp& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.comptest, "%", true);
    parent.mdbg = bool(false);
    parent.run = bool(true);
    parent.capture = bool(false);
    parent.print = bool(false);
    parent.printinput = bool(false);
    parent.e = bool(false);
    parent.normalize = bool(false);
    parent.covcapture = bool(false);
    parent.covcheck = bool(false);
    parent.compdir = algo::strptr("");
    parent.cfg = algo::strptr("release");
    parent.check_untracked = bool(true);
    parent.maxerr = i32(1);
    parent.build = bool(false);
    parent.ood = bool(false);
    parent.memcheck = bool(false);
    parent.force = bool(false);
    parent.callgrind = bool(false);
    parent.maxjobs = i32(0);
    parent.stream = bool(false);
    parent.i = bool(false);
    parent.write = bool(true);
    parent.report = bool(false);
    parent.b = algo::strptr("");
}

// --- command.atf_comp..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_comp_ToCmdline(command::atf_comp& row) {
    tempstr ret;
    ret << "bin/atf_comp ";
    atf_comp_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_comp..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_comp.Argv  printfmt:Tuple
void command::atf_comp_PrintArgv(command::atf_comp& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::comptest_Print(const_cast<command::atf_comp&>(row), temp);
    str << " -comptest:";
    strptr_PrintBash(temp,str);
    if (!(row.mdbg == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.mdbg, temp);
        str << " -mdbg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.run == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.run, temp);
        str << " -run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.print == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.print, temp);
        str << " -print:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.printinput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.printinput, temp);
        str << " -printinput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.normalize == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.normalize, temp);
        str << " -normalize:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.covcapture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.covcapture, temp);
        str << " -covcapture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.covcheck == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.covcheck, temp);
        str << " -covcheck:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.compdir == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.compdir, temp);
        str << " -compdir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cfg == "release")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.cfg, temp);
        str << " -cfg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check_untracked == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.check_untracked, temp);
        str << " -check_untracked:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxerr == 1)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxerr, temp);
        str << " -maxerr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.build == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.build, temp);
        str << " -build:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ood == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ood, temp);
        str << " -ood:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.memcheck == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.memcheck, temp);
        str << " -memcheck:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.force == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.force, temp);
        str << " -force:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.callgrind == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.callgrind, temp);
        str << " -callgrind:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stream == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stream, temp);
        str << " -stream:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.i == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.i, temp);
        str << " -i:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.b == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.b, temp);
        str << " -b:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_comp..GetAnon
algo::strptr command::atf_comp_GetAnon(command::atf_comp &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("comptest", 8);
        default: return algo::strptr();
    }
}

// --- command.atf_comp..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_comp_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_comptest: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_mdbg: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_run: { // bool: no argument required but value may be specified as mdbg:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_capture: { // bool: no argument required but value may be specified as run:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_print: { // bool: no argument required but value may be specified as capture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_printinput: { // bool: no argument required but value may be specified as print:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as printinput:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_normalize: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_covcapture: { // bool: no argument required but value may be specified as normalize:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_covcheck: { // bool: no argument required but value may be specified as covcapture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_compdir: { // bool: no argument required but value may be specified as covcheck:Y
            *out_anon = false;
        } break;
        case command_FieldId_cfg: { // bool: no argument required but value may be specified as covcheck:Y
            *out_anon = false;
        } break;
        case command_FieldId_check_untracked: { // bool: no argument required but value may be specified as covcheck:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_maxerr: { // bool: no argument required but value may be specified as check_untracked:Y
            *out_anon = false;
        } break;
        case command_FieldId_build: { // bool: no argument required but value may be specified as check_untracked:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_ood: { // bool: no argument required but value may be specified as build:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_memcheck: { // bool: no argument required but value may be specified as ood:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_force: { // bool: no argument required but value may be specified as memcheck:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_callgrind: { // bool: no argument required but value may be specified as force:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_maxjobs: { // bool: no argument required but value may be specified as callgrind:Y
            *out_anon = false;
        } break;
        case command_FieldId_stream: { // bool: no argument required but value may be specified as callgrind:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_i: { // bool: no argument required but value may be specified as stream:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_write: { // bool: no argument required but value may be specified as i:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_b: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_comp_proc.atf_comp.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_comp_Start(command::atf_comp_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_comp_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_comp_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_comp_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_comp_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_comp_proc.atf_comp.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_comp_StartRead(command::atf_comp_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_comp_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_comp_proc.atf_comp.Kill
// Kill subprocess and wait
void command::atf_comp_Kill(command::atf_comp_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_comp_Wait(parent);
    }
}

// --- command.atf_comp_proc.atf_comp.Wait
// Wait for subprocess to return
void command::atf_comp_Wait(command::atf_comp_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_comp_proc.atf_comp.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_comp_Exec(command::atf_comp_proc& parent) {
    atf_comp_Start(parent);
    atf_comp_Wait(parent);
    return parent.status;
}

// --- command.atf_comp_proc.atf_comp.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_comp_ExecX(command::atf_comp_proc& parent) {
    int rc = atf_comp_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_comp_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_comp_proc.atf_comp.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_comp_Execv(command::atf_comp_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_comp_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_comp_proc.atf_comp.ToCmdline
algo::tempstr command::atf_comp_ToCmdline(command::atf_comp_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_comp_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_comp_proc.atf_comp.ToArgv
// Form array from the command line
void command::atf_comp_ToArgv(command::atf_comp_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.comptest.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-comptest:";
        command::comptest_Print(parent.cmd, *arg);
    }

    if (parent.cmd.mdbg != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mdbg:";
        bool_Print(parent.cmd.mdbg, *arg);
    }

    if (parent.cmd.run != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-run:";
        bool_Print(parent.cmd.run, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }

    if (parent.cmd.print != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-print:";
        bool_Print(parent.cmd.print, *arg);
    }

    if (parent.cmd.printinput != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-printinput:";
        bool_Print(parent.cmd.printinput, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.normalize != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-normalize:";
        bool_Print(parent.cmd.normalize, *arg);
    }

    if (parent.cmd.covcapture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-covcapture:";
        bool_Print(parent.cmd.covcapture, *arg);
    }

    if (parent.cmd.covcheck != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-covcheck:";
        bool_Print(parent.cmd.covcheck, *arg);
    }

    if (parent.cmd.compdir != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-compdir:";
        cstring_Print(parent.cmd.compdir, *arg);
    }

    if (parent.cmd.cfg != "release") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cfg:";
        Smallstr50_Print(parent.cmd.cfg, *arg);
    }

    if (parent.cmd.check_untracked != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check_untracked:";
        bool_Print(parent.cmd.check_untracked, *arg);
    }

    if (parent.cmd.maxerr != 1) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxerr:";
        i32_Print(parent.cmd.maxerr, *arg);
    }

    if (parent.cmd.build != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-build:";
        bool_Print(parent.cmd.build, *arg);
    }

    if (parent.cmd.ood != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ood:";
        bool_Print(parent.cmd.ood, *arg);
    }

    if (parent.cmd.memcheck != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-memcheck:";
        bool_Print(parent.cmd.memcheck, *arg);
    }

    if (parent.cmd.force != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-force:";
        bool_Print(parent.cmd.force, *arg);
    }

    if (parent.cmd.callgrind != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-callgrind:";
        bool_Print(parent.cmd.callgrind, *arg);
    }

    if (parent.cmd.maxjobs != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxjobs:";
        i32_Print(parent.cmd.maxjobs, *arg);
    }

    if (parent.cmd.stream != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-stream:";
        bool_Print(parent.cmd.stream, *arg);
    }

    if (parent.cmd.i != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-i:";
        bool_Print(parent.cmd.i, *arg);
    }

    if (parent.cmd.write != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write:";
        bool_Print(parent.cmd.write, *arg);
    }

    if (parent.cmd.report != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.b != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-b:";
        cstring_Print(parent.cmd.b, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_comp_proc..Uninit
void command::atf_comp_proc_Uninit(command::atf_comp_proc& parent) {
    command::atf_comp_proc &row = parent; (void)row;

    // command.atf_comp_proc.atf_comp.Uninit (Exec)  //
    atf_comp_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_cov.exclude.Print
// Print back to string
void command::exclude_Print(command::atf_cov& parent, algo::cstring &out) {
    Regx_Print(parent.exclude, out);
}

// --- command.atf_cov.exclude.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::exclude_ReadStrptrMaybe(command::atf_cov& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.exclude, in, true);
    return retval;
}

// --- command.atf_cov..ReadFieldMaybe
bool command::atf_cov_ReadFieldMaybe(command::atf_cov& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_covdir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.covdir, strval);
            break;
        }
        case command_FieldId_logfile: {
            retval = algo::cstring_ReadStrptrMaybe(parent.logfile, strval);
            break;
        }
        case command_FieldId_runcmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.runcmd, strval);
            break;
        }
        case command_FieldId_exclude: {
            retval = exclude_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_mergepath: {
            retval = algo::cstring_ReadStrptrMaybe(parent.mergepath, strval);
            break;
        }
        case command_FieldId_gcov: {
            retval = bool_ReadStrptrMaybe(parent.gcov, strval);
            break;
        }
        case command_FieldId_ssim: {
            retval = bool_ReadStrptrMaybe(parent.ssim, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        case command_FieldId_xmlpretty: {
            retval = bool_ReadStrptrMaybe(parent.xmlpretty, strval);
            break;
        }
        case command_FieldId_summary: {
            retval = bool_ReadStrptrMaybe(parent.summary, strval);
            break;
        }
        case command_FieldId_check: {
            retval = bool_ReadStrptrMaybe(parent.check, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_cov..ReadTupleMaybe
// Read fields of command::atf_cov from attributes of ascii tuple TUPLE
bool command::atf_cov_ReadTupleMaybe(command::atf_cov &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = atf_cov_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_cov..Init
// Set all fields to initial values.
void command::atf_cov_Init(command::atf_cov& parent) {
    parent.in = algo::strptr("data");
    parent.covdir = algo::strptr("temp/covdata");
    parent.logfile = algo::strptr("");
    parent.runcmd = algo::strptr("");
    Regx_ReadSql(parent.exclude, "(extern|include/gen|cpp/gen)/%", true);
    parent.mergepath = algo::strptr("");
    parent.gcov = bool(false);
    parent.ssim = bool(false);
    parent.report = bool(false);
    parent.capture = bool(false);
    parent.xmlpretty = bool(false);
    parent.summary = bool(true);
    parent.check = bool(false);
}

// --- command.atf_cov..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_cov_ToCmdline(command::atf_cov& row) {
    tempstr ret;
    ret << "bin/atf_cov ";
    atf_cov_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_cov..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_cov.Argv  printfmt:Tuple
void command::atf_cov_PrintArgv(command::atf_cov& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.covdir == "temp/covdata")) {
        ch_RemoveAll(temp);
        cstring_Print(row.covdir, temp);
        str << " -covdir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.logfile == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.logfile, temp);
        str << " -logfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.runcmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.runcmd, temp);
        str << " -runcmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.exclude.expr == "(extern|include/gen|cpp/gen)/%")) {
        ch_RemoveAll(temp);
        command::exclude_Print(const_cast<command::atf_cov&>(row), temp);
        str << " -exclude:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.mergepath == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.mergepath, temp);
        str << " -mergepath:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gcov == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gcov, temp);
        str << " -gcov:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ssim == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ssim, temp);
        str << " -ssim:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xmlpretty == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xmlpretty, temp);
        str << " -xmlpretty:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.summary == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.summary, temp);
        str << " -summary:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_cov..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_cov_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_covdir: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_logfile: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_runcmd: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_exclude: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_mergepath: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_gcov: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_ssim: { // bool: no argument required but value may be specified as gcov:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as ssim:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_capture: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_xmlpretty: { // bool: no argument required but value may be specified as capture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_summary: { // bool: no argument required but value may be specified as xmlpretty:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check: { // bool: no argument required but value may be specified as summary:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_cov_proc.atf_cov.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_cov_Start(command::atf_cov_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_cov_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_cov_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_cov_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_cov_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_cov_proc.atf_cov.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_cov_StartRead(command::atf_cov_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_cov_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_cov_proc.atf_cov.Kill
// Kill subprocess and wait
void command::atf_cov_Kill(command::atf_cov_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_cov_Wait(parent);
    }
}

// --- command.atf_cov_proc.atf_cov.Wait
// Wait for subprocess to return
void command::atf_cov_Wait(command::atf_cov_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_cov_proc.atf_cov.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_cov_Exec(command::atf_cov_proc& parent) {
    atf_cov_Start(parent);
    atf_cov_Wait(parent);
    return parent.status;
}

// --- command.atf_cov_proc.atf_cov.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_cov_ExecX(command::atf_cov_proc& parent) {
    int rc = atf_cov_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_cov_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_cov_proc.atf_cov.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_cov_Execv(command::atf_cov_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_cov_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_cov_proc.atf_cov.ToCmdline
algo::tempstr command::atf_cov_ToCmdline(command::atf_cov_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_cov_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_cov_proc.atf_cov.ToArgv
// Form array from the command line
void command::atf_cov_ToArgv(command::atf_cov_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.covdir != "temp/covdata") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-covdir:";
        cstring_Print(parent.cmd.covdir, *arg);
    }

    if (parent.cmd.logfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-logfile:";
        cstring_Print(parent.cmd.logfile, *arg);
    }

    if (parent.cmd.runcmd != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-runcmd:";
        cstring_Print(parent.cmd.runcmd, *arg);
    }

    if (parent.cmd.exclude.expr != "(extern|include/gen|cpp/gen)/%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-exclude:";
        command::exclude_Print(parent.cmd, *arg);
    }

    if (parent.cmd.mergepath != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mergepath:";
        cstring_Print(parent.cmd.mergepath, *arg);
    }

    if (parent.cmd.gcov != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gcov:";
        bool_Print(parent.cmd.gcov, *arg);
    }

    if (parent.cmd.ssim != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ssim:";
        bool_Print(parent.cmd.ssim, *arg);
    }

    if (parent.cmd.report != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }

    if (parent.cmd.xmlpretty != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-xmlpretty:";
        bool_Print(parent.cmd.xmlpretty, *arg);
    }

    if (parent.cmd.summary != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-summary:";
        bool_Print(parent.cmd.summary, *arg);
    }

    if (parent.cmd.check != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check:";
        bool_Print(parent.cmd.check, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_cov_proc..Uninit
void command::atf_cov_proc_Uninit(command::atf_cov_proc& parent) {
    command::atf_cov_proc &row = parent; (void)row;

    // command.atf_cov_proc.atf_cov.Uninit (Exec)  //
    atf_cov_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_fuzz.fuzzstrat.Print
// Print back to string
void command::fuzzstrat_Print(command::atf_fuzz& parent, algo::cstring &out) {
    Regx_Print(parent.fuzzstrat, out);
}

// --- command.atf_fuzz.fuzzstrat.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::fuzzstrat_ReadStrptrMaybe(command::atf_fuzz& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.fuzzstrat, in, true);
    return retval;
}

// --- command.atf_fuzz..ReadFieldMaybe
bool command::atf_fuzz_ReadFieldMaybe(command::atf_fuzz& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_reprofile: {
            retval = algo::cstring_ReadStrptrMaybe(parent.reprofile, strval);
            break;
        }
        case command_FieldId_target: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval);
            break;
        }
        case command_FieldId_args: {
            retval = algo::cstring_ReadStrptrMaybe(parent.args, strval);
            break;
        }
        case command_FieldId_inputfile: {
            retval = algo::cstring_ReadStrptrMaybe(parent.inputfile, strval);
            break;
        }
        case command_FieldId_fuzzstrat: {
            retval = fuzzstrat_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_seed: {
            retval = i32_ReadStrptrMaybe(parent.seed, strval);
            break;
        }
        case command_FieldId_testprob: {
            retval = double_ReadStrptrMaybe(parent.testprob, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_fuzz..ReadTupleMaybe
// Read fields of command::atf_fuzz from attributes of ascii tuple TUPLE
bool command::atf_fuzz_ReadTupleMaybe(command::atf_fuzz &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_fuzz_GetAnon(parent, anon_idx++);
        }
        retval = atf_fuzz_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_fuzz..Init
// Set all fields to initial values.
void command::atf_fuzz_Init(command::atf_fuzz& parent) {
    parent.reprofile = algo::strptr("temp/atf_fuzz.repro");
    parent.target = algo::strptr("");
    parent.args = algo::strptr("");
    parent.inputfile = algo::strptr("");
    Regx_ReadSql(parent.fuzzstrat, "%", true);
    parent.in = algo::strptr("data");
    parent.seed = i32(0);
    parent.testprob = double(1);
}

// --- command.atf_fuzz..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_fuzz_ToCmdline(command::atf_fuzz& row) {
    tempstr ret;
    ret << "bin/atf_fuzz ";
    atf_fuzz_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_fuzz..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_fuzz.Argv  printfmt:Tuple
void command::atf_fuzz_PrintArgv(command::atf_fuzz& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.reprofile == "temp/atf_fuzz.repro")) {
        ch_RemoveAll(temp);
        cstring_Print(row.reprofile, temp);
        str << " -reprofile:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    Smallstr16_Print(row.target, temp);
    str << " -target:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    cstring_Print(row.args, temp);
    str << " -args:";
    strptr_PrintBash(temp,str);
    if (!(row.inputfile == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.inputfile, temp);
        str << " -inputfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fuzzstrat.expr == "%")) {
        ch_RemoveAll(temp);
        command::fuzzstrat_Print(const_cast<command::atf_fuzz&>(row), temp);
        str << " -fuzzstrat:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.seed == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.seed, temp);
        str << " -seed:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.testprob == 1)) {
        ch_RemoveAll(temp);
        double_Print(row.testprob, temp);
        str << " -testprob:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_fuzz..GetAnon
algo::strptr command::atf_fuzz_GetAnon(command::atf_fuzz &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        case(1): return strptr("args", 4);
        default: return algo::strptr();
    }
}

// --- command.atf_fuzz..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_fuzz_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_reprofile: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_target: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_args: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_inputfile: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_fuzzstrat: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_seed: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_testprob: { // $comment
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    (void)out_dflt;//only to avoid -Wunused-parameter
    return retval;
}

// --- command.atf_fuzz_proc.atf_fuzz.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_fuzz_Start(command::atf_fuzz_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_fuzz_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_fuzz_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_fuzz_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_fuzz_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_fuzz_proc.atf_fuzz.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_fuzz_StartRead(command::atf_fuzz_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_fuzz_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_fuzz_proc.atf_fuzz.Kill
// Kill subprocess and wait
void command::atf_fuzz_Kill(command::atf_fuzz_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_fuzz_Wait(parent);
    }
}

// --- command.atf_fuzz_proc.atf_fuzz.Wait
// Wait for subprocess to return
void command::atf_fuzz_Wait(command::atf_fuzz_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_fuzz_proc.atf_fuzz.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_fuzz_Exec(command::atf_fuzz_proc& parent) {
    atf_fuzz_Start(parent);
    atf_fuzz_Wait(parent);
    return parent.status;
}

// --- command.atf_fuzz_proc.atf_fuzz.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_fuzz_ExecX(command::atf_fuzz_proc& parent) {
    int rc = atf_fuzz_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_fuzz_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_fuzz_proc.atf_fuzz.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_fuzz_Execv(command::atf_fuzz_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_fuzz_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_fuzz_proc.atf_fuzz.ToCmdline
algo::tempstr command::atf_fuzz_ToCmdline(command::atf_fuzz_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_fuzz_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_fuzz_proc.atf_fuzz.ToArgv
// Form array from the command line
void command::atf_fuzz_ToArgv(command::atf_fuzz_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.reprofile != "temp/atf_fuzz.repro") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-reprofile:";
        cstring_Print(parent.cmd.reprofile, *arg);
    }

    if (parent.cmd.target != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        Smallstr16_Print(parent.cmd.target, *arg);
    }

    if (parent.cmd.args != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-args:";
        cstring_Print(parent.cmd.args, *arg);
    }

    if (parent.cmd.inputfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-inputfile:";
        cstring_Print(parent.cmd.inputfile, *arg);
    }

    if (parent.cmd.fuzzstrat.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fuzzstrat:";
        command::fuzzstrat_Print(parent.cmd, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.seed != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-seed:";
        i32_Print(parent.cmd.seed, *arg);
    }

    if (parent.cmd.testprob != 1) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-testprob:";
        double_Print(parent.cmd.testprob, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_fuzz_proc..Uninit
void command::atf_fuzz_proc_Uninit(command::atf_fuzz_proc& parent) {
    command::atf_fuzz_proc &row = parent; (void)row;

    // command.atf_fuzz_proc.atf_fuzz.Uninit (Exec)  //
    atf_fuzz_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_gcli.gtblacttst.Print
// Print back to string
void command::gtblacttst_Print(command::atf_gcli& parent, algo::cstring &out) {
    Regx_Print(parent.gtblacttst, out);
}

// --- command.atf_gcli.gtblacttst.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::gtblacttst_ReadStrptrMaybe(command::atf_gcli& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.gtblacttst, in, true);
    return retval;
}

// --- command.atf_gcli..ReadFieldMaybe
bool command::atf_gcli_ReadFieldMaybe(command::atf_gcli& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_gtblacttst: {
            retval = gtblacttst_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_id: {
            retval = algo::cstring_ReadStrptrMaybe(parent.id, strval);
            break;
        }
        case command_FieldId_mr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.mr, strval);
            break;
        }
        case command_FieldId_note: {
            retval = algo::cstring_ReadStrptrMaybe(parent.note, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        case command_FieldId_skip_init: {
            retval = bool_ReadStrptrMaybe(parent.skip_init, strval);
            break;
        }
        case command_FieldId_skip_git_init: {
            retval = bool_ReadStrptrMaybe(parent.skip_git_init, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_gcli..ReadTupleMaybe
// Read fields of command::atf_gcli from attributes of ascii tuple TUPLE
bool command::atf_gcli_ReadTupleMaybe(command::atf_gcli &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = atf_gcli_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_gcli..Init
// Set all fields to initial values.
void command::atf_gcli_Init(command::atf_gcli& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.gtblacttst, "%", true);
    parent.id = algo::strptr("");
    parent.mr = algo::strptr("");
    parent.note = algo::strptr("");
    parent.capture = bool(false);
    parent.skip_init = bool(false);
    parent.skip_git_init = bool(false);
    parent.dry_run = bool(false);
}

// --- command.atf_gcli..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_gcli_ToCmdline(command::atf_gcli& row) {
    tempstr ret;
    ret << "bin/atf_gcli ";
    atf_gcli_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_gcli..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_gcli.Argv  printfmt:Tuple
void command::atf_gcli_PrintArgv(command::atf_gcli& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gtblacttst.expr == "%")) {
        ch_RemoveAll(temp);
        command::gtblacttst_Print(const_cast<command::atf_gcli&>(row), temp);
        str << " -gtblacttst:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.id == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.id, temp);
        str << " -id:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.mr == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.mr, temp);
        str << " -mr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.note == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.note, temp);
        str << " -note:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.skip_init == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.skip_init, temp);
        str << " -skip_init:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.skip_git_init == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.skip_git_init, temp);
        str << " -skip_git_init:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_gcli..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_gcli_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_gtblacttst: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_id: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_mr: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_note: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_capture: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_skip_init: { // bool: no argument required but value may be specified as capture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_skip_git_init: { // bool: no argument required but value may be specified as skip_init:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as skip_git_init:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_gcli_proc.atf_gcli.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_gcli_Start(command::atf_gcli_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_gcli_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_gcli_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_gcli_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_gcli_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_gcli_proc.atf_gcli.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_gcli_StartRead(command::atf_gcli_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_gcli_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_gcli_proc.atf_gcli.Kill
// Kill subprocess and wait
void command::atf_gcli_Kill(command::atf_gcli_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_gcli_Wait(parent);
    }
}

// --- command.atf_gcli_proc.atf_gcli.Wait
// Wait for subprocess to return
void command::atf_gcli_Wait(command::atf_gcli_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_gcli_proc.atf_gcli.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_gcli_Exec(command::atf_gcli_proc& parent) {
    atf_gcli_Start(parent);
    atf_gcli_Wait(parent);
    return parent.status;
}

// --- command.atf_gcli_proc.atf_gcli.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_gcli_ExecX(command::atf_gcli_proc& parent) {
    int rc = atf_gcli_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_gcli_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_gcli_proc.atf_gcli.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_gcli_Execv(command::atf_gcli_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_gcli_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_gcli_proc.atf_gcli.ToCmdline
algo::tempstr command::atf_gcli_ToCmdline(command::atf_gcli_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_gcli_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_gcli_proc.atf_gcli.ToArgv
// Form array from the command line
void command::atf_gcli_ToArgv(command::atf_gcli_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.gtblacttst.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gtblacttst:";
        command::gtblacttst_Print(parent.cmd, *arg);
    }

    if (parent.cmd.id != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-id:";
        cstring_Print(parent.cmd.id, *arg);
    }

    if (parent.cmd.mr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mr:";
        cstring_Print(parent.cmd.mr, *arg);
    }

    if (parent.cmd.note != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-note:";
        cstring_Print(parent.cmd.note, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }

    if (parent.cmd.skip_init != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-skip_init:";
        bool_Print(parent.cmd.skip_init, *arg);
    }

    if (parent.cmd.skip_git_init != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-skip_git_init:";
        bool_Print(parent.cmd.skip_git_init, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_gcli_proc..Uninit
void command::atf_gcli_proc_Uninit(command::atf_gcli_proc& parent) {
    command::atf_gcli_proc &row = parent; (void)row;

    // command.atf_gcli_proc.atf_gcli.Uninit (Exec)  //
    atf_gcli_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_nrun..ReadFieldMaybe
bool command::atf_nrun_ReadFieldMaybe(command::atf_nrun& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_maxjobs: {
            retval = i32_ReadStrptrMaybe(parent.maxjobs, strval);
            break;
        }
        case command_FieldId_ncmd: {
            retval = i32_ReadStrptrMaybe(parent.ncmd, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_nrun..ReadTupleMaybe
// Read fields of command::atf_nrun from attributes of ascii tuple TUPLE
bool command::atf_nrun_ReadTupleMaybe(command::atf_nrun &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_nrun_GetAnon(parent, anon_idx++);
        }
        retval = atf_nrun_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_nrun..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_nrun_ToCmdline(command::atf_nrun& row) {
    tempstr ret;
    ret << "bin/atf_nrun ";
    atf_nrun_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_nrun..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_nrun.Argv  printfmt:Tuple
void command::atf_nrun_PrintArgv(command::atf_nrun& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 2)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    i32_Print(row.ncmd, temp);
    str << " -ncmd:";
    strptr_PrintBash(temp,str);
}

// --- command.atf_nrun..GetAnon
algo::strptr command::atf_nrun_GetAnon(command::atf_nrun &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ncmd", 4);
        default: return algo::strptr();
    }
}

// --- command.atf_nrun..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_nrun_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_maxjobs: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_ncmd: { // $comment
            *out_anon = true;
        } break;
        default:
        retval=-1; // unrecognized
    }
    (void)out_dflt;//only to avoid -Wunused-parameter
    return retval;
}

// --- command.atf_nrun_proc.atf_nrun.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_nrun_Start(command::atf_nrun_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_nrun_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_nrun_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_nrun_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_nrun_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_nrun_proc.atf_nrun.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_nrun_StartRead(command::atf_nrun_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_nrun_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_nrun_proc.atf_nrun.Kill
// Kill subprocess and wait
void command::atf_nrun_Kill(command::atf_nrun_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_nrun_Wait(parent);
    }
}

// --- command.atf_nrun_proc.atf_nrun.Wait
// Wait for subprocess to return
void command::atf_nrun_Wait(command::atf_nrun_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_nrun_proc.atf_nrun.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_nrun_Exec(command::atf_nrun_proc& parent) {
    atf_nrun_Start(parent);
    atf_nrun_Wait(parent);
    return parent.status;
}

// --- command.atf_nrun_proc.atf_nrun.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_nrun_ExecX(command::atf_nrun_proc& parent) {
    int rc = atf_nrun_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_nrun_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_nrun_proc.atf_nrun.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_nrun_Execv(command::atf_nrun_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_nrun_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_nrun_proc.atf_nrun.ToCmdline
algo::tempstr command::atf_nrun_ToCmdline(command::atf_nrun_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_nrun_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_nrun_proc.atf_nrun.ToArgv
// Form array from the command line
void command::atf_nrun_ToArgv(command::atf_nrun_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.maxjobs != 2) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxjobs:";
        i32_Print(parent.cmd.maxjobs, *arg);
    }

    if (parent.cmd.ncmd != 6) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ncmd:";
        i32_Print(parent.cmd.ncmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_nrun_proc..Uninit
void command::atf_nrun_proc_Uninit(command::atf_nrun_proc& parent) {
    command::atf_nrun_proc &row = parent; (void)row;

    // command.atf_nrun_proc.atf_nrun.Uninit (Exec)  //
    atf_nrun_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_unit.unittest.Print
// Print back to string
void command::unittest_Print(command::atf_unit& parent, algo::cstring &out) {
    Regx_Print(parent.unittest, out);
}

// --- command.atf_unit.unittest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::unittest_ReadStrptrMaybe(command::atf_unit& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.unittest, in, true);
    return retval;
}

// --- command.atf_unit..ReadFieldMaybe
bool command::atf_unit_ReadFieldMaybe(command::atf_unit& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_unittest: {
            retval = unittest_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_nofork: {
            retval = bool_ReadStrptrMaybe(parent.nofork, strval);
            break;
        }
        case command_FieldId_arg: {
            retval = algo::cstring_ReadStrptrMaybe(parent.arg, strval);
            break;
        }
        case command_FieldId_data_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval);
            break;
        }
        case command_FieldId_mdbg: {
            retval = bool_ReadStrptrMaybe(parent.mdbg, strval);
            break;
        }
        case command_FieldId_perf_secs: {
            retval = double_ReadStrptrMaybe(parent.perf_secs, strval);
            break;
        }
        case command_FieldId_pertest_timeout: {
            retval = u32_ReadStrptrMaybe(parent.pertest_timeout, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        case command_FieldId_check_untracked: {
            retval = bool_ReadStrptrMaybe(parent.check_untracked, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_unit..ReadTupleMaybe
// Read fields of command::atf_unit from attributes of ascii tuple TUPLE
bool command::atf_unit_ReadTupleMaybe(command::atf_unit &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_unit_GetAnon(parent, anon_idx++);
        }
        retval = atf_unit_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_unit..Init
// Set all fields to initial values.
void command::atf_unit_Init(command::atf_unit& parent) {
    Regx_ReadSql(parent.unittest, "%", true);
    parent.nofork = bool(false);
    parent.arg = algo::strptr("");
    parent.data_dir = algo::strptr("data");
    parent.mdbg = bool(0);
    parent.perf_secs = double(1.0);
    parent.pertest_timeout = u32(900);
    parent.report = bool(true);
    parent.capture = bool(false);
    parent.check_untracked = bool(true);
}

// --- command.atf_unit..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_unit_ToCmdline(command::atf_unit& row) {
    tempstr ret;
    ret << "bin/atf_unit ";
    atf_unit_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_unit..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.atf_unit.Argv  printfmt:Auto
void command::atf_unit_PrintArgv(command::atf_unit& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    command::unittest_Print(const_cast<command::atf_unit&>(row), temp);
    str << " -unittest:";
    strptr_PrintBash(temp,str);
    if (!(row.nofork == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.nofork, temp);
        str << " -nofork:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arg == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.arg, temp);
        str << " -arg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.mdbg == 0)) {
        ch_RemoveAll(temp);
        bool_Print(row.mdbg, temp);
        str << " -mdbg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.perf_secs == 1.0)) {
        ch_RemoveAll(temp);
        double_Print(row.perf_secs, temp);
        str << " -perf_secs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pertest_timeout == 900)) {
        ch_RemoveAll(temp);
        u32_Print(row.pertest_timeout, temp);
        str << " -pertest_timeout:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check_untracked == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.check_untracked, temp);
        str << " -check_untracked:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_unit..GetAnon
algo::strptr command::atf_unit_GetAnon(command::atf_unit &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("unittest", 8);
        default: return algo::strptr();
    }
}

// --- command.atf_unit..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::atf_unit_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_unittest: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_nofork: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_arg: { // bool: no argument required but value may be specified as nofork:Y
            *out_anon = false;
        } break;
        case command_FieldId_data_dir: { // bool: no argument required but value may be specified as nofork:Y
            *out_anon = false;
        } break;
        case command_FieldId_mdbg: { // bool: no argument required but value may be specified as nofork:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_perf_secs: { // bool: no argument required but value may be specified as mdbg:Y
            *out_anon = false;
        } break;
        case command_FieldId_pertest_timeout: { // bool: no argument required but value may be specified as mdbg:Y
            *out_anon = false;
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as mdbg:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_capture: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_check_untracked: { // bool: no argument required but value may be specified as capture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.atf_unit_proc.atf_unit.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_unit_Start(command::atf_unit_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_unit_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_unit_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_unit_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_unit_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_unit_proc.atf_unit.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_unit_StartRead(command::atf_unit_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_unit_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_unit_proc.atf_unit.Kill
// Kill subprocess and wait
void command::atf_unit_Kill(command::atf_unit_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_unit_Wait(parent);
    }
}

// --- command.atf_unit_proc.atf_unit.Wait
// Wait for subprocess to return
void command::atf_unit_Wait(command::atf_unit_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_unit_proc.atf_unit.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_unit_Exec(command::atf_unit_proc& parent) {
    atf_unit_Start(parent);
    atf_unit_Wait(parent);
    return parent.status;
}

// --- command.atf_unit_proc.atf_unit.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_unit_ExecX(command::atf_unit_proc& parent) {
    int rc = atf_unit_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_unit_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_unit_proc.atf_unit.Execv
// Call execv()
// Call execv with specified parameters
int command::atf_unit_Execv(command::atf_unit_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    atf_unit_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.atf_unit_proc.atf_unit.ToCmdline
algo::tempstr command::atf_unit_ToCmdline(command::atf_unit_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_unit_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_unit_proc.atf_unit.ToArgv
// Form array from the command line
void command::atf_unit_ToArgv(command::atf_unit_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.unittest.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-unittest:";
        command::unittest_Print(parent.cmd, *arg);
    }

    if (parent.cmd.nofork != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nofork:";
        bool_Print(parent.cmd.nofork, *arg);
    }

    if (parent.cmd.arg != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-arg:";
        cstring_Print(parent.cmd.arg, *arg);
    }

    if (parent.cmd.data_dir != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, *arg);
    }

    if (parent.cmd.mdbg != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-mdbg:";
        bool_Print(parent.cmd.mdbg, *arg);
    }

    if (parent.cmd.perf_secs != 1.0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-perf_secs:";
        double_Print(parent.cmd.perf_secs, *arg);
    }

    if (parent.cmd.pertest_timeout != 900) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pertest_timeout:";
        u32_Print(parent.cmd.pertest_timeout, *arg);
    }

    if (parent.cmd.report != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }

    if (parent.cmd.check_untracked != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-check_untracked:";
        bool_Print(parent.cmd.check_untracked, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.atf_unit_proc..Uninit
void command::atf_unit_proc_Uninit(command::atf_unit_proc& parent) {
    command::atf_unit_proc &row = parent; (void)row;

    // command.atf_unit_proc.atf_unit.Uninit (Exec)  //
    atf_unit_Kill(parent); // kill child, ensure forward progress
}

// --- command.bash..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.bash.ArgvGnu  printfmt:Auto
void command::bash_PrintArgv(command::bash& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.c == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.c, temp);
        str << " -c ";
        strptr_PrintBash(temp,str);
    }
}

// --- command.bash2html..ReadFieldMaybe
bool command::bash2html_ReadFieldMaybe(command::bash2html& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_test: {
            retval = bool_ReadStrptrMaybe(parent.test, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.bash2html..ReadTupleMaybe
// Read fields of command::bash2html from attributes of ascii tuple TUPLE
bool command::bash2html_ReadTupleMaybe(command::bash2html &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = bash2html_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.bash2html..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::bash2html_ToCmdline(command::bash2html& row) {
    tempstr ret;
    ret << "bin/bash2html ";
    bash2html_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.bash2html..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.bash2html.Argv  printfmt:Tuple
void command::bash2html_PrintArgv(command::bash2html& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.test == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.test, temp);
        str << " -test:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.bash2html..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::bash2html_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_test: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.bash2html_proc.bash2html.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::bash2html_Start(command::bash2html_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(bash2html_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(bash2html_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= bash2html_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.bash2html_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.bash2html_proc.bash2html.StartRead
// Start subprocess & Read output
algo::Fildes command::bash2html_StartRead(command::bash2html_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    bash2html_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.bash2html_proc.bash2html.Kill
// Kill subprocess and wait
void command::bash2html_Kill(command::bash2html_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        bash2html_Wait(parent);
    }
}

// --- command.bash2html_proc.bash2html.Wait
// Wait for subprocess to return
void command::bash2html_Wait(command::bash2html_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.bash2html_proc.bash2html.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::bash2html_Exec(command::bash2html_proc& parent) {
    bash2html_Start(parent);
    bash2html_Wait(parent);
    return parent.status;
}

// --- command.bash2html_proc.bash2html.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::bash2html_ExecX(command::bash2html_proc& parent) {
    int rc = bash2html_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",bash2html_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.bash2html_proc.bash2html.Execv
// Call execv()
// Call execv with specified parameters
int command::bash2html_Execv(command::bash2html_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    bash2html_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.bash2html_proc.bash2html.ToCmdline
algo::tempstr command::bash2html_ToCmdline(command::bash2html_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::bash2html_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.bash2html_proc.bash2html.ToArgv
// Form array from the command line
void command::bash2html_ToArgv(command::bash2html_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.test != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-test:";
        bool_Print(parent.cmd.test, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.bash2html_proc..Uninit
void command::bash2html_proc_Uninit(command::bash2html_proc& parent) {
    command::bash2html_proc &row = parent; (void)row;

    // command.bash2html_proc.bash2html.Uninit (Exec)  //
    bash2html_Kill(parent); // kill child, ensure forward progress
}

// --- command.bash_proc.bash.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::bash_Start(command::bash_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(bash_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(bash_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= bash_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.bash_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.bash_proc.bash.StartRead
// Start subprocess & Read output
algo::Fildes command::bash_StartRead(command::bash_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    bash_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.bash_proc.bash.Kill
// Kill subprocess and wait
void command::bash_Kill(command::bash_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        bash_Wait(parent);
    }
}

// --- command.bash_proc.bash.Wait
// Wait for subprocess to return
void command::bash_Wait(command::bash_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.bash_proc.bash.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::bash_Exec(command::bash_proc& parent) {
    bash_Start(parent);
    bash_Wait(parent);
    return parent.status;
}

// --- command.bash_proc.bash.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::bash_ExecX(command::bash_proc& parent) {
    int rc = bash_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",bash_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.bash_proc.bash.Execv
// Call execv()
// Call execv with specified parameters
int command::bash_Execv(command::bash_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    bash_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.bash_proc.bash.ToCmdline
algo::tempstr command::bash_ToCmdline(command::bash_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::bash_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.bash_proc.bash.ToArgv
// Form array from the command line
void command::bash_ToArgv(command::bash_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.c != "") {
        ary_Alloc(args) << "-c";
        cstring *arg = &ary_Alloc(args);
        cstring_Print(parent.cmd.c, *arg);
    }
}

// --- command.bash_proc..Uninit
void command::bash_proc_Uninit(command::bash_proc& parent) {
    command::bash_proc &row = parent; (void)row;

    // command.bash_proc.bash.Uninit (Exec)  //Must be bash to support $'' for string quoting
    bash_Kill(parent); // kill child, ensure forward progress
}

// --- command.gcache.cmd.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::cmd_Addary(command::gcache& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.cmd_elems && rhs.elems < parent.cmd_elems + parent.cmd_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.gcache.cmd  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    cmd_Reserve(parent, nnew); // reserve space
    int at = parent.cmd_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.cmd_elems + at + i) algo::cstring(rhs[i]);
        parent.cmd_n++;
    }
    return algo::aryptr<algo::cstring>(parent.cmd_elems + at, nnew);
}

// --- command.gcache.cmd.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::cmd_Alloc(command::gcache& parent) {
    cmd_Reserve(parent, 1);
    int n  = parent.cmd_n;
    int at = n;
    algo::cstring *elems = parent.cmd_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.cmd_n = n+1;
    return elems[at];
}

// --- command.gcache.cmd.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::cmd_AllocAt(command::gcache& parent, int at) {
    cmd_Reserve(parent, 1);
    int n  = parent.cmd_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.gcache.cmd  comment:'index out of range'");
    }
    algo::cstring *elems = parent.cmd_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.cmd_n = n+1;
    return elems[at];
}

// --- command.gcache.cmd.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::cmd_AllocN(command::gcache& parent, int n_elems) {
    cmd_Reserve(parent, n_elems);
    int old_n  = parent.cmd_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.cmd_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.cmd_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.gcache.cmd.Remove
// Remove item by index. If index outside of range, do nothing.
void command::cmd_Remove(command::gcache& parent, u32 i) {
    u32 lim = parent.cmd_n;
    algo::cstring *elems = parent.cmd_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.cmd_n = lim - 1;
    }
}

// --- command.gcache.cmd.RemoveAll
void command::cmd_RemoveAll(command::gcache& parent) {
    u32 n = parent.cmd_n;
    while (n > 0) {
        n -= 1;
        parent.cmd_elems[n].~cstring();
        parent.cmd_n = n;
    }
}

// --- command.gcache.cmd.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::cmd_RemoveLast(command::gcache& parent) {
    u64 n = parent.cmd_n;
    if (n > 0) {
        n -= 1;
        cmd_qFind(parent, u64(n)).~cstring();
        parent.cmd_n = n;
    }
}

// --- command.gcache.cmd.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::cmd_AbsReserve(command::gcache& parent, int n) {
    u32 old_max  = parent.cmd_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.cmd_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.gcache.cmd  comment:'out of memory'");
        }
        parent.cmd_elems = (algo::cstring*)new_mem;
        parent.cmd_max = new_max;
    }
}

// --- command.gcache.cmd.Setary
// Copy contents of RHS to PARENT.
void command::cmd_Setary(command::gcache& parent, command::gcache &rhs) {
    cmd_RemoveAll(parent);
    int nnew = rhs.cmd_n;
    cmd_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.cmd_elems + i) algo::cstring(cmd_qFind(rhs, i));
        parent.cmd_n = i + 1;
    }
}

// --- command.gcache.cmd.Setary2
// Copy specified array into cmd, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::cmd_Setary(command::gcache& parent, const algo::aryptr<algo::cstring> &rhs) {
    cmd_RemoveAll(parent);
    cmd_Addary(parent, rhs);
}

// --- command.gcache.cmd.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::cmd_AllocNVal(command::gcache& parent, int n_elems, const algo::cstring& val) {
    cmd_Reserve(parent, n_elems);
    int old_n  = parent.cmd_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.cmd_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.cmd_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.gcache.cmd.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::cmd_ReadStrptrMaybe(command::gcache& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = cmd_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        cmd_RemoveLast(parent);
    }
    return retval;
}

// --- command.gcache..ReadFieldMaybe
bool command::gcache_ReadFieldMaybe(command::gcache& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_cmd: {
            retval = cmd_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_install: {
            retval = bool_ReadStrptrMaybe(parent.install, strval);
            break;
        }
        case command_FieldId_stats: {
            retval = bool_ReadStrptrMaybe(parent.stats, strval);
            break;
        }
        case command_FieldId_enable: {
            retval = bool_ReadStrptrMaybe(parent.enable, strval);
            break;
        }
        case command_FieldId_disable: {
            retval = bool_ReadStrptrMaybe(parent.disable, strval);
            break;
        }
        case command_FieldId_gc: {
            retval = bool_ReadStrptrMaybe(parent.gc, strval);
            break;
        }
        case command_FieldId_clean: {
            retval = bool_ReadStrptrMaybe(parent.clean, strval);
            break;
        }
        case command_FieldId_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.dir, strval);
            break;
        }
        case command_FieldId_hitrate: {
            retval = bool_ReadStrptrMaybe(parent.hitrate, strval);
            break;
        }
        case command_FieldId_after: {
            retval = algo::UnTime_ReadStrptrMaybe(parent.after, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_force: {
            retval = bool_ReadStrptrMaybe(parent.force, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.gcache..ReadTupleMaybe
// Read fields of command::gcache from attributes of ascii tuple TUPLE
bool command::gcache_ReadTupleMaybe(command::gcache &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = gcache_GetAnon(parent, anon_idx++);
        }
        retval = gcache_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.gcache..Init
// Set all fields to initial values.
void command::gcache_Init(command::gcache& parent) {
    parent.in = algo::strptr("data");
    parent.cmd_elems 	= 0; // (command.gcache.cmd)
    parent.cmd_n     	= 0; // (command.gcache.cmd)
    parent.cmd_max   	= 0; // (command.gcache.cmd)
    parent.install = bool(false);
    parent.stats = bool(false);
    parent.enable = bool(false);
    parent.disable = bool(false);
    parent.gc = bool(false);
    parent.clean = bool(false);
    parent.dir = algo::strptr("/tmp/gcache");
    parent.hitrate = bool(false);
    parent.report = bool(false);
    parent.force = bool(false);
}

// --- command.gcache..Uninit
void command::gcache_Uninit(command::gcache& parent) {
    command::gcache &row = parent; (void)row;

    // command.gcache.cmd.Uninit (Tary)  //Command to execute
    // remove all elements from command.gcache.cmd
    cmd_RemoveAll(parent);
    // free memory for Tary command.gcache.cmd
    algo_lib::malloc_FreeMem(parent.cmd_elems, sizeof(algo::cstring)*parent.cmd_max); // (command.gcache.cmd)
}

// --- command.gcache..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::gcache_ToCmdline(command::gcache& row) {
    tempstr ret;
    ret << "bin/gcache ";
    gcache_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.gcache..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.gcache.Argv  printfmt:Tuple
void command::gcache_PrintArgv(command::gcache& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(gcache_cmd_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stats == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stats, temp);
        str << " -stats:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.enable == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.enable, temp);
        str << " -enable:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.disable == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.disable, temp);
        str << " -disable:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gc, temp);
        str << " -gc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.clean == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.clean, temp);
        str << " -clean:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dir == "/tmp/gcache")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dir, temp);
        str << " -dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.hitrate == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.hitrate, temp);
        str << " -hitrate:";
        strptr_PrintBash(temp,str);
    }
    if (!(UnTime_Eq(row.after, algo::UnTime()))) {
        ch_RemoveAll(temp);
        UnTime_Print(row.after, temp);
        str << " -after:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.force == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.force, temp);
        str << " -force:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.gcache..Print
// print string representation of ROW to string STR
// cfmt:command.gcache.String  printfmt:Tuple
void command::gcache_Print(command::gcache& row, algo::cstring& str) {
    algo::tempstr temp;
    str << "command.gcache";

    algo::cstring_Print(row.in, temp);
    PrintAttrSpaceReset(str,"in", temp);

    ind_beg(gcache_cmd_curs,cmd,row) {
        algo::cstring_Print(cmd, temp);
        tempstr name;
        name << "cmd.";
        name << ind_curs(cmd).index;
        PrintAttrSpaceReset(str, name, temp);
    }ind_end;

    bool_Print(row.install, temp);
    PrintAttrSpaceReset(str,"install", temp);

    bool_Print(row.stats, temp);
    PrintAttrSpaceReset(str,"stats", temp);

    bool_Print(row.enable, temp);
    PrintAttrSpaceReset(str,"enable", temp);

    bool_Print(row.disable, temp);
    PrintAttrSpaceReset(str,"disable", temp);

    bool_Print(row.gc, temp);
    PrintAttrSpaceReset(str,"gc", temp);

    bool_Print(row.clean, temp);
    PrintAttrSpaceReset(str,"clean", temp);

    algo::cstring_Print(row.dir, temp);
    PrintAttrSpaceReset(str,"dir", temp);

    bool_Print(row.hitrate, temp);
    PrintAttrSpaceReset(str,"hitrate", temp);

    algo::UnTime_Print(row.after, temp);
    PrintAttrSpaceReset(str,"after", temp);

    bool_Print(row.report, temp);
    PrintAttrSpaceReset(str,"report", temp);

    bool_Print(row.force, temp);
    PrintAttrSpaceReset(str,"force", temp);
}

// --- command.gcache..GetAnon
algo::strptr command::gcache_GetAnon(command::gcache &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        default: return strptr("cmd", 3);
    }
}

// --- command.gcache..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::gcache_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_cmd: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_install: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_stats: { // bool: no argument required but value may be specified as install:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_enable: { // bool: no argument required but value may be specified as stats:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_disable: { // bool: no argument required but value may be specified as enable:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_gc: { // bool: no argument required but value may be specified as disable:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_clean: { // bool: no argument required but value may be specified as gc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dir: { // bool: no argument required but value may be specified as clean:Y
            *out_anon = false;
        } break;
        case command_FieldId_hitrate: { // bool: no argument required but value may be specified as clean:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_after: { // bool: no argument required but value may be specified as hitrate:Y
            *out_anon = false;
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as hitrate:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_force: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.gcache_proc.gcache.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::gcache_Start(command::gcache_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(gcache_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(gcache_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= gcache_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.gcache_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.gcache_proc.gcache.StartRead
// Start subprocess & Read output
algo::Fildes command::gcache_StartRead(command::gcache_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    gcache_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.gcache_proc.gcache.Kill
// Kill subprocess and wait
void command::gcache_Kill(command::gcache_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        gcache_Wait(parent);
    }
}

// --- command.gcache_proc.gcache.Wait
// Wait for subprocess to return
void command::gcache_Wait(command::gcache_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.gcache_proc.gcache.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::gcache_Exec(command::gcache_proc& parent) {
    gcache_Start(parent);
    gcache_Wait(parent);
    return parent.status;
}

// --- command.gcache_proc.gcache.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::gcache_ExecX(command::gcache_proc& parent) {
    int rc = gcache_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",gcache_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.gcache_proc.gcache.Execv
// Call execv()
// Call execv with specified parameters
int command::gcache_Execv(command::gcache_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    gcache_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.gcache_proc.gcache.ToCmdline
algo::tempstr command::gcache_ToCmdline(command::gcache_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::gcache_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.gcache_proc.gcache.ToArgv
// Form array from the command line
void command::gcache_ToArgv(command::gcache_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }
    ind_beg(command::gcache_cmd_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmd:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.install != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-install:";
        bool_Print(parent.cmd.install, *arg);
    }

    if (parent.cmd.stats != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-stats:";
        bool_Print(parent.cmd.stats, *arg);
    }

    if (parent.cmd.enable != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-enable:";
        bool_Print(parent.cmd.enable, *arg);
    }

    if (parent.cmd.disable != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-disable:";
        bool_Print(parent.cmd.disable, *arg);
    }

    if (parent.cmd.gc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gc:";
        bool_Print(parent.cmd.gc, *arg);
    }

    if (parent.cmd.clean != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-clean:";
        bool_Print(parent.cmd.clean, *arg);
    }

    if (parent.cmd.dir != "/tmp/gcache") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dir:";
        cstring_Print(parent.cmd.dir, *arg);
    }

    if (parent.cmd.hitrate != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-hitrate:";
        bool_Print(parent.cmd.hitrate, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-after:";
        UnTime_Print(parent.cmd.after, *arg);
    }

    if (parent.cmd.report != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.force != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-force:";
        bool_Print(parent.cmd.force, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.gcache_proc..Uninit
void command::gcache_proc_Uninit(command::gcache_proc& parent) {
    command::gcache_proc &row = parent; (void)row;

    // command.gcache_proc.gcache.Uninit (Exec)  //
    gcache_Kill(parent); // kill child, ensure forward progress
}

// --- command.gcli.fields.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::fields_Addary(command::gcli& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.fields_elems && rhs.elems < parent.fields_elems + parent.fields_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.gcli.fields  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    fields_Reserve(parent, nnew); // reserve space
    int at = parent.fields_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.fields_elems + at + i) algo::cstring(rhs[i]);
        parent.fields_n++;
    }
    return algo::aryptr<algo::cstring>(parent.fields_elems + at, nnew);
}

// --- command.gcli.fields.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::fields_Alloc(command::gcli& parent) {
    fields_Reserve(parent, 1);
    int n  = parent.fields_n;
    int at = n;
    algo::cstring *elems = parent.fields_elems;
    new (elems + at) algo::cstring(""); // construct new element, default initializer
    parent.fields_n = n+1;
    return elems[at];
}

// --- command.gcli.fields.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::fields_AllocAt(command::gcli& parent, int at) {
    fields_Reserve(parent, 1);
    int n  = parent.fields_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.gcli.fields  comment:'index out of range'");
    }
    algo::cstring *elems = parent.fields_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(""); // construct element, default initializer
    parent.fields_n = n+1;
    return elems[at];
}

// --- command.gcli.fields.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::fields_AllocN(command::gcli& parent, int n_elems) {
    fields_Reserve(parent, n_elems);
    int old_n  = parent.fields_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.fields_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(""); // construct new element, default initialize
    }
    parent.fields_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.gcli.fields.Remove
// Remove item by index. If index outside of range, do nothing.
void command::fields_Remove(command::gcli& parent, u32 i) {
    u32 lim = parent.fields_n;
    algo::cstring *elems = parent.fields_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.fields_n = lim - 1;
    }
}

// --- command.gcli.fields.RemoveAll
void command::fields_RemoveAll(command::gcli& parent) {
    u32 n = parent.fields_n;
    while (n > 0) {
        n -= 1;
        parent.fields_elems[n].~cstring();
        parent.fields_n = n;
    }
}

// --- command.gcli.fields.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::fields_RemoveLast(command::gcli& parent) {
    u64 n = parent.fields_n;
    if (n > 0) {
        n -= 1;
        fields_qFind(parent, u64(n)).~cstring();
        parent.fields_n = n;
    }
}

// --- command.gcli.fields.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::fields_AbsReserve(command::gcli& parent, int n) {
    u32 old_max  = parent.fields_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.fields_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.gcli.fields  comment:'out of memory'");
        }
        parent.fields_elems = (algo::cstring*)new_mem;
        parent.fields_max = new_max;
    }
}

// --- command.gcli.fields.Setary
// Copy contents of RHS to PARENT.
void command::fields_Setary(command::gcli& parent, command::gcli &rhs) {
    fields_RemoveAll(parent);
    int nnew = rhs.fields_n;
    fields_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.fields_elems + i) algo::cstring(fields_qFind(rhs, i));
        parent.fields_n = i + 1;
    }
}

// --- command.gcli.fields.Setary2
// Copy specified array into fields, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::fields_Setary(command::gcli& parent, const algo::aryptr<algo::cstring> &rhs) {
    fields_RemoveAll(parent);
    fields_Addary(parent, rhs);
}

// --- command.gcli.fields.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::fields_AllocNVal(command::gcli& parent, int n_elems, const algo::cstring& val) {
    fields_Reserve(parent, n_elems);
    int old_n  = parent.fields_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.fields_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.fields_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.gcli.fields.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::fields_ReadStrptrMaybe(command::gcli& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = fields_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        fields_RemoveLast(parent);
    }
    return retval;
}

// --- command.gcli..ReadFieldMaybe
bool command::gcli_ReadFieldMaybe(command::gcli& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_selector: {
            retval = algo::Smallstr250_ReadStrptrMaybe(parent.selector, strval);
            break;
        }
        case command_FieldId_fields: {
            retval = fields_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_accept: {
            retval = bool_ReadStrptrMaybe(parent.accept, strval);
            break;
        }
        case command_FieldId_start: {
            retval = bool_ReadStrptrMaybe(parent.start, strval);
            break;
        }
        case command_FieldId_list: {
            retval = bool_ReadStrptrMaybe(parent.list, strval);
            break;
        }
        case command_FieldId_create: {
            retval = bool_ReadStrptrMaybe(parent.create, strval);
            break;
        }
        case command_FieldId_update: {
            retval = bool_ReadStrptrMaybe(parent.update, strval);
            break;
        }
        case command_FieldId_approve: {
            retval = bool_ReadStrptrMaybe(parent.approve, strval);
            break;
        }
        case command_FieldId_needs_work: {
            retval = bool_ReadStrptrMaybe(parent.needs_work, strval);
            break;
        }
        case command_FieldId_stop: {
            retval = bool_ReadStrptrMaybe(parent.stop, strval);
            break;
        }
        case command_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_authdir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.authdir, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        case command_FieldId_gitdir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.gitdir, strval);
            break;
        }
        case command_FieldId_show_gitlab_system_notes: {
            retval = bool_ReadStrptrMaybe(parent.show_gitlab_system_notes, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.gcli..ReadTupleMaybe
// Read fields of command::gcli from attributes of ascii tuple TUPLE
bool command::gcli_ReadTupleMaybe(command::gcli &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = gcli_GetAnon(parent, anon_idx++);
        }
        retval = gcli_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.gcli..Init
// Set all fields to initial values.
void command::gcli_Init(command::gcli& parent) {
    parent.in = algo::strptr("data");
    parent.selector = algo::strptr("issue:%");
    parent.fields_elems 	= 0; // (command.gcli.fields)
    parent.fields_n     	= 0; // (command.gcli.fields)
    parent.fields_max   	= 0; // (command.gcli.fields)
    parent.accept = bool(false);
    parent.start = bool(false);
    parent.list = bool(false);
    parent.create = bool(false);
    parent.update = bool(false);
    parent.approve = bool(false);
    parent.needs_work = bool(false);
    parent.stop = bool(false);
    parent.t = bool(false);
    parent.e = bool(false);
    parent.authdir = algo::strptr(".ssim");
    parent.dry_run = bool(false);
    parent.gitdir = algo::strptr("");
    parent.show_gitlab_system_notes = bool(false);
}

// --- command.gcli..Uninit
void command::gcli_Uninit(command::gcli& parent) {
    command::gcli &row = parent; (void)row;

    // command.gcli.fields.Uninit (Tary)  //additional key:value pairs for use with -create, -list, -update
    // remove all elements from command.gcli.fields
    fields_RemoveAll(parent);
    // free memory for Tary command.gcli.fields
    algo_lib::malloc_FreeMem(parent.fields_elems, sizeof(algo::cstring)*parent.fields_max); // (command.gcli.fields)
}

// --- command.gcli..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::gcli_ToCmdline(command::gcli& row) {
    tempstr ret;
    ret << "bin/gcli ";
    gcli_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.gcli..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.gcli.Argv  printfmt:Tuple
void command::gcli_PrintArgv(command::gcli& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    Smallstr250_Print(row.selector, temp);
    str << " -selector:";
    strptr_PrintBash(temp,str);
    ind_beg(gcli_fields_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -fields:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.accept == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.accept, temp);
        str << " -accept:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.start == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.start, temp);
        str << " -start:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.create == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.create, temp);
        str << " -create:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.update == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.update, temp);
        str << " -update:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.approve == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.approve, temp);
        str << " -approve:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.needs_work == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.needs_work, temp);
        str << " -needs_work:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stop == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stop, temp);
        str << " -stop:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.authdir == ".ssim")) {
        ch_RemoveAll(temp);
        cstring_Print(row.authdir, temp);
        str << " -authdir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gitdir == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.gitdir, temp);
        str << " -gitdir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.show_gitlab_system_notes == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.show_gitlab_system_notes, temp);
        str << " -show_gitlab_system_notes:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.gcli..GetAnon
algo::strptr command::gcli_GetAnon(command::gcli &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("selector", 8);
        default: return strptr("fields", 6);
    }
}

// --- command.gcli..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::gcli_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_selector: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_fields: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_accept: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_start: { // bool: no argument required but value may be specified as accept:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_list: { // bool: no argument required but value may be specified as start:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_create: { // bool: no argument required but value may be specified as list:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_update: { // bool: no argument required but value may be specified as create:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_approve: { // bool: no argument required but value may be specified as update:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_needs_work: { // bool: no argument required but value may be specified as approve:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_stop: { // bool: no argument required but value may be specified as needs_work:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_t: { // bool: no argument required but value may be specified as stop:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_authdir: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_gitdir: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
        } break;
        case command_FieldId_show_gitlab_system_notes: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.gcli_proc.gcli.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::gcli_Start(command::gcli_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(gcli_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(gcli_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= gcli_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.gcli_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.gcli_proc.gcli.StartRead
// Start subprocess & Read output
algo::Fildes command::gcli_StartRead(command::gcli_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    gcli_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.gcli_proc.gcli.Kill
// Kill subprocess and wait
void command::gcli_Kill(command::gcli_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        gcli_Wait(parent);
    }
}

// --- command.gcli_proc.gcli.Wait
// Wait for subprocess to return
void command::gcli_Wait(command::gcli_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.gcli_proc.gcli.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::gcli_Exec(command::gcli_proc& parent) {
    gcli_Start(parent);
    gcli_Wait(parent);
    return parent.status;
}

// --- command.gcli_proc.gcli.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::gcli_ExecX(command::gcli_proc& parent) {
    int rc = gcli_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",gcli_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.gcli_proc.gcli.Execv
// Call execv()
// Call execv with specified parameters
int command::gcli_Execv(command::gcli_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    gcli_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.gcli_proc.gcli.ToCmdline
algo::tempstr command::gcli_ToCmdline(command::gcli_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::gcli_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.gcli_proc.gcli.ToArgv
// Form array from the command line
void command::gcli_ToArgv(command::gcli_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.selector != "issue:%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-selector:";
        Smallstr250_Print(parent.cmd.selector, *arg);
    }
    ind_beg(command::gcli_fields_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fields:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.accept != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-accept:";
        bool_Print(parent.cmd.accept, *arg);
    }

    if (parent.cmd.start != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-start:";
        bool_Print(parent.cmd.start, *arg);
    }

    if (parent.cmd.list != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-list:";
        bool_Print(parent.cmd.list, *arg);
    }

    if (parent.cmd.create != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-create:";
        bool_Print(parent.cmd.create, *arg);
    }

    if (parent.cmd.update != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-update:";
        bool_Print(parent.cmd.update, *arg);
    }

    if (parent.cmd.approve != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-approve:";
        bool_Print(parent.cmd.approve, *arg);
    }

    if (parent.cmd.needs_work != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-needs_work:";
        bool_Print(parent.cmd.needs_work, *arg);
    }

    if (parent.cmd.stop != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-stop:";
        bool_Print(parent.cmd.stop, *arg);
    }

    if (parent.cmd.t != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-t:";
        bool_Print(parent.cmd.t, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.authdir != ".ssim") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-authdir:";
        cstring_Print(parent.cmd.authdir, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }

    if (parent.cmd.gitdir != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gitdir:";
        cstring_Print(parent.cmd.gitdir, *arg);
    }

    if (parent.cmd.show_gitlab_system_notes != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-show_gitlab_system_notes:";
        bool_Print(parent.cmd.show_gitlab_system_notes, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.gcli_proc..Uninit
void command::gcli_proc_Uninit(command::gcli_proc& parent) {
    command::gcli_proc &row = parent; (void)row;

    // command.gcli_proc.gcli.Uninit (Exec)  //
    gcli_Kill(parent); // kill child, ensure forward progress
}

// --- command.mdbg.args.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::args_Addary(command::mdbg& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.args_elems && rhs.elems < parent.args_elems + parent.args_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.mdbg.args  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    args_Reserve(parent, nnew); // reserve space
    int at = parent.args_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.args_elems + at + i) algo::cstring(rhs[i]);
        parent.args_n++;
    }
    return algo::aryptr<algo::cstring>(parent.args_elems + at, nnew);
}

// --- command.mdbg.args.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::args_Alloc(command::mdbg& parent) {
    args_Reserve(parent, 1);
    int n  = parent.args_n;
    int at = n;
    algo::cstring *elems = parent.args_elems;
    new (elems + at) algo::cstring(""); // construct new element, default initializer
    parent.args_n = n+1;
    return elems[at];
}

// --- command.mdbg.args.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::args_AllocAt(command::mdbg& parent, int at) {
    args_Reserve(parent, 1);
    int n  = parent.args_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.mdbg.args  comment:'index out of range'");
    }
    algo::cstring *elems = parent.args_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(""); // construct element, default initializer
    parent.args_n = n+1;
    return elems[at];
}

// --- command.mdbg.args.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::args_AllocN(command::mdbg& parent, int n_elems) {
    args_Reserve(parent, n_elems);
    int old_n  = parent.args_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.args_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(""); // construct new element, default initialize
    }
    parent.args_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.mdbg.args.Remove
// Remove item by index. If index outside of range, do nothing.
void command::args_Remove(command::mdbg& parent, u32 i) {
    u32 lim = parent.args_n;
    algo::cstring *elems = parent.args_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.args_n = lim - 1;
    }
}

// --- command.mdbg.args.RemoveAll
void command::args_RemoveAll(command::mdbg& parent) {
    u32 n = parent.args_n;
    while (n > 0) {
        n -= 1;
        parent.args_elems[n].~cstring();
        parent.args_n = n;
    }
}

// --- command.mdbg.args.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::args_RemoveLast(command::mdbg& parent) {
    u64 n = parent.args_n;
    if (n > 0) {
        n -= 1;
        args_qFind(parent, u64(n)).~cstring();
        parent.args_n = n;
    }
}

// --- command.mdbg.args.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::args_AbsReserve(command::mdbg& parent, int n) {
    u32 old_max  = parent.args_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.args_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.mdbg.args  comment:'out of memory'");
        }
        parent.args_elems = (algo::cstring*)new_mem;
        parent.args_max = new_max;
    }
}

// --- command.mdbg.args.Setary
// Copy contents of RHS to PARENT.
void command::args_Setary(command::mdbg& parent, command::mdbg &rhs) {
    args_RemoveAll(parent);
    int nnew = rhs.args_n;
    args_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.args_elems + i) algo::cstring(args_qFind(rhs, i));
        parent.args_n = i + 1;
    }
}

// --- command.mdbg.args.Setary2
// Copy specified array into args, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::args_Setary(command::mdbg& parent, const algo::aryptr<algo::cstring> &rhs) {
    args_RemoveAll(parent);
    args_Addary(parent, rhs);
}

// --- command.mdbg.args.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::args_AllocNVal(command::mdbg& parent, int n_elems, const algo::cstring& val) {
    args_Reserve(parent, n_elems);
    int old_n  = parent.args_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.args_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.args_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.mdbg.args.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::args_ReadStrptrMaybe(command::mdbg& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = args_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        args_RemoveLast(parent);
    }
    return retval;
}

// --- command.mdbg.b.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::b_Addary(command::mdbg& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.b_elems && rhs.elems < parent.b_elems + parent.b_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.mdbg.b  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    b_Reserve(parent, nnew); // reserve space
    int at = parent.b_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.b_elems + at + i) algo::cstring(rhs[i]);
        parent.b_n++;
    }
    return algo::aryptr<algo::cstring>(parent.b_elems + at, nnew);
}

// --- command.mdbg.b.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::b_Alloc(command::mdbg& parent) {
    b_Reserve(parent, 1);
    int n  = parent.b_n;
    int at = n;
    algo::cstring *elems = parent.b_elems;
    new (elems + at) algo::cstring(""); // construct new element, default initializer
    parent.b_n = n+1;
    return elems[at];
}

// --- command.mdbg.b.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::b_AllocAt(command::mdbg& parent, int at) {
    b_Reserve(parent, 1);
    int n  = parent.b_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.mdbg.b  comment:'index out of range'");
    }
    algo::cstring *elems = parent.b_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(""); // construct element, default initializer
    parent.b_n = n+1;
    return elems[at];
}

// --- command.mdbg.b.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::b_AllocN(command::mdbg& parent, int n_elems) {
    b_Reserve(parent, n_elems);
    int old_n  = parent.b_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.b_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(""); // construct new element, default initialize
    }
    parent.b_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.mdbg.b.Remove
// Remove item by index. If index outside of range, do nothing.
void command::b_Remove(command::mdbg& parent, u32 i) {
    u32 lim = parent.b_n;
    algo::cstring *elems = parent.b_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.b_n = lim - 1;
    }
}

// --- command.mdbg.b.RemoveAll
void command::b_RemoveAll(command::mdbg& parent) {
    u32 n = parent.b_n;
    while (n > 0) {
        n -= 1;
        parent.b_elems[n].~cstring();
        parent.b_n = n;
    }
}

// --- command.mdbg.b.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::b_RemoveLast(command::mdbg& parent) {
    u64 n = parent.b_n;
    if (n > 0) {
        n -= 1;
        b_qFind(parent, u64(n)).~cstring();
        parent.b_n = n;
    }
}

// --- command.mdbg.b.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::b_AbsReserve(command::mdbg& parent, int n) {
    u32 old_max  = parent.b_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.b_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.mdbg.b  comment:'out of memory'");
        }
        parent.b_elems = (algo::cstring*)new_mem;
        parent.b_max = new_max;
    }
}

// --- command.mdbg.b.Setary
// Copy contents of RHS to PARENT.
void command::b_Setary(command::mdbg& parent, command::mdbg &rhs) {
    b_RemoveAll(parent);
    int nnew = rhs.b_n;
    b_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.b_elems + i) algo::cstring(b_qFind(rhs, i));
        parent.b_n = i + 1;
    }
}

// --- command.mdbg.b.Setary2
// Copy specified array into b, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::b_Setary(command::mdbg& parent, const algo::aryptr<algo::cstring> &rhs) {
    b_RemoveAll(parent);
    b_Addary(parent, rhs);
}

// --- command.mdbg.b.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::b_AllocNVal(command::mdbg& parent, int n_elems, const algo::cstring& val) {
    b_Reserve(parent, n_elems);
    int old_n  = parent.b_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.b_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.b_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.mdbg.b.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::b_ReadStrptrMaybe(command::mdbg& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = b_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        b_RemoveLast(parent);
    }
    return retval;
}

// --- command.mdbg..ReadFieldMaybe
bool command::mdbg_ReadFieldMaybe(command::mdbg& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_target: {
            retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_args: {
            retval = args_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_cfg: {
            retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval);
            break;
        }
        case command_FieldId_disas: {
            retval = bool_ReadStrptrMaybe(parent.disas, strval);
            break;
        }
        case command_FieldId_attach: {
            retval = bool_ReadStrptrMaybe(parent.attach, strval);
            break;
        }
        case command_FieldId_b: {
            retval = b_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_catchthrow: {
            retval = bool_ReadStrptrMaybe(parent.catchthrow, strval);
            break;
        }
        case command_FieldId_tui: {
            retval = bool_ReadStrptrMaybe(parent.tui, strval);
            break;
        }
        case command_FieldId_bcmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.bcmd, strval);
            break;
        }
        case command_FieldId_emacs: {
            retval = bool_ReadStrptrMaybe(parent.emacs, strval);
            break;
        }
        case command_FieldId_manywin: {
            retval = bool_ReadStrptrMaybe(parent.manywin, strval);
            break;
        }
        case command_FieldId_follow_child: {
            retval = bool_ReadStrptrMaybe(parent.follow_child, strval);
            break;
        }
        case command_FieldId_py: {
            retval = bool_ReadStrptrMaybe(parent.py, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.mdbg..ReadTupleMaybe
// Read fields of command::mdbg from attributes of ascii tuple TUPLE
bool command::mdbg_ReadTupleMaybe(command::mdbg &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = mdbg_GetAnon(parent, anon_idx++);
        }
        retval = mdbg_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.mdbg..Init
// Set all fields to initial values.
void command::mdbg_Init(command::mdbg& parent) {
    parent.in = algo::strptr("data");
    parent.args_elems 	= 0; // (command.mdbg.args)
    parent.args_n     	= 0; // (command.mdbg.args)
    parent.args_max   	= 0; // (command.mdbg.args)
    parent.cfg = algo::strptr("debug");
    parent.disas = bool(false);
    parent.attach = bool(false);
    parent.b_elems 	= 0; // (command.mdbg.b)
    parent.b_n     	= 0; // (command.mdbg.b)
    parent.b_max   	= 0; // (command.mdbg.b)
    parent.catchthrow = bool(true);
    parent.tui = bool(false);
    parent.bcmd = algo::strptr("");
    parent.emacs = bool(true);
    parent.manywin = bool(false);
    parent.follow_child = bool(false);
    parent.py = bool(false);
    parent.dry_run = bool(false);
}

// --- command.mdbg..Uninit
void command::mdbg_Uninit(command::mdbg& parent) {
    command::mdbg &row = parent; (void)row;

    // command.mdbg.b.Uninit (Tary)  //Set breakpoint, e.g. 'a.cpp:123 if cond1', 'func#3'
    // remove all elements from command.mdbg.b
    b_RemoveAll(parent);
    // free memory for Tary command.mdbg.b
    algo_lib::malloc_FreeMem(parent.b_elems, sizeof(algo::cstring)*parent.b_max); // (command.mdbg.b)

    // command.mdbg.args.Uninit (Tary)  //Additional module args
    // remove all elements from command.mdbg.args
    args_RemoveAll(parent);
    // free memory for Tary command.mdbg.args
    algo_lib::malloc_FreeMem(parent.args_elems, sizeof(algo::cstring)*parent.args_max); // (command.mdbg.args)
}

// --- command.mdbg..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::mdbg_ToCmdline(command::mdbg& row) {
    tempstr ret;
    ret << "bin/mdbg ";
    mdbg_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.mdbg..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.mdbg.Argv  printfmt:Auto
void command::mdbg_PrintArgv(command::mdbg& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    Smallstr16_Print(row.target, temp);
    str << " -target:";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(mdbg_args_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -args:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.cfg == "debug")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.cfg, temp);
        str << " -cfg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.disas == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.disas, temp);
        str << " -disas:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.attach == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.attach, temp);
        str << " -attach:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(mdbg_b_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -b:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.catchthrow == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.catchthrow, temp);
        str << " -catchthrow:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tui == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tui, temp);
        str << " -tui:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.bcmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.bcmd, temp);
        str << " -bcmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.emacs == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.emacs, temp);
        str << " -emacs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.manywin == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.manywin, temp);
        str << " -manywin:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.follow_child == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.follow_child, temp);
        str << " -follow_child:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.py == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.py, temp);
        str << " -py:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.mdbg..GetAnon
algo::strptr command::mdbg_GetAnon(command::mdbg &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        default: return strptr("args", 4);
    }
}

// --- command.mdbg..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::mdbg_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_target: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_args: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_cfg: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_disas: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_attach: { // bool: no argument required but value may be specified as disas:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_b: { // bool: no argument required but value may be specified as attach:Y
            *out_anon = false;
        } break;
        case command_FieldId_catchthrow: { // bool: no argument required but value may be specified as attach:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_tui: { // bool: no argument required but value may be specified as catchthrow:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_bcmd: { // bool: no argument required but value may be specified as tui:Y
            *out_anon = false;
        } break;
        case command_FieldId_emacs: { // bool: no argument required but value may be specified as tui:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_manywin: { // bool: no argument required but value may be specified as emacs:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_follow_child: { // bool: no argument required but value may be specified as manywin:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_py: { // bool: no argument required but value may be specified as follow_child:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as py:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.mdbg_proc.mdbg.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::mdbg_Start(command::mdbg_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(mdbg_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(mdbg_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= mdbg_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.mdbg_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.mdbg_proc.mdbg.StartRead
// Start subprocess & Read output
algo::Fildes command::mdbg_StartRead(command::mdbg_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    mdbg_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.mdbg_proc.mdbg.Kill
// Kill subprocess and wait
void command::mdbg_Kill(command::mdbg_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        mdbg_Wait(parent);
    }
}

// --- command.mdbg_proc.mdbg.Wait
// Wait for subprocess to return
void command::mdbg_Wait(command::mdbg_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.mdbg_proc.mdbg.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::mdbg_Exec(command::mdbg_proc& parent) {
    mdbg_Start(parent);
    mdbg_Wait(parent);
    return parent.status;
}

// --- command.mdbg_proc.mdbg.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::mdbg_ExecX(command::mdbg_proc& parent) {
    int rc = mdbg_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",mdbg_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.mdbg_proc.mdbg.Execv
// Call execv()
// Call execv with specified parameters
int command::mdbg_Execv(command::mdbg_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    mdbg_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.mdbg_proc.mdbg.ToCmdline
algo::tempstr command::mdbg_ToCmdline(command::mdbg_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::mdbg_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.mdbg_proc.mdbg.ToArgv
// Form array from the command line
void command::mdbg_ToArgv(command::mdbg_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        Smallstr16_Print(parent.cmd.target, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }
    ind_beg(command::mdbg_args_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-args:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.cfg != "debug") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cfg:";
        Smallstr50_Print(parent.cmd.cfg, *arg);
    }

    if (parent.cmd.disas != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-disas:";
        bool_Print(parent.cmd.disas, *arg);
    }

    if (parent.cmd.attach != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-attach:";
        bool_Print(parent.cmd.attach, *arg);
    }
    ind_beg(command::mdbg_b_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-b:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.catchthrow != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-catchthrow:";
        bool_Print(parent.cmd.catchthrow, *arg);
    }

    if (parent.cmd.tui != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-tui:";
        bool_Print(parent.cmd.tui, *arg);
    }

    if (parent.cmd.bcmd != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-bcmd:";
        cstring_Print(parent.cmd.bcmd, *arg);
    }

    if (parent.cmd.emacs != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-emacs:";
        bool_Print(parent.cmd.emacs, *arg);
    }

    if (parent.cmd.manywin != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-manywin:";
        bool_Print(parent.cmd.manywin, *arg);
    }

    if (parent.cmd.follow_child != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-follow_child:";
        bool_Print(parent.cmd.follow_child, *arg);
    }

    if (parent.cmd.py != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-py:";
        bool_Print(parent.cmd.py, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.mdbg_proc..Uninit
void command::mdbg_proc_Uninit(command::mdbg_proc& parent) {
    command::mdbg_proc &row = parent; (void)row;

    // command.mdbg_proc.mdbg.Uninit (Exec)  //
    mdbg_Kill(parent); // kill child, ensure forward progress
}

// --- command.mysql2ssim..ReadFieldMaybe
bool command::mysql2ssim_ReadFieldMaybe(command::mysql2ssim& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_writessimfile: {
            retval = bool_ReadStrptrMaybe(parent.writessimfile, strval);
            break;
        }
        case command_FieldId_url: {
            retval = algo::cstring_ReadStrptrMaybe(parent.url, strval);
            break;
        }
        case command_FieldId_tables: {
            retval = algo::cstring_ReadStrptrMaybe(parent.tables, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = bool_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_pretty: {
            retval = bool_ReadStrptrMaybe(parent.pretty, strval);
            break;
        }
        case command_FieldId_nologo: {
            retval = bool_ReadStrptrMaybe(parent.nologo, strval);
            break;
        }
        case command_FieldId_baddbok: {
            retval = bool_ReadStrptrMaybe(parent.baddbok, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.mysql2ssim..ReadTupleMaybe
// Read fields of command::mysql2ssim from attributes of ascii tuple TUPLE
bool command::mysql2ssim_ReadTupleMaybe(command::mysql2ssim &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = mysql2ssim_GetAnon(parent, anon_idx++);
        }
        retval = mysql2ssim_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.mysql2ssim..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::mysql2ssim_ToCmdline(command::mysql2ssim& row) {
    tempstr ret;
    ret << "bin/mysql2ssim ";
    mysql2ssim_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.mysql2ssim..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.mysql2ssim.Argv  printfmt:Auto
void command::mysql2ssim_PrintArgv(command::mysql2ssim& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.writessimfile == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.writessimfile, temp);
        str << " -writessimfile:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.url, temp);
    str << " -url:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    cstring_Print(row.tables, temp);
    str << " -tables:";
    strptr_PrintBash(temp,str);
    if (!(row.schema == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pretty == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.pretty, temp);
        str << " -pretty:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nologo == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.nologo, temp);
        str << " -nologo:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.baddbok == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.baddbok, temp);
        str << " -baddbok:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.mysql2ssim..GetAnon
algo::strptr command::mysql2ssim_GetAnon(command::mysql2ssim &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("url", 3);
        case(1): return strptr("tables", 6);
        default: return algo::strptr();
    }
}

// --- command.mysql2ssim..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::mysql2ssim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_writessimfile: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_url: { // bool: no argument required but value may be specified as writessimfile:Y
            *out_anon = true;
        } break;
        case command_FieldId_tables: { // bool: no argument required but value may be specified as writessimfile:Y
            *out_anon = true;
        } break;
        case command_FieldId_schema: { // bool: no argument required but value may be specified as writessimfile:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_in: { // bool: no argument required but value may be specified as schema:Y
            *out_anon = false;
        } break;
        case command_FieldId_pretty: { // bool: no argument required but value may be specified as schema:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_nologo: { // bool: no argument required but value may be specified as pretty:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_baddbok: { // bool: no argument required but value may be specified as nologo:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.mysql2ssim_proc.mysql2ssim.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::mysql2ssim_Start(command::mysql2ssim_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(mysql2ssim_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(mysql2ssim_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= mysql2ssim_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.mysql2ssim_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.mysql2ssim_proc.mysql2ssim.StartRead
// Start subprocess & Read output
algo::Fildes command::mysql2ssim_StartRead(command::mysql2ssim_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    mysql2ssim_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.mysql2ssim_proc.mysql2ssim.Kill
// Kill subprocess and wait
void command::mysql2ssim_Kill(command::mysql2ssim_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        mysql2ssim_Wait(parent);
    }
}

// --- command.mysql2ssim_proc.mysql2ssim.Wait
// Wait for subprocess to return
void command::mysql2ssim_Wait(command::mysql2ssim_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.mysql2ssim_proc.mysql2ssim.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::mysql2ssim_Exec(command::mysql2ssim_proc& parent) {
    mysql2ssim_Start(parent);
    mysql2ssim_Wait(parent);
    return parent.status;
}

// --- command.mysql2ssim_proc.mysql2ssim.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::mysql2ssim_ExecX(command::mysql2ssim_proc& parent) {
    int rc = mysql2ssim_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",mysql2ssim_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.mysql2ssim_proc.mysql2ssim.Execv
// Call execv()
// Call execv with specified parameters
int command::mysql2ssim_Execv(command::mysql2ssim_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    mysql2ssim_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.mysql2ssim_proc.mysql2ssim.ToCmdline
algo::tempstr command::mysql2ssim_ToCmdline(command::mysql2ssim_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::mysql2ssim_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.mysql2ssim_proc.mysql2ssim.ToArgv
// Form array from the command line
void command::mysql2ssim_ToArgv(command::mysql2ssim_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.writessimfile != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-writessimfile:";
        bool_Print(parent.cmd.writessimfile, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-url:";
        cstring_Print(parent.cmd.url, *arg);
    }

    if (parent.cmd.tables != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-tables:";
        cstring_Print(parent.cmd.tables, *arg);
    }

    if (parent.cmd.schema != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        bool_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.pretty != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pretty:";
        bool_Print(parent.cmd.pretty, *arg);
    }

    if (parent.cmd.nologo != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nologo:";
        bool_Print(parent.cmd.nologo, *arg);
    }

    if (parent.cmd.baddbok != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-baddbok:";
        bool_Print(parent.cmd.baddbok, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.mysql2ssim_proc..Uninit
void command::mysql2ssim_proc_Uninit(command::mysql2ssim_proc& parent) {
    command::mysql2ssim_proc &row = parent; (void)row;

    // command.mysql2ssim_proc.mysql2ssim.Uninit (Exec)  //
    mysql2ssim_Kill(parent); // kill child, ensure forward progress
}

// --- command.orgfile.dedup.Print
// Print back to string
void command::dedup_Print(command::orgfile& parent, algo::cstring &out) {
    Regx_Print(parent.dedup, out);
}

// --- command.orgfile.dedup.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::dedup_ReadStrptrMaybe(command::orgfile& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.dedup, in, true);
    return retval;
}

// --- command.orgfile..ReadFieldMaybe
bool command::orgfile_ReadFieldMaybe(command::orgfile& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_move: {
            retval = algo::cstring_ReadStrptrMaybe(parent.move, strval);
            break;
        }
        case command_FieldId_dedup: {
            retval = dedup_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_commit: {
            retval = bool_ReadStrptrMaybe(parent.commit, strval);
            break;
        }
        case command_FieldId_undo: {
            retval = bool_ReadStrptrMaybe(parent.undo, strval);
            break;
        }
        case command_FieldId_hash: {
            retval = algo::cstring_ReadStrptrMaybe(parent.hash, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.orgfile..ReadTupleMaybe
// Read fields of command::orgfile from attributes of ascii tuple TUPLE
bool command::orgfile_ReadTupleMaybe(command::orgfile &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = orgfile_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.orgfile..Init
// Set all fields to initial values.
void command::orgfile_Init(command::orgfile& parent) {
    parent.in = algo::strptr("data");
    parent.move = algo::strptr("");
    Regx_ReadSql(parent.dedup, "", true);
    parent.commit = bool(false);
    parent.undo = bool(false);
    parent.hash = algo::strptr("sha1");
}

// --- command.orgfile..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::orgfile_ToCmdline(command::orgfile& row) {
    tempstr ret;
    ret << "bin/orgfile ";
    orgfile_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.orgfile..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.orgfile.Argv  printfmt:Tuple
void command::orgfile_PrintArgv(command::orgfile& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.move == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.move, temp);
        str << " -move:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dedup.expr == "")) {
        ch_RemoveAll(temp);
        command::dedup_Print(const_cast<command::orgfile&>(row), temp);
        str << " -dedup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.commit == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.commit, temp);
        str << " -commit:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.undo == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.undo, temp);
        str << " -undo:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.hash == "sha1")) {
        ch_RemoveAll(temp);
        cstring_Print(row.hash, temp);
        str << " -hash:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.orgfile..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::orgfile_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_move: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_dedup: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_commit: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_undo: { // bool: no argument required but value may be specified as commit:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_hash: { // bool: no argument required but value may be specified as undo:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.orgfile_proc.orgfile.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::orgfile_Start(command::orgfile_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(orgfile_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(orgfile_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= orgfile_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.orgfile_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.orgfile_proc.orgfile.StartRead
// Start subprocess & Read output
algo::Fildes command::orgfile_StartRead(command::orgfile_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    orgfile_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.orgfile_proc.orgfile.Kill
// Kill subprocess and wait
void command::orgfile_Kill(command::orgfile_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        orgfile_Wait(parent);
    }
}

// --- command.orgfile_proc.orgfile.Wait
// Wait for subprocess to return
void command::orgfile_Wait(command::orgfile_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.orgfile_proc.orgfile.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::orgfile_Exec(command::orgfile_proc& parent) {
    orgfile_Start(parent);
    orgfile_Wait(parent);
    return parent.status;
}

// --- command.orgfile_proc.orgfile.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::orgfile_ExecX(command::orgfile_proc& parent) {
    int rc = orgfile_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",orgfile_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.orgfile_proc.orgfile.Execv
// Call execv()
// Call execv with specified parameters
int command::orgfile_Execv(command::orgfile_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    orgfile_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.orgfile_proc.orgfile.ToCmdline
algo::tempstr command::orgfile_ToCmdline(command::orgfile_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::orgfile_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.orgfile_proc.orgfile.ToArgv
// Form array from the command line
void command::orgfile_ToArgv(command::orgfile_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.move != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-move:";
        cstring_Print(parent.cmd.move, *arg);
    }

    if (parent.cmd.dedup.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dedup:";
        command::dedup_Print(parent.cmd, *arg);
    }

    if (parent.cmd.commit != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-commit:";
        bool_Print(parent.cmd.commit, *arg);
    }

    if (parent.cmd.undo != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-undo:";
        bool_Print(parent.cmd.undo, *arg);
    }

    if (parent.cmd.hash != "sha1") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-hash:";
        cstring_Print(parent.cmd.hash, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.orgfile_proc..Uninit
void command::orgfile_proc_Uninit(command::orgfile_proc& parent) {
    command::orgfile_proc &row = parent; (void)row;

    // command.orgfile_proc.orgfile.Uninit (Exec)  //
    orgfile_Kill(parent); // kill child, ensure forward progress
}

// --- command.samp_regx.style.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::style_ToCstr(const command::samp_regx& parent) {
    const char *ret = NULL;
    switch(style_GetEnum(parent)) {
        case command_samp_regx_style_acr   : ret = "acr";  break;
        case command_samp_regx_style_shell : ret = "shell";  break;
        case command_samp_regx_style_classic: ret = "classic";  break;
        case command_samp_regx_style_literal: ret = "literal";  break;
    }
    return ret;
}

// --- command.samp_regx.style.Print
// Convert style to a string. First, attempt conversion to a known string.
// If no string matches, print style as a numeric value.
void command::style_Print(const command::samp_regx& parent, algo::cstring &lhs) {
    const char *strval = style_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.style;
    }
}

// --- command.samp_regx.style.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::style_SetStrptrMaybe(command::samp_regx& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','c','r'): {
                    style_SetEnum(parent,command_samp_regx_style_acr); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('s','h','e','l','l'): {
                    style_SetEnum(parent,command_samp_regx_style_shell); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('c','l','a','s','s','i','c'): {
                    style_SetEnum(parent,command_samp_regx_style_classic); ret = true; break;
                }
                case LE_STR7('l','i','t','e','r','a','l'): {
                    style_SetEnum(parent,command_samp_regx_style_literal); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.samp_regx.style.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::style_SetStrptr(command::samp_regx& parent, algo::strptr rhs, command_samp_regx_style_Enum dflt) {
    if (!style_SetStrptrMaybe(parent,rhs)) style_SetEnum(parent,dflt);
}

// --- command.samp_regx.style.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::style_ReadStrptrMaybe(command::samp_regx& parent, algo::strptr rhs) {
    bool retval = false;
    retval = style_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.style,rhs);
    }
    return retval;
}

// --- command.samp_regx..ReadFieldMaybe
bool command::samp_regx_ReadFieldMaybe(command::samp_regx& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_expr: {
            retval = algo::cstring_ReadStrptrMaybe(parent.expr, strval);
            break;
        }
        case command_FieldId_style: {
            retval = style_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_match: {
            retval = bool_ReadStrptrMaybe(parent.match, strval);
            break;
        }
        case command_FieldId_string: {
            retval = algo::cstring_ReadStrptrMaybe(parent.string, strval);
            break;
        }
        case command_FieldId_show: {
            retval = bool_ReadStrptrMaybe(parent.show, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.samp_regx..ReadTupleMaybe
// Read fields of command::samp_regx from attributes of ascii tuple TUPLE
bool command::samp_regx_ReadTupleMaybe(command::samp_regx &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = samp_regx_GetAnon(parent, anon_idx++);
        }
        retval = samp_regx_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.samp_regx..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::samp_regx_ToCmdline(command::samp_regx& row) {
    tempstr ret;
    ret << "bin/samp_regx ";
    samp_regx_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.samp_regx..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.samp_regx.Argv  printfmt:Tuple
void command::samp_regx_PrintArgv(command::samp_regx& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.expr, temp);
    str << " -expr:";
    strptr_PrintBash(temp,str);
    if (!(row.style == 0)) {
        ch_RemoveAll(temp);
        command::style_Print(const_cast<command::samp_regx&>(row), temp);
        str << " -style:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.match == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.match, temp);
        str << " -match:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.string, temp);
    str << " -string:";
    strptr_PrintBash(temp,str);
    if (!(row.show == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.show, temp);
        str << " -show:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.samp_regx..GetAnon
algo::strptr command::samp_regx_GetAnon(command::samp_regx &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("expr", 4);
        case(1): return strptr("string", 6);
        default: return algo::strptr();
    }
}

// --- command.samp_regx..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::samp_regx_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_expr: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_style: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_match: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_string: { // bool: no argument required but value may be specified as match:Y
            *out_anon = true;
        } break;
        case command_FieldId_show: { // bool: no argument required but value may be specified as match:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.samp_regx_proc.samp_regx.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::samp_regx_Start(command::samp_regx_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(samp_regx_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(samp_regx_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= samp_regx_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.samp_regx_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.samp_regx_proc.samp_regx.StartRead
// Start subprocess & Read output
algo::Fildes command::samp_regx_StartRead(command::samp_regx_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    samp_regx_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.samp_regx_proc.samp_regx.Kill
// Kill subprocess and wait
void command::samp_regx_Kill(command::samp_regx_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        samp_regx_Wait(parent);
    }
}

// --- command.samp_regx_proc.samp_regx.Wait
// Wait for subprocess to return
void command::samp_regx_Wait(command::samp_regx_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.samp_regx_proc.samp_regx.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::samp_regx_Exec(command::samp_regx_proc& parent) {
    samp_regx_Start(parent);
    samp_regx_Wait(parent);
    return parent.status;
}

// --- command.samp_regx_proc.samp_regx.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::samp_regx_ExecX(command::samp_regx_proc& parent) {
    int rc = samp_regx_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",samp_regx_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.samp_regx_proc.samp_regx.Execv
// Call execv()
// Call execv with specified parameters
int command::samp_regx_Execv(command::samp_regx_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    samp_regx_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.samp_regx_proc.samp_regx.ToCmdline
algo::tempstr command::samp_regx_ToCmdline(command::samp_regx_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::samp_regx_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.samp_regx_proc.samp_regx.ToArgv
// Form array from the command line
void command::samp_regx_ToArgv(command::samp_regx_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-expr:";
        cstring_Print(parent.cmd.expr, *arg);
    }

    if (parent.cmd.style != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-style:";
        command::style_Print(parent.cmd, *arg);
    }

    if (parent.cmd.match != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-match:";
        bool_Print(parent.cmd.match, *arg);
    }

    if (parent.cmd.string != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-string:";
        cstring_Print(parent.cmd.string, *arg);
    }

    if (parent.cmd.show != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-show:";
        bool_Print(parent.cmd.show, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.samp_regx_proc..Uninit
void command::samp_regx_proc_Uninit(command::samp_regx_proc& parent) {
    command::samp_regx_proc &row = parent; (void)row;

    // command.samp_regx_proc.samp_regx.Uninit (Exec)  //
    samp_regx_Kill(parent); // kill child, ensure forward progress
}

// --- command.sandbox.name.Print
// Print back to string
void command::name_Print(command::sandbox& parent, algo::cstring &out) {
    Regx_Print(parent.name, out);
}

// --- command.sandbox.name.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::name_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.name, in, true);
    return retval;
}

// --- command.sandbox.cmd.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::cmd_Addary(command::sandbox& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.cmd_elems && rhs.elems < parent.cmd_elems + parent.cmd_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.sandbox.cmd  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    cmd_Reserve(parent, nnew); // reserve space
    int at = parent.cmd_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.cmd_elems + at + i) algo::cstring(rhs[i]);
        parent.cmd_n++;
    }
    return algo::aryptr<algo::cstring>(parent.cmd_elems + at, nnew);
}

// --- command.sandbox.cmd.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::cmd_Alloc(command::sandbox& parent) {
    cmd_Reserve(parent, 1);
    int n  = parent.cmd_n;
    int at = n;
    algo::cstring *elems = parent.cmd_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.cmd_n = n+1;
    return elems[at];
}

// --- command.sandbox.cmd.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::cmd_AllocAt(command::sandbox& parent, int at) {
    cmd_Reserve(parent, 1);
    int n  = parent.cmd_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.sandbox.cmd  comment:'index out of range'");
    }
    algo::cstring *elems = parent.cmd_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.cmd_n = n+1;
    return elems[at];
}

// --- command.sandbox.cmd.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::cmd_AllocN(command::sandbox& parent, int n_elems) {
    cmd_Reserve(parent, n_elems);
    int old_n  = parent.cmd_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.cmd_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.cmd_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.sandbox.cmd.Remove
// Remove item by index. If index outside of range, do nothing.
void command::cmd_Remove(command::sandbox& parent, u32 i) {
    u32 lim = parent.cmd_n;
    algo::cstring *elems = parent.cmd_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.cmd_n = lim - 1;
    }
}

// --- command.sandbox.cmd.RemoveAll
void command::cmd_RemoveAll(command::sandbox& parent) {
    u32 n = parent.cmd_n;
    while (n > 0) {
        n -= 1;
        parent.cmd_elems[n].~cstring();
        parent.cmd_n = n;
    }
}

// --- command.sandbox.cmd.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::cmd_RemoveLast(command::sandbox& parent) {
    u64 n = parent.cmd_n;
    if (n > 0) {
        n -= 1;
        cmd_qFind(parent, u64(n)).~cstring();
        parent.cmd_n = n;
    }
}

// --- command.sandbox.cmd.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::cmd_AbsReserve(command::sandbox& parent, int n) {
    u32 old_max  = parent.cmd_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.cmd_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.sandbox.cmd  comment:'out of memory'");
        }
        parent.cmd_elems = (algo::cstring*)new_mem;
        parent.cmd_max = new_max;
    }
}

// --- command.sandbox.cmd.Setary
// Copy contents of RHS to PARENT.
void command::cmd_Setary(command::sandbox& parent, command::sandbox &rhs) {
    cmd_RemoveAll(parent);
    int nnew = rhs.cmd_n;
    cmd_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.cmd_elems + i) algo::cstring(cmd_qFind(rhs, i));
        parent.cmd_n = i + 1;
    }
}

// --- command.sandbox.cmd.Setary2
// Copy specified array into cmd, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::cmd_Setary(command::sandbox& parent, const algo::aryptr<algo::cstring> &rhs) {
    cmd_RemoveAll(parent);
    cmd_Addary(parent, rhs);
}

// --- command.sandbox.cmd.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::cmd_AllocNVal(command::sandbox& parent, int n_elems, const algo::cstring& val) {
    cmd_Reserve(parent, n_elems);
    int old_n  = parent.cmd_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.cmd_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.cmd_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.sandbox.cmd.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::cmd_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = cmd_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        cmd_RemoveLast(parent);
    }
    return retval;
}

// --- command.sandbox.files.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::files_Addary(command::sandbox& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.files_elems && rhs.elems < parent.files_elems + parent.files_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.sandbox.files  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    files_Reserve(parent, nnew); // reserve space
    int at = parent.files_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.files_elems + at + i) algo::cstring(rhs[i]);
        parent.files_n++;
    }
    return algo::aryptr<algo::cstring>(parent.files_elems + at, nnew);
}

// --- command.sandbox.files.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::files_Alloc(command::sandbox& parent) {
    files_Reserve(parent, 1);
    int n  = parent.files_n;
    int at = n;
    algo::cstring *elems = parent.files_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.files_n = n+1;
    return elems[at];
}

// --- command.sandbox.files.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::files_AllocAt(command::sandbox& parent, int at) {
    files_Reserve(parent, 1);
    int n  = parent.files_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.sandbox.files  comment:'index out of range'");
    }
    algo::cstring *elems = parent.files_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.files_n = n+1;
    return elems[at];
}

// --- command.sandbox.files.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::files_AllocN(command::sandbox& parent, int n_elems) {
    files_Reserve(parent, n_elems);
    int old_n  = parent.files_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.files_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.files_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.sandbox.files.Remove
// Remove item by index. If index outside of range, do nothing.
void command::files_Remove(command::sandbox& parent, u32 i) {
    u32 lim = parent.files_n;
    algo::cstring *elems = parent.files_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.files_n = lim - 1;
    }
}

// --- command.sandbox.files.RemoveAll
void command::files_RemoveAll(command::sandbox& parent) {
    u32 n = parent.files_n;
    while (n > 0) {
        n -= 1;
        parent.files_elems[n].~cstring();
        parent.files_n = n;
    }
}

// --- command.sandbox.files.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::files_RemoveLast(command::sandbox& parent) {
    u64 n = parent.files_n;
    if (n > 0) {
        n -= 1;
        files_qFind(parent, u64(n)).~cstring();
        parent.files_n = n;
    }
}

// --- command.sandbox.files.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::files_AbsReserve(command::sandbox& parent, int n) {
    u32 old_max  = parent.files_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.files_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.sandbox.files  comment:'out of memory'");
        }
        parent.files_elems = (algo::cstring*)new_mem;
        parent.files_max = new_max;
    }
}

// --- command.sandbox.files.Setary
// Copy contents of RHS to PARENT.
void command::files_Setary(command::sandbox& parent, command::sandbox &rhs) {
    files_RemoveAll(parent);
    int nnew = rhs.files_n;
    files_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.files_elems + i) algo::cstring(files_qFind(rhs, i));
        parent.files_n = i + 1;
    }
}

// --- command.sandbox.files.Setary2
// Copy specified array into files, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::files_Setary(command::sandbox& parent, const algo::aryptr<algo::cstring> &rhs) {
    files_RemoveAll(parent);
    files_Addary(parent, rhs);
}

// --- command.sandbox.files.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::files_AllocNVal(command::sandbox& parent, int n_elems, const algo::cstring& val) {
    files_Reserve(parent, n_elems);
    int old_n  = parent.files_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.files_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.files_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.sandbox.files.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::files_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = files_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        files_RemoveLast(parent);
    }
    return retval;
}

// --- command.sandbox..ReadFieldMaybe
bool command::sandbox_ReadFieldMaybe(command::sandbox& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_name: {
            retval = name_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_create: {
            retval = bool_ReadStrptrMaybe(parent.create, strval);
            break;
        }
        case command_FieldId_list: {
            retval = bool_ReadStrptrMaybe(parent.list, strval);
            break;
        }
        case command_FieldId_reset: {
            retval = bool_ReadStrptrMaybe(parent.reset, strval);
            break;
        }
        case command_FieldId_clean: {
            retval = bool_ReadStrptrMaybe(parent.clean, strval);
            break;
        }
        case command_FieldId_shell: {
            retval = bool_ReadStrptrMaybe(parent.shell, strval);
            break;
        }
        case command_FieldId_del: {
            retval = bool_ReadStrptrMaybe(parent.del, strval);
            break;
        }
        case command_FieldId_gc: {
            retval = bool_ReadStrptrMaybe(parent.gc, strval);
            break;
        }
        case command_FieldId_cmd: {
            retval = cmd_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_diff: {
            retval = bool_ReadStrptrMaybe(parent.diff, strval);
            break;
        }
        case command_FieldId_files: {
            retval = files_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_refs: {
            retval = algo::cstring_ReadStrptrMaybe(parent.refs, strval);
            break;
        }
        case command_FieldId_q: {
            retval = bool_ReadStrptrMaybe(parent.q, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.sandbox..ReadTupleMaybe
// Read fields of command::sandbox from attributes of ascii tuple TUPLE
bool command::sandbox_ReadTupleMaybe(command::sandbox &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = sandbox_GetAnon(parent, anon_idx++);
        }
        retval = sandbox_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.sandbox..Init
// Set all fields to initial values.
void command::sandbox_Init(command::sandbox& parent) {
    parent.in = algo::strptr("data");
    parent.create = bool(false);
    parent.list = bool(false);
    parent.reset = bool(false);
    parent.clean = bool(false);
    parent.shell = bool(false);
    parent.del = bool(false);
    parent.gc = bool(false);
    parent.cmd_elems 	= 0; // (command.sandbox.cmd)
    parent.cmd_n     	= 0; // (command.sandbox.cmd)
    parent.cmd_max   	= 0; // (command.sandbox.cmd)
    parent.diff = bool(false);
    parent.files_elems 	= 0; // (command.sandbox.files)
    parent.files_n     	= 0; // (command.sandbox.files)
    parent.files_max   	= 0; // (command.sandbox.files)
    parent.refs = algo::strptr("HEAD");
    parent.q = bool(false);
}

// --- command.sandbox..Uninit
void command::sandbox_Uninit(command::sandbox& parent) {
    command::sandbox &row = parent; (void)row;

    // command.sandbox.files.Uninit (Tary)  //Shell regx to diff
    // remove all elements from command.sandbox.files
    files_RemoveAll(parent);
    // free memory for Tary command.sandbox.files
    algo_lib::malloc_FreeMem(parent.files_elems, sizeof(algo::cstring)*parent.files_max); // (command.sandbox.files)

    // command.sandbox.cmd.Uninit (Tary)  //Command to execute in sandbox
    // remove all elements from command.sandbox.cmd
    cmd_RemoveAll(parent);
    // free memory for Tary command.sandbox.cmd
    algo_lib::malloc_FreeMem(parent.cmd_elems, sizeof(algo::cstring)*parent.cmd_max); // (command.sandbox.cmd)
}

// --- command.sandbox..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::sandbox_ToCmdline(command::sandbox& row) {
    tempstr ret;
    ret << "bin/sandbox ";
    sandbox_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.sandbox..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.sandbox.Argv  printfmt:Tuple
void command::sandbox_PrintArgv(command::sandbox& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::name_Print(const_cast<command::sandbox&>(row), temp);
    str << " -name:";
    strptr_PrintBash(temp,str);
    if (!(row.create == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.create, temp);
        str << " -create:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.reset == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.reset, temp);
        str << " -reset:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.clean == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.clean, temp);
        str << " -clean:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.shell == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.shell, temp);
        str << " -shell:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.del == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.del, temp);
        str << " -del:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gc, temp);
        str << " -gc:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(sandbox_cmd_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.diff == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.diff, temp);
        str << " -diff:";
        strptr_PrintBash(temp,str);
    }
    ind_beg(sandbox_files_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -files:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.refs == "HEAD")) {
        ch_RemoveAll(temp);
        cstring_Print(row.refs, temp);
        str << " -refs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.q == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.q, temp);
        str << " -q:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.sandbox..GetAnon
algo::strptr command::sandbox_GetAnon(command::sandbox &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("name", 4);
        default: return strptr("cmd", 3);
    }
}

// --- command.sandbox..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::sandbox_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_name: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_create: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_list: { // bool: no argument required but value may be specified as create:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_reset: { // bool: no argument required but value may be specified as list:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_clean: { // bool: no argument required but value may be specified as reset:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_shell: { // bool: no argument required but value may be specified as clean:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_del: { // bool: no argument required but value may be specified as shell:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_gc: { // bool: no argument required but value may be specified as del:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_cmd: { // bool: no argument required but value may be specified as gc:Y
            *out_anon = true;
        } break;
        case command_FieldId_diff: { // bool: no argument required but value may be specified as gc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_files: { // bool: no argument required but value may be specified as diff:Y
            *out_anon = false;
        } break;
        case command_FieldId_refs: { // bool: no argument required but value may be specified as diff:Y
            *out_anon = false;
        } break;
        case command_FieldId_q: { // bool: no argument required but value may be specified as diff:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.sandbox_proc.sandbox.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::sandbox_Start(command::sandbox_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(sandbox_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(sandbox_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= sandbox_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.sandbox_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.sandbox_proc.sandbox.StartRead
// Start subprocess & Read output
algo::Fildes command::sandbox_StartRead(command::sandbox_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    sandbox_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.sandbox_proc.sandbox.Kill
// Kill subprocess and wait
void command::sandbox_Kill(command::sandbox_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        sandbox_Wait(parent);
    }
}

// --- command.sandbox_proc.sandbox.Wait
// Wait for subprocess to return
void command::sandbox_Wait(command::sandbox_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.sandbox_proc.sandbox.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::sandbox_Exec(command::sandbox_proc& parent) {
    sandbox_Start(parent);
    sandbox_Wait(parent);
    return parent.status;
}

// --- command.sandbox_proc.sandbox.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::sandbox_ExecX(command::sandbox_proc& parent) {
    int rc = sandbox_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",sandbox_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.sandbox_proc.sandbox.Execv
// Call execv()
// Call execv with specified parameters
int command::sandbox_Execv(command::sandbox_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    sandbox_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.sandbox_proc.sandbox.ToCmdline
algo::tempstr command::sandbox_ToCmdline(command::sandbox_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::sandbox_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.sandbox_proc.sandbox.ToArgv
// Form array from the command line
void command::sandbox_ToArgv(command::sandbox_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-name:";
        command::name_Print(parent.cmd, *arg);
    }

    if (parent.cmd.create != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-create:";
        bool_Print(parent.cmd.create, *arg);
    }

    if (parent.cmd.list != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-list:";
        bool_Print(parent.cmd.list, *arg);
    }

    if (parent.cmd.reset != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-reset:";
        bool_Print(parent.cmd.reset, *arg);
    }

    if (parent.cmd.clean != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-clean:";
        bool_Print(parent.cmd.clean, *arg);
    }

    if (parent.cmd.shell != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-shell:";
        bool_Print(parent.cmd.shell, *arg);
    }

    if (parent.cmd.del != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-del:";
        bool_Print(parent.cmd.del, *arg);
    }

    if (parent.cmd.gc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gc:";
        bool_Print(parent.cmd.gc, *arg);
    }
    ind_beg(command::sandbox_cmd_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmd:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.diff != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-diff:";
        bool_Print(parent.cmd.diff, *arg);
    }
    ind_beg(command::sandbox_files_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-files:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.refs != "HEAD") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-refs:";
        cstring_Print(parent.cmd.refs, *arg);
    }

    if (parent.cmd.q != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-q:";
        bool_Print(parent.cmd.q, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.sandbox_proc..Uninit
void command::sandbox_proc_Uninit(command::sandbox_proc& parent) {
    command::sandbox_proc &row = parent; (void)row;

    // command.sandbox_proc.sandbox.Uninit (Exec)  //
    sandbox_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_func.target.Print
// Print back to string
void command::target_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.src_func.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.target, in, true);
    return retval;
}

// --- command.src_func.name.Print
// Print back to string
void command::name_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.name, out);
}

// --- command.src_func.name.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::name_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.name, in, true);
    return retval;
}

// --- command.src_func.body.Print
// Print back to string
void command::body_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.body, out);
}

// --- command.src_func.body.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::body_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.body, in, true);
    return retval;
}

// --- command.src_func.targsrc.Print
// Print back to string
void command::targsrc_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.targsrc, out);
}

// --- command.src_func.targsrc.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::targsrc_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.targsrc, in, true);
    return retval;
}

// --- command.src_func.func.Print
// Print back to string
void command::func_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.func, out);
}

// --- command.src_func.func.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::func_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.func, in, true);
    return retval;
}

// --- command.src_func.comment.Print
// Print back to string
void command::comment_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.comment, out);
}

// --- command.src_func.comment.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::comment_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.comment, in, true);
    return retval;
}

// --- command.src_func..ReadFieldMaybe
bool command::src_func_ReadFieldMaybe(command::src_func& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_target: {
            retval = target_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_name: {
            retval = name_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_body: {
            retval = body_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_targsrc: {
            retval = targsrc_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_func: {
            retval = func_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_comment: {
            retval = comment_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_nextfile: {
            retval = algo::Smallstr200_ReadStrptrMaybe(parent.nextfile, strval);
            break;
        }
        case command_FieldId_other: {
            retval = bool_ReadStrptrMaybe(parent.other, strval);
            break;
        }
        case command_FieldId_updateproto: {
            retval = bool_ReadStrptrMaybe(parent.updateproto, strval);
            break;
        }
        case command_FieldId_listfunc: {
            retval = bool_ReadStrptrMaybe(parent.listfunc, strval);
            break;
        }
        case command_FieldId_iffy: {
            retval = bool_ReadStrptrMaybe(parent.iffy, strval);
            break;
        }
        case command_FieldId_proto: {
            retval = bool_ReadStrptrMaybe(parent.proto, strval);
            break;
        }
        case command_FieldId_gen: {
            retval = bool_ReadStrptrMaybe(parent.gen, strval);
            break;
        }
        case command_FieldId_showloc: {
            retval = bool_ReadStrptrMaybe(parent.showloc, strval);
            break;
        }
        case command_FieldId_showstatic: {
            retval = bool_ReadStrptrMaybe(parent.showstatic, strval);
            break;
        }
        case command_FieldId_showsortkey: {
            retval = bool_ReadStrptrMaybe(parent.showsortkey, strval);
            break;
        }
        case command_FieldId_sortname: {
            retval = bool_ReadStrptrMaybe(parent.sortname, strval);
            break;
        }
        case command_FieldId_e: {
            retval = bool_ReadStrptrMaybe(parent.e, strval);
            break;
        }
        case command_FieldId_baddecl: {
            retval = bool_ReadStrptrMaybe(parent.baddecl, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_func..ReadTupleMaybe
// Read fields of command::src_func from attributes of ascii tuple TUPLE
bool command::src_func_ReadTupleMaybe(command::src_func &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = src_func_GetAnon(parent, anon_idx++);
        }
        retval = src_func_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_func..Init
// Set all fields to initial values.
void command::src_func_Init(command::src_func& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.target, "%", true);
    Regx_ReadSql(parent.name, "%", true);
    Regx_ReadSql(parent.body, "%", true);
    Regx_ReadSql(parent.targsrc, "", true);
    Regx_ReadSql(parent.func, "%", true);
    Regx_ReadSql(parent.comment, "%", true);
    parent.nextfile = algo::strptr("");
    parent.other = bool(false);
    parent.updateproto = bool(false);
    parent.listfunc = bool(false);
    parent.iffy = bool(false);
    parent.proto = bool(false);
    parent.gen = bool(false);
    parent.showloc = bool(true);
    parent.showstatic = bool(true);
    parent.showsortkey = bool(false);
    parent.sortname = bool(false);
    parent.e = bool(false);
    parent.baddecl = bool(false);
    parent.report = bool(false);
}

// --- command.src_func..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_func_ToCmdline(command::src_func& row) {
    tempstr ret;
    ret << "bin/src_func ";
    src_func_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_func..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.src_func.Argv  printfmt:Tuple
void command::src_func_PrintArgv(command::src_func& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::target_Print(const_cast<command::src_func&>(row), temp);
    str << " -target:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    command::name_Print(const_cast<command::src_func&>(row), temp);
    str << " -name:";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    command::body_Print(const_cast<command::src_func&>(row), temp);
    str << " -body:";
    strptr_PrintBash(temp,str);
    if (!(row.targsrc.expr == "")) {
        ch_RemoveAll(temp);
        command::targsrc_Print(const_cast<command::src_func&>(row), temp);
        str << " -targsrc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.func.expr == "%")) {
        ch_RemoveAll(temp);
        command::func_Print(const_cast<command::src_func&>(row), temp);
        str << " -func:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.comment.expr == "%")) {
        ch_RemoveAll(temp);
        command::comment_Print(const_cast<command::src_func&>(row), temp);
        str << " -comment:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nextfile == "")) {
        ch_RemoveAll(temp);
        Smallstr200_Print(row.nextfile, temp);
        str << " -nextfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.other == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.other, temp);
        str << " -other:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.updateproto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.updateproto, temp);
        str << " -updateproto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.listfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.listfunc, temp);
        str << " -listfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.iffy == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.iffy, temp);
        str << " -iffy:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.proto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.proto, temp);
        str << " -proto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gen == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gen, temp);
        str << " -gen:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showloc == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.showloc, temp);
        str << " -showloc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showstatic == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.showstatic, temp);
        str << " -showstatic:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showsortkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showsortkey, temp);
        str << " -showsortkey:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sortname == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.sortname, temp);
        str << " -sortname:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.baddecl == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.baddecl, temp);
        str << " -baddecl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_func..GetAnon
algo::strptr command::src_func_GetAnon(command::src_func &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        case(1): return strptr("name", 4);
        case(2): return strptr("body", 4);
        default: return algo::strptr();
    }
}

// --- command.src_func..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::src_func_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_target: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_name: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_body: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_targsrc: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_func: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_comment: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_nextfile: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_other: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_updateproto: { // bool: no argument required but value may be specified as other:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_listfunc: { // bool: no argument required but value may be specified as updateproto:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_iffy: { // bool: no argument required but value may be specified as listfunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_proto: { // bool: no argument required but value may be specified as iffy:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_gen: { // bool: no argument required but value may be specified as proto:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showloc: { // bool: no argument required but value may be specified as gen:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showstatic: { // bool: no argument required but value may be specified as showloc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_showsortkey: { // bool: no argument required but value may be specified as showstatic:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_sortname: { // bool: no argument required but value may be specified as showsortkey:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_e: { // bool: no argument required but value may be specified as sortname:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_baddecl: { // bool: no argument required but value may be specified as e:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as baddecl:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.src_func_proc.src_func.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_func_Start(command::src_func_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_func_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_func_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_func_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_func_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_func_proc.src_func.StartRead
// Start subprocess & Read output
algo::Fildes command::src_func_StartRead(command::src_func_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_func_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_func_proc.src_func.Kill
// Kill subprocess and wait
void command::src_func_Kill(command::src_func_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_func_Wait(parent);
    }
}

// --- command.src_func_proc.src_func.Wait
// Wait for subprocess to return
void command::src_func_Wait(command::src_func_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_func_proc.src_func.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_func_Exec(command::src_func_proc& parent) {
    src_func_Start(parent);
    src_func_Wait(parent);
    return parent.status;
}

// --- command.src_func_proc.src_func.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_func_ExecX(command::src_func_proc& parent) {
    int rc = src_func_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_func_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_func_proc.src_func.Execv
// Call execv()
// Call execv with specified parameters
int command::src_func_Execv(command::src_func_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    src_func_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.src_func_proc.src_func.ToCmdline
algo::tempstr command::src_func_ToCmdline(command::src_func_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_func_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_func_proc.src_func.ToArgv
// Form array from the command line
void command::src_func_ToArgv(command::src_func_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.target.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-target:";
        command::target_Print(parent.cmd, *arg);
    }

    if (parent.cmd.name.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-name:";
        command::name_Print(parent.cmd, *arg);
    }

    if (parent.cmd.body.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-body:";
        command::body_Print(parent.cmd, *arg);
    }

    if (parent.cmd.targsrc.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-targsrc:";
        command::targsrc_Print(parent.cmd, *arg);
    }

    if (parent.cmd.func.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-func:";
        command::func_Print(parent.cmd, *arg);
    }

    if (parent.cmd.comment.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-comment:";
        command::comment_Print(parent.cmd, *arg);
    }

    if (parent.cmd.nextfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-nextfile:";
        Smallstr200_Print(parent.cmd.nextfile, *arg);
    }

    if (parent.cmd.other != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-other:";
        bool_Print(parent.cmd.other, *arg);
    }

    if (parent.cmd.updateproto != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-updateproto:";
        bool_Print(parent.cmd.updateproto, *arg);
    }

    if (parent.cmd.listfunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-listfunc:";
        bool_Print(parent.cmd.listfunc, *arg);
    }

    if (parent.cmd.iffy != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-iffy:";
        bool_Print(parent.cmd.iffy, *arg);
    }

    if (parent.cmd.proto != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-proto:";
        bool_Print(parent.cmd.proto, *arg);
    }

    if (parent.cmd.gen != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-gen:";
        bool_Print(parent.cmd.gen, *arg);
    }

    if (parent.cmd.showloc != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showloc:";
        bool_Print(parent.cmd.showloc, *arg);
    }

    if (parent.cmd.showstatic != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showstatic:";
        bool_Print(parent.cmd.showstatic, *arg);
    }

    if (parent.cmd.showsortkey != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-showsortkey:";
        bool_Print(parent.cmd.showsortkey, *arg);
    }

    if (parent.cmd.sortname != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-sortname:";
        bool_Print(parent.cmd.sortname, *arg);
    }

    if (parent.cmd.e != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-e:";
        bool_Print(parent.cmd.e, *arg);
    }

    if (parent.cmd.baddecl != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-baddecl:";
        bool_Print(parent.cmd.baddecl, *arg);
    }

    if (parent.cmd.report != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.src_func_proc..Uninit
void command::src_func_proc_Uninit(command::src_func_proc& parent) {
    command::src_func_proc &row = parent; (void)row;

    // command.src_func_proc.src_func.Uninit (Exec)  //
    src_func_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_hdr.targsrc.Print
// Print back to string
void command::targsrc_Print(command::src_hdr& parent, algo::cstring &out) {
    Regx_Print(parent.targsrc, out);
}

// --- command.src_hdr.targsrc.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::targsrc_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.targsrc, in, true);
    return retval;
}

// --- command.src_hdr.scriptfile.Print
// Print back to string
void command::scriptfile_Print(command::src_hdr& parent, algo::cstring &out) {
    Regx_Print(parent.scriptfile, out);
}

// --- command.src_hdr.scriptfile.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::scriptfile_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.scriptfile, in, true);
    return retval;
}

// --- command.src_hdr..ReadFieldMaybe
bool command::src_hdr_ReadFieldMaybe(command::src_hdr& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_targsrc: {
            retval = targsrc_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_write: {
            retval = bool_ReadStrptrMaybe(parent.write, strval);
            break;
        }
        case command_FieldId_indent: {
            retval = bool_ReadStrptrMaybe(parent.indent, strval);
            break;
        }
        case command_FieldId_update_copyright: {
            retval = bool_ReadStrptrMaybe(parent.update_copyright, strval);
            break;
        }
        case command_FieldId_scriptfile: {
            retval = scriptfile_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_hdr..ReadTupleMaybe
// Read fields of command::src_hdr from attributes of ascii tuple TUPLE
bool command::src_hdr_ReadTupleMaybe(command::src_hdr &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = src_hdr_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_hdr..Init
// Set all fields to initial values.
void command::src_hdr_Init(command::src_hdr& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.targsrc, "", true);
    parent.write = bool(false);
    parent.indent = bool(false);
    parent.update_copyright = bool(false);
    Regx_ReadSql(parent.scriptfile, "", true);
}

// --- command.src_hdr..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_hdr_ToCmdline(command::src_hdr& row) {
    tempstr ret;
    ret << "bin/src_hdr ";
    src_hdr_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_hdr..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.src_hdr.Argv  printfmt:Tuple
void command::src_hdr_PrintArgv(command::src_hdr& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.targsrc.expr == "")) {
        ch_RemoveAll(temp);
        command::targsrc_Print(const_cast<command::src_hdr&>(row), temp);
        str << " -targsrc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.indent == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.indent, temp);
        str << " -indent:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.update_copyright == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.update_copyright, temp);
        str << " -update_copyright:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.scriptfile.expr == "")) {
        ch_RemoveAll(temp);
        command::scriptfile_Print(const_cast<command::src_hdr&>(row), temp);
        str << " -scriptfile:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_hdr..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::src_hdr_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_targsrc: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_write: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_indent: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_update_copyright: { // bool: no argument required but value may be specified as indent:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_scriptfile: { // bool: no argument required but value may be specified as update_copyright:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.src_hdr_proc.src_hdr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_hdr_Start(command::src_hdr_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_hdr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_hdr_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_hdr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_hdr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_hdr_proc.src_hdr.StartRead
// Start subprocess & Read output
algo::Fildes command::src_hdr_StartRead(command::src_hdr_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_hdr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_hdr_proc.src_hdr.Kill
// Kill subprocess and wait
void command::src_hdr_Kill(command::src_hdr_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_hdr_Wait(parent);
    }
}

// --- command.src_hdr_proc.src_hdr.Wait
// Wait for subprocess to return
void command::src_hdr_Wait(command::src_hdr_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_hdr_proc.src_hdr.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_hdr_Exec(command::src_hdr_proc& parent) {
    src_hdr_Start(parent);
    src_hdr_Wait(parent);
    return parent.status;
}

// --- command.src_hdr_proc.src_hdr.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_hdr_ExecX(command::src_hdr_proc& parent) {
    int rc = src_hdr_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_hdr_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_hdr_proc.src_hdr.Execv
// Call execv()
// Call execv with specified parameters
int command::src_hdr_Execv(command::src_hdr_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    src_hdr_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.src_hdr_proc.src_hdr.ToCmdline
algo::tempstr command::src_hdr_ToCmdline(command::src_hdr_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_hdr_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_hdr_proc.src_hdr.ToArgv
// Form array from the command line
void command::src_hdr_ToArgv(command::src_hdr_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.targsrc.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-targsrc:";
        command::targsrc_Print(parent.cmd, *arg);
    }

    if (parent.cmd.write != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write:";
        bool_Print(parent.cmd.write, *arg);
    }

    if (parent.cmd.indent != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-indent:";
        bool_Print(parent.cmd.indent, *arg);
    }

    if (parent.cmd.update_copyright != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-update_copyright:";
        bool_Print(parent.cmd.update_copyright, *arg);
    }

    if (parent.cmd.scriptfile.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-scriptfile:";
        command::scriptfile_Print(parent.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.src_hdr_proc..Uninit
void command::src_hdr_proc_Uninit(command::src_hdr_proc& parent) {
    command::src_hdr_proc &row = parent; (void)row;

    // command.src_hdr_proc.src_hdr.Uninit (Exec)  //
    src_hdr_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_lim.srcfile.Print
// Print back to string
void command::srcfile_Print(command::src_lim& parent, algo::cstring &out) {
    Regx_Print(parent.srcfile, out);
}

// --- command.src_lim.srcfile.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::srcfile_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.srcfile, in, true);
    return retval;
}

// --- command.src_lim.badline.Print
// Print back to string
void command::badline_Print(command::src_lim& parent, algo::cstring &out) {
    Regx_Print(parent.badline, out);
}

// --- command.src_lim.badline.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::badline_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.badline, in, true);
    return retval;
}

// --- command.src_lim..ReadFieldMaybe
bool command::src_lim_ReadFieldMaybe(command::src_lim& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_linelim: {
            retval = bool_ReadStrptrMaybe(parent.linelim, strval);
            break;
        }
        case command_FieldId_srcfile: {
            retval = srcfile_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_strayfile: {
            retval = bool_ReadStrptrMaybe(parent.strayfile, strval);
            break;
        }
        case command_FieldId_capture: {
            retval = bool_ReadStrptrMaybe(parent.capture, strval);
            break;
        }
        case command_FieldId_write: {
            retval = bool_ReadStrptrMaybe(parent.write, strval);
            break;
        }
        case command_FieldId_badchar: {
            retval = bool_ReadStrptrMaybe(parent.badchar, strval);
            break;
        }
        case command_FieldId_badline: {
            retval = badline_ReadStrptrMaybe(parent, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_lim..ReadTupleMaybe
// Read fields of command::src_lim from attributes of ascii tuple TUPLE
bool command::src_lim_ReadTupleMaybe(command::src_lim &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = src_lim_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_lim..Init
// Set all fields to initial values.
void command::src_lim_Init(command::src_lim& parent) {
    parent.in = algo::strptr("data");
    parent.linelim = bool(false);
    Regx_ReadSql(parent.srcfile, "%", true);
    parent.strayfile = bool(false);
    parent.capture = bool(false);
    parent.write = bool(false);
    parent.badchar = bool(false);
    Regx_ReadSql(parent.badline, "", true);
}

// --- command.src_lim..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_lim_ToCmdline(command::src_lim& row) {
    tempstr ret;
    ret << "bin/src_lim ";
    src_lim_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_lim..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.src_lim.Argv  printfmt:Tuple
void command::src_lim_PrintArgv(command::src_lim& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.linelim == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.linelim, temp);
        str << " -linelim:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfile.expr == "%")) {
        ch_RemoveAll(temp);
        command::srcfile_Print(const_cast<command::src_lim&>(row), temp);
        str << " -srcfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.strayfile == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.strayfile, temp);
        str << " -strayfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.badchar == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.badchar, temp);
        str << " -badchar:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.badline.expr == "")) {
        ch_RemoveAll(temp);
        command::badline_Print(const_cast<command::src_lim&>(row), temp);
        str << " -badline:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_lim..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::src_lim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_linelim: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_srcfile: { // bool: no argument required but value may be specified as linelim:Y
            *out_anon = false;
        } break;
        case command_FieldId_strayfile: { // bool: no argument required but value may be specified as linelim:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_capture: { // bool: no argument required but value may be specified as strayfile:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_write: { // bool: no argument required but value may be specified as capture:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_badchar: { // bool: no argument required but value may be specified as write:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_badline: { // bool: no argument required but value may be specified as badchar:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.src_lim_proc.src_lim.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_lim_Start(command::src_lim_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_lim_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_lim_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_lim_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_lim_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_lim_proc.src_lim.StartRead
// Start subprocess & Read output
algo::Fildes command::src_lim_StartRead(command::src_lim_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_lim_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_lim_proc.src_lim.Kill
// Kill subprocess and wait
void command::src_lim_Kill(command::src_lim_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_lim_Wait(parent);
    }
}

// --- command.src_lim_proc.src_lim.Wait
// Wait for subprocess to return
void command::src_lim_Wait(command::src_lim_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_lim_proc.src_lim.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_lim_Exec(command::src_lim_proc& parent) {
    src_lim_Start(parent);
    src_lim_Wait(parent);
    return parent.status;
}

// --- command.src_lim_proc.src_lim.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_lim_ExecX(command::src_lim_proc& parent) {
    int rc = src_lim_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_lim_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_lim_proc.src_lim.Execv
// Call execv()
// Call execv with specified parameters
int command::src_lim_Execv(command::src_lim_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    src_lim_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.src_lim_proc.src_lim.ToCmdline
algo::tempstr command::src_lim_ToCmdline(command::src_lim_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_lim_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_lim_proc.src_lim.ToArgv
// Form array from the command line
void command::src_lim_ToArgv(command::src_lim_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.linelim != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-linelim:";
        bool_Print(parent.cmd.linelim, *arg);
    }

    if (parent.cmd.srcfile.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-srcfile:";
        command::srcfile_Print(parent.cmd, *arg);
    }

    if (parent.cmd.strayfile != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-strayfile:";
        bool_Print(parent.cmd.strayfile, *arg);
    }

    if (parent.cmd.capture != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-capture:";
        bool_Print(parent.cmd.capture, *arg);
    }

    if (parent.cmd.write != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-write:";
        bool_Print(parent.cmd.write, *arg);
    }

    if (parent.cmd.badchar != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-badchar:";
        bool_Print(parent.cmd.badchar, *arg);
    }

    if (parent.cmd.badline.expr != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-badline:";
        command::badline_Print(parent.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.src_lim_proc..Uninit
void command::src_lim_proc_Uninit(command::src_lim_proc& parent) {
    command::src_lim_proc &row = parent; (void)row;

    // command.src_lim_proc.src_lim.Uninit (Exec)  //
    src_lim_Kill(parent); // kill child, ensure forward progress
}

// --- command.ssim2csv..ReadFieldMaybe
bool command::ssim2csv_ReadFieldMaybe(command::ssim2csv& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_expand: {
            retval = algo::cstring_ReadStrptrMaybe(parent.expand, strval);
            break;
        }
        case command_FieldId_ignoreQuote: {
            retval = bool_ReadStrptrMaybe(parent.ignoreQuote, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ssim2csv..ReadTupleMaybe
// Read fields of command::ssim2csv from attributes of ascii tuple TUPLE
bool command::ssim2csv_ReadTupleMaybe(command::ssim2csv &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ssim2csv_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ssim2csv..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ssim2csv_ToCmdline(command::ssim2csv& row) {
    tempstr ret;
    ret << "bin/ssim2csv ";
    ssim2csv_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ssim2csv..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.ssim2csv.Argv  printfmt:Auto
void command::ssim2csv_PrintArgv(command::ssim2csv& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.expand == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.expand, temp);
        str << " -expand:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ignoreQuote == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ignoreQuote, temp);
        str << " -ignoreQuote:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ssim2csv..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::ssim2csv_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_expand: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_ignoreQuote: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.ssim2csv_proc.ssim2csv.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ssim2csv_Start(command::ssim2csv_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ssim2csv_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ssim2csv_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ssim2csv_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ssim2csv_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ssim2csv_proc.ssim2csv.StartRead
// Start subprocess & Read output
algo::Fildes command::ssim2csv_StartRead(command::ssim2csv_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ssim2csv_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ssim2csv_proc.ssim2csv.Kill
// Kill subprocess and wait
void command::ssim2csv_Kill(command::ssim2csv_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ssim2csv_Wait(parent);
    }
}

// --- command.ssim2csv_proc.ssim2csv.Wait
// Wait for subprocess to return
void command::ssim2csv_Wait(command::ssim2csv_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ssim2csv_proc.ssim2csv.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ssim2csv_Exec(command::ssim2csv_proc& parent) {
    ssim2csv_Start(parent);
    ssim2csv_Wait(parent);
    return parent.status;
}

// --- command.ssim2csv_proc.ssim2csv.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ssim2csv_ExecX(command::ssim2csv_proc& parent) {
    int rc = ssim2csv_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ssim2csv_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ssim2csv_proc.ssim2csv.Execv
// Call execv()
// Call execv with specified parameters
int command::ssim2csv_Execv(command::ssim2csv_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    ssim2csv_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.ssim2csv_proc.ssim2csv.ToCmdline
algo::tempstr command::ssim2csv_ToCmdline(command::ssim2csv_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ssim2csv_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ssim2csv_proc.ssim2csv.ToArgv
// Form array from the command line
void command::ssim2csv_ToArgv(command::ssim2csv_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.expand != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-expand:";
        cstring_Print(parent.cmd.expand, *arg);
    }

    if (parent.cmd.ignoreQuote != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ignoreQuote:";
        bool_Print(parent.cmd.ignoreQuote, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.ssim2csv_proc..Uninit
void command::ssim2csv_proc_Uninit(command::ssim2csv_proc& parent) {
    command::ssim2csv_proc &row = parent; (void)row;

    // command.ssim2csv_proc.ssim2csv.Uninit (Exec)  //
    ssim2csv_Kill(parent); // kill child, ensure forward progress
}

// --- command.ssim2mysql..ReadFieldMaybe
bool command::ssim2mysql_ReadFieldMaybe(command::ssim2mysql& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_url: {
            retval = algo::cstring_ReadStrptrMaybe(parent.url, strval);
            break;
        }
        case command_FieldId_data_dir: {
            retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval);
            break;
        }
        case command_FieldId_maxpacket: {
            retval = i32_ReadStrptrMaybe(parent.maxpacket, strval);
            break;
        }
        case command_FieldId_replace: {
            retval = bool_ReadStrptrMaybe(parent.replace, strval);
            break;
        }
        case command_FieldId_trunc: {
            retval = bool_ReadStrptrMaybe(parent.trunc, strval);
            break;
        }
        case command_FieldId_dry_run: {
            retval = bool_ReadStrptrMaybe(parent.dry_run, strval);
            break;
        }
        case command_FieldId_fldfunc: {
            retval = bool_ReadStrptrMaybe(parent.fldfunc, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_db: {
            retval = algo::cstring_ReadStrptrMaybe(parent.db, strval);
            break;
        }
        case command_FieldId_createdb: {
            retval = bool_ReadStrptrMaybe(parent.createdb, strval);
            break;
        }
        case command_FieldId_fkey: {
            retval = bool_ReadStrptrMaybe(parent.fkey, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ssim2mysql..ReadTupleMaybe
// Read fields of command::ssim2mysql from attributes of ascii tuple TUPLE
bool command::ssim2mysql_ReadTupleMaybe(command::ssim2mysql &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ssim2mysql_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ssim2mysql..Init
// Set all fields to initial values.
void command::ssim2mysql_Init(command::ssim2mysql& parent) {
    parent.url = algo::strptr("");
    parent.data_dir = algo::strptr("data");
    parent.maxpacket = i32(100000);
    parent.replace = bool(true);
    parent.trunc = bool(false);
    parent.dry_run = bool(false);
    parent.fldfunc = bool(false);
    parent.in = algo::strptr("-");
    parent.db = algo::strptr("");
    parent.createdb = bool(false);
    parent.fkey = bool(false);
}

// --- command.ssim2mysql..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ssim2mysql_ToCmdline(command::ssim2mysql& row) {
    tempstr ret;
    ret << "bin/ssim2mysql ";
    ssim2mysql_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ssim2mysql..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.ssim2mysql.Argv  printfmt:Auto
void command::ssim2mysql_PrintArgv(command::ssim2mysql& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.url == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.url, temp);
        str << " -url:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxpacket == 100000)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxpacket, temp);
        str << " -maxpacket:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.replace == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.replace, temp);
        str << " -replace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.trunc, temp);
        str << " -trunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "-")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.db == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.db, temp);
        str << " -db:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.createdb == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.createdb, temp);
        str << " -createdb:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fkey, temp);
        str << " -fkey:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ssim2mysql..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::ssim2mysql_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_url: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_data_dir: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_maxpacket: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_replace: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_trunc: { // bool: no argument required but value may be specified as replace:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_dry_run: { // bool: no argument required but value may be specified as trunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_fldfunc: { // bool: no argument required but value may be specified as dry_run:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_in: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
        } break;
        case command_FieldId_db: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
        } break;
        case command_FieldId_createdb: { // bool: no argument required but value may be specified as fldfunc:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_fkey: { // bool: no argument required but value may be specified as createdb:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.ssim2mysql_proc.ssim2mysql.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ssim2mysql_Start(command::ssim2mysql_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ssim2mysql_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ssim2mysql_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ssim2mysql_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ssim2mysql_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ssim2mysql_proc.ssim2mysql.StartRead
// Start subprocess & Read output
algo::Fildes command::ssim2mysql_StartRead(command::ssim2mysql_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ssim2mysql_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ssim2mysql_proc.ssim2mysql.Kill
// Kill subprocess and wait
void command::ssim2mysql_Kill(command::ssim2mysql_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ssim2mysql_Wait(parent);
    }
}

// --- command.ssim2mysql_proc.ssim2mysql.Wait
// Wait for subprocess to return
void command::ssim2mysql_Wait(command::ssim2mysql_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ssim2mysql_proc.ssim2mysql.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ssim2mysql_Exec(command::ssim2mysql_proc& parent) {
    ssim2mysql_Start(parent);
    ssim2mysql_Wait(parent);
    return parent.status;
}

// --- command.ssim2mysql_proc.ssim2mysql.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ssim2mysql_ExecX(command::ssim2mysql_proc& parent) {
    int rc = ssim2mysql_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ssim2mysql_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ssim2mysql_proc.ssim2mysql.Execv
// Call execv()
// Call execv with specified parameters
int command::ssim2mysql_Execv(command::ssim2mysql_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    ssim2mysql_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.ssim2mysql_proc.ssim2mysql.ToCmdline
algo::tempstr command::ssim2mysql_ToCmdline(command::ssim2mysql_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ssim2mysql_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ssim2mysql_proc.ssim2mysql.ToArgv
// Form array from the command line
void command::ssim2mysql_ToArgv(command::ssim2mysql_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.url != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-url:";
        cstring_Print(parent.cmd.url, *arg);
    }

    if (parent.cmd.data_dir != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, *arg);
    }

    if (parent.cmd.maxpacket != 100000) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-maxpacket:";
        i32_Print(parent.cmd.maxpacket, *arg);
    }

    if (parent.cmd.replace != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-replace:";
        bool_Print(parent.cmd.replace, *arg);
    }

    if (parent.cmd.trunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-trunc:";
        bool_Print(parent.cmd.trunc, *arg);
    }

    if (parent.cmd.dry_run != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-dry_run:";
        bool_Print(parent.cmd.dry_run, *arg);
    }

    if (parent.cmd.fldfunc != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, *arg);
    }

    if (parent.cmd.in != "-") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.db != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-db:";
        cstring_Print(parent.cmd.db, *arg);
    }

    if (parent.cmd.createdb != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-createdb:";
        bool_Print(parent.cmd.createdb, *arg);
    }

    if (parent.cmd.fkey != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fkey:";
        bool_Print(parent.cmd.fkey, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.ssim2mysql_proc..Uninit
void command::ssim2mysql_proc_Uninit(command::ssim2mysql_proc& parent) {
    command::ssim2mysql_proc &row = parent; (void)row;

    // command.ssim2mysql_proc.ssim2mysql.Uninit (Exec)  //
    ssim2mysql_Kill(parent); // kill child, ensure forward progress
}

// --- command.ssimfilt.typetag.Print
// Print back to string
void command::typetag_Print(command::ssimfilt& parent, algo::cstring &out) {
    Regx_Print(parent.typetag, out);
}

// --- command.ssimfilt.typetag.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::typetag_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.typetag, in, true);
    return retval;
}

// --- command.ssimfilt.match.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::match_Addary(command::ssimfilt& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.match_elems && rhs.elems < parent.match_elems + parent.match_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.ssimfilt.match  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    match_Reserve(parent, nnew); // reserve space
    int at = parent.match_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.match_elems + at + i) algo::cstring(rhs[i]);
        parent.match_n++;
    }
    return algo::aryptr<algo::cstring>(parent.match_elems + at, nnew);
}

// --- command.ssimfilt.match.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::match_Alloc(command::ssimfilt& parent) {
    match_Reserve(parent, 1);
    int n  = parent.match_n;
    int at = n;
    algo::cstring *elems = parent.match_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.match_n = n+1;
    return elems[at];
}

// --- command.ssimfilt.match.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::match_AllocAt(command::ssimfilt& parent, int at) {
    match_Reserve(parent, 1);
    int n  = parent.match_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.ssimfilt.match  comment:'index out of range'");
    }
    algo::cstring *elems = parent.match_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.match_n = n+1;
    return elems[at];
}

// --- command.ssimfilt.match.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::match_AllocN(command::ssimfilt& parent, int n_elems) {
    match_Reserve(parent, n_elems);
    int old_n  = parent.match_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.match_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.match_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.ssimfilt.match.Remove
// Remove item by index. If index outside of range, do nothing.
void command::match_Remove(command::ssimfilt& parent, u32 i) {
    u32 lim = parent.match_n;
    algo::cstring *elems = parent.match_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.match_n = lim - 1;
    }
}

// --- command.ssimfilt.match.RemoveAll
void command::match_RemoveAll(command::ssimfilt& parent) {
    u32 n = parent.match_n;
    while (n > 0) {
        n -= 1;
        parent.match_elems[n].~cstring();
        parent.match_n = n;
    }
}

// --- command.ssimfilt.match.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::match_RemoveLast(command::ssimfilt& parent) {
    u64 n = parent.match_n;
    if (n > 0) {
        n -= 1;
        match_qFind(parent, u64(n)).~cstring();
        parent.match_n = n;
    }
}

// --- command.ssimfilt.match.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::match_AbsReserve(command::ssimfilt& parent, int n) {
    u32 old_max  = parent.match_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.match_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.ssimfilt.match  comment:'out of memory'");
        }
        parent.match_elems = (algo::cstring*)new_mem;
        parent.match_max = new_max;
    }
}

// --- command.ssimfilt.match.Setary
// Copy contents of RHS to PARENT.
void command::match_Setary(command::ssimfilt& parent, command::ssimfilt &rhs) {
    match_RemoveAll(parent);
    int nnew = rhs.match_n;
    match_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.match_elems + i) algo::cstring(match_qFind(rhs, i));
        parent.match_n = i + 1;
    }
}

// --- command.ssimfilt.match.Setary2
// Copy specified array into match, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::match_Setary(command::ssimfilt& parent, const algo::aryptr<algo::cstring> &rhs) {
    match_RemoveAll(parent);
    match_Addary(parent, rhs);
}

// --- command.ssimfilt.match.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::match_AllocNVal(command::ssimfilt& parent, int n_elems, const algo::cstring& val) {
    match_Reserve(parent, n_elems);
    int old_n  = parent.match_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.match_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.match_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.ssimfilt.match.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::match_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = match_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        match_RemoveLast(parent);
    }
    return retval;
}

// --- command.ssimfilt.field.Addary
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::cstring> command::field_Addary(command::ssimfilt& parent, algo::aryptr<algo::cstring> rhs) {
    bool overlaps = rhs.n_elems>0 && rhs.elems >= parent.field_elems && rhs.elems < parent.field_elems + parent.field_max;
    if (UNLIKELY(overlaps)) {
        FatalErrorExit("command.tary_alias  field:command.ssimfilt.field  comment:'alias error: sub-array is being appended to the whole'");
    }
    int nnew = rhs.n_elems;
    field_Reserve(parent, nnew); // reserve space
    int at = parent.field_n;
    for (int i = 0; i < nnew; i++) {
        new (parent.field_elems + at + i) algo::cstring(rhs[i]);
        parent.field_n++;
    }
    return algo::aryptr<algo::cstring>(parent.field_elems + at, nnew);
}

// --- command.ssimfilt.field.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& command::field_Alloc(command::ssimfilt& parent) {
    field_Reserve(parent, 1);
    int n  = parent.field_n;
    int at = n;
    algo::cstring *elems = parent.field_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    parent.field_n = n+1;
    return elems[at];
}

// --- command.ssimfilt.field.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& command::field_AllocAt(command::ssimfilt& parent, int at) {
    field_Reserve(parent, 1);
    int n  = parent.field_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("command.bad_alloc_at  field:command.ssimfilt.field  comment:'index out of range'");
    }
    algo::cstring *elems = parent.field_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    parent.field_n = n+1;
    return elems[at];
}

// --- command.ssimfilt.field.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::field_AllocN(command::ssimfilt& parent, int n_elems) {
    field_Reserve(parent, n_elems);
    int old_n  = parent.field_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.field_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    parent.field_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.ssimfilt.field.Remove
// Remove item by index. If index outside of range, do nothing.
void command::field_Remove(command::ssimfilt& parent, u32 i) {
    u32 lim = parent.field_n;
    algo::cstring *elems = parent.field_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        parent.field_n = lim - 1;
    }
}

// --- command.ssimfilt.field.RemoveAll
void command::field_RemoveAll(command::ssimfilt& parent) {
    u32 n = parent.field_n;
    while (n > 0) {
        n -= 1;
        parent.field_elems[n].~cstring();
        parent.field_n = n;
    }
}

// --- command.ssimfilt.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void command::field_RemoveLast(command::ssimfilt& parent) {
    u64 n = parent.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(parent, u64(n)).~cstring();
        parent.field_n = n;
    }
}

// --- command.ssimfilt.field.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void command::field_AbsReserve(command::ssimfilt& parent, int n) {
    u32 old_max  = parent.field_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = algo_lib::malloc_ReallocMem(parent.field_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("command.tary_nomem  field:command.ssimfilt.field  comment:'out of memory'");
        }
        parent.field_elems = (algo::cstring*)new_mem;
        parent.field_max = new_max;
    }
}

// --- command.ssimfilt.field.Setary
// Copy contents of RHS to PARENT.
void command::field_Setary(command::ssimfilt& parent, command::ssimfilt &rhs) {
    field_RemoveAll(parent);
    int nnew = rhs.field_n;
    field_Reserve(parent, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (parent.field_elems + i) algo::cstring(field_qFind(rhs, i));
        parent.field_n = i + 1;
    }
}

// --- command.ssimfilt.field.Setary2
// Copy specified array into field, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void command::field_Setary(command::ssimfilt& parent, const algo::aryptr<algo::cstring> &rhs) {
    field_RemoveAll(parent);
    field_Addary(parent, rhs);
}

// --- command.ssimfilt.field.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> command::field_AllocNVal(command::ssimfilt& parent, int n_elems, const algo::cstring& val) {
    field_Reserve(parent, n_elems);
    int old_n  = parent.field_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = parent.field_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    parent.field_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- command.ssimfilt.field.ReadStrptrMaybe
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
bool command::field_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in_str) {
    bool retval = true;
    algo::cstring &elem = field_Alloc(parent);
    retval = algo::cstring_ReadStrptrMaybe(elem, in_str);
    if (!retval) {
        field_RemoveLast(parent);
    }
    return retval;
}

// --- command.ssimfilt.format.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::format_ToCstr(const command::ssimfilt& parent) {
    const char *ret = NULL;
    switch(format_GetEnum(parent)) {
        case command_ssimfilt_format_ssim  : ret = "ssim";  break;
        case command_ssimfilt_format_csv   : ret = "csv";  break;
        case command_ssimfilt_format_field : ret = "field";  break;
        case command_ssimfilt_format_cmd   : ret = "cmd";  break;
        case command_ssimfilt_format_json  : ret = "json";  break;
        case command_ssimfilt_format_table : ret = "table";  break;
    }
    return ret;
}

// --- command.ssimfilt.format.Print
// Convert format to a string. First, attempt conversion to a known string.
// If no string matches, print format as a numeric value.
void command::format_Print(const command::ssimfilt& parent, algo::cstring &lhs) {
    const char *strval = format_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.format;
    }
}

// --- command.ssimfilt.format.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::format_SetStrptrMaybe(command::ssimfilt& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','m','d'): {
                    format_SetEnum(parent,command_ssimfilt_format_cmd); ret = true; break;
                }
                case LE_STR3('c','s','v'): {
                    format_SetEnum(parent,command_ssimfilt_format_csv); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('j','s','o','n'): {
                    format_SetEnum(parent,command_ssimfilt_format_json); ret = true; break;
                }
                case LE_STR4('s','s','i','m'): {
                    format_SetEnum(parent,command_ssimfilt_format_ssim); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','i','e','l','d'): {
                    format_SetEnum(parent,command_ssimfilt_format_field); ret = true; break;
                }
                case LE_STR5('t','a','b','l','e'): {
                    format_SetEnum(parent,command_ssimfilt_format_table); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.ssimfilt.format.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::format_SetStrptr(command::ssimfilt& parent, algo::strptr rhs, command_ssimfilt_format_Enum dflt) {
    if (!format_SetStrptrMaybe(parent,rhs)) format_SetEnum(parent,dflt);
}

// --- command.ssimfilt.format.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::format_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr rhs) {
    bool retval = false;
    retval = format_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.format,rhs);
    }
    return retval;
}

// --- command.ssimfilt..ReadFieldMaybe
bool command::ssimfilt_ReadFieldMaybe(command::ssimfilt& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,algo::Pathcomp(field, ".LL"));
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_typetag: {
            retval = typetag_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_match: {
            retval = match_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_field: {
            retval = field_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_format: {
            retval = format_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_t: {
            retval = bool_ReadStrptrMaybe(parent.t, strval);
            break;
        }
        case command_FieldId_cmd: {
            retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ssimfilt..ReadTupleMaybe
// Read fields of command::ssimfilt from attributes of ascii tuple TUPLE
bool command::ssimfilt_ReadTupleMaybe(command::ssimfilt &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = ssimfilt_GetAnon(parent, anon_idx++);
        }
        retval = ssimfilt_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ssimfilt..Init
// Set all fields to initial values.
void command::ssimfilt_Init(command::ssimfilt& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.typetag, "%", true);
    parent.match_elems 	= 0; // (command.ssimfilt.match)
    parent.match_n     	= 0; // (command.ssimfilt.match)
    parent.match_max   	= 0; // (command.ssimfilt.match)
    parent.field_elems 	= 0; // (command.ssimfilt.field)
    parent.field_n     	= 0; // (command.ssimfilt.field)
    parent.field_max   	= 0; // (command.ssimfilt.field)
    parent.format = u8(0);
    parent.t = bool(false);
    parent.cmd = algo::strptr("");
}

// --- command.ssimfilt..Uninit
void command::ssimfilt_Uninit(command::ssimfilt& parent) {
    command::ssimfilt &row = parent; (void)row;

    // command.ssimfilt.field.Uninit (Tary)  //(project) Select fields for output (regx)
    // remove all elements from command.ssimfilt.field
    field_RemoveAll(parent);
    // free memory for Tary command.ssimfilt.field
    algo_lib::malloc_FreeMem(parent.field_elems, sizeof(algo::cstring)*parent.field_max); // (command.ssimfilt.field)

    // command.ssimfilt.match.Uninit (Tary)  //(filter) Select input tuple if value of key matches value (regx:regx)
    // remove all elements from command.ssimfilt.match
    match_RemoveAll(parent);
    // free memory for Tary command.ssimfilt.match
    algo_lib::malloc_FreeMem(parent.match_elems, sizeof(algo::cstring)*parent.match_max); // (command.ssimfilt.match)
}

// --- command.ssimfilt..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ssimfilt_ToCmdline(command::ssimfilt& row) {
    tempstr ret;
    ret << "bin/ssimfilt ";
    ssimfilt_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ssimfilt..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.ssimfilt.Argv  printfmt:Tuple
void command::ssimfilt_PrintArgv(command::ssimfilt& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::typetag_Print(const_cast<command::ssimfilt&>(row), temp);
    str << " -typetag:";
    strptr_PrintBash(temp,str);
    ind_beg(ssimfilt_match_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -match:";
        strptr_PrintBash(temp,str);
    }ind_end;
    ind_beg(ssimfilt_field_curs,value,row) {
        ch_RemoveAll(temp);
        cstring_Print(value, temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }ind_end;
    if (!(row.format == 0)) {
        ch_RemoveAll(temp);
        command::format_Print(const_cast<command::ssimfilt&>(row), temp);
        str << " -format:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cmd, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ssimfilt..GetAnon
algo::strptr command::ssimfilt_GetAnon(command::ssimfilt &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("typetag", 7);
        default: return strptr("match", 5);
    }
}

// --- command.ssimfilt..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::ssimfilt_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_typetag: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_match: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_field: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_format: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_t: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_cmd: { // bool: no argument required but value may be specified as t:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.ssimfilt_proc.ssimfilt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ssimfilt_Start(command::ssimfilt_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ssimfilt_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ssimfilt_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ssimfilt_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ssimfilt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ssimfilt_proc.ssimfilt.StartRead
// Start subprocess & Read output
algo::Fildes command::ssimfilt_StartRead(command::ssimfilt_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ssimfilt_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ssimfilt_proc.ssimfilt.Kill
// Kill subprocess and wait
void command::ssimfilt_Kill(command::ssimfilt_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ssimfilt_Wait(parent);
    }
}

// --- command.ssimfilt_proc.ssimfilt.Wait
// Wait for subprocess to return
void command::ssimfilt_Wait(command::ssimfilt_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ssimfilt_proc.ssimfilt.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ssimfilt_Exec(command::ssimfilt_proc& parent) {
    ssimfilt_Start(parent);
    ssimfilt_Wait(parent);
    return parent.status;
}

// --- command.ssimfilt_proc.ssimfilt.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ssimfilt_ExecX(command::ssimfilt_proc& parent) {
    int rc = ssimfilt_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ssimfilt_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ssimfilt_proc.ssimfilt.Execv
// Call execv()
// Call execv with specified parameters
int command::ssimfilt_Execv(command::ssimfilt_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    ssimfilt_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.ssimfilt_proc.ssimfilt.ToCmdline
algo::tempstr command::ssimfilt_ToCmdline(command::ssimfilt_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ssimfilt_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ssimfilt_proc.ssimfilt.ToArgv
// Form array from the command line
void command::ssimfilt_ToArgv(command::ssimfilt_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.typetag.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-typetag:";
        command::typetag_Print(parent.cmd, *arg);
    }
    ind_beg(command::ssimfilt_match_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-match:";
        cstring_Print(value, *arg);
    }ind_end;
    ind_beg(command::ssimfilt_field_curs,value,parent.cmd) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-field:";
        cstring_Print(value, *arg);
    }ind_end;

    if (parent.cmd.format != 0) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-format:";
        command::format_Print(parent.cmd, *arg);
    }

    if (parent.cmd.t != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-t:";
        bool_Print(parent.cmd.t, *arg);
    }

    if (parent.cmd.cmd != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-cmd:";
        cstring_Print(parent.cmd.cmd, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.ssimfilt_proc..Uninit
void command::ssimfilt_proc_Uninit(command::ssimfilt_proc& parent) {
    command::ssimfilt_proc &row = parent; (void)row;

    // command.ssimfilt_proc.ssimfilt.Uninit (Exec)  //
    ssimfilt_Kill(parent); // kill child, ensure forward progress
}

// --- command.strconv..ReadFieldMaybe
bool command::strconv_ReadFieldMaybe(command::strconv& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_str: {
            retval = algo::cstring_ReadStrptrMaybe(parent.str, strval);
            break;
        }
        case command_FieldId_tocamelcase: {
            retval = bool_ReadStrptrMaybe(parent.tocamelcase, strval);
            break;
        }
        case command_FieldId_tolowerunder: {
            retval = bool_ReadStrptrMaybe(parent.tolowerunder, strval);
            break;
        }
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_pathcomp: {
            retval = algo::Smallstr100_ReadStrptrMaybe(parent.pathcomp, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.strconv..ReadTupleMaybe
// Read fields of command::strconv from attributes of ascii tuple TUPLE
bool command::strconv_ReadTupleMaybe(command::strconv &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = strconv_GetAnon(parent, anon_idx++);
        }
        retval = strconv_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.strconv..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::strconv_ToCmdline(command::strconv& row) {
    tempstr ret;
    ret << "bin/strconv ";
    strconv_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.strconv..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.strconv.Argv  printfmt:Tuple
void command::strconv_PrintArgv(command::strconv& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    ch_RemoveAll(temp);
    cstring_Print(row.str, temp);
    str << " -str:";
    strptr_PrintBash(temp,str);
    if (!(row.tocamelcase == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tocamelcase, temp);
        str << " -tocamelcase:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tolowerunder == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tolowerunder, temp);
        str << " -tolowerunder:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pathcomp == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.pathcomp, temp);
        str << " -pathcomp:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.strconv..GetAnon
algo::strptr command::strconv_GetAnon(command::strconv &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("str", 3);
        default: return algo::strptr();
    }
}

// --- command.strconv..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::strconv_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_str: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_tocamelcase: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_tolowerunder: { // bool: no argument required but value may be specified as tocamelcase:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_in: { // bool: no argument required but value may be specified as tolowerunder:Y
            *out_anon = false;
        } break;
        case command_FieldId_pathcomp: { // bool: no argument required but value may be specified as tolowerunder:Y
            *out_anon = false;
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.strconv_proc.strconv.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::strconv_Start(command::strconv_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(strconv_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(strconv_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= strconv_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.strconv_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.strconv_proc.strconv.StartRead
// Start subprocess & Read output
algo::Fildes command::strconv_StartRead(command::strconv_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    strconv_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.strconv_proc.strconv.Kill
// Kill subprocess and wait
void command::strconv_Kill(command::strconv_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        strconv_Wait(parent);
    }
}

// --- command.strconv_proc.strconv.Wait
// Wait for subprocess to return
void command::strconv_Wait(command::strconv_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.strconv_proc.strconv.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::strconv_Exec(command::strconv_proc& parent) {
    strconv_Start(parent);
    strconv_Wait(parent);
    return parent.status;
}

// --- command.strconv_proc.strconv.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::strconv_ExecX(command::strconv_proc& parent) {
    int rc = strconv_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",strconv_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.strconv_proc.strconv.Execv
// Call execv()
// Call execv with specified parameters
int command::strconv_Execv(command::strconv_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    strconv_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.strconv_proc.strconv.ToCmdline
algo::tempstr command::strconv_ToCmdline(command::strconv_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::strconv_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.strconv_proc.strconv.ToArgv
// Form array from the command line
void command::strconv_ToArgv(command::strconv_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-str:";
        cstring_Print(parent.cmd.str, *arg);
    }

    if (parent.cmd.tocamelcase != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-tocamelcase:";
        bool_Print(parent.cmd.tocamelcase, *arg);
    }

    if (parent.cmd.tolowerunder != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-tolowerunder:";
        bool_Print(parent.cmd.tolowerunder, *arg);
    }

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (parent.cmd.pathcomp != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-pathcomp:";
        Smallstr100_Print(parent.cmd.pathcomp, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.strconv_proc..Uninit
void command::strconv_proc_Uninit(command::strconv_proc& parent) {
    command::strconv_proc &row = parent; (void)row;

    // command.strconv_proc.strconv.Uninit (Exec)  //
    strconv_Kill(parent); // kill child, ensure forward progress
}

// --- command.sv2ssim.field.Print
// Print back to string
void command::field_Print(command::sv2ssim& parent, algo::cstring &out) {
    Regx_Print(parent.field, out);
}

// --- command.sv2ssim.field.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::field_ReadStrptrMaybe(command::sv2ssim& parent, algo::strptr in) {
    bool retval = true;
    Regx_ReadSql(parent.field, in, true);
    return retval;
}

// --- command.sv2ssim..ReadFieldMaybe
bool command::sv2ssim_ReadFieldMaybe(command::sv2ssim& parent, algo::strptr field, algo::strptr strval) {
    bool retval = true;
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    switch(field_id) {
        case command_FieldId_in: {
            retval = algo::cstring_ReadStrptrMaybe(parent.in, strval);
            break;
        }
        case command_FieldId_fname: {
            retval = algo::cstring_ReadStrptrMaybe(parent.fname, strval);
            break;
        }
        case command_FieldId_separator: {
            retval = char_ReadStrptrMaybe(parent.separator, strval);
            break;
        }
        case command_FieldId_outseparator: {
            retval = algo::cstring_ReadStrptrMaybe(parent.outseparator, strval);
            break;
        }
        case command_FieldId_header: {
            retval = bool_ReadStrptrMaybe(parent.header, strval);
            break;
        }
        case command_FieldId_ctype: {
            retval = algo::cstring_ReadStrptrMaybe(parent.ctype, strval);
            break;
        }
        case command_FieldId_ssimfile: {
            retval = algo::cstring_ReadStrptrMaybe(parent.ssimfile, strval);
            break;
        }
        case command_FieldId_schema: {
            retval = bool_ReadStrptrMaybe(parent.schema, strval);
            break;
        }
        case command_FieldId_field: {
            retval = field_ReadStrptrMaybe(parent, strval);
            break;
        }
        case command_FieldId_data: {
            retval = bool_ReadStrptrMaybe(parent.data, strval);
            break;
        }
        case command_FieldId_report: {
            retval = bool_ReadStrptrMaybe(parent.report, strval);
            break;
        }
        case command_FieldId_prefer_signed: {
            retval = bool_ReadStrptrMaybe(parent.prefer_signed, strval);
            break;
        }
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.sv2ssim..ReadTupleMaybe
// Read fields of command::sv2ssim from attributes of ascii tuple TUPLE
bool command::sv2ssim_ReadTupleMaybe(command::sv2ssim &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = sv2ssim_GetAnon(parent, anon_idx++);
        }
        retval = sv2ssim_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.sv2ssim..Init
// Set all fields to initial values.
void command::sv2ssim_Init(command::sv2ssim& parent) {
    parent.in = algo::strptr("data");
    parent.separator = char(',');
    parent.outseparator = algo::strptr("");
    parent.header = bool(true);
    parent.ctype = algo::strptr("");
    parent.ssimfile = algo::strptr("");
    parent.schema = bool(false);
    Regx_ReadSql(parent.field, "%", true);
    parent.data = bool(false);
    parent.report = bool(true);
    parent.prefer_signed = bool(false);
}

// --- command.sv2ssim..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::sv2ssim_ToCmdline(command::sv2ssim& row) {
    tempstr ret;
    ret << "bin/sv2ssim ";
    sv2ssim_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.sv2ssim..PrintArgv
// print string representation of ROW to string STR
// cfmt:command.sv2ssim.Argv  printfmt:Tuple
void command::sv2ssim_PrintArgv(command::sv2ssim& row, algo::cstring& str) {
    algo::tempstr temp;
    (void)temp;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.fname, temp);
    str << " -fname:";
    strptr_PrintBash(temp,str);
    if (!(row.separator == ',')) {
        ch_RemoveAll(temp);
        char_Print(row.separator, temp);
        str << " -separator:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.outseparator == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.outseparator, temp);
        str << " -outseparator:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.header == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.header, temp);
        str << " -header:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ctype == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.ctype, temp);
        str << " -ctype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ssimfile == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.ssimfile, temp);
        str << " -ssimfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.field.expr == "%")) {
        ch_RemoveAll(temp);
        command::field_Print(const_cast<command::sv2ssim&>(row), temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.data, temp);
        str << " -data:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.prefer_signed == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.prefer_signed, temp);
        str << " -prefer_signed:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.sv2ssim..GetAnon
algo::strptr command::sv2ssim_GetAnon(command::sv2ssim &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("fname", 5);
        default: return algo::strptr();
    }
}

// --- command.sv2ssim..NArgs
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32 command::sv2ssim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) {
    i32 retval = 1;
    switch (field) {
        case command_FieldId_in: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_fname: { // $comment
            *out_anon = true;
        } break;
        case command_FieldId_separator: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_outseparator: { // $comment
            *out_anon = false;
        } break;
        case command_FieldId_header: { // $comment
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_ctype: { // bool: no argument required but value may be specified as header:Y
            *out_anon = false;
        } break;
        case command_FieldId_ssimfile: { // bool: no argument required but value may be specified as header:Y
            *out_anon = false;
        } break;
        case command_FieldId_schema: { // bool: no argument required but value may be specified as header:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_field: { // bool: no argument required but value may be specified as schema:Y
            *out_anon = false;
        } break;
        case command_FieldId_data: { // bool: no argument required but value may be specified as schema:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_report: { // bool: no argument required but value may be specified as data:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        case command_FieldId_prefer_signed: { // bool: no argument required but value may be specified as report:Y
            *out_anon = false;
            retval=0;
            out_dflt="Y";
        } break;
        default:
        retval=-1; // unrecognized
    }
    return retval;
}

// --- command.sv2ssim_proc.sv2ssim.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::sv2ssim_Start(command::sv2ssim_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(sv2ssim_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(sv2ssim_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= sv2ssim_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.sv2ssim_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.sv2ssim_proc.sv2ssim.StartRead
// Start subprocess & Read output
algo::Fildes command::sv2ssim_StartRead(command::sv2ssim_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    sv2ssim_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.sv2ssim_proc.sv2ssim.Kill
// Kill subprocess and wait
void command::sv2ssim_Kill(command::sv2ssim_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        sv2ssim_Wait(parent);
    }
}

// --- command.sv2ssim_proc.sv2ssim.Wait
// Wait for subprocess to return
void command::sv2ssim_Wait(command::sv2ssim_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.sv2ssim_proc.sv2ssim.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::sv2ssim_Exec(command::sv2ssim_proc& parent) {
    sv2ssim_Start(parent);
    sv2ssim_Wait(parent);
    return parent.status;
}

// --- command.sv2ssim_proc.sv2ssim.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::sv2ssim_ExecX(command::sv2ssim_proc& parent) {
    int rc = sv2ssim_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",sv2ssim_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.sv2ssim_proc.sv2ssim.Execv
// Call execv()
// Call execv with specified parameters
int command::sv2ssim_Execv(command::sv2ssim_proc& parent) {
    int ret = 0;
    algo::StringAry args;
    sv2ssim_ToArgv(parent, args);
    char **argv = (char**)alloca((ary_N(args)+1)*sizeof(*argv));
    ind_beg(algo::StringAry_ary_curs,arg,args) {
        argv[ind_curs(arg).index] = Zeroterm(arg);
    }ind_end;
    argv[ary_N(args)] = NULL;
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    ret = execv(Zeroterm(parent.path),argv);
    return ret;
}

// --- command.sv2ssim_proc.sv2ssim.ToCmdline
algo::tempstr command::sv2ssim_ToCmdline(command::sv2ssim_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::sv2ssim_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.sv2ssim_proc.sv2ssim.ToArgv
// Form array from the command line
void command::sv2ssim_ToArgv(command::sv2ssim_proc& parent, algo::StringAry& args) {
    ary_RemoveAll(args);
    ary_Alloc(args) << parent.path;

    if (parent.cmd.in != "data") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-in:";
        cstring_Print(parent.cmd.in, *arg);
    }

    if (true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-fname:";
        cstring_Print(parent.cmd.fname, *arg);
    }

    if (parent.cmd.separator != ',') {
        cstring *arg = &ary_Alloc(args);
        *arg << "-separator:";
        char_Print(parent.cmd.separator, *arg);
    }

    if (parent.cmd.outseparator != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-outseparator:";
        cstring_Print(parent.cmd.outseparator, *arg);
    }

    if (parent.cmd.header != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-header:";
        bool_Print(parent.cmd.header, *arg);
    }

    if (parent.cmd.ctype != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ctype:";
        cstring_Print(parent.cmd.ctype, *arg);
    }

    if (parent.cmd.ssimfile != "") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-ssimfile:";
        cstring_Print(parent.cmd.ssimfile, *arg);
    }

    if (parent.cmd.schema != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-schema:";
        bool_Print(parent.cmd.schema, *arg);
    }

    if (parent.cmd.field.expr != "%") {
        cstring *arg = &ary_Alloc(args);
        *arg << "-field:";
        command::field_Print(parent.cmd, *arg);
    }

    if (parent.cmd.data != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-data:";
        bool_Print(parent.cmd.data, *arg);
    }

    if (parent.cmd.report != true) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-report:";
        bool_Print(parent.cmd.report, *arg);
    }

    if (parent.cmd.prefer_signed != false) {
        cstring *arg = &ary_Alloc(args);
        *arg << "-prefer_signed:";
        bool_Print(parent.cmd.prefer_signed, *arg);
    }
    for (int i=1; i < algo_lib::_db.cmdline.verbose; ++i) {
        ary_Alloc(args) << "-verbose";
    }
}

// --- command.sv2ssim_proc..Uninit
void command::sv2ssim_proc_Uninit(command::sv2ssim_proc& parent) {
    command::sv2ssim_proc &row = parent; (void)row;

    // command.sv2ssim_proc.sv2ssim.Uninit (Exec)  //
    sv2ssim_Kill(parent); // kill child, ensure forward progress
}

// --- command...SizeCheck
inline static void command::SizeCheck() {
}
