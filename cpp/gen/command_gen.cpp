//
// cpp/gen/command_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
namespace command {
    static void          SizeCheck();
} // end namespace command

// --- command.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* command::value_ToCstr(const command::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case command_FieldId_target        : ret = "target";  break;
        case command_FieldId_in            : ret = "in";  break;
        case command_FieldId_out_dir       : ret = "out_dir";  break;
        case command_FieldId_cfg           : ret = "cfg";  break;
        case command_FieldId_compiler      : ret = "compiler";  break;
        case command_FieldId_uname         : ret = "uname";  break;
        case command_FieldId_arch          : ret = "arch";  break;
        case command_FieldId_ood           : ret = "ood";  break;
        case command_FieldId_list          : ret = "list";  break;
        case command_FieldId_listincl      : ret = "listincl";  break;
        case command_FieldId_build         : ret = "build";  break;
        case command_FieldId_preproc       : ret = "preproc";  break;
        case command_FieldId_clean         : ret = "clean";  break;
        case command_FieldId_dry_run       : ret = "dry_run";  break;
        case command_FieldId_maxjobs       : ret = "maxjobs";  break;
        case command_FieldId_printcmd      : ret = "printcmd";  break;
        case command_FieldId_force         : ret = "force";  break;
        case command_FieldId_install       : ret = "install";  break;
        case command_FieldId_coverity      : ret = "coverity";  break;
        case command_FieldId_package       : ret = "package";  break;
        case command_FieldId_maxerr        : ret = "maxerr";  break;
        case command_FieldId_disas         : ret = "disas";  break;
        case command_FieldId_report        : ret = "report";  break;
        case command_FieldId_jcdb          : ret = "jcdb";  break;
        case command_FieldId_query         : ret = "query";  break;
        case command_FieldId_select        : ret = "select";  break;
        case command_FieldId_del           : ret = "del";  break;
        case command_FieldId_insert        : ret = "insert";  break;
        case command_FieldId_replace       : ret = "replace";  break;
        case command_FieldId_merge         : ret = "merge";  break;
        case command_FieldId_unused        : ret = "unused";  break;
        case command_FieldId_trunc         : ret = "trunc";  break;
        case command_FieldId_check         : ret = "check";  break;
        case command_FieldId_maxshow       : ret = "maxshow";  break;
        case command_FieldId_write         : ret = "write";  break;
        case command_FieldId_rename        : ret = "rename";  break;
        case command_FieldId_nup           : ret = "nup";  break;
        case command_FieldId_ndown         : ret = "ndown";  break;
        case command_FieldId_xref          : ret = "xref";  break;
        case command_FieldId_fldfunc       : ret = "fldfunc";  break;
        case command_FieldId_maxgroup      : ret = "maxgroup";  break;
        case command_FieldId_pretty        : ret = "pretty";  break;
        case command_FieldId_tree          : ret = "tree";  break;
        case command_FieldId_loose         : ret = "loose";  break;
        case command_FieldId_my            : ret = "my";  break;
        case command_FieldId_schema        : ret = "schema";  break;
        case command_FieldId_e             : ret = "e";  break;
        case command_FieldId_b             : ret = "b";  break;
        case command_FieldId_t             : ret = "t";  break;
        case command_FieldId_rowid         : ret = "rowid";  break;
        case command_FieldId_cmt           : ret = "cmt";  break;
        case command_FieldId_print         : ret = "print";  break;
        case command_FieldId_cmd           : ret = "cmd";  break;
        case command_FieldId_field         : ret = "field";  break;
        case command_FieldId_regxof        : ret = "regxof";  break;
        case command_FieldId_meta          : ret = "meta";  break;
        case command_FieldId_line          : ret = "line";  break;
        case command_FieldId_point         : ret = "point";  break;
        case command_FieldId_type          : ret = "type";  break;
        case command_FieldId_create        : ret = "create";  break;
        case command_FieldId_finput        : ret = "finput";  break;
        case command_FieldId_foutput       : ret = "foutput";  break;
        case command_FieldId_srcfile       : ret = "srcfile";  break;
        case command_FieldId_gstatic       : ret = "gstatic";  break;
        case command_FieldId_indexed       : ret = "indexed";  break;
        case command_FieldId_nstype        : ret = "nstype";  break;
        case command_FieldId_ctype         : ret = "ctype";  break;
        case command_FieldId_pooltype      : ret = "pooltype";  break;
        case command_FieldId_ssimfile      : ret = "ssimfile";  break;
        case command_FieldId_subset        : ret = "subset";  break;
        case command_FieldId_subset2       : ret = "subset2";  break;
        case command_FieldId_separator     : ret = "separator";  break;
        case command_FieldId_arg           : ret = "arg";  break;
        case command_FieldId_dflt          : ret = "dflt";  break;
        case command_FieldId_anon          : ret = "anon";  break;
        case command_FieldId_bigend        : ret = "bigend";  break;
        case command_FieldId_cascdel       : ret = "cascdel";  break;
        case command_FieldId_before        : ret = "before";  break;
        case command_FieldId_substr        : ret = "substr";  break;
        case command_FieldId_srcfield      : ret = "srcfield";  break;
        case command_FieldId_fstep         : ret = "fstep";  break;
        case command_FieldId_inscond       : ret = "inscond";  break;
        case command_FieldId_reftype       : ret = "reftype";  break;
        case command_FieldId_hashfld       : ret = "hashfld";  break;
        case command_FieldId_sortfld       : ret = "sortfld";  break;
        case command_FieldId_unittest      : ret = "unittest";  break;
        case command_FieldId_normcheck     : ret = "normcheck";  break;
        case command_FieldId_cppfunc       : ret = "cppfunc";  break;
        case command_FieldId_via           : ret = "via";  break;
        case command_FieldId_comment       : ret = "comment";  break;
        case command_FieldId_sandbox       : ret = "sandbox";  break;
        case command_FieldId_test          : ret = "test";  break;
        case command_FieldId_showcpp       : ret = "showcpp";  break;
        case command_FieldId_ns            : ret = "ns";  break;
        case command_FieldId_data          : ret = "data";  break;
        case command_FieldId_sigcheck      : ret = "sigcheck";  break;
        case command_FieldId_data_dir      : ret = "data_dir";  break;
        case command_FieldId_related       : ret = "related";  break;
        case command_FieldId_notssimfile   : ret = "notssimfile";  break;
        case command_FieldId_checkable     : ret = "checkable";  break;
        case command_FieldId_nsdb          : ret = "nsdb";  break;
        case command_FieldId_fkey          : ret = "fkey";  break;
        case command_FieldId_start         : ret = "start";  break;
        case command_FieldId_stop          : ret = "stop";  break;
        case command_FieldId_abort         : ret = "abort";  break;
        case command_FieldId_shell         : ret = "shell";  break;
        case command_FieldId_serv          : ret = "serv";  break;
        case command_FieldId_in_dir        : ret = "in_dir";  break;
        case command_FieldId_proto         : ret = "proto";  break;
        case command_FieldId_trace         : ret = "trace";  break;
        case command_FieldId_fconst        : ret = "fconst";  break;
        case command_FieldId_gconst        : ret = "gconst";  break;
        case command_FieldId_key           : ret = "key";  break;
        case command_FieldId_include       : ret = "include";  break;
        case command_FieldId_dot           : ret = "dot";  break;
        case command_FieldId_xns           : ret = "xns";  break;
        case command_FieldId_noinput       : ret = "noinput";  break;
        case command_FieldId_render        : ret = "render";  break;
        case command_FieldId_amctest       : ret = "amctest";  break;
        case command_FieldId_dofork        : ret = "dofork";  break;
        case command_FieldId_q             : ret = "q";  break;
        case command_FieldId_ncmd          : ret = "ncmd";  break;
        case command_FieldId_nofork        : ret = "nofork";  break;
        case command_FieldId_debug         : ret = "debug";  break;
        case command_FieldId_perf_secs     : ret = "perf_secs";  break;
        case command_FieldId_pertest_timeout: ret = "pertest_timeout";  break;
        case command_FieldId_capture       : ret = "capture";  break;
        case command_FieldId_mrlist        : ret = "mrlist";  break;
        case command_FieldId_mergereq      : ret = "mergereq";  break;
        case command_FieldId_ilist         : ret = "ilist";  break;
        case command_FieldId_istart        : ret = "istart";  break;
        case command_FieldId_iadd          : ret = "iadd";  break;
        case command_FieldId_ic            : ret = "ic";  break;
        case command_FieldId_iclose        : ret = "iclose";  break;
        case command_FieldId_iassignto     : ret = "iassignto";  break;
        case command_FieldId_title         : ret = "title";  break;
        case command_FieldId_description   : ret = "description";  break;
        case command_FieldId_gitdir        : ret = "gitdir";  break;
        case command_FieldId_assignee      : ret = "assignee";  break;
        case command_FieldId_ulist         : ret = "ulist";  break;
        case command_FieldId_mraccept      : ret = "mraccept";  break;
        case command_FieldId_auth_token    : ret = "auth_token";  break;
        case command_FieldId_host          : ret = "host";  break;
        case command_FieldId_complooo      : ret = "complooo";  break;
        case command_FieldId_args          : ret = "args";  break;
        case command_FieldId_manywin       : ret = "manywin";  break;
        case command_FieldId_root          : ret = "root";  break;
        case command_FieldId_attach        : ret = "attach";  break;
        case command_FieldId_catchthrow    : ret = "catchthrow";  break;
        case command_FieldId_tui           : ret = "tui";  break;
        case command_FieldId_bcmd          : ret = "bcmd";  break;
        case command_FieldId_emacs         : ret = "emacs";  break;
        case command_FieldId_follow_child  : ret = "follow_child";  break;
        case command_FieldId_py            : ret = "py";  break;
        case command_FieldId_writessimfile : ret = "writessimfile";  break;
        case command_FieldId_url           : ret = "url";  break;
        case command_FieldId_tables        : ret = "tables";  break;
        case command_FieldId_nologo        : ret = "nologo";  break;
        case command_FieldId_baddbok       : ret = "baddbok";  break;
        case command_FieldId_typetag       : ret = "typetag";  break;
        case command_FieldId_move          : ret = "move";  break;
        case command_FieldId_dedup         : ret = "dedup";  break;
        case command_FieldId_commit        : ret = "commit";  break;
        case command_FieldId_undo          : ret = "undo";  break;
        case command_FieldId_hash          : ret = "hash";  break;
        case command_FieldId_targsrc       : ret = "targsrc";  break;
        case command_FieldId_name          : ret = "name";  break;
        case command_FieldId_body          : ret = "body";  break;
        case command_FieldId_func          : ret = "func";  break;
        case command_FieldId_nextfile      : ret = "nextfile";  break;
        case command_FieldId_other         : ret = "other";  break;
        case command_FieldId_updateproto   : ret = "updateproto";  break;
        case command_FieldId_listfunc      : ret = "listfunc";  break;
        case command_FieldId_iffy          : ret = "iffy";  break;
        case command_FieldId_gen           : ret = "gen";  break;
        case command_FieldId_showloc       : ret = "showloc";  break;
        case command_FieldId_showstatic    : ret = "showstatic";  break;
        case command_FieldId_showsortkey   : ret = "showsortkey";  break;
        case command_FieldId_sortname      : ret = "sortname";  break;
        case command_FieldId_baddecl       : ret = "baddecl";  break;
        case command_FieldId_update_authors: ret = "update_authors";  break;
        case command_FieldId_indent        : ret = "indent";  break;
        case command_FieldId_linelim       : ret = "linelim";  break;
        case command_FieldId_strayfile     : ret = "strayfile";  break;
        case command_FieldId_badchar       : ret = "badchar";  break;
        case command_FieldId_badline       : ret = "badline";  break;
        case command_FieldId_expand        : ret = "expand";  break;
        case command_FieldId_ignoreQuote   : ret = "ignoreQuote";  break;
        case command_FieldId_maxpacket     : ret = "maxpacket";  break;
        case command_FieldId_db            : ret = "db";  break;
        case command_FieldId_createdb      : ret = "createdb";  break;
        case command_FieldId_str           : ret = "str";  break;
        case command_FieldId_tocamelcase   : ret = "tocamelcase";  break;
        case command_FieldId_tolowerunder  : ret = "tolowerunder";  break;
        case command_FieldId_pathcomp      : ret = "pathcomp";  break;
        case command_FieldId_value         : ret = "value";  break;
    }
    return ret;
}

// --- command.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void command::value_Print(const command::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- command.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 1: {
            switch (u64(rhs[0])) {
                case 'b': {
                    value_SetEnum(parent,command_FieldId_b); ret = true; break;
                }
                case 'e': {
                    value_SetEnum(parent,command_FieldId_e); ret = true; break;
                }
                case 'q': {
                    value_SetEnum(parent,command_FieldId_q); ret = true; break;
                }
                case 't': {
                    value_SetEnum(parent,command_FieldId_t); ret = true; break;
                }
            }
            break;
        }
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('d','b'): {
                    value_SetEnum(parent,command_FieldId_db); ret = true; break;
                }
                case LE_STR2('i','c'): {
                    value_SetEnum(parent,command_FieldId_ic); ret = true; break;
                }
                case LE_STR2('i','n'): {
                    value_SetEnum(parent,command_FieldId_in); ret = true; break;
                }
                case LE_STR2('m','y'): {
                    value_SetEnum(parent,command_FieldId_my); ret = true; break;
                }
                case LE_STR2('n','s'): {
                    value_SetEnum(parent,command_FieldId_ns); ret = true; break;
                }
                case LE_STR2('p','y'): {
                    value_SetEnum(parent,command_FieldId_py); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','r','g'): {
                    value_SetEnum(parent,command_FieldId_arg); ret = true; break;
                }
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,command_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('c','m','d'): {
                    value_SetEnum(parent,command_FieldId_cmd); ret = true; break;
                }
                case LE_STR3('c','m','t'): {
                    value_SetEnum(parent,command_FieldId_cmt); ret = true; break;
                }
                case LE_STR3('d','e','l'): {
                    value_SetEnum(parent,command_FieldId_del); ret = true; break;
                }
                case LE_STR3('d','o','t'): {
                    value_SetEnum(parent,command_FieldId_dot); ret = true; break;
                }
                case LE_STR3('g','e','n'): {
                    value_SetEnum(parent,command_FieldId_gen); ret = true; break;
                }
                case LE_STR3('k','e','y'): {
                    value_SetEnum(parent,command_FieldId_key); ret = true; break;
                }
                case LE_STR3('n','u','p'): {
                    value_SetEnum(parent,command_FieldId_nup); ret = true; break;
                }
                case LE_STR3('o','o','d'): {
                    value_SetEnum(parent,command_FieldId_ood); ret = true; break;
                }
                case LE_STR3('s','t','r'): {
                    value_SetEnum(parent,command_FieldId_str); ret = true; break;
                }
                case LE_STR3('t','u','i'): {
                    value_SetEnum(parent,command_FieldId_tui); ret = true; break;
                }
                case LE_STR3('u','r','l'): {
                    value_SetEnum(parent,command_FieldId_url); ret = true; break;
                }
                case LE_STR3('v','i','a'): {
                    value_SetEnum(parent,command_FieldId_via); ret = true; break;
                }
                case LE_STR3('x','n','s'): {
                    value_SetEnum(parent,command_FieldId_xns); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','n','o','n'): {
                    value_SetEnum(parent,command_FieldId_anon); ret = true; break;
                }
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,command_FieldId_arch); ret = true; break;
                }
                case LE_STR4('a','r','g','s'): {
                    value_SetEnum(parent,command_FieldId_args); ret = true; break;
                }
                case LE_STR4('b','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_bcmd); ret = true; break;
                }
                case LE_STR4('b','o','d','y'): {
                    value_SetEnum(parent,command_FieldId_body); ret = true; break;
                }
                case LE_STR4('d','a','t','a'): {
                    value_SetEnum(parent,command_FieldId_data); ret = true; break;
                }
                case LE_STR4('d','f','l','t'): {
                    value_SetEnum(parent,command_FieldId_dflt); ret = true; break;
                }
                case LE_STR4('f','k','e','y'): {
                    value_SetEnum(parent,command_FieldId_fkey); ret = true; break;
                }
                case LE_STR4('f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_func); ret = true; break;
                }
                case LE_STR4('h','a','s','h'): {
                    value_SetEnum(parent,command_FieldId_hash); ret = true; break;
                }
                case LE_STR4('h','o','s','t'): {
                    value_SetEnum(parent,command_FieldId_host); ret = true; break;
                }
                case LE_STR4('i','a','d','d'): {
                    value_SetEnum(parent,command_FieldId_iadd); ret = true; break;
                }
                case LE_STR4('i','f','f','y'): {
                    value_SetEnum(parent,command_FieldId_iffy); ret = true; break;
                }
                case LE_STR4('j','c','d','b'): {
                    value_SetEnum(parent,command_FieldId_jcdb); ret = true; break;
                }
                case LE_STR4('l','i','n','e'): {
                    value_SetEnum(parent,command_FieldId_line); ret = true; break;
                }
                case LE_STR4('l','i','s','t'): {
                    value_SetEnum(parent,command_FieldId_list); ret = true; break;
                }
                case LE_STR4('m','e','t','a'): {
                    value_SetEnum(parent,command_FieldId_meta); ret = true; break;
                }
                case LE_STR4('m','o','v','e'): {
                    value_SetEnum(parent,command_FieldId_move); ret = true; break;
                }
                case LE_STR4('n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_name); ret = true; break;
                }
                case LE_STR4('n','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_ncmd); ret = true; break;
                }
                case LE_STR4('n','s','d','b'): {
                    value_SetEnum(parent,command_FieldId_nsdb); ret = true; break;
                }
                case LE_STR4('r','o','o','t'): {
                    value_SetEnum(parent,command_FieldId_root); ret = true; break;
                }
                case LE_STR4('s','e','r','v'): {
                    value_SetEnum(parent,command_FieldId_serv); ret = true; break;
                }
                case LE_STR4('s','t','o','p'): {
                    value_SetEnum(parent,command_FieldId_stop); ret = true; break;
                }
                case LE_STR4('t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_test); ret = true; break;
                }
                case LE_STR4('t','r','e','e'): {
                    value_SetEnum(parent,command_FieldId_tree); ret = true; break;
                }
                case LE_STR4('t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_type); ret = true; break;
                }
                case LE_STR4('u','n','d','o'): {
                    value_SetEnum(parent,command_FieldId_undo); ret = true; break;
                }
                case LE_STR4('x','r','e','f'): {
                    value_SetEnum(parent,command_FieldId_xref); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('a','b','o','r','t'): {
                    value_SetEnum(parent,command_FieldId_abort); ret = true; break;
                }
                case LE_STR5('b','u','i','l','d'): {
                    value_SetEnum(parent,command_FieldId_build); ret = true; break;
                }
                case LE_STR5('c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_check); ret = true; break;
                }
                case LE_STR5('c','l','e','a','n'): {
                    value_SetEnum(parent,command_FieldId_clean); ret = true; break;
                }
                case LE_STR5('c','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_ctype); ret = true; break;
                }
                case LE_STR5('d','e','b','u','g'): {
                    value_SetEnum(parent,command_FieldId_debug); ret = true; break;
                }
                case LE_STR5('d','e','d','u','p'): {
                    value_SetEnum(parent,command_FieldId_dedup); ret = true; break;
                }
                case LE_STR5('d','i','s','a','s'): {
                    value_SetEnum(parent,command_FieldId_disas); ret = true; break;
                }
                case LE_STR5('e','m','a','c','s'): {
                    value_SetEnum(parent,command_FieldId_emacs); ret = true; break;
                }
                case LE_STR5('f','i','e','l','d'): {
                    value_SetEnum(parent,command_FieldId_field); ret = true; break;
                }
                case LE_STR5('f','o','r','c','e'): {
                    value_SetEnum(parent,command_FieldId_force); ret = true; break;
                }
                case LE_STR5('f','s','t','e','p'): {
                    value_SetEnum(parent,command_FieldId_fstep); ret = true; break;
                }
                case LE_STR5('i','l','i','s','t'): {
                    value_SetEnum(parent,command_FieldId_ilist); ret = true; break;
                }
                case LE_STR5('l','o','o','s','e'): {
                    value_SetEnum(parent,command_FieldId_loose); ret = true; break;
                }
                case LE_STR5('m','e','r','g','e'): {
                    value_SetEnum(parent,command_FieldId_merge); ret = true; break;
                }
                case LE_STR5('n','d','o','w','n'): {
                    value_SetEnum(parent,command_FieldId_ndown); ret = true; break;
                }
                case LE_STR5('o','t','h','e','r'): {
                    value_SetEnum(parent,command_FieldId_other); ret = true; break;
                }
                case LE_STR5('p','o','i','n','t'): {
                    value_SetEnum(parent,command_FieldId_point); ret = true; break;
                }
                case LE_STR5('p','r','i','n','t'): {
                    value_SetEnum(parent,command_FieldId_print); ret = true; break;
                }
                case LE_STR5('p','r','o','t','o'): {
                    value_SetEnum(parent,command_FieldId_proto); ret = true; break;
                }
                case LE_STR5('q','u','e','r','y'): {
                    value_SetEnum(parent,command_FieldId_query); ret = true; break;
                }
                case LE_STR5('r','o','w','i','d'): {
                    value_SetEnum(parent,command_FieldId_rowid); ret = true; break;
                }
                case LE_STR5('s','h','e','l','l'): {
                    value_SetEnum(parent,command_FieldId_shell); ret = true; break;
                }
                case LE_STR5('s','t','a','r','t'): {
                    value_SetEnum(parent,command_FieldId_start); ret = true; break;
                }
                case LE_STR5('t','i','t','l','e'): {
                    value_SetEnum(parent,command_FieldId_title); ret = true; break;
                }
                case LE_STR5('t','r','a','c','e'): {
                    value_SetEnum(parent,command_FieldId_trace); ret = true; break;
                }
                case LE_STR5('t','r','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_trunc); ret = true; break;
                }
                case LE_STR5('u','l','i','s','t'): {
                    value_SetEnum(parent,command_FieldId_ulist); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,command_FieldId_value); ret = true; break;
                }
                case LE_STR5('w','r','i','t','e'): {
                    value_SetEnum(parent,command_FieldId_write); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','t','t','a','c','h'): {
                    value_SetEnum(parent,command_FieldId_attach); ret = true; break;
                }
                case LE_STR6('b','e','f','o','r','e'): {
                    value_SetEnum(parent,command_FieldId_before); ret = true; break;
                }
                case LE_STR6('b','i','g','e','n','d'): {
                    value_SetEnum(parent,command_FieldId_bigend); ret = true; break;
                }
                case LE_STR6('c','o','m','m','i','t'): {
                    value_SetEnum(parent,command_FieldId_commit); ret = true; break;
                }
                case LE_STR6('c','r','e','a','t','e'): {
                    value_SetEnum(parent,command_FieldId_create); ret = true; break;
                }
                case LE_STR6('d','o','f','o','r','k'): {
                    value_SetEnum(parent,command_FieldId_dofork); ret = true; break;
                }
                case LE_STR6('e','x','p','a','n','d'): {
                    value_SetEnum(parent,command_FieldId_expand); ret = true; break;
                }
                case LE_STR6('f','c','o','n','s','t'): {
                    value_SetEnum(parent,command_FieldId_fconst); ret = true; break;
                }
                case LE_STR6('f','i','n','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_finput); ret = true; break;
                }
                case LE_STR6('g','c','o','n','s','t'): {
                    value_SetEnum(parent,command_FieldId_gconst); ret = true; break;
                }
                case LE_STR6('g','i','t','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_gitdir); ret = true; break;
                }
                case LE_STR6('i','c','l','o','s','e'): {
                    value_SetEnum(parent,command_FieldId_iclose); ret = true; break;
                }
                case LE_STR6('i','n','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_in_dir); ret = true; break;
                }
                case LE_STR6('i','n','d','e','n','t'): {
                    value_SetEnum(parent,command_FieldId_indent); ret = true; break;
                }
                case LE_STR6('i','n','s','e','r','t'): {
                    value_SetEnum(parent,command_FieldId_insert); ret = true; break;
                }
                case LE_STR6('i','s','t','a','r','t'): {
                    value_SetEnum(parent,command_FieldId_istart); ret = true; break;
                }
                case LE_STR6('m','a','x','e','r','r'): {
                    value_SetEnum(parent,command_FieldId_maxerr); ret = true; break;
                }
                case LE_STR6('m','r','l','i','s','t'): {
                    value_SetEnum(parent,command_FieldId_mrlist); ret = true; break;
                }
                case LE_STR6('n','o','f','o','r','k'): {
                    value_SetEnum(parent,command_FieldId_nofork); ret = true; break;
                }
                case LE_STR6('n','o','l','o','g','o'): {
                    value_SetEnum(parent,command_FieldId_nologo); ret = true; break;
                }
                case LE_STR6('n','s','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_nstype); ret = true; break;
                }
                case LE_STR6('p','r','e','t','t','y'): {
                    value_SetEnum(parent,command_FieldId_pretty); ret = true; break;
                }
                case LE_STR6('r','e','g','x','o','f'): {
                    value_SetEnum(parent,command_FieldId_regxof); ret = true; break;
                }
                case LE_STR6('r','e','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_rename); ret = true; break;
                }
                case LE_STR6('r','e','n','d','e','r'): {
                    value_SetEnum(parent,command_FieldId_render); ret = true; break;
                }
                case LE_STR6('r','e','p','o','r','t'): {
                    value_SetEnum(parent,command_FieldId_report); ret = true; break;
                }
                case LE_STR6('s','c','h','e','m','a'): {
                    value_SetEnum(parent,command_FieldId_schema); ret = true; break;
                }
                case LE_STR6('s','e','l','e','c','t'): {
                    value_SetEnum(parent,command_FieldId_select); ret = true; break;
                }
                case LE_STR6('s','u','b','s','e','t'): {
                    value_SetEnum(parent,command_FieldId_subset); ret = true; break;
                }
                case LE_STR6('s','u','b','s','t','r'): {
                    value_SetEnum(parent,command_FieldId_substr); ret = true; break;
                }
                case LE_STR6('t','a','b','l','e','s'): {
                    value_SetEnum(parent,command_FieldId_tables); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,command_FieldId_target); ret = true; break;
                }
                case LE_STR6('u','n','u','s','e','d'): {
                    value_SetEnum(parent,command_FieldId_unused); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','m','c','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_amctest); ret = true; break;
                }
                case LE_STR7('b','a','d','c','h','a','r'): {
                    value_SetEnum(parent,command_FieldId_badchar); ret = true; break;
                }
                case LE_STR7('b','a','d','d','b','o','k'): {
                    value_SetEnum(parent,command_FieldId_baddbok); ret = true; break;
                }
                case LE_STR7('b','a','d','d','e','c','l'): {
                    value_SetEnum(parent,command_FieldId_baddecl); ret = true; break;
                }
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,command_FieldId_badline); ret = true; break;
                }
                case LE_STR7('c','a','p','t','u','r','e'): {
                    value_SetEnum(parent,command_FieldId_capture); ret = true; break;
                }
                case LE_STR7('c','a','s','c','d','e','l'): {
                    value_SetEnum(parent,command_FieldId_cascdel); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,command_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','p','p','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_cppfunc); ret = true; break;
                }
                case LE_STR7('d','r','y','_','r','u','n'): {
                    value_SetEnum(parent,command_FieldId_dry_run); ret = true; break;
                }
                case LE_STR7('f','l','d','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_fldfunc); ret = true; break;
                }
                case LE_STR7('f','o','u','t','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_foutput); ret = true; break;
                }
                case LE_STR7('g','s','t','a','t','i','c'): {
                    value_SetEnum(parent,command_FieldId_gstatic); ret = true; break;
                }
                case LE_STR7('h','a','s','h','f','l','d'): {
                    value_SetEnum(parent,command_FieldId_hashfld); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,command_FieldId_include); ret = true; break;
                }
                case LE_STR7('i','n','d','e','x','e','d'): {
                    value_SetEnum(parent,command_FieldId_indexed); ret = true; break;
                }
                case LE_STR7('i','n','s','c','o','n','d'): {
                    value_SetEnum(parent,command_FieldId_inscond); ret = true; break;
                }
                case LE_STR7('i','n','s','t','a','l','l'): {
                    value_SetEnum(parent,command_FieldId_install); ret = true; break;
                }
                case LE_STR7('l','i','n','e','l','i','m'): {
                    value_SetEnum(parent,command_FieldId_linelim); ret = true; break;
                }
                case LE_STR7('m','a','n','y','w','i','n'): {
                    value_SetEnum(parent,command_FieldId_manywin); ret = true; break;
                }
                case LE_STR7('m','a','x','j','o','b','s'): {
                    value_SetEnum(parent,command_FieldId_maxjobs); ret = true; break;
                }
                case LE_STR7('m','a','x','s','h','o','w'): {
                    value_SetEnum(parent,command_FieldId_maxshow); ret = true; break;
                }
                case LE_STR7('n','o','i','n','p','u','t'): {
                    value_SetEnum(parent,command_FieldId_noinput); ret = true; break;
                }
                case LE_STR7('o','u','t','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_out_dir); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,command_FieldId_package); ret = true; break;
                }
                case LE_STR7('p','r','e','p','r','o','c'): {
                    value_SetEnum(parent,command_FieldId_preproc); ret = true; break;
                }
                case LE_STR7('r','e','f','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_reftype); ret = true; break;
                }
                case LE_STR7('r','e','l','a','t','e','d'): {
                    value_SetEnum(parent,command_FieldId_related); ret = true; break;
                }
                case LE_STR7('r','e','p','l','a','c','e'): {
                    value_SetEnum(parent,command_FieldId_replace); ret = true; break;
                }
                case LE_STR7('s','a','n','d','b','o','x'): {
                    value_SetEnum(parent,command_FieldId_sandbox); ret = true; break;
                }
                case LE_STR7('s','h','o','w','c','p','p'): {
                    value_SetEnum(parent,command_FieldId_showcpp); ret = true; break;
                }
                case LE_STR7('s','h','o','w','l','o','c'): {
                    value_SetEnum(parent,command_FieldId_showloc); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,command_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('s','u','b','s','e','t','2'): {
                    value_SetEnum(parent,command_FieldId_subset2); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,command_FieldId_targsrc); ret = true; break;
                }
                case LE_STR7('t','y','p','e','t','a','g'): {
                    value_SetEnum(parent,command_FieldId_typetag); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','s','s','i','g','n','e','e'): {
                    value_SetEnum(parent,command_FieldId_assignee); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,command_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('c','o','m','p','l','o','o','o'): {
                    value_SetEnum(parent,command_FieldId_complooo); ret = true; break;
                }
                case LE_STR8('c','o','v','e','r','i','t','y'): {
                    value_SetEnum(parent,command_FieldId_coverity); ret = true; break;
                }
                case LE_STR8('c','r','e','a','t','e','d','b'): {
                    value_SetEnum(parent,command_FieldId_createdb); ret = true; break;
                }
                case LE_STR8('d','a','t','a','_','d','i','r'): {
                    value_SetEnum(parent,command_FieldId_data_dir); ret = true; break;
                }
                case LE_STR8('l','i','s','t','f','u','n','c'): {
                    value_SetEnum(parent,command_FieldId_listfunc); ret = true; break;
                }
                case LE_STR8('l','i','s','t','i','n','c','l'): {
                    value_SetEnum(parent,command_FieldId_listincl); ret = true; break;
                }
                case LE_STR8('m','a','x','g','r','o','u','p'): {
                    value_SetEnum(parent,command_FieldId_maxgroup); ret = true; break;
                }
                case LE_STR8('m','e','r','g','e','r','e','q'): {
                    value_SetEnum(parent,command_FieldId_mergereq); ret = true; break;
                }
                case LE_STR8('m','r','a','c','c','e','p','t'): {
                    value_SetEnum(parent,command_FieldId_mraccept); ret = true; break;
                }
                case LE_STR8('n','e','x','t','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_nextfile); ret = true; break;
                }
                case LE_STR8('p','a','t','h','c','o','m','p'): {
                    value_SetEnum(parent,command_FieldId_pathcomp); ret = true; break;
                }
                case LE_STR8('p','o','o','l','t','y','p','e'): {
                    value_SetEnum(parent,command_FieldId_pooltype); ret = true; break;
                }
                case LE_STR8('p','r','i','n','t','c','m','d'): {
                    value_SetEnum(parent,command_FieldId_printcmd); ret = true; break;
                }
                case LE_STR8('s','i','g','c','h','e','c','k'): {
                    value_SetEnum(parent,command_FieldId_sigcheck); ret = true; break;
                }
                case LE_STR8('s','o','r','t','n','a','m','e'): {
                    value_SetEnum(parent,command_FieldId_sortname); ret = true; break;
                }
                case LE_STR8('s','r','c','f','i','e','l','d'): {
                    value_SetEnum(parent,command_FieldId_srcfield); ret = true; break;
                }
                case LE_STR8('s','s','i','m','f','i','l','e'): {
                    value_SetEnum(parent,command_FieldId_ssimfile); ret = true; break;
                }
                case LE_STR8('u','n','i','t','t','e','s','t'): {
                    value_SetEnum(parent,command_FieldId_unittest); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','e','c','k','a','b','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_checkable); ret = true; break; }
                    break;
                }
                case LE_STR8('i','a','s','s','i','g','n','t'): {
                    if (memcmp(rhs.elems+8,"o",1)==0) { value_SetEnum(parent,command_FieldId_iassignto); ret = true; break; }
                    break;
                }
                case LE_STR8('m','a','x','p','a','c','k','e'): {
                    if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,command_FieldId_maxpacket); ret = true; break; }
                    break;
                }
                case LE_STR8('n','o','r','m','c','h','e','c'): {
                    if (memcmp(rhs.elems+8,"k",1)==0) { value_SetEnum(parent,command_FieldId_normcheck); ret = true; break; }
                    break;
                }
                case LE_STR8('p','e','r','f','_','s','e','c'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,command_FieldId_perf_secs); ret = true; break; }
                    break;
                }
                case LE_STR8('s','e','p','a','r','a','t','o'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { value_SetEnum(parent,command_FieldId_separator); ret = true; break; }
                    break;
                }
                case LE_STR8('s','t','r','a','y','f','i','l'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_strayfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','u','t','h','_','t','o','k'): {
                    if (memcmp(rhs.elems+8,"en",2)==0) { value_SetEnum(parent,command_FieldId_auth_token); ret = true; break; }
                    break;
                }
                case LE_STR8('c','a','t','c','h','t','h','r'): {
                    if (memcmp(rhs.elems+8,"ow",2)==0) { value_SetEnum(parent,command_FieldId_catchthrow); ret = true; break; }
                    break;
                }
                case LE_STR8('s','h','o','w','s','t','a','t'): {
                    if (memcmp(rhs.elems+8,"ic",2)==0) { value_SetEnum(parent,command_FieldId_showstatic); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','s','c','r','i','p','t'): {
                    if (memcmp(rhs.elems+8,"ion",3)==0) { value_SetEnum(parent,command_FieldId_description); ret = true; break; }
                    break;
                }
                case LE_STR8('i','g','n','o','r','e','Q','u'): {
                    if (memcmp(rhs.elems+8,"ote",3)==0) { value_SetEnum(parent,command_FieldId_ignoreQuote); ret = true; break; }
                    break;
                }
                case LE_STR8('n','o','t','s','s','i','m','f'): {
                    if (memcmp(rhs.elems+8,"ile",3)==0) { value_SetEnum(parent,command_FieldId_notssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('s','h','o','w','s','o','r','t'): {
                    if (memcmp(rhs.elems+8,"key",3)==0) { value_SetEnum(parent,command_FieldId_showsortkey); ret = true; break; }
                    break;
                }
                case LE_STR8('t','o','c','a','m','e','l','c'): {
                    if (memcmp(rhs.elems+8,"ase",3)==0) { value_SetEnum(parent,command_FieldId_tocamelcase); ret = true; break; }
                    break;
                }
                case LE_STR8('u','p','d','a','t','e','p','r'): {
                    if (memcmp(rhs.elems+8,"oto",3)==0) { value_SetEnum(parent,command_FieldId_updateproto); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','o','l','l','o','w','_','c'): {
                    if (memcmp(rhs.elems+8,"hild",4)==0) { value_SetEnum(parent,command_FieldId_follow_child); ret = true; break; }
                    break;
                }
                case LE_STR8('t','o','l','o','w','e','r','u'): {
                    if (memcmp(rhs.elems+8,"nder",4)==0) { value_SetEnum(parent,command_FieldId_tolowerunder); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('w','r','i','t','e','s','s','i'): {
                    if (memcmp(rhs.elems+8,"mfile",5)==0) { value_SetEnum(parent,command_FieldId_writessimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('u','p','d','a','t','e','_','a'): {
                    if (memcmp(rhs.elems+8,"uthors",6)==0) { value_SetEnum(parent,command_FieldId_update_authors); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','e','r','t','e','s','t','_'): {
                    if (memcmp(rhs.elems+8,"timeout",7)==0) { value_SetEnum(parent,command_FieldId_pertest_timeout); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- command.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void command::value_SetStrptr(command::FieldId& parent, algo::strptr rhs, command_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- command.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool command::value_ReadStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- command.FieldId..ReadStrptrMaybe
// Read fields of command::FieldId from an ascii string.
// The format of the string is the format of the command::FieldId's only field
bool command::FieldId_ReadStrptrMaybe(command::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && command::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- command.FieldId..Print
// print string representation of command::FieldId to string LHS, no header -- cprint:command.FieldId.String
void command::FieldId_Print(command::FieldId & row, algo::cstring &str) {
    command::value_Print(row, str);
}

// --- command.Protocol.proto.StaticCheck
void command::StaticCheck() {
    algo_assert(_offset_of(command::FieldId, value) + sizeof(((command::FieldId*)0)->value) == sizeof(command::FieldId));
}

// --- command.abt.target.Print
// Print back to string
void command::target_Print(command::abt& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.abt.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::abt& parent, algo::strptr in) {
    Regx_ReadSql(parent.target, in, true);
    bool retval = true;// !parent.target.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.abt.disas.Print
// Print back to string
void command::disas_Print(command::abt& parent, algo::cstring &out) {
    Regx_Print(parent.disas, out);
}

// --- command.abt.disas.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::disas_ReadStrptrMaybe(command::abt& parent, algo::strptr in) {
    Regx_ReadSql(parent.disas, in, false);
    bool retval = true;// !parent.disas.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.abt..ReadFieldMaybe
bool command::abt_ReadFieldMaybe(command::abt &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_target: retval = target_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_out_dir: retval = algo::cstring_ReadStrptrMaybe(parent.out_dir, strval); break;
        case command_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case command_FieldId_compiler: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval); break;
        case command_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case command_FieldId_arch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval); break;
        case command_FieldId_ood: retval = bool_ReadStrptrMaybe(parent.ood, strval); break;
        case command_FieldId_list: retval = bool_ReadStrptrMaybe(parent.list, strval); break;
        case command_FieldId_listincl: retval = bool_ReadStrptrMaybe(parent.listincl, strval); break;
        case command_FieldId_build: retval = bool_ReadStrptrMaybe(parent.build, strval); break;
        case command_FieldId_preproc: retval = bool_ReadStrptrMaybe(parent.preproc, strval); break;
        case command_FieldId_clean: retval = bool_ReadStrptrMaybe(parent.clean, strval); break;
        case command_FieldId_dry_run: retval = bool_ReadStrptrMaybe(parent.dry_run, strval); break;
        case command_FieldId_maxjobs: retval = i32_ReadStrptrMaybe(parent.maxjobs, strval); break;
        case command_FieldId_printcmd: retval = bool_ReadStrptrMaybe(parent.printcmd, strval); break;
        case command_FieldId_force: retval = bool_ReadStrptrMaybe(parent.force, strval); break;
        case command_FieldId_install: retval = bool_ReadStrptrMaybe(parent.install, strval); break;
        case command_FieldId_coverity: retval = bool_ReadStrptrMaybe(parent.coverity, strval); break;
        case command_FieldId_package: retval = algo::cstring_ReadStrptrMaybe(parent.package, strval); break;
        case command_FieldId_maxerr: retval = u32_ReadStrptrMaybe(parent.maxerr, strval); break;
        case command_FieldId_disas: retval = disas_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_report: retval = bool_ReadStrptrMaybe(parent.report, strval); break;
        case command_FieldId_jcdb: retval = algo::cstring_ReadStrptrMaybe(parent.jcdb, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.abt..ReadTupleMaybe
// Read fields of command::abt from attributes of ascii tuple TUPLE
bool command::abt_ReadTupleMaybe(command::abt &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = abt_GetAnon(parent, anon_idx++);
        }
        retval = abt_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.abt..Init
// Set all fields to initial values.
void command::abt_Init(command::abt& parent) {
    Regx_ReadSql(parent.target, "", true);
    parent.in = algo::strptr("data");
    parent.out_dir = algo::strptr("");
    parent.cfg = algo::strptr("");
    parent.compiler = algo::strptr("");
    parent.uname = algo::strptr("");
    parent.arch = algo::strptr("");
    parent.ood = bool(false);
    parent.list = bool(false);
    parent.listincl = bool(false);
    parent.build = bool(false);
    parent.preproc = bool(false);
    parent.clean = bool(false);
    parent.dry_run = bool(false);
    parent.maxjobs = i32(0);
    parent.printcmd = bool(false);
    parent.force = bool(false);
    parent.install = bool(false);
    parent.coverity = bool(false);
    parent.package = algo::strptr("");
    parent.maxerr = u32(100);
    Regx_ReadSql(parent.disas, "", true);
    parent.report = bool(true);
    parent.jcdb = algo::strptr("");
}

// --- command.abt..PrintArgv
// print command-line args of command::abt to string  -- cprint:command.abt.Argv
void command::abt_PrintArgv(command::abt & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    command::target_Print(const_cast<command::abt&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.out_dir == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.out_dir, temp);
        str << " -out_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cfg == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.cfg, temp);
        str << " -cfg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.compiler == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.compiler, temp);
        str << " -compiler:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.uname == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.uname, temp);
        str << " -uname:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arch == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.arch, temp);
        str << " -arch:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ood == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ood, temp);
        str << " -ood:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.listincl == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.listincl, temp);
        str << " -listincl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.build == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.build, temp);
        str << " -build:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.preproc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.preproc, temp);
        str << " -preproc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.clean == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.clean, temp);
        str << " -clean:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.printcmd == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.printcmd, temp);
        str << " -printcmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.force == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.force, temp);
        str << " -force:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.coverity == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.coverity, temp);
        str << " -coverity:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.package == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.package, temp);
        str << " -package:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxerr == 100)) {
        ch_RemoveAll(temp);
        u32_Print(row.maxerr, temp);
        str << " -maxerr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.disas.expr == "")) {
        ch_RemoveAll(temp);
        command::disas_Print(const_cast<command::abt&>(row), temp);
        str << " -disas:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.jcdb == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.jcdb, temp);
        str << " -jcdb:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.abt..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::abt_ToCmdline(command::abt & row) {
    tempstr ret;
    ret << "bin/abt ";
    abt_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.abt..GetAnon
algo::strptr command::abt_GetAnon(command::abt &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        default: return algo::strptr();
    }
}

// --- command.abt_proc.abt.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::abt_Start(command::abt_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(abt_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(abt_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= abt_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.abt_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.abt_proc.abt.StartRead
// Start subprocess & Read output
algo::Fildes command::abt_StartRead(command::abt_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    abt_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.abt_proc.abt.Kill
// Kill subprocess and wait
void command::abt_Kill(command::abt_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        abt_Wait(parent);
    }
}

// --- command.abt_proc.abt.Wait
// Wait for subprocess to return
void command::abt_Wait(command::abt_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.abt_proc.abt.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::abt_Exec(command::abt_proc& parent) {
    abt_Start(parent);
    abt_Wait(parent);
    return parent.status;
}

// --- command.abt_proc.abt.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::abt_ExecX(command::abt_proc& parent) {
    int rc = abt_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",abt_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.abt_proc.abt.Execv
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int command::abt_Execv(command::abt_proc& parent) {
    char *argv[48+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.target.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        command::target_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.out_dir != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-out_dir:";
        cstring_Print(parent.cmd.out_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cfg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cfg:";
        Smallstr50_Print(parent.cmd.cfg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.compiler != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-compiler:";
        Smallstr50_Print(parent.cmd.compiler, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.uname != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-uname:";
        Smallstr50_Print(parent.cmd.uname, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.arch != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arch:";
        Smallstr50_Print(parent.cmd.arch, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ood != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ood:";
        bool_Print(parent.cmd.ood, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.list != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-list:";
        bool_Print(parent.cmd.list, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.listincl != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-listincl:";
        bool_Print(parent.cmd.listincl, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.build != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-build:";
        bool_Print(parent.cmd.build, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.preproc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-preproc:";
        bool_Print(parent.cmd.preproc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.clean != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-clean:";
        bool_Print(parent.cmd.clean, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dry_run != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dry_run:";
        bool_Print(parent.cmd.dry_run, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxjobs != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxjobs:";
        i32_Print(parent.cmd.maxjobs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.printcmd != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-printcmd:";
        bool_Print(parent.cmd.printcmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.force != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-force:";
        bool_Print(parent.cmd.force, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.install != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-install:";
        bool_Print(parent.cmd.install, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.coverity != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-coverity:";
        bool_Print(parent.cmd.coverity, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.package != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-package:";
        cstring_Print(parent.cmd.package, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxerr != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxerr:";
        u32_Print(parent.cmd.maxerr, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.disas.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-disas:";
        command::disas_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.jcdb != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-jcdb:";
        cstring_Print(parent.cmd.jcdb, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.abt_proc.abt.ToCmdline
algo::tempstr command::abt_ToCmdline(command::abt_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::abt_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.abt_proc..Uninit
void command::abt_proc_Uninit(command::abt_proc& parent) {
    command::abt_proc &row = parent; (void)row;

    // command.abt_proc.abt.Uninit (Exec)  //
    abt_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr..ReadFieldMaybe
bool command::acr_ReadFieldMaybe(command::acr &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_query: retval = algo::cstring_ReadStrptrMaybe(parent.query, strval); break;
        case command_FieldId_select: retval = bool_ReadStrptrMaybe(parent.select, strval); break;
        case command_FieldId_del: retval = bool_ReadStrptrMaybe(parent.del, strval); break;
        case command_FieldId_insert: retval = bool_ReadStrptrMaybe(parent.insert, strval); break;
        case command_FieldId_replace: retval = bool_ReadStrptrMaybe(parent.replace, strval); break;
        case command_FieldId_merge: retval = bool_ReadStrptrMaybe(parent.merge, strval); break;
        case command_FieldId_unused: retval = bool_ReadStrptrMaybe(parent.unused, strval); break;
        case command_FieldId_trunc: retval = bool_ReadStrptrMaybe(parent.trunc, strval); break;
        case command_FieldId_check: retval = bool_ReadStrptrMaybe(parent.check, strval); break;
        case command_FieldId_maxshow: retval = i32_ReadStrptrMaybe(parent.maxshow, strval); break;
        case command_FieldId_write: retval = bool_ReadStrptrMaybe(parent.write, strval); break;
        case command_FieldId_rename: retval = algo::cstring_ReadStrptrMaybe(parent.rename, strval); break;
        case command_FieldId_nup: retval = i32_ReadStrptrMaybe(parent.nup, strval); break;
        case command_FieldId_ndown: retval = i32_ReadStrptrMaybe(parent.ndown, strval); break;
        case command_FieldId_xref: retval = bool_ReadStrptrMaybe(parent.xref, strval); break;
        case command_FieldId_fldfunc: retval = bool_ReadStrptrMaybe(parent.fldfunc, strval); break;
        case command_FieldId_maxgroup: retval = i32_ReadStrptrMaybe(parent.maxgroup, strval); break;
        case command_FieldId_pretty: retval = bool_ReadStrptrMaybe(parent.pretty, strval); break;
        case command_FieldId_tree: retval = bool_ReadStrptrMaybe(parent.tree, strval); break;
        case command_FieldId_loose: retval = bool_ReadStrptrMaybe(parent.loose, strval); break;
        case command_FieldId_my: retval = bool_ReadStrptrMaybe(parent.my, strval); break;
        case command_FieldId_schema: retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval); break;
        case command_FieldId_e: retval = bool_ReadStrptrMaybe(parent.e, strval); break;
        case command_FieldId_b: retval = bool_ReadStrptrMaybe(parent.b, strval); break;
        case command_FieldId_t: retval = bool_ReadStrptrMaybe(parent.t, strval); break;
        case command_FieldId_rowid: retval = bool_ReadStrptrMaybe(parent.rowid, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_cmt: retval = bool_ReadStrptrMaybe(parent.cmt, strval); break;
        case command_FieldId_report: retval = bool_ReadStrptrMaybe(parent.report, strval); break;
        case command_FieldId_print: retval = bool_ReadStrptrMaybe(parent.print, strval); break;
        case command_FieldId_cmd: retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval); break;
        case command_FieldId_field: retval = algo::cstring_ReadStrptrMaybe(parent.field, strval); break;
        case command_FieldId_regxof: retval = algo::cstring_ReadStrptrMaybe(parent.regxof, strval); break;
        case command_FieldId_meta: retval = bool_ReadStrptrMaybe(parent.meta, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr..ReadTupleMaybe
// Read fields of command::acr from attributes of ascii tuple TUPLE
bool command::acr_ReadTupleMaybe(command::acr &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_GetAnon(parent, anon_idx++);
        }
        retval = acr_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr..Init
// Set all fields to initial values.
void command::acr_Init(command::acr& parent) {
    parent.query = algo::strptr("");
    parent.select = bool(true);
    parent.del = bool(false);
    parent.insert = bool(false);
    parent.replace = bool(false);
    parent.merge = bool(false);
    parent.unused = bool(false);
    parent.trunc = bool(false);
    parent.check = bool(false);
    parent.maxshow = i32(100);
    parent.write = bool(false);
    parent.rename = algo::strptr("");
    parent.nup = i32(0);
    parent.ndown = i32(0);
    parent.xref = bool(false);
    parent.fldfunc = bool(false);
    parent.maxgroup = i32(25);
    parent.pretty = bool(true);
    parent.tree = bool(false);
    parent.loose = bool(false);
    parent.my = bool(false);
    parent.schema = algo::strptr("data");
    parent.e = bool(false);
    parent.b = bool(false);
    parent.t = bool(false);
    parent.rowid = bool(false);
    parent.in = algo::strptr("data");
    parent.cmt = bool(false);
    parent.report = bool(true);
    parent.print = bool(true);
    parent.cmd = algo::strptr("");
    parent.field = algo::strptr("");
    parent.regxof = algo::strptr("");
    parent.meta = bool(false);
}

// --- command.acr..PrintArgv
// print command-line args of command::acr to string  -- cprint:command.acr.Argv
void command::acr_PrintArgv(command::acr & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    cstring_Print(row.query, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.select == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.select, temp);
        str << " -select:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.del == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.del, temp);
        str << " -del:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.insert == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.insert, temp);
        str << " -insert:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.replace == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.replace, temp);
        str << " -replace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.merge == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.merge, temp);
        str << " -merge:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.unused == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.unused, temp);
        str << " -unused:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.trunc, temp);
        str << " -trunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxshow == 100)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxshow, temp);
        str << " -maxshow:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rename == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.rename, temp);
        str << " -rename:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nup == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.nup, temp);
        str << " -nup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ndown == 0)) {
        ch_RemoveAll(temp);
        i32_Print(row.ndown, temp);
        str << " -ndown:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxgroup == 25)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxgroup, temp);
        str << " -maxgroup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pretty == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.pretty, temp);
        str << " -pretty:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tree == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tree, temp);
        str << " -tree:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.loose == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.loose, temp);
        str << " -loose:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.my == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.my, temp);
        str << " -my:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.b == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.b, temp);
        str << " -b:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rowid == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.rowid, temp);
        str << " -rowid:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmt == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.cmt, temp);
        str << " -cmt:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.print == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.print, temp);
        str << " -print:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cmd, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.field == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.field, temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.regxof == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.regxof, temp);
        str << " -regxof:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.meta == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.meta, temp);
        str << " -meta:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_ToCmdline(command::acr & row) {
    tempstr ret;
    ret << "bin/acr ";
    acr_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr..GetAnon
algo::strptr command::acr_GetAnon(command::acr &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("query", 5);
        default: return algo::strptr();
    }
}

// --- command.acr_compl..ReadFieldMaybe
bool command::acr_compl_ReadFieldMaybe(command::acr_compl &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_line: retval = algo::cstring_ReadStrptrMaybe(parent.line, strval); break;
        case command_FieldId_point: retval = algo::cstring_ReadStrptrMaybe(parent.point, strval); break;
        case command_FieldId_type: retval = algo::cstring_ReadStrptrMaybe(parent.type, strval); break;
        case command_FieldId_install: retval = bool_ReadStrptrMaybe(parent.install, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_compl..ReadTupleMaybe
// Read fields of command::acr_compl from attributes of ascii tuple TUPLE
bool command::acr_compl_ReadTupleMaybe(command::acr_compl &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = acr_compl_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_compl..PrintArgv
// print command-line args of command::acr_compl to string  -- cprint:command.acr_compl.Argv
void command::acr_compl_PrintArgv(command::acr_compl & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.line == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.line, temp);
        str << " -line:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.point == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.point, temp);
        str << " -point:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.type == "9")) {
        ch_RemoveAll(temp);
        cstring_Print(row.type, temp);
        str << " -type:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.install == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.install, temp);
        str << " -install:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_compl..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_compl_ToCmdline(command::acr_compl & row) {
    tempstr ret;
    ret << "bin/acr_compl ";
    acr_compl_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_compl_proc.acr_compl.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_compl_Start(command::acr_compl_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_compl_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_compl_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_compl_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_compl_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_compl_proc.acr_compl.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_compl_StartRead(command::acr_compl_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_compl_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_compl_proc.acr_compl.Kill
// Kill subprocess and wait
void command::acr_compl_Kill(command::acr_compl_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_compl_Wait(parent);
    }
}

// --- command.acr_compl_proc.acr_compl.Wait
// Wait for subprocess to return
void command::acr_compl_Wait(command::acr_compl_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_compl_proc.acr_compl.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_compl_Exec(command::acr_compl_proc& parent) {
    acr_compl_Start(parent);
    acr_compl_Wait(parent);
    return parent.status;
}

// --- command.acr_compl_proc.acr_compl.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_compl_ExecX(command::acr_compl_proc& parent) {
    int rc = acr_compl_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_compl_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_compl_proc.acr_compl.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr_compl.Argv
int command::acr_compl_Execv(command::acr_compl_proc& parent) {
    char *argv[8+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.line != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-line:";
        cstring_Print(parent.cmd.line, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.point != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-point:";
        cstring_Print(parent.cmd.point, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.type != "9") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-type:";
        cstring_Print(parent.cmd.type, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.install != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-install:";
        bool_Print(parent.cmd.install, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.acr_compl_proc.acr_compl.ToCmdline
algo::tempstr command::acr_compl_ToCmdline(command::acr_compl_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_compl_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_compl_proc..Uninit
void command::acr_compl_proc_Uninit(command::acr_compl_proc& parent) {
    command::acr_compl_proc &row = parent; (void)row;

    // command.acr_compl_proc.acr_compl.Uninit (Exec)  //
    acr_compl_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_ed..ReadFieldMaybe
bool command::acr_ed_ReadFieldMaybe(command::acr_ed &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_create: retval = bool_ReadStrptrMaybe(parent.create, strval); break;
        case command_FieldId_del: retval = bool_ReadStrptrMaybe(parent.del, strval); break;
        case command_FieldId_rename: retval = algo::cstring_ReadStrptrMaybe(parent.rename, strval); break;
        case command_FieldId_replace: retval = bool_ReadStrptrMaybe(parent.replace, strval); break;
        case command_FieldId_finput: retval = bool_ReadStrptrMaybe(parent.finput, strval); break;
        case command_FieldId_foutput: retval = bool_ReadStrptrMaybe(parent.foutput, strval); break;
        case command_FieldId_srcfile: retval = algo::cstring_ReadStrptrMaybe(parent.srcfile, strval); break;
        case command_FieldId_gstatic: retval = bool_ReadStrptrMaybe(parent.gstatic, strval); break;
        case command_FieldId_indexed: retval = bool_ReadStrptrMaybe(parent.indexed, strval); break;
        case command_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case command_FieldId_nstype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.nstype, strval); break;
        case command_FieldId_ctype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ctype, strval); break;
        case command_FieldId_pooltype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.pooltype, strval); break;
        case command_FieldId_ssimfile: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ssimfile, strval); break;
        case command_FieldId_subset: retval = algo::Smallstr50_ReadStrptrMaybe(parent.subset, strval); break;
        case command_FieldId_subset2: retval = algo::Smallstr50_ReadStrptrMaybe(parent.subset2, strval); break;
        case command_FieldId_separator: retval = algo::cstring_ReadStrptrMaybe(parent.separator, strval); break;
        case command_FieldId_field: retval = algo::Smallstr100_ReadStrptrMaybe(parent.field, strval); break;
        case command_FieldId_arg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arg, strval); break;
        case command_FieldId_dflt: retval = algo::cstring_ReadStrptrMaybe(parent.dflt, strval); break;
        case command_FieldId_anon: retval = bool_ReadStrptrMaybe(parent.anon, strval); break;
        case command_FieldId_bigend: retval = bool_ReadStrptrMaybe(parent.bigend, strval); break;
        case command_FieldId_cascdel: retval = bool_ReadStrptrMaybe(parent.cascdel, strval); break;
        case command_FieldId_before: retval = algo::Smallstr100_ReadStrptrMaybe(parent.before, strval); break;
        case command_FieldId_substr: retval = algo::Smallstr100_ReadStrptrMaybe(parent.substr, strval); break;
        case command_FieldId_srcfield: retval = algo::Smallstr100_ReadStrptrMaybe(parent.srcfield, strval); break;
        case command_FieldId_fstep: retval = algo::Smallstr100_ReadStrptrMaybe(parent.fstep, strval); break;
        case command_FieldId_inscond: retval = algo::cstring_ReadStrptrMaybe(parent.inscond, strval); break;
        case command_FieldId_reftype: retval = algo::Smallstr50_ReadStrptrMaybe(parent.reftype, strval); break;
        case command_FieldId_hashfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.hashfld, strval); break;
        case command_FieldId_sortfld: retval = algo::Smallstr100_ReadStrptrMaybe(parent.sortfld, strval); break;
        case command_FieldId_unittest: retval = algo::cstring_ReadStrptrMaybe(parent.unittest, strval); break;
        case command_FieldId_normcheck: retval = algo::cstring_ReadStrptrMaybe(parent.normcheck, strval); break;
        case command_FieldId_cppfunc: retval = algo::cstring_ReadStrptrMaybe(parent.cppfunc, strval); break;
        case command_FieldId_xref: retval = bool_ReadStrptrMaybe(parent.xref, strval); break;
        case command_FieldId_via: retval = algo::cstring_ReadStrptrMaybe(parent.via, strval); break;
        case command_FieldId_write: retval = bool_ReadStrptrMaybe(parent.write, strval); break;
        case command_FieldId_e: retval = bool_ReadStrptrMaybe(parent.e, strval); break;
        case command_FieldId_comment: retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval); break;
        case command_FieldId_sandbox: retval = bool_ReadStrptrMaybe(parent.sandbox, strval); break;
        case command_FieldId_test: retval = bool_ReadStrptrMaybe(parent.test, strval); break;
        case command_FieldId_showcpp: retval = bool_ReadStrptrMaybe(parent.showcpp, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_ed..ReadTupleMaybe
// Read fields of command::acr_ed from attributes of ascii tuple TUPLE
bool command::acr_ed_ReadTupleMaybe(command::acr_ed &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = acr_ed_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_ed..Init
// Set all fields to initial values.
void command::acr_ed_Init(command::acr_ed& parent) {
    parent.in = algo::strptr("data");
    parent.create = bool(false);
    parent.del = bool(false);
    parent.rename = algo::strptr("");
    parent.replace = bool(false);
    parent.finput = bool(false);
    parent.foutput = bool(false);
    parent.srcfile = algo::strptr("");
    parent.gstatic = bool(false);
    parent.indexed = bool(false);
    parent.target = algo::strptr("");
    parent.nstype = algo::strptr("exe");
    parent.ctype = algo::strptr("");
    parent.pooltype = algo::strptr("");
    parent.ssimfile = algo::strptr("");
    parent.subset = algo::strptr("");
    parent.subset2 = algo::strptr("");
    parent.separator = algo::strptr(".");
    parent.field = algo::strptr("");
    parent.arg = algo::strptr("");
    parent.dflt = algo::strptr("");
    parent.anon = bool(false);
    parent.bigend = bool(false);
    parent.cascdel = bool(false);
    parent.before = algo::strptr("");
    parent.substr = algo::strptr("");
    parent.srcfield = algo::strptr("");
    parent.fstep = algo::strptr("");
    parent.inscond = algo::strptr("true");
    parent.reftype = algo::strptr("");
    parent.hashfld = algo::strptr("");
    parent.sortfld = algo::strptr("");
    parent.unittest = algo::strptr("");
    parent.normcheck = algo::strptr("");
    parent.cppfunc = algo::strptr("");
    parent.xref = bool(false);
    parent.via = algo::strptr("");
    parent.write = bool(false);
    parent.e = bool(false);
    parent.comment = algo::strptr("");
    parent.sandbox = bool(false);
    parent.test = bool(false);
    parent.showcpp = bool(false);
}

// --- command.acr_ed..PrintArgv
// print command-line args of command::acr_ed to string  -- cprint:command.acr_ed.Argv
void command::acr_ed_PrintArgv(command::acr_ed & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.create == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.create, temp);
        str << " -create:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.del == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.del, temp);
        str << " -del:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.rename == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.rename, temp);
        str << " -rename:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.replace == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.replace, temp);
        str << " -replace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.finput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.finput, temp);
        str << " -finput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.foutput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.foutput, temp);
        str << " -foutput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfile == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.srcfile, temp);
        str << " -srcfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gstatic == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gstatic, temp);
        str << " -gstatic:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.indexed == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.indexed, temp);
        str << " -indexed:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.target == "")) {
        ch_RemoveAll(temp);
        Smallstr16_Print(row.target, temp);
        str << " -target:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nstype == "exe")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.nstype, temp);
        str << " -nstype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ctype == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.ctype, temp);
        str << " -ctype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pooltype == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.pooltype, temp);
        str << " -pooltype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ssimfile == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.ssimfile, temp);
        str << " -ssimfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.subset == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.subset, temp);
        str << " -subset:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.subset2 == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.subset2, temp);
        str << " -subset2:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.separator == ".")) {
        ch_RemoveAll(temp);
        cstring_Print(row.separator, temp);
        str << " -separator:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.field == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.field, temp);
        str << " -field:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arg == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.arg, temp);
        str << " -arg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dflt == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dflt, temp);
        str << " -dflt:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.anon == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.anon, temp);
        str << " -anon:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.bigend == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.bigend, temp);
        str << " -bigend:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cascdel == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.cascdel, temp);
        str << " -cascdel:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.before == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.before, temp);
        str << " -before:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.substr == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.substr, temp);
        str << " -substr:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfield == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.srcfield, temp);
        str << " -srcfield:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fstep == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.fstep, temp);
        str << " -fstep:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.inscond == "true")) {
        ch_RemoveAll(temp);
        cstring_Print(row.inscond, temp);
        str << " -inscond:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.reftype == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.reftype, temp);
        str << " -reftype:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.hashfld == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.hashfld, temp);
        str << " -hashfld:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sortfld == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.sortfld, temp);
        str << " -sortfld:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.unittest == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.unittest, temp);
        str << " -unittest:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.normcheck == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.normcheck, temp);
        str << " -normcheck:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cppfunc == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cppfunc, temp);
        str << " -cppfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.via == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.via, temp);
        str << " -via:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.comment == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.comment, temp);
        str << " -comment:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sandbox == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.sandbox, temp);
        str << " -sandbox:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.test == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.test, temp);
        str << " -test:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showcpp == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showcpp, temp);
        str << " -showcpp:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_ed..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_ed_ToCmdline(command::acr_ed & row) {
    tempstr ret;
    ret << "bin/acr_ed ";
    acr_ed_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_ed_proc.acr_ed.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_ed_Start(command::acr_ed_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_ed_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_ed_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_ed_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_ed_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_ed_proc.acr_ed.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_ed_StartRead(command::acr_ed_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_ed_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_ed_proc.acr_ed.Kill
// Kill subprocess and wait
void command::acr_ed_Kill(command::acr_ed_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_ed_Wait(parent);
    }
}

// --- command.acr_ed_proc.acr_ed.Wait
// Wait for subprocess to return
void command::acr_ed_Wait(command::acr_ed_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_ed_proc.acr_ed.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_ed_Exec(command::acr_ed_proc& parent) {
    acr_ed_Start(parent);
    acr_ed_Wait(parent);
    return parent.status;
}

// --- command.acr_ed_proc.acr_ed.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_ed_ExecX(command::acr_ed_proc& parent) {
    int rc = acr_ed_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_ed_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_ed_proc.acr_ed.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr_ed.Argv
int command::acr_ed_Execv(command::acr_ed_proc& parent) {
    char *argv[86+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.create != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-create:";
        bool_Print(parent.cmd.create, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.del != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-del:";
        bool_Print(parent.cmd.del, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.rename != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rename:";
        cstring_Print(parent.cmd.rename, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.replace != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(parent.cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.finput != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-finput:";
        bool_Print(parent.cmd.finput, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.foutput != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-foutput:";
        bool_Print(parent.cmd.foutput, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.srcfile != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-srcfile:";
        cstring_Print(parent.cmd.srcfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.gstatic != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-gstatic:";
        bool_Print(parent.cmd.gstatic, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.indexed != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-indexed:";
        bool_Print(parent.cmd.indexed, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.target != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        Smallstr16_Print(parent.cmd.target, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.nstype != "exe") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nstype:";
        Smallstr50_Print(parent.cmd.nstype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ctype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ctype:";
        Smallstr50_Print(parent.cmd.ctype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.pooltype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pooltype:";
        Smallstr50_Print(parent.cmd.pooltype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ssimfile != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ssimfile:";
        Smallstr50_Print(parent.cmd.ssimfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.subset != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-subset:";
        Smallstr50_Print(parent.cmd.subset, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.subset2 != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-subset2:";
        Smallstr50_Print(parent.cmd.subset2, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.separator != ".") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-separator:";
        cstring_Print(parent.cmd.separator, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.field != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        Smallstr100_Print(parent.cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.arg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arg:";
        Smallstr50_Print(parent.cmd.arg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dflt != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dflt:";
        cstring_Print(parent.cmd.dflt, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.anon != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-anon:";
        bool_Print(parent.cmd.anon, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.bigend != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-bigend:";
        bool_Print(parent.cmd.bigend, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cascdel != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cascdel:";
        bool_Print(parent.cmd.cascdel, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.before != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-before:";
        Smallstr100_Print(parent.cmd.before, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.substr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-substr:";
        Smallstr100_Print(parent.cmd.substr, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.srcfield != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-srcfield:";
        Smallstr100_Print(parent.cmd.srcfield, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fstep != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fstep:";
        Smallstr100_Print(parent.cmd.fstep, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.inscond != "true") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-inscond:";
        cstring_Print(parent.cmd.inscond, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.reftype != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-reftype:";
        Smallstr50_Print(parent.cmd.reftype, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.hashfld != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-hashfld:";
        Smallstr100_Print(parent.cmd.hashfld, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.sortfld != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sortfld:";
        Smallstr100_Print(parent.cmd.sortfld, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.unittest != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unittest:";
        cstring_Print(parent.cmd.unittest, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.normcheck != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-normcheck:";
        cstring_Print(parent.cmd.normcheck, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cppfunc != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cppfunc:";
        cstring_Print(parent.cmd.cppfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(parent.cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.via != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-via:";
        cstring_Print(parent.cmd.via, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.comment != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-comment:";
        cstring_Print(parent.cmd.comment, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.sandbox != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sandbox:";
        bool_Print(parent.cmd.sandbox, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.test != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-test:";
        bool_Print(parent.cmd.test, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.showcpp != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-showcpp:";
        bool_Print(parent.cmd.showcpp, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.acr_ed_proc.acr_ed.ToCmdline
algo::tempstr command::acr_ed_ToCmdline(command::acr_ed_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_ed_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_ed_proc..Uninit
void command::acr_ed_proc_Uninit(command::acr_ed_proc& parent) {
    command::acr_ed_proc &row = parent; (void)row;

    // command.acr_ed_proc.acr_ed.Uninit (Exec)  //
    acr_ed_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_in.ns.Print
// Print back to string
void command::ns_Print(command::acr_in& parent, algo::cstring &out) {
    Regx_Print(parent.ns, out);
}

// --- command.acr_in.ns.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ns_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) {
    Regx_ReadSql(parent.ns, in, true);
    bool retval = true;// !parent.ns.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.acr_in.notssimfile.Print
// Print back to string
void command::notssimfile_Print(command::acr_in& parent, algo::cstring &out) {
    Regx_Print(parent.notssimfile, out);
}

// --- command.acr_in.notssimfile.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::notssimfile_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) {
    Regx_ReadSql(parent.notssimfile, in, true);
    bool retval = true;// !parent.notssimfile.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.acr_in..ReadFieldMaybe
bool command::acr_in_ReadFieldMaybe(command::acr_in &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_ns: retval = ns_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_data: retval = bool_ReadStrptrMaybe(parent.data, strval); break;
        case command_FieldId_sigcheck: retval = bool_ReadStrptrMaybe(parent.sigcheck, strval); break;
        case command_FieldId_list: retval = bool_ReadStrptrMaybe(parent.list, strval); break;
        case command_FieldId_data_dir: retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval); break;
        case command_FieldId_schema: retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval); break;
        case command_FieldId_related: retval = algo::cstring_ReadStrptrMaybe(parent.related, strval); break;
        case command_FieldId_notssimfile: retval = notssimfile_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_checkable: retval = bool_ReadStrptrMaybe(parent.checkable, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_in..ReadTupleMaybe
// Read fields of command::acr_in from attributes of ascii tuple TUPLE
bool command::acr_in_ReadTupleMaybe(command::acr_in &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_in_GetAnon(parent, anon_idx++);
        }
        retval = acr_in_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_in..Init
// Set all fields to initial values.
void command::acr_in_Init(command::acr_in& parent) {
    parent.data = bool(false);
    parent.sigcheck = bool(true);
    parent.list = bool(false);
    parent.data_dir = algo::strptr("data");
    parent.schema = algo::strptr("data");
    parent.related = algo::strptr("");
    Regx_ReadSql(parent.notssimfile, "", true);
    parent.checkable = bool(false);
}

// --- command.acr_in..PrintArgv
// print command-line args of command::acr_in to string  -- cprint:command.acr_in.Argv
void command::acr_in_PrintArgv(command::acr_in & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    command::ns_Print(const_cast<command::acr_in&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.data == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.data, temp);
        str << " -data:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sigcheck == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.sigcheck, temp);
        str << " -sigcheck:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.list == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.list, temp);
        str << " -list:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.related == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.related, temp);
        str << " -related:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.notssimfile.expr == "")) {
        ch_RemoveAll(temp);
        command::notssimfile_Print(const_cast<command::acr_in&>(row), temp);
        str << " -notssimfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.checkable == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.checkable, temp);
        str << " -checkable:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_in..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_in_ToCmdline(command::acr_in & row) {
    tempstr ret;
    ret << "bin/acr_in ";
    acr_in_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_in..GetAnon
algo::strptr command::acr_in_GetAnon(command::acr_in &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ns", 2);
        default: return algo::strptr();
    }
}

// --- command.acr_in_proc.acr_in.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_in_Start(command::acr_in_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_in_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_in_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_in_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_in_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_in_proc.acr_in.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_in_StartRead(command::acr_in_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_in_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_in_proc.acr_in.Kill
// Kill subprocess and wait
void command::acr_in_Kill(command::acr_in_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_in_Wait(parent);
    }
}

// --- command.acr_in_proc.acr_in.Wait
// Wait for subprocess to return
void command::acr_in_Wait(command::acr_in_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_in_proc.acr_in.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_in_Exec(command::acr_in_proc& parent) {
    acr_in_Start(parent);
    acr_in_Wait(parent);
    return parent.status;
}

// --- command.acr_in_proc.acr_in.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_in_ExecX(command::acr_in_proc& parent) {
    int rc = acr_in_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_in_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_in_proc.acr_in.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr_in.Argv
int command::acr_in_Execv(command::acr_in_proc& parent) {
    char *argv[18+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ns:";
        command::ns_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.data != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-data:";
        bool_Print(parent.cmd.data, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.sigcheck != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sigcheck:";
        bool_Print(parent.cmd.sigcheck, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.list != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-list:";
        bool_Print(parent.cmd.list, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.data_dir != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.schema != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        cstring_Print(parent.cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.related != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-related:";
        cstring_Print(parent.cmd.related, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.notssimfile.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-notssimfile:";
        command::notssimfile_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.checkable != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-checkable:";
        bool_Print(parent.cmd.checkable, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.acr_in_proc.acr_in.ToCmdline
algo::tempstr command::acr_in_ToCmdline(command::acr_in_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_in_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_in_proc..Uninit
void command::acr_in_proc_Uninit(command::acr_in_proc& parent) {
    command::acr_in_proc &row = parent; (void)row;

    // command.acr_in_proc.acr_in.Uninit (Exec)  //
    acr_in_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_my.nsdb.Print
// Print back to string
void command::nsdb_Print(command::acr_my& parent, algo::cstring &out) {
    Regx_Print(parent.nsdb, out);
}

// --- command.acr_my.nsdb.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::nsdb_ReadStrptrMaybe(command::acr_my& parent, algo::strptr in) {
    Regx_ReadSql(parent.nsdb, in, true);
    bool retval = true;// !parent.nsdb.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.acr_my..ReadFieldMaybe
bool command::acr_my_ReadFieldMaybe(command::acr_my &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_nsdb: retval = nsdb_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_schema: retval = algo::cstring_ReadStrptrMaybe(parent.schema, strval); break;
        case command_FieldId_fldfunc: retval = bool_ReadStrptrMaybe(parent.fldfunc, strval); break;
        case command_FieldId_fkey: retval = bool_ReadStrptrMaybe(parent.fkey, strval); break;
        case command_FieldId_e: retval = bool_ReadStrptrMaybe(parent.e, strval); break;
        case command_FieldId_start: retval = bool_ReadStrptrMaybe(parent.start, strval); break;
        case command_FieldId_stop: retval = bool_ReadStrptrMaybe(parent.stop, strval); break;
        case command_FieldId_abort: retval = bool_ReadStrptrMaybe(parent.abort, strval); break;
        case command_FieldId_shell: retval = bool_ReadStrptrMaybe(parent.shell, strval); break;
        case command_FieldId_serv: retval = bool_ReadStrptrMaybe(parent.serv, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.acr_my..ReadTupleMaybe
// Read fields of command::acr_my from attributes of ascii tuple TUPLE
bool command::acr_my_ReadTupleMaybe(command::acr_my &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = acr_my_GetAnon(parent, anon_idx++);
        }
        retval = acr_my_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.acr_my..Init
// Set all fields to initial values.
void command::acr_my_Init(command::acr_my& parent) {
    Regx_ReadSql(parent.nsdb, "", true);
    parent.in = algo::strptr("data");
    parent.schema = algo::strptr("data");
    parent.fldfunc = bool(false);
    parent.fkey = bool(false);
    parent.e = bool(false);
    parent.start = bool(false);
    parent.stop = bool(false);
    parent.abort = bool(false);
    parent.shell = bool(false);
    parent.serv = bool(false);
}

// --- command.acr_my..PrintArgv
// print command-line args of command::acr_my to string  -- cprint:command.acr_my.Argv
void command::acr_my_PrintArgv(command::acr_my & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    command::nsdb_Print(const_cast<command::acr_my&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.schema == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fkey, temp);
        str << " -fkey:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.start == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.start, temp);
        str << " -start:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.stop == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.stop, temp);
        str << " -stop:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.abort == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.abort, temp);
        str << " -abort:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.shell == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.shell, temp);
        str << " -shell:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.serv == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.serv, temp);
        str << " -serv:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.acr_my..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::acr_my_ToCmdline(command::acr_my & row) {
    tempstr ret;
    ret << "bin/acr_my ";
    acr_my_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.acr_my..GetAnon
algo::strptr command::acr_my_GetAnon(command::acr_my &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("nsdb", 4);
        default: return algo::strptr();
    }
}

// --- command.acr_my_proc.acr_my.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_my_Start(command::acr_my_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_my_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_my_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_my_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_my_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_my_proc.acr_my.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_my_StartRead(command::acr_my_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_my_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_my_proc.acr_my.Kill
// Kill subprocess and wait
void command::acr_my_Kill(command::acr_my_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_my_Wait(parent);
    }
}

// --- command.acr_my_proc.acr_my.Wait
// Wait for subprocess to return
void command::acr_my_Wait(command::acr_my_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_my_proc.acr_my.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_my_Exec(command::acr_my_proc& parent) {
    acr_my_Start(parent);
    acr_my_Wait(parent);
    return parent.status;
}

// --- command.acr_my_proc.acr_my.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_my_ExecX(command::acr_my_proc& parent) {
    int rc = acr_my_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_my_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_my_proc.acr_my.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr_my.Argv
int command::acr_my_Execv(command::acr_my_proc& parent) {
    char *argv[22+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.nsdb.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nsdb:";
        command::nsdb_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.schema != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        cstring_Print(parent.cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fldfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fkey != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fkey:";
        bool_Print(parent.cmd.fkey, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.start != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-start:";
        bool_Print(parent.cmd.start, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.stop != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-stop:";
        bool_Print(parent.cmd.stop, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.abort != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-abort:";
        bool_Print(parent.cmd.abort, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.shell != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-shell:";
        bool_Print(parent.cmd.shell, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.serv != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-serv:";
        bool_Print(parent.cmd.serv, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.acr_my_proc.acr_my.ToCmdline
algo::tempstr command::acr_my_ToCmdline(command::acr_my_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_my_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_my_proc..Uninit
void command::acr_my_proc_Uninit(command::acr_my_proc& parent) {
    command::acr_my_proc &row = parent; (void)row;

    // command.acr_my_proc.acr_my.Uninit (Exec)  //
    acr_my_Kill(parent); // kill child, ensure forward progress
}

// --- command.acr_proc.acr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::acr_Start(command::acr_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(acr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(acr_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= acr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.acr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.acr_proc.acr.StartRead
// Start subprocess & Read output
algo::Fildes command::acr_StartRead(command::acr_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    acr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.acr_proc.acr.Kill
// Kill subprocess and wait
void command::acr_Kill(command::acr_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        acr_Wait(parent);
    }
}

// --- command.acr_proc.acr.Wait
// Wait for subprocess to return
void command::acr_Wait(command::acr_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.acr_proc.acr.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::acr_Exec(command::acr_proc& parent) {
    acr_Start(parent);
    acr_Wait(parent);
    return parent.status;
}

// --- command.acr_proc.acr.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::acr_ExecX(command::acr_proc& parent) {
    int rc = acr_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",acr_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.acr_proc.acr.Execv
// Call execv()
// Call execv with specified parameters -- cprint:acr.Argv
int command::acr_Execv(command::acr_proc& parent) {
    char *argv[68+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.query != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-query:";
        cstring_Print(parent.cmd.query, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.select != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-select:";
        bool_Print(parent.cmd.select, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.del != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-del:";
        bool_Print(parent.cmd.del, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.insert != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-insert:";
        bool_Print(parent.cmd.insert, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.replace != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(parent.cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.merge != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-merge:";
        bool_Print(parent.cmd.merge, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.unused != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unused:";
        bool_Print(parent.cmd.unused, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.trunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trunc:";
        bool_Print(parent.cmd.trunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.check != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-check:";
        bool_Print(parent.cmd.check, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxshow != 100) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxshow:";
        i32_Print(parent.cmd.maxshow, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.rename != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rename:";
        cstring_Print(parent.cmd.rename, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.nup != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nup:";
        i32_Print(parent.cmd.nup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ndown != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ndown:";
        i32_Print(parent.cmd.ndown, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(parent.cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fldfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxgroup != 25) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxgroup:";
        i32_Print(parent.cmd.maxgroup, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.pretty != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pretty:";
        bool_Print(parent.cmd.pretty, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.tree != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tree:";
        bool_Print(parent.cmd.tree, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.loose != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-loose:";
        bool_Print(parent.cmd.loose, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.my != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-my:";
        bool_Print(parent.cmd.my, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.schema != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        cstring_Print(parent.cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.b != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-b:";
        bool_Print(parent.cmd.b, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.t != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-t:";
        bool_Print(parent.cmd.t, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.rowid != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-rowid:";
        bool_Print(parent.cmd.rowid, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cmt != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmt:";
        bool_Print(parent.cmd.cmt, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.print != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-print:";
        bool_Print(parent.cmd.print, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cmd != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmd:";
        cstring_Print(parent.cmd.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.field != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        cstring_Print(parent.cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.regxof != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-regxof:";
        cstring_Print(parent.cmd.regxof, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.meta != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-meta:";
        bool_Print(parent.cmd.meta, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.acr_proc.acr.ToCmdline
algo::tempstr command::acr_ToCmdline(command::acr_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::acr_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.acr_proc..Uninit
void command::acr_proc_Uninit(command::acr_proc& parent) {
    command::acr_proc &row = parent; (void)row;

    // command.acr_proc.acr.Uninit (Exec)  //
    acr_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc.trace.Print
// Print back to string
void command::trace_Print(command::amc& parent, algo::cstring &out) {
    Regx_Print(parent.trace, out);
}

// --- command.amc.trace.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::trace_ReadStrptrMaybe(command::amc& parent, algo::strptr in) {
    Regx_ReadSql(parent.trace, in, true);
    bool retval = true;// !parent.trace.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.amc..ReadFieldMaybe
bool command::amc_ReadFieldMaybe(command::amc &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in_dir: retval = algo::cstring_ReadStrptrMaybe(parent.in_dir, strval); break;
        case command_FieldId_query: retval = algo::cstring_ReadStrptrMaybe(parent.query, strval); break;
        case command_FieldId_out_dir: retval = algo::cstring_ReadStrptrMaybe(parent.out_dir, strval); break;
        case command_FieldId_proto: retval = bool_ReadStrptrMaybe(parent.proto, strval); break;
        case command_FieldId_report: retval = bool_ReadStrptrMaybe(parent.report, strval); break;
        case command_FieldId_e: retval = bool_ReadStrptrMaybe(parent.e, strval); break;
        case command_FieldId_trace: retval = trace_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc..ReadTupleMaybe
// Read fields of command::amc from attributes of ascii tuple TUPLE
bool command::amc_ReadTupleMaybe(command::amc &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = amc_GetAnon(parent, anon_idx++);
        }
        retval = amc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc..Init
// Set all fields to initial values.
void command::amc_Init(command::amc& parent) {
    parent.in_dir = algo::strptr("data");
    parent.query = algo::strptr("");
    parent.out_dir = algo::strptr(".");
    parent.proto = bool(false);
    parent.report = bool(true);
    parent.e = bool(false);
    Regx_ReadSql(parent.trace, "", true);
}

// --- command.amc..PrintArgv
// print command-line args of command::amc to string  -- cprint:command.amc.Argv
void command::amc_PrintArgv(command::amc & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in_dir, temp);
        str << " -in_dir:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.query, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.out_dir == ".")) {
        ch_RemoveAll(temp);
        cstring_Print(row.out_dir, temp);
        str << " -out_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.proto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.proto, temp);
        str << " -proto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trace.expr == "")) {
        ch_RemoveAll(temp);
        command::trace_Print(const_cast<command::amc&>(row), temp);
        str << " -trace:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_ToCmdline(command::amc & row) {
    tempstr ret;
    ret << "bin/amc ";
    amc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc..GetAnon
algo::strptr command::amc_GetAnon(command::amc &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("query", 5);
        default: return algo::strptr();
    }
}

// --- command.amc_dml.ns.Print
// Print back to string
void command::ns_Print(command::amc_dml& parent, algo::cstring &out) {
    Regx_Print(parent.ns, out);
}

// --- command.amc_dml.ns.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ns_ReadStrptrMaybe(command::amc_dml& parent, algo::strptr in) {
    Regx_ReadSql(parent.ns, in, true);
    bool retval = true;// !parent.ns.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.amc_dml..ReadFieldMaybe
bool command::amc_dml_ReadFieldMaybe(command::amc_dml &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_ns: retval = ns_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_fconst: retval = bool_ReadStrptrMaybe(parent.fconst, strval); break;
        case command_FieldId_gconst: retval = bool_ReadStrptrMaybe(parent.gconst, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc_dml..ReadTupleMaybe
// Read fields of command::amc_dml from attributes of ascii tuple TUPLE
bool command::amc_dml_ReadTupleMaybe(command::amc_dml &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = amc_dml_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc_dml..Init
// Set all fields to initial values.
void command::amc_dml_Init(command::amc_dml& parent) {
    Regx_ReadSql(parent.ns, "%", true);
    parent.fconst = bool(true);
    parent.gconst = bool(true);
    parent.in = algo::strptr("data");
}

// --- command.amc_dml..PrintArgv
// print command-line args of command::amc_dml to string  -- cprint:command.amc_dml.Argv
void command::amc_dml_PrintArgv(command::amc_dml & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.ns.expr == "%")) {
        ch_RemoveAll(temp);
        command::ns_Print(const_cast<command::amc_dml&>(row), temp);
        str << " -ns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fconst == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.fconst, temp);
        str << " -fconst:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gconst == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.gconst, temp);
        str << " -gconst:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc_dml..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_dml_ToCmdline(command::amc_dml & row) {
    tempstr ret;
    ret << "bin/amc_dml ";
    amc_dml_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc_gc.target.Print
// Print back to string
void command::target_Print(command::amc_gc& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.amc_gc.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) {
    Regx_ReadSql(parent.target, in, true);
    bool retval = true;// !parent.target.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.amc_gc.key.Print
// Print back to string
void command::key_Print(command::amc_gc& parent, algo::cstring &out) {
    Regx_Print(parent.key, out);
}

// --- command.amc_gc.key.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::key_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) {
    Regx_ReadSql(parent.key, in, true);
    bool retval = true;// !parent.key.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.amc_gc..ReadFieldMaybe
bool command::amc_gc_ReadFieldMaybe(command::amc_gc &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_target: retval = target_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_key: retval = key_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_include: retval = bool_ReadStrptrMaybe(parent.include, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc_gc..ReadTupleMaybe
// Read fields of command::amc_gc from attributes of ascii tuple TUPLE
bool command::amc_gc_ReadTupleMaybe(command::amc_gc &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = amc_gc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc_gc..Init
// Set all fields to initial values.
void command::amc_gc_Init(command::amc_gc& parent) {
    Regx_ReadSql(parent.target, "%", true);
    Regx_ReadSql(parent.key, "", true);
    parent.include = bool(false);
    parent.in = algo::strptr("data");
}

// --- command.amc_gc..PrintArgv
// print command-line args of command::amc_gc to string  -- cprint:command.amc_gc.Argv
void command::amc_gc_PrintArgv(command::amc_gc & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.target.expr == "%")) {
        ch_RemoveAll(temp);
        command::target_Print(const_cast<command::amc_gc&>(row), temp);
        str << " -target:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.key.expr == "")) {
        ch_RemoveAll(temp);
        command::key_Print(const_cast<command::amc_gc&>(row), temp);
        str << " -key:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.include == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.include, temp);
        str << " -include:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc_gc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_gc_ToCmdline(command::amc_gc & row) {
    tempstr ret;
    ret << "bin/amc_gc ";
    amc_gc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc_gc_proc.amc_gc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_gc_Start(command::amc_gc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_gc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_gc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_gc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_gc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_gc_proc.amc_gc.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_gc_StartRead(command::amc_gc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_gc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_gc_proc.amc_gc.Kill
// Kill subprocess and wait
void command::amc_gc_Kill(command::amc_gc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_gc_Wait(parent);
    }
}

// --- command.amc_gc_proc.amc_gc.Wait
// Wait for subprocess to return
void command::amc_gc_Wait(command::amc_gc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_gc_proc.amc_gc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_gc_Exec(command::amc_gc_proc& parent) {
    amc_gc_Start(parent);
    amc_gc_Wait(parent);
    return parent.status;
}

// --- command.amc_gc_proc.amc_gc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_gc_ExecX(command::amc_gc_proc& parent) {
    int rc = amc_gc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_gc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_gc_proc.amc_gc.Execv
// Call execv()
// Call execv with specified parameters -- cprint:amc_gc.Argv
int command::amc_gc_Execv(command::amc_gc_proc& parent) {
    char *argv[8+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.target.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        command::target_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.key.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-key:";
        command::key_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.include != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-include:";
        bool_Print(parent.cmd.include, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.amc_gc_proc.amc_gc.ToCmdline
algo::tempstr command::amc_gc_ToCmdline(command::amc_gc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_gc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_gc_proc..Uninit
void command::amc_gc_proc_Uninit(command::amc_gc_proc& parent) {
    command::amc_gc_proc &row = parent; (void)row;

    // command.amc_gc_proc.amc_gc.Uninit (Exec)  //
    amc_gc_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc_proc.amc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_Start(command::amc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_proc.amc.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_StartRead(command::amc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_proc.amc.Kill
// Kill subprocess and wait
void command::amc_Kill(command::amc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_Wait(parent);
    }
}

// --- command.amc_proc.amc.Wait
// Wait for subprocess to return
void command::amc_Wait(command::amc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_proc.amc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_Exec(command::amc_proc& parent) {
    amc_Start(parent);
    amc_Wait(parent);
    return parent.status;
}

// --- command.amc_proc.amc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_ExecX(command::amc_proc& parent) {
    int rc = amc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_proc.amc.Execv
// Call execv()
// Call execv with specified parameters -- cprint:amc.Argv
int command::amc_Execv(command::amc_proc& parent) {
    char *argv[14+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in_dir != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in_dir:";
        cstring_Print(parent.cmd.in_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.query != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-query:";
        cstring_Print(parent.cmd.query, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.out_dir != ".") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-out_dir:";
        cstring_Print(parent.cmd.out_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.proto != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-proto:";
        bool_Print(parent.cmd.proto, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.trace.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trace:";
        command::trace_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.amc_proc.amc.ToCmdline
algo::tempstr command::amc_ToCmdline(command::amc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_proc..Uninit
void command::amc_proc_Uninit(command::amc_proc& parent) {
    command::amc_proc &row = parent; (void)row;

    // command.amc_proc.amc.Uninit (Exec)  //
    amc_Kill(parent); // kill child, ensure forward progress
}

// --- command.amc_vis.ctype.Print
// Print back to string
void command::ctype_Print(command::amc_vis& parent, algo::cstring &out) {
    Regx_Print(parent.ctype, out);
}

// --- command.amc_vis.ctype.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::ctype_ReadStrptrMaybe(command::amc_vis& parent, algo::strptr in) {
    Regx_ReadSql(parent.ctype, in, true);
    bool retval = true;// !parent.ctype.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.amc_vis..ReadFieldMaybe
bool command::amc_vis_ReadFieldMaybe(command::amc_vis &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_ctype: retval = ctype_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_dot: retval = algo::cstring_ReadStrptrMaybe(parent.dot, strval); break;
        case command_FieldId_xref: retval = bool_ReadStrptrMaybe(parent.xref, strval); break;
        case command_FieldId_xns: retval = bool_ReadStrptrMaybe(parent.xns, strval); break;
        case command_FieldId_noinput: retval = bool_ReadStrptrMaybe(parent.noinput, strval); break;
        case command_FieldId_check: retval = bool_ReadStrptrMaybe(parent.check, strval); break;
        case command_FieldId_render: retval = bool_ReadStrptrMaybe(parent.render, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.amc_vis..ReadTupleMaybe
// Read fields of command::amc_vis from attributes of ascii tuple TUPLE
bool command::amc_vis_ReadTupleMaybe(command::amc_vis &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = amc_vis_GetAnon(parent, anon_idx++);
        }
        retval = amc_vis_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.amc_vis..Init
// Set all fields to initial values.
void command::amc_vis_Init(command::amc_vis& parent) {
    Regx_ReadSql(parent.ctype, "%", true);
    parent.in = algo::strptr("data");
    parent.dot = algo::strptr("");
    parent.xref = bool(false);
    parent.xns = bool(false);
    parent.noinput = bool(false);
    parent.check = bool(false);
    parent.render = bool(true);
}

// --- command.amc_vis..PrintArgv
// print command-line args of command::amc_vis to string  -- cprint:command.amc_vis.Argv
void command::amc_vis_PrintArgv(command::amc_vis & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    command::ctype_Print(const_cast<command::amc_vis&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dot == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.dot, temp);
        str << " -dot:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xref == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xref, temp);
        str << " -xref:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.xns == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.xns, temp);
        str << " -xns:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.noinput == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.noinput, temp);
        str << " -noinput:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.check == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.check, temp);
        str << " -check:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.render == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.render, temp);
        str << " -render:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.amc_vis..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::amc_vis_ToCmdline(command::amc_vis & row) {
    tempstr ret;
    ret << "bin/amc_vis ";
    amc_vis_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.amc_vis..GetAnon
algo::strptr command::amc_vis_GetAnon(command::amc_vis &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ctype", 5);
        default: return algo::strptr();
    }
}

// --- command.amc_vis_proc.amc_vis.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::amc_vis_Start(command::amc_vis_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(amc_vis_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(amc_vis_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= amc_vis_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.amc_vis_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.amc_vis_proc.amc_vis.StartRead
// Start subprocess & Read output
algo::Fildes command::amc_vis_StartRead(command::amc_vis_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    amc_vis_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.amc_vis_proc.amc_vis.Kill
// Kill subprocess and wait
void command::amc_vis_Kill(command::amc_vis_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        amc_vis_Wait(parent);
    }
}

// --- command.amc_vis_proc.amc_vis.Wait
// Wait for subprocess to return
void command::amc_vis_Wait(command::amc_vis_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.amc_vis_proc.amc_vis.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::amc_vis_Exec(command::amc_vis_proc& parent) {
    amc_vis_Start(parent);
    amc_vis_Wait(parent);
    return parent.status;
}

// --- command.amc_vis_proc.amc_vis.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::amc_vis_ExecX(command::amc_vis_proc& parent) {
    int rc = amc_vis_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",amc_vis_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.amc_vis_proc.amc_vis.Execv
// Call execv()
// Call execv with specified parameters -- cprint:amc_vis.Argv
int command::amc_vis_Execv(command::amc_vis_proc& parent) {
    char *argv[16+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.ctype.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ctype:";
        command::ctype_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dot != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dot:";
        cstring_Print(parent.cmd.dot, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.xref != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xref:";
        bool_Print(parent.cmd.xref, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.xns != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-xns:";
        bool_Print(parent.cmd.xns, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.noinput != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-noinput:";
        bool_Print(parent.cmd.noinput, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.check != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-check:";
        bool_Print(parent.cmd.check, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.render != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-render:";
        bool_Print(parent.cmd.render, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.amc_vis_proc.amc_vis.ToCmdline
algo::tempstr command::amc_vis_ToCmdline(command::amc_vis_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::amc_vis_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.amc_vis_proc..Uninit
void command::amc_vis_proc_Uninit(command::amc_vis_proc& parent) {
    command::amc_vis_proc &row = parent; (void)row;

    // command.amc_vis_proc.amc_vis.Uninit (Exec)  //
    amc_vis_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_amc.amctest.Print
// Print back to string
void command::amctest_Print(command::atf_amc& parent, algo::cstring &out) {
    Regx_Print(parent.amctest, out);
}

// --- command.atf_amc.amctest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::amctest_ReadStrptrMaybe(command::atf_amc& parent, algo::strptr in) {
    Regx_ReadSql(parent.amctest, in, true);
    bool retval = true;// !parent.amctest.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.atf_amc..ReadFieldMaybe
bool command::atf_amc_ReadFieldMaybe(command::atf_amc &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_amctest: retval = amctest_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_dofork: retval = bool_ReadStrptrMaybe(parent.dofork, strval); break;
        case command_FieldId_q: retval = bool_ReadStrptrMaybe(parent.q, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_amc..ReadTupleMaybe
// Read fields of command::atf_amc from attributes of ascii tuple TUPLE
bool command::atf_amc_ReadTupleMaybe(command::atf_amc &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_amc_GetAnon(parent, anon_idx++);
        }
        retval = atf_amc_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_amc..Init
// Set all fields to initial values.
void command::atf_amc_Init(command::atf_amc& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.amctest, "%", true);
    parent.dofork = bool(true);
    parent.q = bool(false);
}

// --- command.atf_amc..PrintArgv
// print command-line args of command::atf_amc to string  -- cprint:command.atf_amc.Argv
void command::atf_amc_PrintArgv(command::atf_amc & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::amctest_Print(const_cast<command::atf_amc&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.dofork == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.dofork, temp);
        str << " -dofork:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.q == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.q, temp);
        str << " -q:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_amc..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_amc_ToCmdline(command::atf_amc & row) {
    tempstr ret;
    ret << "bin/atf_amc ";
    atf_amc_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_amc..GetAnon
algo::strptr command::atf_amc_GetAnon(command::atf_amc &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("amctest", 7);
        default: return algo::strptr();
    }
}

// --- command.atf_amc_proc.atf_amc.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_amc_Start(command::atf_amc_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_amc_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_amc_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_amc_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_amc_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_amc_proc.atf_amc.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_amc_StartRead(command::atf_amc_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_amc_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_amc_proc.atf_amc.Kill
// Kill subprocess and wait
void command::atf_amc_Kill(command::atf_amc_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_amc_Wait(parent);
    }
}

// --- command.atf_amc_proc.atf_amc.Wait
// Wait for subprocess to return
void command::atf_amc_Wait(command::atf_amc_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_amc_proc.atf_amc.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_amc_Exec(command::atf_amc_proc& parent) {
    atf_amc_Start(parent);
    atf_amc_Wait(parent);
    return parent.status;
}

// --- command.atf_amc_proc.atf_amc.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_amc_ExecX(command::atf_amc_proc& parent) {
    int rc = atf_amc_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_amc_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_amc_proc.atf_amc.Execv
// Call execv()
// Call execv with specified parameters -- cprint:atf_amc.Argv
int command::atf_amc_Execv(command::atf_amc_proc& parent) {
    char *argv[8+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.amctest.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-amctest:";
        command::amctest_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dofork != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dofork:";
        bool_Print(parent.cmd.dofork, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.q != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-q:";
        bool_Print(parent.cmd.q, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.atf_amc_proc.atf_amc.ToCmdline
algo::tempstr command::atf_amc_ToCmdline(command::atf_amc_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_amc_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_amc_proc..Uninit
void command::atf_amc_proc_Uninit(command::atf_amc_proc& parent) {
    command::atf_amc_proc &row = parent; (void)row;

    // command.atf_amc_proc.atf_amc.Uninit (Exec)  //
    atf_amc_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_norm.normcheck.Print
// Print back to string
void command::normcheck_Print(command::atf_norm& parent, algo::cstring &out) {
    Regx_Print(parent.normcheck, out);
}

// --- command.atf_norm.normcheck.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::normcheck_ReadStrptrMaybe(command::atf_norm& parent, algo::strptr in) {
    Regx_ReadSql(parent.normcheck, in, true);
    bool retval = true;// !parent.normcheck.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.atf_norm..ReadFieldMaybe
bool command::atf_norm_ReadFieldMaybe(command::atf_norm &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_normcheck: retval = normcheck_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_norm..ReadTupleMaybe
// Read fields of command::atf_norm from attributes of ascii tuple TUPLE
bool command::atf_norm_ReadTupleMaybe(command::atf_norm &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_norm_GetAnon(parent, anon_idx++);
        }
        retval = atf_norm_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_norm..Init
// Set all fields to initial values.
void command::atf_norm_Init(command::atf_norm& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.normcheck, "%", true);
}

// --- command.atf_norm..PrintArgv
// print command-line args of command::atf_norm to string  -- cprint:command.atf_norm.Argv
void command::atf_norm_PrintArgv(command::atf_norm & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::normcheck_Print(const_cast<command::atf_norm&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
}

// --- command.atf_norm..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_norm_ToCmdline(command::atf_norm & row) {
    tempstr ret;
    ret << "bin/atf_norm ";
    atf_norm_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_norm..GetAnon
algo::strptr command::atf_norm_GetAnon(command::atf_norm &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("normcheck", 9);
        default: return algo::strptr();
    }
}

// --- command.atf_norm_proc.atf_norm.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_norm_Start(command::atf_norm_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_norm_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_norm_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_norm_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_norm_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_norm_proc.atf_norm.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_norm_StartRead(command::atf_norm_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_norm_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_norm_proc.atf_norm.Kill
// Kill subprocess and wait
void command::atf_norm_Kill(command::atf_norm_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_norm_Wait(parent);
    }
}

// --- command.atf_norm_proc.atf_norm.Wait
// Wait for subprocess to return
void command::atf_norm_Wait(command::atf_norm_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_norm_proc.atf_norm.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_norm_Exec(command::atf_norm_proc& parent) {
    atf_norm_Start(parent);
    atf_norm_Wait(parent);
    return parent.status;
}

// --- command.atf_norm_proc.atf_norm.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_norm_ExecX(command::atf_norm_proc& parent) {
    int rc = atf_norm_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_norm_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_norm_proc.atf_norm.Execv
// Call execv()
// Call execv with specified parameters -- cprint:atf_norm.Argv
int command::atf_norm_Execv(command::atf_norm_proc& parent) {
    char *argv[4+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.normcheck.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-normcheck:";
        command::normcheck_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.atf_norm_proc.atf_norm.ToCmdline
algo::tempstr command::atf_norm_ToCmdline(command::atf_norm_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_norm_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_norm_proc..Uninit
void command::atf_norm_proc_Uninit(command::atf_norm_proc& parent) {
    command::atf_norm_proc &row = parent; (void)row;

    // command.atf_norm_proc.atf_norm.Uninit (Exec)  //
    atf_norm_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_nrun..ReadFieldMaybe
bool command::atf_nrun_ReadFieldMaybe(command::atf_nrun &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_maxjobs: retval = i32_ReadStrptrMaybe(parent.maxjobs, strval); break;
        case command_FieldId_ncmd: retval = i32_ReadStrptrMaybe(parent.ncmd, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_nrun..ReadTupleMaybe
// Read fields of command::atf_nrun from attributes of ascii tuple TUPLE
bool command::atf_nrun_ReadTupleMaybe(command::atf_nrun &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_nrun_GetAnon(parent, anon_idx++);
        }
        retval = atf_nrun_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_nrun..PrintArgv
// print command-line args of command::atf_nrun to string  -- cprint:command.atf_nrun.Argv
void command::atf_nrun_PrintArgv(command::atf_nrun & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 2)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    i32_Print(row.ncmd, temp);
    str << " ";
    strptr_PrintBash(temp,str);
}

// --- command.atf_nrun..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_nrun_ToCmdline(command::atf_nrun & row) {
    tempstr ret;
    ret << "bin/atf_nrun ";
    atf_nrun_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_nrun..GetAnon
algo::strptr command::atf_nrun_GetAnon(command::atf_nrun &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("ncmd", 4);
        default: return algo::strptr();
    }
}

// --- command.atf_nrun_proc.atf_nrun.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_nrun_Start(command::atf_nrun_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_nrun_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_nrun_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_nrun_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_nrun_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_nrun_proc.atf_nrun.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_nrun_StartRead(command::atf_nrun_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_nrun_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_nrun_proc.atf_nrun.Kill
// Kill subprocess and wait
void command::atf_nrun_Kill(command::atf_nrun_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_nrun_Wait(parent);
    }
}

// --- command.atf_nrun_proc.atf_nrun.Wait
// Wait for subprocess to return
void command::atf_nrun_Wait(command::atf_nrun_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_nrun_proc.atf_nrun.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_nrun_Exec(command::atf_nrun_proc& parent) {
    atf_nrun_Start(parent);
    atf_nrun_Wait(parent);
    return parent.status;
}

// --- command.atf_nrun_proc.atf_nrun.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_nrun_ExecX(command::atf_nrun_proc& parent) {
    int rc = atf_nrun_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_nrun_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_nrun_proc.atf_nrun.Execv
// Call execv()
// Call execv with specified parameters -- cprint:atf_nrun.Argv
int command::atf_nrun_Execv(command::atf_nrun_proc& parent) {
    char *argv[6+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxjobs != 2) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxjobs:";
        i32_Print(parent.cmd.maxjobs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ncmd != 6) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ncmd:";
        i32_Print(parent.cmd.ncmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.atf_nrun_proc.atf_nrun.ToCmdline
algo::tempstr command::atf_nrun_ToCmdline(command::atf_nrun_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_nrun_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_nrun_proc..Uninit
void command::atf_nrun_proc_Uninit(command::atf_nrun_proc& parent) {
    command::atf_nrun_proc &row = parent; (void)row;

    // command.atf_nrun_proc.atf_nrun.Uninit (Exec)  //
    atf_nrun_Kill(parent); // kill child, ensure forward progress
}

// --- command.atf_unit.unittest.Print
// Print back to string
void command::unittest_Print(command::atf_unit& parent, algo::cstring &out) {
    Regx_Print(parent.unittest, out);
}

// --- command.atf_unit.unittest.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::unittest_ReadStrptrMaybe(command::atf_unit& parent, algo::strptr in) {
    Regx_ReadSql(parent.unittest, in, true);
    bool retval = true;// !parent.unittest.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.atf_unit..ReadFieldMaybe
bool command::atf_unit_ReadFieldMaybe(command::atf_unit &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_unittest: retval = unittest_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_nofork: retval = bool_ReadStrptrMaybe(parent.nofork, strval); break;
        case command_FieldId_arg: retval = algo::cstring_ReadStrptrMaybe(parent.arg, strval); break;
        case command_FieldId_data_dir: retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval); break;
        case command_FieldId_debug: retval = bool_ReadStrptrMaybe(parent.debug, strval); break;
        case command_FieldId_perf_secs: retval = double_ReadStrptrMaybe(parent.perf_secs, strval); break;
        case command_FieldId_pertest_timeout: retval = u32_ReadStrptrMaybe(parent.pertest_timeout, strval); break;
        case command_FieldId_report: retval = bool_ReadStrptrMaybe(parent.report, strval); break;
        case command_FieldId_capture: retval = bool_ReadStrptrMaybe(parent.capture, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.atf_unit..ReadTupleMaybe
// Read fields of command::atf_unit from attributes of ascii tuple TUPLE
bool command::atf_unit_ReadTupleMaybe(command::atf_unit &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = atf_unit_GetAnon(parent, anon_idx++);
        }
        retval = atf_unit_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.atf_unit..Init
// Set all fields to initial values.
void command::atf_unit_Init(command::atf_unit& parent) {
    Regx_ReadSql(parent.unittest, "%", true);
    parent.nofork = bool(false);
    parent.arg = algo::strptr("");
    parent.data_dir = algo::strptr("data");
    parent.debug = bool(0);
    parent.perf_secs = double(1.0);
    parent.pertest_timeout = u32(900);
    parent.report = bool(true);
    parent.capture = bool(false);
}

// --- command.atf_unit..PrintArgv
// print command-line args of command::atf_unit to string  -- cprint:command.atf_unit.Argv
void command::atf_unit_PrintArgv(command::atf_unit & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    command::unittest_Print(const_cast<command::atf_unit&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.nofork == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.nofork, temp);
        str << " -nofork:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.arg == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.arg, temp);
        str << " -arg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.debug == 0)) {
        ch_RemoveAll(temp);
        bool_Print(row.debug, temp);
        str << " -debug:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.perf_secs == 1.0)) {
        ch_RemoveAll(temp);
        double_Print(row.perf_secs, temp);
        str << " -perf_secs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pertest_timeout == 900)) {
        ch_RemoveAll(temp);
        u32_Print(row.pertest_timeout, temp);
        str << " -pertest_timeout:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.atf_unit..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::atf_unit_ToCmdline(command::atf_unit & row) {
    tempstr ret;
    ret << "bin/atf_unit ";
    atf_unit_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.atf_unit..GetAnon
algo::strptr command::atf_unit_GetAnon(command::atf_unit &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("unittest", 8);
        default: return algo::strptr();
    }
}

// --- command.atf_unit_proc.atf_unit.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::atf_unit_Start(command::atf_unit_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(atf_unit_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(atf_unit_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= atf_unit_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.atf_unit_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.atf_unit_proc.atf_unit.StartRead
// Start subprocess & Read output
algo::Fildes command::atf_unit_StartRead(command::atf_unit_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    atf_unit_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.atf_unit_proc.atf_unit.Kill
// Kill subprocess and wait
void command::atf_unit_Kill(command::atf_unit_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        atf_unit_Wait(parent);
    }
}

// --- command.atf_unit_proc.atf_unit.Wait
// Wait for subprocess to return
void command::atf_unit_Wait(command::atf_unit_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.atf_unit_proc.atf_unit.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::atf_unit_Exec(command::atf_unit_proc& parent) {
    atf_unit_Start(parent);
    atf_unit_Wait(parent);
    return parent.status;
}

// --- command.atf_unit_proc.atf_unit.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::atf_unit_ExecX(command::atf_unit_proc& parent) {
    int rc = atf_unit_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",atf_unit_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.atf_unit_proc.atf_unit.Execv
// Call execv()
// Call execv with specified parameters -- cprint:atf_unit.Argv
int command::atf_unit_Execv(command::atf_unit_proc& parent) {
    char *argv[18+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.unittest.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-unittest:";
        command::unittest_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.nofork != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nofork:";
        bool_Print(parent.cmd.nofork, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.arg != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-arg:";
        cstring_Print(parent.cmd.arg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.data_dir != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.debug != 0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-debug:";
        bool_Print(parent.cmd.debug, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.perf_secs != 1.0) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-perf_secs:";
        double_Print(parent.cmd.perf_secs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.pertest_timeout != 900) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pertest_timeout:";
        u32_Print(parent.cmd.pertest_timeout, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.report != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.capture != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-capture:";
        bool_Print(parent.cmd.capture, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.atf_unit_proc.atf_unit.ToCmdline
algo::tempstr command::atf_unit_ToCmdline(command::atf_unit_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::atf_unit_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.atf_unit_proc..Uninit
void command::atf_unit_proc_Uninit(command::atf_unit_proc& parent) {
    command::atf_unit_proc &row = parent; (void)row;

    // command.atf_unit_proc.atf_unit.Uninit (Exec)  //
    atf_unit_Kill(parent); // kill child, ensure forward progress
}

// --- command.bash..PrintArgv
// print command-line args of command::bash to string  -- cprint:command.bash.Argv
void command::bash_PrintArgv(command::bash & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.c == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.c, temp);
        str << " -c ";
        strptr_PrintBash(temp,str);
    }
}

// --- command.bash2html..ReadFieldMaybe
bool command::bash2html_ReadFieldMaybe(command::bash2html &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_test: retval = bool_ReadStrptrMaybe(parent.test, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.bash2html..ReadTupleMaybe
// Read fields of command::bash2html from attributes of ascii tuple TUPLE
bool command::bash2html_ReadTupleMaybe(command::bash2html &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = bash2html_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.bash2html..PrintArgv
// print command-line args of command::bash2html to string  -- cprint:command.bash2html.Argv
void command::bash2html_PrintArgv(command::bash2html & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.test == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.test, temp);
        str << " -test:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.bash2html..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::bash2html_ToCmdline(command::bash2html & row) {
    tempstr ret;
    ret << "bin/bash2html ";
    bash2html_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.bash2html_proc.bash2html.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::bash2html_Start(command::bash2html_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(bash2html_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(bash2html_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= bash2html_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.bash2html_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.bash2html_proc.bash2html.StartRead
// Start subprocess & Read output
algo::Fildes command::bash2html_StartRead(command::bash2html_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    bash2html_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.bash2html_proc.bash2html.Kill
// Kill subprocess and wait
void command::bash2html_Kill(command::bash2html_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        bash2html_Wait(parent);
    }
}

// --- command.bash2html_proc.bash2html.Wait
// Wait for subprocess to return
void command::bash2html_Wait(command::bash2html_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.bash2html_proc.bash2html.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::bash2html_Exec(command::bash2html_proc& parent) {
    bash2html_Start(parent);
    bash2html_Wait(parent);
    return parent.status;
}

// --- command.bash2html_proc.bash2html.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::bash2html_ExecX(command::bash2html_proc& parent) {
    int rc = bash2html_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",bash2html_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.bash2html_proc.bash2html.Execv
// Call execv()
// Call execv with specified parameters -- cprint:bash2html.Argv
int command::bash2html_Execv(command::bash2html_proc& parent) {
    char *argv[4+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.test != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-test:";
        bool_Print(parent.cmd.test, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.bash2html_proc.bash2html.ToCmdline
algo::tempstr command::bash2html_ToCmdline(command::bash2html_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::bash2html_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.bash2html_proc..Uninit
void command::bash2html_proc_Uninit(command::bash2html_proc& parent) {
    command::bash2html_proc &row = parent; (void)row;

    // command.bash2html_proc.bash2html.Uninit (Exec)  //
    bash2html_Kill(parent); // kill child, ensure forward progress
}

// --- command.bash_proc.bash.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::bash_Start(command::bash_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(bash_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(bash_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= bash_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.bash_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.bash_proc.bash.StartRead
// Start subprocess & Read output
algo::Fildes command::bash_StartRead(command::bash_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    bash_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.bash_proc.bash.Kill
// Kill subprocess and wait
void command::bash_Kill(command::bash_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        bash_Wait(parent);
    }
}

// --- command.bash_proc.bash.Wait
// Wait for subprocess to return
void command::bash_Wait(command::bash_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.bash_proc.bash.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::bash_Exec(command::bash_proc& parent) {
    bash_Start(parent);
    bash_Wait(parent);
    return parent.status;
}

// --- command.bash_proc.bash.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::bash_ExecX(command::bash_proc& parent) {
    int rc = bash_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",bash_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.bash_proc.bash.Execv
// Call execv()
// Call execv with specified parameters -- cprint:bash.Argv
int command::bash_Execv(command::bash_proc& parent) {
    char *argv[2+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.c != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-c";
        ch_Alloc(temp) = 0;
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        cstring_Print(parent.cmd.c, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.bash_proc.bash.ToCmdline
algo::tempstr command::bash_ToCmdline(command::bash_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::bash_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.bash_proc..Uninit
void command::bash_proc_Uninit(command::bash_proc& parent) {
    command::bash_proc &row = parent; (void)row;

    // command.bash_proc.bash.Uninit (Exec)  //Must be bash to support $'' for string quoting
    bash_Kill(parent); // kill child, ensure forward progress
}

// --- command.gitlab.target.Print
// Print back to string
void command::target_Print(command::gitlab& parent, algo::cstring &out) {
    Regx_Print(parent.target, out);
}

// --- command.gitlab.target.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::target_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) {
    Regx_ReadSql(parent.target, in, true);
    bool retval = true;// !parent.target.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.gitlab.assignee.Print
// Print back to string
void command::assignee_Print(command::gitlab& parent, algo::cstring &out) {
    Regx_Print(parent.assignee, out);
}

// --- command.gitlab.assignee.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::assignee_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) {
    Regx_ReadSql(parent.assignee, in, true);
    bool retval = true;// !parent.assignee.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.gitlab..ReadFieldMaybe
bool command::gitlab_ReadFieldMaybe(command::gitlab &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_target: retval = target_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_mrlist: retval = bool_ReadStrptrMaybe(parent.mrlist, strval); break;
        case command_FieldId_mergereq: retval = bool_ReadStrptrMaybe(parent.mergereq, strval); break;
        case command_FieldId_ilist: retval = bool_ReadStrptrMaybe(parent.ilist, strval); break;
        case command_FieldId_istart: retval = bool_ReadStrptrMaybe(parent.istart, strval); break;
        case command_FieldId_t: retval = bool_ReadStrptrMaybe(parent.t, strval); break;
        case command_FieldId_iadd: retval = bool_ReadStrptrMaybe(parent.iadd, strval); break;
        case command_FieldId_ic: retval = bool_ReadStrptrMaybe(parent.ic, strval); break;
        case command_FieldId_iclose: retval = bool_ReadStrptrMaybe(parent.iclose, strval); break;
        case command_FieldId_iassignto: retval = algo::Smallstr50_ReadStrptrMaybe(parent.iassignto, strval); break;
        case command_FieldId_title: retval = algo::cstring_ReadStrptrMaybe(parent.title, strval); break;
        case command_FieldId_description: retval = algo::cstring_ReadStrptrMaybe(parent.description, strval); break;
        case command_FieldId_comment: retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval); break;
        case command_FieldId_gitdir: retval = algo::cstring_ReadStrptrMaybe(parent.gitdir, strval); break;
        case command_FieldId_assignee: retval = assignee_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_ulist: retval = bool_ReadStrptrMaybe(parent.ulist, strval); break;
        case command_FieldId_mraccept: retval = algo::cstring_ReadStrptrMaybe(parent.mraccept, strval); break;
        case command_FieldId_auth_token: retval = algo::cstring_ReadStrptrMaybe(parent.auth_token, strval); break;
        case command_FieldId_host: retval = algo::cstring_ReadStrptrMaybe(parent.host, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.gitlab..ReadTupleMaybe
// Read fields of command::gitlab from attributes of ascii tuple TUPLE
bool command::gitlab_ReadTupleMaybe(command::gitlab &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = gitlab_GetAnon(parent, anon_idx++);
        }
        retval = gitlab_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.gitlab..Init
// Set all fields to initial values.
void command::gitlab_Init(command::gitlab& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.target, "%", true);
    parent.mrlist = bool(false);
    parent.mergereq = bool(false);
    parent.ilist = bool(false);
    parent.istart = bool(false);
    parent.t = bool(false);
    parent.iadd = bool(false);
    parent.ic = bool(false);
    parent.iclose = bool(false);
    parent.iassignto = algo::strptr("");
    parent.title = algo::strptr("");
    parent.description = algo::strptr("");
    parent.comment = algo::strptr("");
    parent.gitdir = algo::strptr("");
    Regx_ReadSql(parent.assignee, "", true);
    parent.ulist = bool(false);
    parent.mraccept = algo::strptr("");
    parent.auth_token = algo::strptr("");
    parent.host = algo::strptr("");
}

// --- command.gitlab..PrintArgv
// print command-line args of command::gitlab to string  -- cprint:command.gitlab.Argv
void command::gitlab_PrintArgv(command::gitlab & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::target_Print(const_cast<command::gitlab&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.mrlist == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.mrlist, temp);
        str << " -mrlist:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.mergereq == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.mergereq, temp);
        str << " -mergereq:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ilist == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ilist, temp);
        str << " -ilist:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.istart == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.istart, temp);
        str << " -istart:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.t == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.t, temp);
        str << " -t:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.iadd == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.iadd, temp);
        str << " -iadd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ic == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ic, temp);
        str << " -ic:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.iclose == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.iclose, temp);
        str << " -iclose:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.iassignto == "")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.iassignto, temp);
        str << " -iassignto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.title == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.title, temp);
        str << " -title:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.description == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.description, temp);
        str << " -description:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.comment == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.comment, temp);
        str << " -comment:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gitdir == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.gitdir, temp);
        str << " -gitdir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.assignee.expr == "")) {
        ch_RemoveAll(temp);
        command::assignee_Print(const_cast<command::gitlab&>(row), temp);
        str << " -assignee:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ulist == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ulist, temp);
        str << " -ulist:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.mraccept == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.mraccept, temp);
        str << " -mraccept:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.auth_token == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.auth_token, temp);
        str << " -auth_token:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.host == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.host, temp);
        str << " -host:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.gitlab..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::gitlab_ToCmdline(command::gitlab & row) {
    tempstr ret;
    ret << "bin/gitlab ";
    gitlab_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.gitlab..GetAnon
algo::strptr command::gitlab_GetAnon(command::gitlab &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        default: return algo::strptr();
    }
}

// --- command.gitlab_proc.gitlab.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::gitlab_Start(command::gitlab_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(gitlab_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(gitlab_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= gitlab_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.gitlab_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.gitlab_proc.gitlab.StartRead
// Start subprocess & Read output
algo::Fildes command::gitlab_StartRead(command::gitlab_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    gitlab_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.gitlab_proc.gitlab.Kill
// Kill subprocess and wait
void command::gitlab_Kill(command::gitlab_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        gitlab_Wait(parent);
    }
}

// --- command.gitlab_proc.gitlab.Wait
// Wait for subprocess to return
void command::gitlab_Wait(command::gitlab_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.gitlab_proc.gitlab.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::gitlab_Exec(command::gitlab_proc& parent) {
    gitlab_Start(parent);
    gitlab_Wait(parent);
    return parent.status;
}

// --- command.gitlab_proc.gitlab.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::gitlab_ExecX(command::gitlab_proc& parent) {
    int rc = gitlab_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",gitlab_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.gitlab_proc.gitlab.Execv
// Call execv()
// Call execv with specified parameters -- cprint:gitlab.Argv
int command::gitlab_Execv(command::gitlab_proc& parent) {
    char *argv[40+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.target.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        command::target_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.mrlist != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-mrlist:";
        bool_Print(parent.cmd.mrlist, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.mergereq != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-mergereq:";
        bool_Print(parent.cmd.mergereq, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ilist != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ilist:";
        bool_Print(parent.cmd.ilist, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.istart != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-istart:";
        bool_Print(parent.cmd.istart, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.t != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-t:";
        bool_Print(parent.cmd.t, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.iadd != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-iadd:";
        bool_Print(parent.cmd.iadd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ic != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ic:";
        bool_Print(parent.cmd.ic, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.iclose != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-iclose:";
        bool_Print(parent.cmd.iclose, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.iassignto != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-iassignto:";
        Smallstr50_Print(parent.cmd.iassignto, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.title != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-title:";
        cstring_Print(parent.cmd.title, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.description != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-description:";
        cstring_Print(parent.cmd.description, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.comment != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-comment:";
        cstring_Print(parent.cmd.comment, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.gitdir != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-gitdir:";
        cstring_Print(parent.cmd.gitdir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.assignee.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-assignee:";
        command::assignee_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ulist != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ulist:";
        bool_Print(parent.cmd.ulist, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.mraccept != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-mraccept:";
        cstring_Print(parent.cmd.mraccept, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.auth_token != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-auth_token:";
        cstring_Print(parent.cmd.auth_token, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.host != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-host:";
        cstring_Print(parent.cmd.host, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.gitlab_proc.gitlab.ToCmdline
algo::tempstr command::gitlab_ToCmdline(command::gitlab_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::gitlab_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.gitlab_proc..Uninit
void command::gitlab_proc_Uninit(command::gitlab_proc& parent) {
    command::gitlab_proc &row = parent; (void)row;

    // command.gitlab_proc.gitlab.Uninit (Exec)  //
    gitlab_Kill(parent); // kill child, ensure forward progress
}

// --- command.lib_ctype..ReadFieldMaybe
bool command::lib_ctype_ReadFieldMaybe(command::lib_ctype &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.lib_ctype..ReadTupleMaybe
// Read fields of command::lib_ctype from attributes of ascii tuple TUPLE
bool command::lib_ctype_ReadTupleMaybe(command::lib_ctype &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = lib_ctype_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.lib_ctype..PrintArgv
// print command-line args of command::lib_ctype to string  -- cprint:command.lib_ctype.Argv
void command::lib_ctype_PrintArgv(command::lib_ctype & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.lib_ctype..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::lib_ctype_ToCmdline(command::lib_ctype & row) {
    tempstr ret;
    ret << "bin/lib_ctype ";
    lib_ctype_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.lib_exec..ReadFieldMaybe
bool command::lib_exec_ReadFieldMaybe(command::lib_exec &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_dry_run: retval = bool_ReadStrptrMaybe(parent.dry_run, strval); break;
        case command_FieldId_q: retval = bool_ReadStrptrMaybe(parent.q, strval); break;
        case command_FieldId_maxjobs: retval = i32_ReadStrptrMaybe(parent.maxjobs, strval); break;
        case command_FieldId_complooo: retval = bool_ReadStrptrMaybe(parent.complooo, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.lib_exec..ReadTupleMaybe
// Read fields of command::lib_exec from attributes of ascii tuple TUPLE
bool command::lib_exec_ReadTupleMaybe(command::lib_exec &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = lib_exec_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.lib_exec..PrintArgv
// print command-line args of command::lib_exec to string  -- cprint:command.lib_exec.Argv
void command::lib_exec_PrintArgv(command::lib_exec & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.q == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.q, temp);
        str << " -q:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxjobs == 8)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxjobs, temp);
        str << " -maxjobs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.complooo == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.complooo, temp);
        str << " -complooo:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.lib_exec..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::lib_exec_ToCmdline(command::lib_exec & row) {
    tempstr ret;
    ret << "bin/lib_exec ";
    lib_exec_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.mdbg..ReadFieldMaybe
bool command::mdbg_ReadFieldMaybe(command::mdbg &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_target: retval = algo::cstring_ReadStrptrMaybe(parent.target, strval); break;
        case command_FieldId_args: retval = algo::cstring_ReadStrptrMaybe(parent.args, strval); break;
        case command_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case command_FieldId_manywin: retval = bool_ReadStrptrMaybe(parent.manywin, strval); break;
        case command_FieldId_disas: retval = bool_ReadStrptrMaybe(parent.disas, strval); break;
        case command_FieldId_root: retval = bool_ReadStrptrMaybe(parent.root, strval); break;
        case command_FieldId_attach: retval = bool_ReadStrptrMaybe(parent.attach, strval); break;
        case command_FieldId_b: retval = algo::cstring_ReadStrptrMaybe(parent.b, strval); break;
        case command_FieldId_catchthrow: retval = bool_ReadStrptrMaybe(parent.catchthrow, strval); break;
        case command_FieldId_tui: retval = bool_ReadStrptrMaybe(parent.tui, strval); break;
        case command_FieldId_bcmd: retval = algo::cstring_ReadStrptrMaybe(parent.bcmd, strval); break;
        case command_FieldId_emacs: retval = bool_ReadStrptrMaybe(parent.emacs, strval); break;
        case command_FieldId_follow_child: retval = bool_ReadStrptrMaybe(parent.follow_child, strval); break;
        case command_FieldId_py: retval = bool_ReadStrptrMaybe(parent.py, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.mdbg..ReadTupleMaybe
// Read fields of command::mdbg from attributes of ascii tuple TUPLE
bool command::mdbg_ReadTupleMaybe(command::mdbg &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = mdbg_GetAnon(parent, anon_idx++);
        }
        retval = mdbg_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.mdbg..Init
// Set all fields to initial values.
void command::mdbg_Init(command::mdbg& parent) {
    parent.target = algo::strptr("");
    parent.args = algo::strptr("");
    parent.cfg = algo::strptr("debug");
    parent.manywin = bool(false);
    parent.disas = bool(false);
    parent.root = bool(false);
    parent.attach = bool(false);
    parent.b = algo::strptr("main");
    parent.catchthrow = bool(true);
    parent.tui = bool(false);
    parent.bcmd = algo::strptr("");
    parent.emacs = bool(true);
    parent.follow_child = bool(false);
    parent.py = bool(false);
    parent.in = algo::strptr("data");
}

// --- command.mdbg..PrintArgv
// print command-line args of command::mdbg to string  -- cprint:command.mdbg.Argv
void command::mdbg_PrintArgv(command::mdbg & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    cstring_Print(row.target, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    cstring_Print(row.args, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.cfg == "debug")) {
        ch_RemoveAll(temp);
        Smallstr50_Print(row.cfg, temp);
        str << " -cfg:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.manywin == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.manywin, temp);
        str << " -manywin:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.disas == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.disas, temp);
        str << " -disas:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.root == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.root, temp);
        str << " -root:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.attach == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.attach, temp);
        str << " -attach:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.b == "main")) {
        ch_RemoveAll(temp);
        cstring_Print(row.b, temp);
        str << " -b:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.catchthrow == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.catchthrow, temp);
        str << " -catchthrow:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tui == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tui, temp);
        str << " -tui:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.bcmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.bcmd, temp);
        str << " -bcmd:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.emacs == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.emacs, temp);
        str << " -emacs:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.follow_child == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.follow_child, temp);
        str << " -follow_child:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.py == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.py, temp);
        str << " -py:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.mdbg..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::mdbg_ToCmdline(command::mdbg & row) {
    tempstr ret;
    ret << "bin/mdbg ";
    mdbg_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.mdbg..GetAnon
algo::strptr command::mdbg_GetAnon(command::mdbg &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("target", 6);
        case(1): return strptr("args", 4);
        default: return algo::strptr();
    }
}

// --- command.mdbg_proc.mdbg.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::mdbg_Start(command::mdbg_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(mdbg_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(mdbg_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= mdbg_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.mdbg_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.mdbg_proc.mdbg.StartRead
// Start subprocess & Read output
algo::Fildes command::mdbg_StartRead(command::mdbg_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    mdbg_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.mdbg_proc.mdbg.Kill
// Kill subprocess and wait
void command::mdbg_Kill(command::mdbg_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        mdbg_Wait(parent);
    }
}

// --- command.mdbg_proc.mdbg.Wait
// Wait for subprocess to return
void command::mdbg_Wait(command::mdbg_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.mdbg_proc.mdbg.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::mdbg_Exec(command::mdbg_proc& parent) {
    mdbg_Start(parent);
    mdbg_Wait(parent);
    return parent.status;
}

// --- command.mdbg_proc.mdbg.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::mdbg_ExecX(command::mdbg_proc& parent) {
    int rc = mdbg_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",mdbg_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.mdbg_proc.mdbg.Execv
// Call execv()
// Call execv with specified parameters -- cprint:mdbg.Argv
int command::mdbg_Execv(command::mdbg_proc& parent) {
    char *argv[30+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.target != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-target:";
        cstring_Print(parent.cmd.target, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.args != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-args:";
        cstring_Print(parent.cmd.args, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cfg != "debug") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cfg:";
        Smallstr50_Print(parent.cmd.cfg, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.manywin != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-manywin:";
        bool_Print(parent.cmd.manywin, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.disas != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-disas:";
        bool_Print(parent.cmd.disas, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.root != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-root:";
        bool_Print(parent.cmd.root, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.attach != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-attach:";
        bool_Print(parent.cmd.attach, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.b != "main") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-b:";
        cstring_Print(parent.cmd.b, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.catchthrow != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-catchthrow:";
        bool_Print(parent.cmd.catchthrow, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.tui != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tui:";
        bool_Print(parent.cmd.tui, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.bcmd != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-bcmd:";
        cstring_Print(parent.cmd.bcmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.emacs != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-emacs:";
        bool_Print(parent.cmd.emacs, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.follow_child != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-follow_child:";
        bool_Print(parent.cmd.follow_child, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.py != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-py:";
        bool_Print(parent.cmd.py, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.mdbg_proc.mdbg.ToCmdline
algo::tempstr command::mdbg_ToCmdline(command::mdbg_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::mdbg_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.mdbg_proc..Uninit
void command::mdbg_proc_Uninit(command::mdbg_proc& parent) {
    command::mdbg_proc &row = parent; (void)row;

    // command.mdbg_proc.mdbg.Uninit (Exec)  //
    mdbg_Kill(parent); // kill child, ensure forward progress
}

// --- command.mysql2ssim..ReadFieldMaybe
bool command::mysql2ssim_ReadFieldMaybe(command::mysql2ssim &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_writessimfile: retval = bool_ReadStrptrMaybe(parent.writessimfile, strval); break;
        case command_FieldId_url: retval = algo::cstring_ReadStrptrMaybe(parent.url, strval); break;
        case command_FieldId_tables: retval = algo::cstring_ReadStrptrMaybe(parent.tables, strval); break;
        case command_FieldId_schema: retval = bool_ReadStrptrMaybe(parent.schema, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_pretty: retval = bool_ReadStrptrMaybe(parent.pretty, strval); break;
        case command_FieldId_nologo: retval = bool_ReadStrptrMaybe(parent.nologo, strval); break;
        case command_FieldId_baddbok: retval = bool_ReadStrptrMaybe(parent.baddbok, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.mysql2ssim..ReadTupleMaybe
// Read fields of command::mysql2ssim from attributes of ascii tuple TUPLE
bool command::mysql2ssim_ReadTupleMaybe(command::mysql2ssim &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = mysql2ssim_GetAnon(parent, anon_idx++);
        }
        retval = mysql2ssim_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.mysql2ssim..PrintArgv
// print command-line args of command::mysql2ssim to string  -- cprint:command.mysql2ssim.Argv
void command::mysql2ssim_PrintArgv(command::mysql2ssim & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.writessimfile == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.writessimfile, temp);
        str << " -writessimfile:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    cstring_Print(row.url, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    cstring_Print(row.tables, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.schema == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.schema, temp);
        str << " -schema:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pretty == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.pretty, temp);
        str << " -pretty:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nologo == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.nologo, temp);
        str << " -nologo:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.baddbok == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.baddbok, temp);
        str << " -baddbok:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.mysql2ssim..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::mysql2ssim_ToCmdline(command::mysql2ssim & row) {
    tempstr ret;
    ret << "bin/mysql2ssim ";
    mysql2ssim_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.mysql2ssim..GetAnon
algo::strptr command::mysql2ssim_GetAnon(command::mysql2ssim &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("url", 3);
        case(1): return strptr("tables", 6);
        default: return algo::strptr();
    }
}

// --- command.mysql2ssim_proc.mysql2ssim.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::mysql2ssim_Start(command::mysql2ssim_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(mysql2ssim_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(mysql2ssim_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= mysql2ssim_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.mysql2ssim_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.mysql2ssim_proc.mysql2ssim.StartRead
// Start subprocess & Read output
algo::Fildes command::mysql2ssim_StartRead(command::mysql2ssim_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    mysql2ssim_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.mysql2ssim_proc.mysql2ssim.Kill
// Kill subprocess and wait
void command::mysql2ssim_Kill(command::mysql2ssim_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        mysql2ssim_Wait(parent);
    }
}

// --- command.mysql2ssim_proc.mysql2ssim.Wait
// Wait for subprocess to return
void command::mysql2ssim_Wait(command::mysql2ssim_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.mysql2ssim_proc.mysql2ssim.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::mysql2ssim_Exec(command::mysql2ssim_proc& parent) {
    mysql2ssim_Start(parent);
    mysql2ssim_Wait(parent);
    return parent.status;
}

// --- command.mysql2ssim_proc.mysql2ssim.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::mysql2ssim_ExecX(command::mysql2ssim_proc& parent) {
    int rc = mysql2ssim_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",mysql2ssim_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.mysql2ssim_proc.mysql2ssim.Execv
// Call execv()
// Call execv with specified parameters -- cprint:mysql2ssim.Argv
int command::mysql2ssim_Execv(command::mysql2ssim_proc& parent) {
    char *argv[16+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.writessimfile != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-writessimfile:";
        bool_Print(parent.cmd.writessimfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-url:";
        cstring_Print(parent.cmd.url, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.tables != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tables:";
        cstring_Print(parent.cmd.tables, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.schema != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-schema:";
        bool_Print(parent.cmd.schema, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.pretty != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pretty:";
        bool_Print(parent.cmd.pretty, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.nologo != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nologo:";
        bool_Print(parent.cmd.nologo, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.baddbok != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-baddbok:";
        bool_Print(parent.cmd.baddbok, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.mysql2ssim_proc.mysql2ssim.ToCmdline
algo::tempstr command::mysql2ssim_ToCmdline(command::mysql2ssim_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::mysql2ssim_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.mysql2ssim_proc..Uninit
void command::mysql2ssim_proc_Uninit(command::mysql2ssim_proc& parent) {
    command::mysql2ssim_proc &row = parent; (void)row;

    // command.mysql2ssim_proc.mysql2ssim.Uninit (Exec)  //
    mysql2ssim_Kill(parent); // kill child, ensure forward progress
}

// --- command.ntup.typetag.Print
// Print back to string
void command::typetag_Print(command::ntup& parent, algo::cstring &out) {
    Regx_Print(parent.typetag, out);
}

// --- command.ntup.typetag.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::typetag_ReadStrptrMaybe(command::ntup& parent, algo::strptr in) {
    Regx_ReadSql(parent.typetag, in, true);
    bool retval = true;// !parent.typetag.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.ntup..ReadFieldMaybe
bool command::ntup_ReadFieldMaybe(command::ntup &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_cmd: retval = algo::cstring_ReadStrptrMaybe(parent.cmd, strval); break;
        case command_FieldId_field: retval = algo::Smallstr50_ReadStrptrMaybe(parent.field, strval); break;
        case command_FieldId_typetag: retval = typetag_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ntup..ReadTupleMaybe
// Read fields of command::ntup from attributes of ascii tuple TUPLE
bool command::ntup_ReadTupleMaybe(command::ntup &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ntup_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ntup..Init
// Set all fields to initial values.
void command::ntup_Init(command::ntup& parent) {
    parent.in = algo::strptr("data");
    parent.cmd = algo::strptr("");
    Regx_ReadSql(parent.typetag, "%", true);
}

// --- command.ntup..PrintArgv
// print command-line args of command::ntup to string  -- cprint:command.ntup.Argv
void command::ntup_PrintArgv(command::ntup & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.cmd == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.cmd, temp);
        str << " -cmd:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    Smallstr50_Print(row.field, temp);
    str << " -field:";
    strptr_PrintBash(temp,str);
    if (!(row.typetag.expr == "%")) {
        ch_RemoveAll(temp);
        command::typetag_Print(const_cast<command::ntup&>(row), temp);
        str << " -typetag:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ntup..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ntup_ToCmdline(command::ntup & row) {
    tempstr ret;
    ret << "bin/ntup ";
    ntup_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ntup_proc.ntup.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ntup_Start(command::ntup_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ntup_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ntup_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ntup_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ntup_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ntup_proc.ntup.StartRead
// Start subprocess & Read output
algo::Fildes command::ntup_StartRead(command::ntup_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ntup_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ntup_proc.ntup.Kill
// Kill subprocess and wait
void command::ntup_Kill(command::ntup_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ntup_Wait(parent);
    }
}

// --- command.ntup_proc.ntup.Wait
// Wait for subprocess to return
void command::ntup_Wait(command::ntup_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ntup_proc.ntup.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ntup_Exec(command::ntup_proc& parent) {
    ntup_Start(parent);
    ntup_Wait(parent);
    return parent.status;
}

// --- command.ntup_proc.ntup.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ntup_ExecX(command::ntup_proc& parent) {
    int rc = ntup_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ntup_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ntup_proc.ntup.Execv
// Call execv()
// Call execv with specified parameters -- cprint:ntup.Argv
int command::ntup_Execv(command::ntup_proc& parent) {
    char *argv[8+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.cmd != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-cmd:";
        cstring_Print(parent.cmd.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-field:";
        Smallstr50_Print(parent.cmd.field, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.typetag.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-typetag:";
        command::typetag_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.ntup_proc.ntup.ToCmdline
algo::tempstr command::ntup_ToCmdline(command::ntup_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ntup_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ntup_proc..Uninit
void command::ntup_proc_Uninit(command::ntup_proc& parent) {
    command::ntup_proc &row = parent; (void)row;

    // command.ntup_proc.ntup.Uninit (Exec)  //
    ntup_Kill(parent); // kill child, ensure forward progress
}

// --- command.orgfile.dedup.Print
// Print back to string
void command::dedup_Print(command::orgfile& parent, algo::cstring &out) {
    Regx_Print(parent.dedup, out);
}

// --- command.orgfile.dedup.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::dedup_ReadStrptrMaybe(command::orgfile& parent, algo::strptr in) {
    Regx_ReadSql(parent.dedup, in, true);
    bool retval = true;// !parent.dedup.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.orgfile..ReadFieldMaybe
bool command::orgfile_ReadFieldMaybe(command::orgfile &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_move: retval = algo::cstring_ReadStrptrMaybe(parent.move, strval); break;
        case command_FieldId_dedup: retval = dedup_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_commit: retval = bool_ReadStrptrMaybe(parent.commit, strval); break;
        case command_FieldId_undo: retval = bool_ReadStrptrMaybe(parent.undo, strval); break;
        case command_FieldId_hash: retval = algo::cstring_ReadStrptrMaybe(parent.hash, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.orgfile..ReadTupleMaybe
// Read fields of command::orgfile from attributes of ascii tuple TUPLE
bool command::orgfile_ReadTupleMaybe(command::orgfile &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = orgfile_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.orgfile..Init
// Set all fields to initial values.
void command::orgfile_Init(command::orgfile& parent) {
    parent.in = algo::strptr("data");
    parent.move = algo::strptr("");
    Regx_ReadSql(parent.dedup, "", true);
    parent.commit = bool(false);
    parent.undo = bool(false);
    parent.hash = algo::strptr("sha1");
}

// --- command.orgfile..PrintArgv
// print command-line args of command::orgfile to string  -- cprint:command.orgfile.Argv
void command::orgfile_PrintArgv(command::orgfile & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.move == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.move, temp);
        str << " -move:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dedup.expr == "")) {
        ch_RemoveAll(temp);
        command::dedup_Print(const_cast<command::orgfile&>(row), temp);
        str << " -dedup:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.commit == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.commit, temp);
        str << " -commit:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.undo == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.undo, temp);
        str << " -undo:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.hash == "sha1")) {
        ch_RemoveAll(temp);
        cstring_Print(row.hash, temp);
        str << " -hash:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.orgfile..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::orgfile_ToCmdline(command::orgfile & row) {
    tempstr ret;
    ret << "bin/orgfile ";
    orgfile_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.orgfile_proc.orgfile.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::orgfile_Start(command::orgfile_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(orgfile_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(orgfile_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= orgfile_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.orgfile_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.orgfile_proc.orgfile.StartRead
// Start subprocess & Read output
algo::Fildes command::orgfile_StartRead(command::orgfile_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    orgfile_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.orgfile_proc.orgfile.Kill
// Kill subprocess and wait
void command::orgfile_Kill(command::orgfile_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        orgfile_Wait(parent);
    }
}

// --- command.orgfile_proc.orgfile.Wait
// Wait for subprocess to return
void command::orgfile_Wait(command::orgfile_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.orgfile_proc.orgfile.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::orgfile_Exec(command::orgfile_proc& parent) {
    orgfile_Start(parent);
    orgfile_Wait(parent);
    return parent.status;
}

// --- command.orgfile_proc.orgfile.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::orgfile_ExecX(command::orgfile_proc& parent) {
    int rc = orgfile_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",orgfile_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.orgfile_proc.orgfile.Execv
// Call execv()
// Call execv with specified parameters -- cprint:orgfile.Argv
int command::orgfile_Execv(command::orgfile_proc& parent) {
    char *argv[12+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.move != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-move:";
        cstring_Print(parent.cmd.move, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dedup.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dedup:";
        command::dedup_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.commit != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-commit:";
        bool_Print(parent.cmd.commit, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.undo != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-undo:";
        bool_Print(parent.cmd.undo, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.hash != "sha1") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-hash:";
        cstring_Print(parent.cmd.hash, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.orgfile_proc.orgfile.ToCmdline
algo::tempstr command::orgfile_ToCmdline(command::orgfile_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::orgfile_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.orgfile_proc..Uninit
void command::orgfile_proc_Uninit(command::orgfile_proc& parent) {
    command::orgfile_proc &row = parent; (void)row;

    // command.orgfile_proc.orgfile.Uninit (Exec)  //
    orgfile_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_func.targsrc.Print
// Print back to string
void command::targsrc_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.targsrc, out);
}

// --- command.src_func.targsrc.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::targsrc_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    Regx_ReadSql(parent.targsrc, in, true);
    bool retval = true;// !parent.targsrc.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_func.name.Print
// Print back to string
void command::name_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.name, out);
}

// --- command.src_func.name.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::name_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    Regx_ReadSql(parent.name, in, true);
    bool retval = true;// !parent.name.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_func.body.Print
// Print back to string
void command::body_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.body, out);
}

// --- command.src_func.body.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::body_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    Regx_ReadSql(parent.body, in, true);
    bool retval = true;// !parent.body.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_func.func.Print
// Print back to string
void command::func_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.func, out);
}

// --- command.src_func.func.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::func_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    Regx_ReadSql(parent.func, in, true);
    bool retval = true;// !parent.func.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_func.comment.Print
// Print back to string
void command::comment_Print(command::src_func& parent, algo::cstring &out) {
    Regx_Print(parent.comment, out);
}

// --- command.src_func.comment.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::comment_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) {
    Regx_ReadSql(parent.comment, in, true);
    bool retval = true;// !parent.comment.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_func..ReadFieldMaybe
bool command::src_func_ReadFieldMaybe(command::src_func &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_targsrc: retval = targsrc_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_name: retval = name_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_body: retval = body_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_func: retval = func_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_comment: retval = comment_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_nextfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.nextfile, strval); break;
        case command_FieldId_other: retval = bool_ReadStrptrMaybe(parent.other, strval); break;
        case command_FieldId_updateproto: retval = bool_ReadStrptrMaybe(parent.updateproto, strval); break;
        case command_FieldId_listfunc: retval = bool_ReadStrptrMaybe(parent.listfunc, strval); break;
        case command_FieldId_iffy: retval = bool_ReadStrptrMaybe(parent.iffy, strval); break;
        case command_FieldId_proto: retval = bool_ReadStrptrMaybe(parent.proto, strval); break;
        case command_FieldId_gen: retval = bool_ReadStrptrMaybe(parent.gen, strval); break;
        case command_FieldId_showloc: retval = bool_ReadStrptrMaybe(parent.showloc, strval); break;
        case command_FieldId_showstatic: retval = bool_ReadStrptrMaybe(parent.showstatic, strval); break;
        case command_FieldId_showsortkey: retval = bool_ReadStrptrMaybe(parent.showsortkey, strval); break;
        case command_FieldId_sortname: retval = bool_ReadStrptrMaybe(parent.sortname, strval); break;
        case command_FieldId_e: retval = bool_ReadStrptrMaybe(parent.e, strval); break;
        case command_FieldId_baddecl: retval = bool_ReadStrptrMaybe(parent.baddecl, strval); break;
        case command_FieldId_report: retval = bool_ReadStrptrMaybe(parent.report, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_func..ReadTupleMaybe
// Read fields of command::src_func from attributes of ascii tuple TUPLE
bool command::src_func_ReadTupleMaybe(command::src_func &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = src_func_GetAnon(parent, anon_idx++);
        }
        retval = src_func_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_func..Init
// Set all fields to initial values.
void command::src_func_Init(command::src_func& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.targsrc, "%", true);
    Regx_ReadSql(parent.name, "%", true);
    Regx_ReadSql(parent.body, "%", true);
    Regx_ReadSql(parent.func, "%", true);
    Regx_ReadSql(parent.comment, "%", true);
    parent.nextfile = algo::strptr("");
    parent.other = bool(false);
    parent.updateproto = bool(false);
    parent.listfunc = bool(false);
    parent.iffy = bool(false);
    parent.proto = bool(false);
    parent.gen = bool(false);
    parent.showloc = bool(true);
    parent.showstatic = bool(true);
    parent.showsortkey = bool(false);
    parent.sortname = bool(false);
    parent.e = bool(false);
    parent.baddecl = bool(false);
    parent.report = bool(false);
}

// --- command.src_func..PrintArgv
// print command-line args of command::src_func to string  -- cprint:command.src_func.Argv
void command::src_func_PrintArgv(command::src_func & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    ch_RemoveAll(temp);
    command::targsrc_Print(const_cast<command::src_func&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    command::name_Print(const_cast<command::src_func&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    ch_RemoveAll(temp);
    command::body_Print(const_cast<command::src_func&>(row), temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.func.expr == "%")) {
        ch_RemoveAll(temp);
        command::func_Print(const_cast<command::src_func&>(row), temp);
        str << " -func:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.comment.expr == "%")) {
        ch_RemoveAll(temp);
        command::comment_Print(const_cast<command::src_func&>(row), temp);
        str << " -comment:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.nextfile == "")) {
        ch_RemoveAll(temp);
        Smallstr200_Print(row.nextfile, temp);
        str << " -nextfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.other == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.other, temp);
        str << " -other:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.updateproto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.updateproto, temp);
        str << " -updateproto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.listfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.listfunc, temp);
        str << " -listfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.iffy == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.iffy, temp);
        str << " -iffy:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.proto == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.proto, temp);
        str << " -proto:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.gen == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.gen, temp);
        str << " -gen:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showloc == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.showloc, temp);
        str << " -showloc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showstatic == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.showstatic, temp);
        str << " -showstatic:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.showsortkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.showsortkey, temp);
        str << " -showsortkey:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.sortname == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.sortname, temp);
        str << " -sortname:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.e == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.e, temp);
        str << " -e:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.baddecl == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.baddecl, temp);
        str << " -baddecl:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.report == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.report, temp);
        str << " -report:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_func..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_func_ToCmdline(command::src_func & row) {
    tempstr ret;
    ret << "bin/src_func ";
    src_func_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_func..GetAnon
algo::strptr command::src_func_GetAnon(command::src_func &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("targsrc", 7);
        case(1): return strptr("name", 4);
        case(2): return strptr("body", 4);
        default: return algo::strptr();
    }
}

// --- command.src_func_proc.src_func.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_func_Start(command::src_func_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_func_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_func_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_func_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_func_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_func_proc.src_func.StartRead
// Start subprocess & Read output
algo::Fildes command::src_func_StartRead(command::src_func_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_func_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_func_proc.src_func.Kill
// Kill subprocess and wait
void command::src_func_Kill(command::src_func_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_func_Wait(parent);
    }
}

// --- command.src_func_proc.src_func.Wait
// Wait for subprocess to return
void command::src_func_Wait(command::src_func_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_func_proc.src_func.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_func_Exec(command::src_func_proc& parent) {
    src_func_Start(parent);
    src_func_Wait(parent);
    return parent.status;
}

// --- command.src_func_proc.src_func.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_func_ExecX(command::src_func_proc& parent) {
    int rc = src_func_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_func_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_func_proc.src_func.Execv
// Call execv()
// Call execv with specified parameters -- cprint:src_func.Argv
int command::src_func_Execv(command::src_func_proc& parent) {
    char *argv[40+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.targsrc.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-targsrc:";
        command::targsrc_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.name.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-name:";
        command::name_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.body.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-body:";
        command::body_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.func.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-func:";
        command::func_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.comment.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-comment:";
        command::comment_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.nextfile != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-nextfile:";
        Smallstr200_Print(parent.cmd.nextfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.other != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-other:";
        bool_Print(parent.cmd.other, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.updateproto != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-updateproto:";
        bool_Print(parent.cmd.updateproto, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.listfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-listfunc:";
        bool_Print(parent.cmd.listfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.iffy != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-iffy:";
        bool_Print(parent.cmd.iffy, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.proto != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-proto:";
        bool_Print(parent.cmd.proto, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.gen != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-gen:";
        bool_Print(parent.cmd.gen, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.showloc != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-showloc:";
        bool_Print(parent.cmd.showloc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.showstatic != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-showstatic:";
        bool_Print(parent.cmd.showstatic, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.showsortkey != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-showsortkey:";
        bool_Print(parent.cmd.showsortkey, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.sortname != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-sortname:";
        bool_Print(parent.cmd.sortname, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.e != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-e:";
        bool_Print(parent.cmd.e, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.baddecl != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-baddecl:";
        bool_Print(parent.cmd.baddecl, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.report != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-report:";
        bool_Print(parent.cmd.report, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.src_func_proc.src_func.ToCmdline
algo::tempstr command::src_func_ToCmdline(command::src_func_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_func_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_func_proc..Uninit
void command::src_func_proc_Uninit(command::src_func_proc& parent) {
    command::src_func_proc &row = parent; (void)row;

    // command.src_func_proc.src_func.Uninit (Exec)  //
    src_func_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_hdr.targsrc.Print
// Print back to string
void command::targsrc_Print(command::src_hdr& parent, algo::cstring &out) {
    Regx_Print(parent.targsrc, out);
}

// --- command.src_hdr.targsrc.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::targsrc_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) {
    Regx_ReadSql(parent.targsrc, in, true);
    bool retval = true;// !parent.targsrc.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_hdr..ReadFieldMaybe
bool command::src_hdr_ReadFieldMaybe(command::src_hdr &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_targsrc: retval = targsrc_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_write: retval = bool_ReadStrptrMaybe(parent.write, strval); break;
        case command_FieldId_update_authors: retval = bool_ReadStrptrMaybe(parent.update_authors, strval); break;
        case command_FieldId_indent: retval = bool_ReadStrptrMaybe(parent.indent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_hdr..ReadTupleMaybe
// Read fields of command::src_hdr from attributes of ascii tuple TUPLE
bool command::src_hdr_ReadTupleMaybe(command::src_hdr &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = src_hdr_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_hdr..Init
// Set all fields to initial values.
void command::src_hdr_Init(command::src_hdr& parent) {
    parent.in = algo::strptr("data");
    Regx_ReadSql(parent.targsrc, "%", true);
    parent.write = bool(false);
    parent.update_authors = bool(false);
    parent.indent = bool(false);
}

// --- command.src_hdr..PrintArgv
// print command-line args of command::src_hdr to string  -- cprint:command.src_hdr.Argv
void command::src_hdr_PrintArgv(command::src_hdr & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.targsrc.expr == "%")) {
        ch_RemoveAll(temp);
        command::targsrc_Print(const_cast<command::src_hdr&>(row), temp);
        str << " -targsrc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.update_authors == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.update_authors, temp);
        str << " -update_authors:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.indent == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.indent, temp);
        str << " -indent:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_hdr..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_hdr_ToCmdline(command::src_hdr & row) {
    tempstr ret;
    ret << "bin/src_hdr ";
    src_hdr_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_hdr_proc.src_hdr.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_hdr_Start(command::src_hdr_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_hdr_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_hdr_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_hdr_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_hdr_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_hdr_proc.src_hdr.StartRead
// Start subprocess & Read output
algo::Fildes command::src_hdr_StartRead(command::src_hdr_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_hdr_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_hdr_proc.src_hdr.Kill
// Kill subprocess and wait
void command::src_hdr_Kill(command::src_hdr_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_hdr_Wait(parent);
    }
}

// --- command.src_hdr_proc.src_hdr.Wait
// Wait for subprocess to return
void command::src_hdr_Wait(command::src_hdr_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_hdr_proc.src_hdr.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_hdr_Exec(command::src_hdr_proc& parent) {
    src_hdr_Start(parent);
    src_hdr_Wait(parent);
    return parent.status;
}

// --- command.src_hdr_proc.src_hdr.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_hdr_ExecX(command::src_hdr_proc& parent) {
    int rc = src_hdr_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_hdr_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_hdr_proc.src_hdr.Execv
// Call execv()
// Call execv with specified parameters -- cprint:src_hdr.Argv
int command::src_hdr_Execv(command::src_hdr_proc& parent) {
    char *argv[10+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.targsrc.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-targsrc:";
        command::targsrc_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.update_authors != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-update_authors:";
        bool_Print(parent.cmd.update_authors, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.indent != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-indent:";
        bool_Print(parent.cmd.indent, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.src_hdr_proc.src_hdr.ToCmdline
algo::tempstr command::src_hdr_ToCmdline(command::src_hdr_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_hdr_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_hdr_proc..Uninit
void command::src_hdr_proc_Uninit(command::src_hdr_proc& parent) {
    command::src_hdr_proc &row = parent; (void)row;

    // command.src_hdr_proc.src_hdr.Uninit (Exec)  //
    src_hdr_Kill(parent); // kill child, ensure forward progress
}

// --- command.src_lim.srcfile.Print
// Print back to string
void command::srcfile_Print(command::src_lim& parent, algo::cstring &out) {
    Regx_Print(parent.srcfile, out);
}

// --- command.src_lim.srcfile.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::srcfile_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) {
    Regx_ReadSql(parent.srcfile, in, true);
    bool retval = true;// !parent.srcfile.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_lim.badline.Print
// Print back to string
void command::badline_Print(command::src_lim& parent, algo::cstring &out) {
    Regx_Print(parent.badline, out);
}

// --- command.src_lim.badline.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool command::badline_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) {
    Regx_ReadSql(parent.badline, in, true);
    bool retval = true;// !parent.badline.parseerror; -- TODO: uncomment
    return retval;
}

// --- command.src_lim..ReadFieldMaybe
bool command::src_lim_ReadFieldMaybe(command::src_lim &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_linelim: retval = bool_ReadStrptrMaybe(parent.linelim, strval); break;
        case command_FieldId_srcfile: retval = srcfile_ReadStrptrMaybe(parent, strval); break;
        case command_FieldId_strayfile: retval = bool_ReadStrptrMaybe(parent.strayfile, strval); break;
        case command_FieldId_capture: retval = bool_ReadStrptrMaybe(parent.capture, strval); break;
        case command_FieldId_write: retval = bool_ReadStrptrMaybe(parent.write, strval); break;
        case command_FieldId_badchar: retval = bool_ReadStrptrMaybe(parent.badchar, strval); break;
        case command_FieldId_badline: retval = badline_ReadStrptrMaybe(parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.src_lim..ReadTupleMaybe
// Read fields of command::src_lim from attributes of ascii tuple TUPLE
bool command::src_lim_ReadTupleMaybe(command::src_lim &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = src_lim_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.src_lim..Init
// Set all fields to initial values.
void command::src_lim_Init(command::src_lim& parent) {
    parent.in = algo::strptr("data");
    parent.linelim = bool(false);
    Regx_ReadSql(parent.srcfile, "%", true);
    parent.strayfile = bool(false);
    parent.capture = bool(false);
    parent.write = bool(false);
    parent.badchar = bool(false);
    Regx_ReadSql(parent.badline, "", true);
}

// --- command.src_lim..PrintArgv
// print command-line args of command::src_lim to string  -- cprint:command.src_lim.Argv
void command::src_lim_PrintArgv(command::src_lim & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.linelim == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.linelim, temp);
        str << " -linelim:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.srcfile.expr == "%")) {
        ch_RemoveAll(temp);
        command::srcfile_Print(const_cast<command::src_lim&>(row), temp);
        str << " -srcfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.strayfile == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.strayfile, temp);
        str << " -strayfile:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.capture == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.capture, temp);
        str << " -capture:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.write == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.write, temp);
        str << " -write:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.badchar == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.badchar, temp);
        str << " -badchar:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.badline.expr == "")) {
        ch_RemoveAll(temp);
        command::badline_Print(const_cast<command::src_lim&>(row), temp);
        str << " -badline:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.src_lim..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::src_lim_ToCmdline(command::src_lim & row) {
    tempstr ret;
    ret << "bin/src_lim ";
    src_lim_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.src_lim_proc.src_lim.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::src_lim_Start(command::src_lim_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(src_lim_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(src_lim_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= src_lim_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.src_lim_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.src_lim_proc.src_lim.StartRead
// Start subprocess & Read output
algo::Fildes command::src_lim_StartRead(command::src_lim_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    src_lim_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.src_lim_proc.src_lim.Kill
// Kill subprocess and wait
void command::src_lim_Kill(command::src_lim_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        src_lim_Wait(parent);
    }
}

// --- command.src_lim_proc.src_lim.Wait
// Wait for subprocess to return
void command::src_lim_Wait(command::src_lim_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.src_lim_proc.src_lim.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::src_lim_Exec(command::src_lim_proc& parent) {
    src_lim_Start(parent);
    src_lim_Wait(parent);
    return parent.status;
}

// --- command.src_lim_proc.src_lim.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::src_lim_ExecX(command::src_lim_proc& parent) {
    int rc = src_lim_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",src_lim_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.src_lim_proc.src_lim.Execv
// Call execv()
// Call execv with specified parameters -- cprint:src_lim.Argv
int command::src_lim_Execv(command::src_lim_proc& parent) {
    char *argv[16+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.linelim != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-linelim:";
        bool_Print(parent.cmd.linelim, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.srcfile.expr != "%") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-srcfile:";
        command::srcfile_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.strayfile != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-strayfile:";
        bool_Print(parent.cmd.strayfile, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.capture != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-capture:";
        bool_Print(parent.cmd.capture, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.write != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-write:";
        bool_Print(parent.cmd.write, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.badchar != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-badchar:";
        bool_Print(parent.cmd.badchar, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.badline.expr != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-badline:";
        command::badline_Print(parent.cmd, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.src_lim_proc.src_lim.ToCmdline
algo::tempstr command::src_lim_ToCmdline(command::src_lim_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::src_lim_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.src_lim_proc..Uninit
void command::src_lim_proc_Uninit(command::src_lim_proc& parent) {
    command::src_lim_proc &row = parent; (void)row;

    // command.src_lim_proc.src_lim.Uninit (Exec)  //
    src_lim_Kill(parent); // kill child, ensure forward progress
}

// --- command.ssim2csv..ReadFieldMaybe
bool command::ssim2csv_ReadFieldMaybe(command::ssim2csv &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_expand: retval = algo::cstring_ReadStrptrMaybe(parent.expand, strval); break;
        case command_FieldId_ignoreQuote: retval = bool_ReadStrptrMaybe(parent.ignoreQuote, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ssim2csv..ReadTupleMaybe
// Read fields of command::ssim2csv from attributes of ascii tuple TUPLE
bool command::ssim2csv_ReadTupleMaybe(command::ssim2csv &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ssim2csv_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ssim2csv..PrintArgv
// print command-line args of command::ssim2csv to string  -- cprint:command.ssim2csv.Argv
void command::ssim2csv_PrintArgv(command::ssim2csv & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.expand == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.expand, temp);
        str << " -expand:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.ignoreQuote == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.ignoreQuote, temp);
        str << " -ignoreQuote:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ssim2csv..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ssim2csv_ToCmdline(command::ssim2csv & row) {
    tempstr ret;
    ret << "bin/ssim2csv ";
    ssim2csv_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ssim2csv_proc.ssim2csv.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ssim2csv_Start(command::ssim2csv_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ssim2csv_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ssim2csv_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ssim2csv_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ssim2csv_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ssim2csv_proc.ssim2csv.StartRead
// Start subprocess & Read output
algo::Fildes command::ssim2csv_StartRead(command::ssim2csv_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ssim2csv_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ssim2csv_proc.ssim2csv.Kill
// Kill subprocess and wait
void command::ssim2csv_Kill(command::ssim2csv_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ssim2csv_Wait(parent);
    }
}

// --- command.ssim2csv_proc.ssim2csv.Wait
// Wait for subprocess to return
void command::ssim2csv_Wait(command::ssim2csv_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ssim2csv_proc.ssim2csv.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ssim2csv_Exec(command::ssim2csv_proc& parent) {
    ssim2csv_Start(parent);
    ssim2csv_Wait(parent);
    return parent.status;
}

// --- command.ssim2csv_proc.ssim2csv.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ssim2csv_ExecX(command::ssim2csv_proc& parent) {
    int rc = ssim2csv_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ssim2csv_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ssim2csv_proc.ssim2csv.Execv
// Call execv()
// Call execv with specified parameters -- cprint:ssim2csv.Argv
int command::ssim2csv_Execv(command::ssim2csv_proc& parent) {
    char *argv[4+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.expand != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-expand:";
        cstring_Print(parent.cmd.expand, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.ignoreQuote != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-ignoreQuote:";
        bool_Print(parent.cmd.ignoreQuote, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.ssim2csv_proc.ssim2csv.ToCmdline
algo::tempstr command::ssim2csv_ToCmdline(command::ssim2csv_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ssim2csv_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ssim2csv_proc..Uninit
void command::ssim2csv_proc_Uninit(command::ssim2csv_proc& parent) {
    command::ssim2csv_proc &row = parent; (void)row;

    // command.ssim2csv_proc.ssim2csv.Uninit (Exec)  //
    ssim2csv_Kill(parent); // kill child, ensure forward progress
}

// --- command.ssim2mysql..ReadFieldMaybe
bool command::ssim2mysql_ReadFieldMaybe(command::ssim2mysql &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_url: retval = algo::cstring_ReadStrptrMaybe(parent.url, strval); break;
        case command_FieldId_data_dir: retval = algo::cstring_ReadStrptrMaybe(parent.data_dir, strval); break;
        case command_FieldId_maxpacket: retval = i32_ReadStrptrMaybe(parent.maxpacket, strval); break;
        case command_FieldId_replace: retval = bool_ReadStrptrMaybe(parent.replace, strval); break;
        case command_FieldId_trunc: retval = bool_ReadStrptrMaybe(parent.trunc, strval); break;
        case command_FieldId_dry_run: retval = bool_ReadStrptrMaybe(parent.dry_run, strval); break;
        case command_FieldId_fldfunc: retval = bool_ReadStrptrMaybe(parent.fldfunc, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_db: retval = algo::cstring_ReadStrptrMaybe(parent.db, strval); break;
        case command_FieldId_createdb: retval = bool_ReadStrptrMaybe(parent.createdb, strval); break;
        case command_FieldId_fkey: retval = bool_ReadStrptrMaybe(parent.fkey, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.ssim2mysql..ReadTupleMaybe
// Read fields of command::ssim2mysql from attributes of ascii tuple TUPLE
bool command::ssim2mysql_ReadTupleMaybe(command::ssim2mysql &parent, algo::Tuple &tuple) {
    bool retval = true;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        retval = ssim2mysql_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.ssim2mysql..Init
// Set all fields to initial values.
void command::ssim2mysql_Init(command::ssim2mysql& parent) {
    parent.url = algo::strptr("");
    parent.data_dir = algo::strptr("data");
    parent.maxpacket = i32(100000);
    parent.replace = bool(true);
    parent.trunc = bool(false);
    parent.dry_run = bool(false);
    parent.fldfunc = bool(false);
    parent.in = algo::strptr("-");
    parent.db = algo::strptr("");
    parent.createdb = bool(false);
    parent.fkey = bool(false);
}

// --- command.ssim2mysql..PrintArgv
// print command-line args of command::ssim2mysql to string  -- cprint:command.ssim2mysql.Argv
void command::ssim2mysql_PrintArgv(command::ssim2mysql & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    if (!(row.url == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.url, temp);
        str << " -url:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.data_dir == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.data_dir, temp);
        str << " -data_dir:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.maxpacket == 100000)) {
        ch_RemoveAll(temp);
        i32_Print(row.maxpacket, temp);
        str << " -maxpacket:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.replace == true)) {
        ch_RemoveAll(temp);
        bool_Print(row.replace, temp);
        str << " -replace:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.trunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.trunc, temp);
        str << " -trunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.dry_run == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.dry_run, temp);
        str << " -dry_run:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fldfunc == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fldfunc, temp);
        str << " -fldfunc:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "-")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.db == "")) {
        ch_RemoveAll(temp);
        cstring_Print(row.db, temp);
        str << " -db:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.createdb == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.createdb, temp);
        str << " -createdb:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.fkey == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.fkey, temp);
        str << " -fkey:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.ssim2mysql..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::ssim2mysql_ToCmdline(command::ssim2mysql & row) {
    tempstr ret;
    ret << "bin/ssim2mysql ";
    ssim2mysql_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.ssim2mysql_proc.ssim2mysql.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::ssim2mysql_Start(command::ssim2mysql_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(ssim2mysql_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(ssim2mysql_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= ssim2mysql_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.ssim2mysql_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.ssim2mysql_proc.ssim2mysql.StartRead
// Start subprocess & Read output
algo::Fildes command::ssim2mysql_StartRead(command::ssim2mysql_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    ssim2mysql_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.ssim2mysql_proc.ssim2mysql.Kill
// Kill subprocess and wait
void command::ssim2mysql_Kill(command::ssim2mysql_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        ssim2mysql_Wait(parent);
    }
}

// --- command.ssim2mysql_proc.ssim2mysql.Wait
// Wait for subprocess to return
void command::ssim2mysql_Wait(command::ssim2mysql_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.ssim2mysql_proc.ssim2mysql.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::ssim2mysql_Exec(command::ssim2mysql_proc& parent) {
    ssim2mysql_Start(parent);
    ssim2mysql_Wait(parent);
    return parent.status;
}

// --- command.ssim2mysql_proc.ssim2mysql.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::ssim2mysql_ExecX(command::ssim2mysql_proc& parent) {
    int rc = ssim2mysql_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",ssim2mysql_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.ssim2mysql_proc.ssim2mysql.Execv
// Call execv()
// Call execv with specified parameters -- cprint:ssim2mysql.Argv
int command::ssim2mysql_Execv(command::ssim2mysql_proc& parent) {
    char *argv[22+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (parent.cmd.url != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-url:";
        cstring_Print(parent.cmd.url, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.data_dir != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-data_dir:";
        cstring_Print(parent.cmd.data_dir, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.maxpacket != 100000) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-maxpacket:";
        i32_Print(parent.cmd.maxpacket, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.replace != true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-replace:";
        bool_Print(parent.cmd.replace, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.trunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-trunc:";
        bool_Print(parent.cmd.trunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.dry_run != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-dry_run:";
        bool_Print(parent.cmd.dry_run, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fldfunc != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fldfunc:";
        bool_Print(parent.cmd.fldfunc, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "-") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.db != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-db:";
        cstring_Print(parent.cmd.db, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.createdb != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-createdb:";
        bool_Print(parent.cmd.createdb, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.fkey != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-fkey:";
        bool_Print(parent.cmd.fkey, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.ssim2mysql_proc.ssim2mysql.ToCmdline
algo::tempstr command::ssim2mysql_ToCmdline(command::ssim2mysql_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::ssim2mysql_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.ssim2mysql_proc..Uninit
void command::ssim2mysql_proc_Uninit(command::ssim2mysql_proc& parent) {
    command::ssim2mysql_proc &row = parent; (void)row;

    // command.ssim2mysql_proc.ssim2mysql.Uninit (Exec)  //
    ssim2mysql_Kill(parent); // kill child, ensure forward progress
}

// --- command.strconv..ReadFieldMaybe
bool command::strconv_ReadFieldMaybe(command::strconv &parent, algo::strptr field, algo::strptr strval) {
    command::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case command_FieldId_str: retval = algo::cstring_ReadStrptrMaybe(parent.str, strval); break;
        case command_FieldId_tocamelcase: retval = bool_ReadStrptrMaybe(parent.tocamelcase, strval); break;
        case command_FieldId_tolowerunder: retval = bool_ReadStrptrMaybe(parent.tolowerunder, strval); break;
        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
        case command_FieldId_pathcomp: retval = algo::Smallstr100_ReadStrptrMaybe(parent.pathcomp, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- command.strconv..ReadTupleMaybe
// Read fields of command::strconv from attributes of ascii tuple TUPLE
bool command::strconv_ReadTupleMaybe(command::strconv &parent, algo::Tuple &tuple) {
    bool retval = true;
    int anon_idx = 0;
    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
        if (ch_N(attr.name) == 0) {
            attr.name = strconv_GetAnon(parent, anon_idx++);
        }
        retval = strconv_ReadFieldMaybe(parent, attr.name, attr.value);
        if (!retval) {
            break;
        }
    }ind_end;
    return retval;
}

// --- command.strconv..PrintArgv
// print command-line args of command::strconv to string  -- cprint:command.strconv.Argv
void command::strconv_PrintArgv(command::strconv & row, algo::cstring &str) {
    algo::tempstr temp;
    (void)temp;
    (void)row;
    (void)str;
    ch_RemoveAll(temp);
    cstring_Print(row.str, temp);
    str << " ";
    strptr_PrintBash(temp,str);
    if (!(row.tocamelcase == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tocamelcase, temp);
        str << " -tocamelcase:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.tolowerunder == false)) {
        ch_RemoveAll(temp);
        bool_Print(row.tolowerunder, temp);
        str << " -tolowerunder:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.in == "data")) {
        ch_RemoveAll(temp);
        cstring_Print(row.in, temp);
        str << " -in:";
        strptr_PrintBash(temp,str);
    }
    if (!(row.pathcomp == "")) {
        ch_RemoveAll(temp);
        Smallstr100_Print(row.pathcomp, temp);
        str << " -pathcomp:";
        strptr_PrintBash(temp,str);
    }
}

// --- command.strconv..ToCmdline
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr command::strconv_ToCmdline(command::strconv & row) {
    tempstr ret;
    ret << "bin/strconv ";
    strconv_PrintArgv(row, ret);
    // inherit less intense verbose, debug options
    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
        ret << " -verbose";
    }
    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
        ret << " -debug";
    }
    return ret;
}

// --- command.strconv..GetAnon
algo::strptr command::strconv_GetAnon(command::strconv &parent, i32 idx) {
    (void)parent;//only to avoid -Wunused-parameter
    switch(idx) {
        case(0): return strptr("str", 3);
        default: return algo::strptr();
    }
}

// --- command.strconv_proc.strconv.Start
// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int command::strconv_Start(command::strconv_proc& parent) {
    int retval = 0;
    if (parent.pid == 0) {
        verblog(strconv_ToCmdline(parent)); // maybe print command
#ifdef WIN32
        algo_lib::ResolveExecFname(parent.path);
        tempstr cmdline(strconv_ToCmdline(parent));
        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
#else
        parent.pid = fork();
        if (parent.pid == 0) { // child
            algo_lib::DieWithParent();
            if (parent.timeout > 0) {
                alarm(parent.timeout);
            }
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
            if (retval==0) retval= strconv_Execv(parent);
            if (retval != 0) { // if start fails, print error
                int err=errno;
                prerr("command.strconv_execv"
                <<Keyval("errno",err)
                <<Keyval("errstr",strerror(err))
                <<Keyval("comment","Execv failed"));
            }
            _exit(127); // if failed to start, exit anyway
        } else if (parent.pid == -1) {
            retval = errno; // failed to fork
        }
#endif
    }
    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
    return retval;
}

// --- command.strconv_proc.strconv.StartRead
// Start subprocess & Read output
algo::Fildes command::strconv_StartRead(command::strconv_proc& parent, algo_lib::FFildes &read) {
    int pipefd[2];
    int rc=pipe(pipefd);
    (void)rc;
    read.fd.value = pipefd[0];
    parent.fstdout  << ">&" << pipefd[1];
    strconv_Start(parent);
    (void)close(pipefd[1]);
    return read.fd;
}

// --- command.strconv_proc.strconv.Kill
// Kill subprocess and wait
void command::strconv_Kill(command::strconv_proc& parent) {
    if (parent.pid != 0) {
        kill(parent.pid,9);
        strconv_Wait(parent);
    }
}

// --- command.strconv_proc.strconv.Wait
// Wait for subprocess to return
void command::strconv_Wait(command::strconv_proc& parent) {
    if (parent.pid > 0) {
        int wait_flags = 0;
        int wait_status = 0;
        int rc = -1;
        do {
            // really wait for subprocess to exit
            rc = waitpid(parent.pid,&wait_status,wait_flags);
        } while (rc==-1 && errno==EINTR);
        if (rc == parent.pid) {
            parent.status = wait_status;
            parent.pid = 0;
        }
    }
}

// --- command.strconv_proc.strconv.Exec
// Start + Wait
// Execute subprocess and return exit code
int command::strconv_Exec(command::strconv_proc& parent) {
    strconv_Start(parent);
    strconv_Wait(parent);
    return parent.status;
}

// --- command.strconv_proc.strconv.ExecX
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void command::strconv_ExecX(command::strconv_proc& parent) {
    int rc = strconv_Exec(parent);
    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",strconv_ToCmdline(parent))
    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
}

// --- command.strconv_proc.strconv.Execv
// Call execv()
// Call execv with specified parameters -- cprint:strconv.Argv
int command::strconv_Execv(command::strconv_proc& parent) {
    char *argv[10+2]; // start of first arg (future pointer)
    algo::tempstr temp;
    int n_argv=0;
    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
    temp << parent.path;
    ch_Alloc(temp) = 0;// NUL term for pathname

    if (true) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-str:";
        cstring_Print(parent.cmd.str, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.tocamelcase != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tocamelcase:";
        bool_Print(parent.cmd.tocamelcase, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.tolowerunder != false) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-tolowerunder:";
        bool_Print(parent.cmd.tolowerunder, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.in != "data") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-in:";
        cstring_Print(parent.cmd.in, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }

    if (parent.cmd.pathcomp != "") {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-pathcomp:";
        Smallstr100_Print(parent.cmd.pathcomp, temp);
        ch_Alloc(temp) = 0;// NUL term for this arg
    }
    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
        temp << "-verbose";
        ch_Alloc(temp) = 0;
    }
    argv[n_argv] = NULL; // last pointer
    while (n_argv>0) { // shift pointers
        argv[--n_argv] += (u64)temp.ch_elems;
    }
    // if parent.path is relative, search for it in PATH
    algo_lib::ResolveExecFname(parent.path);
    return execv(Zeroterm(parent.path),argv);
}

// --- command.strconv_proc.strconv.ToCmdline
algo::tempstr command::strconv_ToCmdline(command::strconv_proc& parent) {
    algo::tempstr retval;
    retval << parent.path << " ";
    command::strconv_PrintArgv(parent.cmd,retval);
    if (ch_N(parent.fstdin)) {
        retval << " " << parent.fstdin;
    }
    if (ch_N(parent.fstdout)) {
        retval << " " << parent.fstdout;
    }
    if (ch_N(parent.fstderr)) {
        retval << " 2" << parent.fstderr;
    }
    return retval;
}

// --- command.strconv_proc..Uninit
void command::strconv_proc_Uninit(command::strconv_proc& parent) {
    command::strconv_proc &row = parent; (void)row;

    // command.strconv_proc.strconv.Uninit (Exec)  //
    strconv_Kill(parent); // kill child, ensure forward progress
}

// --- command...SizeCheck
inline static void command::SizeCheck() {
    algo_assert(_offset_of(command::abt,target) == 0);
    algo_assert(_offset_of(command::abt,in) == 96);
    algo_assert(_offset_of(command::abt,out_dir) == 112);
    algo_assert(_offset_of(command::abt,cfg) == 128);
    algo_assert(_offset_of(command::abt,compiler) == 180);
    algo_assert(_offset_of(command::abt,uname) == 232);
    algo_assert(_offset_of(command::abt,arch) == 284);
    algo_assert(_offset_of(command::abt,ood) == 336);
    algo_assert(_offset_of(command::abt,list) == 337);
    algo_assert(_offset_of(command::abt,listincl) == 338);
    algo_assert(_offset_of(command::abt,build) == 339);
    algo_assert(_offset_of(command::abt,preproc) == 340);
    algo_assert(_offset_of(command::abt,clean) == 341);
    algo_assert(_offset_of(command::abt,dry_run) == 342);
    algo_assert(_offset_of(command::abt,maxjobs) == 344);
    algo_assert(_offset_of(command::abt,printcmd) == 348);
    algo_assert(_offset_of(command::abt,force) == 349);
    algo_assert(_offset_of(command::abt,install) == 350);
    algo_assert(_offset_of(command::abt,coverity) == 351);
    algo_assert(_offset_of(command::abt,package) == 352);
    algo_assert(_offset_of(command::abt,maxerr) == 368);
    algo_assert(_offset_of(command::abt,disas) == 376);
    algo_assert(_offset_of(command::abt,report) == 472);
    algo_assert(_offset_of(command::abt,jcdb) == 480);
    algo_assert(sizeof(command::abt) == 496);
    algo_assert(_offset_of(command::acr,query) == 0);
    algo_assert(_offset_of(command::acr,select) == 16);
    algo_assert(_offset_of(command::acr,del) == 17);
    algo_assert(_offset_of(command::acr,insert) == 18);
    algo_assert(_offset_of(command::acr,replace) == 19);
    algo_assert(_offset_of(command::acr,merge) == 20);
    algo_assert(_offset_of(command::acr,unused) == 21);
    algo_assert(_offset_of(command::acr,trunc) == 22);
    algo_assert(_offset_of(command::acr,check) == 23);
    algo_assert(_offset_of(command::acr,maxshow) == 24);
    algo_assert(_offset_of(command::acr,write) == 28);
    algo_assert(_offset_of(command::acr,rename) == 32);
    algo_assert(_offset_of(command::acr,nup) == 48);
    algo_assert(_offset_of(command::acr,ndown) == 52);
    algo_assert(_offset_of(command::acr,xref) == 56);
    algo_assert(_offset_of(command::acr,fldfunc) == 57);
    algo_assert(_offset_of(command::acr,maxgroup) == 60);
    algo_assert(_offset_of(command::acr,pretty) == 64);
    algo_assert(_offset_of(command::acr,tree) == 65);
    algo_assert(_offset_of(command::acr,loose) == 66);
    algo_assert(_offset_of(command::acr,my) == 67);
    algo_assert(_offset_of(command::acr,schema) == 72);
    algo_assert(_offset_of(command::acr,e) == 88);
    algo_assert(_offset_of(command::acr,b) == 89);
    algo_assert(_offset_of(command::acr,t) == 90);
    algo_assert(_offset_of(command::acr,rowid) == 91);
    algo_assert(_offset_of(command::acr,in) == 96);
    algo_assert(_offset_of(command::acr,cmt) == 112);
    algo_assert(_offset_of(command::acr,report) == 113);
    algo_assert(_offset_of(command::acr,print) == 114);
    algo_assert(_offset_of(command::acr,cmd) == 120);
    algo_assert(_offset_of(command::acr,field) == 136);
    algo_assert(_offset_of(command::acr,regxof) == 152);
    algo_assert(_offset_of(command::acr,meta) == 168);
    algo_assert(sizeof(command::acr) == 176);
    algo_assert(_offset_of(command::acr_compl,line) == 0);
    algo_assert(_offset_of(command::acr_compl,point) == 16);
    algo_assert(_offset_of(command::acr_compl,type) == 32);
    algo_assert(_offset_of(command::acr_compl,install) == 48);
    algo_assert(sizeof(command::acr_compl) == 56);
    algo_assert(_offset_of(command::acr_ed,in) == 0);
    algo_assert(_offset_of(command::acr_ed,create) == 16);
    algo_assert(_offset_of(command::acr_ed,del) == 17);
    algo_assert(_offset_of(command::acr_ed,rename) == 24);
    algo_assert(_offset_of(command::acr_ed,replace) == 40);
    algo_assert(_offset_of(command::acr_ed,finput) == 41);
    algo_assert(_offset_of(command::acr_ed,foutput) == 42);
    algo_assert(_offset_of(command::acr_ed,srcfile) == 48);
    algo_assert(_offset_of(command::acr_ed,gstatic) == 64);
    algo_assert(_offset_of(command::acr_ed,indexed) == 65);
    algo_assert(_offset_of(command::acr_ed,target) == 66);
    algo_assert(_offset_of(command::acr_ed,nstype) == 84);
    algo_assert(_offset_of(command::acr_ed,ctype) == 136);
    algo_assert(_offset_of(command::acr_ed,pooltype) == 188);
    algo_assert(_offset_of(command::acr_ed,ssimfile) == 240);
    algo_assert(_offset_of(command::acr_ed,subset) == 292);
    algo_assert(_offset_of(command::acr_ed,subset2) == 344);
    algo_assert(_offset_of(command::acr_ed,separator) == 400);
    algo_assert(_offset_of(command::acr_ed,field) == 416);
    algo_assert(_offset_of(command::acr_ed,arg) == 518);
    algo_assert(_offset_of(command::acr_ed,dflt) == 576);
    algo_assert(_offset_of(command::acr_ed,anon) == 592);
    algo_assert(_offset_of(command::acr_ed,bigend) == 593);
    algo_assert(_offset_of(command::acr_ed,cascdel) == 594);
    algo_assert(_offset_of(command::acr_ed,before) == 595);
    algo_assert(_offset_of(command::acr_ed,substr) == 697);
    algo_assert(_offset_of(command::acr_ed,srcfield) == 799);
    algo_assert(_offset_of(command::acr_ed,fstep) == 901);
    algo_assert(_offset_of(command::acr_ed,inscond) == 1008);
    algo_assert(_offset_of(command::acr_ed,reftype) == 1024);
    algo_assert(_offset_of(command::acr_ed,hashfld) == 1076);
    algo_assert(_offset_of(command::acr_ed,sortfld) == 1178);
    algo_assert(_offset_of(command::acr_ed,unittest) == 1280);
    algo_assert(_offset_of(command::acr_ed,normcheck) == 1296);
    algo_assert(_offset_of(command::acr_ed,cppfunc) == 1312);
    algo_assert(_offset_of(command::acr_ed,xref) == 1328);
    algo_assert(_offset_of(command::acr_ed,via) == 1336);
    algo_assert(_offset_of(command::acr_ed,write) == 1352);
    algo_assert(_offset_of(command::acr_ed,e) == 1353);
    algo_assert(_offset_of(command::acr_ed,comment) == 1360);
    algo_assert(_offset_of(command::acr_ed,sandbox) == 1376);
    algo_assert(_offset_of(command::acr_ed,test) == 1377);
    algo_assert(_offset_of(command::acr_ed,showcpp) == 1378);
    algo_assert(sizeof(command::acr_ed) == 1384);
    algo_assert(_offset_of(command::acr_in,ns) == 0);
    algo_assert(_offset_of(command::acr_in,data) == 96);
    algo_assert(_offset_of(command::acr_in,sigcheck) == 97);
    algo_assert(_offset_of(command::acr_in,list) == 98);
    algo_assert(_offset_of(command::acr_in,data_dir) == 104);
    algo_assert(_offset_of(command::acr_in,schema) == 120);
    algo_assert(_offset_of(command::acr_in,related) == 136);
    algo_assert(_offset_of(command::acr_in,notssimfile) == 152);
    algo_assert(_offset_of(command::acr_in,checkable) == 248);
    algo_assert(sizeof(command::acr_in) == 256);
    algo_assert(_offset_of(command::acr_my,nsdb) == 0);
    algo_assert(_offset_of(command::acr_my,in) == 96);
    algo_assert(_offset_of(command::acr_my,schema) == 112);
    algo_assert(_offset_of(command::acr_my,fldfunc) == 128);
    algo_assert(_offset_of(command::acr_my,fkey) == 129);
    algo_assert(_offset_of(command::acr_my,e) == 130);
    algo_assert(_offset_of(command::acr_my,start) == 131);
    algo_assert(_offset_of(command::acr_my,stop) == 132);
    algo_assert(_offset_of(command::acr_my,abort) == 133);
    algo_assert(_offset_of(command::acr_my,shell) == 134);
    algo_assert(_offset_of(command::acr_my,serv) == 135);
    algo_assert(sizeof(command::acr_my) == 136);
    algo_assert(_offset_of(command::amc,in_dir) == 0);
    algo_assert(_offset_of(command::amc,query) == 16);
    algo_assert(_offset_of(command::amc,out_dir) == 32);
    algo_assert(_offset_of(command::amc,proto) == 48);
    algo_assert(_offset_of(command::amc,report) == 49);
    algo_assert(_offset_of(command::amc,e) == 50);
    algo_assert(_offset_of(command::amc,trace) == 56);
    algo_assert(sizeof(command::amc) == 152);
    algo_assert(_offset_of(command::amc_dml,ns) == 0);
    algo_assert(_offset_of(command::amc_dml,fconst) == 96);
    algo_assert(_offset_of(command::amc_dml,gconst) == 97);
    algo_assert(_offset_of(command::amc_dml,in) == 104);
    algo_assert(sizeof(command::amc_dml) == 120);
    algo_assert(_offset_of(command::amc_gc,target) == 0);
    algo_assert(_offset_of(command::amc_gc,key) == 96);
    algo_assert(_offset_of(command::amc_gc,include) == 192);
    algo_assert(_offset_of(command::amc_gc,in) == 200);
    algo_assert(sizeof(command::amc_gc) == 216);
    algo_assert(_offset_of(command::amc_vis,ctype) == 0);
    algo_assert(_offset_of(command::amc_vis,in) == 96);
    algo_assert(_offset_of(command::amc_vis,dot) == 112);
    algo_assert(_offset_of(command::amc_vis,xref) == 128);
    algo_assert(_offset_of(command::amc_vis,xns) == 129);
    algo_assert(_offset_of(command::amc_vis,noinput) == 130);
    algo_assert(_offset_of(command::amc_vis,check) == 131);
    algo_assert(_offset_of(command::amc_vis,render) == 132);
    algo_assert(sizeof(command::amc_vis) == 136);
    algo_assert(_offset_of(command::atf_amc,in) == 0);
    algo_assert(_offset_of(command::atf_amc,amctest) == 16);
    algo_assert(_offset_of(command::atf_amc,dofork) == 112);
    algo_assert(_offset_of(command::atf_amc,q) == 113);
    algo_assert(sizeof(command::atf_amc) == 120);
    algo_assert(_offset_of(command::atf_norm,in) == 0);
    algo_assert(_offset_of(command::atf_norm,normcheck) == 16);
    algo_assert(sizeof(command::atf_norm) == 112);
    algo_assert(_offset_of(command::atf_nrun,in) == 0);
    algo_assert(_offset_of(command::atf_nrun,maxjobs) == 16);
    algo_assert(_offset_of(command::atf_nrun,ncmd) == 20);
    algo_assert(sizeof(command::atf_nrun) == 24);
    algo_assert(_offset_of(command::atf_unit,unittest) == 0);
    algo_assert(_offset_of(command::atf_unit,nofork) == 96);
    algo_assert(_offset_of(command::atf_unit,arg) == 104);
    algo_assert(_offset_of(command::atf_unit,data_dir) == 120);
    algo_assert(_offset_of(command::atf_unit,debug) == 136);
    algo_assert(_offset_of(command::atf_unit,perf_secs) == 144);
    algo_assert(_offset_of(command::atf_unit,pertest_timeout) == 152);
    algo_assert(_offset_of(command::atf_unit,report) == 156);
    algo_assert(_offset_of(command::atf_unit,capture) == 157);
    algo_assert(sizeof(command::atf_unit) == 160);
    algo_assert(_offset_of(command::bash,c) == 0);
    algo_assert(sizeof(command::bash) == 16);
    algo_assert(_offset_of(command::bash2html,in) == 0);
    algo_assert(_offset_of(command::bash2html,test) == 16);
    algo_assert(sizeof(command::bash2html) == 24);
    algo_assert(_offset_of(command::bash_proc,path) == 0);
    algo_assert(_offset_of(command::bash_proc,cmd) == 16);
    algo_assert(_offset_of(command::bash_proc,fstdin) == 32);
    algo_assert(_offset_of(command::bash_proc,fstdout) == 48);
    algo_assert(_offset_of(command::bash_proc,fstderr) == 64);
    algo_assert(_offset_of(command::bash_proc,pid) == 80);
    algo_assert(_offset_of(command::bash_proc,timeout) == 84);
    algo_assert(_offset_of(command::bash_proc,status) == 88);
    algo_assert(sizeof(command::bash_proc) == 96);
    algo_assert(_offset_of(command::gitlab,in) == 0);
    algo_assert(_offset_of(command::gitlab,target) == 16);
    algo_assert(_offset_of(command::gitlab,mrlist) == 112);
    algo_assert(_offset_of(command::gitlab,mergereq) == 113);
    algo_assert(_offset_of(command::gitlab,ilist) == 114);
    algo_assert(_offset_of(command::gitlab,istart) == 115);
    algo_assert(_offset_of(command::gitlab,t) == 116);
    algo_assert(_offset_of(command::gitlab,iadd) == 117);
    algo_assert(_offset_of(command::gitlab,ic) == 118);
    algo_assert(_offset_of(command::gitlab,iclose) == 119);
    algo_assert(_offset_of(command::gitlab,iassignto) == 120);
    algo_assert(_offset_of(command::gitlab,title) == 176);
    algo_assert(_offset_of(command::gitlab,description) == 192);
    algo_assert(_offset_of(command::gitlab,comment) == 208);
    algo_assert(_offset_of(command::gitlab,gitdir) == 224);
    algo_assert(_offset_of(command::gitlab,assignee) == 240);
    algo_assert(_offset_of(command::gitlab,ulist) == 336);
    algo_assert(_offset_of(command::gitlab,mraccept) == 344);
    algo_assert(_offset_of(command::gitlab,auth_token) == 360);
    algo_assert(_offset_of(command::gitlab,host) == 376);
    algo_assert(sizeof(command::gitlab) == 392);
    algo_assert(_offset_of(command::lib_ctype,in) == 0);
    algo_assert(sizeof(command::lib_ctype) == 16);
    algo_assert(_offset_of(command::lib_exec,dry_run) == 0);
    algo_assert(_offset_of(command::lib_exec,q) == 1);
    algo_assert(_offset_of(command::lib_exec,maxjobs) == 4);
    algo_assert(_offset_of(command::lib_exec,complooo) == 8);
    algo_assert(sizeof(command::lib_exec) == 12);
    algo_assert(_offset_of(command::mdbg,target) == 0);
    algo_assert(_offset_of(command::mdbg,args) == 16);
    algo_assert(_offset_of(command::mdbg,cfg) == 32);
    algo_assert(_offset_of(command::mdbg,manywin) == 84);
    algo_assert(_offset_of(command::mdbg,disas) == 85);
    algo_assert(_offset_of(command::mdbg,root) == 86);
    algo_assert(_offset_of(command::mdbg,attach) == 87);
    algo_assert(_offset_of(command::mdbg,b) == 88);
    algo_assert(_offset_of(command::mdbg,catchthrow) == 104);
    algo_assert(_offset_of(command::mdbg,tui) == 105);
    algo_assert(_offset_of(command::mdbg,bcmd) == 112);
    algo_assert(_offset_of(command::mdbg,emacs) == 128);
    algo_assert(_offset_of(command::mdbg,follow_child) == 129);
    algo_assert(_offset_of(command::mdbg,py) == 130);
    algo_assert(_offset_of(command::mdbg,in) == 136);
    algo_assert(sizeof(command::mdbg) == 152);
    algo_assert(_offset_of(command::mysql2ssim,writessimfile) == 0);
    algo_assert(_offset_of(command::mysql2ssim,url) == 8);
    algo_assert(_offset_of(command::mysql2ssim,tables) == 24);
    algo_assert(_offset_of(command::mysql2ssim,schema) == 40);
    algo_assert(_offset_of(command::mysql2ssim,in) == 48);
    algo_assert(_offset_of(command::mysql2ssim,pretty) == 64);
    algo_assert(_offset_of(command::mysql2ssim,nologo) == 65);
    algo_assert(_offset_of(command::mysql2ssim,baddbok) == 66);
    algo_assert(sizeof(command::mysql2ssim) == 72);
    algo_assert(_offset_of(command::ntup,in) == 0);
    algo_assert(_offset_of(command::ntup,cmd) == 16);
    algo_assert(_offset_of(command::ntup,field) == 32);
    algo_assert(_offset_of(command::ntup,typetag) == 88);
    algo_assert(sizeof(command::ntup) == 184);
    algo_assert(_offset_of(command::orgfile,in) == 0);
    algo_assert(_offset_of(command::orgfile,move) == 16);
    algo_assert(_offset_of(command::orgfile,dedup) == 32);
    algo_assert(_offset_of(command::orgfile,commit) == 128);
    algo_assert(_offset_of(command::orgfile,undo) == 129);
    algo_assert(_offset_of(command::orgfile,hash) == 136);
    algo_assert(sizeof(command::orgfile) == 152);
    algo_assert(_offset_of(command::src_func,in) == 0);
    algo_assert(_offset_of(command::src_func,targsrc) == 16);
    algo_assert(_offset_of(command::src_func,name) == 112);
    algo_assert(_offset_of(command::src_func,body) == 208);
    algo_assert(_offset_of(command::src_func,func) == 304);
    algo_assert(_offset_of(command::src_func,comment) == 400);
    algo_assert(_offset_of(command::src_func,nextfile) == 496);
    algo_assert(_offset_of(command::src_func,other) == 698);
    algo_assert(_offset_of(command::src_func,updateproto) == 699);
    algo_assert(_offset_of(command::src_func,listfunc) == 700);
    algo_assert(_offset_of(command::src_func,iffy) == 701);
    algo_assert(_offset_of(command::src_func,proto) == 702);
    algo_assert(_offset_of(command::src_func,gen) == 703);
    algo_assert(_offset_of(command::src_func,showloc) == 704);
    algo_assert(_offset_of(command::src_func,showstatic) == 705);
    algo_assert(_offset_of(command::src_func,showsortkey) == 706);
    algo_assert(_offset_of(command::src_func,sortname) == 707);
    algo_assert(_offset_of(command::src_func,e) == 708);
    algo_assert(_offset_of(command::src_func,baddecl) == 709);
    algo_assert(_offset_of(command::src_func,report) == 710);
    algo_assert(sizeof(command::src_func) == 712);
    algo_assert(_offset_of(command::src_hdr,in) == 0);
    algo_assert(_offset_of(command::src_hdr,targsrc) == 16);
    algo_assert(_offset_of(command::src_hdr,write) == 112);
    algo_assert(_offset_of(command::src_hdr,update_authors) == 113);
    algo_assert(_offset_of(command::src_hdr,indent) == 114);
    algo_assert(sizeof(command::src_hdr) == 120);
    algo_assert(_offset_of(command::src_lim,in) == 0);
    algo_assert(_offset_of(command::src_lim,linelim) == 16);
    algo_assert(_offset_of(command::src_lim,srcfile) == 24);
    algo_assert(_offset_of(command::src_lim,strayfile) == 120);
    algo_assert(_offset_of(command::src_lim,capture) == 121);
    algo_assert(_offset_of(command::src_lim,write) == 122);
    algo_assert(_offset_of(command::src_lim,badchar) == 123);
    algo_assert(_offset_of(command::src_lim,badline) == 128);
    algo_assert(sizeof(command::src_lim) == 224);
    algo_assert(_offset_of(command::ssim2csv,expand) == 0);
    algo_assert(_offset_of(command::ssim2csv,ignoreQuote) == 16);
    algo_assert(sizeof(command::ssim2csv) == 24);
    algo_assert(_offset_of(command::ssim2mysql,url) == 0);
    algo_assert(_offset_of(command::ssim2mysql,data_dir) == 16);
    algo_assert(_offset_of(command::ssim2mysql,maxpacket) == 32);
    algo_assert(_offset_of(command::ssim2mysql,replace) == 36);
    algo_assert(_offset_of(command::ssim2mysql,trunc) == 37);
    algo_assert(_offset_of(command::ssim2mysql,dry_run) == 38);
    algo_assert(_offset_of(command::ssim2mysql,fldfunc) == 39);
    algo_assert(_offset_of(command::ssim2mysql,in) == 40);
    algo_assert(_offset_of(command::ssim2mysql,db) == 56);
    algo_assert(_offset_of(command::ssim2mysql,createdb) == 72);
    algo_assert(_offset_of(command::ssim2mysql,fkey) == 73);
    algo_assert(sizeof(command::ssim2mysql) == 80);
    algo_assert(_offset_of(command::strconv,str) == 0);
    algo_assert(_offset_of(command::strconv,tocamelcase) == 16);
    algo_assert(_offset_of(command::strconv,tolowerunder) == 17);
    algo_assert(_offset_of(command::strconv,in) == 24);
    algo_assert(_offset_of(command::strconv,pathcomp) == 40);
    algo_assert(sizeof(command::strconv) == 144);
}
