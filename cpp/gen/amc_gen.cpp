//
// cpp/gen/amc_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/amc_gen.h"
#include "include/gen/amc_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/amcdb_gen.inl.h"
#include "include/gen/command_gen.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/lib_json_gen.inl.h"
#include "include/gen/lib_prot_gen.h"
#include "include/gen/lib_prot_gen.inl.h"
//#pragma endinclude

// Instantiate all libraries linked into this executable,
// in dependency order
lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
amc::FDb        amc::_db;         // dependency found via dev.targdep

namespace amc {
const char *amc_help =
"amc: Algo Model Compiler: generate code under include/gen and cpp/gen\n"
"Usage: amc [options]\n"
"    -in_dir   string  Root of input ssim dir. default: \"data\"\n"
"    [query]   string  Query mode: generate code for specified object\n"
"    -out_dir  string  Root of output cpp dir. default: \".\"\n"
"    -proto            Print prototype. default: false\n"
"    -report           Final report. default: true\n"
"    -e                Open matching records in editor. default: false\n"
"    -trace    string  Regx of something to trace code generation\n"
"    -verbose          Enable verbose mode\n"
"    -debug            Enable debug mode\n"
"    -version          Show version information\n"
"    -sig              Print SHA1 signatures for dispatches\n"
"    -help             Print this screen and exit\n"
;


const char *amc_syntax =
"-in_dir:string=\"data\"\n"
" [query]:string=\n"
" -out_dir:string=\".\"\n"
" -proto:flag\n"
" -report:flag=true\n"
" -e:flag\n"
" -trace:string=\n"
;
} // namespace amc
amc::_db_bh_enumstr_len_curs::~_db_bh_enumstr_len_curs() {
    amc::lpool_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

amc::enumstr_len_bh_enumstr_curs::~enumstr_len_bh_enumstr_curs() {
    amc::lpool_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

amc::field_bh_bitfld_curs::~field_bh_bitfld_curs() {
    amc::lpool_FreeMem(temp_elems, sizeof(void*) * temp_max);

}

namespace amc { // gen:ns_print_proto
    // Extract next character from STR and advance IDX
    static int           str_Nextchar(const amc::Enumstr& parent, algo::strptr &str, int &idx) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_field_Swap(amc::FField* &elem_a, amc::FField* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_field_Rotleft(amc::FField* &elem_a, amc::FField* &elem_b, amc::FField* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_field_Lt(amc::FField &elem_a, amc::FField &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_field_IntInsertionSort(amc::FField* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_field_IntHeapSort(amc::FField* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_field_IntQuickSort(amc::FField* *elems, int n, int depth) __attribute__((nothrow));
    static bool          fsort_InputMaybe(dmmeta::Fsort &elem) __attribute__((nothrow));
    static bool          dispfilter_InputMaybe(dmmeta::Dispfilter &elem) __attribute__((nothrow));
    static bool          usertracefld_InputMaybe(dmmeta::Usertracefld &elem) __attribute__((nothrow));
    static bool          cfmt_InputMaybe(dmmeta::Cfmt &elem) __attribute__((nothrow));
    static bool          dispatch_InputMaybe(dmmeta::Dispatch &elem) __attribute__((nothrow));
    static bool          dispatch_msg_InputMaybe(dmmeta::DispatchMsg &elem) __attribute__((nothrow));
    static bool          ctype_InputMaybe(dmmeta::Ctype &elem) __attribute__((nothrow));
    static bool          field_InputMaybe(dmmeta::Field &elem) __attribute__((nothrow));
    static bool          basepool_InputMaybe(dmmeta::Basepool &elem) __attribute__((nothrow));
    static bool          llist_InputMaybe(dmmeta::Llist &elem) __attribute__((nothrow));
    static bool          anonfld_InputMaybe(dmmeta::Anonfld &elem) __attribute__((nothrow));
    static bool          xref_InputMaybe(dmmeta::Xref &elem) __attribute__((nothrow));
    static bool          ns_InputMaybe(dmmeta::Ns &elem) __attribute__((nothrow));
    static bool          pnew_InputMaybe(dmmeta::Pnew &elem) __attribute__((nothrow));
    static bool          fldoffset_InputMaybe(dmmeta::Fldoffset &elem) __attribute__((nothrow));
    static bool          typefld_InputMaybe(dmmeta::Typefld &elem) __attribute__((nothrow));
    static bool          lenfld_InputMaybe(dmmeta::Lenfld &elem) __attribute__((nothrow));
    static bool          bltin_InputMaybe(amcdb::Bltin &elem) __attribute__((nothrow));
    static bool          msgtype_InputMaybe(dmmeta::Msgtype &elem) __attribute__((nothrow));
    static bool          gconst_InputMaybe(dmmeta::Gconst &elem) __attribute__((nothrow));
    static bool          gstatic_InputMaybe(dmmeta::Gstatic &elem) __attribute__((nothrow));
    static bool          thash_InputMaybe(dmmeta::Thash &elem) __attribute__((nothrow));
    static bool          func_InputMaybe(dmmeta::Func &elem) __attribute__((nothrow));
    static bool          smallstr_InputMaybe(dmmeta::Smallstr &elem) __attribute__((nothrow));
    static bool          numstr_InputMaybe(dmmeta::Numstr &elem) __attribute__((nothrow));
    static bool          main_InputMaybe(dmmeta::Main &elem) __attribute__((nothrow));
    static void          reftype_LoadStatic() __attribute__((nothrow));
    // Load statically available data into tables, register tables and database.
    static void          InitReflection();
    static bool          cpptype_InputMaybe(dmmeta::Cpptype &elem) __attribute__((nothrow));
    static bool          inlary_InputMaybe(dmmeta::Inlary &elem) __attribute__((nothrow));
    static bool          tary_InputMaybe(dmmeta::Tary &elem) __attribute__((nothrow));
    static bool          cppfunc_InputMaybe(dmmeta::Cppfunc &elem) __attribute__((nothrow));
    static bool          rowid_InputMaybe(dmmeta::Rowid &elem) __attribute__((nothrow));
    static bool          cascdel_InputMaybe(dmmeta::Cascdel &elem) __attribute__((nothrow));
    static bool          substr_InputMaybe(dmmeta::Substr &elem) __attribute__((nothrow));
    static bool          bitfld_InputMaybe(dmmeta::Bitfld &elem) __attribute__((nothrow));
    static bool          ssimfile_InputMaybe(dmmeta::Ssimfile &elem) __attribute__((nothrow));
    static bool          pack_InputMaybe(dmmeta::Pack &elem) __attribute__((nothrow));
    static bool          ptrary_InputMaybe(dmmeta::Ptrary &elem) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_ctype_sorted_Swap(amc::FCtype* &elem_a, amc::FCtype* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_ctype_sorted_Rotleft(amc::FCtype* &elem_a, amc::FCtype* &elem_b, amc::FCtype* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_ctype_sorted_Lt(amc::FCtype &elem_a, amc::FCtype &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_ctype_sorted_IntInsertionSort(amc::FCtype* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_ctype_sorted_IntHeapSort(amc::FCtype* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_ctype_sorted_IntQuickSort(amc::FCtype* *elems, int n, int depth) __attribute__((nothrow));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_enumstr_len_Downheap(amc::FEnumstrLen& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_enumstr_len_Upheap(amc::FEnumstrLen& row, int idx) __attribute__((nothrow));
    static bool          bh_enumstr_len_ElemLt(amc::FEnumstrLen &a, amc::FEnumstrLen &b) __attribute__((nothrow));
    static void          _db_bh_enumstr_len_curs_Add(_db_bh_enumstr_len_curs &curs, amc::FEnumstrLen& row);
    static bool          fbitset_InputMaybe(dmmeta::Fbitset &elem) __attribute__((nothrow));
    static bool          fcleanup_InputMaybe(dmmeta::Fcleanup &elem) __attribute__((nothrow));
    static bool          fdec_InputMaybe(dmmeta::Fdec &elem) __attribute__((nothrow));
    static bool          fconst_InputMaybe(dmmeta::Fconst &elem) __attribute__((nothrow));
    static bool          finput_InputMaybe(dmmeta::Finput &elem) __attribute__((nothrow));
    static bool          foutput_InputMaybe(dmmeta::Foutput &elem) __attribute__((nothrow));
    static bool          fbuf_InputMaybe(dmmeta::Fbuf &elem) __attribute__((nothrow));
    static bool          chash_InputMaybe(dmmeta::Chash &elem) __attribute__((nothrow));
    static bool          ccmp_InputMaybe(dmmeta::Ccmp &elem) __attribute__((nothrow));
    static bool          fbigend_InputMaybe(dmmeta::Fbigend &elem) __attribute__((nothrow));
    static bool          cstr_InputMaybe(dmmeta::Cstr &elem) __attribute__((nothrow));
    static bool          listtype_InputMaybe(dmmeta::Listtype &elem) __attribute__((nothrow));
    static bool          fstep_InputMaybe(dmmeta::Fstep &elem) __attribute__((nothrow));
    static bool          cextern_InputMaybe(dmmeta::Cextern &elem) __attribute__((nothrow));
    static bool          fdelay_InputMaybe(dmmeta::Fdelay &elem) __attribute__((nothrow));
    static bool          disptrace_InputMaybe(dmmeta::Disptrace &elem) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_dispsig_sorted_Swap(amc::FDispsig* &elem_a, amc::FDispsig* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_dispsig_sorted_Rotleft(amc::FDispsig* &elem_a, amc::FDispsig* &elem_b, amc::FDispsig* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_dispsig_sorted_Lt(amc::FDispsig &elem_a, amc::FDispsig &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_dispsig_sorted_IntInsertionSort(amc::FDispsig* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_dispsig_sorted_IntHeapSort(amc::FDispsig* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_dispsig_sorted_IntQuickSort(amc::FDispsig* *elems, int n, int depth) __attribute__((nothrow));
    static bool          target_InputMaybe(dev::Target &elem) __attribute__((nothrow));
    static bool          targdep_InputMaybe(dev::Targdep &elem) __attribute__((nothrow));
    static bool          dispctx_InputMaybe(dmmeta::Dispctx &elem) __attribute__((nothrow));
    static bool          pmaskfld_InputMaybe(dmmeta::Pmaskfld &elem) __attribute__((nothrow));
    static bool          fwddecl_InputMaybe(dmmeta::Fwddecl &elem) __attribute__((nothrow));
    static void          tfunc_LoadStatic() __attribute__((nothrow));
    static void          gen_LoadStatic() __attribute__((nothrow));
    static bool          fregx_InputMaybe(dmmeta::Fregx &elem) __attribute__((nothrow));
    static void          tclass_LoadStatic() __attribute__((nothrow));
    static bool          fcmp_InputMaybe(dmmeta::Fcmp &elem) __attribute__((nothrow));
    static bool          fcast_InputMaybe(dmmeta::Fcast &elem) __attribute__((nothrow));
    static bool          noxref_InputMaybe(dmmeta::Noxref &elem) __attribute__((nothrow));
    static bool          nocascdel_InputMaybe(dmmeta::Nocascdel &elem) __attribute__((nothrow));
    static bool          cafter_InputMaybe(dmmeta::Cafter &elem) __attribute__((nothrow));
    static bool          csize_InputMaybe(dmmeta::Csize &elem) __attribute__((nothrow));
    static bool          nsx_InputMaybe(dmmeta::Nsx &elem) __attribute__((nothrow));
    static bool          fcompact_InputMaybe(dmmeta::Fcompact &elem) __attribute__((nothrow));
    static bool          findrem_InputMaybe(dmmeta::Findrem &elem) __attribute__((nothrow));
    static bool          fcurs_InputMaybe(dmmeta::Fcurs &elem) __attribute__((nothrow));
    static bool          cdflt_InputMaybe(dmmeta::Cdflt &elem) __attribute__((nothrow));
    static bool          argvtype_InputMaybe(dmmeta::Argvtype &elem) __attribute__((nothrow));
    static bool          fcmdline_InputMaybe(dmmeta::Fcmdline &elem) __attribute__((nothrow));
    static bool          floadtuples_InputMaybe(dmmeta::Floadtuples &elem) __attribute__((nothrow));
    static bool          fcmap_InputMaybe(dmmeta::Fcmap &elem) __attribute__((nothrow));
    static bool          nsproto_InputMaybe(dmmeta::Nsproto &elem) __attribute__((nothrow));
    static bool          nsdb_InputMaybe(dmmeta::Nsdb &elem) __attribute__((nothrow));
    static bool          fprefix_InputMaybe(dmmeta::Fprefix &elem) __attribute__((nothrow));
    static bool          ftrace_InputMaybe(dmmeta::Ftrace &elem) __attribute__((nothrow));
    static bool          fnoremove_InputMaybe(dmmeta::Fnoremove &elem) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_substr_field_Swap(amc::FSubstr* &elem_a, amc::FSubstr* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_substr_field_Rotleft(amc::FSubstr* &elem_a, amc::FSubstr* &elem_b, amc::FSubstr* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_substr_field_Lt(amc::FSubstr &elem_a, amc::FSubstr &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_substr_field_IntInsertionSort(amc::FSubstr* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_substr_field_IntHeapSort(amc::FSubstr* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_substr_field_IntQuickSort(amc::FSubstr* *elems, int n, int depth) __attribute__((nothrow));
    // Swap values elem_a and elem_b
    static void          c_ctypelen_Swap(amc::FCtypelen* &elem_a, amc::FCtypelen* &elem_b) __attribute__((nothrow));
    // Left circular shift of three-tuple
    static void          c_ctypelen_Rotleft(amc::FCtypelen* &elem_a, amc::FCtypelen* &elem_b, amc::FCtypelen* &elem_c) __attribute__((nothrow));
    // Compare values elem_a and elem_b
    // The comparison function must be anti-symmetric: if a>b, then !(b>a).
    // If not, mayhem results.
    static bool          c_ctypelen_Lt(amc::FCtypelen &elem_a, amc::FCtypelen &elem_b) __attribute__((nothrow));
    // Internal insertion sort
    static void          c_ctypelen_IntInsertionSort(amc::FCtypelen* *elems, int n) __attribute__((nothrow));
    // Internal heap sort
    static void          c_ctypelen_IntHeapSort(amc::FCtypelen* *elems, int n) __attribute__((nothrow));
    // Quick sort engine
    static void          c_ctypelen_IntQuickSort(amc::FCtypelen* *elems, int n, int depth) __attribute__((nothrow));
    static bool          fbase_InputMaybe(dmmeta::Fbase &elem) __attribute__((nothrow));
    static bool          nossimfile_InputMaybe(dmmeta::Nossimfile &elem) __attribute__((nothrow));
    static bool          gsymbol_InputMaybe(dmmeta::Gsymbol &elem) __attribute__((nothrow));
    static bool          sortfld_InputMaybe(dmmeta::Sortfld &elem) __attribute__((nothrow));
    static bool          cget_InputMaybe(dmmeta::Cget &elem) __attribute__((nothrow));
    static bool          hook_InputMaybe(dmmeta::Hook &elem) __attribute__((nothrow));
    static bool          charset_InputMaybe(dmmeta::Charset &elem) __attribute__((nothrow));
    static bool          nsinclude_InputMaybe(dmmeta::Nsinclude &elem) __attribute__((nothrow));
    static bool          ssimvolatile_InputMaybe(dmmeta::Ssimvolatile &elem) __attribute__((nothrow));
    static bool          funique_InputMaybe(dmmeta::Funique &elem) __attribute__((nothrow));
    static bool          fuserinit_InputMaybe(dmmeta::Fuserinit &elem) __attribute__((nothrow));
    static bool          tcurs_InputMaybe(amcdb::Tcurs &elem) __attribute__((nothrow));
    // find trace by row id (used to implement reflection)
    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
    // Function return 1
    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_enumstr_Downheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_enumstr_Upheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row, int idx) __attribute__((nothrow));
    static bool          bh_enumstr_ElemLt(amc::FEnumstrLen& enumstr_len, amc::FEnumstr &a, amc::FEnumstr &b) __attribute__((nothrow));
    static void          enumstr_len_bh_enumstr_curs_Add(enumstr_len_bh_enumstr_curs &curs, amc::FEnumstr& row);
    // Find new location for ROW starting at IDX
    // NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
    static int           bh_bitfld_Downheap(amc::FField& field, amc::FBitfld& row, int idx) __attribute__((nothrow));
    // Find and return index of new location for element ROW in the heap, starting at index IDX.
    // Move any elements along the way but do not modify ROW.
    static int           bh_bitfld_Upheap(amc::FField& field, amc::FBitfld& row, int idx) __attribute__((nothrow));
    static bool          bh_bitfld_ElemLt(amc::FField& field, amc::FBitfld &a, amc::FBitfld &b) __attribute__((nothrow));
    static void          field_bh_bitfld_curs_Add(field_bh_bitfld_curs &curs, amc::FBitfld& row);
    static void          SizeCheck();
} // gen:ns_print_proto

// --- amc.BltinId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* amc::value_ToCstr(const amc::BltinId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case amc_BltinId_bool              : ret = "bool";  break;
        case amc_BltinId_char              : ret = "char";  break;
        case amc_BltinId_double            : ret = "double";  break;
        case amc_BltinId_float             : ret = "float";  break;
        case amc_BltinId_i16               : ret = "i16";  break;
        case amc_BltinId_i32               : ret = "i32";  break;
        case amc_BltinId_i64               : ret = "i64";  break;
        case amc_BltinId_i8                : ret = "i8";  break;
        case amc_BltinId_pad_byte          : ret = "pad_byte";  break;
        case amc_BltinId_u128              : ret = "u128";  break;
        case amc_BltinId_u16               : ret = "u16";  break;
        case amc_BltinId_u32               : ret = "u32";  break;
        case amc_BltinId_u64               : ret = "u64";  break;
        case amc_BltinId_u8                : ret = "u8";  break;
    }
    return ret;
}

// --- amc.BltinId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void amc::value_Print(const amc::BltinId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- amc.BltinId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool amc::value_SetStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('i','8'): {
                    value_SetEnum(parent,amc_BltinId_i8); ret = true; break;
                }
                case LE_STR2('u','8'): {
                    value_SetEnum(parent,amc_BltinId_u8); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('i','1','6'): {
                    value_SetEnum(parent,amc_BltinId_i16); ret = true; break;
                }
                case LE_STR3('i','3','2'): {
                    value_SetEnum(parent,amc_BltinId_i32); ret = true; break;
                }
                case LE_STR3('i','6','4'): {
                    value_SetEnum(parent,amc_BltinId_i64); ret = true; break;
                }
                case LE_STR3('u','1','6'): {
                    value_SetEnum(parent,amc_BltinId_u16); ret = true; break;
                }
                case LE_STR3('u','3','2'): {
                    value_SetEnum(parent,amc_BltinId_u32); ret = true; break;
                }
                case LE_STR3('u','6','4'): {
                    value_SetEnum(parent,amc_BltinId_u64); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('b','o','o','l'): {
                    value_SetEnum(parent,amc_BltinId_bool); ret = true; break;
                }
                case LE_STR4('c','h','a','r'): {
                    value_SetEnum(parent,amc_BltinId_char); ret = true; break;
                }
                case LE_STR4('u','1','2','8'): {
                    value_SetEnum(parent,amc_BltinId_u128); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('f','l','o','a','t'): {
                    value_SetEnum(parent,amc_BltinId_float); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('d','o','u','b','l','e'): {
                    value_SetEnum(parent,amc_BltinId_double); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('p','a','d','_','b','y','t','e'): {
                    value_SetEnum(parent,amc_BltinId_pad_byte); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- amc.BltinId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void amc::value_SetStrptr(amc::BltinId& parent, algo::strptr rhs, amc_BltinIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- amc.BltinId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool amc::value_ReadStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = u8_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- amc.BltinId..ReadStrptrMaybe
// Read fields of amc::BltinId from an ascii string.
// The format of the string is the format of the amc::BltinId's only field
bool amc::BltinId_ReadStrptrMaybe(amc::BltinId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && amc::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- amc.BltinId..Print
// print string representation of amc::BltinId to string LHS, no header -- cprint:amc.BltinId.String
void amc::BltinId_Print(amc::BltinId row, algo::cstring &str) {
    amc::value_Print(row, str);
}

// --- amc.CppkeywordId.id.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* amc::id_ToCstr(const amc::CppkeywordId& parent) {
    const char *ret = NULL;
    switch(id_GetEnum(parent)) {
        case amc_CppkeywordId_alignas      : ret = "alignas";  break;
        case amc_CppkeywordId_alignof      : ret = "alignof";  break;
        case amc_CppkeywordId_and          : ret = "and";  break;
        case amc_CppkeywordId_and_eq       : ret = "and_eq";  break;
        case amc_CppkeywordId_asm          : ret = "asm";  break;
        case amc_CppkeywordId_auto         : ret = "auto";  break;
        case amc_CppkeywordId_bitand       : ret = "bitand";  break;
        case amc_CppkeywordId_bitor        : ret = "bitor";  break;
        case amc_CppkeywordId_bool         : ret = "bool";  break;
        case amc_CppkeywordId_break        : ret = "break";  break;
        case amc_CppkeywordId_case         : ret = "case";  break;
        case amc_CppkeywordId_catch        : ret = "catch";  break;
        case amc_CppkeywordId_char         : ret = "char";  break;
        case amc_CppkeywordId_char16_t     : ret = "char16_t";  break;
        case amc_CppkeywordId_char32_t     : ret = "char32_t";  break;
        case amc_CppkeywordId_class        : ret = "class";  break;
        case amc_CppkeywordId_compl        : ret = "compl";  break;
        case amc_CppkeywordId_const        : ret = "const";  break;
        case amc_CppkeywordId_constexpr    : ret = "constexpr";  break;
        case amc_CppkeywordId_const_cast   : ret = "const_cast";  break;
        case amc_CppkeywordId_continue     : ret = "continue";  break;
        case amc_CppkeywordId_decltype     : ret = "decltype";  break;
        case amc_CppkeywordId_default      : ret = "default";  break;
        case amc_CppkeywordId_delete       : ret = "delete";  break;
        case amc_CppkeywordId_do           : ret = "do";  break;
        case amc_CppkeywordId_double       : ret = "double";  break;
        case amc_CppkeywordId_dynamic_cast : ret = "dynamic_cast";  break;
        case amc_CppkeywordId_else         : ret = "else";  break;
        case amc_CppkeywordId_enum         : ret = "enum";  break;
        case amc_CppkeywordId_explicit     : ret = "explicit";  break;
        case amc_CppkeywordId_export       : ret = "export";  break;
        case amc_CppkeywordId_extern       : ret = "extern";  break;
        case amc_CppkeywordId_false        : ret = "false";  break;
        case amc_CppkeywordId_float        : ret = "float";  break;
        case amc_CppkeywordId_for          : ret = "for";  break;
        case amc_CppkeywordId_friend       : ret = "friend";  break;
        case amc_CppkeywordId_goto         : ret = "goto";  break;
        case amc_CppkeywordId_if           : ret = "if";  break;
        case amc_CppkeywordId_inline       : ret = "inline";  break;
        case amc_CppkeywordId_int          : ret = "int";  break;
        case amc_CppkeywordId_long         : ret = "long";  break;
        case amc_CppkeywordId_mutable      : ret = "mutable";  break;
        case amc_CppkeywordId_namespace    : ret = "namespace";  break;
        case amc_CppkeywordId_new          : ret = "new";  break;
        case amc_CppkeywordId_noexcept     : ret = "noexcept";  break;
        case amc_CppkeywordId_not          : ret = "not";  break;
        case amc_CppkeywordId_not_eq       : ret = "not_eq";  break;
        case amc_CppkeywordId_nullptr      : ret = "nullptr";  break;
        case amc_CppkeywordId_operator     : ret = "operator";  break;
        case amc_CppkeywordId_or           : ret = "or";  break;
        case amc_CppkeywordId_or_eq        : ret = "or_eq";  break;
        case amc_CppkeywordId_private      : ret = "private";  break;
        case amc_CppkeywordId_protected    : ret = "protected";  break;
        case amc_CppkeywordId_public       : ret = "public";  break;
        case amc_CppkeywordId_register     : ret = "register";  break;
        case amc_CppkeywordId_reinterpret_cast: ret = "reinterpret_cast";  break;
        case amc_CppkeywordId_return       : ret = "return";  break;
        case amc_CppkeywordId_short        : ret = "short";  break;
        case amc_CppkeywordId_signed       : ret = "signed";  break;
        case amc_CppkeywordId_sizeof       : ret = "sizeof";  break;
        case amc_CppkeywordId_static       : ret = "static";  break;
        case amc_CppkeywordId_static_assert: ret = "static_assert";  break;
        case amc_CppkeywordId_static_cast  : ret = "static_cast";  break;
        case amc_CppkeywordId_struct       : ret = "struct";  break;
        case amc_CppkeywordId_switch       : ret = "switch";  break;
        case amc_CppkeywordId_template     : ret = "template";  break;
        case amc_CppkeywordId_this         : ret = "this";  break;
        case amc_CppkeywordId_thread_local : ret = "thread_local";  break;
        case amc_CppkeywordId_throw        : ret = "throw";  break;
        case amc_CppkeywordId_true         : ret = "true";  break;
        case amc_CppkeywordId_try          : ret = "try";  break;
        case amc_CppkeywordId_typedef      : ret = "typedef";  break;
        case amc_CppkeywordId_typeid       : ret = "typeid";  break;
        case amc_CppkeywordId_typename     : ret = "typename";  break;
        case amc_CppkeywordId_union        : ret = "union";  break;
        case amc_CppkeywordId_unsigned     : ret = "unsigned";  break;
        case amc_CppkeywordId_using        : ret = "using";  break;
        case amc_CppkeywordId_virtual      : ret = "virtual";  break;
        case amc_CppkeywordId_void         : ret = "void";  break;
        case amc_CppkeywordId_volatile     : ret = "volatile";  break;
        case amc_CppkeywordId_wchar_t      : ret = "wchar_t";  break;
        case amc_CppkeywordId_while        : ret = "while";  break;
        case amc_CppkeywordId_xor          : ret = "xor";  break;
        case amc_CppkeywordId_xor_eq       : ret = "xor_eq";  break;
    }
    return ret;
}

// --- amc.CppkeywordId.id.Print
// Convert id to a string. First, attempt conversion to a known string.
// If no string matches, print id as a numeric value.
void amc::id_Print(const amc::CppkeywordId& parent, algo::cstring &lhs) {
    const char *strval = id_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.id;
    }
}

// --- amc.CppkeywordId.id.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool amc::id_SetStrptrMaybe(amc::CppkeywordId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('d','o'): {
                    id_SetEnum(parent,amc_CppkeywordId_do); ret = true; break;
                }
                case LE_STR2('i','f'): {
                    id_SetEnum(parent,amc_CppkeywordId_if); ret = true; break;
                }
                case LE_STR2('o','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_or); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('a','n','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_and); ret = true; break;
                }
                case LE_STR3('a','s','m'): {
                    id_SetEnum(parent,amc_CppkeywordId_asm); ret = true; break;
                }
                case LE_STR3('f','o','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_for); ret = true; break;
                }
                case LE_STR3('i','n','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_int); ret = true; break;
                }
                case LE_STR3('n','e','w'): {
                    id_SetEnum(parent,amc_CppkeywordId_new); ret = true; break;
                }
                case LE_STR3('n','o','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_not); ret = true; break;
                }
                case LE_STR3('t','r','y'): {
                    id_SetEnum(parent,amc_CppkeywordId_try); ret = true; break;
                }
                case LE_STR3('x','o','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_xor); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','u','t','o'): {
                    id_SetEnum(parent,amc_CppkeywordId_auto); ret = true; break;
                }
                case LE_STR4('b','o','o','l'): {
                    id_SetEnum(parent,amc_CppkeywordId_bool); ret = true; break;
                }
                case LE_STR4('c','a','s','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_case); ret = true; break;
                }
                case LE_STR4('c','h','a','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_char); ret = true; break;
                }
                case LE_STR4('e','l','s','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_else); ret = true; break;
                }
                case LE_STR4('e','n','u','m'): {
                    id_SetEnum(parent,amc_CppkeywordId_enum); ret = true; break;
                }
                case LE_STR4('g','o','t','o'): {
                    id_SetEnum(parent,amc_CppkeywordId_goto); ret = true; break;
                }
                case LE_STR4('l','o','n','g'): {
                    id_SetEnum(parent,amc_CppkeywordId_long); ret = true; break;
                }
                case LE_STR4('t','h','i','s'): {
                    id_SetEnum(parent,amc_CppkeywordId_this); ret = true; break;
                }
                case LE_STR4('t','r','u','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_true); ret = true; break;
                }
                case LE_STR4('v','o','i','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_void); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('b','i','t','o','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_bitor); ret = true; break;
                }
                case LE_STR5('b','r','e','a','k'): {
                    id_SetEnum(parent,amc_CppkeywordId_break); ret = true; break;
                }
                case LE_STR5('c','a','t','c','h'): {
                    id_SetEnum(parent,amc_CppkeywordId_catch); ret = true; break;
                }
                case LE_STR5('c','l','a','s','s'): {
                    id_SetEnum(parent,amc_CppkeywordId_class); ret = true; break;
                }
                case LE_STR5('c','o','m','p','l'): {
                    id_SetEnum(parent,amc_CppkeywordId_compl); ret = true; break;
                }
                case LE_STR5('c','o','n','s','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_const); ret = true; break;
                }
                case LE_STR5('f','a','l','s','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_false); ret = true; break;
                }
                case LE_STR5('f','l','o','a','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_float); ret = true; break;
                }
                case LE_STR5('o','r','_','e','q'): {
                    id_SetEnum(parent,amc_CppkeywordId_or_eq); ret = true; break;
                }
                case LE_STR5('s','h','o','r','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_short); ret = true; break;
                }
                case LE_STR5('t','h','r','o','w'): {
                    id_SetEnum(parent,amc_CppkeywordId_throw); ret = true; break;
                }
                case LE_STR5('u','n','i','o','n'): {
                    id_SetEnum(parent,amc_CppkeywordId_union); ret = true; break;
                }
                case LE_STR5('u','s','i','n','g'): {
                    id_SetEnum(parent,amc_CppkeywordId_using); ret = true; break;
                }
                case LE_STR5('w','h','i','l','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_while); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','n','d','_','e','q'): {
                    id_SetEnum(parent,amc_CppkeywordId_and_eq); ret = true; break;
                }
                case LE_STR6('b','i','t','a','n','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_bitand); ret = true; break;
                }
                case LE_STR6('d','e','l','e','t','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_delete); ret = true; break;
                }
                case LE_STR6('d','o','u','b','l','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_double); ret = true; break;
                }
                case LE_STR6('e','x','p','o','r','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_export); ret = true; break;
                }
                case LE_STR6('e','x','t','e','r','n'): {
                    id_SetEnum(parent,amc_CppkeywordId_extern); ret = true; break;
                }
                case LE_STR6('f','r','i','e','n','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_friend); ret = true; break;
                }
                case LE_STR6('i','n','l','i','n','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_inline); ret = true; break;
                }
                case LE_STR6('n','o','t','_','e','q'): {
                    id_SetEnum(parent,amc_CppkeywordId_not_eq); ret = true; break;
                }
                case LE_STR6('p','u','b','l','i','c'): {
                    id_SetEnum(parent,amc_CppkeywordId_public); ret = true; break;
                }
                case LE_STR6('r','e','t','u','r','n'): {
                    id_SetEnum(parent,amc_CppkeywordId_return); ret = true; break;
                }
                case LE_STR6('s','i','g','n','e','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_signed); ret = true; break;
                }
                case LE_STR6('s','i','z','e','o','f'): {
                    id_SetEnum(parent,amc_CppkeywordId_sizeof); ret = true; break;
                }
                case LE_STR6('s','t','a','t','i','c'): {
                    id_SetEnum(parent,amc_CppkeywordId_static); ret = true; break;
                }
                case LE_STR6('s','t','r','u','c','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_struct); ret = true; break;
                }
                case LE_STR6('s','w','i','t','c','h'): {
                    id_SetEnum(parent,amc_CppkeywordId_switch); ret = true; break;
                }
                case LE_STR6('t','y','p','e','i','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_typeid); ret = true; break;
                }
                case LE_STR6('x','o','r','_','e','q'): {
                    id_SetEnum(parent,amc_CppkeywordId_xor_eq); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('a','l','i','g','n','a','s'): {
                    id_SetEnum(parent,amc_CppkeywordId_alignas); ret = true; break;
                }
                case LE_STR7('a','l','i','g','n','o','f'): {
                    id_SetEnum(parent,amc_CppkeywordId_alignof); ret = true; break;
                }
                case LE_STR7('d','e','f','a','u','l','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_default); ret = true; break;
                }
                case LE_STR7('m','u','t','a','b','l','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_mutable); ret = true; break;
                }
                case LE_STR7('n','u','l','l','p','t','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_nullptr); ret = true; break;
                }
                case LE_STR7('p','r','i','v','a','t','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_private); ret = true; break;
                }
                case LE_STR7('t','y','p','e','d','e','f'): {
                    id_SetEnum(parent,amc_CppkeywordId_typedef); ret = true; break;
                }
                case LE_STR7('v','i','r','t','u','a','l'): {
                    id_SetEnum(parent,amc_CppkeywordId_virtual); ret = true; break;
                }
                case LE_STR7('w','c','h','a','r','_','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_wchar_t); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','h','a','r','1','6','_','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_char16_t); ret = true; break;
                }
                case LE_STR8('c','h','a','r','3','2','_','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_char32_t); ret = true; break;
                }
                case LE_STR8('c','o','n','t','i','n','u','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_continue); ret = true; break;
                }
                case LE_STR8('d','e','c','l','t','y','p','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_decltype); ret = true; break;
                }
                case LE_STR8('e','x','p','l','i','c','i','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_explicit); ret = true; break;
                }
                case LE_STR8('n','o','e','x','c','e','p','t'): {
                    id_SetEnum(parent,amc_CppkeywordId_noexcept); ret = true; break;
                }
                case LE_STR8('o','p','e','r','a','t','o','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_operator); ret = true; break;
                }
                case LE_STR8('r','e','g','i','s','t','e','r'): {
                    id_SetEnum(parent,amc_CppkeywordId_register); ret = true; break;
                }
                case LE_STR8('t','e','m','p','l','a','t','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_template); ret = true; break;
                }
                case LE_STR8('t','y','p','e','n','a','m','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_typename); ret = true; break;
                }
                case LE_STR8('u','n','s','i','g','n','e','d'): {
                    id_SetEnum(parent,amc_CppkeywordId_unsigned); ret = true; break;
                }
                case LE_STR8('v','o','l','a','t','i','l','e'): {
                    id_SetEnum(parent,amc_CppkeywordId_volatile); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','s','t','e','x','p'): {
                    if (memcmp(rhs.elems+8,"r",1)==0) { id_SetEnum(parent,amc_CppkeywordId_constexpr); ret = true; break; }
                    break;
                }
                case LE_STR8('n','a','m','e','s','p','a','c'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { id_SetEnum(parent,amc_CppkeywordId_namespace); ret = true; break; }
                    break;
                }
                case LE_STR8('p','r','o','t','e','c','t','e'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { id_SetEnum(parent,amc_CppkeywordId_protected); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','n','s','t','_','c','a'): {
                    if (memcmp(rhs.elems+8,"st",2)==0) { id_SetEnum(parent,amc_CppkeywordId_const_cast); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','a','t','i','c','_','c'): {
                    if (memcmp(rhs.elems+8,"ast",3)==0) { id_SetEnum(parent,amc_CppkeywordId_static_cast); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','y','n','a','m','i','c','_'): {
                    if (memcmp(rhs.elems+8,"cast",4)==0) { id_SetEnum(parent,amc_CppkeywordId_dynamic_cast); ret = true; break; }
                    break;
                }
                case LE_STR8('t','h','r','e','a','d','_','l'): {
                    if (memcmp(rhs.elems+8,"ocal",4)==0) { id_SetEnum(parent,amc_CppkeywordId_thread_local); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('s','t','a','t','i','c','_','a'): {
                    if (memcmp(rhs.elems+8,"ssert",5)==0) { id_SetEnum(parent,amc_CppkeywordId_static_assert); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('r','e','i','n','t','e','r','p'): {
                    if (memcmp(rhs.elems+8,"ret_cast",8)==0) { id_SetEnum(parent,amc_CppkeywordId_reinterpret_cast); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- amc.CppkeywordId.id.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void amc::id_SetStrptr(amc::CppkeywordId& parent, algo::strptr rhs, amc_CppkeywordIdEnum dflt) {
    if (!id_SetStrptrMaybe(parent,rhs)) id_SetEnum(parent,dflt);
}

// --- amc.Enumstr.str.Nextchar
// Extract next character from STR and advance IDX
inline static int amc::str_Nextchar(const amc::Enumstr& parent, algo::strptr &str, int &idx) {
    (void)parent;
    int i = idx;
    int ch = str.elems[i];
    i++;
    idx = i;
    return ch;
}

// --- amc.Enumstr..ReadFieldMaybe
bool amc::Enumstr_ReadFieldMaybe(amc::Enumstr &parent, algo::strptr field, algo::strptr strval) {
    amc::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case amc_FieldId_len: retval = i32_ReadStrptrMaybe(parent.len, strval); break;
        case amc_FieldId_str: retval = algo::RnullStr8_ReadStrptrMaybe(parent.str, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- amc.Enumstr..ReadStrptrMaybe
// Read fields of amc::Enumstr from an ascii string.
// The format of the string is an ssim Tuple
bool amc::Enumstr_ReadStrptrMaybe(amc::Enumstr &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "amc.Enumstr");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Enumstr_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- amc.Enumstr..Print
// print string representation of amc::Enumstr to string LHS, no header -- cprint:amc.Enumstr.String
void amc::Enumstr_Print(amc::Enumstr & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "amc.Enumstr";

    i32_Print(row.len, temp);
    PrintAttrSpaceReset(str,"len", temp);

    algo::RnullStr8_Print(row.str, temp);
    PrintAttrSpaceReset(str,"str", temp);
}

// --- amc.FAnonfld.msghdr.CopyIn
// Copy fields in to row
void amc::anonfld_CopyIn(amc::FAnonfld &row, dmmeta::Anonfld &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FAnonfld.msghdr
}

// --- amc.FAnonfld..Uninit
void amc::FAnonfld_Uninit(amc::FAnonfld& anonfld) {
    amc::FAnonfld &row = anonfld; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_anonfld_Remove(*p_field, row);// remove anonfld from index c_anonfld
    }
}

// --- amc.FArgvtype.base.CopyOut
// Copy fields out of row
void amc::argvtype_CopyOut(amc::FArgvtype &row, dmmeta::Argvtype &out) {
    out.ctype = row.ctype;
    out.argvtype = row.argvtype;
    out.comment = row.comment;
}

// --- amc.FArgvtype.base.CopyIn
// Copy fields in to row
void amc::argvtype_CopyIn(amc::FArgvtype &row, dmmeta::Argvtype &in) {
    row.ctype = in.ctype;
    row.argvtype = in.argvtype;
    row.comment = in.comment;
}

// --- amc.FArgvtype..Uninit
void amc::FArgvtype_Uninit(amc::FArgvtype& argvtype) {
    amc::FArgvtype &row = argvtype; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_argvtype_Remove(*p_ctype, row);// remove argvtype from index c_argvtype
    }
}

// --- amc.FBasepool.msghdr.CopyIn
// Copy fields in to row
void amc::basepool_CopyIn(amc::FBasepool &row, dmmeta::Basepool &in) {
    row.field = in.field;
    row.base = in.base;
}

// --- amc.FBasepool..Uninit
void amc::FBasepool_Uninit(amc::FBasepool& basepool) {
    amc::FBasepool &row = basepool; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_basepool_Remove(*p_field, row);// remove basepool from index c_basepool
    }
}

// --- amc.FBitfld.msghdr.CopyIn
// Copy fields in to row
void amc::bitfld_CopyIn(amc::FBitfld &row, dmmeta::Bitfld &in) {
    row.field = in.field;
    row.offset = in.offset;
    row.width = in.width;
    row.srcfield = in.srcfield;
    // comment stripped, see dmmeta.fbase:amc.FBitfld.msghdr
}

// --- amc.FBitfld.name.Get
algo::Smallstr50 amc::name_Get(amc::FBitfld& bitfld) {
    algo::Smallstr50 ret(algo::Pathcomp(bitfld.field, ".RR"));
    return ret;
}

// --- amc.FBitfld..Uninit
void amc::FBitfld_Uninit(amc::FBitfld& bitfld) {
    amc::FBitfld &row = bitfld; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_bitfld_Remove(*p_field, row);// remove bitfld from index c_bitfld
    }
    amc::FField* p_srcfield = amc::ind_field_Find(row.srcfield);
    if (p_srcfield)  {
        bh_bitfld_Remove(*p_srcfield, row);// remove bitfld from index bh_bitfld
    }
}

// --- amc.FBltin.msghdr.CopyIn
// Copy fields in to row
void amc::bltin_CopyIn(amc::FBltin &row, amcdb::Bltin &in) {
    row.ctype = in.ctype;
    row.likeu64 = in.likeu64;
    row.bigendok = in.bigendok;
    row.issigned = in.issigned;
    // comment stripped, see dmmeta.fbase:amc.FBltin.msghdr
}

// --- amc.FBltin..Uninit
void amc::FBltin_Uninit(amc::FBltin& bltin) {
    amc::FBltin &row = bltin; (void)row;
    ind_bltin_Remove(row); // remove bltin from index ind_bltin
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_bltin_Remove(*p_ctype, row);// remove bltin from index c_bltin
    }
}

// --- amc.FCafter.msghdr.CopyIn
// Copy fields in to row
void amc::cafter_CopyIn(amc::FCafter &row, dmmeta::Cafter &in) {
    row.cafter = in.cafter;
    // comment stripped, see dmmeta.fbase:amc.FCafter.msghdr
}

// --- amc.FCafter.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FCafter& cafter) {
    algo::Smallstr50 ret(algo::Pathcomp(cafter.cafter, "/RL"));
    return ret;
}

// --- amc.FCafter.after.Get
algo::Smallstr50 amc::after_Get(amc::FCafter& cafter) {
    algo::Smallstr50 ret(algo::Pathcomp(cafter.cafter, "/RR"));
    return ret;
}

// --- amc.FCafter..Uninit
void amc::FCafter_Uninit(amc::FCafter& cafter) {
    amc::FCafter &row = cafter; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        zd_cafter_Remove(*p_ctype, row);// remove cafter from index zd_cafter
    }
}

// --- amc.FCascdel.msghdr.CopyIn
// Copy fields in to row
void amc::cascdel_CopyIn(amc::FCascdel &row, dmmeta::Cascdel &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FCascdel.msghdr
}

// --- amc.FCascdel..Uninit
void amc::FCascdel_Uninit(amc::FCascdel& cascdel) {
    amc::FCascdel &row = cascdel; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_cascdel_Remove(*p_field, row);// remove cascdel from index c_cascdel
    }
}

// --- amc.FCcmp.msghdr.CopyIn
// Copy fields in to row
void amc::ccmp_CopyIn(amc::FCcmp &row, dmmeta::Ccmp &in) {
    row.ctype = in.ctype;
    row.extrn = in.extrn;
    row.genop = in.genop;
    row.order = in.order;
    row.minmax = in.minmax;
    // comment stripped, see dmmeta.fbase:amc.FCcmp.msghdr
}

// --- amc.FCcmp..Uninit
void amc::FCcmp_Uninit(amc::FCcmp& ccmp) {
    amc::FCcmp &row = ccmp; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ccmp_Remove(*p_ctype, row);// remove ccmp from index c_ccmp
    }
    ind_ccmp_Remove(row); // remove ccmp from index ind_ccmp
}

// --- amc.FCdflt.base.CopyOut
// Copy fields out of row
void amc::cdflt_CopyOut(amc::FCdflt &row, dmmeta::Cdflt &out) {
    out.ctype = row.ctype;
    out.dflt = row.dflt;
    out.cppdflt = row.cppdflt;
    out.ssimdflt = row.ssimdflt;
    out.comment = row.comment;
}

// --- amc.FCdflt.base.CopyIn
// Copy fields in to row
void amc::cdflt_CopyIn(amc::FCdflt &row, dmmeta::Cdflt &in) {
    row.ctype = in.ctype;
    row.dflt = in.dflt;
    row.cppdflt = in.cppdflt;
    row.ssimdflt = in.ssimdflt;
    row.comment = in.comment;
}

// --- amc.FCdflt..Uninit
void amc::FCdflt_Uninit(amc::FCdflt& cdflt) {
    amc::FCdflt &row = cdflt; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cdflt_Remove(*p_ctype, row);// remove cdflt from index c_cdflt
    }
}

// --- amc.FCextern.msghdr.CopyIn
// Copy fields in to row
void amc::cextern_CopyIn(amc::FCextern &row, dmmeta::Cextern &in) {
    row.ctype = in.ctype;
    row.initmemset = in.initmemset;
    row.isstruct = in.isstruct;
}

// --- amc.FCextern..Uninit
void amc::FCextern_Uninit(amc::FCextern& cextern) {
    amc::FCextern &row = cextern; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cextern_Remove(*p_ctype, row);// remove cextern from index c_cextern
    }
}

// --- amc.FCfmt.msghdr.CopyIn
// Copy fields in to row
void amc::cfmt_CopyIn(amc::FCfmt &row, dmmeta::Cfmt &in) {
    row.cfmt = in.cfmt;
    row.printfmt = in.printfmt;
    row.read = in.read;
    row.print = in.print;
    row.sep = in.sep;
    row.genop = in.genop;
    // comment stripped, see dmmeta.fbase:amc.FCfmt.msghdr
}

// --- amc.FCfmt.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FCfmt& cfmt) {
    algo::Smallstr50 ret(algo::Pathcomp(cfmt.cfmt, ".RL"));
    return ret;
}

// --- amc.FCfmt.strfmt.Get
algo::Smallstr50 amc::strfmt_Get(amc::FCfmt& cfmt) {
    algo::Smallstr50 ret(algo::Pathcomp(cfmt.cfmt, ".RR"));
    return ret;
}

// --- amc.FCfmt..Uninit
void amc::FCfmt_Uninit(amc::FCfmt& cfmt) {
    amc::FCfmt &row = cfmt; (void)row;
    ind_cfmt_Remove(row); // remove cfmt from index ind_cfmt
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        zs_cfmt_Remove(*p_ctype, row);// remove cfmt from index zs_cfmt
    }
}

// --- amc.FCget.base.CopyOut
// Copy fields out of row
void amc::cget_CopyOut(amc::FCget &row, dmmeta::Cget &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- amc.FCget.base.CopyIn
// Copy fields in to row
void amc::cget_CopyIn(amc::FCget &row, dmmeta::Cget &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- amc.FCharset.base.CopyOut
// Copy fields out of row
void amc::charset_CopyOut(amc::FCharset &row, dmmeta::Charset &out) {
    out.field = row.field;
    out.expr = row.expr;
    out.charrange = row.charrange;
    out.calc = row.calc;
    out.comment = row.comment;
}

// --- amc.FCharset.base.CopyIn
// Copy fields in to row
void amc::charset_CopyIn(amc::FCharset &row, dmmeta::Charset &in) {
    row.field = in.field;
    row.expr = in.expr;
    row.charrange = in.charrange;
    row.calc = in.calc;
    row.comment = in.comment;
}

// --- amc.FCharset..Uninit
void amc::FCharset_Uninit(amc::FCharset& charset) {
    amc::FCharset &row = charset; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_charset_Remove(*p_field, row);// remove charset from index c_charset
    }
}

// --- amc.FChash.msghdr.CopyIn
// Copy fields in to row
void amc::chash_CopyIn(amc::FChash &row, dmmeta::Chash &in) {
    row.ctype = in.ctype;
    row.hashtype = in.hashtype;
    // comment stripped, see dmmeta.fbase:amc.FChash.msghdr
}

// --- amc.FChash..Uninit
void amc::FChash_Uninit(amc::FChash& chash) {
    amc::FChash &row = chash; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_chash_Remove(*p_ctype, row);// remove chash from index c_chash
    }
    ind_chash_Remove(row); // remove chash from index ind_chash
}

// --- amc.FCppfunc.msghdr.CopyOut
// Copy fields out of row
void amc::cppfunc_CopyOut(amc::FCppfunc &row, dmmeta::Cppfunc &out) {
    out.field = row.field;
    out.expr = row.expr;
}

// --- amc.FCppfunc.msghdr.CopyIn
// Copy fields in to row
void amc::cppfunc_CopyIn(amc::FCppfunc &row, dmmeta::Cppfunc &in) {
    row.field = in.field;
    row.expr = in.expr;
}

// --- amc.FCppfunc..Uninit
void amc::FCppfunc_Uninit(amc::FCppfunc& cppfunc) {
    amc::FCppfunc &row = cppfunc; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_cppfunc_Remove(*p_field, row);// remove cppfunc from index c_cppfunc
    }
}

// --- amc.FCpptype.msghdr.CopyIn
// Copy fields in to row
void amc::cpptype_CopyIn(amc::FCpptype &row, dmmeta::Cpptype &in) {
    row.ctype = in.ctype;
    row.ctor = in.ctor;
    row.dtor = in.dtor;
    row.cheap_copy = in.cheap_copy;
}

// --- amc.FCpptype..Uninit
void amc::FCpptype_Uninit(amc::FCpptype& cpptype) {
    amc::FCpptype &row = cpptype; (void)row;
    ind_cpptype_Remove(row); // remove cpptype from index ind_cpptype
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cpptype_Remove(*p_ctype, row);// remove cpptype from index c_cpptype
    }
}

// --- amc.FCsize.msghdr.CopyIn
// Copy fields in to row
void amc::csize_CopyIn(amc::FCsize &row, dmmeta::Csize &in) {
    row.ctype = in.ctype;
    row.size = in.size;
    row.alignment = in.alignment;
    // comment stripped, see dmmeta.fbase:amc.FCsize.msghdr
}

// --- amc.FCsize..Uninit
void amc::FCsize_Uninit(amc::FCsize& csize) {
    amc::FCsize &row = csize; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_csize_Remove(*p_ctype, row);// remove csize from index c_csize
    }
}

// --- amc.FCstr.msghdr.CopyIn
// Copy fields in to row
void amc::cstr_CopyIn(amc::FCstr &row, dmmeta::Cstr &in) {
    row.ctype = in.ctype;
    row.strequiv = in.strequiv;
    // comment stripped, see dmmeta.fbase:amc.FCstr.msghdr
}

// --- amc.FCstr..Uninit
void amc::FCstr_Uninit(amc::FCstr& cstr) {
    amc::FCstr &row = cstr; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_cstr_Remove(*p_ctype, row);// remove cstr from index c_cstr
    }
}

// --- amc.FCtype.msghdr.CopyOut
// Copy fields out of row
void amc::ctype_CopyOut(amc::FCtype &row, dmmeta::Ctype &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- amc.FCtype.msghdr.CopyIn
// Copy fields in to row
void amc::ctype_CopyIn(amc::FCtype &row, dmmeta::Ctype &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- amc.FCtype.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FCtype& ctype) {
    algo::Smallstr16 ret(algo::Pathcomp(ctype.ctype, ".RL"));
    return ret;
}

// --- amc.FCtype.name.Get
algo::Smallstr50 amc::name_Get(amc::FCtype& ctype) {
    algo::Smallstr50 ret(algo::Pathcomp(ctype.ctype, ".RR"));
    return ret;
}

// --- amc.FCtype.zs_cfmt.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_cfmt_Insert(amc::FCtype& ctype, amc::FCfmt& row) {
    if (!zs_cfmt_InLlistQ(row)) {
        amc::FCfmt* old_tail       = ctype.zs_cfmt_tail;
        row.zs_cfmt_next  = NULL;
        ctype.zs_cfmt_tail = &row;
        amc::FCfmt **new_row_a = &old_tail->zs_cfmt_next;
        amc::FCfmt **new_row_b = &ctype.zs_cfmt_head;
        amc::FCfmt **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FCtype.zs_cfmt.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_cfmt_Remove(amc::FCtype& ctype, amc::FCfmt& row) {
    if (zs_cfmt_InLlistQ(row)) {
        amc::FCfmt* old_head       = ctype.zs_cfmt_head;
        (void)old_head; // in case it's not used
        amc::FCfmt* prev=NULL;
        amc::FCfmt* cur     = ctype.zs_cfmt_head;
        while (cur) {  // search for element by pointer
            amc::FCfmt* next = cur->zs_cfmt_next;
            if (cur == &row) {

                if (!next) {
                    ctype.zs_cfmt_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_cfmt_next = next;
                } else {
                    ctype.zs_cfmt_head = next;
                }
                row.zs_cfmt_next = (amc::FCfmt*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FCtype.zs_cfmt.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_cfmt_RemoveAll(amc::FCtype& ctype) {
    amc::FCfmt* row = ctype.zs_cfmt_head;
    ctype.zs_cfmt_head = NULL;
    ctype.zs_cfmt_tail = NULL;
    while (row) {
        amc::FCfmt* row_next = row->zs_cfmt_next;
        row->zs_cfmt_next  = (amc::FCfmt*)-1;
        row = row_next;
    }
}

// --- amc.FCtype.zs_cfmt.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCfmt* amc::zs_cfmt_RemoveFirst(amc::FCtype& ctype) {
    amc::FCfmt *row = NULL;
    row = ctype.zs_cfmt_head;
    if (row) {
        amc::FCfmt *next = row->zs_cfmt_next;
        ctype.zs_cfmt_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            ctype.zs_cfmt_tail = NULL;
        }
        row->zs_cfmt_next = (amc::FCfmt*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FCtype.c_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_field_Insert(amc::FCtype& ctype, amc::FField& row) {
    // reserve space
    c_field_Reserve(ctype, 1);
    u32 n  = ctype.c_field_n;
    u32 at = n;
    amc::FField* *elems = ctype.c_field_elems;
    elems[at] = &row;
    ctype.c_field_n = n+1;

}

// --- amc.FCtype.c_field.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_field_ScanInsertMaybe(amc::FCtype& ctype, amc::FField& row) {
    bool retval = true;
    u32 n  = ctype.c_field_n;
    for (u32 i = 0; i < n; i++) {
        if (ctype.c_field_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_field_Reserve(ctype, 1);
        ctype.c_field_elems[n] = &row;
        ctype.c_field_n = n+1;
    }
    return retval;
}

// --- amc.FCtype.c_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_field_Remove(amc::FCtype& ctype, amc::FField& row) {
    int lim = ctype.c_field_n;
    amc::FField* *elems = ctype.c_field_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FField* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FField*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ctype.c_field_n = lim - 1;
            break;
        }
    }
}

// --- amc.FCtype.c_field.Reserve
// Reserve space in index for N more elements;
void amc::c_field_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_field_max;
    if (UNLIKELY(ctype.c_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FField*);
        u32 new_size = new_max * sizeof(amc::FField*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_field");
        }
        ctype.c_field_elems = (amc::FField**)new_mem;
        ctype.c_field_max = new_max;
    }
}

// --- amc.FCtype.c_field.Swap
// Swap values elem_a and elem_b
inline static void amc::c_field_Swap(amc::FField* &elem_a, amc::FField* &elem_b) {
    amc::FField *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- amc.FCtype.c_field.Rotleft
// Left circular shift of three-tuple
inline static void amc::c_field_Rotleft(amc::FField* &elem_a, amc::FField* &elem_b, amc::FField* &elem_c) {
    amc::FField *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- amc.FCtype.c_field.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool amc::c_field_Lt(amc::FField &elem_a, amc::FField &elem_b) {
    bool ret;
    ret = elem_a.rowid < elem_b.rowid;
    return ret;
}

// --- amc.FCtype.c_field.SortedQ
// Verify whether array is sorted
bool amc::c_field_SortedQ(amc::FCtype& ctype) {
    amc::FField* *elems = c_field_Getary(ctype).elems;
    int n = c_field_N(ctype);
    for (int i = 1; i < n; i++) {
        if (c_field_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- amc.FCtype.c_field.IntInsertionSort
// Internal insertion sort
static void amc::c_field_IntInsertionSort(amc::FField* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        amc::FField *tmp = elems[i];
        // shift elements up by one
        if (c_field_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_field_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- amc.FCtype.c_field.IntHeapSort
// Internal heap sort
static void amc::c_field_IntHeapSort(amc::FField* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_field_Lt(*elems[j], *elems[k])) {
            c_field_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_field_Lt(*elems[l], *elems[l+1]);
            if (c_field_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_field_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_field_Swap(elems[i],elems[k]);
        }
    }
}

// --- amc.FCtype.c_field.IntQuickSort
// Quick sort engine
static void amc::c_field_IntQuickSort(amc::FField* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_field_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_field_Lt(*elems[pp], *elems[pi])) {
            c_field_Swap(elems[pi], elems[pp]);
        }
        if (c_field_Lt(*elems[pj], *elems[pp])) {
            if (c_field_Lt(*elems[pj], *elems[pi])) {
                c_field_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_field_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_field_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        amc::FField *pivot = elems[pj];
        for(;;){
            while (c_field_Lt(*elems[++pi], *pivot)) {
            }
            while (c_field_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_field_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_field_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_field_IntInsertionSort(elems,n);
}

// --- amc.FCtype.c_field.InsertionSort
// Insertion sort
void amc::c_field_InsertionSort(amc::FCtype& ctype) {
    amc::FField* *elems = c_field_Getary(ctype).elems;
    int n = c_field_N(ctype);
    c_field_IntInsertionSort(elems, n);
}

// --- amc.FCtype.c_field.HeapSort
// Heap sort
void amc::c_field_HeapSort(amc::FCtype& ctype) {
    amc::FField* *elems = c_field_Getary(ctype).elems;
    int n = c_field_N(ctype);
    c_field_IntHeapSort(elems, n);
}

// --- amc.FCtype.c_field.QuickSort
// Quick sort
void amc::c_field_QuickSort(amc::FCtype& ctype) {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_field_N(ctype) + 1)) + 3;
    amc::FField* *elems = c_field_Getary(ctype).elems;
    int n = c_field_N(ctype);
    c_field_IntQuickSort(elems, n, max_depth);
}

// --- amc.FCtype.c_static.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_static_Insert(amc::FCtype& ctype, amc::FStatictuple& row) {
    if (bool_Update(row.ctype_c_static_in_ary,true)) {
        // reserve space
        c_static_Reserve(ctype, 1);
        u32 n  = ctype.c_static_n;
        u32 at = n;
        amc::FStatictuple* *elems = ctype.c_static_elems;
        elems[at] = &row;
        ctype.c_static_n = n+1;

    }
}

// --- amc.FCtype.c_static.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_static_InsertMaybe(amc::FCtype& ctype, amc::FStatictuple& row) {
    bool retval = !row.ctype_c_static_in_ary;
    c_static_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FCtype.c_static.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_static_Remove(amc::FCtype& ctype, amc::FStatictuple& row) {
    if (bool_Update(row.ctype_c_static_in_ary,false)) {
        int lim = ctype.c_static_n;
        amc::FStatictuple* *elems = ctype.c_static_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FStatictuple* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FStatictuple*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_static_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FCtype.c_static.Reserve
// Reserve space in index for N more elements;
void amc::c_static_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_static_max;
    if (UNLIKELY(ctype.c_static_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FStatictuple*);
        u32 new_size = new_max * sizeof(amc::FStatictuple*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_static_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_static");
        }
        ctype.c_static_elems = (amc::FStatictuple**)new_mem;
        ctype.c_static_max = new_max;
    }
}

// --- amc.FCtype.c_parent.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_parent_Insert(amc::FCtype& ctype, amc::FCtype& row) {
    // reserve space
    c_parent_Reserve(ctype, 1);
    u32 n  = ctype.c_parent_n;
    u32 at = n;
    amc::FCtype* *elems = ctype.c_parent_elems;
    elems[at] = &row;
    ctype.c_parent_n = n+1;

}

// --- amc.FCtype.c_parent.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_parent_ScanInsertMaybe(amc::FCtype& ctype, amc::FCtype& row) {
    bool retval = true;
    u32 n  = ctype.c_parent_n;
    for (u32 i = 0; i < n; i++) {
        if (ctype.c_parent_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_parent_Reserve(ctype, 1);
        ctype.c_parent_elems[n] = &row;
        ctype.c_parent_n = n+1;
    }
    return retval;
}

// --- amc.FCtype.c_parent.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_parent_Remove(amc::FCtype& ctype, amc::FCtype& row) {
    int lim = ctype.c_parent_n;
    amc::FCtype* *elems = ctype.c_parent_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FCtype* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FCtype*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ctype.c_parent_n = lim - 1;
            break;
        }
    }
}

// --- amc.FCtype.c_parent.Reserve
// Reserve space in index for N more elements;
void amc::c_parent_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_parent_max;
    if (UNLIKELY(ctype.c_parent_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FCtype*);
        u32 new_size = new_max * sizeof(amc::FCtype*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_parent_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_parent");
        }
        ctype.c_parent_elems = (amc::FCtype**)new_mem;
        ctype.c_parent_max = new_max;
    }
}

// --- amc.FCtype.c_datafld.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_datafld_Insert(amc::FCtype& ctype, amc::FField& row) {
    if (bool_Update(row.ctype_c_datafld_in_ary,true)) {
        // reserve space
        c_datafld_Reserve(ctype, 1);
        u32 n  = ctype.c_datafld_n;
        u32 at = n;
        amc::FField* *elems = ctype.c_datafld_elems;
        elems[at] = &row;
        ctype.c_datafld_n = n+1;

    }
}

// --- amc.FCtype.c_datafld.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_datafld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) {
    bool retval = !row.ctype_c_datafld_in_ary;
    c_datafld_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FCtype.c_datafld.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_datafld_Remove(amc::FCtype& ctype, amc::FField& row) {
    if (bool_Update(row.ctype_c_datafld_in_ary,false)) {
        int lim = ctype.c_datafld_n;
        amc::FField* *elems = ctype.c_datafld_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_datafld_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FCtype.c_datafld.Reserve
// Reserve space in index for N more elements;
void amc::c_datafld_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_datafld_max;
    if (UNLIKELY(ctype.c_datafld_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FField*);
        u32 new_size = new_max * sizeof(amc::FField*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_datafld_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_datafld");
        }
        ctype.c_datafld_elems = (amc::FField**)new_mem;
        ctype.c_datafld_max = new_max;
    }
}

// --- amc.FCtype.zd_inst.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zd_inst_Insert(amc::FCtype& ctype, amc::FField& row) {
    if (!zd_inst_InLlistQ(row)) {
        amc::FField* old_tail = ctype.zd_inst_tail;
        row.zd_inst_next = NULL;
        row.zd_inst_prev = old_tail;
        ctype.zd_inst_tail = &row;
        amc::FField **new_row_a = &old_tail->zd_inst_next;
        amc::FField **new_row_b = &ctype.zd_inst_head;
        amc::FField **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ctype.zd_inst_n++;
    }
}

// --- amc.FCtype.zd_inst.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::zd_inst_Remove(amc::FCtype& ctype, amc::FField& row) {
    if (zd_inst_InLlistQ(row)) {
        amc::FField* old_head       = ctype.zd_inst_head;
        (void)old_head; // in case it's not used
        amc::FField* prev = row.zd_inst_prev;
        amc::FField* next = row.zd_inst_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        amc::FField **new_next_a = &prev->zd_inst_next;
        amc::FField **new_next_b = &ctype.zd_inst_head;
        amc::FField **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        amc::FField **new_prev_a = &next->zd_inst_prev;
        amc::FField **new_prev_b = &ctype.zd_inst_tail;
        amc::FField **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        ctype.zd_inst_n--;
        row.zd_inst_next=(amc::FField*)-1; // not-in-list
    }
}

// --- amc.FCtype.zd_inst.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zd_inst_RemoveAll(amc::FCtype& ctype) {
    amc::FField* row = ctype.zd_inst_head;
    ctype.zd_inst_head = NULL;
    ctype.zd_inst_tail = NULL;
    ctype.zd_inst_n = 0;
    while (row) {
        amc::FField* row_next = row->zd_inst_next;
        row->zd_inst_next  = (amc::FField*)-1;
        row->zd_inst_prev  = NULL;
        row = row_next;
    }
}

// --- amc.FCtype.zd_inst.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField* amc::zd_inst_RemoveFirst(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_inst_head;
    if (row) {
        amc::FField *next = row->zd_inst_next;
        ctype.zd_inst_head = next;
        amc::FField **new_end_a = &next->zd_inst_prev;
        amc::FField **new_end_b = &ctype.zd_inst_tail;
        amc::FField **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        ctype.zd_inst_n--;
        row->zd_inst_next = (amc::FField*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FCtype.zs_xref.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_xref_Insert(amc::FCtype& ctype, amc::FXref& row) {
    if (!zs_xref_InLlistQ(row)) {
        amc::FXref* old_tail       = ctype.zs_xref_tail;
        row.zs_xref_next  = NULL;
        ctype.zs_xref_tail = &row;
        amc::FXref **new_row_a = &old_tail->zs_xref_next;
        amc::FXref **new_row_b = &ctype.zs_xref_head;
        amc::FXref **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ctype.zs_xref_n++;
    }
}

// --- amc.FCtype.zs_xref.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_xref_Remove(amc::FCtype& ctype, amc::FXref& row) {
    if (zs_xref_InLlistQ(row)) {
        amc::FXref* old_head       = ctype.zs_xref_head;
        (void)old_head; // in case it's not used
        amc::FXref* prev=NULL;
        amc::FXref* cur     = ctype.zs_xref_head;
        while (cur) {  // search for element by pointer
            amc::FXref* next = cur->zs_xref_next;
            if (cur == &row) {
                ctype.zs_xref_n--;  // adjust count

                if (!next) {
                    ctype.zs_xref_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_xref_next = next;
                } else {
                    ctype.zs_xref_head = next;
                }
                row.zs_xref_next = (amc::FXref*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FCtype.zs_xref.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_xref_RemoveAll(amc::FCtype& ctype) {
    amc::FXref* row = ctype.zs_xref_head;
    ctype.zs_xref_head = NULL;
    ctype.zs_xref_tail = NULL;
    ctype.zs_xref_n = 0;
    while (row) {
        amc::FXref* row_next = row->zs_xref_next;
        row->zs_xref_next  = (amc::FXref*)-1;
        row = row_next;
    }
}

// --- amc.FCtype.zs_xref.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FXref* amc::zs_xref_RemoveFirst(amc::FCtype& ctype) {
    amc::FXref *row = NULL;
    row = ctype.zs_xref_head;
    if (row) {
        amc::FXref *next = row->zs_xref_next;
        ctype.zs_xref_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            ctype.zs_xref_tail = NULL;
        }
        ctype.zs_xref_n--;
        row->zs_xref_next = (amc::FXref*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FCtype.c_ffunc.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ffunc_Insert(amc::FCtype& ctype, amc::FFunc& row) {
    // reserve space
    c_ffunc_Reserve(ctype, 1);
    u32 n  = ctype.c_ffunc_n;
    u32 at = n;
    amc::FFunc* *elems = ctype.c_ffunc_elems;
    elems[at] = &row;
    ctype.c_ffunc_n = n+1;

}

// --- amc.FCtype.c_ffunc.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_ffunc_ScanInsertMaybe(amc::FCtype& ctype, amc::FFunc& row) {
    bool retval = true;
    u32 n  = ctype.c_ffunc_n;
    for (u32 i = 0; i < n; i++) {
        if (ctype.c_ffunc_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ffunc_Reserve(ctype, 1);
        ctype.c_ffunc_elems[n] = &row;
        ctype.c_ffunc_n = n+1;
    }
    return retval;
}

// --- amc.FCtype.c_ffunc.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ffunc_Remove(amc::FCtype& ctype, amc::FFunc& row) {
    int lim = ctype.c_ffunc_n;
    amc::FFunc* *elems = ctype.c_ffunc_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FFunc* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FFunc*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ctype.c_ffunc_n = lim - 1;
            break;
        }
    }
}

// --- amc.FCtype.c_ffunc.Reserve
// Reserve space in index for N more elements;
void amc::c_ffunc_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_ffunc_max;
    if (UNLIKELY(ctype.c_ffunc_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFunc*);
        u32 new_size = new_max * sizeof(amc::FFunc*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_ffunc_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_ffunc");
        }
        ctype.c_ffunc_elems = (amc::FFunc**)new_mem;
        ctype.c_ffunc_max = new_max;
    }
}

// --- amc.FCtype.zd_cafter.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zd_cafter_Insert(amc::FCtype& ctype, amc::FCafter& row) {
    if (!zd_cafter_InLlistQ(row)) {
        amc::FCafter* old_tail = ctype.zd_cafter_tail;
        row.zd_cafter_next = NULL;
        row.zd_cafter_prev = old_tail;
        ctype.zd_cafter_tail = &row;
        amc::FCafter **new_row_a = &old_tail->zd_cafter_next;
        amc::FCafter **new_row_b = &ctype.zd_cafter_head;
        amc::FCafter **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ctype.zd_cafter_n++;
    }
}

// --- amc.FCtype.zd_cafter.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::zd_cafter_Remove(amc::FCtype& ctype, amc::FCafter& row) {
    if (zd_cafter_InLlistQ(row)) {
        amc::FCafter* old_head       = ctype.zd_cafter_head;
        (void)old_head; // in case it's not used
        amc::FCafter* prev = row.zd_cafter_prev;
        amc::FCafter* next = row.zd_cafter_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        amc::FCafter **new_next_a = &prev->zd_cafter_next;
        amc::FCafter **new_next_b = &ctype.zd_cafter_head;
        amc::FCafter **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        amc::FCafter **new_prev_a = &next->zd_cafter_prev;
        amc::FCafter **new_prev_b = &ctype.zd_cafter_tail;
        amc::FCafter **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        ctype.zd_cafter_n--;
        row.zd_cafter_next=(amc::FCafter*)-1; // not-in-list
    }
}

// --- amc.FCtype.zd_cafter.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zd_cafter_RemoveAll(amc::FCtype& ctype) {
    amc::FCafter* row = ctype.zd_cafter_head;
    ctype.zd_cafter_head = NULL;
    ctype.zd_cafter_tail = NULL;
    ctype.zd_cafter_n = 0;
    while (row) {
        amc::FCafter* row_next = row->zd_cafter_next;
        row->zd_cafter_next  = (amc::FCafter*)-1;
        row->zd_cafter_prev  = NULL;
        row = row_next;
    }
}

// --- amc.FCtype.zd_cafter.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCafter* amc::zd_cafter_RemoveFirst(amc::FCtype& ctype) {
    amc::FCafter *row = NULL;
    row = ctype.zd_cafter_head;
    if (row) {
        amc::FCafter *next = row->zd_cafter_next;
        ctype.zd_cafter_head = next;
        amc::FCafter **new_end_a = &next->zd_cafter_prev;
        amc::FCafter **new_end_b = &ctype.zd_cafter_tail;
        amc::FCafter **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        ctype.zd_cafter_n--;
        row->zd_cafter_next = (amc::FCafter*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FCtype.zd_access.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zd_access_Insert(amc::FCtype& ctype, amc::FField& row) {
    if (!zd_access_InLlistQ(row)) {
        amc::FField* old_tail = ctype.zd_access_tail;
        row.zd_access_next = NULL;
        row.zd_access_prev = old_tail;
        ctype.zd_access_tail = &row;
        amc::FField **new_row_a = &old_tail->zd_access_next;
        amc::FField **new_row_b = &ctype.zd_access_head;
        amc::FField **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        ctype.zd_access_n++;
    }
}

// --- amc.FCtype.zd_access.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::zd_access_Remove(amc::FCtype& ctype, amc::FField& row) {
    if (zd_access_InLlistQ(row)) {
        amc::FField* old_head       = ctype.zd_access_head;
        (void)old_head; // in case it's not used
        amc::FField* prev = row.zd_access_prev;
        amc::FField* next = row.zd_access_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        amc::FField **new_next_a = &prev->zd_access_next;
        amc::FField **new_next_b = &ctype.zd_access_head;
        amc::FField **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        amc::FField **new_prev_a = &next->zd_access_prev;
        amc::FField **new_prev_b = &ctype.zd_access_tail;
        amc::FField **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        ctype.zd_access_n--;
        row.zd_access_next=(amc::FField*)-1; // not-in-list
    }
}

// --- amc.FCtype.zd_access.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zd_access_RemoveAll(amc::FCtype& ctype) {
    amc::FField* row = ctype.zd_access_head;
    ctype.zd_access_head = NULL;
    ctype.zd_access_tail = NULL;
    ctype.zd_access_n = 0;
    while (row) {
        amc::FField* row_next = row->zd_access_next;
        row->zd_access_next  = (amc::FField*)-1;
        row->zd_access_prev  = NULL;
        row = row_next;
    }
}

// --- amc.FCtype.zd_access.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField* amc::zd_access_RemoveFirst(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_access_head;
    if (row) {
        amc::FField *next = row->zd_access_next;
        ctype.zd_access_head = next;
        amc::FField **new_end_a = &next->zd_access_prev;
        amc::FField **new_end_b = &ctype.zd_access_tail;
        amc::FField **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        ctype.zd_access_n--;
        row->zd_access_next = (amc::FField*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FCtype.c_fcurs.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_fcurs_Insert(amc::FCtype& ctype, amc::FFcurs& row) {
    if (bool_Update(row.ctype_c_fcurs_in_ary,true)) {
        // reserve space
        c_fcurs_Reserve(ctype, 1);
        u32 n  = ctype.c_fcurs_n;
        u32 at = n;
        amc::FFcurs* *elems = ctype.c_fcurs_elems;
        elems[at] = &row;
        ctype.c_fcurs_n = n+1;

    }
}

// --- amc.FCtype.c_fcurs.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_fcurs_InsertMaybe(amc::FCtype& ctype, amc::FFcurs& row) {
    bool retval = !row.ctype_c_fcurs_in_ary;
    c_fcurs_Insert(ctype,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FCtype.c_fcurs.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_fcurs_Remove(amc::FCtype& ctype, amc::FFcurs& row) {
    if (bool_Update(row.ctype_c_fcurs_in_ary,false)) {
        int lim = ctype.c_fcurs_n;
        amc::FFcurs* *elems = ctype.c_fcurs_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFcurs* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFcurs*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ctype.c_fcurs_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FCtype.c_fcurs.Reserve
// Reserve space in index for N more elements;
void amc::c_fcurs_Reserve(amc::FCtype& ctype, u32 n) {
    u32 old_max = ctype.c_fcurs_max;
    if (UNLIKELY(ctype.c_fcurs_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFcurs*);
        u32 new_size = new_max * sizeof(amc::FFcurs*);
        void *new_mem = amc::lpool_ReallocMem(ctype.c_fcurs_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FCtype.c_fcurs");
        }
        ctype.c_fcurs_elems = (amc::FFcurs**)new_mem;
        ctype.c_fcurs_max = new_max;
    }
}

// --- amc.FCtype..Init
// Set all fields to initial values.
void amc::FCtype_Init(amc::FCtype& ctype) {
    ctype.zs_cfmt_head = NULL; // (amc.FCtype.zs_cfmt)
    ctype.zs_cfmt_tail = NULL; // (amc.FCtype.zs_cfmt)
    ctype.c_init = NULL;
    ctype.p_ns = NULL;
    ctype.c_bltin = NULL;
    ctype.c_field_elems = NULL; // (amc.FCtype.c_field)
    ctype.c_field_n = 0; // (amc.FCtype.c_field)
    ctype.c_field_max = 0; // (amc.FCtype.c_field)
    ctype.c_msgtype = NULL;
    ctype.c_varlenfld = NULL;
    ctype.c_optfld = NULL;
    ctype.c_static_elems = NULL; // (amc.FCtype.c_static)
    ctype.c_static_n = 0; // (amc.FCtype.c_static)
    ctype.c_static_max = 0; // (amc.FCtype.c_static)
    ctype.c_cpptype = NULL;
    ctype.c_parent_elems = NULL; // (amc.FCtype.c_parent)
    ctype.c_parent_n = 0; // (amc.FCtype.c_parent)
    ctype.c_parent_max = 0; // (amc.FCtype.c_parent)
    ctype.c_ssimfile = NULL;
    ctype.c_pack = NULL;
    ctype.c_lenfld = NULL;
    ctype.c_pmaskfld = NULL;
    ctype.c_typefld = NULL;
    ctype.c_datafld_elems = NULL; // (amc.FCtype.c_datafld)
    ctype.c_datafld_n = 0; // (amc.FCtype.c_datafld)
    ctype.c_datafld_max = 0; // (amc.FCtype.c_datafld)
    ctype.zd_inst_head = NULL; // (amc.FCtype.zd_inst)
    ctype.zd_inst_n = 0; // (amc.FCtype.zd_inst)
    ctype.zd_inst_tail = NULL; // (amc.FCtype.zd_inst)
    ctype.zs_xref_head = NULL; // (amc.FCtype.zs_xref)
    ctype.zs_xref_n = 0; // (amc.FCtype.zs_xref)
    ctype.zs_xref_tail = NULL; // (amc.FCtype.zs_xref)
    ctype.c_chash = NULL;
    ctype.c_ccmp = NULL;
    ctype.c_cstr = NULL;
    ctype.c_cextern = NULL;
    ctype.c_ffunc_elems = NULL; // (amc.FCtype.c_ffunc)
    ctype.c_ffunc_n = 0; // (amc.FCtype.c_ffunc)
    ctype.c_ffunc_max = 0; // (amc.FCtype.c_ffunc)
    ctype.zd_cafter_head = NULL; // (amc.FCtype.zd_cafter)
    ctype.zd_cafter_n = 0; // (amc.FCtype.zd_cafter)
    ctype.zd_cafter_tail = NULL; // (amc.FCtype.zd_cafter)
    ctype.c_csize = NULL;
    ctype.zd_access_head = NULL; // (amc.FCtype.zd_access)
    ctype.zd_access_n = 0; // (amc.FCtype.zd_access)
    ctype.zd_access_tail = NULL; // (amc.FCtype.zd_access)
    ctype.c_cdflt = NULL;
    ctype.c_argvtype = NULL;
    ctype.c_floadtuples = NULL;
    ctype.c_pkeyfield = NULL;
    ctype.c_fcurs_elems = NULL; // (amc.FCtype.c_fcurs)
    ctype.c_fcurs_n = 0; // (amc.FCtype.c_fcurs)
    ctype.c_fcurs_max = 0; // (amc.FCtype.c_fcurs)
    ctype.c_ctypelen = NULL;
    ctype.copy_priv_valid = bool(false);
    ctype.size_unknown = bool(false);
    ctype.size_locked = bool(false);
    ctype.topo_visited = bool(false);
    ctype.ins_visited = bool(false);
    ctype.enum_visited = bool(false);
    ctype.copy_priv = bool(false);
    ctype.fields_cloned = bool(false);
    ctype.original = bool(false);
    ctype.alignment = u32(1);
    ctype.n_padbytes = i32(0);
    ctype.totsize_byte = u32(0);
    ctype.n_xref = i32(0);
    ctype.next_anon_idx = i32(0);
    ctype.c_nossimfile = NULL;
    ctype.ns_c_ctype_in_ary = bool(false);
    ctype.ns_c_ctype_ins_in_ary = bool(false);
    ctype.ind_ctype_next = (amc::FCtype*)-1; // (amc.FDb.ind_ctype) not-in-hash
    ctype.zsl_ctype_pack_tran_next = (amc::FCtype*)-1; // (amc.FDb.zsl_ctype_pack_tran) not-in-list
    ctype.zs_sig_visit_next = (amc::FCtype*)-1; // (amc.FDb.zs_sig_visit) not-in-list
}

// --- amc.FCtype..Uninit
void amc::FCtype_Uninit(amc::FCtype& ctype) {
    amc::FCtype &row = ctype; (void)row;
    ind_ctype_Remove(row); // remove ctype from index ind_ctype
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_ctype_Remove(*p_ns, row);// remove ctype from index c_ctype
    }
    if (p_ns)  {
        c_ctype_ins_Remove(*p_ns, row);// remove ctype from index c_ctype_ins
    }
    zsl_ctype_pack_tran_Remove(row); // remove ctype from index zsl_ctype_pack_tran
    zs_sig_visit_Remove(row); // remove ctype from index zs_sig_visit

    // amc.FCtype.c_fcurs.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ctype.c_fcurs_elems, sizeof(amc::FFcurs*)*ctype.c_fcurs_max); // (amc.FCtype.c_fcurs)

    // amc.FCtype.c_ffunc.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ctype.c_ffunc_elems, sizeof(amc::FFunc*)*ctype.c_ffunc_max); // (amc.FCtype.c_ffunc)

    // amc.FCtype.c_datafld.Uninit (Ptrary)  //Physical fields (non-fldfunc)
    amc::lpool_FreeMem(ctype.c_datafld_elems, sizeof(amc::FField*)*ctype.c_datafld_max); // (amc.FCtype.c_datafld)

    // amc.FCtype.c_parent.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ctype.c_parent_elems, sizeof(amc::FCtype*)*ctype.c_parent_max); // (amc.FCtype.c_parent)

    // amc.FCtype.c_static.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ctype.c_static_elems, sizeof(amc::FStatictuple*)*ctype.c_static_max); // (amc.FCtype.c_static)

    // amc.FCtype.c_field.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ctype.c_field_elems, sizeof(amc::FField*)*ctype.c_field_max); // (amc.FCtype.c_field)
}

// --- amc.FCtypelen.base.CopyOut
// Copy fields out of row
void amc::ctypelen_CopyOut(amc::FCtypelen &row, dmmeta::Ctypelen &out) {
    out.ctype = row.ctype;
    out.len = row.len;
    out.alignment = row.alignment;
    out.padbytes = row.padbytes;
}

// --- amc.FCtypelen.base.CopyIn
// Copy fields in to row
void amc::ctypelen_CopyIn(amc::FCtypelen &row, dmmeta::Ctypelen &in) {
    row.ctype = in.ctype;
    row.len = in.len;
    row.alignment = in.alignment;
    row.padbytes = in.padbytes;
}

// --- amc.FCtypelen..Uninit
void amc::FCtypelen_Uninit(amc::FCtypelen& ctypelen) {
    amc::FCtypelen &row = ctypelen; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ctypelen_Remove(*p_ctype, row);// remove ctypelen from index c_ctypelen
    }
    c_ctypelen_Remove(row); // remove ctypelen from index c_ctypelen
}

// --- amc.FTclass.msghdr.CopyIn
// Copy fields in to row
void amc::tclass_CopyIn(amc::FTclass &row, amcdb::Tclass &in) {
    row.tclass = in.tclass;
    // comment stripped, see dmmeta.fbase:amc.FTclass.msghdr
}

// --- amc.FTclass.c_tfunc.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_tfunc_Insert(amc::FTclass& tclass, amc::FTfunc& row) {
    if (bool_Update(row.tclass_c_tfunc_in_ary,true)) {
        // reserve space
        c_tfunc_Reserve(tclass, 1);
        u32 n  = tclass.c_tfunc_n;
        u32 at = n;
        amc::FTfunc* *elems = tclass.c_tfunc_elems;
        elems[at] = &row;
        tclass.c_tfunc_n = n+1;

    }
}

// --- amc.FTclass.c_tfunc.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_tfunc_InsertMaybe(amc::FTclass& tclass, amc::FTfunc& row) {
    bool retval = !row.tclass_c_tfunc_in_ary;
    c_tfunc_Insert(tclass,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FTclass.c_tfunc.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_tfunc_Remove(amc::FTclass& tclass, amc::FTfunc& row) {
    if (bool_Update(row.tclass_c_tfunc_in_ary,false)) {
        int lim = tclass.c_tfunc_n;
        amc::FTfunc* *elems = tclass.c_tfunc_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FTfunc* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FTfunc*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                tclass.c_tfunc_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FTclass.c_tfunc.Reserve
// Reserve space in index for N more elements;
void amc::c_tfunc_Reserve(amc::FTclass& tclass, u32 n) {
    u32 old_max = tclass.c_tfunc_max;
    if (UNLIKELY(tclass.c_tfunc_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FTfunc*);
        u32 new_size = new_max * sizeof(amc::FTfunc*);
        void *new_mem = amc::lpool_ReallocMem(tclass.c_tfunc_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FTclass.c_tfunc");
        }
        tclass.c_tfunc_elems = (amc::FTfunc**)new_mem;
        tclass.c_tfunc_max = new_max;
    }
}

// --- amc.FTclass..Uninit
void amc::FTclass_Uninit(amc::FTclass& tclass) {
    amc::FTclass &row = tclass; (void)row;
    ind_tclass_Remove(row); // remove tclass from index ind_tclass

    // amc.FTclass.c_tfunc.Uninit (Ptrary)  //
    amc::lpool_FreeMem(tclass.c_tfunc_elems, sizeof(amc::FTfunc*)*tclass.c_tfunc_max); // (amc.FTclass.c_tfunc)
}

// --- amc.trace..Print
// print string representation of amc::trace to string LHS, no header -- cprint:amc.trace.String
void amc::trace_Print(amc::trace & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "amc.trace";
    (void)row;//only to avoid -Wunused-parameter
}

// --- amc.FDb.lpool.FreeMem
// Free block of memory previously returned by Lpool.
void amc::lpool_FreeMem(void *mem, u64 size) {
    if (mem) {
        size = u64_Max(size,16); // enforce alignment
        u64 cell = algo::u64_BitScanReverse(size-1) + 1;
        lpool_Lpblock *temp = (lpool_Lpblock*)mem; // push  singly linked list
        temp->next = _db.lpool_free[cell];
        _db.lpool_free[cell] = temp;
    }
}

// --- amc.FDb.lpool.AllocMem
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void* amc::lpool_AllocMem(u64 size) {
    size     = u64_Max(size,16); // enforce alignment
    u64 cell = algo::u64_BitScanReverse(size-1)+1;
    u64 i    = cell;
    u8 *retval = NULL;
    // try to find a block that's at least as large as required.
    // if found, remove from free list
    for (; i < 31; i++) {
        lpool_Lpblock *blk = _db.lpool_free[i];
        if (blk) {
            _db.lpool_free[i] = blk->next;
            retval = (u8*)blk;
            break;
        }
    }
    // if suitable size block is not found, create a new one
    // by requesting a block from the base allocator.
    if (UNLIKELY(!retval)) {
        i = u64_Max(cell, 21); // 2MB min -- allow huge page to be used
        retval = (u8*)algo_lib::sbrk_AllocMem(1<<i);
    }
    if (LIKELY(retval)) {
        // if block is more than 2x as large as needed, return the upper half to the free
        // list (repeatedly). meanwhile, retval doesn't change.
        while (i > cell) {
            i--;
            int half = 1<<i;
            lpool_Lpblock *blk = (lpool_Lpblock*)(retval + half);
            blk->next = _db.lpool_free[i];
            _db.lpool_free[i] = blk;
        }
    }
    return retval;
}

// --- amc.FDb.lpool.ReserveBuffers
// Add N buffers of some size to the free store
bool amc::lpool_ReserveBuffers(int nbuf, u64 bufsize) {
    bool retval = true;
    bufsize = u64_Max(bufsize, 16);
    for (int i = 0; i < nbuf; i++) {
        u64     cell = algo::u64_BitScanReverse(bufsize-1)+1;
        u64     size = 1ULL<<cell;
        lpool_Lpblock *temp = (lpool_Lpblock*)algo_lib::sbrk_AllocMem(size);
        if (temp == NULL) {
            retval = false;
            break;// why continue?
        } else {
            temp->next = _db.lpool_free[cell];
            _db.lpool_free[cell] = temp;
        }
    }
    return retval;
}

// --- amc.FDb.lpool.ReallocMem
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void* amc::lpool_ReallocMem(void *oldmem, u64 old_size, u64 new_size) {
    void* ret = oldmem;
    if (new_size != old_size) {
        ret = lpool_AllocMem(new_size);
        if (ret && oldmem) {
            memcpy(ret,oldmem,u64_Min(new_size,old_size));
            lpool_FreeMem(oldmem, old_size);
        }
    }
    return ret;
}

// --- amc.FDb.fsort.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFsort& amc::fsort_Alloc() {
    amc::FFsort* row = fsort_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fsort  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fsort.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFsort* amc::fsort_AllocMaybe() {
    amc::FFsort *row = (amc::FFsort*)fsort_AllocMem();
    if (row) {
        new (row) amc::FFsort; // call constructor
    }
    return row;
}

// --- amc.FDb.fsort.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFsort* amc::fsort_InsertMaybe(const dmmeta::Fsort &value) {
    amc::FFsort *row = &fsort_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fsort_CopyIn(*row,const_cast<dmmeta::Fsort&>(value));
    bool ok = fsort_XrefMaybe(*row); // this may return false
    if (!ok) {
        fsort_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fsort.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fsort_AllocMem() {
    u64 new_nelems     = _db.fsort_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFsort*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fsort_lary[bsr];
        if (!lev) {
            lev=(amc::FFsort*)amc::lpool_AllocMem(sizeof(amc::FFsort) * (u64(1)<<bsr));
            _db.fsort_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fsort_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fsort.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fsort_RemoveLast() {
    u64 n = _db.fsort_n;
    if (n > 0) {
        n -= 1;
        fsort_qFind(u64(n)).~FFsort();
        _db.fsort_n = i32(n);
    }
}

// --- amc.FDb.fsort.InputMaybe
static bool amc::fsort_InputMaybe(dmmeta::Fsort &elem) {
    bool retval = true;
    retval = fsort_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fsort.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fsort_XrefMaybe(amc::FFsort &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fsort: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FField* p_sortfld = amc::ind_field_Find(row.sortfld);
    if (UNLIKELY(!p_sortfld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.sortfld);
        return false;
    }
    // fsort: save pointer to sortfld
    if (true) { // user-defined insert condition
        row.p_sortfld = p_sortfld;
    }
    // insert fsort into index c_fsort
    if (true) { // user-defined insert condition
        bool success = c_fsort_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fsort"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_cfmt.Find
// Find row by key. Return NULL if not found.
amc::FCfmt* amc::ind_cfmt_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_cfmt_buckets_n - 1);
    amc::FCfmt* *e = &_db.ind_cfmt_buckets_elems[index];
    amc::FCfmt* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).cfmt == key;
        if (done) break;
        e         = &ret->ind_cfmt_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_cfmt.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCfmt& amc::ind_cfmt_GetOrCreate(const algo::strptr& key) {
    amc::FCfmt* ret = ind_cfmt_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &cfmt_Alloc();
        (*ret).cfmt = key;
        bool good = cfmt_XrefMaybe(*ret);
        if (!good) {
            cfmt_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_cfmt  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_cfmt.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_cfmt_InsertMaybe(amc::FCfmt& row) {
    ind_cfmt_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_cfmt_next == (amc::FCfmt*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.cfmt) & (_db.ind_cfmt_buckets_n - 1);
        amc::FCfmt* *prev = &_db.ind_cfmt_buckets_elems[index];
        do {
            amc::FCfmt* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).cfmt == row.cfmt) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_cfmt_next;
        } while (true);
        if (retval) {
            row.ind_cfmt_next = *prev;
            _db.ind_cfmt_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_cfmt.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_cfmt_Remove(amc::FCfmt& row) {
    if (LIKELY(row.ind_cfmt_next != (amc::FCfmt*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.cfmt) & (_db.ind_cfmt_buckets_n - 1);
        amc::FCfmt* *prev = &_db.ind_cfmt_buckets_elems[index]; // addr of pointer to current element
        while (amc::FCfmt *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_cfmt_next; // unlink (singly linked list)
                _db.ind_cfmt_n--;
                row.ind_cfmt_next = (amc::FCfmt*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_cfmt_next;
        }
    }
}

// --- amc.FDb.ind_cfmt.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_cfmt_Reserve(int n) {
    u32 old_nbuckets = _db.ind_cfmt_buckets_n;
    u32 new_nelems   = _db.ind_cfmt_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FCfmt*);
        u32 new_size = new_nbuckets * sizeof(amc::FCfmt*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FCfmt* *new_buckets = (amc::FCfmt**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_cfmt");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_cfmt_buckets_n; i++) {
            amc::FCfmt* elem = _db.ind_cfmt_buckets_elems[i];
            while (elem) {
                amc::FCfmt &row        = *elem;
                amc::FCfmt* next       = row.ind_cfmt_next;
                u32 index          = algo::Smallstr100_Hash(0, row.cfmt) & (new_nbuckets-1);
                row.ind_cfmt_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_cfmt_buckets_elems, old_size);
        _db.ind_cfmt_buckets_elems = new_buckets;
        _db.ind_cfmt_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.dispfilter.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispfilter& amc::dispfilter_Alloc() {
    amc::FDispfilter* row = dispfilter_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.dispfilter  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.dispfilter.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispfilter* amc::dispfilter_AllocMaybe() {
    amc::FDispfilter *row = (amc::FDispfilter*)dispfilter_AllocMem();
    if (row) {
        new (row) amc::FDispfilter; // call constructor
    }
    return row;
}

// --- amc.FDb.dispfilter.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispfilter* amc::dispfilter_InsertMaybe(const dmmeta::Dispfilter &value) {
    amc::FDispfilter *row = &dispfilter_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispfilter_CopyIn(*row,const_cast<dmmeta::Dispfilter&>(value));
    bool ok = dispfilter_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispfilter_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.dispfilter.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::dispfilter_AllocMem() {
    u64 new_nelems     = _db.dispfilter_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDispfilter*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispfilter_lary[bsr];
        if (!lev) {
            lev=(amc::FDispfilter*)amc::lpool_AllocMem(sizeof(amc::FDispfilter) * (u64(1)<<bsr));
            _db.dispfilter_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispfilter_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.dispfilter.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::dispfilter_RemoveLast() {
    u64 n = _db.dispfilter_n;
    if (n > 0) {
        n -= 1;
        dispfilter_qFind(u64(n)).~FDispfilter();
        _db.dispfilter_n = i32(n);
    }
}

// --- amc.FDb.dispfilter.InputMaybe
static bool amc::dispfilter_InputMaybe(dmmeta::Dispfilter &elem) {
    bool retval = true;
    retval = dispfilter_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.dispfilter.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::dispfilter_XrefMaybe(amc::FDispfilter &row) {
    bool retval = true;
    (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (UNLIKELY(!p_dispatch)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_dispatch" << Keyval("key", row.dispatch);
        return false;
    }
    // insert dispfilter into index c_dispfilter
    if (true) { // user-defined insert condition
        bool success = c_dispfilter_InsertMaybe(*p_dispatch, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDispatch.c_dispfilter"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.usertracefld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FUsertracefld& amc::usertracefld_Alloc() {
    amc::FUsertracefld* row = usertracefld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.usertracefld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.usertracefld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FUsertracefld* amc::usertracefld_AllocMaybe() {
    amc::FUsertracefld *row = (amc::FUsertracefld*)usertracefld_AllocMem();
    if (row) {
        new (row) amc::FUsertracefld; // call constructor
    }
    return row;
}

// --- amc.FDb.usertracefld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FUsertracefld* amc::usertracefld_InsertMaybe(const dmmeta::Usertracefld &value) {
    amc::FUsertracefld *row = &usertracefld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    usertracefld_CopyIn(*row,const_cast<dmmeta::Usertracefld&>(value));
    bool ok = usertracefld_XrefMaybe(*row); // this may return false
    if (!ok) {
        usertracefld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.usertracefld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::usertracefld_AllocMem() {
    u64 new_nelems     = _db.usertracefld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FUsertracefld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.usertracefld_lary[bsr];
        if (!lev) {
            lev=(amc::FUsertracefld*)amc::lpool_AllocMem(sizeof(amc::FUsertracefld) * (u64(1)<<bsr));
            _db.usertracefld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.usertracefld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.usertracefld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::usertracefld_RemoveLast() {
    u64 n = _db.usertracefld_n;
    if (n > 0) {
        n -= 1;
        usertracefld_qFind(u64(n)).~FUsertracefld();
        _db.usertracefld_n = i32(n);
    }
}

// --- amc.FDb.usertracefld.InputMaybe
static bool amc::usertracefld_InputMaybe(dmmeta::Usertracefld &elem) {
    bool retval = true;
    retval = usertracefld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.usertracefld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::usertracefld_XrefMaybe(amc::FUsertracefld &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- amc.FDb.cfmt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCfmt& amc::cfmt_Alloc() {
    amc::FCfmt* row = cfmt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cfmt  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cfmt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCfmt* amc::cfmt_AllocMaybe() {
    amc::FCfmt *row = (amc::FCfmt*)cfmt_AllocMem();
    if (row) {
        new (row) amc::FCfmt; // call constructor
    }
    return row;
}

// --- amc.FDb.cfmt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCfmt* amc::cfmt_InsertMaybe(const dmmeta::Cfmt &value) {
    amc::FCfmt *row = &cfmt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cfmt_CopyIn(*row,const_cast<dmmeta::Cfmt&>(value));
    bool ok = cfmt_XrefMaybe(*row); // this may return false
    if (!ok) {
        cfmt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cfmt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cfmt_AllocMem() {
    u64 new_nelems     = _db.cfmt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCfmt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cfmt_lary[bsr];
        if (!lev) {
            lev=(amc::FCfmt*)amc::lpool_AllocMem(sizeof(amc::FCfmt) * (u64(1)<<bsr));
            _db.cfmt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cfmt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cfmt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cfmt_RemoveLast() {
    u64 n = _db.cfmt_n;
    if (n > 0) {
        n -= 1;
        cfmt_qFind(u64(n)).~FCfmt();
        _db.cfmt_n = i32(n);
    }
}

// --- amc.FDb.cfmt.InputMaybe
static bool amc::cfmt_InputMaybe(dmmeta::Cfmt &elem) {
    bool retval = true;
    retval = cfmt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cfmt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cfmt_XrefMaybe(amc::FCfmt &row) {
    bool retval = true;
    (void)row;
    // insert cfmt into index ind_cfmt
    if (true) { // user-defined insert condition
        bool success = ind_cfmt_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_cfmt"; // check for duplicate key
            return false;
        }
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert cfmt into index zs_cfmt
    if (true) { // user-defined insert condition
        zs_cfmt_Insert(*p_ctype, row);
    }
    return retval;
}

// --- amc.FDb.dispatch.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispatch& amc::dispatch_Alloc() {
    amc::FDispatch* row = dispatch_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.dispatch  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.dispatch.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispatch* amc::dispatch_AllocMaybe() {
    amc::FDispatch *row = (amc::FDispatch*)dispatch_AllocMem();
    if (row) {
        new (row) amc::FDispatch; // call constructor
    }
    return row;
}

// --- amc.FDb.dispatch.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispatch* amc::dispatch_InsertMaybe(const dmmeta::Dispatch &value) {
    amc::FDispatch *row = &dispatch_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispatch_CopyIn(*row,const_cast<dmmeta::Dispatch&>(value));
    bool ok = dispatch_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispatch_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.dispatch.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::dispatch_AllocMem() {
    u64 new_nelems     = _db.dispatch_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDispatch*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispatch_lary[bsr];
        if (!lev) {
            lev=(amc::FDispatch*)amc::lpool_AllocMem(sizeof(amc::FDispatch) * (u64(1)<<bsr));
            _db.dispatch_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispatch_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.dispatch.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::dispatch_RemoveLast() {
    u64 n = _db.dispatch_n;
    if (n > 0) {
        n -= 1;
        dispatch_qFind(u64(n)).~FDispatch();
        _db.dispatch_n = i32(n);
    }
}

// --- amc.FDb.dispatch.InputMaybe
static bool amc::dispatch_InputMaybe(dmmeta::Dispatch &elem) {
    bool retval = true;
    retval = dispatch_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.dispatch.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::dispatch_XrefMaybe(amc::FDispatch &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // dispatch: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert dispatch into index ind_dispatch
    if (true) { // user-defined insert condition
        bool success = ind_dispatch_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_dispatch"; // check for duplicate key
            return false;
        }
    }
    // insert dispatch into index c_dispatch
    if (true) { // user-defined insert condition
        c_dispatch_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.dispatch_msg.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispatchmsg& amc::dispatch_msg_Alloc() {
    amc::FDispatchmsg* row = dispatch_msg_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.dispatch_msg  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.dispatch_msg.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispatchmsg* amc::dispatch_msg_AllocMaybe() {
    amc::FDispatchmsg *row = (amc::FDispatchmsg*)dispatch_msg_AllocMem();
    if (row) {
        new (row) amc::FDispatchmsg; // call constructor
    }
    return row;
}

// --- amc.FDb.dispatch_msg.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispatchmsg* amc::dispatch_msg_InsertMaybe(const dmmeta::DispatchMsg &value) {
    amc::FDispatchmsg *row = &dispatch_msg_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispatch_msg_CopyIn(*row,const_cast<dmmeta::DispatchMsg&>(value));
    bool ok = dispatch_msg_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispatch_msg_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.dispatch_msg.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::dispatch_msg_AllocMem() {
    u64 new_nelems     = _db.dispatch_msg_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDispatchmsg*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispatch_msg_lary[bsr];
        if (!lev) {
            lev=(amc::FDispatchmsg*)amc::lpool_AllocMem(sizeof(amc::FDispatchmsg) * (u64(1)<<bsr));
            _db.dispatch_msg_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispatch_msg_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.dispatch_msg.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::dispatch_msg_RemoveLast() {
    u64 n = _db.dispatch_msg_n;
    if (n > 0) {
        n -= 1;
        dispatch_msg_qFind(u64(n)).~FDispatchmsg();
        _db.dispatch_msg_n = i32(n);
    }
}

// --- amc.FDb.dispatch_msg.InputMaybe
static bool amc::dispatch_msg_InputMaybe(dmmeta::DispatchMsg &elem) {
    bool retval = true;
    retval = dispatch_msg_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.dispatch_msg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::dispatch_msg_XrefMaybe(amc::FDispatchmsg &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // dispatch_msg: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(dispatch_Get(row));
    if (UNLIKELY(!p_dispatch)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_dispatch" << Keyval("key", dispatch_Get(row));
        return false;
    }
    // dispatch_msg: save pointer to dispatch
    if (true) { // user-defined insert condition
        row.p_dispatch = p_dispatch;
    }
    // insert dispatch_msg into index c_dispatch_msg
    if (true) { // user-defined insert condition
        c_dispatch_msg_Insert(*p_dispatch, row);
    }
    return retval;
}

// --- amc.FDb.ctype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCtype& amc::ctype_Alloc() {
    amc::FCtype* row = ctype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ctype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ctype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCtype* amc::ctype_AllocMaybe() {
    amc::FCtype *row = (amc::FCtype*)ctype_AllocMem();
    if (row) {
        new (row) amc::FCtype; // call constructor
    }
    return row;
}

// --- amc.FDb.ctype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCtype* amc::ctype_InsertMaybe(const dmmeta::Ctype &value) {
    amc::FCtype *row = &ctype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctype_CopyIn(*row,const_cast<dmmeta::Ctype&>(value));
    bool ok = ctype_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ctype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ctype_AllocMem() {
    u64 new_nelems     = _db.ctype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctype_lary[bsr];
        if (!lev) {
            lev=(amc::FCtype*)amc::lpool_AllocMem(sizeof(amc::FCtype) * (u64(1)<<bsr));
            _db.ctype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ctype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ctype_RemoveLast() {
    u64 n = _db.ctype_n;
    if (n > 0) {
        n -= 1;
        ctype_qFind(u64(n)).~FCtype();
        _db.ctype_n = i32(n);
    }
}

// --- amc.FDb.ctype.InputMaybe
static bool amc::ctype_InputMaybe(dmmeta::Ctype &elem) {
    bool retval = true;
    retval = ctype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ctype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ctype_XrefMaybe(amc::FCtype &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // ctype: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert ctype into index ind_ctype
    if (true) { // user-defined insert condition
        bool success = ind_ctype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_ctype"; // check for duplicate key
            return false;
        }
    }
    // insert ctype into index c_ctype
    if (true) { // user-defined insert condition
        c_ctype_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.field.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FField& amc::field_Alloc() {
    amc::FField* row = field_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.field  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.field.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FField* amc::field_AllocMaybe() {
    amc::FField *row = (amc::FField*)field_AllocMem();
    if (row) {
        new (row) amc::FField; // call constructor
        row->rowid = double(field_N() - 1);
    }
    return row;
}

// --- amc.FDb.field.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FField* amc::field_InsertMaybe(const dmmeta::Field &value) {
    amc::FField *row = &field_Alloc(); // if out of memory, process dies. if input error, return NULL.
    field_CopyIn(*row,const_cast<dmmeta::Field&>(value));
    bool ok = field_XrefMaybe(*row); // this may return false
    if (!ok) {
        field_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.field.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::field_AllocMem() {
    u64 new_nelems     = _db.field_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FField*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.field_lary[bsr];
        if (!lev) {
            lev=(amc::FField*)amc::lpool_AllocMem(sizeof(amc::FField) * (u64(1)<<bsr));
            _db.field_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.field_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.field.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::field_RemoveLast() {
    u64 n = _db.field_n;
    if (n > 0) {
        n -= 1;
        field_qFind(u64(n)).~FField();
        _db.field_n = i32(n);
    }
}

// --- amc.FDb.field.InputMaybe
static bool amc::field_InputMaybe(dmmeta::Field &elem) {
    bool retval = true;
    retval = field_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.field.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::field_XrefMaybe(amc::FField &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // field: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    amc::FCtype* p_arg = amc::ind_ctype_Find(row.arg);
    if (UNLIKELY(!p_arg)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.arg);
        return false;
    }
    // field: save pointer to arg
    if (true) { // user-defined insert condition
        row.p_arg = p_arg;
    }
    amc::FReftype* p_reftype = amc::ind_reftype_Find(row.reftype);
    if (UNLIKELY(!p_reftype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_reftype" << Keyval("key", row.reftype);
        return false;
    }
    // field: save pointer to reftype
    if (true) { // user-defined insert condition
        row.p_reftype = p_reftype;
    }
    // insert field into index ind_field
    if (true) { // user-defined insert condition
        bool success = ind_field_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_field"; // check for duplicate key
            return false;
        }
    }
    // insert field into index c_field
    if (true) { // user-defined insert condition
        c_field_Insert(*p_ctype, row);
    }
    // insert field into index zd_access
    if (true) { // user-defined insert condition
        zd_access_Insert(*p_arg, row);
    }
    return retval;
}

// --- amc.FDb.basepool.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBasepool& amc::basepool_Alloc() {
    amc::FBasepool* row = basepool_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.basepool  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.basepool.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FBasepool* amc::basepool_AllocMaybe() {
    amc::FBasepool *row = (amc::FBasepool*)basepool_AllocMem();
    if (row) {
        new (row) amc::FBasepool; // call constructor
    }
    return row;
}

// --- amc.FDb.basepool.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBasepool* amc::basepool_InsertMaybe(const dmmeta::Basepool &value) {
    amc::FBasepool *row = &basepool_Alloc(); // if out of memory, process dies. if input error, return NULL.
    basepool_CopyIn(*row,const_cast<dmmeta::Basepool&>(value));
    bool ok = basepool_XrefMaybe(*row); // this may return false
    if (!ok) {
        basepool_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.basepool.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::basepool_AllocMem() {
    u64 new_nelems     = _db.basepool_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FBasepool*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.basepool_lary[bsr];
        if (!lev) {
            lev=(amc::FBasepool*)amc::lpool_AllocMem(sizeof(amc::FBasepool) * (u64(1)<<bsr));
            _db.basepool_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.basepool_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.basepool.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::basepool_RemoveLast() {
    u64 n = _db.basepool_n;
    if (n > 0) {
        n -= 1;
        basepool_qFind(u64(n)).~FBasepool();
        _db.basepool_n = i32(n);
    }
}

// --- amc.FDb.basepool.InputMaybe
static bool amc::basepool_InputMaybe(dmmeta::Basepool &elem) {
    bool retval = true;
    retval = basepool_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.basepool.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::basepool_XrefMaybe(amc::FBasepool &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // basepool: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FField* p_base = amc::ind_field_Find(row.base);
    if (UNLIKELY(!p_base)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.base);
        return false;
    }
    // basepool: save pointer to base
    if (true) { // user-defined insert condition
        row.p_base = p_base;
    }
    // insert basepool into index c_basepool
    if (true) { // user-defined insert condition
        bool success = c_basepool_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_basepool"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.llist.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FLlist& amc::llist_Alloc() {
    amc::FLlist* row = llist_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.llist  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.llist.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FLlist* amc::llist_AllocMaybe() {
    amc::FLlist *row = (amc::FLlist*)llist_AllocMem();
    if (row) {
        new (row) amc::FLlist; // call constructor
    }
    return row;
}

// --- amc.FDb.llist.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FLlist* amc::llist_InsertMaybe(const dmmeta::Llist &value) {
    amc::FLlist *row = &llist_Alloc(); // if out of memory, process dies. if input error, return NULL.
    llist_CopyIn(*row,const_cast<dmmeta::Llist&>(value));
    bool ok = llist_XrefMaybe(*row); // this may return false
    if (!ok) {
        llist_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.llist.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::llist_AllocMem() {
    u64 new_nelems     = _db.llist_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FLlist*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.llist_lary[bsr];
        if (!lev) {
            lev=(amc::FLlist*)amc::lpool_AllocMem(sizeof(amc::FLlist) * (u64(1)<<bsr));
            _db.llist_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.llist_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.llist.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::llist_RemoveLast() {
    u64 n = _db.llist_n;
    if (n > 0) {
        n -= 1;
        llist_qFind(u64(n)).~FLlist();
        _db.llist_n = i32(n);
    }
}

// --- amc.FDb.llist.InputMaybe
static bool amc::llist_InputMaybe(dmmeta::Llist &elem) {
    bool retval = true;
    retval = llist_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.llist.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::llist_XrefMaybe(amc::FLlist &row) {
    bool retval = true;
    (void)row;
    amc::FListtype* p_listtype = amc::ind_listtype_Find(listtype_Get(row));
    if (UNLIKELY(!p_listtype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_listtype" << Keyval("key", listtype_Get(row));
        return false;
    }
    // llist: save pointer to listtype
    if (true) { // user-defined insert condition
        row.p_listtype = p_listtype;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert llist into index c_llist
    if (true) { // user-defined insert condition
        bool success = c_llist_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_llist"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.anonfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FAnonfld& amc::anonfld_Alloc() {
    amc::FAnonfld* row = anonfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.anonfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.anonfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FAnonfld* amc::anonfld_AllocMaybe() {
    amc::FAnonfld *row = (amc::FAnonfld*)anonfld_AllocMem();
    if (row) {
        new (row) amc::FAnonfld; // call constructor
    }
    return row;
}

// --- amc.FDb.anonfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FAnonfld* amc::anonfld_InsertMaybe(const dmmeta::Anonfld &value) {
    amc::FAnonfld *row = &anonfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    anonfld_CopyIn(*row,const_cast<dmmeta::Anonfld&>(value));
    bool ok = anonfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        anonfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.anonfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::anonfld_AllocMem() {
    u64 new_nelems     = _db.anonfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FAnonfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.anonfld_lary[bsr];
        if (!lev) {
            lev=(amc::FAnonfld*)amc::lpool_AllocMem(sizeof(amc::FAnonfld) * (u64(1)<<bsr));
            _db.anonfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.anonfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.anonfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::anonfld_RemoveLast() {
    u64 n = _db.anonfld_n;
    if (n > 0) {
        n -= 1;
        anonfld_qFind(u64(n)).~FAnonfld();
        _db.anonfld_n = i32(n);
    }
}

// --- amc.FDb.anonfld.InputMaybe
static bool amc::anonfld_InputMaybe(dmmeta::Anonfld &elem) {
    bool retval = true;
    retval = anonfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.anonfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::anonfld_XrefMaybe(amc::FAnonfld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert anonfld into index c_anonfld
    if (true) { // user-defined insert condition
        bool success = c_anonfld_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_anonfld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.xref.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FXref& amc::xref_Alloc() {
    amc::FXref* row = xref_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.xref  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.xref.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FXref* amc::xref_AllocMaybe() {
    amc::FXref *row = (amc::FXref*)xref_AllocMem();
    if (row) {
        new (row) amc::FXref; // call constructor
    }
    return row;
}

// --- amc.FDb.xref.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FXref* amc::xref_InsertMaybe(const dmmeta::Xref &value) {
    amc::FXref *row = &xref_Alloc(); // if out of memory, process dies. if input error, return NULL.
    xref_CopyIn(*row,const_cast<dmmeta::Xref&>(value));
    bool ok = xref_XrefMaybe(*row); // this may return false
    if (!ok) {
        xref_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.xref.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::xref_AllocMem() {
    u64 new_nelems     = _db.xref_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FXref*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.xref_lary[bsr];
        if (!lev) {
            lev=(amc::FXref*)amc::lpool_AllocMem(sizeof(amc::FXref) * (u64(1)<<bsr));
            _db.xref_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.xref_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.xref.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::xref_RemoveLast() {
    u64 n = _db.xref_n;
    if (n > 0) {
        n -= 1;
        xref_qFind(u64(n)).~FXref();
        _db.xref_n = i32(n);
    }
}

// --- amc.FDb.xref.InputMaybe
static bool amc::xref_InputMaybe(dmmeta::Xref &elem) {
    bool retval = true;
    retval = xref_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.xref.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::xref_XrefMaybe(amc::FXref &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // xref: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FField* p_viafld = amc::ind_field_Find(viafld_Get(row));
    if (UNLIKELY(!p_viafld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", viafld_Get(row));
        return false;
    }
    // xref: save pointer to viafld
    if (true) { // user-defined insert condition
        row.p_viafld = p_viafld;
    }
    amc::FField* p_keyfld = amc::ind_field_Find(keyfld_Get(row));
    if (UNLIKELY(!p_keyfld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", keyfld_Get(row));
        return false;
    }
    // xref: save pointer to keyfld
    if (true) { // user-defined insert condition
        row.p_keyfld = p_keyfld;
    }
    // insert xref into index ind_xref
    if (true) { // user-defined insert condition
        bool success = ind_xref_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_xref"; // check for duplicate key
            return false;
        }
    }
    // insert xref into index c_xref
    if (true) { // user-defined insert condition
        bool success = c_xref_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_xref"; // check for duplicate key
            return false;
        }
    }
    // insert xref into index zd_xref_keyfld
    if (true) { // user-defined insert condition
        zd_xref_keyfld_Insert(*p_keyfld, row);
    }
    return retval;
}

// --- amc.FDb.ns.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNs& amc::ns_Alloc() {
    amc::FNs* row = ns_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ns  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ns.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNs* amc::ns_AllocMaybe() {
    amc::FNs *row = (amc::FNs*)ns_AllocMem();
    if (row) {
        new (row) amc::FNs; // call constructor
    }
    return row;
}

// --- amc.FDb.ns.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNs* amc::ns_InsertMaybe(const dmmeta::Ns &value) {
    amc::FNs *row = &ns_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ns_CopyIn(*row,const_cast<dmmeta::Ns&>(value));
    bool ok = ns_XrefMaybe(*row); // this may return false
    if (!ok) {
        ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ns.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ns_AllocMem() {
    u64 new_nelems     = _db.ns_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ns_lary[bsr];
        if (!lev) {
            lev=(amc::FNs*)amc::lpool_AllocMem(sizeof(amc::FNs) * (u64(1)<<bsr));
            _db.ns_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ns_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ns.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ns_RemoveLast() {
    u64 n = _db.ns_n;
    if (n > 0) {
        n -= 1;
        ns_qFind(u64(n)).~FNs();
        _db.ns_n = i32(n);
    }
}

// --- amc.FDb.ns.InputMaybe
static bool amc::ns_InputMaybe(dmmeta::Ns &elem) {
    bool retval = true;
    retval = ns_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ns.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ns_XrefMaybe(amc::FNs &row) {
    bool retval = true;
    (void)row;
    // insert ns into index ind_ns
    if (true) { // user-defined insert condition
        bool success = ind_ns_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_ns"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.pnew.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPnew& amc::pnew_Alloc() {
    amc::FPnew* row = pnew_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.pnew  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.pnew.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FPnew* amc::pnew_AllocMaybe() {
    amc::FPnew *row = (amc::FPnew*)pnew_AllocMem();
    if (row) {
        new (row) amc::FPnew; // call constructor
    }
    return row;
}

// --- amc.FDb.pnew.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPnew* amc::pnew_InsertMaybe(const dmmeta::Pnew &value) {
    amc::FPnew *row = &pnew_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pnew_CopyIn(*row,const_cast<dmmeta::Pnew&>(value));
    bool ok = pnew_XrefMaybe(*row); // this may return false
    if (!ok) {
        pnew_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.pnew.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::pnew_AllocMem() {
    u64 new_nelems     = _db.pnew_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FPnew*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pnew_lary[bsr];
        if (!lev) {
            lev=(amc::FPnew*)amc::lpool_AllocMem(sizeof(amc::FPnew) * (u64(1)<<bsr));
            _db.pnew_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pnew_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.pnew.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::pnew_RemoveLast() {
    u64 n = _db.pnew_n;
    if (n > 0) {
        n -= 1;
        pnew_qFind(u64(n)).~FPnew();
        _db.pnew_n = i32(n);
    }
}

// --- amc.FDb.pnew.InputMaybe
static bool amc::pnew_InputMaybe(dmmeta::Pnew &elem) {
    bool retval = true;
    retval = pnew_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.pnew.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::pnew_XrefMaybe(amc::FPnew &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // pnew: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // pnew: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert pnew into index ind_pnew
    if (true) { // user-defined insert condition
        bool success = ind_pnew_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_pnew"; // check for duplicate key
            return false;
        }
    }
    // insert pnew into index c_pnew
    if (true) { // user-defined insert condition
        c_pnew_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.fldoffset.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFldoffset& amc::fldoffset_Alloc() {
    amc::FFldoffset* row = fldoffset_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fldoffset  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fldoffset.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFldoffset* amc::fldoffset_AllocMaybe() {
    amc::FFldoffset *row = (amc::FFldoffset*)fldoffset_AllocMem();
    if (row) {
        new (row) amc::FFldoffset; // call constructor
    }
    return row;
}

// --- amc.FDb.fldoffset.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFldoffset* amc::fldoffset_InsertMaybe(const dmmeta::Fldoffset &value) {
    amc::FFldoffset *row = &fldoffset_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fldoffset_CopyIn(*row,const_cast<dmmeta::Fldoffset&>(value));
    bool ok = fldoffset_XrefMaybe(*row); // this may return false
    if (!ok) {
        fldoffset_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fldoffset.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fldoffset_AllocMem() {
    u64 new_nelems     = _db.fldoffset_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFldoffset*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fldoffset_lary[bsr];
        if (!lev) {
            lev=(amc::FFldoffset*)amc::lpool_AllocMem(sizeof(amc::FFldoffset) * (u64(1)<<bsr));
            _db.fldoffset_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fldoffset_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fldoffset.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fldoffset_RemoveLast() {
    u64 n = _db.fldoffset_n;
    if (n > 0) {
        n -= 1;
        fldoffset_qFind(u64(n)).~FFldoffset();
        _db.fldoffset_n = i32(n);
    }
}

// --- amc.FDb.fldoffset.InputMaybe
static bool amc::fldoffset_InputMaybe(dmmeta::Fldoffset &elem) {
    bool retval = true;
    retval = fldoffset_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fldoffset.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fldoffset_XrefMaybe(amc::FFldoffset &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fldoffset: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fldoffset into index c_fldoffset
    if (true) { // user-defined insert condition
        bool success = c_fldoffset_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fldoffset"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.typefld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTypefld& amc::typefld_Alloc() {
    amc::FTypefld* row = typefld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.typefld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.typefld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTypefld* amc::typefld_AllocMaybe() {
    amc::FTypefld *row = (amc::FTypefld*)typefld_AllocMem();
    if (row) {
        new (row) amc::FTypefld; // call constructor
    }
    return row;
}

// --- amc.FDb.typefld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTypefld* amc::typefld_InsertMaybe(const dmmeta::Typefld &value) {
    amc::FTypefld *row = &typefld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    typefld_CopyIn(*row,const_cast<dmmeta::Typefld&>(value));
    bool ok = typefld_XrefMaybe(*row); // this may return false
    if (!ok) {
        typefld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.typefld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::typefld_AllocMem() {
    u64 new_nelems     = _db.typefld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTypefld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.typefld_lary[bsr];
        if (!lev) {
            lev=(amc::FTypefld*)amc::lpool_AllocMem(sizeof(amc::FTypefld) * (u64(1)<<bsr));
            _db.typefld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.typefld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.typefld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::typefld_RemoveLast() {
    u64 n = _db.typefld_n;
    if (n > 0) {
        n -= 1;
        typefld_qFind(u64(n)).~FTypefld();
        _db.typefld_n = i32(n);
    }
}

// --- amc.FDb.typefld.InputMaybe
static bool amc::typefld_InputMaybe(dmmeta::Typefld &elem) {
    bool retval = true;
    retval = typefld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.typefld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::typefld_XrefMaybe(amc::FTypefld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // typefld: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // typefld: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert typefld into index c_typefld
    if (true) { // user-defined insert condition
        bool success = c_typefld_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_typefld"; // check for duplicate key
            return false;
        }
    }
    // insert typefld into index c_typefld
    if (true) { // user-defined insert condition
        bool success = c_typefld_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_typefld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.lenfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FLenfld& amc::lenfld_Alloc() {
    amc::FLenfld* row = lenfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.lenfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.lenfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FLenfld* amc::lenfld_AllocMaybe() {
    amc::FLenfld *row = (amc::FLenfld*)lenfld_AllocMem();
    if (row) {
        new (row) amc::FLenfld; // call constructor
    }
    return row;
}

// --- amc.FDb.lenfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FLenfld* amc::lenfld_InsertMaybe(const dmmeta::Lenfld &value) {
    amc::FLenfld *row = &lenfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    lenfld_CopyIn(*row,const_cast<dmmeta::Lenfld&>(value));
    bool ok = lenfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        lenfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.lenfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::lenfld_AllocMem() {
    u64 new_nelems     = _db.lenfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FLenfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.lenfld_lary[bsr];
        if (!lev) {
            lev=(amc::FLenfld*)amc::lpool_AllocMem(sizeof(amc::FLenfld) * (u64(1)<<bsr));
            _db.lenfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.lenfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.lenfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::lenfld_RemoveLast() {
    u64 n = _db.lenfld_n;
    if (n > 0) {
        n -= 1;
        lenfld_qFind(u64(n)).~FLenfld();
        _db.lenfld_n = i32(n);
    }
}

// --- amc.FDb.lenfld.InputMaybe
static bool amc::lenfld_InputMaybe(dmmeta::Lenfld &elem) {
    bool retval = true;
    retval = lenfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.lenfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::lenfld_XrefMaybe(amc::FLenfld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // lenfld: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert lenfld into index c_lenfld
    if (true) { // user-defined insert condition
        bool success = c_lenfld_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_lenfld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.bltin.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBltin& amc::bltin_Alloc() {
    amc::FBltin* row = bltin_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.bltin  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.bltin.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FBltin* amc::bltin_AllocMaybe() {
    amc::FBltin *row = (amc::FBltin*)bltin_AllocMem();
    if (row) {
        new (row) amc::FBltin; // call constructor
    }
    return row;
}

// --- amc.FDb.bltin.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBltin* amc::bltin_InsertMaybe(const amcdb::Bltin &value) {
    amc::FBltin *row = &bltin_Alloc(); // if out of memory, process dies. if input error, return NULL.
    bltin_CopyIn(*row,const_cast<amcdb::Bltin&>(value));
    bool ok = bltin_XrefMaybe(*row); // this may return false
    if (!ok) {
        bltin_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.bltin.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::bltin_AllocMem() {
    u64 new_nelems     = _db.bltin_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FBltin*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.bltin_lary[bsr];
        if (!lev) {
            lev=(amc::FBltin*)amc::lpool_AllocMem(sizeof(amc::FBltin) * (u64(1)<<bsr));
            _db.bltin_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.bltin_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.bltin.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::bltin_RemoveLast() {
    u64 n = _db.bltin_n;
    if (n > 0) {
        n -= 1;
        bltin_qFind(u64(n)).~FBltin();
        _db.bltin_n = i32(n);
    }
}

// --- amc.FDb.bltin.InputMaybe
static bool amc::bltin_InputMaybe(amcdb::Bltin &elem) {
    bool retval = true;
    retval = bltin_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.bltin.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::bltin_XrefMaybe(amc::FBltin &row) {
    bool retval = true;
    (void)row;
    // insert bltin into index ind_bltin
    if (true) { // user-defined insert condition
        bool success = ind_bltin_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_bltin"; // check for duplicate key
            return false;
        }
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert bltin into index c_bltin
    if (true) { // user-defined insert condition
        bool success = c_bltin_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_bltin"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.static_tuple.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FStatictuple& amc::static_tuple_Alloc() {
    amc::FStatictuple* row = static_tuple_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.static_tuple  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.static_tuple.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FStatictuple* amc::static_tuple_AllocMaybe() {
    amc::FStatictuple *row = (amc::FStatictuple*)static_tuple_AllocMem();
    if (row) {
        new (row) amc::FStatictuple; // call constructor
    }
    return row;
}

// --- amc.FDb.static_tuple.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::static_tuple_AllocMem() {
    u64 new_nelems     = _db.static_tuple_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FStatictuple*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.static_tuple_lary[bsr];
        if (!lev) {
            lev=(amc::FStatictuple*)amc::lpool_AllocMem(sizeof(amc::FStatictuple) * (u64(1)<<bsr));
            _db.static_tuple_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.static_tuple_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.static_tuple.RemoveAll
// Remove all elements from Lary
void amc::static_tuple_RemoveAll() {
    for (u64 n = _db.static_tuple_n; n>0; ) {
        n--;
        static_tuple_qFind(u64(n)).~FStatictuple(); // destroy last element
        _db.static_tuple_n = i32(n);
    }
}

// --- amc.FDb.static_tuple.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::static_tuple_RemoveLast() {
    u64 n = _db.static_tuple_n;
    if (n > 0) {
        n -= 1;
        static_tuple_qFind(u64(n)).~FStatictuple();
        _db.static_tuple_n = i32(n);
    }
}

// --- amc.FDb.static_tuple.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::static_tuple_XrefMaybe(amc::FStatictuple &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert static_tuple into index c_static
    if (true) { // user-defined insert condition
        c_static_Insert(*p_ctype, row);
    }
    return retval;
}

// --- amc.FDb.msgtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FMsgtype& amc::msgtype_Alloc() {
    amc::FMsgtype* row = msgtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.msgtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.msgtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FMsgtype* amc::msgtype_AllocMaybe() {
    amc::FMsgtype *row = (amc::FMsgtype*)msgtype_AllocMem();
    if (row) {
        new (row) amc::FMsgtype; // call constructor
    }
    return row;
}

// --- amc.FDb.msgtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FMsgtype* amc::msgtype_InsertMaybe(const dmmeta::Msgtype &value) {
    amc::FMsgtype *row = &msgtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    msgtype_CopyIn(*row,const_cast<dmmeta::Msgtype&>(value));
    bool ok = msgtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        msgtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.msgtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::msgtype_AllocMem() {
    u64 new_nelems     = _db.msgtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FMsgtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.msgtype_lary[bsr];
        if (!lev) {
            lev=(amc::FMsgtype*)amc::lpool_AllocMem(sizeof(amc::FMsgtype) * (u64(1)<<bsr));
            _db.msgtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.msgtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.msgtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::msgtype_RemoveLast() {
    u64 n = _db.msgtype_n;
    if (n > 0) {
        n -= 1;
        msgtype_qFind(u64(n)).~FMsgtype();
        _db.msgtype_n = i32(n);
    }
}

// --- amc.FDb.msgtype.InputMaybe
static bool amc::msgtype_InputMaybe(dmmeta::Msgtype &elem) {
    bool retval = true;
    retval = msgtype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.msgtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::msgtype_XrefMaybe(amc::FMsgtype &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // msgtype: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert msgtype into index c_msgtype
    if (true) { // user-defined insert condition
        bool success = c_msgtype_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_msgtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.gconst.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGconst& amc::gconst_Alloc() {
    amc::FGconst* row = gconst_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.gconst  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.gconst.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FGconst* amc::gconst_AllocMaybe() {
    amc::FGconst *row = (amc::FGconst*)gconst_AllocMem();
    if (row) {
        new (row) amc::FGconst; // call constructor
    }
    return row;
}

// --- amc.FDb.gconst.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGconst* amc::gconst_InsertMaybe(const dmmeta::Gconst &value) {
    amc::FGconst *row = &gconst_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gconst_CopyIn(*row,const_cast<dmmeta::Gconst&>(value));
    bool ok = gconst_XrefMaybe(*row); // this may return false
    if (!ok) {
        gconst_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.gconst.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::gconst_AllocMem() {
    u64 new_nelems     = _db.gconst_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FGconst*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gconst_lary[bsr];
        if (!lev) {
            lev=(amc::FGconst*)amc::lpool_AllocMem(sizeof(amc::FGconst) * (u64(1)<<bsr));
            _db.gconst_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gconst_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.gconst.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::gconst_RemoveLast() {
    u64 n = _db.gconst_n;
    if (n > 0) {
        n -= 1;
        gconst_qFind(u64(n)).~FGconst();
        _db.gconst_n = i32(n);
    }
}

// --- amc.FDb.gconst.InputMaybe
static bool amc::gconst_InputMaybe(dmmeta::Gconst &elem) {
    bool retval = true;
    retval = gconst_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.gconst.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::gconst_XrefMaybe(amc::FGconst &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_namefld = amc::ind_field_Find(row.namefld);
    if (UNLIKELY(!p_namefld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.namefld);
        return false;
    }
    // gconst: save pointer to namefld
    if (true) { // user-defined insert condition
        row.p_namefld = p_namefld;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // gconst: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert gconst into index c_gconst
    if (true) { // user-defined insert condition
        bool success = c_gconst_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_gconst"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.gstatic.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGstatic& amc::gstatic_Alloc() {
    amc::FGstatic* row = gstatic_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.gstatic  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.gstatic.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FGstatic* amc::gstatic_AllocMaybe() {
    amc::FGstatic *row = (amc::FGstatic*)gstatic_AllocMem();
    if (row) {
        new (row) amc::FGstatic; // call constructor
        row->rowid = u32(gstatic_N() - 1);
    }
    return row;
}

// --- amc.FDb.gstatic.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGstatic* amc::gstatic_InsertMaybe(const dmmeta::Gstatic &value) {
    amc::FGstatic *row = &gstatic_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gstatic_CopyIn(*row,const_cast<dmmeta::Gstatic&>(value));
    bool ok = gstatic_XrefMaybe(*row); // this may return false
    if (!ok) {
        gstatic_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.gstatic.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::gstatic_AllocMem() {
    u64 new_nelems     = _db.gstatic_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FGstatic*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gstatic_lary[bsr];
        if (!lev) {
            lev=(amc::FGstatic*)amc::lpool_AllocMem(sizeof(amc::FGstatic) * (u64(1)<<bsr));
            _db.gstatic_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gstatic_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.gstatic.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::gstatic_RemoveLast() {
    u64 n = _db.gstatic_n;
    if (n > 0) {
        n -= 1;
        gstatic_qFind(u32(n)).~FGstatic();
        _db.gstatic_n = i32(n);
    }
}

// --- amc.FDb.gstatic.InputMaybe
static bool amc::gstatic_InputMaybe(dmmeta::Gstatic &elem) {
    bool retval = true;
    retval = gstatic_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.gstatic.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::gstatic_XrefMaybe(amc::FGstatic &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // gstatic: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert gstatic into index c_gstatic
    if (true) { // user-defined insert condition
        c_gstatic_Insert(*p_ns, row);
    }
    // insert gstatic into index c_gstatic
    if (true) { // user-defined insert condition
        bool success = c_gstatic_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_gstatic"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.thash.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FThash& amc::thash_Alloc() {
    amc::FThash* row = thash_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.thash  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.thash.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FThash* amc::thash_AllocMaybe() {
    amc::FThash *row = (amc::FThash*)thash_AllocMem();
    if (row) {
        new (row) amc::FThash; // call constructor
    }
    return row;
}

// --- amc.FDb.thash.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FThash* amc::thash_InsertMaybe(const dmmeta::Thash &value) {
    amc::FThash *row = &thash_Alloc(); // if out of memory, process dies. if input error, return NULL.
    thash_CopyIn(*row,const_cast<dmmeta::Thash&>(value));
    bool ok = thash_XrefMaybe(*row); // this may return false
    if (!ok) {
        thash_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.thash.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::thash_AllocMem() {
    u64 new_nelems     = _db.thash_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FThash*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.thash_lary[bsr];
        if (!lev) {
            lev=(amc::FThash*)amc::lpool_AllocMem(sizeof(amc::FThash) * (u64(1)<<bsr));
            _db.thash_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.thash_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.thash.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::thash_RemoveLast() {
    u64 n = _db.thash_n;
    if (n > 0) {
        n -= 1;
        thash_qFind(u64(n)).~FThash();
        _db.thash_n = i32(n);
    }
}

// --- amc.FDb.thash.InputMaybe
static bool amc::thash_InputMaybe(dmmeta::Thash &elem) {
    bool retval = true;
    retval = thash_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.thash.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::thash_XrefMaybe(amc::FThash &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_hashfld = amc::ind_field_Find(row.hashfld);
    if (UNLIKELY(!p_hashfld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.hashfld);
        return false;
    }
    // thash: save pointer to hashfld
    if (true) { // user-defined insert condition
        row.p_hashfld = p_hashfld;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // thash: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert thash into index c_thash
    if (true) { // user-defined insert condition
        bool success = c_thash_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_thash"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.outfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FOutfile& amc::outfile_Alloc() {
    amc::FOutfile* row = outfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.outfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.outfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FOutfile* amc::outfile_AllocMaybe() {
    amc::FOutfile *row = (amc::FOutfile*)outfile_AllocMem();
    if (row) {
        new (row) amc::FOutfile; // call constructor
    }
    return row;
}

// --- amc.FDb.outfile.Delete
// Remove row from all global and cross indices, then deallocate row
void amc::outfile_Delete(amc::FOutfile &row) {
    row.~FOutfile();
    outfile_FreeMem(row);
}

// --- amc.FDb.outfile.AllocMem
// Allocate space for one element
// If no memory available, return NULL.
void* amc::outfile_AllocMem() {
    amc::FOutfile *row = _db.outfile_free;
    if (UNLIKELY(!row)) {
        outfile_Reserve(1);
        row = _db.outfile_free;
    }
    if (row) {
        _db.outfile_free = row->outfile_next;
    }
    return row;
}

// --- amc.FDb.outfile.FreeMem
// Remove mem from all global and cross indices, then deallocate mem
void amc::outfile_FreeMem(amc::FOutfile &row) {
    if (UNLIKELY(row.outfile_next != (amc::FOutfile*)-1)) {
        FatalErrorExit("amc.tpool_double_delete  pool:amc.FDb.outfile  comment:'double deletion caught'");
    }
    row.outfile_next = _db.outfile_free; // insert into free list
    _db.outfile_free  = &row;
}

// --- amc.FDb.outfile.Reserve
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64 amc::outfile_Reserve(u64 n_elems) {
    u64 ret = 0;
    while (ret < n_elems) {
        u64 size = _db.outfile_blocksize; // underlying allocator is probably Lpool
        u64 reserved = outfile_ReserveMem(size);
        ret += reserved;
        if (reserved == 0) {
            break;
        }
    }
    return ret;
}

// --- amc.FDb.outfile.ReserveMem
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64 amc::outfile_ReserveMem(u64 size) {
    u64 ret = 0;
    if (size >= sizeof(amc::FOutfile)) {
        amc::FOutfile *mem = (amc::FOutfile*)amc::lpool_AllocMem(size);
        ret = mem ? size / sizeof(amc::FOutfile) : 0;
        // add newly allocated elements to the free list;
        for (u64 i=0; i < ret; i++) {
            mem[i].outfile_next = _db.outfile_free;
            _db.outfile_free = mem+i;
        }
    }
    return ret;
}

// --- amc.FDb.outfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::outfile_XrefMaybe(amc::FOutfile &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // outfile: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    amc::FNs* p_p_ns = row.p_ns;
    if (UNLIKELY(!p_p_ns)) {
        algo_lib::ResetErrtext() << "amc.null_ref  xref:amc.FNs.c_outfile";
        return false;
    }
    // insert outfile into index c_outfile
    if (true) { // user-defined insert condition
        c_outfile_Insert(*p_p_ns, row);
    }
    return retval;
}

// --- amc.FDb.func.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFunc& amc::func_Alloc() {
    amc::FFunc* row = func_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.func  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.func.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFunc* amc::func_AllocMaybe() {
    amc::FFunc *row = (amc::FFunc*)func_AllocMem();
    if (row) {
        new (row) amc::FFunc; // call constructor
    }
    return row;
}

// --- amc.FDb.func.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFunc* amc::func_InsertMaybe(const dmmeta::Func &value) {
    amc::FFunc *row = &func_Alloc(); // if out of memory, process dies. if input error, return NULL.
    func_CopyIn(*row,const_cast<dmmeta::Func&>(value));
    bool ok = func_XrefMaybe(*row); // this may return false
    if (!ok) {
        func_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.func.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::func_AllocMem() {
    u64 new_nelems     = _db.func_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFunc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.func_lary[bsr];
        if (!lev) {
            lev=(amc::FFunc*)amc::lpool_AllocMem(sizeof(amc::FFunc) * (u64(1)<<bsr));
            _db.func_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.func_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.func.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::func_RemoveLast() {
    u64 n = _db.func_n;
    if (n > 0) {
        n -= 1;
        func_qFind(u64(n)).~FFunc();
        _db.func_n = i32(n);
    }
}

// --- amc.FDb.func.InputMaybe
static bool amc::func_InputMaybe(dmmeta::Func &elem) {
    bool retval = true;
    retval = func_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.func.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::func_XrefMaybe(amc::FFunc &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // func: save pointer to ns
    if (true) { // user-defined insert condition
        row.p_ns = p_ns;
    }
    // insert func into index ind_func
    if (true) { // user-defined insert condition
        bool success = ind_func_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_func"; // check for duplicate key
            return false;
        }
    }
    // insert func into index c_func
    if (true) { // user-defined insert condition
        c_func_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.smallstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSmallstr& amc::smallstr_Alloc() {
    amc::FSmallstr* row = smallstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.smallstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.smallstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FSmallstr* amc::smallstr_AllocMaybe() {
    amc::FSmallstr *row = (amc::FSmallstr*)smallstr_AllocMem();
    if (row) {
        new (row) amc::FSmallstr; // call constructor
    }
    return row;
}

// --- amc.FDb.smallstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSmallstr* amc::smallstr_InsertMaybe(const dmmeta::Smallstr &value) {
    amc::FSmallstr *row = &smallstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    smallstr_CopyIn(*row,const_cast<dmmeta::Smallstr&>(value));
    bool ok = smallstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        smallstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.smallstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::smallstr_AllocMem() {
    u64 new_nelems     = _db.smallstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FSmallstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.smallstr_lary[bsr];
        if (!lev) {
            lev=(amc::FSmallstr*)amc::lpool_AllocMem(sizeof(amc::FSmallstr) * (u64(1)<<bsr));
            _db.smallstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.smallstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.smallstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::smallstr_RemoveLast() {
    u64 n = _db.smallstr_n;
    if (n > 0) {
        n -= 1;
        smallstr_qFind(u64(n)).~FSmallstr();
        _db.smallstr_n = i32(n);
    }
}

// --- amc.FDb.smallstr.InputMaybe
static bool amc::smallstr_InputMaybe(dmmeta::Smallstr &elem) {
    bool retval = true;
    retval = smallstr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.smallstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::smallstr_XrefMaybe(amc::FSmallstr &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // smallstr: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert smallstr into index c_smallstr
    if (true) { // user-defined insert condition
        bool success = c_smallstr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_smallstr"; // check for duplicate key
            return false;
        }
    }
    // insert smallstr into index ind_smallstr
    if (true) { // user-defined insert condition
        bool success = ind_smallstr_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_smallstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.numstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNumstr& amc::numstr_Alloc() {
    amc::FNumstr* row = numstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.numstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.numstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNumstr* amc::numstr_AllocMaybe() {
    amc::FNumstr *row = (amc::FNumstr*)numstr_AllocMem();
    if (row) {
        new (row) amc::FNumstr; // call constructor
    }
    return row;
}

// --- amc.FDb.numstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNumstr* amc::numstr_InsertMaybe(const dmmeta::Numstr &value) {
    amc::FNumstr *row = &numstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    numstr_CopyIn(*row,const_cast<dmmeta::Numstr&>(value));
    bool ok = numstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        numstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.numstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::numstr_AllocMem() {
    u64 new_nelems     = _db.numstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNumstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.numstr_lary[bsr];
        if (!lev) {
            lev=(amc::FNumstr*)amc::lpool_AllocMem(sizeof(amc::FNumstr) * (u64(1)<<bsr));
            _db.numstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.numstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.numstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::numstr_RemoveLast() {
    u64 n = _db.numstr_n;
    if (n > 0) {
        n -= 1;
        numstr_qFind(u64(n)).~FNumstr();
        _db.numstr_n = i32(n);
    }
}

// --- amc.FDb.numstr.InputMaybe
static bool amc::numstr_InputMaybe(dmmeta::Numstr &elem) {
    bool retval = true;
    retval = numstr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.numstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::numstr_XrefMaybe(amc::FNumstr &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_numtype = amc::ind_ctype_Find(row.numtype);
    if (UNLIKELY(!p_numtype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.numtype);
        return false;
    }
    // numstr: save pointer to numtype
    if (true) { // user-defined insert condition
        row.p_numtype = p_numtype;
    }
    amc::FSmallstr* p_field = amc::ind_smallstr_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_smallstr" << Keyval("key", row.field);
        return false;
    }
    // insert numstr into index c_numstr
    if (true) { // user-defined insert condition
        bool success = c_numstr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FSmallstr.c_numstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.main.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FMain& amc::main_Alloc() {
    amc::FMain* row = main_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.main  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.main.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FMain* amc::main_AllocMaybe() {
    amc::FMain *row = (amc::FMain*)main_AllocMem();
    if (row) {
        new (row) amc::FMain; // call constructor
    }
    return row;
}

// --- amc.FDb.main.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FMain* amc::main_InsertMaybe(const dmmeta::Main &value) {
    amc::FMain *row = &main_Alloc(); // if out of memory, process dies. if input error, return NULL.
    main_CopyIn(*row,const_cast<dmmeta::Main&>(value));
    bool ok = main_XrefMaybe(*row); // this may return false
    if (!ok) {
        main_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.main.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::main_AllocMem() {
    u64 new_nelems     = _db.main_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FMain*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.main_lary[bsr];
        if (!lev) {
            lev=(amc::FMain*)amc::lpool_AllocMem(sizeof(amc::FMain) * (u64(1)<<bsr));
            _db.main_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.main_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.main.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::main_RemoveLast() {
    u64 n = _db.main_n;
    if (n > 0) {
        n -= 1;
        main_qFind(u64(n)).~FMain();
        _db.main_n = i32(n);
    }
}

// --- amc.FDb.main.InputMaybe
static bool amc::main_InputMaybe(dmmeta::Main &elem) {
    bool retval = true;
    retval = main_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.main.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::main_XrefMaybe(amc::FMain &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", row.ns);
        return false;
    }
    // insert main into index c_main
    if (true) { // user-defined insert condition
        bool success = c_main_InsertMaybe(*p_ns, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_main"; // check for duplicate key
            return false;
        }
    }
    // insert main into index ind_main
    if (true) { // user-defined insert condition
        bool success = ind_main_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_main"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.reftype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FReftype& amc::reftype_Alloc() {
    amc::FReftype* row = reftype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.reftype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.reftype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FReftype* amc::reftype_AllocMaybe() {
    amc::FReftype *row = (amc::FReftype*)reftype_AllocMem();
    if (row) {
        new (row) amc::FReftype; // call constructor
        row->rowid = dmmeta::ReftypeId(reftype_N() - 1);
    }
    return row;
}

// --- amc.FDb.reftype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FReftype* amc::reftype_InsertMaybe(const dmmeta::Reftype &value) {
    amc::FReftype *row = &reftype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    reftype_CopyIn(*row,const_cast<dmmeta::Reftype&>(value));
    bool ok = reftype_XrefMaybe(*row); // this may return false
    if (!ok) {
        reftype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.reftype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::reftype_AllocMem() {
    u64 new_nelems     = _db.reftype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FReftype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.reftype_lary[bsr];
        if (!lev) {
            lev=(amc::FReftype*)amc::lpool_AllocMem(sizeof(amc::FReftype) * (u64(1)<<bsr));
            _db.reftype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.reftype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.reftype.RemoveAll
// Remove all elements from Lary
void amc::reftype_RemoveAll() {
    for (u64 n = _db.reftype_n; n>0; ) {
        n--;
        reftype_qFind(dmmeta::ReftypeId(n)).~FReftype(); // destroy last element
        _db.reftype_n = i32(n);
    }
}

// --- amc.FDb.reftype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::reftype_RemoveLast() {
    u64 n = _db.reftype_n;
    if (n > 0) {
        n -= 1;
        reftype_qFind(dmmeta::ReftypeId(n)).~FReftype();
        _db.reftype_n = i32(n);
    }
}

// --- amc.FDb.reftype.LoadStatic
static void amc::reftype_LoadStatic() {
    static struct _t {
        const char *s;
    } data[] = {
        { "dmmeta.reftype  reftype:Atree  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:Y  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Base  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:Y  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Bheap  isval:N  cascins:N  usebasepool:Y  cancopy:N  isxref:Y  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Bitfld  isval:Y  cascins:Y  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Blkpool  isval:Y  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:Y  up:N  isnew:N  hasalloc:Y  inst:Y  varlen:Y" }
        ,{ "dmmeta.reftype  reftype:Charset  isval:Y  cascins:Y  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Count  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Cppstack  isval:Y  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Delptr  isval:N  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Exec  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Fbuf  isval:Y  cascins:Y  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Global  isval:Y  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Hook  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Inlary  isval:Y  cascins:Y  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Lary  isval:Y  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:Y  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Llist  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:Y  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Lpool  isval:Y  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:Y  up:N  isnew:N  hasalloc:Y  inst:Y  varlen:Y" }
        ,{ "dmmeta.reftype  reftype:Malloc  isval:Y  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:Y  up:N  isnew:N  hasalloc:Y  inst:Y  varlen:Y" }
        ,{ "dmmeta.reftype  reftype:Opt  isval:Y  cascins:Y  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:Y  varlen:Y" }
        ,{ "dmmeta.reftype  reftype:Pkey  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:Y  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Protocol  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Ptr  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Ptrary  isval:N  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:RegxSql  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:Y  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Sbrk  isval:Y  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Smallstr  isval:Y  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Tary  isval:Y  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Thash  isval:N  cascins:N  usebasepool:Y  cancopy:N  isxref:Y  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Tpool  isval:Y  cascins:N  usebasepool:Y  cancopy:N  isxref:N  del:Y  up:N  isnew:N  hasalloc:Y  inst:Y  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Upptr  isval:N  cascins:N  usebasepool:N  cancopy:Y  isxref:N  del:N  up:Y  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Val  isval:Y  cascins:Y  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:N  varlen:N" }
        ,{ "dmmeta.reftype  reftype:Varlen  isval:Y  cascins:Y  usebasepool:N  cancopy:Y  isxref:N  del:N  up:N  isnew:Y  hasalloc:N  inst:Y  varlen:Y" }
        ,{ "dmmeta.reftype  reftype:ZSListMT  isval:N  cascins:N  usebasepool:N  cancopy:N  isxref:N  del:N  up:N  isnew:N  hasalloc:N  inst:N  varlen:N" }
        ,{NULL}
    };
    (void)data;
    dmmeta::Reftype reftype;
    for (int i=0; data[i].s; i++) {
        (void)dmmeta::Reftype_ReadStrptrMaybe(reftype, algo::strptr(data[i].s));
        amc::FReftype *elem = reftype_InsertMaybe(reftype);
        (void)elem;
    }
}

// --- amc.FDb.reftype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::reftype_XrefMaybe(amc::FReftype &row) {
    bool retval = true;
    (void)row;
    amc::FTclass* p_reftype = amc::ind_tclass_Find(row.reftype);
    if (UNLIKELY(!p_reftype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_tclass" << Keyval("key", row.reftype);
        return false;
    }
    // reftype: save pointer to reftype
    if (true) { // user-defined insert condition
        row.p_tclass = p_reftype;
    }
    // insert reftype into index ind_reftype
    if (true) { // user-defined insert condition
        bool success = ind_reftype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_reftype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb._db.MainArgs
// Main function
void amc::MainArgs(int argc, char **argv) {
    Argtuple argtuple;
    Argtuple_ReadArgv(argtuple, argc,argv,amc_syntax, amc_help);
    vrfy(amc_ReadTupleMaybe(amc::_db.cmdline, argtuple.tuple),"where:read_cmdline");
    amc::Main(); // call through to user-defined main
}

// --- amc.FDb._db.MainLoop
// Main loop.
void amc::MainLoop() {
    algo::SchedTime time(algo::get_cycles());
    algo_lib::_db.clock          = time;
    do {
        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
        amc::Steps();
    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
}

// --- amc.FDb._db.Step
// Main step
void amc::Step() {
}

// --- amc.FDb._db.InitReflection
// Load statically available data into tables, register tables and database.
static void amc::InitReflection() {
    algo_lib::imdb_InsertMaybe(algo::Imdb("amc", amc::InsertStrptrMaybe, NULL, amc::MainLoop, NULL, algo::Comment()));

    algo::Imtable t_trace;
    t_trace.imtable         = "amc.trace";
    t_trace.ssimfile        = "";
    t_trace.size            = sizeof(amc::trace);
    t_trace.comment.value   = "";
    t_trace.c_RowidFind     = trace_RowidFind;
    t_trace.NItems          = trace_N;
    t_trace.Print           = (algo::ImrowPrintFcn)amc::trace_Print;
    algo_lib::imtable_InsertMaybe(t_trace);


    // -- load signatures of existing dispatches --
    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'amc.Input'  signature:'14122266c68d0c532f10b510dab70b7d62b67ef8'");
}

// --- amc.FDb._db.StaticCheck
void amc::StaticCheck() {
    algo_assert(sizeof(amc::gen_step_hook) == 8); // csize:amc.gen_step_hook
    algo_assert(sizeof(amc::tclass_step_hook) == 8); // csize:amc.tclass_step_hook
    algo_assert(sizeof(amc::tfunc_step_hook) == 8); // csize:amc.tfunc_step_hook
    algo_assert(_offset_of(amc::FieldId, value) + sizeof(((amc::FieldId*)0)->value) == sizeof(amc::FieldId));
}

// --- amc.FDb._db.InsertStrptrMaybe
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool amc::InsertStrptrMaybe(algo::strptr str) {
    bool retval = true;
    amc::TableId table_id(-1);
    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
    switch (value_GetEnum(table_id)) {
        case amc_TableId_dmmeta_Fsort: { // finput:amc.FDb.fsort
            dmmeta::Fsort elem;
            retval = dmmeta::Fsort_ReadStrptrMaybe(elem, str);
            retval = retval && fsort_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Dispfilter: { // finput:amc.FDb.dispfilter
            dmmeta::Dispfilter elem;
            retval = dmmeta::Dispfilter_ReadStrptrMaybe(elem, str);
            retval = retval && dispfilter_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Usertracefld: { // finput:amc.FDb.usertracefld
            dmmeta::Usertracefld elem;
            retval = dmmeta::Usertracefld_ReadStrptrMaybe(elem, str);
            retval = retval && usertracefld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cfmt: { // finput:amc.FDb.cfmt
            dmmeta::Cfmt elem;
            retval = dmmeta::Cfmt_ReadStrptrMaybe(elem, str);
            retval = retval && cfmt_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Dispatch: { // finput:amc.FDb.dispatch
            dmmeta::Dispatch elem;
            retval = dmmeta::Dispatch_ReadStrptrMaybe(elem, str);
            retval = retval && dispatch_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_DispatchMsg: { // finput:amc.FDb.dispatch_msg
            dmmeta::DispatchMsg elem;
            retval = dmmeta::DispatchMsg_ReadStrptrMaybe(elem, str);
            retval = retval && dispatch_msg_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ctype: { // finput:amc.FDb.ctype
            dmmeta::Ctype elem;
            retval = dmmeta::Ctype_ReadStrptrMaybe(elem, str);
            retval = retval && ctype_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Field: { // finput:amc.FDb.field
            dmmeta::Field elem;
            retval = dmmeta::Field_ReadStrptrMaybe(elem, str);
            retval = retval && field_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Basepool: { // finput:amc.FDb.basepool
            dmmeta::Basepool elem;
            retval = dmmeta::Basepool_ReadStrptrMaybe(elem, str);
            retval = retval && basepool_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Llist: { // finput:amc.FDb.llist
            dmmeta::Llist elem;
            retval = dmmeta::Llist_ReadStrptrMaybe(elem, str);
            retval = retval && llist_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Anonfld: { // finput:amc.FDb.anonfld
            dmmeta::Anonfld elem;
            retval = dmmeta::Anonfld_ReadStrptrMaybe(elem, str);
            retval = retval && anonfld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Xref: { // finput:amc.FDb.xref
            dmmeta::Xref elem;
            retval = dmmeta::Xref_ReadStrptrMaybe(elem, str);
            retval = retval && xref_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ns: { // finput:amc.FDb.ns
            dmmeta::Ns elem;
            retval = dmmeta::Ns_ReadStrptrMaybe(elem, str);
            retval = retval && ns_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Pnew: { // finput:amc.FDb.pnew
            dmmeta::Pnew elem;
            retval = dmmeta::Pnew_ReadStrptrMaybe(elem, str);
            retval = retval && pnew_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fldoffset: { // finput:amc.FDb.fldoffset
            dmmeta::Fldoffset elem;
            retval = dmmeta::Fldoffset_ReadStrptrMaybe(elem, str);
            retval = retval && fldoffset_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Typefld: { // finput:amc.FDb.typefld
            dmmeta::Typefld elem;
            retval = dmmeta::Typefld_ReadStrptrMaybe(elem, str);
            retval = retval && typefld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Lenfld: { // finput:amc.FDb.lenfld
            dmmeta::Lenfld elem;
            retval = dmmeta::Lenfld_ReadStrptrMaybe(elem, str);
            retval = retval && lenfld_InputMaybe(elem);
            break;
        }
        case amc_TableId_amcdb_Bltin: { // finput:amc.FDb.bltin
            amcdb::Bltin elem;
            retval = amcdb::Bltin_ReadStrptrMaybe(elem, str);
            retval = retval && bltin_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Msgtype: { // finput:amc.FDb.msgtype
            dmmeta::Msgtype elem;
            retval = dmmeta::Msgtype_ReadStrptrMaybe(elem, str);
            retval = retval && msgtype_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Gconst: { // finput:amc.FDb.gconst
            dmmeta::Gconst elem;
            retval = dmmeta::Gconst_ReadStrptrMaybe(elem, str);
            retval = retval && gconst_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Gstatic: { // finput:amc.FDb.gstatic
            dmmeta::Gstatic elem;
            retval = dmmeta::Gstatic_ReadStrptrMaybe(elem, str);
            retval = retval && gstatic_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Thash: { // finput:amc.FDb.thash
            dmmeta::Thash elem;
            retval = dmmeta::Thash_ReadStrptrMaybe(elem, str);
            retval = retval && thash_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Func: { // finput:amc.FDb.func
            dmmeta::Func elem;
            retval = dmmeta::Func_ReadStrptrMaybe(elem, str);
            retval = retval && func_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Smallstr: { // finput:amc.FDb.smallstr
            dmmeta::Smallstr elem;
            retval = dmmeta::Smallstr_ReadStrptrMaybe(elem, str);
            retval = retval && smallstr_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Numstr: { // finput:amc.FDb.numstr
            dmmeta::Numstr elem;
            retval = dmmeta::Numstr_ReadStrptrMaybe(elem, str);
            retval = retval && numstr_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Main: { // finput:amc.FDb.main
            dmmeta::Main elem;
            retval = dmmeta::Main_ReadStrptrMaybe(elem, str);
            retval = retval && main_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cpptype: { // finput:amc.FDb.cpptype
            dmmeta::Cpptype elem;
            retval = dmmeta::Cpptype_ReadStrptrMaybe(elem, str);
            retval = retval && cpptype_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Inlary: { // finput:amc.FDb.inlary
            dmmeta::Inlary elem;
            retval = dmmeta::Inlary_ReadStrptrMaybe(elem, str);
            retval = retval && inlary_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Tary: { // finput:amc.FDb.tary
            dmmeta::Tary elem;
            retval = dmmeta::Tary_ReadStrptrMaybe(elem, str);
            retval = retval && tary_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cppfunc: { // finput:amc.FDb.cppfunc
            dmmeta::Cppfunc elem;
            retval = dmmeta::Cppfunc_ReadStrptrMaybe(elem, str);
            retval = retval && cppfunc_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Rowid: { // finput:amc.FDb.rowid
            dmmeta::Rowid elem;
            retval = dmmeta::Rowid_ReadStrptrMaybe(elem, str);
            retval = retval && rowid_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cascdel: { // finput:amc.FDb.cascdel
            dmmeta::Cascdel elem;
            retval = dmmeta::Cascdel_ReadStrptrMaybe(elem, str);
            retval = retval && cascdel_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Substr: { // finput:amc.FDb.substr
            dmmeta::Substr elem;
            retval = dmmeta::Substr_ReadStrptrMaybe(elem, str);
            retval = retval && substr_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Bitfld: { // finput:amc.FDb.bitfld
            dmmeta::Bitfld elem;
            retval = dmmeta::Bitfld_ReadStrptrMaybe(elem, str);
            retval = retval && bitfld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ssimfile: { // finput:amc.FDb.ssimfile
            dmmeta::Ssimfile elem;
            retval = dmmeta::Ssimfile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimfile_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Pack: { // finput:amc.FDb.pack
            dmmeta::Pack elem;
            retval = dmmeta::Pack_ReadStrptrMaybe(elem, str);
            retval = retval && pack_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ptrary: { // finput:amc.FDb.ptrary
            dmmeta::Ptrary elem;
            retval = dmmeta::Ptrary_ReadStrptrMaybe(elem, str);
            retval = retval && ptrary_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fbitset: { // finput:amc.FDb.fbitset
            dmmeta::Fbitset elem;
            retval = dmmeta::Fbitset_ReadStrptrMaybe(elem, str);
            retval = retval && fbitset_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcleanup: { // finput:amc.FDb.fcleanup
            dmmeta::Fcleanup elem;
            retval = dmmeta::Fcleanup_ReadStrptrMaybe(elem, str);
            retval = retval && fcleanup_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fdec: { // finput:amc.FDb.fdec
            dmmeta::Fdec elem;
            retval = dmmeta::Fdec_ReadStrptrMaybe(elem, str);
            retval = retval && fdec_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fconst: { // finput:amc.FDb.fconst
            dmmeta::Fconst elem;
            retval = dmmeta::Fconst_ReadStrptrMaybe(elem, str);
            retval = retval && fconst_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Finput: { // finput:amc.FDb.finput
            dmmeta::Finput elem;
            retval = dmmeta::Finput_ReadStrptrMaybe(elem, str);
            retval = retval && finput_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Foutput: { // finput:amc.FDb.foutput
            dmmeta::Foutput elem;
            retval = dmmeta::Foutput_ReadStrptrMaybe(elem, str);
            retval = retval && foutput_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fbuf: { // finput:amc.FDb.fbuf
            dmmeta::Fbuf elem;
            retval = dmmeta::Fbuf_ReadStrptrMaybe(elem, str);
            retval = retval && fbuf_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Chash: { // finput:amc.FDb.chash
            dmmeta::Chash elem;
            retval = dmmeta::Chash_ReadStrptrMaybe(elem, str);
            retval = retval && chash_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ccmp: { // finput:amc.FDb.ccmp
            dmmeta::Ccmp elem;
            retval = dmmeta::Ccmp_ReadStrptrMaybe(elem, str);
            retval = retval && ccmp_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fbigend: { // finput:amc.FDb.fbigend
            dmmeta::Fbigend elem;
            retval = dmmeta::Fbigend_ReadStrptrMaybe(elem, str);
            retval = retval && fbigend_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cstr: { // finput:amc.FDb.cstr
            dmmeta::Cstr elem;
            retval = dmmeta::Cstr_ReadStrptrMaybe(elem, str);
            retval = retval && cstr_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Listtype: { // finput:amc.FDb.listtype
            dmmeta::Listtype elem;
            retval = dmmeta::Listtype_ReadStrptrMaybe(elem, str);
            retval = retval && listtype_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fstep: { // finput:amc.FDb.fstep
            dmmeta::Fstep elem;
            retval = dmmeta::Fstep_ReadStrptrMaybe(elem, str);
            retval = retval && fstep_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cextern: { // finput:amc.FDb.cextern
            dmmeta::Cextern elem;
            retval = dmmeta::Cextern_ReadStrptrMaybe(elem, str);
            retval = retval && cextern_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fdelay: { // finput:amc.FDb.fdelay
            dmmeta::Fdelay elem;
            retval = dmmeta::Fdelay_ReadStrptrMaybe(elem, str);
            retval = retval && fdelay_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Disptrace: { // finput:amc.FDb.disptrace
            dmmeta::Disptrace elem;
            retval = dmmeta::Disptrace_ReadStrptrMaybe(elem, str);
            retval = retval && disptrace_InputMaybe(elem);
            break;
        }
        case amc_TableId_dev_Target: { // finput:amc.FDb.target
            dev::Target elem;
            retval = dev::Target_ReadStrptrMaybe(elem, str);
            retval = retval && target_InputMaybe(elem);
            break;
        }
        case amc_TableId_dev_Targdep: { // finput:amc.FDb.targdep
            dev::Targdep elem;
            retval = dev::Targdep_ReadStrptrMaybe(elem, str);
            retval = retval && targdep_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Dispctx: { // finput:amc.FDb.dispctx
            dmmeta::Dispctx elem;
            retval = dmmeta::Dispctx_ReadStrptrMaybe(elem, str);
            retval = retval && dispctx_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Pmaskfld: { // finput:amc.FDb.pmaskfld
            dmmeta::Pmaskfld elem;
            retval = dmmeta::Pmaskfld_ReadStrptrMaybe(elem, str);
            retval = retval && pmaskfld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fwddecl: { // finput:amc.FDb.fwddecl
            dmmeta::Fwddecl elem;
            retval = dmmeta::Fwddecl_ReadStrptrMaybe(elem, str);
            retval = retval && fwddecl_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fregx: { // finput:amc.FDb.fregx
            dmmeta::Fregx elem;
            retval = dmmeta::Fregx_ReadStrptrMaybe(elem, str);
            retval = retval && fregx_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcmp: { // finput:amc.FDb.fcmp
            dmmeta::Fcmp elem;
            retval = dmmeta::Fcmp_ReadStrptrMaybe(elem, str);
            retval = retval && fcmp_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcast: { // finput:amc.FDb.fcast
            dmmeta::Fcast elem;
            retval = dmmeta::Fcast_ReadStrptrMaybe(elem, str);
            retval = retval && fcast_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Noxref: { // finput:amc.FDb.noxref
            dmmeta::Noxref elem;
            retval = dmmeta::Noxref_ReadStrptrMaybe(elem, str);
            retval = retval && noxref_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nocascdel: { // finput:amc.FDb.nocascdel
            dmmeta::Nocascdel elem;
            retval = dmmeta::Nocascdel_ReadStrptrMaybe(elem, str);
            retval = retval && nocascdel_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cafter: { // finput:amc.FDb.cafter
            dmmeta::Cafter elem;
            retval = dmmeta::Cafter_ReadStrptrMaybe(elem, str);
            retval = retval && cafter_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Csize: { // finput:amc.FDb.csize
            dmmeta::Csize elem;
            retval = dmmeta::Csize_ReadStrptrMaybe(elem, str);
            retval = retval && csize_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nsx: { // finput:amc.FDb.nsx
            dmmeta::Nsx elem;
            retval = dmmeta::Nsx_ReadStrptrMaybe(elem, str);
            retval = retval && nsx_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcompact: { // finput:amc.FDb.fcompact
            dmmeta::Fcompact elem;
            retval = dmmeta::Fcompact_ReadStrptrMaybe(elem, str);
            retval = retval && fcompact_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Findrem: { // finput:amc.FDb.findrem
            dmmeta::Findrem elem;
            retval = dmmeta::Findrem_ReadStrptrMaybe(elem, str);
            retval = retval && findrem_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcurs: { // finput:amc.FDb.fcurs
            dmmeta::Fcurs elem;
            retval = dmmeta::Fcurs_ReadStrptrMaybe(elem, str);
            retval = retval && fcurs_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cdflt: { // finput:amc.FDb.cdflt
            dmmeta::Cdflt elem;
            retval = dmmeta::Cdflt_ReadStrptrMaybe(elem, str);
            retval = retval && cdflt_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Argvtype: { // finput:amc.FDb.argvtype
            dmmeta::Argvtype elem;
            retval = dmmeta::Argvtype_ReadStrptrMaybe(elem, str);
            retval = retval && argvtype_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcmdline: { // finput:amc.FDb.fcmdline
            dmmeta::Fcmdline elem;
            retval = dmmeta::Fcmdline_ReadStrptrMaybe(elem, str);
            retval = retval && fcmdline_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Floadtuples: { // finput:amc.FDb.floadtuples
            dmmeta::Floadtuples elem;
            retval = dmmeta::Floadtuples_ReadStrptrMaybe(elem, str);
            retval = retval && floadtuples_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fcmap: { // finput:amc.FDb.fcmap
            dmmeta::Fcmap elem;
            retval = dmmeta::Fcmap_ReadStrptrMaybe(elem, str);
            retval = retval && fcmap_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nsproto: { // finput:amc.FDb.nsproto
            dmmeta::Nsproto elem;
            retval = dmmeta::Nsproto_ReadStrptrMaybe(elem, str);
            retval = retval && nsproto_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nsdb: { // finput:amc.FDb.nsdb
            dmmeta::Nsdb elem;
            retval = dmmeta::Nsdb_ReadStrptrMaybe(elem, str);
            retval = retval && nsdb_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fprefix: { // finput:amc.FDb.fprefix
            dmmeta::Fprefix elem;
            retval = dmmeta::Fprefix_ReadStrptrMaybe(elem, str);
            retval = retval && fprefix_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ftrace: { // finput:amc.FDb.ftrace
            dmmeta::Ftrace elem;
            retval = dmmeta::Ftrace_ReadStrptrMaybe(elem, str);
            retval = retval && ftrace_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fnoremove: { // finput:amc.FDb.fnoremove
            dmmeta::Fnoremove elem;
            retval = dmmeta::Fnoremove_ReadStrptrMaybe(elem, str);
            retval = retval && fnoremove_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fbase: { // finput:amc.FDb.fbase
            dmmeta::Fbase elem;
            retval = dmmeta::Fbase_ReadStrptrMaybe(elem, str);
            retval = retval && fbase_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nossimfile: { // finput:amc.FDb.nossimfile
            dmmeta::Nossimfile elem;
            retval = dmmeta::Nossimfile_ReadStrptrMaybe(elem, str);
            retval = retval && nossimfile_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Gsymbol: { // finput:amc.FDb.gsymbol
            dmmeta::Gsymbol elem;
            retval = dmmeta::Gsymbol_ReadStrptrMaybe(elem, str);
            retval = retval && gsymbol_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Sortfld: { // finput:amc.FDb.sortfld
            dmmeta::Sortfld elem;
            retval = dmmeta::Sortfld_ReadStrptrMaybe(elem, str);
            retval = retval && sortfld_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Cget: { // finput:amc.FDb.cget
            dmmeta::Cget elem;
            retval = dmmeta::Cget_ReadStrptrMaybe(elem, str);
            retval = retval && cget_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Hook: { // finput:amc.FDb.hook
            dmmeta::Hook elem;
            retval = dmmeta::Hook_ReadStrptrMaybe(elem, str);
            retval = retval && hook_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Charset: { // finput:amc.FDb.charset
            dmmeta::Charset elem;
            retval = dmmeta::Charset_ReadStrptrMaybe(elem, str);
            retval = retval && charset_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Nsinclude: { // finput:amc.FDb.nsinclude
            dmmeta::Nsinclude elem;
            retval = dmmeta::Nsinclude_ReadStrptrMaybe(elem, str);
            retval = retval && nsinclude_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Ssimvolatile: { // finput:amc.FDb.ssimvolatile
            dmmeta::Ssimvolatile elem;
            retval = dmmeta::Ssimvolatile_ReadStrptrMaybe(elem, str);
            retval = retval && ssimvolatile_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Funique: { // finput:amc.FDb.funique
            dmmeta::Funique elem;
            retval = dmmeta::Funique_ReadStrptrMaybe(elem, str);
            retval = retval && funique_InputMaybe(elem);
            break;
        }
        case amc_TableId_dmmeta_Fuserinit: { // finput:amc.FDb.fuserinit
            dmmeta::Fuserinit elem;
            retval = dmmeta::Fuserinit_ReadStrptrMaybe(elem, str);
            retval = retval && fuserinit_InputMaybe(elem);
            break;
        }
        case amc_TableId_amcdb_Tcurs: { // finput:amc.FDb.tcurs
            amcdb::Tcurs elem;
            retval = amcdb::Tcurs_ReadStrptrMaybe(elem, str);
            retval = retval && tcurs_InputMaybe(elem);
            break;
        }
        default:
        retval = algo_lib::InsertStrptrMaybe(str);
        break;
    } //switch
    if (!retval) {
        algo_lib::NoteInsertErr(str); // increment error counter
    }
    return retval;
}

// --- amc.FDb._db.LoadTuplesMaybe
// Load all finputs from given directory.
bool amc::LoadTuplesMaybe(algo::strptr root) {
    bool retval = true;
    static const char *ssimfiles[] = {
        "dmmeta.ns", "dmmeta.ctype", "dmmeta.field", "dmmeta.anonfld"
        , "dmmeta.argvtype", "dmmeta.basepool", "dmmeta.bitfld", "amcdb.bltin"
        , "dmmeta.cafter", "dmmeta.cascdel", "dmmeta.ccmp", "dmmeta.cdflt"
        , "dmmeta.cextern", "dmmeta.cfmt", "dmmeta.cget", "dmmeta.charset"
        , "dmmeta.chash", "dmmeta.cppfunc", "dmmeta.cpptype", "dmmeta.csize"
        , "dmmeta.cstr", "dmmeta.dispatch", "dmmeta.dispatch_msg", "dmmeta.dispctx"
        , "dmmeta.dispfilter", "dmmeta.disptrace", "dmmeta.fbase", "dmmeta.fbigend"
        , "dmmeta.fbitset", "dmmeta.fbuf", "dmmeta.fcast", "dmmeta.fcleanup"
        , "dmmeta.fcmap", "dmmeta.fcmdline", "dmmeta.fcmp", "dmmeta.fcompact"
        , "dmmeta.fconst", "dmmeta.fcurs", "dmmeta.fdec", "dmmeta.fstep"
        , "dmmeta.fdelay", "dmmeta.findrem", "dmmeta.finput", "dmmeta.fldoffset"
        , "dmmeta.floadtuples", "dmmeta.fnoremove", "dmmeta.foutput", "dmmeta.fprefix"
        , "dmmeta.fregx", "dmmeta.fsort", "dmmeta.ftrace", "dmmeta.funique"
        , "dmmeta.fuserinit", "dmmeta.fwddecl", "dmmeta.gconst", "dmmeta.gstatic"
        , "dmmeta.ssimfile", "dmmeta.gsymbol", "dmmeta.hook", "dmmeta.inlary"
        , "dmmeta.lenfld", "dmmeta.listtype", "dmmeta.llist", "dmmeta.main"
        , "dmmeta.msgtype", "dmmeta.xref", "dmmeta.nocascdel", "dmmeta.nossimfile"
        , "dmmeta.noxref", "dmmeta.nsdb", "dmmeta.nsinclude", "dmmeta.nsproto"
        , "dmmeta.nsx", "dmmeta.smallstr", "dmmeta.numstr", "dmmeta.pack"
        , "dmmeta.pmaskfld", "dmmeta.pnew", "dmmeta.ptrary", "dmmeta.rowid"
        , "dmmeta.sortfld", "dmmeta.ssimvolatile", "dmmeta.substr", "dev.target"
        , "dev.targdep", "dmmeta.tary", "amcdb.tcurs", "dmmeta.thash"
        , "dmmeta.typefld", "dmmeta.usertracefld"
        , NULL};
        retval = algo_lib::DoLoadTuples(root, amc::InsertStrptrMaybe, ssimfiles, true);
        return retval;
}

// --- amc.FDb._db.SaveTuples
// Save ssim data to given directory.
u32 amc::SaveTuples(algo::strptr root) {
    u32 retval = 0;
    u32 nbefore = algo_lib::_db.stringtofile_nwrite;
    (void)tracefld_SaveSsimfile(SsimFname(root, "dmmeta.tracefld"));
    (void)tracerec_SaveSsimfile(SsimFname(root, "dmmeta.tracerec"));
    (void)c_dispsig_sorted_SaveSsimfile(SsimFname(root, "dmmeta.dispsig"));
    (void)c_ctypelen_SaveSsimfile(SsimFname(root, "dmmeta.ctypelen"));
    retval = algo_lib::_db.stringtofile_nwrite - nbefore;
    return retval;
}

// --- amc.FDb._db.LoadSsimfileMaybe
// Load specified ssimfile.
bool amc::LoadSsimfileMaybe(algo::strptr fname) {
    bool retval = true;
    if (FileQ(fname)) {
        retval = algo_lib::LoadTuplesFile(fname, amc::InsertStrptrMaybe, true);
    }
    return retval;
}

// --- amc.FDb._db.Steps
// Calls Step function of dependencies
void amc::Steps() {
    algo_lib::Step(); // dependent namespace specified via (dev.targdep)
}

// --- amc.FDb._db.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::_db_XrefMaybe() {
    bool retval = true;
    return retval;
}

// --- amc.FDb.ind_bltin.Find
// Find row by key. Return NULL if not found.
amc::FBltin* amc::ind_bltin_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_bltin_buckets_n - 1);
    amc::FBltin* *e = &_db.ind_bltin_buckets_elems[index];
    amc::FBltin* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_bltin_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_bltin.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FBltin& amc::ind_bltin_GetOrCreate(const algo::strptr& key) {
    amc::FBltin* ret = ind_bltin_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &bltin_Alloc();
        (*ret).ctype = key;
        bool good = bltin_XrefMaybe(*ret);
        if (!good) {
            bltin_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_bltin  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_bltin.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_bltin_InsertMaybe(amc::FBltin& row) {
    ind_bltin_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_bltin_next == (amc::FBltin*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_bltin_buckets_n - 1);
        amc::FBltin* *prev = &_db.ind_bltin_buckets_elems[index];
        do {
            amc::FBltin* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_bltin_next;
        } while (true);
        if (retval) {
            row.ind_bltin_next = *prev;
            _db.ind_bltin_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_bltin.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_bltin_Remove(amc::FBltin& row) {
    if (LIKELY(row.ind_bltin_next != (amc::FBltin*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_bltin_buckets_n - 1);
        amc::FBltin* *prev = &_db.ind_bltin_buckets_elems[index]; // addr of pointer to current element
        while (amc::FBltin *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_bltin_next; // unlink (singly linked list)
                _db.ind_bltin_n--;
                row.ind_bltin_next = (amc::FBltin*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_bltin_next;
        }
    }
}

// --- amc.FDb.ind_bltin.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_bltin_Reserve(int n) {
    u32 old_nbuckets = _db.ind_bltin_buckets_n;
    u32 new_nelems   = _db.ind_bltin_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FBltin*);
        u32 new_size = new_nbuckets * sizeof(amc::FBltin*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FBltin* *new_buckets = (amc::FBltin**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_bltin");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_bltin_buckets_n; i++) {
            amc::FBltin* elem = _db.ind_bltin_buckets_elems[i];
            while (elem) {
                amc::FBltin &row        = *elem;
                amc::FBltin* next       = row.ind_bltin_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_bltin_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_bltin_buckets_elems, old_size);
        _db.ind_bltin_buckets_elems = new_buckets;
        _db.ind_bltin_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_ctype.Find
// Find row by key. Return NULL if not found.
amc::FCtype* amc::ind_ctype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ctype_buckets_n - 1);
    amc::FCtype* *e = &_db.ind_ctype_buckets_elems[index];
    amc::FCtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ctype_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_ctype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCtype& amc::ind_ctype_GetOrCreate(const algo::strptr& key) {
    amc::FCtype* ret = ind_ctype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ctype_Alloc();
        (*ret).ctype = key;
        bool good = ctype_XrefMaybe(*ret);
        if (!good) {
            ctype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_ctype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_ctype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_ctype_InsertMaybe(amc::FCtype& row) {
    ind_ctype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ctype_next == (amc::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        amc::FCtype* *prev = &_db.ind_ctype_buckets_elems[index];
        do {
            amc::FCtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ctype_next;
        } while (true);
        if (retval) {
            row.ind_ctype_next = *prev;
            _db.ind_ctype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ctype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_ctype_Remove(amc::FCtype& row) {
    if (LIKELY(row.ind_ctype_next != (amc::FCtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ctype_buckets_n - 1);
        amc::FCtype* *prev = &_db.ind_ctype_buckets_elems[index]; // addr of pointer to current element
        while (amc::FCtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ctype_next; // unlink (singly linked list)
                _db.ind_ctype_n--;
                row.ind_ctype_next = (amc::FCtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ctype_next;
        }
    }
}

// --- amc.FDb.ind_ctype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_ctype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ctype_buckets_n;
    u32 new_nelems   = _db.ind_ctype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FCtype*);
        u32 new_size = new_nbuckets * sizeof(amc::FCtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FCtype* *new_buckets = (amc::FCtype**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_ctype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ctype_buckets_n; i++) {
            amc::FCtype* elem = _db.ind_ctype_buckets_elems[i];
            while (elem) {
                amc::FCtype &row        = *elem;
                amc::FCtype* next       = row.ind_ctype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ctype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_ctype_buckets_elems, old_size);
        _db.ind_ctype_buckets_elems = new_buckets;
        _db.ind_ctype_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_dispatch.Find
// Find row by key. Return NULL if not found.
amc::FDispatch* amc::ind_dispatch_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_dispatch_buckets_n - 1);
    amc::FDispatch* *e = &_db.ind_dispatch_buckets_elems[index];
    amc::FDispatch* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).dispatch == key;
        if (done) break;
        e         = &ret->ind_dispatch_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_dispatch.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FDispatch& amc::ind_dispatch_GetOrCreate(const algo::strptr& key) {
    amc::FDispatch* ret = ind_dispatch_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &dispatch_Alloc();
        (*ret).dispatch = key;
        bool good = dispatch_XrefMaybe(*ret);
        if (!good) {
            dispatch_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_dispatch  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_dispatch.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_dispatch_InsertMaybe(amc::FDispatch& row) {
    ind_dispatch_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_dispatch_next == (amc::FDispatch*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.dispatch) & (_db.ind_dispatch_buckets_n - 1);
        amc::FDispatch* *prev = &_db.ind_dispatch_buckets_elems[index];
        do {
            amc::FDispatch* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).dispatch == row.dispatch) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_dispatch_next;
        } while (true);
        if (retval) {
            row.ind_dispatch_next = *prev;
            _db.ind_dispatch_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_dispatch.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_dispatch_Remove(amc::FDispatch& row) {
    if (LIKELY(row.ind_dispatch_next != (amc::FDispatch*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.dispatch) & (_db.ind_dispatch_buckets_n - 1);
        amc::FDispatch* *prev = &_db.ind_dispatch_buckets_elems[index]; // addr of pointer to current element
        while (amc::FDispatch *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_dispatch_next; // unlink (singly linked list)
                _db.ind_dispatch_n--;
                row.ind_dispatch_next = (amc::FDispatch*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_dispatch_next;
        }
    }
}

// --- amc.FDb.ind_dispatch.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_dispatch_Reserve(int n) {
    u32 old_nbuckets = _db.ind_dispatch_buckets_n;
    u32 new_nelems   = _db.ind_dispatch_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FDispatch*);
        u32 new_size = new_nbuckets * sizeof(amc::FDispatch*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FDispatch* *new_buckets = (amc::FDispatch**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_dispatch");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_dispatch_buckets_n; i++) {
            amc::FDispatch* elem = _db.ind_dispatch_buckets_elems[i];
            while (elem) {
                amc::FDispatch &row        = *elem;
                amc::FDispatch* next       = row.ind_dispatch_next;
                u32 index          = algo::Smallstr50_Hash(0, row.dispatch) & (new_nbuckets-1);
                row.ind_dispatch_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_dispatch_buckets_elems, old_size);
        _db.ind_dispatch_buckets_elems = new_buckets;
        _db.ind_dispatch_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_func.Find
// Find row by key. Return NULL if not found.
amc::FFunc* amc::ind_func_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_func_buckets_n - 1);
    amc::FFunc* *e = &_db.ind_func_buckets_elems[index];
    amc::FFunc* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).func == key;
        if (done) break;
        e         = &ret->ind_func_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_func.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFunc& amc::ind_func_GetOrCreate(const algo::strptr& key) {
    amc::FFunc* ret = ind_func_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &func_Alloc();
        (*ret).func = key;
        bool good = func_XrefMaybe(*ret);
        if (!good) {
            func_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_func  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_func.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_func_InsertMaybe(amc::FFunc& row) {
    ind_func_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_func_next == (amc::FFunc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.func) & (_db.ind_func_buckets_n - 1);
        amc::FFunc* *prev = &_db.ind_func_buckets_elems[index];
        do {
            amc::FFunc* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).func == row.func) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_func_next;
        } while (true);
        if (retval) {
            row.ind_func_next = *prev;
            _db.ind_func_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_func.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_func_Remove(amc::FFunc& row) {
    if (LIKELY(row.ind_func_next != (amc::FFunc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.func) & (_db.ind_func_buckets_n - 1);
        amc::FFunc* *prev = &_db.ind_func_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFunc *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_func_next; // unlink (singly linked list)
                _db.ind_func_n--;
                row.ind_func_next = (amc::FFunc*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_func_next;
        }
    }
}

// --- amc.FDb.ind_func.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_func_Reserve(int n) {
    u32 old_nbuckets = _db.ind_func_buckets_n;
    u32 new_nelems   = _db.ind_func_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFunc*);
        u32 new_size = new_nbuckets * sizeof(amc::FFunc*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFunc* *new_buckets = (amc::FFunc**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_func");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_func_buckets_n; i++) {
            amc::FFunc* elem = _db.ind_func_buckets_elems[i];
            while (elem) {
                amc::FFunc &row        = *elem;
                amc::FFunc* next       = row.ind_func_next;
                u32 index          = algo::Smallstr100_Hash(0, row.func) & (new_nbuckets-1);
                row.ind_func_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_func_buckets_elems, old_size);
        _db.ind_func_buckets_elems = new_buckets;
        _db.ind_func_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_field.Find
// Find row by key. Return NULL if not found.
amc::FField* amc::ind_field_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_field_buckets_n - 1);
    amc::FField* *e = &_db.ind_field_buckets_elems[index];
    amc::FField* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_field_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_field.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_field_InsertMaybe(amc::FField& row) {
    ind_field_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_field_next == (amc::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        amc::FField* *prev = &_db.ind_field_buckets_elems[index];
        do {
            amc::FField* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_field_next;
        } while (true);
        if (retval) {
            row.ind_field_next = *prev;
            _db.ind_field_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_field.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_field_Remove(amc::FField& row) {
    if (LIKELY(row.ind_field_next != (amc::FField*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_field_buckets_n - 1);
        amc::FField* *prev = &_db.ind_field_buckets_elems[index]; // addr of pointer to current element
        while (amc::FField *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_field_next; // unlink (singly linked list)
                _db.ind_field_n--;
                row.ind_field_next = (amc::FField*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_field_next;
        }
    }
}

// --- amc.FDb.ind_field.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_field_Reserve(int n) {
    u32 old_nbuckets = _db.ind_field_buckets_n;
    u32 new_nelems   = _db.ind_field_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FField*);
        u32 new_size = new_nbuckets * sizeof(amc::FField*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FField* *new_buckets = (amc::FField**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_field");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_field_buckets_n; i++) {
            amc::FField* elem = _db.ind_field_buckets_elems[i];
            while (elem) {
                amc::FField &row        = *elem;
                amc::FField* next       = row.ind_field_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_field_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_field_buckets_elems, old_size);
        _db.ind_field_buckets_elems = new_buckets;
        _db.ind_field_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_ns.Find
// Find row by key. Return NULL if not found.
amc::FNs* amc::ind_ns_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_ns_buckets_n - 1);
    amc::FNs* *e = &_db.ind_ns_buckets_elems[index];
    amc::FNs* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_ns_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_ns.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FNs& amc::ind_ns_GetOrCreate(const algo::strptr& key) {
    amc::FNs* ret = ind_ns_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ns_Alloc();
        (*ret).ns = key;
        bool good = ns_XrefMaybe(*ret);
        if (!good) {
            ns_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_ns  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_ns.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_ns_InsertMaybe(amc::FNs& row) {
    ind_ns_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ns_next == (amc::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        amc::FNs* *prev = &_db.ind_ns_buckets_elems[index];
        do {
            amc::FNs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ns_next;
        } while (true);
        if (retval) {
            row.ind_ns_next = *prev;
            _db.ind_ns_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ns.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_ns_Remove(amc::FNs& row) {
    if (LIKELY(row.ind_ns_next != (amc::FNs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_ns_buckets_n - 1);
        amc::FNs* *prev = &_db.ind_ns_buckets_elems[index]; // addr of pointer to current element
        while (amc::FNs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ns_next; // unlink (singly linked list)
                _db.ind_ns_n--;
                row.ind_ns_next = (amc::FNs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ns_next;
        }
    }
}

// --- amc.FDb.ind_ns.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_ns_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ns_buckets_n;
    u32 new_nelems   = _db.ind_ns_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FNs*);
        u32 new_size = new_nbuckets * sizeof(amc::FNs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FNs* *new_buckets = (amc::FNs**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_ns");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ns_buckets_n; i++) {
            amc::FNs* elem = _db.ind_ns_buckets_elems[i];
            while (elem) {
                amc::FNs &row        = *elem;
                amc::FNs* next       = row.ind_ns_next;
                u32 index          = algo::Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_ns_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_ns_buckets_elems, old_size);
        _db.ind_ns_buckets_elems = new_buckets;
        _db.ind_ns_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_pnew.Find
// Find row by key. Return NULL if not found.
amc::FPnew* amc::ind_pnew_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_pnew_buckets_n - 1);
    amc::FPnew* *e = &_db.ind_pnew_buckets_elems[index];
    amc::FPnew* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).pnew == key;
        if (done) break;
        e         = &ret->ind_pnew_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_pnew.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FPnew& amc::ind_pnew_GetOrCreate(const algo::strptr& key) {
    amc::FPnew* ret = ind_pnew_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &pnew_Alloc();
        (*ret).pnew = key;
        bool good = pnew_XrefMaybe(*ret);
        if (!good) {
            pnew_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_pnew  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_pnew.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_pnew_InsertMaybe(amc::FPnew& row) {
    ind_pnew_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_pnew_next == (amc::FPnew*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.pnew) & (_db.ind_pnew_buckets_n - 1);
        amc::FPnew* *prev = &_db.ind_pnew_buckets_elems[index];
        do {
            amc::FPnew* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).pnew == row.pnew) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_pnew_next;
        } while (true);
        if (retval) {
            row.ind_pnew_next = *prev;
            _db.ind_pnew_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_pnew.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_pnew_Remove(amc::FPnew& row) {
    if (LIKELY(row.ind_pnew_next != (amc::FPnew*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.pnew) & (_db.ind_pnew_buckets_n - 1);
        amc::FPnew* *prev = &_db.ind_pnew_buckets_elems[index]; // addr of pointer to current element
        while (amc::FPnew *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_pnew_next; // unlink (singly linked list)
                _db.ind_pnew_n--;
                row.ind_pnew_next = (amc::FPnew*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_pnew_next;
        }
    }
}

// --- amc.FDb.ind_pnew.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_pnew_Reserve(int n) {
    u32 old_nbuckets = _db.ind_pnew_buckets_n;
    u32 new_nelems   = _db.ind_pnew_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FPnew*);
        u32 new_size = new_nbuckets * sizeof(amc::FPnew*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FPnew* *new_buckets = (amc::FPnew**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_pnew");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_pnew_buckets_n; i++) {
            amc::FPnew* elem = _db.ind_pnew_buckets_elems[i];
            while (elem) {
                amc::FPnew &row        = *elem;
                amc::FPnew* next       = row.ind_pnew_next;
                u32 index          = algo::Smallstr100_Hash(0, row.pnew) & (new_nbuckets-1);
                row.ind_pnew_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_pnew_buckets_elems, old_size);
        _db.ind_pnew_buckets_elems = new_buckets;
        _db.ind_pnew_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_xref.Find
// Find row by key. Return NULL if not found.
amc::FXref* amc::ind_xref_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_xref_buckets_n - 1);
    amc::FXref* *e = &_db.ind_xref_buckets_elems[index];
    amc::FXref* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_xref_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_xref.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FXref& amc::ind_xref_GetOrCreate(const algo::strptr& key) {
    amc::FXref* ret = ind_xref_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &xref_Alloc();
        (*ret).field = key;
        bool good = xref_XrefMaybe(*ret);
        if (!good) {
            xref_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_xref  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_xref.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_xref_InsertMaybe(amc::FXref& row) {
    ind_xref_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_xref_next == (amc::FXref*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_xref_buckets_n - 1);
        amc::FXref* *prev = &_db.ind_xref_buckets_elems[index];
        do {
            amc::FXref* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_xref_next;
        } while (true);
        if (retval) {
            row.ind_xref_next = *prev;
            _db.ind_xref_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_xref.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_xref_Remove(amc::FXref& row) {
    if (LIKELY(row.ind_xref_next != (amc::FXref*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_xref_buckets_n - 1);
        amc::FXref* *prev = &_db.ind_xref_buckets_elems[index]; // addr of pointer to current element
        while (amc::FXref *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_xref_next; // unlink (singly linked list)
                _db.ind_xref_n--;
                row.ind_xref_next = (amc::FXref*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_xref_next;
        }
    }
}

// --- amc.FDb.ind_xref.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_xref_Reserve(int n) {
    u32 old_nbuckets = _db.ind_xref_buckets_n;
    u32 new_nelems   = _db.ind_xref_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FXref*);
        u32 new_size = new_nbuckets * sizeof(amc::FXref*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FXref* *new_buckets = (amc::FXref**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_xref");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_xref_buckets_n; i++) {
            amc::FXref* elem = _db.ind_xref_buckets_elems[i];
            while (elem) {
                amc::FXref &row        = *elem;
                amc::FXref* next       = row.ind_xref_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_xref_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_xref_buckets_elems, old_size);
        _db.ind_xref_buckets_elems = new_buckets;
        _db.ind_xref_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.cpptype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCpptype& amc::cpptype_Alloc() {
    amc::FCpptype* row = cpptype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cpptype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cpptype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCpptype* amc::cpptype_AllocMaybe() {
    amc::FCpptype *row = (amc::FCpptype*)cpptype_AllocMem();
    if (row) {
        new (row) amc::FCpptype; // call constructor
    }
    return row;
}

// --- amc.FDb.cpptype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCpptype* amc::cpptype_InsertMaybe(const dmmeta::Cpptype &value) {
    amc::FCpptype *row = &cpptype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cpptype_CopyIn(*row,const_cast<dmmeta::Cpptype&>(value));
    bool ok = cpptype_XrefMaybe(*row); // this may return false
    if (!ok) {
        cpptype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cpptype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cpptype_AllocMem() {
    u64 new_nelems     = _db.cpptype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCpptype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cpptype_lary[bsr];
        if (!lev) {
            lev=(amc::FCpptype*)amc::lpool_AllocMem(sizeof(amc::FCpptype) * (u64(1)<<bsr));
            _db.cpptype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cpptype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cpptype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cpptype_RemoveLast() {
    u64 n = _db.cpptype_n;
    if (n > 0) {
        n -= 1;
        cpptype_qFind(u64(n)).~FCpptype();
        _db.cpptype_n = i32(n);
    }
}

// --- amc.FDb.cpptype.InputMaybe
static bool amc::cpptype_InputMaybe(dmmeta::Cpptype &elem) {
    bool retval = true;
    retval = cpptype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cpptype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cpptype_XrefMaybe(amc::FCpptype &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // cpptype: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert cpptype into index ind_cpptype
    if (true) { // user-defined insert condition
        bool success = ind_cpptype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_cpptype"; // check for duplicate key
            return false;
        }
    }
    // insert cpptype into index c_cpptype
    if (true) { // user-defined insert condition
        bool success = c_cpptype_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_cpptype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_cpptype.Find
// Find row by key. Return NULL if not found.
amc::FCpptype* amc::ind_cpptype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_cpptype_buckets_n - 1);
    amc::FCpptype* *e = &_db.ind_cpptype_buckets_elems[index];
    amc::FCpptype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_cpptype_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_cpptype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCpptype& amc::ind_cpptype_GetOrCreate(const algo::strptr& key) {
    amc::FCpptype* ret = ind_cpptype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &cpptype_Alloc();
        (*ret).ctype = key;
        bool good = cpptype_XrefMaybe(*ret);
        if (!good) {
            cpptype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_cpptype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_cpptype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_cpptype_InsertMaybe(amc::FCpptype& row) {
    ind_cpptype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_cpptype_next == (amc::FCpptype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_cpptype_buckets_n - 1);
        amc::FCpptype* *prev = &_db.ind_cpptype_buckets_elems[index];
        do {
            amc::FCpptype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_cpptype_next;
        } while (true);
        if (retval) {
            row.ind_cpptype_next = *prev;
            _db.ind_cpptype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_cpptype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_cpptype_Remove(amc::FCpptype& row) {
    if (LIKELY(row.ind_cpptype_next != (amc::FCpptype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_cpptype_buckets_n - 1);
        amc::FCpptype* *prev = &_db.ind_cpptype_buckets_elems[index]; // addr of pointer to current element
        while (amc::FCpptype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_cpptype_next; // unlink (singly linked list)
                _db.ind_cpptype_n--;
                row.ind_cpptype_next = (amc::FCpptype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_cpptype_next;
        }
    }
}

// --- amc.FDb.ind_cpptype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_cpptype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_cpptype_buckets_n;
    u32 new_nelems   = _db.ind_cpptype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FCpptype*);
        u32 new_size = new_nbuckets * sizeof(amc::FCpptype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FCpptype* *new_buckets = (amc::FCpptype**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_cpptype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_cpptype_buckets_n; i++) {
            amc::FCpptype* elem = _db.ind_cpptype_buckets_elems[i];
            while (elem) {
                amc::FCpptype &row        = *elem;
                amc::FCpptype* next       = row.ind_cpptype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_cpptype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_cpptype_buckets_elems, old_size);
        _db.ind_cpptype_buckets_elems = new_buckets;
        _db.ind_cpptype_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.inlary.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FInlary& amc::inlary_Alloc() {
    amc::FInlary* row = inlary_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.inlary  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.inlary.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FInlary* amc::inlary_AllocMaybe() {
    amc::FInlary *row = (amc::FInlary*)inlary_AllocMem();
    if (row) {
        new (row) amc::FInlary; // call constructor
    }
    return row;
}

// --- amc.FDb.inlary.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FInlary* amc::inlary_InsertMaybe(const dmmeta::Inlary &value) {
    amc::FInlary *row = &inlary_Alloc(); // if out of memory, process dies. if input error, return NULL.
    inlary_CopyIn(*row,const_cast<dmmeta::Inlary&>(value));
    bool ok = inlary_XrefMaybe(*row); // this may return false
    if (!ok) {
        inlary_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.inlary.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::inlary_AllocMem() {
    u64 new_nelems     = _db.inlary_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FInlary*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.inlary_lary[bsr];
        if (!lev) {
            lev=(amc::FInlary*)amc::lpool_AllocMem(sizeof(amc::FInlary) * (u64(1)<<bsr));
            _db.inlary_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.inlary_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.inlary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::inlary_RemoveLast() {
    u64 n = _db.inlary_n;
    if (n > 0) {
        n -= 1;
        inlary_qFind(u64(n)).~FInlary();
        _db.inlary_n = i32(n);
    }
}

// --- amc.FDb.inlary.InputMaybe
static bool amc::inlary_InputMaybe(dmmeta::Inlary &elem) {
    bool retval = true;
    retval = inlary_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.inlary.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::inlary_XrefMaybe(amc::FInlary &row) {
    bool retval = true;
    (void)row;
    // insert inlary into index ind_inlary
    if (true) { // user-defined insert condition
        bool success = ind_inlary_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_inlary"; // check for duplicate key
            return false;
        }
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert inlary into index c_inlary
    if (true) { // user-defined insert condition
        bool success = c_inlary_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_inlary"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_inlary.Find
// Find row by key. Return NULL if not found.
amc::FInlary* amc::ind_inlary_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_inlary_buckets_n - 1);
    amc::FInlary* *e = &_db.ind_inlary_buckets_elems[index];
    amc::FInlary* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_inlary_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_inlary.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FInlary& amc::ind_inlary_GetOrCreate(const algo::strptr& key) {
    amc::FInlary* ret = ind_inlary_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &inlary_Alloc();
        (*ret).field = key;
        bool good = inlary_XrefMaybe(*ret);
        if (!good) {
            inlary_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_inlary  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_inlary.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_inlary_InsertMaybe(amc::FInlary& row) {
    ind_inlary_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_inlary_next == (amc::FInlary*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_inlary_buckets_n - 1);
        amc::FInlary* *prev = &_db.ind_inlary_buckets_elems[index];
        do {
            amc::FInlary* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_inlary_next;
        } while (true);
        if (retval) {
            row.ind_inlary_next = *prev;
            _db.ind_inlary_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_inlary.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_inlary_Remove(amc::FInlary& row) {
    if (LIKELY(row.ind_inlary_next != (amc::FInlary*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_inlary_buckets_n - 1);
        amc::FInlary* *prev = &_db.ind_inlary_buckets_elems[index]; // addr of pointer to current element
        while (amc::FInlary *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_inlary_next; // unlink (singly linked list)
                _db.ind_inlary_n--;
                row.ind_inlary_next = (amc::FInlary*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_inlary_next;
        }
    }
}

// --- amc.FDb.ind_inlary.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_inlary_Reserve(int n) {
    u32 old_nbuckets = _db.ind_inlary_buckets_n;
    u32 new_nelems   = _db.ind_inlary_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FInlary*);
        u32 new_size = new_nbuckets * sizeof(amc::FInlary*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FInlary* *new_buckets = (amc::FInlary**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_inlary");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_inlary_buckets_n; i++) {
            amc::FInlary* elem = _db.ind_inlary_buckets_elems[i];
            while (elem) {
                amc::FInlary &row        = *elem;
                amc::FInlary* next       = row.ind_inlary_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_inlary_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_inlary_buckets_elems, old_size);
        _db.ind_inlary_buckets_elems = new_buckets;
        _db.ind_inlary_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.tary.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTary& amc::tary_Alloc() {
    amc::FTary* row = tary_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tary  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tary.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTary* amc::tary_AllocMaybe() {
    amc::FTary *row = (amc::FTary*)tary_AllocMem();
    if (row) {
        new (row) amc::FTary; // call constructor
    }
    return row;
}

// --- amc.FDb.tary.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTary* amc::tary_InsertMaybe(const dmmeta::Tary &value) {
    amc::FTary *row = &tary_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tary_CopyIn(*row,const_cast<dmmeta::Tary&>(value));
    bool ok = tary_XrefMaybe(*row); // this may return false
    if (!ok) {
        tary_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tary.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::tary_AllocMem() {
    u64 new_nelems     = _db.tary_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTary*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tary_lary[bsr];
        if (!lev) {
            lev=(amc::FTary*)amc::lpool_AllocMem(sizeof(amc::FTary) * (u64(1)<<bsr));
            _db.tary_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tary_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.tary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tary_RemoveLast() {
    u64 n = _db.tary_n;
    if (n > 0) {
        n -= 1;
        tary_qFind(u64(n)).~FTary();
        _db.tary_n = i32(n);
    }
}

// --- amc.FDb.tary.InputMaybe
static bool amc::tary_InputMaybe(dmmeta::Tary &elem) {
    bool retval = true;
    retval = tary_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.tary.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tary_XrefMaybe(amc::FTary &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // tary: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert tary into index ind_tary
    if (true) { // user-defined insert condition
        bool success = ind_tary_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_tary"; // check for duplicate key
            return false;
        }
    }
    // insert tary into index c_tary
    if (true) { // user-defined insert condition
        bool success = c_tary_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_tary"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_tary.Find
// Find row by key. Return NULL if not found.
amc::FTary* amc::ind_tary_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_tary_buckets_n - 1);
    amc::FTary* *e = &_db.ind_tary_buckets_elems[index];
    amc::FTary* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_tary_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_tary.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTary& amc::ind_tary_GetOrCreate(const algo::strptr& key) {
    amc::FTary* ret = ind_tary_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &tary_Alloc();
        (*ret).field = key;
        bool good = tary_XrefMaybe(*ret);
        if (!good) {
            tary_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_tary  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_tary.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_tary_InsertMaybe(amc::FTary& row) {
    ind_tary_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_tary_next == (amc::FTary*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_tary_buckets_n - 1);
        amc::FTary* *prev = &_db.ind_tary_buckets_elems[index];
        do {
            amc::FTary* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_tary_next;
        } while (true);
        if (retval) {
            row.ind_tary_next = *prev;
            _db.ind_tary_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_tary.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_tary_Remove(amc::FTary& row) {
    if (LIKELY(row.ind_tary_next != (amc::FTary*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_tary_buckets_n - 1);
        amc::FTary* *prev = &_db.ind_tary_buckets_elems[index]; // addr of pointer to current element
        while (amc::FTary *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_tary_next; // unlink (singly linked list)
                _db.ind_tary_n--;
                row.ind_tary_next = (amc::FTary*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_tary_next;
        }
    }
}

// --- amc.FDb.ind_tary.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_tary_Reserve(int n) {
    u32 old_nbuckets = _db.ind_tary_buckets_n;
    u32 new_nelems   = _db.ind_tary_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FTary*);
        u32 new_size = new_nbuckets * sizeof(amc::FTary*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FTary* *new_buckets = (amc::FTary**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_tary");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_tary_buckets_n; i++) {
            amc::FTary* elem = _db.ind_tary_buckets_elems[i];
            while (elem) {
                amc::FTary &row        = *elem;
                amc::FTary* next       = row.ind_tary_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_tary_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_tary_buckets_elems, old_size);
        _db.ind_tary_buckets_elems = new_buckets;
        _db.ind_tary_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.cppfunc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCppfunc& amc::cppfunc_Alloc() {
    amc::FCppfunc* row = cppfunc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cppfunc  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cppfunc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCppfunc* amc::cppfunc_AllocMaybe() {
    amc::FCppfunc *row = (amc::FCppfunc*)cppfunc_AllocMem();
    if (row) {
        new (row) amc::FCppfunc; // call constructor
    }
    return row;
}

// --- amc.FDb.cppfunc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCppfunc* amc::cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) {
    amc::FCppfunc *row = &cppfunc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cppfunc_CopyIn(*row,const_cast<dmmeta::Cppfunc&>(value));
    bool ok = cppfunc_XrefMaybe(*row); // this may return false
    if (!ok) {
        cppfunc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cppfunc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cppfunc_AllocMem() {
    u64 new_nelems     = _db.cppfunc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCppfunc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cppfunc_lary[bsr];
        if (!lev) {
            lev=(amc::FCppfunc*)amc::lpool_AllocMem(sizeof(amc::FCppfunc) * (u64(1)<<bsr));
            _db.cppfunc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cppfunc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cppfunc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cppfunc_RemoveLast() {
    u64 n = _db.cppfunc_n;
    if (n > 0) {
        n -= 1;
        cppfunc_qFind(u64(n)).~FCppfunc();
        _db.cppfunc_n = i32(n);
    }
}

// --- amc.FDb.cppfunc.InputMaybe
static bool amc::cppfunc_InputMaybe(dmmeta::Cppfunc &elem) {
    bool retval = true;
    retval = cppfunc_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cppfunc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cppfunc_XrefMaybe(amc::FCppfunc &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert cppfunc into index c_cppfunc
    if (true) { // user-defined insert condition
        bool success = c_cppfunc_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_cppfunc"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.rowid.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FRowid& amc::rowid_Alloc() {
    amc::FRowid* row = rowid_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.rowid  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.rowid.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FRowid* amc::rowid_AllocMaybe() {
    amc::FRowid *row = (amc::FRowid*)rowid_AllocMem();
    if (row) {
        new (row) amc::FRowid; // call constructor
    }
    return row;
}

// --- amc.FDb.rowid.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FRowid* amc::rowid_InsertMaybe(const dmmeta::Rowid &value) {
    amc::FRowid *row = &rowid_Alloc(); // if out of memory, process dies. if input error, return NULL.
    rowid_CopyIn(*row,const_cast<dmmeta::Rowid&>(value));
    bool ok = rowid_XrefMaybe(*row); // this may return false
    if (!ok) {
        rowid_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.rowid.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::rowid_AllocMem() {
    u64 new_nelems     = _db.rowid_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FRowid*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.rowid_lary[bsr];
        if (!lev) {
            lev=(amc::FRowid*)amc::lpool_AllocMem(sizeof(amc::FRowid) * (u64(1)<<bsr));
            _db.rowid_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.rowid_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.rowid.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::rowid_RemoveLast() {
    u64 n = _db.rowid_n;
    if (n > 0) {
        n -= 1;
        rowid_qFind(u64(n)).~FRowid();
        _db.rowid_n = i32(n);
    }
}

// --- amc.FDb.rowid.InputMaybe
static bool amc::rowid_InputMaybe(dmmeta::Rowid &elem) {
    bool retval = true;
    retval = rowid_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.rowid.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::rowid_XrefMaybe(amc::FRowid &row) {
    bool retval = true;
    (void)row;
    // insert rowid into index ind_rowid
    if (true) { // user-defined insert condition
        bool success = ind_rowid_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_rowid"; // check for duplicate key
            return false;
        }
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert rowid into index c_rowid
    if (true) { // user-defined insert condition
        bool success = c_rowid_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_rowid"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_rowid.Find
// Find row by key. Return NULL if not found.
amc::FRowid* amc::ind_rowid_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_rowid_buckets_n - 1);
    amc::FRowid* *e = &_db.ind_rowid_buckets_elems[index];
    amc::FRowid* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_rowid_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_rowid.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FRowid& amc::ind_rowid_GetOrCreate(const algo::strptr& key) {
    amc::FRowid* ret = ind_rowid_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &rowid_Alloc();
        (*ret).field = key;
        bool good = rowid_XrefMaybe(*ret);
        if (!good) {
            rowid_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_rowid  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_rowid.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_rowid_InsertMaybe(amc::FRowid& row) {
    ind_rowid_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_rowid_next == (amc::FRowid*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_rowid_buckets_n - 1);
        amc::FRowid* *prev = &_db.ind_rowid_buckets_elems[index];
        do {
            amc::FRowid* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_rowid_next;
        } while (true);
        if (retval) {
            row.ind_rowid_next = *prev;
            _db.ind_rowid_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_rowid.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_rowid_Remove(amc::FRowid& row) {
    if (LIKELY(row.ind_rowid_next != (amc::FRowid*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_rowid_buckets_n - 1);
        amc::FRowid* *prev = &_db.ind_rowid_buckets_elems[index]; // addr of pointer to current element
        while (amc::FRowid *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_rowid_next; // unlink (singly linked list)
                _db.ind_rowid_n--;
                row.ind_rowid_next = (amc::FRowid*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_rowid_next;
        }
    }
}

// --- amc.FDb.ind_rowid.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_rowid_Reserve(int n) {
    u32 old_nbuckets = _db.ind_rowid_buckets_n;
    u32 new_nelems   = _db.ind_rowid_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FRowid*);
        u32 new_size = new_nbuckets * sizeof(amc::FRowid*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FRowid* *new_buckets = (amc::FRowid**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_rowid");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_rowid_buckets_n; i++) {
            amc::FRowid* elem = _db.ind_rowid_buckets_elems[i];
            while (elem) {
                amc::FRowid &row        = *elem;
                amc::FRowid* next       = row.ind_rowid_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_rowid_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_rowid_buckets_elems, old_size);
        _db.ind_rowid_buckets_elems = new_buckets;
        _db.ind_rowid_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.cascdel.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCascdel& amc::cascdel_Alloc() {
    amc::FCascdel* row = cascdel_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cascdel  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cascdel.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCascdel* amc::cascdel_AllocMaybe() {
    amc::FCascdel *row = (amc::FCascdel*)cascdel_AllocMem();
    if (row) {
        new (row) amc::FCascdel; // call constructor
    }
    return row;
}

// --- amc.FDb.cascdel.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCascdel* amc::cascdel_InsertMaybe(const dmmeta::Cascdel &value) {
    amc::FCascdel *row = &cascdel_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cascdel_CopyIn(*row,const_cast<dmmeta::Cascdel&>(value));
    bool ok = cascdel_XrefMaybe(*row); // this may return false
    if (!ok) {
        cascdel_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cascdel.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cascdel_AllocMem() {
    u64 new_nelems     = _db.cascdel_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCascdel*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cascdel_lary[bsr];
        if (!lev) {
            lev=(amc::FCascdel*)amc::lpool_AllocMem(sizeof(amc::FCascdel) * (u64(1)<<bsr));
            _db.cascdel_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cascdel_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cascdel.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cascdel_RemoveLast() {
    u64 n = _db.cascdel_n;
    if (n > 0) {
        n -= 1;
        cascdel_qFind(u64(n)).~FCascdel();
        _db.cascdel_n = i32(n);
    }
}

// --- amc.FDb.cascdel.InputMaybe
static bool amc::cascdel_InputMaybe(dmmeta::Cascdel &elem) {
    bool retval = true;
    retval = cascdel_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cascdel.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cascdel_XrefMaybe(amc::FCascdel &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // cascdel: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert cascdel into index c_cascdel
    if (true) { // user-defined insert condition
        bool success = c_cascdel_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_cascdel"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.substr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSubstr& amc::substr_Alloc() {
    amc::FSubstr* row = substr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.substr  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.substr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FSubstr* amc::substr_AllocMaybe() {
    amc::FSubstr *row = (amc::FSubstr*)substr_AllocMem();
    if (row) {
        new (row) amc::FSubstr; // call constructor
    }
    return row;
}

// --- amc.FDb.substr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSubstr* amc::substr_InsertMaybe(const dmmeta::Substr &value) {
    amc::FSubstr *row = &substr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    substr_CopyIn(*row,const_cast<dmmeta::Substr&>(value));
    bool ok = substr_XrefMaybe(*row); // this may return false
    if (!ok) {
        substr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.substr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::substr_AllocMem() {
    u64 new_nelems     = _db.substr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FSubstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.substr_lary[bsr];
        if (!lev) {
            lev=(amc::FSubstr*)amc::lpool_AllocMem(sizeof(amc::FSubstr) * (u64(1)<<bsr));
            _db.substr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.substr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.substr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::substr_RemoveLast() {
    u64 n = _db.substr_n;
    if (n > 0) {
        n -= 1;
        substr_qFind(u64(n)).~FSubstr();
        _db.substr_n = i32(n);
    }
}

// --- amc.FDb.substr.InputMaybe
static bool amc::substr_InputMaybe(dmmeta::Substr &elem) {
    bool retval = true;
    retval = substr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.substr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::substr_XrefMaybe(amc::FSubstr &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // substr: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FField* p_srcfield = amc::ind_field_Find(row.srcfield);
    if (UNLIKELY(!p_srcfield)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.srcfield);
        return false;
    }
    // substr: save pointer to srcfield
    if (true) { // user-defined insert condition
        row.p_srcfield = p_srcfield;
    }
    // insert substr into index c_substr
    if (true) { // user-defined insert condition
        bool success = c_substr_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_substr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.bitfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBitfld& amc::bitfld_Alloc() {
    amc::FBitfld* row = bitfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.bitfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.bitfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FBitfld* amc::bitfld_AllocMaybe() {
    amc::FBitfld *row = (amc::FBitfld*)bitfld_AllocMem();
    if (row) {
        new (row) amc::FBitfld; // call constructor
    }
    return row;
}

// --- amc.FDb.bitfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBitfld* amc::bitfld_InsertMaybe(const dmmeta::Bitfld &value) {
    amc::FBitfld *row = &bitfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    bitfld_CopyIn(*row,const_cast<dmmeta::Bitfld&>(value));
    bool ok = bitfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        bitfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.bitfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::bitfld_AllocMem() {
    u64 new_nelems     = _db.bitfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FBitfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.bitfld_lary[bsr];
        if (!lev) {
            lev=(amc::FBitfld*)amc::lpool_AllocMem(sizeof(amc::FBitfld) * (u64(1)<<bsr));
            _db.bitfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.bitfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.bitfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::bitfld_RemoveLast() {
    u64 n = _db.bitfld_n;
    if (n > 0) {
        n -= 1;
        bitfld_qFind(u64(n)).~FBitfld();
        _db.bitfld_n = i32(n);
    }
}

// --- amc.FDb.bitfld.InputMaybe
static bool amc::bitfld_InputMaybe(dmmeta::Bitfld &elem) {
    bool retval = true;
    retval = bitfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.bitfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::bitfld_XrefMaybe(amc::FBitfld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_srcfield = amc::ind_field_Find(row.srcfield);
    if (UNLIKELY(!p_srcfield)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.srcfield);
        return false;
    }
    // bitfld: save pointer to srcfield
    if (true) { // user-defined insert condition
        row.p_srcfield = p_srcfield;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // bitfld: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert bitfld into index c_bitfld
    if (true) { // user-defined insert condition
        bool success = c_bitfld_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_bitfld"; // check for duplicate key
            return false;
        }
    }
    // insert bitfld into index bh_bitfld
    if (true) { // user-defined insert condition
        bh_bitfld_Insert(*p_srcfield, row);
    }
    return retval;
}

// --- amc.FDb.ssimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSsimfile& amc::ssimfile_Alloc() {
    amc::FSsimfile* row = ssimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ssimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ssimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FSsimfile* amc::ssimfile_AllocMaybe() {
    amc::FSsimfile *row = (amc::FSsimfile*)ssimfile_AllocMem();
    if (row) {
        new (row) amc::FSsimfile; // call constructor
    }
    return row;
}

// --- amc.FDb.ssimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSsimfile* amc::ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) {
    amc::FSsimfile *row = &ssimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimfile_CopyIn(*row,const_cast<dmmeta::Ssimfile&>(value));
    bool ok = ssimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ssimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ssimfile_AllocMem() {
    u64 new_nelems     = _db.ssimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FSsimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimfile_lary[bsr];
        if (!lev) {
            lev=(amc::FSsimfile*)amc::lpool_AllocMem(sizeof(amc::FSsimfile) * (u64(1)<<bsr));
            _db.ssimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ssimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ssimfile_RemoveLast() {
    u64 n = _db.ssimfile_n;
    if (n > 0) {
        n -= 1;
        ssimfile_qFind(u64(n)).~FSsimfile();
        _db.ssimfile_n = i32(n);
    }
}

// --- amc.FDb.ssimfile.InputMaybe
static bool amc::ssimfile_InputMaybe(dmmeta::Ssimfile &elem) {
    bool retval = true;
    retval = ssimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ssimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ssimfile_XrefMaybe(amc::FSsimfile &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // ssimfile: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert ssimfile into index ind_ssimfile
    if (true) { // user-defined insert condition
        bool success = ind_ssimfile_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_ssimfile"; // check for duplicate key
            return false;
        }
    }
    // insert ssimfile into index c_ssimfile
    if (true) { // user-defined insert condition
        bool success = c_ssimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_ssimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ssimfile.Find
// Find row by key. Return NULL if not found.
amc::FSsimfile* amc::ind_ssimfile_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ssimfile_buckets_n - 1);
    amc::FSsimfile* *e = &_db.ind_ssimfile_buckets_elems[index];
    amc::FSsimfile* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ssimfile == key;
        if (done) break;
        e         = &ret->ind_ssimfile_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_ssimfile.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FSsimfile& amc::ind_ssimfile_GetOrCreate(const algo::strptr& key) {
    amc::FSsimfile* ret = ind_ssimfile_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ssimfile_Alloc();
        (*ret).ssimfile = key;
        bool good = ssimfile_XrefMaybe(*ret);
        if (!good) {
            ssimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_ssimfile  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_ssimfile.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_ssimfile_InsertMaybe(amc::FSsimfile& row) {
    ind_ssimfile_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ssimfile_next == (amc::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        amc::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index];
        do {
            amc::FSsimfile* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ssimfile == row.ssimfile) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ssimfile_next;
        } while (true);
        if (retval) {
            row.ind_ssimfile_next = *prev;
            _db.ind_ssimfile_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ssimfile.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_ssimfile_Remove(amc::FSsimfile& row) {
    if (LIKELY(row.ind_ssimfile_next != (amc::FSsimfile*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ssimfile) & (_db.ind_ssimfile_buckets_n - 1);
        amc::FSsimfile* *prev = &_db.ind_ssimfile_buckets_elems[index]; // addr of pointer to current element
        while (amc::FSsimfile *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ssimfile_next; // unlink (singly linked list)
                _db.ind_ssimfile_n--;
                row.ind_ssimfile_next = (amc::FSsimfile*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ssimfile_next;
        }
    }
}

// --- amc.FDb.ind_ssimfile.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_ssimfile_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ssimfile_buckets_n;
    u32 new_nelems   = _db.ind_ssimfile_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FSsimfile*);
        u32 new_size = new_nbuckets * sizeof(amc::FSsimfile*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FSsimfile* *new_buckets = (amc::FSsimfile**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_ssimfile");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ssimfile_buckets_n; i++) {
            amc::FSsimfile* elem = _db.ind_ssimfile_buckets_elems[i];
            while (elem) {
                amc::FSsimfile &row        = *elem;
                amc::FSsimfile* next       = row.ind_ssimfile_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ssimfile) & (new_nbuckets-1);
                row.ind_ssimfile_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_ssimfile_buckets_elems, old_size);
        _db.ind_ssimfile_buckets_elems = new_buckets;
        _db.ind_ssimfile_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.pack.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPack& amc::pack_Alloc() {
    amc::FPack* row = pack_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.pack  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.pack.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FPack* amc::pack_AllocMaybe() {
    amc::FPack *row = (amc::FPack*)pack_AllocMem();
    if (row) {
        new (row) amc::FPack; // call constructor
    }
    return row;
}

// --- amc.FDb.pack.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPack* amc::pack_InsertMaybe(const dmmeta::Pack &value) {
    amc::FPack *row = &pack_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pack_CopyIn(*row,const_cast<dmmeta::Pack&>(value));
    bool ok = pack_XrefMaybe(*row); // this may return false
    if (!ok) {
        pack_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.pack.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::pack_AllocMem() {
    u64 new_nelems     = _db.pack_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FPack*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pack_lary[bsr];
        if (!lev) {
            lev=(amc::FPack*)amc::lpool_AllocMem(sizeof(amc::FPack) * (u64(1)<<bsr));
            _db.pack_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pack_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.pack.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::pack_RemoveLast() {
    u64 n = _db.pack_n;
    if (n > 0) {
        n -= 1;
        pack_qFind(u64(n)).~FPack();
        _db.pack_n = i32(n);
    }
}

// --- amc.FDb.pack.InputMaybe
static bool amc::pack_InputMaybe(dmmeta::Pack &elem) {
    bool retval = true;
    retval = pack_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.pack.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::pack_XrefMaybe(amc::FPack &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // pack: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    // insert pack into index c_pack
    if (true) { // user-defined insert condition
        bool success = c_pack_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_pack"; // check for duplicate key
            return false;
        }
    }
    // insert pack into index ind_pack
    if (true) { // user-defined insert condition
        bool success = ind_pack_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_pack"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_pack.Find
// Find row by key. Return NULL if not found.
amc::FPack* amc::ind_pack_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_pack_buckets_n - 1);
    amc::FPack* *e = &_db.ind_pack_buckets_elems[index];
    amc::FPack* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_pack_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_pack.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FPack& amc::ind_pack_GetOrCreate(const algo::strptr& key) {
    amc::FPack* ret = ind_pack_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &pack_Alloc();
        (*ret).ctype = key;
        bool good = pack_XrefMaybe(*ret);
        if (!good) {
            pack_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_pack  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_pack.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_pack_InsertMaybe(amc::FPack& row) {
    ind_pack_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_pack_next == (amc::FPack*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_pack_buckets_n - 1);
        amc::FPack* *prev = &_db.ind_pack_buckets_elems[index];
        do {
            amc::FPack* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_pack_next;
        } while (true);
        if (retval) {
            row.ind_pack_next = *prev;
            _db.ind_pack_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_pack.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_pack_Remove(amc::FPack& row) {
    if (LIKELY(row.ind_pack_next != (amc::FPack*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_pack_buckets_n - 1);
        amc::FPack* *prev = &_db.ind_pack_buckets_elems[index]; // addr of pointer to current element
        while (amc::FPack *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_pack_next; // unlink (singly linked list)
                _db.ind_pack_n--;
                row.ind_pack_next = (amc::FPack*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_pack_next;
        }
    }
}

// --- amc.FDb.ind_pack.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_pack_Reserve(int n) {
    u32 old_nbuckets = _db.ind_pack_buckets_n;
    u32 new_nelems   = _db.ind_pack_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FPack*);
        u32 new_size = new_nbuckets * sizeof(amc::FPack*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FPack* *new_buckets = (amc::FPack**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_pack");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_pack_buckets_n; i++) {
            amc::FPack* elem = _db.ind_pack_buckets_elems[i];
            while (elem) {
                amc::FPack &row        = *elem;
                amc::FPack* next       = row.ind_pack_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_pack_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_pack_buckets_elems, old_size);
        _db.ind_pack_buckets_elems = new_buckets;
        _db.ind_pack_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_smallstr.Find
// Find row by key. Return NULL if not found.
amc::FSmallstr* amc::ind_smallstr_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_smallstr_buckets_n - 1);
    amc::FSmallstr* *e = &_db.ind_smallstr_buckets_elems[index];
    amc::FSmallstr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_smallstr_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_smallstr.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FSmallstr& amc::ind_smallstr_GetOrCreate(const algo::strptr& key) {
    amc::FSmallstr* ret = ind_smallstr_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &smallstr_Alloc();
        (*ret).field = key;
        bool good = smallstr_XrefMaybe(*ret);
        if (!good) {
            smallstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_smallstr  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_smallstr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_smallstr_InsertMaybe(amc::FSmallstr& row) {
    ind_smallstr_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_smallstr_next == (amc::FSmallstr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_smallstr_buckets_n - 1);
        amc::FSmallstr* *prev = &_db.ind_smallstr_buckets_elems[index];
        do {
            amc::FSmallstr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_smallstr_next;
        } while (true);
        if (retval) {
            row.ind_smallstr_next = *prev;
            _db.ind_smallstr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_smallstr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_smallstr_Remove(amc::FSmallstr& row) {
    if (LIKELY(row.ind_smallstr_next != (amc::FSmallstr*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_smallstr_buckets_n - 1);
        amc::FSmallstr* *prev = &_db.ind_smallstr_buckets_elems[index]; // addr of pointer to current element
        while (amc::FSmallstr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_smallstr_next; // unlink (singly linked list)
                _db.ind_smallstr_n--;
                row.ind_smallstr_next = (amc::FSmallstr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_smallstr_next;
        }
    }
}

// --- amc.FDb.ind_smallstr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_smallstr_Reserve(int n) {
    u32 old_nbuckets = _db.ind_smallstr_buckets_n;
    u32 new_nelems   = _db.ind_smallstr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FSmallstr*);
        u32 new_size = new_nbuckets * sizeof(amc::FSmallstr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FSmallstr* *new_buckets = (amc::FSmallstr**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_smallstr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_smallstr_buckets_n; i++) {
            amc::FSmallstr* elem = _db.ind_smallstr_buckets_elems[i];
            while (elem) {
                amc::FSmallstr &row        = *elem;
                amc::FSmallstr* next       = row.ind_smallstr_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_smallstr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_smallstr_buckets_elems, old_size);
        _db.ind_smallstr_buckets_elems = new_buckets;
        _db.ind_smallstr_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ptrary.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPtrary& amc::ptrary_Alloc() {
    amc::FPtrary* row = ptrary_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ptrary  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ptrary.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FPtrary* amc::ptrary_AllocMaybe() {
    amc::FPtrary *row = (amc::FPtrary*)ptrary_AllocMem();
    if (row) {
        new (row) amc::FPtrary; // call constructor
    }
    return row;
}

// --- amc.FDb.ptrary.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPtrary* amc::ptrary_InsertMaybe(const dmmeta::Ptrary &value) {
    amc::FPtrary *row = &ptrary_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ptrary_CopyIn(*row,const_cast<dmmeta::Ptrary&>(value));
    bool ok = ptrary_XrefMaybe(*row); // this may return false
    if (!ok) {
        ptrary_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ptrary.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ptrary_AllocMem() {
    u64 new_nelems     = _db.ptrary_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FPtrary*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ptrary_lary[bsr];
        if (!lev) {
            lev=(amc::FPtrary*)amc::lpool_AllocMem(sizeof(amc::FPtrary) * (u64(1)<<bsr));
            _db.ptrary_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ptrary_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ptrary.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ptrary_RemoveLast() {
    u64 n = _db.ptrary_n;
    if (n > 0) {
        n -= 1;
        ptrary_qFind(u64(n)).~FPtrary();
        _db.ptrary_n = i32(n);
    }
}

// --- amc.FDb.ptrary.InputMaybe
static bool amc::ptrary_InputMaybe(dmmeta::Ptrary &elem) {
    bool retval = true;
    retval = ptrary_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ptrary.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ptrary_XrefMaybe(amc::FPtrary &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // ptrary: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert ptrary into index c_ptrary
    if (true) { // user-defined insert condition
        bool success = c_ptrary_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_ptrary"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.c_ctype_sorted.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ctype_sorted_Insert(amc::FCtype& row) {
    // reserve space
    c_ctype_sorted_Reserve(1);
    u32 n  = _db.c_ctype_sorted_n;
    u32 at = n;
    amc::FCtype* *elems = _db.c_ctype_sorted_elems;
    elems[at] = &row;
    _db.c_ctype_sorted_n = n+1;

}

// --- amc.FDb.c_ctype_sorted.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_ctype_sorted_ScanInsertMaybe(amc::FCtype& row) {
    bool retval = true;
    u32 n  = _db.c_ctype_sorted_n;
    for (u32 i = 0; i < n; i++) {
        if (_db.c_ctype_sorted_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ctype_sorted_Reserve(1);
        _db.c_ctype_sorted_elems[n] = &row;
        _db.c_ctype_sorted_n = n+1;
    }
    return retval;
}

// --- amc.FDb.c_ctype_sorted.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ctype_sorted_Remove(amc::FCtype& row) {
    int lim = _db.c_ctype_sorted_n;
    amc::FCtype* *elems = _db.c_ctype_sorted_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FCtype* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FCtype*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            _db.c_ctype_sorted_n = lim - 1;
            break;
        }
    }
}

// --- amc.FDb.c_ctype_sorted.Reserve
// Reserve space in index for N more elements;
void amc::c_ctype_sorted_Reserve(u32 n) {
    u32 old_max = _db.c_ctype_sorted_max;
    if (UNLIKELY(_db.c_ctype_sorted_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FCtype*);
        u32 new_size = new_max * sizeof(amc::FCtype*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_ctype_sorted_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_ctype_sorted");
        }
        _db.c_ctype_sorted_elems = (amc::FCtype**)new_mem;
        _db.c_ctype_sorted_max = new_max;
    }
}

// --- amc.FDb.c_ctype_sorted.Swap
// Swap values elem_a and elem_b
inline static void amc::c_ctype_sorted_Swap(amc::FCtype* &elem_a, amc::FCtype* &elem_b) {
    amc::FCtype *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- amc.FDb.c_ctype_sorted.Rotleft
// Left circular shift of three-tuple
inline static void amc::c_ctype_sorted_Rotleft(amc::FCtype* &elem_a, amc::FCtype* &elem_b, amc::FCtype* &elem_c) {
    amc::FCtype *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- amc.FDb.c_ctype_sorted.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool amc::c_ctype_sorted_Lt(amc::FCtype &elem_a, amc::FCtype &elem_b) {
    bool ret;
    ret = elem_a.ctype < elem_b.ctype;
    return ret;
}

// --- amc.FDb.c_ctype_sorted.SortedQ
// Verify whether array is sorted
bool amc::c_ctype_sorted_SortedQ() {
    amc::FCtype* *elems = c_ctype_sorted_Getary().elems;
    int n = c_ctype_sorted_N();
    for (int i = 1; i < n; i++) {
        if (c_ctype_sorted_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- amc.FDb.c_ctype_sorted.IntInsertionSort
// Internal insertion sort
static void amc::c_ctype_sorted_IntInsertionSort(amc::FCtype* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        amc::FCtype *tmp = elems[i];
        // shift elements up by one
        if (c_ctype_sorted_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_ctype_sorted_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- amc.FDb.c_ctype_sorted.IntHeapSort
// Internal heap sort
static void amc::c_ctype_sorted_IntHeapSort(amc::FCtype* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_ctype_sorted_Lt(*elems[j], *elems[k])) {
            c_ctype_sorted_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_ctype_sorted_Lt(*elems[l], *elems[l+1]);
            if (c_ctype_sorted_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_ctype_sorted_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_ctype_sorted_Swap(elems[i],elems[k]);
        }
    }
}

// --- amc.FDb.c_ctype_sorted.IntQuickSort
// Quick sort engine
static void amc::c_ctype_sorted_IntQuickSort(amc::FCtype* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_ctype_sorted_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_ctype_sorted_Lt(*elems[pp], *elems[pi])) {
            c_ctype_sorted_Swap(elems[pi], elems[pp]);
        }
        if (c_ctype_sorted_Lt(*elems[pj], *elems[pp])) {
            if (c_ctype_sorted_Lt(*elems[pj], *elems[pi])) {
                c_ctype_sorted_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_ctype_sorted_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_ctype_sorted_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        amc::FCtype *pivot = elems[pj];
        for(;;){
            while (c_ctype_sorted_Lt(*elems[++pi], *pivot)) {
            }
            while (c_ctype_sorted_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_ctype_sorted_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_ctype_sorted_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_ctype_sorted_IntInsertionSort(elems,n);
}

// --- amc.FDb.c_ctype_sorted.InsertionSort
// Insertion sort
void amc::c_ctype_sorted_InsertionSort() {
    amc::FCtype* *elems = c_ctype_sorted_Getary().elems;
    int n = c_ctype_sorted_N();
    c_ctype_sorted_IntInsertionSort(elems, n);
}

// --- amc.FDb.c_ctype_sorted.HeapSort
// Heap sort
void amc::c_ctype_sorted_HeapSort() {
    amc::FCtype* *elems = c_ctype_sorted_Getary().elems;
    int n = c_ctype_sorted_N();
    c_ctype_sorted_IntHeapSort(elems, n);
}

// --- amc.FDb.c_ctype_sorted.QuickSort
// Quick sort
void amc::c_ctype_sorted_QuickSort() {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_ctype_sorted_N() + 1)) + 3;
    amc::FCtype* *elems = c_ctype_sorted_Getary().elems;
    int n = c_ctype_sorted_N();
    c_ctype_sorted_IntQuickSort(elems, n, max_depth);
}

// --- amc.FDb.enumstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FEnumstr& amc::enumstr_Alloc() {
    amc::FEnumstr* row = enumstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.enumstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.enumstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FEnumstr* amc::enumstr_AllocMaybe() {
    amc::FEnumstr *row = (amc::FEnumstr*)enumstr_AllocMem();
    if (row) {
        new (row) amc::FEnumstr; // call constructor
    }
    return row;
}

// --- amc.FDb.enumstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::enumstr_AllocMem() {
    u64 new_nelems     = _db.enumstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FEnumstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.enumstr_lary[bsr];
        if (!lev) {
            lev=(amc::FEnumstr*)amc::lpool_AllocMem(sizeof(amc::FEnumstr) * (u64(1)<<bsr));
            _db.enumstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.enumstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.enumstr.RemoveAll
// Remove all elements from Lary
void amc::enumstr_RemoveAll() {
    for (u64 n = _db.enumstr_n; n>0; ) {
        n--;
        enumstr_qFind(u64(n)).~FEnumstr(); // destroy last element
        _db.enumstr_n = i32(n);
    }
}

// --- amc.FDb.enumstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::enumstr_RemoveLast() {
    u64 n = _db.enumstr_n;
    if (n > 0) {
        n -= 1;
        enumstr_qFind(u64(n)).~FEnumstr();
        _db.enumstr_n = i32(n);
    }
}

// --- amc.FDb.enumstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::enumstr_XrefMaybe(amc::FEnumstr &row) {
    bool retval = true;
    (void)row;
    amc::FEnumstrLen* p_len = amc::ind_enumstr_len_Find(row.enumstr.len);
    if (UNLIKELY(!p_len)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_enumstr_len" << Keyval("key", row.enumstr.len);
        return false;
    }
    // insert enumstr into index bh_enumstr
    if (true) { // user-defined insert condition
        bh_enumstr_Insert(*p_len, row);
    }
    // insert enumstr into index ind_enumstr
    if (true) { // user-defined insert condition
        bool success = ind_enumstr_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_enumstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.enumstr_len.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FEnumstrLen& amc::enumstr_len_Alloc() {
    amc::FEnumstrLen* row = enumstr_len_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.enumstr_len  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.enumstr_len.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FEnumstrLen* amc::enumstr_len_AllocMaybe() {
    amc::FEnumstrLen *row = (amc::FEnumstrLen*)enumstr_len_AllocMem();
    if (row) {
        new (row) amc::FEnumstrLen; // call constructor
    }
    return row;
}

// --- amc.FDb.enumstr_len.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::enumstr_len_AllocMem() {
    u64 new_nelems     = _db.enumstr_len_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FEnumstrLen*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.enumstr_len_lary[bsr];
        if (!lev) {
            lev=(amc::FEnumstrLen*)amc::lpool_AllocMem(sizeof(amc::FEnumstrLen) * (u64(1)<<bsr));
            _db.enumstr_len_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.enumstr_len_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.enumstr_len.RemoveAll
// Remove all elements from Lary
void amc::enumstr_len_RemoveAll() {
    for (u64 n = _db.enumstr_len_n; n>0; ) {
        n--;
        enumstr_len_qFind(u64(n)).~FEnumstrLen(); // destroy last element
        _db.enumstr_len_n = i32(n);
    }
}

// --- amc.FDb.enumstr_len.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::enumstr_len_RemoveLast() {
    u64 n = _db.enumstr_len_n;
    if (n > 0) {
        n -= 1;
        enumstr_len_qFind(u64(n)).~FEnumstrLen();
        _db.enumstr_len_n = i32(n);
    }
}

// --- amc.FDb.enumstr_len.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::enumstr_len_XrefMaybe(amc::FEnumstrLen &row) {
    bool retval = true;
    (void)row;
    // insert enumstr_len into index bh_enumstr_len
    if (true) { // user-defined insert condition
        bh_enumstr_len_Insert(row);
    }
    // insert enumstr_len into index ind_enumstr_len
    if (true) { // user-defined insert condition
        bool success = ind_enumstr_len_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_enumstr_len"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.bh_enumstr_len.Dealloc
// Remove all elements from heap and free memory used by the array.
void amc::bh_enumstr_len_Dealloc() {
    bh_enumstr_len_RemoveAll();
    amc::lpool_FreeMem(_db.bh_enumstr_len_elems, sizeof(amc::FEnumstrLen*)*_db.bh_enumstr_len_max);
    _db.bh_enumstr_len_max   = 0;
    _db.bh_enumstr_len_elems = NULL;
}

// --- amc.FDb.bh_enumstr_len.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int amc::bh_enumstr_len_Downheap(amc::FEnumstrLen& row, int idx) {
    amc::FEnumstrLen* *elems = _db.bh_enumstr_len_elems;
    int n = _db.bh_enumstr_len_n;
    int child = idx*2+1;
    while (child < n) {
        amc::FEnumstrLen* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            amc::FEnumstrLen* q = elems[rchild]; // right child
            if (bh_enumstr_len_ElemLt(*q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_enumstr_len_ElemLt(*p,row)) {
            break;
        }
        p->bh_enumstr_len_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- amc.FDb.bh_enumstr_len.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void amc::bh_enumstr_len_Insert(amc::FEnumstrLen& row) {
    if (LIKELY(row.bh_enumstr_len_idx == -1)) {
        bh_enumstr_len_Reserve(1);
        int n = _db.bh_enumstr_len_n;
        _db.bh_enumstr_len_n = n + 1;
        int new_idx = bh_enumstr_len_Upheap(row, n);
        row.bh_enumstr_len_idx = new_idx;
        _db.bh_enumstr_len_elems[new_idx] = &row;
    }
}

// --- amc.FDb.bh_enumstr_len.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 amc::bh_enumstr_len_Reheap(amc::FEnumstrLen& row) {
    int old_idx = row.bh_enumstr_len_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_enumstr_len_Reserve(1);
        old_idx = _db.bh_enumstr_len_n++;
    }
    int new_idx = bh_enumstr_len_Upheap(row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_enumstr_len_Downheap(row, old_idx);
    }
    row.bh_enumstr_len_idx = new_idx;
    _db.bh_enumstr_len_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FDb.bh_enumstr_len.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 amc::bh_enumstr_len_ReheapFirst() {
    amc::FEnumstrLen &row = *_db.bh_enumstr_len_elems[0];
    i32 new_idx = bh_enumstr_len_Downheap(row, 0);
    row.bh_enumstr_len_idx = new_idx;
    _db.bh_enumstr_len_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FDb.bh_enumstr_len.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::bh_enumstr_len_Remove(amc::FEnumstrLen& row) {
    if (bh_enumstr_len_InBheapQ(row)) {
        int old_idx = row.bh_enumstr_len_idx;
        if (_db.bh_enumstr_len_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_enumstr_len_idx = -1;           // mark not in heap
            i32 n = _db.bh_enumstr_len_n - 1; // index of last element in heap
            _db.bh_enumstr_len_n = n;         // decrease count
            if (old_idx != n) {
                amc::FEnumstrLen *elem = _db.bh_enumstr_len_elems[n];
                int new_idx = bh_enumstr_len_Upheap(*elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_enumstr_len_Downheap(*elem, old_idx);
                }
                elem->bh_enumstr_len_idx = new_idx;
                _db.bh_enumstr_len_elems[new_idx] = elem;
            }
        }
    }
}

// --- amc.FDb.bh_enumstr_len.RemoveAll
// Remove all elements from binary heap
void amc::bh_enumstr_len_RemoveAll() {
    int n = _db.bh_enumstr_len_n;
    for (int i = n - 1; i>=0; i--) {
        _db.bh_enumstr_len_elems[i]->bh_enumstr_len_idx = -1; // mark not-in-heap
    }
    _db.bh_enumstr_len_n = 0;
}

// --- amc.FDb.bh_enumstr_len.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FEnumstrLen* amc::bh_enumstr_len_RemoveFirst() {
    amc::FEnumstrLen *row = NULL;
    if (_db.bh_enumstr_len_n > 0) {
        row = _db.bh_enumstr_len_elems[0];
        row->bh_enumstr_len_idx = -1;           // mark not in heap
        i32 n = _db.bh_enumstr_len_n - 1; // index of last element in heap
        _db.bh_enumstr_len_n = n;         // decrease count
        if (n) {
            amc::FEnumstrLen &elem = *_db.bh_enumstr_len_elems[n];
            int new_idx = bh_enumstr_len_Downheap(elem, 0);
            elem.bh_enumstr_len_idx = new_idx;
            _db.bh_enumstr_len_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- amc.FDb.bh_enumstr_len.Reserve
// Reserve space in index for N more elements
void amc::bh_enumstr_len_Reserve(int n) {
    i32 old_max = _db.bh_enumstr_len_max;
    if (UNLIKELY(_db.bh_enumstr_len_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FEnumstrLen*);
        u32 new_size = new_max * sizeof(amc::FEnumstrLen*);
        void *new_mem = amc::lpool_ReallocMem(_db.bh_enumstr_len_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.bh_enumstr_len");
        }
        _db.bh_enumstr_len_elems = (amc::FEnumstrLen**)new_mem;
        _db.bh_enumstr_len_max = new_max;
    }
}

// --- amc.FDb.bh_enumstr_len.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int amc::bh_enumstr_len_Upheap(amc::FEnumstrLen& row, int idx) {
    amc::FEnumstrLen* *elems = _db.bh_enumstr_len_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        amc::FEnumstrLen* p = elems[j];
        if (!bh_enumstr_len_ElemLt(row, *p)) {
            break;
        }
        p->bh_enumstr_len_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- amc.FDb.bh_enumstr_len.ElemLt
inline static bool amc::bh_enumstr_len_ElemLt(amc::FEnumstrLen &a, amc::FEnumstrLen &b) {
    (void)_db;
    return a.len < b.len;
}

// --- amc.FDb.ind_enumstr_len.Find
// Find row by key. Return NULL if not found.
amc::FEnumstrLen* amc::ind_enumstr_len_Find(i32 key) {
    u32 index = ::i32_Hash(0, key) & (_db.ind_enumstr_len_buckets_n - 1);
    amc::FEnumstrLen* *e = &_db.ind_enumstr_len_buckets_elems[index];
    amc::FEnumstrLen* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).len == key;
        if (done) break;
        e         = &ret->ind_enumstr_len_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_enumstr_len.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FEnumstrLen& amc::ind_enumstr_len_GetOrCreate(i32 key) {
    amc::FEnumstrLen* ret = ind_enumstr_len_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &enumstr_len_Alloc();
        (*ret).len = key;
        bool good = enumstr_len_XrefMaybe(*ret);
        if (!good) {
            enumstr_len_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_enumstr_len  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_enumstr_len.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_enumstr_len_InsertMaybe(amc::FEnumstrLen& row) {
    ind_enumstr_len_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_enumstr_len_next == (amc::FEnumstrLen*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.len) & (_db.ind_enumstr_len_buckets_n - 1);
        amc::FEnumstrLen* *prev = &_db.ind_enumstr_len_buckets_elems[index];
        do {
            amc::FEnumstrLen* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).len == row.len) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_enumstr_len_next;
        } while (true);
        if (retval) {
            row.ind_enumstr_len_next = *prev;
            _db.ind_enumstr_len_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_enumstr_len.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_enumstr_len_Remove(amc::FEnumstrLen& row) {
    if (LIKELY(row.ind_enumstr_len_next != (amc::FEnumstrLen*)-1)) {// check if in hash already
        u32 index = ::i32_Hash(0, row.len) & (_db.ind_enumstr_len_buckets_n - 1);
        amc::FEnumstrLen* *prev = &_db.ind_enumstr_len_buckets_elems[index]; // addr of pointer to current element
        while (amc::FEnumstrLen *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_enumstr_len_next; // unlink (singly linked list)
                _db.ind_enumstr_len_n--;
                row.ind_enumstr_len_next = (amc::FEnumstrLen*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_enumstr_len_next;
        }
    }
}

// --- amc.FDb.ind_enumstr_len.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_enumstr_len_Reserve(int n) {
    u32 old_nbuckets = _db.ind_enumstr_len_buckets_n;
    u32 new_nelems   = _db.ind_enumstr_len_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FEnumstrLen*);
        u32 new_size = new_nbuckets * sizeof(amc::FEnumstrLen*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FEnumstrLen* *new_buckets = (amc::FEnumstrLen**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_enumstr_len");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_enumstr_len_buckets_n; i++) {
            amc::FEnumstrLen* elem = _db.ind_enumstr_len_buckets_elems[i];
            while (elem) {
                amc::FEnumstrLen &row        = *elem;
                amc::FEnumstrLen* next       = row.ind_enumstr_len_next;
                u32 index          = ::i32_Hash(0, row.len) & (new_nbuckets-1);
                row.ind_enumstr_len_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_enumstr_len_buckets_elems, old_size);
        _db.ind_enumstr_len_buckets_elems = new_buckets;
        _db.ind_enumstr_len_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_enumstr.Find
// Find row by key. Return NULL if not found.
amc::FEnumstr* amc::ind_enumstr_Find(const amc::Enumstr& key) {
    u32 index = amc::Enumstr_Hash(0, key) & (_db.ind_enumstr_buckets_n - 1);
    amc::FEnumstr* *e = &_db.ind_enumstr_buckets_elems[index];
    amc::FEnumstr* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).enumstr == key;
        if (done) break;
        e         = &ret->ind_enumstr_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_enumstr.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FEnumstr& amc::ind_enumstr_GetOrCreate(const amc::Enumstr& key) {
    amc::FEnumstr* ret = ind_enumstr_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &enumstr_Alloc();
        (*ret).enumstr = key;
        bool good = enumstr_XrefMaybe(*ret);
        if (!good) {
            enumstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_enumstr  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_enumstr.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_enumstr_InsertMaybe(amc::FEnumstr& row) {
    ind_enumstr_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_enumstr_next == (amc::FEnumstr*)-1)) {// check if in hash already
        u32 index = amc::Enumstr_Hash(0, row.enumstr) & (_db.ind_enumstr_buckets_n - 1);
        amc::FEnumstr* *prev = &_db.ind_enumstr_buckets_elems[index];
        do {
            amc::FEnumstr* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).enumstr == row.enumstr) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_enumstr_next;
        } while (true);
        if (retval) {
            row.ind_enumstr_next = *prev;
            _db.ind_enumstr_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_enumstr.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_enumstr_Remove(amc::FEnumstr& row) {
    if (LIKELY(row.ind_enumstr_next != (amc::FEnumstr*)-1)) {// check if in hash already
        u32 index = amc::Enumstr_Hash(0, row.enumstr) & (_db.ind_enumstr_buckets_n - 1);
        amc::FEnumstr* *prev = &_db.ind_enumstr_buckets_elems[index]; // addr of pointer to current element
        while (amc::FEnumstr *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_enumstr_next; // unlink (singly linked list)
                _db.ind_enumstr_n--;
                row.ind_enumstr_next = (amc::FEnumstr*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_enumstr_next;
        }
    }
}

// --- amc.FDb.ind_enumstr.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_enumstr_Reserve(int n) {
    u32 old_nbuckets = _db.ind_enumstr_buckets_n;
    u32 new_nelems   = _db.ind_enumstr_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FEnumstr*);
        u32 new_size = new_nbuckets * sizeof(amc::FEnumstr*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FEnumstr* *new_buckets = (amc::FEnumstr**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_enumstr");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_enumstr_buckets_n; i++) {
            amc::FEnumstr* elem = _db.ind_enumstr_buckets_elems[i];
            while (elem) {
                amc::FEnumstr &row        = *elem;
                amc::FEnumstr* next       = row.ind_enumstr_next;
                u32 index          = amc::Enumstr_Hash(0, row.enumstr) & (new_nbuckets-1);
                row.ind_enumstr_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_enumstr_buckets_elems, old_size);
        _db.ind_enumstr_buckets_elems = new_buckets;
        _db.ind_enumstr_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fbitset.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbitset& amc::fbitset_Alloc() {
    amc::FFbitset* row = fbitset_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fbitset  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fbitset.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbitset* amc::fbitset_AllocMaybe() {
    amc::FFbitset *row = (amc::FFbitset*)fbitset_AllocMem();
    if (row) {
        new (row) amc::FFbitset; // call constructor
    }
    return row;
}

// --- amc.FDb.fbitset.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbitset* amc::fbitset_InsertMaybe(const dmmeta::Fbitset &value) {
    amc::FFbitset *row = &fbitset_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fbitset_CopyIn(*row,const_cast<dmmeta::Fbitset&>(value));
    bool ok = fbitset_XrefMaybe(*row); // this may return false
    if (!ok) {
        fbitset_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fbitset.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fbitset_AllocMem() {
    u64 new_nelems     = _db.fbitset_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFbitset*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fbitset_lary[bsr];
        if (!lev) {
            lev=(amc::FFbitset*)amc::lpool_AllocMem(sizeof(amc::FFbitset) * (u64(1)<<bsr));
            _db.fbitset_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fbitset_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fbitset.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fbitset_RemoveLast() {
    u64 n = _db.fbitset_n;
    if (n > 0) {
        n -= 1;
        fbitset_qFind(u64(n)).~FFbitset();
        _db.fbitset_n = i32(n);
    }
}

// --- amc.FDb.fbitset.InputMaybe
static bool amc::fbitset_InputMaybe(dmmeta::Fbitset &elem) {
    bool retval = true;
    retval = fbitset_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fbitset.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fbitset_XrefMaybe(amc::FFbitset &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fbitset: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fbitset into index c_fbitset
    if (true) { // user-defined insert condition
        bool success = c_fbitset_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fbitset"; // check for duplicate key
            return false;
        }
    }
    // insert fbitset into index ind_fbitset
    if (true) { // user-defined insert condition
        bool success = ind_fbitset_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fbitset"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fbitset.Find
// Find row by key. Return NULL if not found.
amc::FFbitset* amc::ind_fbitset_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fbitset_buckets_n - 1);
    amc::FFbitset* *e = &_db.ind_fbitset_buckets_elems[index];
    amc::FFbitset* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_fbitset_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fbitset.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFbitset& amc::ind_fbitset_GetOrCreate(const algo::strptr& key) {
    amc::FFbitset* ret = ind_fbitset_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fbitset_Alloc();
        (*ret).field = key;
        bool good = fbitset_XrefMaybe(*ret);
        if (!good) {
            fbitset_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fbitset  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fbitset.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fbitset_InsertMaybe(amc::FFbitset& row) {
    ind_fbitset_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fbitset_next == (amc::FFbitset*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fbitset_buckets_n - 1);
        amc::FFbitset* *prev = &_db.ind_fbitset_buckets_elems[index];
        do {
            amc::FFbitset* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fbitset_next;
        } while (true);
        if (retval) {
            row.ind_fbitset_next = *prev;
            _db.ind_fbitset_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fbitset.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fbitset_Remove(amc::FFbitset& row) {
    if (LIKELY(row.ind_fbitset_next != (amc::FFbitset*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fbitset_buckets_n - 1);
        amc::FFbitset* *prev = &_db.ind_fbitset_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFbitset *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fbitset_next; // unlink (singly linked list)
                _db.ind_fbitset_n--;
                row.ind_fbitset_next = (amc::FFbitset*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fbitset_next;
        }
    }
}

// --- amc.FDb.ind_fbitset.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fbitset_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fbitset_buckets_n;
    u32 new_nelems   = _db.ind_fbitset_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFbitset*);
        u32 new_size = new_nbuckets * sizeof(amc::FFbitset*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFbitset* *new_buckets = (amc::FFbitset**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fbitset");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fbitset_buckets_n; i++) {
            amc::FFbitset* elem = _db.ind_fbitset_buckets_elems[i];
            while (elem) {
                amc::FFbitset &row        = *elem;
                amc::FFbitset* next       = row.ind_fbitset_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_fbitset_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fbitset_buckets_elems, old_size);
        _db.ind_fbitset_buckets_elems = new_buckets;
        _db.ind_fbitset_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fcleanup.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcleanup& amc::fcleanup_Alloc() {
    amc::FFcleanup* row = fcleanup_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcleanup  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcleanup.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcleanup* amc::fcleanup_AllocMaybe() {
    amc::FFcleanup *row = (amc::FFcleanup*)fcleanup_AllocMem();
    if (row) {
        new (row) amc::FFcleanup; // call constructor
    }
    return row;
}

// --- amc.FDb.fcleanup.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcleanup* amc::fcleanup_InsertMaybe(const dmmeta::Fcleanup &value) {
    amc::FFcleanup *row = &fcleanup_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcleanup_CopyIn(*row,const_cast<dmmeta::Fcleanup&>(value));
    bool ok = fcleanup_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcleanup_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcleanup.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcleanup_AllocMem() {
    u64 new_nelems     = _db.fcleanup_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcleanup*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcleanup_lary[bsr];
        if (!lev) {
            lev=(amc::FFcleanup*)amc::lpool_AllocMem(sizeof(amc::FFcleanup) * (u64(1)<<bsr));
            _db.fcleanup_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcleanup_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcleanup.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcleanup_RemoveLast() {
    u64 n = _db.fcleanup_n;
    if (n > 0) {
        n -= 1;
        fcleanup_qFind(u64(n)).~FFcleanup();
        _db.fcleanup_n = i32(n);
    }
}

// --- amc.FDb.fcleanup.InputMaybe
static bool amc::fcleanup_InputMaybe(dmmeta::Fcleanup &elem) {
    bool retval = true;
    retval = fcleanup_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcleanup.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcleanup_XrefMaybe(amc::FFcleanup &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fcleanup: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fcleanup into index c_fcleanup
    if (true) { // user-defined insert condition
        bool success = c_fcleanup_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fcleanup"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fdec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFdec& amc::fdec_Alloc() {
    amc::FFdec* row = fdec_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fdec  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fdec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFdec* amc::fdec_AllocMaybe() {
    amc::FFdec *row = (amc::FFdec*)fdec_AllocMem();
    if (row) {
        new (row) amc::FFdec; // call constructor
    }
    return row;
}

// --- amc.FDb.fdec.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFdec* amc::fdec_InsertMaybe(const dmmeta::Fdec &value) {
    amc::FFdec *row = &fdec_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fdec_CopyIn(*row,const_cast<dmmeta::Fdec&>(value));
    bool ok = fdec_XrefMaybe(*row); // this may return false
    if (!ok) {
        fdec_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fdec.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fdec_AllocMem() {
    u64 new_nelems     = _db.fdec_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFdec*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fdec_lary[bsr];
        if (!lev) {
            lev=(amc::FFdec*)amc::lpool_AllocMem(sizeof(amc::FFdec) * (u64(1)<<bsr));
            _db.fdec_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fdec_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fdec.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fdec_RemoveLast() {
    u64 n = _db.fdec_n;
    if (n > 0) {
        n -= 1;
        fdec_qFind(u64(n)).~FFdec();
        _db.fdec_n = i32(n);
    }
}

// --- amc.FDb.fdec.InputMaybe
static bool amc::fdec_InputMaybe(dmmeta::Fdec &elem) {
    bool retval = true;
    retval = fdec_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fdec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fdec_XrefMaybe(amc::FFdec &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fdec: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fdec into index ind_fdec
    if (true) { // user-defined insert condition
        bool success = ind_fdec_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fdec"; // check for duplicate key
            return false;
        }
    }
    // insert fdec into index c_fdec
    if (true) { // user-defined insert condition
        bool success = c_fdec_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fdec"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fdec.Find
// Find row by key. Return NULL if not found.
amc::FFdec* amc::ind_fdec_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fdec_buckets_n - 1);
    amc::FFdec* *e = &_db.ind_fdec_buckets_elems[index];
    amc::FFdec* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_fdec_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fdec.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFdec& amc::ind_fdec_GetOrCreate(const algo::strptr& key) {
    amc::FFdec* ret = ind_fdec_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fdec_Alloc();
        (*ret).field = key;
        bool good = fdec_XrefMaybe(*ret);
        if (!good) {
            fdec_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fdec  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fdec.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fdec_InsertMaybe(amc::FFdec& row) {
    ind_fdec_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fdec_next == (amc::FFdec*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fdec_buckets_n - 1);
        amc::FFdec* *prev = &_db.ind_fdec_buckets_elems[index];
        do {
            amc::FFdec* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fdec_next;
        } while (true);
        if (retval) {
            row.ind_fdec_next = *prev;
            _db.ind_fdec_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fdec.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fdec_Remove(amc::FFdec& row) {
    if (LIKELY(row.ind_fdec_next != (amc::FFdec*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fdec_buckets_n - 1);
        amc::FFdec* *prev = &_db.ind_fdec_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFdec *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fdec_next; // unlink (singly linked list)
                _db.ind_fdec_n--;
                row.ind_fdec_next = (amc::FFdec*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fdec_next;
        }
    }
}

// --- amc.FDb.ind_fdec.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fdec_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fdec_buckets_n;
    u32 new_nelems   = _db.ind_fdec_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFdec*);
        u32 new_size = new_nbuckets * sizeof(amc::FFdec*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFdec* *new_buckets = (amc::FFdec**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fdec");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fdec_buckets_n; i++) {
            amc::FFdec* elem = _db.ind_fdec_buckets_elems[i];
            while (elem) {
                amc::FFdec &row        = *elem;
                amc::FFdec* next       = row.ind_fdec_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_fdec_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fdec_buckets_elems, old_size);
        _db.ind_fdec_buckets_elems = new_buckets;
        _db.ind_fdec_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ind_reftype.Find
// Find row by key. Return NULL if not found.
amc::FReftype* amc::ind_reftype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_reftype_buckets_n - 1);
    amc::FReftype* *e = &_db.ind_reftype_buckets_elems[index];
    amc::FReftype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).reftype == key;
        if (done) break;
        e         = &ret->ind_reftype_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_reftype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FReftype& amc::ind_reftype_GetOrCreate(const algo::strptr& key) {
    amc::FReftype* ret = ind_reftype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &reftype_Alloc();
        (*ret).reftype = key;
        bool good = reftype_XrefMaybe(*ret);
        if (!good) {
            reftype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_reftype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_reftype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_reftype_InsertMaybe(amc::FReftype& row) {
    ind_reftype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_reftype_next == (amc::FReftype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.reftype) & (_db.ind_reftype_buckets_n - 1);
        amc::FReftype* *prev = &_db.ind_reftype_buckets_elems[index];
        do {
            amc::FReftype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).reftype == row.reftype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_reftype_next;
        } while (true);
        if (retval) {
            row.ind_reftype_next = *prev;
            _db.ind_reftype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_reftype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_reftype_Remove(amc::FReftype& row) {
    if (LIKELY(row.ind_reftype_next != (amc::FReftype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.reftype) & (_db.ind_reftype_buckets_n - 1);
        amc::FReftype* *prev = &_db.ind_reftype_buckets_elems[index]; // addr of pointer to current element
        while (amc::FReftype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_reftype_next; // unlink (singly linked list)
                _db.ind_reftype_n--;
                row.ind_reftype_next = (amc::FReftype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_reftype_next;
        }
    }
}

// --- amc.FDb.ind_reftype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_reftype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_reftype_buckets_n;
    u32 new_nelems   = _db.ind_reftype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FReftype*);
        u32 new_size = new_nbuckets * sizeof(amc::FReftype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FReftype* *new_buckets = (amc::FReftype**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_reftype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_reftype_buckets_n; i++) {
            amc::FReftype* elem = _db.ind_reftype_buckets_elems[i];
            while (elem) {
                amc::FReftype &row        = *elem;
                amc::FReftype* next       = row.ind_reftype_next;
                u32 index          = algo::Smallstr50_Hash(0, row.reftype) & (new_nbuckets-1);
                row.ind_reftype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_reftype_buckets_elems, old_size);
        _db.ind_reftype_buckets_elems = new_buckets;
        _db.ind_reftype_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fconst.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFconst& amc::fconst_Alloc() {
    amc::FFconst* row = fconst_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fconst  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fconst.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFconst* amc::fconst_AllocMaybe() {
    amc::FFconst *row = (amc::FFconst*)fconst_AllocMem();
    if (row) {
        new (row) amc::FFconst; // call constructor
    }
    return row;
}

// --- amc.FDb.fconst.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFconst* amc::fconst_InsertMaybe(const dmmeta::Fconst &value) {
    amc::FFconst *row = &fconst_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fconst_CopyIn(*row,const_cast<dmmeta::Fconst&>(value));
    bool ok = fconst_XrefMaybe(*row); // this may return false
    if (!ok) {
        fconst_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fconst.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fconst_AllocMem() {
    u64 new_nelems     = _db.fconst_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFconst*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fconst_lary[bsr];
        if (!lev) {
            lev=(amc::FFconst*)amc::lpool_AllocMem(sizeof(amc::FFconst) * (u64(1)<<bsr));
            _db.fconst_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fconst_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fconst.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fconst_RemoveLast() {
    u64 n = _db.fconst_n;
    if (n > 0) {
        n -= 1;
        fconst_qFind(u64(n)).~FFconst();
        _db.fconst_n = i32(n);
    }
}

// --- amc.FDb.fconst.InputMaybe
static bool amc::fconst_InputMaybe(dmmeta::Fconst &elem) {
    bool retval = true;
    retval = fconst_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fconst.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fconst_XrefMaybe(amc::FFconst &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(field_Get(row));
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", field_Get(row));
        return false;
    }
    // fconst: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fconst into index ind_fconst
    if (true) { // user-defined insert condition
        bool success = ind_fconst_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fconst"; // check for duplicate key
            return false;
        }
    }
    // insert fconst into index c_fconst
    if (true) { // user-defined insert condition
        c_fconst_Insert(*p_field, row);
    }
    return retval;
}

// --- amc.FDb.ind_fconst.Find
// Find row by key. Return NULL if not found.
amc::FFconst* amc::ind_fconst_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fconst_buckets_n - 1);
    amc::FFconst* *e = &_db.ind_fconst_buckets_elems[index];
    amc::FFconst* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fconst == key;
        if (done) break;
        e         = &ret->ind_fconst_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fconst.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFconst& amc::ind_fconst_GetOrCreate(const algo::strptr& key) {
    amc::FFconst* ret = ind_fconst_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fconst_Alloc();
        (*ret).fconst = key;
        bool good = fconst_XrefMaybe(*ret);
        if (!good) {
            fconst_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fconst  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fconst.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fconst_InsertMaybe(amc::FFconst& row) {
    ind_fconst_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fconst_next == (amc::FFconst*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fconst) & (_db.ind_fconst_buckets_n - 1);
        amc::FFconst* *prev = &_db.ind_fconst_buckets_elems[index];
        do {
            amc::FFconst* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fconst == row.fconst) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fconst_next;
        } while (true);
        if (retval) {
            row.ind_fconst_next = *prev;
            _db.ind_fconst_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fconst.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fconst_Remove(amc::FFconst& row) {
    if (LIKELY(row.ind_fconst_next != (amc::FFconst*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fconst) & (_db.ind_fconst_buckets_n - 1);
        amc::FFconst* *prev = &_db.ind_fconst_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFconst *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fconst_next; // unlink (singly linked list)
                _db.ind_fconst_n--;
                row.ind_fconst_next = (amc::FFconst*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fconst_next;
        }
    }
}

// --- amc.FDb.ind_fconst.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fconst_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fconst_buckets_n;
    u32 new_nelems   = _db.ind_fconst_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFconst*);
        u32 new_size = new_nbuckets * sizeof(amc::FFconst*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFconst* *new_buckets = (amc::FFconst**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fconst");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fconst_buckets_n; i++) {
            amc::FFconst* elem = _db.ind_fconst_buckets_elems[i];
            while (elem) {
                amc::FFconst &row        = *elem;
                amc::FFconst* next       = row.ind_fconst_next;
                u32 index          = algo::Smallstr100_Hash(0, row.fconst) & (new_nbuckets-1);
                row.ind_fconst_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fconst_buckets_elems, old_size);
        _db.ind_fconst_buckets_elems = new_buckets;
        _db.ind_fconst_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.c_ns_sorted.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ns_sorted_Insert(amc::FNs& row) {
    // reserve space
    c_ns_sorted_Reserve(1);
    u32 n  = _db.c_ns_sorted_n;
    u32 at = n;
    amc::FNs* *elems = _db.c_ns_sorted_elems;
    elems[at] = &row;
    _db.c_ns_sorted_n = n+1;

}

// --- amc.FDb.c_ns_sorted.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_ns_sorted_ScanInsertMaybe(amc::FNs& row) {
    bool retval = true;
    u32 n  = _db.c_ns_sorted_n;
    for (u32 i = 0; i < n; i++) {
        if (_db.c_ns_sorted_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ns_sorted_Reserve(1);
        _db.c_ns_sorted_elems[n] = &row;
        _db.c_ns_sorted_n = n+1;
    }
    return retval;
}

// --- amc.FDb.c_ns_sorted.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ns_sorted_Remove(amc::FNs& row) {
    int lim = _db.c_ns_sorted_n;
    amc::FNs* *elems = _db.c_ns_sorted_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FNs* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FNs*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            _db.c_ns_sorted_n = lim - 1;
            break;
        }
    }
}

// --- amc.FDb.c_ns_sorted.Reserve
// Reserve space in index for N more elements;
void amc::c_ns_sorted_Reserve(u32 n) {
    u32 old_max = _db.c_ns_sorted_max;
    if (UNLIKELY(_db.c_ns_sorted_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FNs*);
        u32 new_size = new_max * sizeof(amc::FNs*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_ns_sorted_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_ns_sorted");
        }
        _db.c_ns_sorted_elems = (amc::FNs**)new_mem;
        _db.c_ns_sorted_max = new_max;
    }
}

// --- amc.FDb.finput.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFinput& amc::finput_Alloc() {
    amc::FFinput* row = finput_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.finput  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.finput.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFinput* amc::finput_AllocMaybe() {
    amc::FFinput *row = (amc::FFinput*)finput_AllocMem();
    if (row) {
        new (row) amc::FFinput; // call constructor
    }
    return row;
}

// --- amc.FDb.finput.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFinput* amc::finput_InsertMaybe(const dmmeta::Finput &value) {
    amc::FFinput *row = &finput_Alloc(); // if out of memory, process dies. if input error, return NULL.
    finput_CopyIn(*row,const_cast<dmmeta::Finput&>(value));
    bool ok = finput_XrefMaybe(*row); // this may return false
    if (!ok) {
        finput_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.finput.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::finput_AllocMem() {
    u64 new_nelems     = _db.finput_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFinput*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.finput_lary[bsr];
        if (!lev) {
            lev=(amc::FFinput*)amc::lpool_AllocMem(sizeof(amc::FFinput) * (u64(1)<<bsr));
            _db.finput_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.finput_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.finput.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::finput_RemoveLast() {
    u64 n = _db.finput_n;
    if (n > 0) {
        n -= 1;
        finput_qFind(u64(n)).~FFinput();
        _db.finput_n = i32(n);
    }
}

// --- amc.FDb.finput.InputMaybe
static bool amc::finput_InputMaybe(dmmeta::Finput &elem) {
    bool retval = true;
    retval = finput_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.finput.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::finput_XrefMaybe(amc::FFinput &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // finput: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert finput into index c_finput
    if (true) { // user-defined insert condition
        bool success = c_finput_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_finput"; // check for duplicate key
            return false;
        }
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert finput into index c_finput
    if (true) { // user-defined insert condition
        c_finput_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.foutput.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFoutput& amc::foutput_Alloc() {
    amc::FFoutput* row = foutput_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.foutput  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.foutput.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFoutput* amc::foutput_AllocMaybe() {
    amc::FFoutput *row = (amc::FFoutput*)foutput_AllocMem();
    if (row) {
        new (row) amc::FFoutput; // call constructor
    }
    return row;
}

// --- amc.FDb.foutput.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFoutput* amc::foutput_InsertMaybe(const dmmeta::Foutput &value) {
    amc::FFoutput *row = &foutput_Alloc(); // if out of memory, process dies. if input error, return NULL.
    foutput_CopyIn(*row,const_cast<dmmeta::Foutput&>(value));
    bool ok = foutput_XrefMaybe(*row); // this may return false
    if (!ok) {
        foutput_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.foutput.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::foutput_AllocMem() {
    u64 new_nelems     = _db.foutput_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFoutput*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.foutput_lary[bsr];
        if (!lev) {
            lev=(amc::FFoutput*)amc::lpool_AllocMem(sizeof(amc::FFoutput) * (u64(1)<<bsr));
            _db.foutput_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.foutput_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.foutput.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::foutput_RemoveLast() {
    u64 n = _db.foutput_n;
    if (n > 0) {
        n -= 1;
        foutput_qFind(u64(n)).~FFoutput();
        _db.foutput_n = i32(n);
    }
}

// --- amc.FDb.foutput.InputMaybe
static bool amc::foutput_InputMaybe(dmmeta::Foutput &elem) {
    bool retval = true;
    retval = foutput_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.foutput.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::foutput_XrefMaybe(amc::FFoutput &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert foutput into index c_foutput
    if (true) { // user-defined insert condition
        bool success = c_foutput_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_foutput"; // check for duplicate key
            return false;
        }
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert foutput into index c_foutput
    if (true) { // user-defined insert condition
        c_foutput_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.fbuf.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbuf& amc::fbuf_Alloc() {
    amc::FFbuf* row = fbuf_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fbuf  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fbuf.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbuf* amc::fbuf_AllocMaybe() {
    amc::FFbuf *row = (amc::FFbuf*)fbuf_AllocMem();
    if (row) {
        new (row) amc::FFbuf; // call constructor
    }
    return row;
}

// --- amc.FDb.fbuf.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbuf* amc::fbuf_InsertMaybe(const dmmeta::Fbuf &value) {
    amc::FFbuf *row = &fbuf_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fbuf_CopyIn(*row,const_cast<dmmeta::Fbuf&>(value));
    bool ok = fbuf_XrefMaybe(*row); // this may return false
    if (!ok) {
        fbuf_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fbuf.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fbuf_AllocMem() {
    u64 new_nelems     = _db.fbuf_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFbuf*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fbuf_lary[bsr];
        if (!lev) {
            lev=(amc::FFbuf*)amc::lpool_AllocMem(sizeof(amc::FFbuf) * (u64(1)<<bsr));
            _db.fbuf_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fbuf_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fbuf.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fbuf_RemoveLast() {
    u64 n = _db.fbuf_n;
    if (n > 0) {
        n -= 1;
        fbuf_qFind(u64(n)).~FFbuf();
        _db.fbuf_n = i32(n);
    }
}

// --- amc.FDb.fbuf.InputMaybe
static bool amc::fbuf_InputMaybe(dmmeta::Fbuf &elem) {
    bool retval = true;
    retval = fbuf_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fbuf.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fbuf_XrefMaybe(amc::FFbuf &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_insready = amc::ind_field_Find(row.insready);
    if (UNLIKELY(!p_insready)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.insready);
        return false;
    }
    // fbuf: save pointer to insready
    if (true) { // user-defined insert condition
        row.p_insready = p_insready;
    }
    amc::FField* p_inseof = amc::ind_field_Find(row.inseof);
    if (UNLIKELY(!p_inseof)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.inseof);
        return false;
    }
    // fbuf: save pointer to inseof
    if (true) { // user-defined insert condition
        row.p_inseof = p_inseof;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fbuf into index c_fbuf
    if (true) { // user-defined insert condition
        bool success = c_fbuf_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fbuf"; // check for duplicate key
            return false;
        }
    }
    // insert fbuf into index ind_fbuf
    if (true) { // user-defined insert condition
        bool success = ind_fbuf_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fbuf"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fbuf.Find
// Find row by key. Return NULL if not found.
amc::FFbuf* amc::ind_fbuf_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fbuf_buckets_n - 1);
    amc::FFbuf* *e = &_db.ind_fbuf_buckets_elems[index];
    amc::FFbuf* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).field == key;
        if (done) break;
        e         = &ret->ind_fbuf_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fbuf.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFbuf& amc::ind_fbuf_GetOrCreate(const algo::strptr& key) {
    amc::FFbuf* ret = ind_fbuf_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fbuf_Alloc();
        (*ret).field = key;
        bool good = fbuf_XrefMaybe(*ret);
        if (!good) {
            fbuf_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fbuf  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fbuf.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fbuf_InsertMaybe(amc::FFbuf& row) {
    ind_fbuf_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fbuf_next == (amc::FFbuf*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fbuf_buckets_n - 1);
        amc::FFbuf* *prev = &_db.ind_fbuf_buckets_elems[index];
        do {
            amc::FFbuf* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).field == row.field) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fbuf_next;
        } while (true);
        if (retval) {
            row.ind_fbuf_next = *prev;
            _db.ind_fbuf_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fbuf.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fbuf_Remove(amc::FFbuf& row) {
    if (LIKELY(row.ind_fbuf_next != (amc::FFbuf*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.field) & (_db.ind_fbuf_buckets_n - 1);
        amc::FFbuf* *prev = &_db.ind_fbuf_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFbuf *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fbuf_next; // unlink (singly linked list)
                _db.ind_fbuf_n--;
                row.ind_fbuf_next = (amc::FFbuf*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fbuf_next;
        }
    }
}

// --- amc.FDb.ind_fbuf.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fbuf_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fbuf_buckets_n;
    u32 new_nelems   = _db.ind_fbuf_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFbuf*);
        u32 new_size = new_nbuckets * sizeof(amc::FFbuf*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFbuf* *new_buckets = (amc::FFbuf**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fbuf");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fbuf_buckets_n; i++) {
            amc::FFbuf* elem = _db.ind_fbuf_buckets_elems[i];
            while (elem) {
                amc::FFbuf &row        = *elem;
                amc::FFbuf* next       = row.ind_fbuf_next;
                u32 index          = algo::Smallstr100_Hash(0, row.field) & (new_nbuckets-1);
                row.ind_fbuf_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fbuf_buckets_elems, old_size);
        _db.ind_fbuf_buckets_elems = new_buckets;
        _db.ind_fbuf_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.chash.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FChash& amc::chash_Alloc() {
    amc::FChash* row = chash_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.chash  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.chash.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FChash* amc::chash_AllocMaybe() {
    amc::FChash *row = (amc::FChash*)chash_AllocMem();
    if (row) {
        new (row) amc::FChash; // call constructor
    }
    return row;
}

// --- amc.FDb.chash.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FChash* amc::chash_InsertMaybe(const dmmeta::Chash &value) {
    amc::FChash *row = &chash_Alloc(); // if out of memory, process dies. if input error, return NULL.
    chash_CopyIn(*row,const_cast<dmmeta::Chash&>(value));
    bool ok = chash_XrefMaybe(*row); // this may return false
    if (!ok) {
        chash_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.chash.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::chash_AllocMem() {
    u64 new_nelems     = _db.chash_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FChash*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.chash_lary[bsr];
        if (!lev) {
            lev=(amc::FChash*)amc::lpool_AllocMem(sizeof(amc::FChash) * (u64(1)<<bsr));
            _db.chash_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.chash_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.chash.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::chash_RemoveLast() {
    u64 n = _db.chash_n;
    if (n > 0) {
        n -= 1;
        chash_qFind(u64(n)).~FChash();
        _db.chash_n = i32(n);
    }
}

// --- amc.FDb.chash.InputMaybe
static bool amc::chash_InputMaybe(dmmeta::Chash &elem) {
    bool retval = true;
    retval = chash_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.chash.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::chash_XrefMaybe(amc::FChash &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert chash into index c_chash
    if (true) { // user-defined insert condition
        bool success = c_chash_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_chash"; // check for duplicate key
            return false;
        }
    }
    // insert chash into index ind_chash
    if (true) { // user-defined insert condition
        bool success = ind_chash_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_chash"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_chash.Find
// Find row by key. Return NULL if not found.
amc::FChash* amc::ind_chash_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_chash_buckets_n - 1);
    amc::FChash* *e = &_db.ind_chash_buckets_elems[index];
    amc::FChash* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_chash_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_chash.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FChash& amc::ind_chash_GetOrCreate(const algo::strptr& key) {
    amc::FChash* ret = ind_chash_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &chash_Alloc();
        (*ret).ctype = key;
        bool good = chash_XrefMaybe(*ret);
        if (!good) {
            chash_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_chash  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_chash.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_chash_InsertMaybe(amc::FChash& row) {
    ind_chash_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_chash_next == (amc::FChash*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_chash_buckets_n - 1);
        amc::FChash* *prev = &_db.ind_chash_buckets_elems[index];
        do {
            amc::FChash* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_chash_next;
        } while (true);
        if (retval) {
            row.ind_chash_next = *prev;
            _db.ind_chash_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_chash.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_chash_Remove(amc::FChash& row) {
    if (LIKELY(row.ind_chash_next != (amc::FChash*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_chash_buckets_n - 1);
        amc::FChash* *prev = &_db.ind_chash_buckets_elems[index]; // addr of pointer to current element
        while (amc::FChash *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_chash_next; // unlink (singly linked list)
                _db.ind_chash_n--;
                row.ind_chash_next = (amc::FChash*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_chash_next;
        }
    }
}

// --- amc.FDb.ind_chash.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_chash_Reserve(int n) {
    u32 old_nbuckets = _db.ind_chash_buckets_n;
    u32 new_nelems   = _db.ind_chash_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FChash*);
        u32 new_size = new_nbuckets * sizeof(amc::FChash*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FChash* *new_buckets = (amc::FChash**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_chash");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_chash_buckets_n; i++) {
            amc::FChash* elem = _db.ind_chash_buckets_elems[i];
            while (elem) {
                amc::FChash &row        = *elem;
                amc::FChash* next       = row.ind_chash_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_chash_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_chash_buckets_elems, old_size);
        _db.ind_chash_buckets_elems = new_buckets;
        _db.ind_chash_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ccmp.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCcmp& amc::ccmp_Alloc() {
    amc::FCcmp* row = ccmp_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ccmp  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ccmp.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCcmp* amc::ccmp_AllocMaybe() {
    amc::FCcmp *row = (amc::FCcmp*)ccmp_AllocMem();
    if (row) {
        new (row) amc::FCcmp; // call constructor
    }
    return row;
}

// --- amc.FDb.ccmp.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCcmp* amc::ccmp_InsertMaybe(const dmmeta::Ccmp &value) {
    amc::FCcmp *row = &ccmp_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ccmp_CopyIn(*row,const_cast<dmmeta::Ccmp&>(value));
    bool ok = ccmp_XrefMaybe(*row); // this may return false
    if (!ok) {
        ccmp_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ccmp.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ccmp_AllocMem() {
    u64 new_nelems     = _db.ccmp_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCcmp*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ccmp_lary[bsr];
        if (!lev) {
            lev=(amc::FCcmp*)amc::lpool_AllocMem(sizeof(amc::FCcmp) * (u64(1)<<bsr));
            _db.ccmp_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ccmp_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ccmp.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ccmp_RemoveLast() {
    u64 n = _db.ccmp_n;
    if (n > 0) {
        n -= 1;
        ccmp_qFind(u64(n)).~FCcmp();
        _db.ccmp_n = i32(n);
    }
}

// --- amc.FDb.ccmp.InputMaybe
static bool amc::ccmp_InputMaybe(dmmeta::Ccmp &elem) {
    bool retval = true;
    retval = ccmp_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ccmp.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ccmp_XrefMaybe(amc::FCcmp &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert ccmp into index c_ccmp
    if (true) { // user-defined insert condition
        bool success = c_ccmp_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_ccmp"; // check for duplicate key
            return false;
        }
    }
    // insert ccmp into index ind_ccmp
    if (true) { // user-defined insert condition
        bool success = ind_ccmp_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_ccmp"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ccmp.Find
// Find row by key. Return NULL if not found.
amc::FCcmp* amc::ind_ccmp_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_ccmp_buckets_n - 1);
    amc::FCcmp* *e = &_db.ind_ccmp_buckets_elems[index];
    amc::FCcmp* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ctype == key;
        if (done) break;
        e         = &ret->ind_ccmp_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_ccmp.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCcmp& amc::ind_ccmp_GetOrCreate(const algo::strptr& key) {
    amc::FCcmp* ret = ind_ccmp_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &ccmp_Alloc();
        (*ret).ctype = key;
        bool good = ccmp_XrefMaybe(*ret);
        if (!good) {
            ccmp_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_ccmp  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_ccmp.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_ccmp_InsertMaybe(amc::FCcmp& row) {
    ind_ccmp_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_ccmp_next == (amc::FCcmp*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ccmp_buckets_n - 1);
        amc::FCcmp* *prev = &_db.ind_ccmp_buckets_elems[index];
        do {
            amc::FCcmp* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ctype == row.ctype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_ccmp_next;
        } while (true);
        if (retval) {
            row.ind_ccmp_next = *prev;
            _db.ind_ccmp_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_ccmp.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_ccmp_Remove(amc::FCcmp& row) {
    if (LIKELY(row.ind_ccmp_next != (amc::FCcmp*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.ctype) & (_db.ind_ccmp_buckets_n - 1);
        amc::FCcmp* *prev = &_db.ind_ccmp_buckets_elems[index]; // addr of pointer to current element
        while (amc::FCcmp *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_ccmp_next; // unlink (singly linked list)
                _db.ind_ccmp_n--;
                row.ind_ccmp_next = (amc::FCcmp*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_ccmp_next;
        }
    }
}

// --- amc.FDb.ind_ccmp.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_ccmp_Reserve(int n) {
    u32 old_nbuckets = _db.ind_ccmp_buckets_n;
    u32 new_nelems   = _db.ind_ccmp_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FCcmp*);
        u32 new_size = new_nbuckets * sizeof(amc::FCcmp*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FCcmp* *new_buckets = (amc::FCcmp**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_ccmp");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_ccmp_buckets_n; i++) {
            amc::FCcmp* elem = _db.ind_ccmp_buckets_elems[i];
            while (elem) {
                amc::FCcmp &row        = *elem;
                amc::FCcmp* next       = row.ind_ccmp_next;
                u32 index          = algo::Smallstr50_Hash(0, row.ctype) & (new_nbuckets-1);
                row.ind_ccmp_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_ccmp_buckets_elems, old_size);
        _db.ind_ccmp_buckets_elems = new_buckets;
        _db.ind_ccmp_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fbigend.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbigend& amc::fbigend_Alloc() {
    amc::FFbigend* row = fbigend_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fbigend  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fbigend.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbigend* amc::fbigend_AllocMaybe() {
    amc::FFbigend *row = (amc::FFbigend*)fbigend_AllocMem();
    if (row) {
        new (row) amc::FFbigend; // call constructor
    }
    return row;
}

// --- amc.FDb.fbigend.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbigend* amc::fbigend_InsertMaybe(const dmmeta::Fbigend &value) {
    amc::FFbigend *row = &fbigend_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fbigend_CopyIn(*row,const_cast<dmmeta::Fbigend&>(value));
    bool ok = fbigend_XrefMaybe(*row); // this may return false
    if (!ok) {
        fbigend_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fbigend.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fbigend_AllocMem() {
    u64 new_nelems     = _db.fbigend_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFbigend*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fbigend_lary[bsr];
        if (!lev) {
            lev=(amc::FFbigend*)amc::lpool_AllocMem(sizeof(amc::FFbigend) * (u64(1)<<bsr));
            _db.fbigend_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fbigend_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fbigend.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fbigend_RemoveLast() {
    u64 n = _db.fbigend_n;
    if (n > 0) {
        n -= 1;
        fbigend_qFind(u64(n)).~FFbigend();
        _db.fbigend_n = i32(n);
    }
}

// --- amc.FDb.fbigend.InputMaybe
static bool amc::fbigend_InputMaybe(dmmeta::Fbigend &elem) {
    bool retval = true;
    retval = fbigend_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fbigend.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fbigend_XrefMaybe(amc::FFbigend &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fbigend: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fbigend into index c_fbigend
    if (true) { // user-defined insert condition
        bool success = c_fbigend_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fbigend"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.zsl_ctype_pack_tran.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zsl_ctype_pack_tran_Insert(amc::FCtype& row) {
    if (!zsl_ctype_pack_tran_InLlistQ(row)) {
        amc::FCtype* old_head = _db.zsl_ctype_pack_tran_head;
        row.zsl_ctype_pack_tran_next  = old_head;
        _db.zsl_ctype_pack_tran_head = &row;
    }
}

// --- amc.FDb.zsl_ctype_pack_tran.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zsl_ctype_pack_tran_Remove(amc::FCtype& row) {
    if (zsl_ctype_pack_tran_InLlistQ(row)) {
        amc::FCtype* old_head       = _db.zsl_ctype_pack_tran_head;
        (void)old_head; // in case it's not used
        amc::FCtype* prev=NULL;
        amc::FCtype* cur     = _db.zsl_ctype_pack_tran_head;
        while (cur) {  // search for element by pointer
            amc::FCtype* next = cur->zsl_ctype_pack_tran_next;
            if (cur == &row) {
                // disconnect element from linked list
                if (prev) {
                    prev->zsl_ctype_pack_tran_next = next;
                } else {
                    _db.zsl_ctype_pack_tran_head = next;
                }
                row.zsl_ctype_pack_tran_next = (amc::FCtype*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FDb.zsl_ctype_pack_tran.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zsl_ctype_pack_tran_RemoveAll() {
    amc::FCtype* row = _db.zsl_ctype_pack_tran_head;
    _db.zsl_ctype_pack_tran_head = NULL;
    while (row) {
        amc::FCtype* row_next = row->zsl_ctype_pack_tran_next;
        row->zsl_ctype_pack_tran_next  = (amc::FCtype*)-1;
        row = row_next;
    }
}

// --- amc.FDb.zsl_ctype_pack_tran.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCtype* amc::zsl_ctype_pack_tran_RemoveFirst() {
    amc::FCtype *row = NULL;
    row = _db.zsl_ctype_pack_tran_head;
    if (row) {
        amc::FCtype *next = row->zsl_ctype_pack_tran_next;
        _db.zsl_ctype_pack_tran_head = next;
        row->zsl_ctype_pack_tran_next = (amc::FCtype*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.cstr.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCstr& amc::cstr_Alloc() {
    amc::FCstr* row = cstr_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cstr  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cstr.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCstr* amc::cstr_AllocMaybe() {
    amc::FCstr *row = (amc::FCstr*)cstr_AllocMem();
    if (row) {
        new (row) amc::FCstr; // call constructor
    }
    return row;
}

// --- amc.FDb.cstr.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCstr* amc::cstr_InsertMaybe(const dmmeta::Cstr &value) {
    amc::FCstr *row = &cstr_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cstr_CopyIn(*row,const_cast<dmmeta::Cstr&>(value));
    bool ok = cstr_XrefMaybe(*row); // this may return false
    if (!ok) {
        cstr_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cstr.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cstr_AllocMem() {
    u64 new_nelems     = _db.cstr_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCstr*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cstr_lary[bsr];
        if (!lev) {
            lev=(amc::FCstr*)amc::lpool_AllocMem(sizeof(amc::FCstr) * (u64(1)<<bsr));
            _db.cstr_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cstr_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cstr.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cstr_RemoveLast() {
    u64 n = _db.cstr_n;
    if (n > 0) {
        n -= 1;
        cstr_qFind(u64(n)).~FCstr();
        _db.cstr_n = i32(n);
    }
}

// --- amc.FDb.cstr.InputMaybe
static bool amc::cstr_InputMaybe(dmmeta::Cstr &elem) {
    bool retval = true;
    retval = cstr_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cstr.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cstr_XrefMaybe(amc::FCstr &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cstr into index c_cstr
    if (true) { // user-defined insert condition
        bool success = c_cstr_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_cstr"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.listtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FListtype& amc::listtype_Alloc() {
    amc::FListtype* row = listtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.listtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.listtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FListtype* amc::listtype_AllocMaybe() {
    amc::FListtype *row = (amc::FListtype*)listtype_AllocMem();
    if (row) {
        new (row) amc::FListtype; // call constructor
    }
    return row;
}

// --- amc.FDb.listtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FListtype* amc::listtype_InsertMaybe(const dmmeta::Listtype &value) {
    amc::FListtype *row = &listtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    listtype_CopyIn(*row,const_cast<dmmeta::Listtype&>(value));
    bool ok = listtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.listtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::listtype_AllocMem() {
    u64 new_nelems     = _db.listtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FListtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.listtype_lary[bsr];
        if (!lev) {
            lev=(amc::FListtype*)amc::lpool_AllocMem(sizeof(amc::FListtype) * (u64(1)<<bsr));
            _db.listtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.listtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.listtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::listtype_RemoveLast() {
    u64 n = _db.listtype_n;
    if (n > 0) {
        n -= 1;
        listtype_qFind(u64(n)).~FListtype();
        _db.listtype_n = i32(n);
    }
}

// --- amc.FDb.listtype.InputMaybe
static bool amc::listtype_InputMaybe(dmmeta::Listtype &elem) {
    bool retval = true;
    retval = listtype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.listtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::listtype_XrefMaybe(amc::FListtype &row) {
    bool retval = true;
    (void)row;
    // insert listtype into index ind_listtype
    if (true) { // user-defined insert condition
        bool success = ind_listtype_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_listtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_listtype.Find
// Find row by key. Return NULL if not found.
amc::FListtype* amc::ind_listtype_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr5_Hash(0, key) & (_db.ind_listtype_buckets_n - 1);
    amc::FListtype* *e = &_db.ind_listtype_buckets_elems[index];
    amc::FListtype* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).listtype == key;
        if (done) break;
        e         = &ret->ind_listtype_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_listtype.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FListtype& amc::ind_listtype_GetOrCreate(const algo::strptr& key) {
    amc::FListtype* ret = ind_listtype_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &listtype_Alloc();
        (*ret).listtype = key;
        bool good = listtype_XrefMaybe(*ret);
        if (!good) {
            listtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_listtype  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_listtype.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_listtype_InsertMaybe(amc::FListtype& row) {
    ind_listtype_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_listtype_next == (amc::FListtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        amc::FListtype* *prev = &_db.ind_listtype_buckets_elems[index];
        do {
            amc::FListtype* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).listtype == row.listtype) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_listtype_next;
        } while (true);
        if (retval) {
            row.ind_listtype_next = *prev;
            _db.ind_listtype_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_listtype.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_listtype_Remove(amc::FListtype& row) {
    if (LIKELY(row.ind_listtype_next != (amc::FListtype*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.listtype) & (_db.ind_listtype_buckets_n - 1);
        amc::FListtype* *prev = &_db.ind_listtype_buckets_elems[index]; // addr of pointer to current element
        while (amc::FListtype *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_listtype_next; // unlink (singly linked list)
                _db.ind_listtype_n--;
                row.ind_listtype_next = (amc::FListtype*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_listtype_next;
        }
    }
}

// --- amc.FDb.ind_listtype.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_listtype_Reserve(int n) {
    u32 old_nbuckets = _db.ind_listtype_buckets_n;
    u32 new_nelems   = _db.ind_listtype_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FListtype*);
        u32 new_size = new_nbuckets * sizeof(amc::FListtype*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FListtype* *new_buckets = (amc::FListtype**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_listtype");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_listtype_buckets_n; i++) {
            amc::FListtype* elem = _db.ind_listtype_buckets_elems[i];
            while (elem) {
                amc::FListtype &row        = *elem;
                amc::FListtype* next       = row.ind_listtype_next;
                u32 index          = algo::Smallstr5_Hash(0, row.listtype) & (new_nbuckets-1);
                row.ind_listtype_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_listtype_buckets_elems, old_size);
        _db.ind_listtype_buckets_elems = new_buckets;
        _db.ind_listtype_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fstep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFstep& amc::fstep_Alloc() {
    amc::FFstep* row = fstep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fstep  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fstep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFstep* amc::fstep_AllocMaybe() {
    amc::FFstep *row = (amc::FFstep*)fstep_AllocMem();
    if (row) {
        new (row) amc::FFstep; // call constructor
    }
    return row;
}

// --- amc.FDb.fstep.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFstep* amc::fstep_InsertMaybe(const dmmeta::Fstep &value) {
    amc::FFstep *row = &fstep_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fstep_CopyIn(*row,const_cast<dmmeta::Fstep&>(value));
    bool ok = fstep_XrefMaybe(*row); // this may return false
    if (!ok) {
        fstep_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fstep.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fstep_AllocMem() {
    u64 new_nelems     = _db.fstep_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFstep*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fstep_lary[bsr];
        if (!lev) {
            lev=(amc::FFstep*)amc::lpool_AllocMem(sizeof(amc::FFstep) * (u64(1)<<bsr));
            _db.fstep_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fstep_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fstep.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fstep_RemoveLast() {
    u64 n = _db.fstep_n;
    if (n > 0) {
        n -= 1;
        fstep_qFind(u64(n)).~FFstep();
        _db.fstep_n = i32(n);
    }
}

// --- amc.FDb.fstep.InputMaybe
static bool amc::fstep_InputMaybe(dmmeta::Fstep &elem) {
    bool retval = true;
    retval = fstep_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fstep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fstep_XrefMaybe(amc::FFstep &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(field_Get(row));
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", field_Get(row));
        return false;
    }
    // fstep: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert fstep into index c_fstep
    if (true) { // user-defined insert condition
        bool success = c_fstep_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fstep"; // check for duplicate key
            return false;
        }
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert fstep into index c_fstep
    if (true) { // user-defined insert condition
        c_fstep_Insert(*p_ns, row);
    }
    // insert fstep into index ind_fstep
    if (true) { // user-defined insert condition
        bool success = ind_fstep_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fstep"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.cextern.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCextern& amc::cextern_Alloc() {
    amc::FCextern* row = cextern_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cextern  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cextern.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCextern* amc::cextern_AllocMaybe() {
    amc::FCextern *row = (amc::FCextern*)cextern_AllocMem();
    if (row) {
        new (row) amc::FCextern; // call constructor
    }
    return row;
}

// --- amc.FDb.cextern.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCextern* amc::cextern_InsertMaybe(const dmmeta::Cextern &value) {
    amc::FCextern *row = &cextern_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cextern_CopyIn(*row,const_cast<dmmeta::Cextern&>(value));
    bool ok = cextern_XrefMaybe(*row); // this may return false
    if (!ok) {
        cextern_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cextern.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cextern_AllocMem() {
    u64 new_nelems     = _db.cextern_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCextern*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cextern_lary[bsr];
        if (!lev) {
            lev=(amc::FCextern*)amc::lpool_AllocMem(sizeof(amc::FCextern) * (u64(1)<<bsr));
            _db.cextern_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cextern_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cextern.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cextern_RemoveLast() {
    u64 n = _db.cextern_n;
    if (n > 0) {
        n -= 1;
        cextern_qFind(u64(n)).~FCextern();
        _db.cextern_n = i32(n);
    }
}

// --- amc.FDb.cextern.InputMaybe
static bool amc::cextern_InputMaybe(dmmeta::Cextern &elem) {
    bool retval = true;
    retval = cextern_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cextern.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cextern_XrefMaybe(amc::FCextern &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cextern into index c_cextern
    if (true) { // user-defined insert condition
        bool success = c_cextern_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_cextern"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fdelay.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFdelay& amc::fdelay_Alloc() {
    amc::FFdelay* row = fdelay_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fdelay  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fdelay.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFdelay* amc::fdelay_AllocMaybe() {
    amc::FFdelay *row = (amc::FFdelay*)fdelay_AllocMem();
    if (row) {
        new (row) amc::FFdelay; // call constructor
    }
    return row;
}

// --- amc.FDb.fdelay.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFdelay* amc::fdelay_InsertMaybe(const dmmeta::Fdelay &value) {
    amc::FFdelay *row = &fdelay_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fdelay_CopyIn(*row,const_cast<dmmeta::Fdelay&>(value));
    bool ok = fdelay_XrefMaybe(*row); // this may return false
    if (!ok) {
        fdelay_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fdelay.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fdelay_AllocMem() {
    u64 new_nelems     = _db.fdelay_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFdelay*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fdelay_lary[bsr];
        if (!lev) {
            lev=(amc::FFdelay*)amc::lpool_AllocMem(sizeof(amc::FFdelay) * (u64(1)<<bsr));
            _db.fdelay_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fdelay_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fdelay.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fdelay_RemoveLast() {
    u64 n = _db.fdelay_n;
    if (n > 0) {
        n -= 1;
        fdelay_qFind(u64(n)).~FFdelay();
        _db.fdelay_n = i32(n);
    }
}

// --- amc.FDb.fdelay.InputMaybe
static bool amc::fdelay_InputMaybe(dmmeta::Fdelay &elem) {
    bool retval = true;
    retval = fdelay_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fdelay.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fdelay_XrefMaybe(amc::FFdelay &row) {
    bool retval = true;
    (void)row;
    amc::FFstep* p_fstep = amc::ind_fstep_Find(row.fstep);
    if (UNLIKELY(!p_fstep)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_fstep" << Keyval("key", row.fstep);
        return false;
    }
    // insert fdelay into index c_fdelay
    if (true) { // user-defined insert condition
        bool success = c_fdelay_InsertMaybe(*p_fstep, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FFstep.c_fdelay"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.disptrace.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDisptrace& amc::disptrace_Alloc() {
    amc::FDisptrace* row = disptrace_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.disptrace  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.disptrace.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDisptrace* amc::disptrace_AllocMaybe() {
    amc::FDisptrace *row = (amc::FDisptrace*)disptrace_AllocMem();
    if (row) {
        new (row) amc::FDisptrace; // call constructor
    }
    return row;
}

// --- amc.FDb.disptrace.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDisptrace* amc::disptrace_InsertMaybe(const dmmeta::Disptrace &value) {
    amc::FDisptrace *row = &disptrace_Alloc(); // if out of memory, process dies. if input error, return NULL.
    disptrace_CopyIn(*row,const_cast<dmmeta::Disptrace&>(value));
    bool ok = disptrace_XrefMaybe(*row); // this may return false
    if (!ok) {
        disptrace_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.disptrace.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::disptrace_AllocMem() {
    u64 new_nelems     = _db.disptrace_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDisptrace*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.disptrace_lary[bsr];
        if (!lev) {
            lev=(amc::FDisptrace*)amc::lpool_AllocMem(sizeof(amc::FDisptrace) * (u64(1)<<bsr));
            _db.disptrace_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.disptrace_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.disptrace.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::disptrace_RemoveLast() {
    u64 n = _db.disptrace_n;
    if (n > 0) {
        n -= 1;
        disptrace_qFind(u64(n)).~FDisptrace();
        _db.disptrace_n = i32(n);
    }
}

// --- amc.FDb.disptrace.InputMaybe
static bool amc::disptrace_InputMaybe(dmmeta::Disptrace &elem) {
    bool retval = true;
    retval = disptrace_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.disptrace.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::disptrace_XrefMaybe(amc::FDisptrace &row) {
    bool retval = true;
    (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (UNLIKELY(!p_dispatch)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_dispatch" << Keyval("key", row.dispatch);
        return false;
    }
    // disptrace: save pointer to dispatch
    if (true) { // user-defined insert condition
        row.p_dispatch = p_dispatch;
    }
    // insert disptrace into index c_disptrace
    if (true) { // user-defined insert condition
        bool success = c_disptrace_InsertMaybe(*p_dispatch, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDispatch.c_disptrace"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fstep.Find
// Find row by key. Return NULL if not found.
amc::FFstep* amc::ind_fstep_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fstep_buckets_n - 1);
    amc::FFstep* *e = &_db.ind_fstep_buckets_elems[index];
    amc::FFstep* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fstep == key;
        if (done) break;
        e         = &ret->ind_fstep_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fstep.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFstep& amc::ind_fstep_GetOrCreate(const algo::strptr& key) {
    amc::FFstep* ret = ind_fstep_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fstep_Alloc();
        (*ret).fstep = key;
        bool good = fstep_XrefMaybe(*ret);
        if (!good) {
            fstep_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fstep  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fstep.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fstep_InsertMaybe(amc::FFstep& row) {
    ind_fstep_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fstep_next == (amc::FFstep*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fstep) & (_db.ind_fstep_buckets_n - 1);
        amc::FFstep* *prev = &_db.ind_fstep_buckets_elems[index];
        do {
            amc::FFstep* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fstep == row.fstep) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fstep_next;
        } while (true);
        if (retval) {
            row.ind_fstep_next = *prev;
            _db.ind_fstep_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fstep.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fstep_Remove(amc::FFstep& row) {
    if (LIKELY(row.ind_fstep_next != (amc::FFstep*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fstep) & (_db.ind_fstep_buckets_n - 1);
        amc::FFstep* *prev = &_db.ind_fstep_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFstep *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fstep_next; // unlink (singly linked list)
                _db.ind_fstep_n--;
                row.ind_fstep_next = (amc::FFstep*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fstep_next;
        }
    }
}

// --- amc.FDb.ind_fstep.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fstep_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fstep_buckets_n;
    u32 new_nelems   = _db.ind_fstep_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFstep*);
        u32 new_size = new_nbuckets * sizeof(amc::FFstep*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFstep* *new_buckets = (amc::FFstep**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fstep");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fstep_buckets_n; i++) {
            amc::FFstep* elem = _db.ind_fstep_buckets_elems[i];
            while (elem) {
                amc::FFstep &row        = *elem;
                amc::FFstep* next       = row.ind_fstep_next;
                u32 index          = algo::Smallstr100_Hash(0, row.fstep) & (new_nbuckets-1);
                row.ind_fstep_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fstep_buckets_elems, old_size);
        _db.ind_fstep_buckets_elems = new_buckets;
        _db.ind_fstep_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.tracefld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTracefld& amc::tracefld_Alloc() {
    amc::FTracefld* row = tracefld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tracefld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tracefld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTracefld* amc::tracefld_AllocMaybe() {
    amc::FTracefld *row = (amc::FTracefld*)tracefld_AllocMem();
    if (row) {
        new (row) amc::FTracefld; // call constructor
    }
    return row;
}

// --- amc.FDb.tracefld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTracefld* amc::tracefld_InsertMaybe(const dmmeta::Tracefld &value) {
    amc::FTracefld *row = &tracefld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tracefld_CopyIn(*row,const_cast<dmmeta::Tracefld&>(value));
    bool ok = tracefld_XrefMaybe(*row); // this may return false
    if (!ok) {
        tracefld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tracefld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::tracefld_AllocMem() {
    u64 new_nelems     = _db.tracefld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTracefld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tracefld_lary[bsr];
        if (!lev) {
            lev=(amc::FTracefld*)amc::lpool_AllocMem(sizeof(amc::FTracefld) * (u64(1)<<bsr));
            _db.tracefld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tracefld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.tracefld.RemoveAll
// Remove all elements from Lary
void amc::tracefld_RemoveAll() {
    for (u64 n = _db.tracefld_n; n>0; ) {
        n--;
        tracefld_qFind(u64(n)).~FTracefld(); // destroy last element
        _db.tracefld_n = i32(n);
    }
}

// --- amc.FDb.tracefld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tracefld_RemoveLast() {
    u64 n = _db.tracefld_n;
    if (n > 0) {
        n -= 1;
        tracefld_qFind(u64(n)).~FTracefld();
        _db.tracefld_n = i32(n);
    }
}

// --- amc.FDb.tracefld.SaveSsimfile
// Save table to ssimfile
bool amc::tracefld_SaveSsimfile(algo::strptr fname) {
    cstring text;
    ind_beg(amc::_db_tracefld_curs, tracefld, amc::_db) {
        dmmeta::Tracefld out;
        tracefld_CopyOut(tracefld, out);
        dmmeta::Tracefld_Print(out, text);
        text << eol;
    }ind_end;
    (void)algo::CreateDirRecurse(algo::GetDirName(fname));
    // it is a silent error if the file cannot be saved.
    return algo::SafeStringToFile(text, fname);
}

// --- amc.FDb.tracefld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tracefld_XrefMaybe(amc::FTracefld &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- amc.FDb.tracerec.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTracerec& amc::tracerec_Alloc() {
    amc::FTracerec* row = tracerec_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tracerec  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tracerec.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTracerec* amc::tracerec_AllocMaybe() {
    amc::FTracerec *row = (amc::FTracerec*)tracerec_AllocMem();
    if (row) {
        new (row) amc::FTracerec; // call constructor
    }
    return row;
}

// --- amc.FDb.tracerec.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTracerec* amc::tracerec_InsertMaybe(const dmmeta::Tracerec &value) {
    amc::FTracerec *row = &tracerec_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tracerec_CopyIn(*row,const_cast<dmmeta::Tracerec&>(value));
    bool ok = tracerec_XrefMaybe(*row); // this may return false
    if (!ok) {
        tracerec_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tracerec.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::tracerec_AllocMem() {
    u64 new_nelems     = _db.tracerec_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTracerec*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tracerec_lary[bsr];
        if (!lev) {
            lev=(amc::FTracerec*)amc::lpool_AllocMem(sizeof(amc::FTracerec) * (u64(1)<<bsr));
            _db.tracerec_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tracerec_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.tracerec.RemoveAll
// Remove all elements from Lary
void amc::tracerec_RemoveAll() {
    for (u64 n = _db.tracerec_n; n>0; ) {
        n--;
        tracerec_qFind(u64(n)).~FTracerec(); // destroy last element
        _db.tracerec_n = i32(n);
    }
}

// --- amc.FDb.tracerec.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tracerec_RemoveLast() {
    u64 n = _db.tracerec_n;
    if (n > 0) {
        n -= 1;
        tracerec_qFind(u64(n)).~FTracerec();
        _db.tracerec_n = i32(n);
    }
}

// --- amc.FDb.tracerec.SaveSsimfile
// Save table to ssimfile
bool amc::tracerec_SaveSsimfile(algo::strptr fname) {
    cstring text;
    ind_beg(amc::_db_tracerec_curs, tracerec, amc::_db) {
        dmmeta::Tracerec out;
        tracerec_CopyOut(tracerec, out);
        dmmeta::Tracerec_Print(out, text);
        text << eol;
    }ind_end;
    (void)algo::CreateDirRecurse(algo::GetDirName(fname));
    // it is a silent error if the file cannot be saved.
    return algo::SafeStringToFile(text, fname);
}

// --- amc.FDb.tracerec.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tracerec_XrefMaybe(amc::FTracerec &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- amc.FDb.dispsig.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispsig& amc::dispsig_Alloc() {
    amc::FDispsig* row = dispsig_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.dispsig  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.dispsig.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispsig* amc::dispsig_AllocMaybe() {
    amc::FDispsig *row = (amc::FDispsig*)dispsig_AllocMem();
    if (row) {
        new (row) amc::FDispsig; // call constructor
    }
    return row;
}

// --- amc.FDb.dispsig.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispsig* amc::dispsig_InsertMaybe(const dmmeta::Dispsig &value) {
    amc::FDispsig *row = &dispsig_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispsig_CopyIn(*row,const_cast<dmmeta::Dispsig&>(value));
    bool ok = dispsig_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispsig_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.dispsig.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::dispsig_AllocMem() {
    u64 new_nelems     = _db.dispsig_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDispsig*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispsig_lary[bsr];
        if (!lev) {
            lev=(amc::FDispsig*)amc::lpool_AllocMem(sizeof(amc::FDispsig) * (u64(1)<<bsr));
            _db.dispsig_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispsig_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.dispsig.RemoveAll
// Remove all elements from Lary
void amc::dispsig_RemoveAll() {
    for (u64 n = _db.dispsig_n; n>0; ) {
        n--;
        dispsig_qFind(u64(n)).~FDispsig(); // destroy last element
        _db.dispsig_n = i32(n);
    }
}

// --- amc.FDb.dispsig.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::dispsig_RemoveLast() {
    u64 n = _db.dispsig_n;
    if (n > 0) {
        n -= 1;
        dispsig_qFind(u64(n)).~FDispsig();
        _db.dispsig_n = i32(n);
    }
}

// --- amc.FDb.dispsig.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::dispsig_XrefMaybe(amc::FDispsig &row) {
    bool retval = true;
    (void)row;
    // insert dispsig into index c_dispsig_sorted
    if (true) { // user-defined insert condition
        c_dispsig_sorted_Insert(row);
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert dispsig into index c_dispsig
    if (true) { // user-defined insert condition
        c_dispsig_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.c_dispsig_sorted.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_dispsig_sorted_Insert(amc::FDispsig& row) {
    if (bool_Update(row._db_c_dispsig_sorted_in_ary,true)) {
        // reserve space
        c_dispsig_sorted_Reserve(1);
        u32 n  = _db.c_dispsig_sorted_n;
        u32 at = n;
        amc::FDispsig* *elems = _db.c_dispsig_sorted_elems;
        elems[at] = &row;
        _db.c_dispsig_sorted_n = n+1;

    }
}

// --- amc.FDb.c_dispsig_sorted.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_dispsig_sorted_InsertMaybe(amc::FDispsig& row) {
    bool retval = !row._db_c_dispsig_sorted_in_ary;
    c_dispsig_sorted_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- amc.FDb.c_dispsig_sorted.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_dispsig_sorted_Remove(amc::FDispsig& row) {
    if (bool_Update(row._db_c_dispsig_sorted_in_ary,false)) {
        int lim = _db.c_dispsig_sorted_n;
        amc::FDispsig* *elems = _db.c_dispsig_sorted_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FDispsig* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FDispsig*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_dispsig_sorted_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FDb.c_dispsig_sorted.Reserve
// Reserve space in index for N more elements;
void amc::c_dispsig_sorted_Reserve(u32 n) {
    u32 old_max = _db.c_dispsig_sorted_max;
    if (UNLIKELY(_db.c_dispsig_sorted_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FDispsig*);
        u32 new_size = new_max * sizeof(amc::FDispsig*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_dispsig_sorted_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_dispsig_sorted");
        }
        _db.c_dispsig_sorted_elems = (amc::FDispsig**)new_mem;
        _db.c_dispsig_sorted_max = new_max;
    }
}

// --- amc.FDb.c_dispsig_sorted.Swap
// Swap values elem_a and elem_b
inline static void amc::c_dispsig_sorted_Swap(amc::FDispsig* &elem_a, amc::FDispsig* &elem_b) {
    amc::FDispsig *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- amc.FDb.c_dispsig_sorted.Rotleft
// Left circular shift of three-tuple
inline static void amc::c_dispsig_sorted_Rotleft(amc::FDispsig* &elem_a, amc::FDispsig* &elem_b, amc::FDispsig* &elem_c) {
    amc::FDispsig *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- amc.FDb.c_dispsig_sorted.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool amc::c_dispsig_sorted_Lt(amc::FDispsig &elem_a, amc::FDispsig &elem_b) {
    bool ret;
    ret = elem_a.dispsig < elem_b.dispsig;
    return ret;
}

// --- amc.FDb.c_dispsig_sorted.SortedQ
// Verify whether array is sorted
bool amc::c_dispsig_sorted_SortedQ() {
    amc::FDispsig* *elems = c_dispsig_sorted_Getary().elems;
    int n = c_dispsig_sorted_N();
    for (int i = 1; i < n; i++) {
        if (c_dispsig_sorted_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- amc.FDb.c_dispsig_sorted.IntInsertionSort
// Internal insertion sort
static void amc::c_dispsig_sorted_IntInsertionSort(amc::FDispsig* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        amc::FDispsig *tmp = elems[i];
        // shift elements up by one
        if (c_dispsig_sorted_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_dispsig_sorted_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- amc.FDb.c_dispsig_sorted.IntHeapSort
// Internal heap sort
static void amc::c_dispsig_sorted_IntHeapSort(amc::FDispsig* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_dispsig_sorted_Lt(*elems[j], *elems[k])) {
            c_dispsig_sorted_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_dispsig_sorted_Lt(*elems[l], *elems[l+1]);
            if (c_dispsig_sorted_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_dispsig_sorted_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_dispsig_sorted_Swap(elems[i],elems[k]);
        }
    }
}

// --- amc.FDb.c_dispsig_sorted.IntQuickSort
// Quick sort engine
static void amc::c_dispsig_sorted_IntQuickSort(amc::FDispsig* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_dispsig_sorted_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_dispsig_sorted_Lt(*elems[pp], *elems[pi])) {
            c_dispsig_sorted_Swap(elems[pi], elems[pp]);
        }
        if (c_dispsig_sorted_Lt(*elems[pj], *elems[pp])) {
            if (c_dispsig_sorted_Lt(*elems[pj], *elems[pi])) {
                c_dispsig_sorted_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_dispsig_sorted_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_dispsig_sorted_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        amc::FDispsig *pivot = elems[pj];
        for(;;){
            while (c_dispsig_sorted_Lt(*elems[++pi], *pivot)) {
            }
            while (c_dispsig_sorted_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_dispsig_sorted_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_dispsig_sorted_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_dispsig_sorted_IntInsertionSort(elems,n);
}

// --- amc.FDb.c_dispsig_sorted.InsertionSort
// Insertion sort
void amc::c_dispsig_sorted_InsertionSort() {
    amc::FDispsig* *elems = c_dispsig_sorted_Getary().elems;
    int n = c_dispsig_sorted_N();
    c_dispsig_sorted_IntInsertionSort(elems, n);
}

// --- amc.FDb.c_dispsig_sorted.HeapSort
// Heap sort
void amc::c_dispsig_sorted_HeapSort() {
    amc::FDispsig* *elems = c_dispsig_sorted_Getary().elems;
    int n = c_dispsig_sorted_N();
    c_dispsig_sorted_IntHeapSort(elems, n);
}

// --- amc.FDb.c_dispsig_sorted.QuickSort
// Quick sort
void amc::c_dispsig_sorted_QuickSort() {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_dispsig_sorted_N() + 1)) + 3;
    amc::FDispsig* *elems = c_dispsig_sorted_Getary().elems;
    int n = c_dispsig_sorted_N();
    c_dispsig_sorted_IntQuickSort(elems, n, max_depth);
}

// --- amc.FDb.c_dispsig_sorted.SaveSsimfile
// Save table to ssimfile
bool amc::c_dispsig_sorted_SaveSsimfile(algo::strptr fname) {
    cstring text;
    ind_beg(amc::_db_c_dispsig_sorted_curs, c_dispsig_sorted, amc::_db) {
        dmmeta::Dispsig out;
        dispsig_CopyOut(c_dispsig_sorted, out);
        dmmeta::Dispsig_Print(out, text);
        text << eol;
    }ind_end;
    (void)algo::CreateDirRecurse(algo::GetDirName(fname));
    // it is a silent error if the file cannot be saved.
    return algo::SafeStringToFile(text, fname);
}

// --- amc.FDb.zs_sig_visit.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_sig_visit_Insert(amc::FCtype& row) {
    if (!zs_sig_visit_InLlistQ(row)) {
        amc::FCtype* old_tail       = _db.zs_sig_visit_tail;
        row.zs_sig_visit_next  = NULL;
        _db.zs_sig_visit_tail = &row;
        amc::FCtype **new_row_a = &old_tail->zs_sig_visit_next;
        amc::FCtype **new_row_b = &_db.zs_sig_visit_head;
        amc::FCtype **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FDb.zs_sig_visit.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_sig_visit_Remove(amc::FCtype& row) {
    if (zs_sig_visit_InLlistQ(row)) {
        amc::FCtype* old_head       = _db.zs_sig_visit_head;
        (void)old_head; // in case it's not used
        amc::FCtype* prev=NULL;
        amc::FCtype* cur     = _db.zs_sig_visit_head;
        while (cur) {  // search for element by pointer
            amc::FCtype* next = cur->zs_sig_visit_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_sig_visit_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_sig_visit_next = next;
                } else {
                    _db.zs_sig_visit_head = next;
                }
                row.zs_sig_visit_next = (amc::FCtype*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FDb.zs_sig_visit.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_sig_visit_RemoveAll() {
    amc::FCtype* row = _db.zs_sig_visit_head;
    _db.zs_sig_visit_head = NULL;
    _db.zs_sig_visit_tail = NULL;
    while (row) {
        amc::FCtype* row_next = row->zs_sig_visit_next;
        row->zs_sig_visit_next  = (amc::FCtype*)-1;
        row = row_next;
    }
}

// --- amc.FDb.zs_sig_visit.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCtype* amc::zs_sig_visit_RemoveFirst() {
    amc::FCtype *row = NULL;
    row = _db.zs_sig_visit_head;
    if (row) {
        amc::FCtype *next = row->zs_sig_visit_next;
        _db.zs_sig_visit_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_sig_visit_tail = NULL;
        }
        row->zs_sig_visit_next = (amc::FCtype*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.target.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTarget& amc::target_Alloc() {
    amc::FTarget* row = target_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.target  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.target.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTarget* amc::target_AllocMaybe() {
    amc::FTarget *row = (amc::FTarget*)target_AllocMem();
    if (row) {
        new (row) amc::FTarget; // call constructor
    }
    return row;
}

// --- amc.FDb.target.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTarget* amc::target_InsertMaybe(const dev::Target &value) {
    amc::FTarget *row = &target_Alloc(); // if out of memory, process dies. if input error, return NULL.
    target_CopyIn(*row,const_cast<dev::Target&>(value));
    bool ok = target_XrefMaybe(*row); // this may return false
    if (!ok) {
        target_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.target.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::target_AllocMem() {
    u64 new_nelems     = _db.target_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTarget*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.target_lary[bsr];
        if (!lev) {
            lev=(amc::FTarget*)amc::lpool_AllocMem(sizeof(amc::FTarget) * (u64(1)<<bsr));
            _db.target_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.target_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.target.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::target_RemoveLast() {
    u64 n = _db.target_n;
    if (n > 0) {
        n -= 1;
        target_qFind(u64(n)).~FTarget();
        _db.target_n = i32(n);
    }
}

// --- amc.FDb.target.InputMaybe
static bool amc::target_InputMaybe(dev::Target &elem) {
    bool retval = true;
    retval = target_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.target.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::target_XrefMaybe(amc::FTarget &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_target = amc::ind_ns_Find(row.target);
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", row.target);
        return false;
    }
    // target: save pointer to target
    if (true) { // user-defined insert condition
        row.p_ns = p_target;
    }
    // insert target into index ind_target
    if (true) { // user-defined insert condition
        bool success = ind_target_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_target"; // check for duplicate key
            return false;
        }
    }
    // insert target into index c_target
    if (true) { // user-defined insert condition
        bool success = c_target_InsertMaybe(*p_target, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_target"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_target.Find
// Find row by key. Return NULL if not found.
amc::FTarget* amc::ind_target_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_target_buckets_n - 1);
    amc::FTarget* *e = &_db.ind_target_buckets_elems[index];
    amc::FTarget* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).target == key;
        if (done) break;
        e         = &ret->ind_target_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_target.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTarget& amc::ind_target_GetOrCreate(const algo::strptr& key) {
    amc::FTarget* ret = ind_target_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &target_Alloc();
        (*ret).target = key;
        bool good = target_XrefMaybe(*ret);
        if (!good) {
            target_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_target  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_target.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_target_InsertMaybe(amc::FTarget& row) {
    ind_target_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_target_next == (amc::FTarget*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        amc::FTarget* *prev = &_db.ind_target_buckets_elems[index];
        do {
            amc::FTarget* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).target == row.target) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_target_next;
        } while (true);
        if (retval) {
            row.ind_target_next = *prev;
            _db.ind_target_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_target.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_target_Remove(amc::FTarget& row) {
    if (LIKELY(row.ind_target_next != (amc::FTarget*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.target) & (_db.ind_target_buckets_n - 1);
        amc::FTarget* *prev = &_db.ind_target_buckets_elems[index]; // addr of pointer to current element
        while (amc::FTarget *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_target_next; // unlink (singly linked list)
                _db.ind_target_n--;
                row.ind_target_next = (amc::FTarget*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_target_next;
        }
    }
}

// --- amc.FDb.ind_target.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_target_Reserve(int n) {
    u32 old_nbuckets = _db.ind_target_buckets_n;
    u32 new_nelems   = _db.ind_target_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FTarget*);
        u32 new_size = new_nbuckets * sizeof(amc::FTarget*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FTarget* *new_buckets = (amc::FTarget**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_target");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_target_buckets_n; i++) {
            amc::FTarget* elem = _db.ind_target_buckets_elems[i];
            while (elem) {
                amc::FTarget &row        = *elem;
                amc::FTarget* next       = row.ind_target_next;
                u32 index          = algo::Smallstr16_Hash(0, row.target) & (new_nbuckets-1);
                row.ind_target_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_target_buckets_elems, old_size);
        _db.ind_target_buckets_elems = new_buckets;
        _db.ind_target_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.targdep.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTargdep& amc::targdep_Alloc() {
    amc::FTargdep* row = targdep_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.targdep  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.targdep.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTargdep* amc::targdep_AllocMaybe() {
    amc::FTargdep *row = (amc::FTargdep*)targdep_AllocMem();
    if (row) {
        new (row) amc::FTargdep; // call constructor
    }
    return row;
}

// --- amc.FDb.targdep.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTargdep* amc::targdep_InsertMaybe(const dev::Targdep &value) {
    amc::FTargdep *row = &targdep_Alloc(); // if out of memory, process dies. if input error, return NULL.
    targdep_CopyIn(*row,const_cast<dev::Targdep&>(value));
    bool ok = targdep_XrefMaybe(*row); // this may return false
    if (!ok) {
        targdep_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.targdep.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::targdep_AllocMem() {
    u64 new_nelems     = _db.targdep_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTargdep*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.targdep_lary[bsr];
        if (!lev) {
            lev=(amc::FTargdep*)amc::lpool_AllocMem(sizeof(amc::FTargdep) * (u64(1)<<bsr));
            _db.targdep_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.targdep_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.targdep.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::targdep_RemoveLast() {
    u64 n = _db.targdep_n;
    if (n > 0) {
        n -= 1;
        targdep_qFind(u64(n)).~FTargdep();
        _db.targdep_n = i32(n);
    }
}

// --- amc.FDb.targdep.InputMaybe
static bool amc::targdep_InputMaybe(dev::Targdep &elem) {
    bool retval = true;
    retval = targdep_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.targdep.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::targdep_XrefMaybe(amc::FTargdep &row) {
    bool retval = true;
    (void)row;
    amc::FTarget* p_target = amc::ind_target_Find(target_Get(row));
    if (UNLIKELY(!p_target)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_target" << Keyval("key", target_Get(row));
        return false;
    }
    // targdep: save pointer to target
    if (true) { // user-defined insert condition
        row.p_target = p_target;
    }
    amc::FTarget* p_parent = amc::ind_target_Find(parent_Get(row));
    if (UNLIKELY(!p_parent)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_target" << Keyval("key", parent_Get(row));
        return false;
    }
    // targdep: save pointer to parent
    if (true) { // user-defined insert condition
        row.p_parent = p_parent;
    }
    // insert targdep into index c_targdep
    if (true) { // user-defined insert condition
        c_targdep_Insert(*p_target, row);
    }
    return retval;
}

// --- amc.FDb.dispctx.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispctx& amc::dispctx_Alloc() {
    amc::FDispctx* row = dispctx_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.dispctx  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.dispctx.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispctx* amc::dispctx_AllocMaybe() {
    amc::FDispctx *row = (amc::FDispctx*)dispctx_AllocMem();
    if (row) {
        new (row) amc::FDispctx; // call constructor
    }
    return row;
}

// --- amc.FDb.dispctx.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispctx* amc::dispctx_InsertMaybe(const dmmeta::Dispctx &value) {
    amc::FDispctx *row = &dispctx_Alloc(); // if out of memory, process dies. if input error, return NULL.
    dispctx_CopyIn(*row,const_cast<dmmeta::Dispctx&>(value));
    bool ok = dispctx_XrefMaybe(*row); // this may return false
    if (!ok) {
        dispctx_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.dispctx.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::dispctx_AllocMem() {
    u64 new_nelems     = _db.dispctx_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FDispctx*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.dispctx_lary[bsr];
        if (!lev) {
            lev=(amc::FDispctx*)amc::lpool_AllocMem(sizeof(amc::FDispctx) * (u64(1)<<bsr));
            _db.dispctx_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.dispctx_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.dispctx.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::dispctx_RemoveLast() {
    u64 n = _db.dispctx_n;
    if (n > 0) {
        n -= 1;
        dispctx_qFind(u64(n)).~FDispctx();
        _db.dispctx_n = i32(n);
    }
}

// --- amc.FDb.dispctx.InputMaybe
static bool amc::dispctx_InputMaybe(dmmeta::Dispctx &elem) {
    bool retval = true;
    retval = dispctx_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.dispctx.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::dispctx_XrefMaybe(amc::FDispctx &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // dispctx: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (UNLIKELY(!p_dispatch)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_dispatch" << Keyval("key", row.dispatch);
        return false;
    }
    // insert dispctx into index c_dispctx
    if (true) { // user-defined insert condition
        bool success = c_dispctx_InsertMaybe(*p_dispatch, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDispatch.c_dispctx"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.pmaskfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPmaskfld& amc::pmaskfld_Alloc() {
    amc::FPmaskfld* row = pmaskfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.pmaskfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.pmaskfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FPmaskfld* amc::pmaskfld_AllocMaybe() {
    amc::FPmaskfld *row = (amc::FPmaskfld*)pmaskfld_AllocMem();
    if (row) {
        new (row) amc::FPmaskfld; // call constructor
    }
    return row;
}

// --- amc.FDb.pmaskfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPmaskfld* amc::pmaskfld_InsertMaybe(const dmmeta::Pmaskfld &value) {
    amc::FPmaskfld *row = &pmaskfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    pmaskfld_CopyIn(*row,const_cast<dmmeta::Pmaskfld&>(value));
    bool ok = pmaskfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        pmaskfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.pmaskfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::pmaskfld_AllocMem() {
    u64 new_nelems     = _db.pmaskfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FPmaskfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.pmaskfld_lary[bsr];
        if (!lev) {
            lev=(amc::FPmaskfld*)amc::lpool_AllocMem(sizeof(amc::FPmaskfld) * (u64(1)<<bsr));
            _db.pmaskfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.pmaskfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.pmaskfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::pmaskfld_RemoveLast() {
    u64 n = _db.pmaskfld_n;
    if (n > 0) {
        n -= 1;
        pmaskfld_qFind(u64(n)).~FPmaskfld();
        _db.pmaskfld_n = i32(n);
    }
}

// --- amc.FDb.pmaskfld.InputMaybe
static bool amc::pmaskfld_InputMaybe(dmmeta::Pmaskfld &elem) {
    bool retval = true;
    retval = pmaskfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.pmaskfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::pmaskfld_XrefMaybe(amc::FPmaskfld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // pmaskfld: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert pmaskfld into index c_pmaskfld
    if (true) { // user-defined insert condition
        bool success = c_pmaskfld_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_pmaskfld"; // check for duplicate key
            return false;
        }
    }
    // insert pmaskfld into index c_pmaskfld
    if (true) { // user-defined insert condition
        bool success = c_pmaskfld_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_pmaskfld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fwddecl.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFwddecl& amc::fwddecl_Alloc() {
    amc::FFwddecl* row = fwddecl_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fwddecl  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fwddecl.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFwddecl* amc::fwddecl_AllocMaybe() {
    amc::FFwddecl *row = (amc::FFwddecl*)fwddecl_AllocMem();
    if (row) {
        new (row) amc::FFwddecl; // call constructor
    }
    return row;
}

// --- amc.FDb.fwddecl.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFwddecl* amc::fwddecl_InsertMaybe(const dmmeta::Fwddecl &value) {
    amc::FFwddecl *row = &fwddecl_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fwddecl_CopyIn(*row,const_cast<dmmeta::Fwddecl&>(value));
    bool ok = fwddecl_XrefMaybe(*row); // this may return false
    if (!ok) {
        fwddecl_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fwddecl.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fwddecl_AllocMem() {
    u64 new_nelems     = _db.fwddecl_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFwddecl*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fwddecl_lary[bsr];
        if (!lev) {
            lev=(amc::FFwddecl*)amc::lpool_AllocMem(sizeof(amc::FFwddecl) * (u64(1)<<bsr));
            _db.fwddecl_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fwddecl_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fwddecl.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fwddecl_RemoveLast() {
    u64 n = _db.fwddecl_n;
    if (n > 0) {
        n -= 1;
        fwddecl_qFind(u64(n)).~FFwddecl();
        _db.fwddecl_n = i32(n);
    }
}

// --- amc.FDb.fwddecl.InputMaybe
static bool amc::fwddecl_InputMaybe(dmmeta::Fwddecl &elem) {
    bool retval = true;
    retval = fwddecl_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fwddecl.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fwddecl_XrefMaybe(amc::FFwddecl &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert fwddecl into index c_fwddecl
    if (true) { // user-defined insert condition
        c_fwddecl_Insert(*p_ns, row);
    }
    // insert fwddecl into index ind_fwddecl
    if (true) { // user-defined insert condition
        bool success = ind_fwddecl_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fwddecl"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fwddecl.Find
// Find row by key. Return NULL if not found.
amc::FFwddecl* amc::ind_fwddecl_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr100_Hash(0, key) & (_db.ind_fwddecl_buckets_n - 1);
    amc::FFwddecl* *e = &_db.ind_fwddecl_buckets_elems[index];
    amc::FFwddecl* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fwddecl == key;
        if (done) break;
        e         = &ret->ind_fwddecl_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fwddecl.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFwddecl& amc::ind_fwddecl_GetOrCreate(const algo::strptr& key) {
    amc::FFwddecl* ret = ind_fwddecl_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fwddecl_Alloc();
        (*ret).fwddecl = key;
        bool good = fwddecl_XrefMaybe(*ret);
        if (!good) {
            fwddecl_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fwddecl  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fwddecl.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fwddecl_InsertMaybe(amc::FFwddecl& row) {
    ind_fwddecl_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fwddecl_next == (amc::FFwddecl*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fwddecl) & (_db.ind_fwddecl_buckets_n - 1);
        amc::FFwddecl* *prev = &_db.ind_fwddecl_buckets_elems[index];
        do {
            amc::FFwddecl* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fwddecl == row.fwddecl) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fwddecl_next;
        } while (true);
        if (retval) {
            row.ind_fwddecl_next = *prev;
            _db.ind_fwddecl_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fwddecl.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fwddecl_Remove(amc::FFwddecl& row) {
    if (LIKELY(row.ind_fwddecl_next != (amc::FFwddecl*)-1)) {// check if in hash already
        u32 index = algo::Smallstr100_Hash(0, row.fwddecl) & (_db.ind_fwddecl_buckets_n - 1);
        amc::FFwddecl* *prev = &_db.ind_fwddecl_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFwddecl *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fwddecl_next; // unlink (singly linked list)
                _db.ind_fwddecl_n--;
                row.ind_fwddecl_next = (amc::FFwddecl*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fwddecl_next;
        }
    }
}

// --- amc.FDb.ind_fwddecl.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fwddecl_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fwddecl_buckets_n;
    u32 new_nelems   = _db.ind_fwddecl_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFwddecl*);
        u32 new_size = new_nbuckets * sizeof(amc::FFwddecl*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFwddecl* *new_buckets = (amc::FFwddecl**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fwddecl");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fwddecl_buckets_n; i++) {
            amc::FFwddecl* elem = _db.ind_fwddecl_buckets_elems[i];
            while (elem) {
                amc::FFwddecl &row        = *elem;
                amc::FFwddecl* next       = row.ind_fwddecl_next;
                u32 index          = algo::Smallstr100_Hash(0, row.fwddecl) & (new_nbuckets-1);
                row.ind_fwddecl_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fwddecl_buckets_elems, old_size);
        _db.ind_fwddecl_buckets_elems = new_buckets;
        _db.ind_fwddecl_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.tfunc.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTfunc& amc::tfunc_Alloc() {
    amc::FTfunc* row = tfunc_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tfunc  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tfunc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTfunc* amc::tfunc_AllocMaybe() {
    amc::FTfunc *row = (amc::FTfunc*)tfunc_AllocMem();
    if (row) {
        new (row) amc::FTfunc; // call constructor
    }
    return row;
}

// --- amc.FDb.tfunc.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTfunc* amc::tfunc_InsertMaybe(const amcdb::Tfunc &value) {
    amc::FTfunc *row = &tfunc_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tfunc_CopyIn(*row,const_cast<amcdb::Tfunc&>(value));
    bool ok = tfunc_XrefMaybe(*row); // this may return false
    if (!ok) {
        tfunc_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tfunc.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::tfunc_AllocMem() {
    u64 new_nelems     = _db.tfunc_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTfunc*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tfunc_lary[bsr];
        if (!lev) {
            lev=(amc::FTfunc*)amc::lpool_AllocMem(sizeof(amc::FTfunc) * (u64(1)<<bsr));
            _db.tfunc_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tfunc_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.tfunc.RemoveAll
// Remove all elements from Lary
void amc::tfunc_RemoveAll() {
    for (u64 n = _db.tfunc_n; n>0; ) {
        n--;
        tfunc_qFind(u64(n)).~FTfunc(); // destroy last element
        _db.tfunc_n = i32(n);
    }
}

// --- amc.FDb.tfunc.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tfunc_RemoveLast() {
    u64 n = _db.tfunc_n;
    if (n > 0) {
        n -= 1;
        tfunc_qFind(u64(n)).~FTfunc();
        _db.tfunc_n = i32(n);
    }
}

// --- amc.FDb.tfunc.LoadStatic
static void amc::tfunc_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)();
    } data[] = {
        { "amcdb.tfunc  tfunc:Atree.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete all elements in the tree.\"", amc::tfunc_Atree_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Atree.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Atree_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Atree.FirstImpl  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_FirstImpl }
        ,{ "amcdb.tfunc  tfunc:Atree.First  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return pointer to the first(smallest) element in the tree\"", amc::tfunc_Atree_First }
        ,{ "amcdb.tfunc  tfunc:Atree.InTreeQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if row is in the tree, false otherwise\"", amc::tfunc_Atree_InTreeQ }
        ,{ "amcdb.tfunc  tfunc:Atree.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Atree_Init }
        ,{ "amcdb.tfunc  tfunc:Atree.InsertImpl  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Insert row into the tree. If row is already in the tree, do nothing.\"", amc::tfunc_Atree_InsertImpl }
        ,{ "amcdb.tfunc  tfunc:Atree.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Insert row into the tree. If row is already in the tree, do nothing.\"", amc::tfunc_Atree_Insert }
        ,{ "amcdb.tfunc  tfunc:Atree.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove element from index. If element is not in index, do nothing.\"", amc::tfunc_Atree_Remove }
        ,{ "amcdb.tfunc  tfunc:Atree.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Empty the index. (The rows are not deleted)\"", amc::tfunc_Atree_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Atree.RemoveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.\"", amc::tfunc_Atree_RemoveFirst }
        ,{ "amcdb.tfunc  tfunc:Atree.Balance  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_Balance }
        ,{ "amcdb.tfunc  tfunc:Atree.Propagate  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Recalculate depth and keep rebalancing if needed\"", amc::tfunc_Atree_Propagate }
        ,{ "amcdb.tfunc  tfunc:Atree.TallerChild  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Returns the child that has greater height.\"", amc::tfunc_Atree_TallerChild }
        ,{ "amcdb.tfunc  tfunc:Atree.Disconnect  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Disconnects the subtree(branch) from the parent\"", amc::tfunc_Atree_Disconnect }
        ,{ "amcdb.tfunc  tfunc:Atree.Rebalance  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Rebalances the node if needed.\"", amc::tfunc_Atree_Rebalance }
        ,{ "amcdb.tfunc  tfunc:Atree.Next  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_Next }
        ,{ "amcdb.tfunc  tfunc:Atree.Prev  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_Prev }
        ,{ "amcdb.tfunc  tfunc:Atree.LastImpl  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_LastImpl }
        ,{ "amcdb.tfunc  tfunc:Atree.Last  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return pointer to the last(largest) element in tree\"", amc::tfunc_Atree_Last }
        ,{ "amcdb.tfunc  tfunc:Atree.ElemLt  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_ElemLt }
        ,{ "amcdb.tfunc  tfunc:Atree.UpdateDepth  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_UpdateDepth }
        ,{ "amcdb.tfunc  tfunc:Atree.Turn  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"rotates the tree in from->to direction\"", amc::tfunc_Atree_Turn }
        ,{ "amcdb.tfunc  tfunc:Atree.Connect  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_Connect }
        ,{ "amcdb.tfunc  tfunc:Atree.curs  hasthrow:N  leaf:N  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Atree_curs }
        ,{ "amcdb.tfunc  tfunc:Atree.RemoveAllImpl  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Empty the index. (rows may be deleted if cascdel)\"", amc::tfunc_Atree_RemoveAllImpl }
        ,{ "amcdb.tfunc  tfunc:Atree.Reinsert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Reinsert a row with modified key(Reheap semantics)\"", amc::tfunc_Atree_Reinsert }
        ,{ "amcdb.tfunc  tfunc:Atree.FirstGe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Find the first element that is greater or equal to a sortfld value\"", amc::tfunc_Atree_FirstGe }
        ,{ "amcdb.tfunc  tfunc:Atree.LastLt  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Find the last element that is smaller or equal to a sortfld value\"", amc::tfunc_Atree_LastLt }
        ,{ "amcdb.tfunc  tfunc:Base.CopyOut  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy fields out of row\"", amc::tfunc_Base_CopyOut }
        ,{ "amcdb.tfunc  tfunc:Base.Castdown  hasthrow:N  leaf:N  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Base_Castdown }
        ,{ "amcdb.tfunc  tfunc:Base.Castbase  hasthrow:N  leaf:N  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Base_Castbase }
        ,{ "amcdb.tfunc  tfunc:Base.CopyIn  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy fields in to row\"", amc::tfunc_Base_CopyIn }
        ,{ "amcdb.tfunc  tfunc:Bheap.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Bheap.Compact  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Return unneeded memory to allocator\"", amc::tfunc_Bheap_Compact }
        ,{ "amcdb.tfunc  tfunc:Bheap.Dealloc  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Dealloc }
        ,{ "amcdb.tfunc  tfunc:Bheap.Downheap  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Downheap }
        ,{ "amcdb.tfunc  tfunc:Bheap.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Bheap.First  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"If index empty, return NULL. Otherwise return pointer to first element in index\"", amc::tfunc_Bheap_First }
        ,{ "amcdb.tfunc  tfunc:Bheap.InBheapQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if row is in index, false otherwise\"", amc::tfunc_Bheap_InBheapQ }
        ,{ "amcdb.tfunc  tfunc:Bheap.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Bheap_Init }
        ,{ "amcdb.tfunc  tfunc:Bheap.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Insert }
        ,{ "amcdb.tfunc  tfunc:Bheap.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"\"", amc::tfunc_Bheap_N }
        ,{ "amcdb.tfunc  tfunc:Bheap.Reheap  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Reheap }
        ,{ "amcdb.tfunc  tfunc:Bheap.ReheapFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_ReheapFirst }
        ,{ "amcdb.tfunc  tfunc:Bheap.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove element from index. If element is not in index, do nothing.\"", amc::tfunc_Bheap_Remove }
        ,{ "amcdb.tfunc  tfunc:Bheap.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Bheap.RemoveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_RemoveFirst }
        ,{ "amcdb.tfunc  tfunc:Bheap.Reserve  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Reserve space in index for N more elements\"", amc::tfunc_Bheap_Reserve }
        ,{ "amcdb.tfunc  tfunc:Bheap.Set  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Set }
        ,{ "amcdb.tfunc  tfunc:Bheap.SetIfBetter  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_SetIfBetter }
        ,{ "amcdb.tfunc  tfunc:Bheap.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Bheap_Uninit }
        ,{ "amcdb.tfunc  tfunc:Bheap.Upheap  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_Upheap }
        ,{ "amcdb.tfunc  tfunc:Bheap.ElemLt  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_ElemLt }
        ,{ "amcdb.tfunc  tfunc:Bheap.ElemLtval  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_ElemLtval }
        ,{ "amcdb.tfunc  tfunc:Bheap.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_curs }
        ,{ "amcdb.tfunc  tfunc:Bheap.unordcurs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bheap_unordcurs }
        ,{ "amcdb.tfunc  tfunc:Bitfld.Get  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitfld_Get }
        ,{ "amcdb.tfunc  tfunc:Bitfld.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Bitfld_Init }
        ,{ "amcdb.tfunc  tfunc:Bitfld.Set  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitfld_Set }
        ,{ "amcdb.tfunc  tfunc:Bitset.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"\"", amc::tfunc_Bitset_N }
        ,{ "amcdb.tfunc  tfunc:Bitset.qFind  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_qFind }
        ,{ "amcdb.tfunc  tfunc:Bitset.NBits  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Get max # of bits in the bitset\"", amc::tfunc_Bitset_NBits }
        ,{ "amcdb.tfunc  tfunc:Bitset.qGetBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_qGetBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.GetBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_GetBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.BitsEmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Check if all the bits in the bitset are equal to zero\"", amc::tfunc_Bitset_BitsEmptyQ }
        ,{ "amcdb.tfunc  tfunc:Bitset.Sum1s  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_Sum1s }
        ,{ "amcdb.tfunc  tfunc:Bitset.qClearBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_qClearBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.ClearBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_ClearBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.qSetBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Set bit # BIT_IDX in bit set. No bounds checking\"", amc::tfunc_Bitset_qSetBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.SetBit  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.\"", amc::tfunc_Bitset_SetBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.qSetBitVal  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Set bit # BIT_IDX in bit set. No bounds checking\"", amc::tfunc_Bitset_qSetBitVal }
        ,{ "amcdb.tfunc  tfunc:Bitset.qOrBitVal  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Or bit # BIT_IDX in bit set. No bounds checking\"", amc::tfunc_Bitset_qOrBitVal }
        ,{ "amcdb.tfunc  tfunc:Bitset.ClearBitsAll  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_ClearBitsAll }
        ,{ "amcdb.tfunc  tfunc:Bitset.ClearBits  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Zero in PARENT any bits that are set in RHS.\"", amc::tfunc_Bitset_ClearBits }
        ,{ "amcdb.tfunc  tfunc:Bitset.OrBits  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_OrBits }
        ,{ "amcdb.tfunc  tfunc:Bitset.ExpandBits  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_ExpandBits }
        ,{ "amcdb.tfunc  tfunc:Bitset.AllocBit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Bitset_AllocBit }
        ,{ "amcdb.tfunc  tfunc:Bitset.Sup  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return smallest number N such that indexes of all 1 bits are below N\"", amc::tfunc_Bitset_Sup }
        ,{ "amcdb.tfunc  tfunc:Blkpool.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Blkpool_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Blkpool.SetBufferSize  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Blkpool_SetBufferSize }
        ,{ "amcdb.tfunc  tfunc:Blkpool.ReserveBuffers  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Reserve NBUF buffers of specified size\"", amc::tfunc_Blkpool_ReserveBuffers }
        ,{ "amcdb.tfunc  tfunc:Blkpool.FreeMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Deallocate memory previously allocated from pool\"", amc::tfunc_Blkpool_FreeMem }
        ,{ "amcdb.tfunc  tfunc:Blkpool.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Blkpool_Init }
        ,{ "amcdb.tfunc  tfunc:Charset.Match  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Charset_Match }
        ,{ "amcdb.tfunc  tfunc:Cmp.Nextchar  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cmp_Nextchar }
        ,{ "amcdb.tfunc  tfunc:Cmp.Lt  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cmp_Lt }
        ,{ "amcdb.tfunc  tfunc:Cmp.Cmp  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cmp_Cmp }
        ,{ "amcdb.tfunc  tfunc:Count.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Count_Insert }
        ,{ "amcdb.tfunc  tfunc:Count.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Count_Remove }
        ,{ "amcdb.tfunc  tfunc:Count.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"\"", amc::tfunc_Count_N }
        ,{ "amcdb.tfunc  tfunc:Cppfunc.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cppfunc_Init }
        ,{ "amcdb.tfunc  tfunc:Cppfunc.Get  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cppfunc_Get }
        ,{ "amcdb.tfunc  tfunc:Cppfunc.Set  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Cppfunc_Set }
        ,{ "amcdb.tfunc  tfunc:Ctype.Hash  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Hash }
        ,{ "amcdb.tfunc  tfunc:Ctype.XrefMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_XrefMaybe }
        ,{ "amcdb.tfunc  tfunc:Ctype.Unref  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Unref }
        ,{ "amcdb.tfunc  tfunc:Ctype.ReadFieldMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_ReadFieldMaybe }
        ,{ "amcdb.tfunc  tfunc:Ctype.ReadStrptrMaybe  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Ctype.ReadTupleMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_ReadTupleMaybe }
        ,{ "amcdb.tfunc  tfunc:Ctype.Lt  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Lt }
        ,{ "amcdb.tfunc  tfunc:Ctype.GetMsgLength  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Message length (uses length field)\"", amc::tfunc_Ctype_GetMsgLength }
        ,{ "amcdb.tfunc  tfunc:Ctype.GetMsgMemptr  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Memptr encompassing the message (uses length field)\"", amc::tfunc_Ctype_GetMsgMemptr }
        ,{ "amcdb.tfunc  tfunc:Ctype.Cmp  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Cmp }
        ,{ "amcdb.tfunc  tfunc:Ctype.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Init }
        ,{ "amcdb.tfunc  tfunc:Ctype.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Uninit }
        ,{ "amcdb.tfunc  tfunc:Ctype.UpdateMax  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Attempt to make LHS bigger. Return true if it was changed\"", amc::tfunc_Ctype_UpdateMax }
        ,{ "amcdb.tfunc  tfunc:Ctype.Min  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return the lesser of two values\"", amc::tfunc_Ctype_Min }
        ,{ "amcdb.tfunc  tfunc:Ctype.UpdateMin  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Attempt to make LHS smaller. Return true if it was changed\"", amc::tfunc_Ctype_UpdateMin }
        ,{ "amcdb.tfunc  tfunc:Ctype.Max  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return the greater of two values\"", amc::tfunc_Ctype_Max }
        ,{ "amcdb.tfunc  tfunc:Ctype.Eq  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Eq }
        ,{ "amcdb.tfunc  tfunc:Ctype.Update  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Set value. Return true if new value is different from old value.\"", amc::tfunc_Ctype_Update }
        ,{ "amcdb.tfunc  tfunc:Ctype.EqStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_EqStrptr }
        ,{ "amcdb.tfunc  tfunc:Ctype.PrintArgv  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_PrintArgv }
        ,{ "amcdb.tfunc  tfunc:Ctype.ToCmdline  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_ToCmdline }
        ,{ "amcdb.tfunc  tfunc:Ctype.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_Print }
        ,{ "amcdb.tfunc  tfunc:Ctype.FmtJson  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_FmtJson }
        ,{ "amcdb.tfunc  tfunc:Ctype.EqEnum  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_EqEnum }
        ,{ "amcdb.tfunc  tfunc:Ctype.GetAnon  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ctype_GetAnon }
        ,{ "amcdb.tfunc  tfunc:Dec.qSetDouble  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_qSetDouble }
        ,{ "amcdb.tfunc  tfunc:Dec.GetDouble  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_GetDouble }
        ,{ "amcdb.tfunc  tfunc:Dec.GetInt  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_GetInt }
        ,{ "amcdb.tfunc  tfunc:Dec.GetScale  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_GetScale }
        ,{ "amcdb.tfunc  tfunc:Dec.SetDoubleMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_SetDoubleMaybe }
        ,{ "amcdb.tfunc  tfunc:Dec.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Dec.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Dec_Print }
        ,{ "amcdb.tfunc  tfunc:Delptr.Access  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Get or Create\"", amc::tfunc_Delptr_Access }
        ,{ "amcdb.tfunc  tfunc:Delptr.Delete  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Delptr_Delete }
        ,{ "amcdb.tfunc  tfunc:Delptr.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Delptr_Init }
        ,{ "amcdb.tfunc  tfunc:Delptr.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Delptr_Uninit }
        ,{ "amcdb.tfunc  tfunc:Exec.Start  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Start subprocess\"", amc::tfunc_Exec_Start }
        ,{ "amcdb.tfunc  tfunc:Exec.StartRead  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Start subprocess & Read output\"", amc::tfunc_Exec_StartRead }
        ,{ "amcdb.tfunc  tfunc:Exec.Kill  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Kill subprocess and wait\"", amc::tfunc_Exec_Kill }
        ,{ "amcdb.tfunc  tfunc:Exec.Wait  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Wait for subprocess to return\"", amc::tfunc_Exec_Wait }
        ,{ "amcdb.tfunc  tfunc:Exec.Exec  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Start + Wait\"", amc::tfunc_Exec_Exec }
        ,{ "amcdb.tfunc  tfunc:Exec.ExecX  hasthrow:Y  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Start + Wait, throw exception on error\"", amc::tfunc_Exec_ExecX }
        ,{ "amcdb.tfunc  tfunc:Exec.Execv  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Call execv()\"", amc::tfunc_Exec_Execv }
        ,{ "amcdb.tfunc  tfunc:Exec.ToCmdline  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Exec_ToCmdline }
        ,{ "amcdb.tfunc  tfunc:Exec.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Exec_Init }
        ,{ "amcdb.tfunc  tfunc:Exec.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Exec_Uninit }
        ,{ "amcdb.tfunc  tfunc:Fbuf.BeginRead  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_BeginRead }
        ,{ "amcdb.tfunc  tfunc:Fbuf.EndRead  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Set EOF flag\"", amc::tfunc_Fbuf_EndRead }
        ,{ "amcdb.tfunc  tfunc:Fbuf.EndWrite  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Send zero-byte write\"", amc::tfunc_Fbuf_EndWrite }
        ,{ "amcdb.tfunc  tfunc:Fbuf.BeginWrite  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_BeginWrite }
        ,{ "amcdb.tfunc  tfunc:Fbuf.GetMsg  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_GetMsg }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Fbuf_Init }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Max  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return max. number of bytes in the buffer.\"", amc::tfunc_Fbuf_Max }
        ,{ "amcdb.tfunc  tfunc:Fbuf.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of bytes in the buffer.\"", amc::tfunc_Fbuf_N }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Outflow  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Transfer bytes from buffer to fd using write()\"", amc::tfunc_Fbuf_Outflow }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Refill  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Refill buffer. Return false if no further refill possible (input buffer exhausted)\"", amc::tfunc_Fbuf_Refill }
        ,{ "amcdb.tfunc  tfunc:Fbuf.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Scanmsg  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_Scanmsg }
        ,{ "amcdb.tfunc  tfunc:Fbuf.Shift  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_Shift }
        ,{ "amcdb.tfunc  tfunc:Fbuf.SkipBytes  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_SkipBytes }
        ,{ "amcdb.tfunc  tfunc:Fbuf.SkipMsg  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_SkipMsg }
        ,{ "amcdb.tfunc  tfunc:Fbuf.WriteAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fbuf_WriteAll }
        ,{ "amcdb.tfunc  tfunc:Fbuf.WriteMsg  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Write message to buffer. If the entire message is written, return true, otherwise false.\"", amc::tfunc_Fbuf_WriteMsg }
        ,{ "amcdb.tfunc  tfunc:Fcast.Cast  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fcast_Cast }
        ,{ "amcdb.tfunc  tfunc:Fconst.GetEnum  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_GetEnum }
        ,{ "amcdb.tfunc  tfunc:Fconst.SetEnum  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_SetEnum }
        ,{ "amcdb.tfunc  tfunc:Fconst.ToCstr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_ToCstr }
        ,{ "amcdb.tfunc  tfunc:Fconst.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_Print }
        ,{ "amcdb.tfunc  tfunc:Fconst.SetStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_SetStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Fconst.SetStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_SetStrptr }
        ,{ "amcdb.tfunc  tfunc:Fconst.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Fconst_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Field.Cleanup  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Field_Cleanup }
        ,{ "amcdb.tfunc  tfunc:Field.Userinit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Field_Userinit }
        ,{ "amcdb.tfunc  tfunc:Field.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Field_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Field.Concat  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Generate Concat functin if the field is a sourcefield\"", amc::tfunc_Field_Concat }
        ,{ "amcdb.tfunc  tfunc:Field2.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Field2_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Global.ReadArgv  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Global_ReadArgv }
        ,{ "amcdb.tfunc  tfunc:Global.MainArgs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Main function\"", amc::tfunc_Global_MainArgs }
        ,{ "amcdb.tfunc  tfunc:Global.main  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Global_main }
        ,{ "amcdb.tfunc  tfunc:Global.WinMain  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"WinMain for Win GUI executables\"", amc::tfunc_Global_WinMain }
        ,{ "amcdb.tfunc  tfunc:Global.MainLoop  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Main loop.\"", amc::tfunc_Global_MainLoop }
        ,{ "amcdb.tfunc  tfunc:Global.Step  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Main step\"", amc::tfunc_Global_Step }
        ,{ "amcdb.tfunc  tfunc:Global.Main  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Main function\"", amc::tfunc_Global_Main }
        ,{ "amcdb.tfunc  tfunc:Global.InitReflection  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Load statically available data into tables, register tables and database.\"", amc::tfunc_Global_InitReflection }
        ,{ "amcdb.tfunc  tfunc:Global.StaticCheck  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Global_StaticCheck }
        ,{ "amcdb.tfunc  tfunc:Global.InsertStrptrMaybe  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Global_InsertStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Global.LoadTuplesMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Load all finputs from given directory.\"", amc::tfunc_Global_LoadTuplesMaybe }
        ,{ "amcdb.tfunc  tfunc:Global.SaveTuples  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Save ssim data to given directory.\"", amc::tfunc_Global_SaveTuples }
        ,{ "amcdb.tfunc  tfunc:Global.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Global_Init }
        ,{ "amcdb.tfunc  tfunc:Global.LoadSsimfileMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Load specified ssimfile.\"", amc::tfunc_Global_LoadSsimfileMaybe }
        ,{ "amcdb.tfunc  tfunc:Global.Steps  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Calls Step function of dependencies\"", amc::tfunc_Global_Steps }
        ,{ "amcdb.tfunc  tfunc:Hook.Call  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Invoke function by pointer\"", amc::tfunc_Hook_Call }
        ,{ "amcdb.tfunc  tfunc:Hook.Set0  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Assign 0-argument hook with no context pointer\"", amc::tfunc_Hook_Set0 }
        ,{ "amcdb.tfunc  tfunc:Hook.Set1  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Assign 1-argument hook with context pointer\"", amc::tfunc_Hook_Set1 }
        ,{ "amcdb.tfunc  tfunc:Hook.Set2  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Assign 2-argument hook with context pointer\"", amc::tfunc_Hook_Set2 }
        ,{ "amcdb.tfunc  tfunc:Inlary.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate space for one element. If no memory available, return NULL.\"", amc::tfunc_Inlary_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Inlary.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Inlary_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Inlary.Fill  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Set all elements of fixed array to value RHS\"", amc::tfunc_Inlary_Fill }
        ,{ "amcdb.tfunc  tfunc:Inlary.Find  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Look up row by row id. Return NULL if out of range\"", amc::tfunc_Inlary_Find }
        ,{ "amcdb.tfunc  tfunc:Inlary.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_Getary }
        ,{ "amcdb.tfunc  tfunc:Inlary.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Inlary_Init }
        ,{ "amcdb.tfunc  tfunc:Inlary.Max  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_Max }
        ,{ "amcdb.tfunc  tfunc:Inlary.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the array\"", amc::tfunc_Inlary_N }
        ,{ "amcdb.tfunc  tfunc:Inlary.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Destroy all elements of Inlary\"", amc::tfunc_Inlary_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Inlary.RemoveLast  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete last element of array. Do nothing if array is empty.\"", amc::tfunc_Inlary_RemoveLast }
        ,{ "amcdb.tfunc  tfunc:Inlary.RowidFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"find row by row id\"", amc::tfunc_Inlary_RowidFind }
        ,{ "amcdb.tfunc  tfunc:Inlary.Setary  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Set contents of fixed array to RHS; Input length is trimmed as necessary\"", amc::tfunc_Inlary_Setary }
        ,{ "amcdb.tfunc  tfunc:Inlary.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Inlary_Uninit }
        ,{ "amcdb.tfunc  tfunc:Inlary.qFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"'quick' Access row by row id. No bounds checking in release.\"", amc::tfunc_Inlary_qFind }
        ,{ "amcdb.tfunc  tfunc:Inlary.rowid_Get  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Compute row id of element given element's address\"", amc::tfunc_Inlary_rowid_Get }
        ,{ "amcdb.tfunc  tfunc:Inlary.Eq  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_Eq }
        ,{ "amcdb.tfunc  tfunc:Inlary.Cmp  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_Cmp }
        ,{ "amcdb.tfunc  tfunc:Inlary.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_curs }
        ,{ "amcdb.tfunc  tfunc:Inlary.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Inlary_Print }
        ,{ "amcdb.tfunc  tfunc:Inlary.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Read array from string\"", amc::tfunc_Inlary_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Io.SaveSsimfile  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Io_SaveSsimfile }
        ,{ "amcdb.tfunc  tfunc:Io.Input  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Io_Input }
        ,{ "amcdb.tfunc  tfunc:Io.InputMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Io_InputMaybe }
        ,{ "amcdb.tfunc  tfunc:Io.LoadStatic  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Io_LoadStatic }
        ,{ "amcdb.tfunc  tfunc:Lary.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate space for one element. If no memory available, return NULL.\"", amc::tfunc_Lary_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Lary.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Lary_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Lary.Find  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Look up row by row id. Return NULL if out of range\"", amc::tfunc_Lary_Find }
        ,{ "amcdb.tfunc  tfunc:Lary.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Lary_Init }
        ,{ "amcdb.tfunc  tfunc:Lary.Last  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:Y  ismacro:N  comment:\"Return pointer to last element of array, or NULL if array is empty\"", amc::tfunc_Lary_Last }
        ,{ "amcdb.tfunc  tfunc:Lary.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the pool\"", amc::tfunc_Lary_N }
        ,{ "amcdb.tfunc  tfunc:Lary.RemoveAll  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove all elements from Lary\"", amc::tfunc_Lary_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Lary.RemoveLast  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete last element of array. Do nothing if array is empty.\"", amc::tfunc_Lary_RemoveLast }
        ,{ "amcdb.tfunc  tfunc:Lary.RowidFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"find row by row id\"", amc::tfunc_Lary_RowidFind }
        ,{ "amcdb.tfunc  tfunc:Lary.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Lary_Uninit }
        ,{ "amcdb.tfunc  tfunc:Lary.qFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"'quick' Access row by row id. No bounds checking.\"", amc::tfunc_Lary_qFind }
        ,{ "amcdb.tfunc  tfunc:Lary.qLast  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return reference to last element of array. No bounds checking\"", amc::tfunc_Lary_qLast }
        ,{ "amcdb.tfunc  tfunc:Lary.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Lary_curs }
        ,{ "amcdb.tfunc  tfunc:Llist.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete all elements in the linked list.\"", amc::tfunc_Llist_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Llist.DestructiveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"If index empty, return NULL. Otherwise return pointer to first element in index\"", amc::tfunc_Llist_DestructiveFirst }
        ,{ "amcdb.tfunc  tfunc:Llist.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Llist_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Llist.First  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"If index empty, return NULL. Otherwise return pointer to first element in index\"", amc::tfunc_Llist_First }
        ,{ "amcdb.tfunc  tfunc:Llist.InLlistQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if row is in the linked list, false otherwise\"", amc::tfunc_Llist_InLlistQ }
        ,{ "amcdb.tfunc  tfunc:Llist.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Llist_Init }
        ,{ "amcdb.tfunc  tfunc:Llist.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Insert row into linked list. If row is already in linked list, do nothing.\"", amc::tfunc_Llist_Insert }
        ,{ "amcdb.tfunc  tfunc:Llist.Last  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"If index empty, return NULL. Otherwise return pointer to last element in index\"", amc::tfunc_Llist_Last }
        ,{ "amcdb.tfunc  tfunc:Llist.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the linked list\"", amc::tfunc_Llist_N }
        ,{ "amcdb.tfunc  tfunc:Llist.Next  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return pointer to next element in the list\"", amc::tfunc_Llist_Next }
        ,{ "amcdb.tfunc  tfunc:Llist.Prev  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return pointer to previous element in the list\"", amc::tfunc_Llist_Prev }
        ,{ "amcdb.tfunc  tfunc:Llist.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove element from index. If element is not in index, do nothing.\"", amc::tfunc_Llist_Remove }
        ,{ "amcdb.tfunc  tfunc:Llist.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Empty the index. (The rows are not deleted)\"", amc::tfunc_Llist_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Llist.RemoveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.\"", amc::tfunc_Llist_RemoveFirst }
        ,{ "amcdb.tfunc  tfunc:Llist.RotateFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"If linked list is empty, return NULL.\\nOtherwise return head item and advance head to the next item.\"", amc::tfunc_Llist_RotateFirst }
        ,{ "amcdb.tfunc  tfunc:Llist.qLast  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return reference to last element in the index. No bounds checking.\"", amc::tfunc_Llist_qLast }
        ,{ "amcdb.tfunc  tfunc:Llist.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Llist_curs }
        ,{ "amcdb.tfunc  tfunc:Llist.delcurs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Llist_delcurs }
        ,{ "amcdb.tfunc  tfunc:Lpool.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Lpool_Init }
        ,{ "amcdb.tfunc  tfunc:Lpool.FreeMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Free block of memory previously returned by Lpool.\"", amc::tfunc_Lpool_FreeMem }
        ,{ "amcdb.tfunc  tfunc:Lpool.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Lpool_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Lpool.ReserveBuffers  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Add N buffers of some size to the free store\"", amc::tfunc_Lpool_ReserveBuffers }
        ,{ "amcdb.tfunc  tfunc:Lpool.ReallocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Lpool_ReallocMem }
        ,{ "amcdb.tfunc  tfunc:Lpool.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the pool\"", amc::tfunc_Lpool_N }
        ,{ "amcdb.tfunc  tfunc:Malloc.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Malloc_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Malloc.FreeMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Malloc_FreeMem }
        ,{ "amcdb.tfunc  tfunc:Malloc.ReallocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Malloc_ReallocMem }
        ,{ "amcdb.tfunc  tfunc:Numstr.qGetnum  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Numstr_qGetnum }
        ,{ "amcdb.tfunc  tfunc:Numstr.GetnumDflt  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Numstr_GetnumDflt }
        ,{ "amcdb.tfunc  tfunc:Numstr.Geti64  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Numstr_Geti64 }
        ,{ "amcdb.tfunc  tfunc:Numstr.SetnumMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Numstr_SetnumMaybe }
        ,{ "amcdb.tfunc  tfunc:Numstr.ForAllStrings  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Numstr_ForAllStrings }
        ,{ "amcdb.tfunc  tfunc:Opt.Get  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Opt_Get }
        ,{ "amcdb.tfunc  tfunc:Opt.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Access optional portion as an array of bytes\"", amc::tfunc_Opt_Getary }
        ,{ "amcdb.tfunc  tfunc:Opt.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Opt_Print }
        ,{ "amcdb.tfunc  tfunc:Opt.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Opt_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Pmask.PresentQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pmask_PresentQ }
        ,{ "amcdb.tfunc  tfunc:Pmask.SetPresent  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pmask_SetPresent }
        ,{ "amcdb.tfunc  tfunc:Pool.Alloc  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pool_Alloc }
        ,{ "amcdb.tfunc  tfunc:Pool.AllocMaybe  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate memory for new element. If out of memory, return NULL.\"", amc::tfunc_Pool_AllocMaybe }
        ,{ "amcdb.tfunc  tfunc:Pool.AllocExtra  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pool_AllocExtra }
        ,{ "amcdb.tfunc  tfunc:Pool.AllocExtraMaybe  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate memory for new element. If out of memory, return NULL.\"", amc::tfunc_Pool_AllocExtraMaybe }
        ,{ "amcdb.tfunc  tfunc:Pool.AllocVarlenMaybe  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate element & copy memory from input parameter. If out of memory, return NULL.\"", amc::tfunc_Pool_AllocVarlenMaybe }
        ,{ "amcdb.tfunc  tfunc:Pool.AllocVarlen  hasthrow:N  leaf:N  poolfunc:Y  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Allocate element & copy memory from input parameter. If out of memory, terminate process.\"", amc::tfunc_Pool_AllocVarlen }
        ,{ "amcdb.tfunc  tfunc:Pool.InsertMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pool_InsertMaybe }
        ,{ "amcdb.tfunc  tfunc:Pool.UpdateMaybe  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Insert new value or update existing value\"", amc::tfunc_Pool_UpdateMaybe }
        ,{ "amcdb.tfunc  tfunc:Pool.Delete  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Pool_Delete }
        ,{ "amcdb.tfunc  tfunc:Protocol.StaticCheck  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Protocol_StaticCheck }
        ,{ "amcdb.tfunc  tfunc:Ptr.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptr_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Ptr.InsertMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptr_InsertMaybe }
        ,{ "amcdb.tfunc  tfunc:Ptr.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Ptr_Print }
        ,{ "amcdb.tfunc  tfunc:Ptr.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Remove element from index. If element is not in index, do nothing.\"", amc::tfunc_Ptr_Remove }
        ,{ "amcdb.tfunc  tfunc:Ptr.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Ptr_Init }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete all elements pointed to by the index.\"", amc::tfunc_Ptrary_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Ptrary.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Ptrary_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Find  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Look up row by row id. Return NULL if out of range\"", amc::tfunc_Ptrary_Find }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return array of pointers\"", amc::tfunc_Ptrary_Getary }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Ptrary_Init }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptrary_Insert }
        ,{ "amcdb.tfunc  tfunc:Ptrary.InsertMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptrary_InsertMaybe }
        ,{ "amcdb.tfunc  tfunc:Ptrary.ScanInsertMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptrary_ScanInsertMaybe }
        ,{ "amcdb.tfunc  tfunc:Ptrary.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the pointer array\"", amc::tfunc_Ptrary_N }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Find element using linear scan. If element is in array, remove, otherwise do nothing\"", amc::tfunc_Ptrary_Remove }
        ,{ "amcdb.tfunc  tfunc:Ptrary.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Empty the index. (The rows are not deleted)\"", amc::tfunc_Ptrary_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Reserve  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Reserve space in index for N more elements;\"", amc::tfunc_Ptrary_Reserve }
        ,{ "amcdb.tfunc  tfunc:Ptrary.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Ptrary_Uninit }
        ,{ "amcdb.tfunc  tfunc:Ptrary.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptrary_curs }
        ,{ "amcdb.tfunc  tfunc:Ptrary.oncecurs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Ptrary_oncecurs }
        ,{ "amcdb.tfunc  tfunc:RegxSql.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_RegxSql_Init }
        ,{ "amcdb.tfunc  tfunc:RegxSql.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Print back to string\"", amc::tfunc_RegxSql_Print }
        ,{ "amcdb.tfunc  tfunc:RegxSql.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Read Regx from string\"", amc::tfunc_RegxSql_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Sbrk.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sbrk_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Sbrk.FreeMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sbrk_FreeMem }
        ,{ "amcdb.tfunc  tfunc:Sbrk.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Sbrk_Init }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Add  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_Add }
        ,{ "amcdb.tfunc  tfunc:Smallstr.AddStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_AddStrptr }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_Getary }
        ,{ "amcdb.tfunc  tfunc:Smallstr.HashStrptr  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_HashStrptr }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_Init }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Max  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_Max }
        ,{ "amcdb.tfunc  tfunc:Smallstr.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_N }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Print  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_Print }
        ,{ "amcdb.tfunc  tfunc:Smallstr.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Smallstr_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Smallstr.SetStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy from strptr, clipping length\"", amc::tfunc_Smallstr_SetStrptr }
        ,{ "amcdb.tfunc  tfunc:Smallstr.AssignStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy from strptr (operator=)\"", amc::tfunc_Smallstr_AssignStrptr }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Set  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy from same type\"", amc::tfunc_Smallstr_Set }
        ,{ "amcdb.tfunc  tfunc:Smallstr.Ctor  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Construct from same type\"", amc::tfunc_Smallstr_Ctor }
        ,{ "amcdb.tfunc  tfunc:Smallstr.CtorStrptr  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Construct from stptr\"", amc::tfunc_Smallstr_CtorStrptr }
        ,{ "amcdb.tfunc  tfunc:Sort.Swap  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_Swap }
        ,{ "amcdb.tfunc  tfunc:Sort.Rotleft  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_Rotleft }
        ,{ "amcdb.tfunc  tfunc:Sort.Lt  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_Lt }
        ,{ "amcdb.tfunc  tfunc:Sort.SortedQ  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_SortedQ }
        ,{ "amcdb.tfunc  tfunc:Sort.IntInsertionSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_IntInsertionSort }
        ,{ "amcdb.tfunc  tfunc:Sort.IntHeapSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_IntHeapSort }
        ,{ "amcdb.tfunc  tfunc:Sort.IntQuickSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_IntQuickSort }
        ,{ "amcdb.tfunc  tfunc:Sort.InsertionSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_InsertionSort }
        ,{ "amcdb.tfunc  tfunc:Sort.HeapSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_HeapSort }
        ,{ "amcdb.tfunc  tfunc:Sort.QuickSort  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Sort_QuickSort }
        ,{ "amcdb.tfunc  tfunc:Step.FirstChanged  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Step_FirstChanged }
        ,{ "amcdb.tfunc  tfunc:Step.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Step_Init }
        ,{ "amcdb.tfunc  tfunc:Step.UpdateCycles  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Step_UpdateCycles }
        ,{ "amcdb.tfunc  tfunc:Step.Step  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Step_Step }
        ,{ "amcdb.tfunc  tfunc:Step.Call  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Step_Call }
        ,{ "amcdb.tfunc  tfunc:Step.SetDelay  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Step_SetDelay }
        ,{ "amcdb.tfunc  tfunc:Substr.Get  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Substr_Get }
        ,{ "amcdb.tfunc  tfunc:Substr.Get2  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Substr_Get2 }
        ,{ "amcdb.tfunc  tfunc:Tary.Eq  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_Eq }
        ,{ "amcdb.tfunc  tfunc:Tary.Cmp  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_Cmp }
        ,{ "amcdb.tfunc  tfunc:Tary.Addary  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_Addary }
        ,{ "amcdb.tfunc  tfunc:Tary.Alloc  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_Alloc }
        ,{ "amcdb.tfunc  tfunc:Tary.AllocAt  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_AllocAt }
        ,{ "amcdb.tfunc  tfunc:Tary.AllocN  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Reserve space. Insert N elements at the end of the array, return pointer to array\"", amc::tfunc_Tary_AllocN }
        ,{ "amcdb.tfunc  tfunc:Tary.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return true if index is empty\"", amc::tfunc_Tary_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Tary.Find  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Look up row by row id. Return NULL if out of range\"", amc::tfunc_Tary_Find }
        ,{ "amcdb.tfunc  tfunc:Tary.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return array pointer by value\"", amc::tfunc_Tary_Getary }
        ,{ "amcdb.tfunc  tfunc:Tary.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Tary_Init }
        ,{ "amcdb.tfunc  tfunc:Tary.Last  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:Y  ismacro:N  comment:\"Return pointer to last element of array, or NULL if array is empty\"", amc::tfunc_Tary_Last }
        ,{ "amcdb.tfunc  tfunc:Tary.Max  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return max. number of items in the array\"", amc::tfunc_Tary_Max }
        ,{ "amcdb.tfunc  tfunc:Tary.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the array\"", amc::tfunc_Tary_N }
        ,{ "amcdb.tfunc  tfunc:Tary.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove item by index. If index outside of range, do nothing.\"", amc::tfunc_Tary_Remove }
        ,{ "amcdb.tfunc  tfunc:Tary.RemoveAll  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_RemoveAll }
        ,{ "amcdb.tfunc  tfunc:Tary.RemoveLast  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete last element of array. Do nothing if array is empty.\"", amc::tfunc_Tary_RemoveLast }
        ,{ "amcdb.tfunc  tfunc:Tary.Reserve  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Make sure N *more* elements will fit in array. Process dies if out of memory\"", amc::tfunc_Tary_Reserve }
        ,{ "amcdb.tfunc  tfunc:Tary.AbsReserve  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Make sure N elements fit in array. Process dies if out of memory\"", amc::tfunc_Tary_AbsReserve }
        ,{ "amcdb.tfunc  tfunc:Tary.RowidFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"find row by row id\"", amc::tfunc_Tary_RowidFind }
        ,{ "amcdb.tfunc  tfunc:Tary.Setary  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Copy contents of RHS to PARENT.\"", amc::tfunc_Tary_Setary }
        ,{ "amcdb.tfunc  tfunc:Tary.Setary2  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_Setary2 }
        ,{ "amcdb.tfunc  tfunc:Tary.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Tary_Uninit }
        ,{ "amcdb.tfunc  tfunc:Tary.qFind  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"'quick' Access row by row id. No bounds checking.\"", amc::tfunc_Tary_qFind }
        ,{ "amcdb.tfunc  tfunc:Tary.qLast  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return reference to last element of array. No bounds checking\"", amc::tfunc_Tary_qLast }
        ,{ "amcdb.tfunc  tfunc:Tary.rowid_Get  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return row id of specified element\"", amc::tfunc_Tary_rowid_Get }
        ,{ "amcdb.tfunc  tfunc:Tary.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tary_curs }
        ,{ "amcdb.tfunc  tfunc:Tary.AllocNVal  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Reserve space. Insert N elements at the end of the array, return pointer to array\"", amc::tfunc_Tary_AllocNVal }
        ,{ "amcdb.tfunc  tfunc:Thash.Cascdel  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Delete all rows reachable through the hash index\"", amc::tfunc_Thash_Cascdel }
        ,{ "amcdb.tfunc  tfunc:Thash.EmptyQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:N  pure:N  ismacro:N  comment:\"Return true if hash is empty\"", amc::tfunc_Thash_EmptyQ }
        ,{ "amcdb.tfunc  tfunc:Thash.Find  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"Find row by key. Return NULL if not found.\"", amc::tfunc_Thash_Find }
        ,{ "amcdb.tfunc  tfunc:Thash.FindX  hasthrow:Y  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Look up row by key and return reference. Throw exception if not found\"", amc::tfunc_Thash_FindX }
        ,{ "amcdb.tfunc  tfunc:Thash.GetOrCreate  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Find row by key. If not found, create and x-reference a new row with with this key.\"", amc::tfunc_Thash_GetOrCreate }
        ,{ "amcdb.tfunc  tfunc:Thash.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Thash_Init }
        ,{ "amcdb.tfunc  tfunc:Thash.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of items in the hash\"", amc::tfunc_Thash_N }
        ,{ "amcdb.tfunc  tfunc:Thash.InsertMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Thash_InsertMaybe }
        ,{ "amcdb.tfunc  tfunc:Thash.Remove  hasthrow:N  leaf:Y  poolfunc:Y  inl:N  wur:N  pure:N  ismacro:N  comment:\"Remove reference to element from hash index. If element is not in hash, do nothing\"", amc::tfunc_Thash_Remove }
        ,{ "amcdb.tfunc  tfunc:Thash.Reserve  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Reserve enough room in the hash for N more elements. Return success code.\"", amc::tfunc_Thash_Reserve }
        ,{ "amcdb.tfunc  tfunc:Thash.FindRemove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Thash_FindRemove }
        ,{ "amcdb.tfunc  tfunc:Thash.Uninit  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Thash_Uninit }
        ,{ "amcdb.tfunc  tfunc:Thash.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Thash_curs }
        ,{ "amcdb.tfunc  tfunc:Tpool.AllocMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tpool_AllocMem }
        ,{ "amcdb.tfunc  tfunc:Tpool.FreeMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tpool_FreeMem }
        ,{ "amcdb.tfunc  tfunc:Tpool.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Tpool_Init }
        ,{ "amcdb.tfunc  tfunc:Tpool.Reserve  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tpool_Reserve }
        ,{ "amcdb.tfunc  tfunc:Tpool.ReserveMem  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Tpool_ReserveMem }
        ,{ "amcdb.tfunc  tfunc:Upptr.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Upptr_Init }
        ,{ "amcdb.tfunc  tfunc:Val.Get  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Val_Get }
        ,{ "amcdb.tfunc  tfunc:Val.Set  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Val_Set }
        ,{ "amcdb.tfunc  tfunc:Val.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_Val_Init }
        ,{ "amcdb.tfunc  tfunc:Val.RowidFind  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Val_RowidFind }
        ,{ "amcdb.tfunc  tfunc:Val.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"\"", amc::tfunc_Val_N }
        ,{ "amcdb.tfunc  tfunc:Varlen.Getary  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Access var-length portion as an aryptr. Length is determined from one of the fields.\"", amc::tfunc_Varlen_Getary }
        ,{ "amcdb.tfunc  tfunc:Varlen.Addr  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Varlen_Addr }
        ,{ "amcdb.tfunc  tfunc:Varlen.N  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:Y  ismacro:N  comment:\"Return number of elements in varlen field\"", amc::tfunc_Varlen_N }
        ,{ "amcdb.tfunc  tfunc:Varlen.ReadStrptrMaybe  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Varlen_ReadStrptrMaybe }
        ,{ "amcdb.tfunc  tfunc:Varlen.curs  hasthrow:N  leaf:N  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_Varlen_curs }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.DestructiveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_ZSListMT_DestructiveFirst }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.InLlistQ  hasthrow:N  leaf:Y  poolfunc:N  inl:Y  wur:Y  pure:N  ismacro:N  comment:\"Return true if row is in index, false otherwise. Row must be non-NULL.\"", amc::tfunc_ZSListMT_InLlistQ }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.Init  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:Y  comment:\"\"", amc::tfunc_ZSListMT_Init }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.Insert  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"Insert row. Row must not already be in index. If row is already in index, the behavior is undefined.\"", amc::tfunc_ZSListMT_Insert }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.Remove  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"\"", amc::tfunc_ZSListMT_Remove }
        ,{ "amcdb.tfunc  tfunc:ZSListMT.RemoveFirst  hasthrow:N  leaf:Y  poolfunc:N  inl:N  wur:N  pure:N  ismacro:N  comment:\"If index is empty, return NULL. Otherwise remove and return first key in index.\"", amc::tfunc_ZSListMT_RemoveFirst }
        ,{NULL, NULL}
    };
    (void)data;
    amcdb::Tfunc tfunc;
    for (int i=0; data[i].s; i++) {
        (void)amcdb::Tfunc_ReadStrptrMaybe(tfunc, algo::strptr(data[i].s));
        amc::FTfunc *elem = tfunc_InsertMaybe(tfunc);
        vrfy(elem, tempstr("amc.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- amc.FDb.tfunc.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tfunc_XrefMaybe(amc::FTfunc &row) {
    bool retval = true;
    (void)row;
    // insert tfunc into index ind_tfunc
    if (true) { // user-defined insert condition
        bool success = ind_tfunc_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_tfunc"; // check for duplicate key
            return false;
        }
    }
    amc::FTclass* p_tclass = amc::ind_tclass_Find(tclass_Get(row));
    if (UNLIKELY(!p_tclass)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_tclass" << Keyval("key", tclass_Get(row));
        return false;
    }
    // insert tfunc into index c_tfunc
    if (true) { // user-defined insert condition
        c_tfunc_Insert(*p_tclass, row);
    }
    return retval;
}

// --- amc.FDb.ind_tfunc.Find
// Find row by key. Return NULL if not found.
amc::FTfunc* amc::ind_tfunc_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_tfunc_buckets_n - 1);
    amc::FTfunc* *e = &_db.ind_tfunc_buckets_elems[index];
    amc::FTfunc* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).tfunc == key;
        if (done) break;
        e         = &ret->ind_tfunc_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_tfunc.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTfunc& amc::ind_tfunc_GetOrCreate(const algo::strptr& key) {
    amc::FTfunc* ret = ind_tfunc_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &tfunc_Alloc();
        (*ret).tfunc = key;
        bool good = tfunc_XrefMaybe(*ret);
        if (!good) {
            tfunc_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_tfunc  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_tfunc.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_tfunc_InsertMaybe(amc::FTfunc& row) {
    ind_tfunc_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_tfunc_next == (amc::FTfunc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.tfunc) & (_db.ind_tfunc_buckets_n - 1);
        amc::FTfunc* *prev = &_db.ind_tfunc_buckets_elems[index];
        do {
            amc::FTfunc* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).tfunc == row.tfunc) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_tfunc_next;
        } while (true);
        if (retval) {
            row.ind_tfunc_next = *prev;
            _db.ind_tfunc_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_tfunc.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_tfunc_Remove(amc::FTfunc& row) {
    if (LIKELY(row.ind_tfunc_next != (amc::FTfunc*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.tfunc) & (_db.ind_tfunc_buckets_n - 1);
        amc::FTfunc* *prev = &_db.ind_tfunc_buckets_elems[index]; // addr of pointer to current element
        while (amc::FTfunc *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_tfunc_next; // unlink (singly linked list)
                _db.ind_tfunc_n--;
                row.ind_tfunc_next = (amc::FTfunc*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_tfunc_next;
        }
    }
}

// --- amc.FDb.ind_tfunc.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_tfunc_Reserve(int n) {
    u32 old_nbuckets = _db.ind_tfunc_buckets_n;
    u32 new_nelems   = _db.ind_tfunc_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FTfunc*);
        u32 new_size = new_nbuckets * sizeof(amc::FTfunc*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FTfunc* *new_buckets = (amc::FTfunc**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_tfunc");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_tfunc_buckets_n; i++) {
            amc::FTfunc* elem = _db.ind_tfunc_buckets_elems[i];
            while (elem) {
                amc::FTfunc &row        = *elem;
                amc::FTfunc* next       = row.ind_tfunc_next;
                u32 index          = algo::Smallstr50_Hash(0, row.tfunc) & (new_nbuckets-1);
                row.ind_tfunc_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_tfunc_buckets_elems, old_size);
        _db.ind_tfunc_buckets_elems = new_buckets;
        _db.ind_tfunc_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.gen.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGen& amc::gen_Alloc() {
    amc::FGen* row = gen_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.gen  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.gen.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FGen* amc::gen_AllocMaybe() {
    amc::FGen *row = (amc::FGen*)gen_AllocMem();
    if (row) {
        new (row) amc::FGen; // call constructor
    }
    return row;
}

// --- amc.FDb.gen.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGen* amc::gen_InsertMaybe(const amcdb::Gen &value) {
    amc::FGen *row = &gen_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gen_CopyIn(*row,const_cast<amcdb::Gen&>(value));
    bool ok = gen_XrefMaybe(*row); // this may return false
    if (!ok) {
        gen_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.gen.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::gen_AllocMem() {
    u64 new_nelems     = _db.gen_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FGen*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gen_lary[bsr];
        if (!lev) {
            lev=(amc::FGen*)amc::lpool_AllocMem(sizeof(amc::FGen) * (u64(1)<<bsr));
            _db.gen_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gen_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.gen.RemoveAll
// Remove all elements from Lary
void amc::gen_RemoveAll() {
    for (u64 n = _db.gen_n; n>0; ) {
        n--;
        gen_qFind(u64(n)).~FGen(); // destroy last element
        _db.gen_n = i32(n);
    }
}

// --- amc.FDb.gen.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::gen_RemoveLast() {
    u64 n = _db.gen_n;
    if (n > 0) {
        n -= 1;
        gen_qFind(u64(n)).~FGen();
        _db.gen_n = i32(n);
    }
}

// --- amc.FDb.gen.LoadStatic
static void amc::gen_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)();
    } data[] = {
        { "amcdb.gen  gen:prep_signature  perns:N  comment:\"Prepare signatures\"", amc::gen_prep_signature }
        ,{ "amcdb.gen  gen:select_ns  perns:N  comment:\"Select namespaces for processing\"", amc::gen_select_ns }
        ,{ "amcdb.gen  gen:dispenum  perns:N  comment:\"generate enum for each dispatch (creates new ctypes)\"", amc::gen_dispenum }
        ,{ "amcdb.gen  gen:countxref  perns:N  comment:\"\"", amc::gen_countxref }
        ,{ "amcdb.gen  gen:detectinst  perns:N  comment:\"Detect creation access paths\"", amc::gen_detectinst }
        ,{ "amcdb.gen  gen:trace  perns:N  comment:\"Generate trace counters (creates new ctypes)\"", amc::gen_trace }
        ,{ "amcdb.gen  gen:lookuppkey  perns:N  comment:\"Rewrite Pkey->Val\"", amc::gen_lookuppkey }
        ,{ "amcdb.gen  gen:tableenum  perns:N  comment:\"Create enum for tables\"", amc::gen_tableenum }
        ,{ "amcdb.gen  gen:gconst  perns:N  comment:\"Generate fconsts from tables\"", amc::gen_gconst }
        ,{ "amcdb.gen  gen:bitfldenum  perns:N  comment:\"Generate fconsts from bool bitfield\"", amc::gen_bitfldenum }
        ,{ "amcdb.gen  gen:proc  perns:N  comment:\"Create command::xyz_proc for every executable\"", amc::gen_proc }
        ,{ "amcdb.gen  gen:msgcurs  perns:N  comment:\"Generate message cursors\"", amc::gen_msgcurs }
        ,{ "amcdb.gen  gen:check_basefield  perns:N  comment:\"Check Base usage\"", amc::gen_check_basefield }
        ,{ "amcdb.gen  gen:clonefconst  perns:N  comment:\"Generate numeric fconsts for all string-based fconsts (creates new ctype)\"", amc::gen_clonefconst }
        ,{ "amcdb.gen  gen:parsenum  perns:N  comment:\"Generate functions to parse {i,u}{32,64,128}\"", amc::gen_parsenum }
        ,{ "amcdb.gen  gen:prep_proto  perns:N  comment:\"Detect protocol namespaces\"", amc::gen_prep_proto }
        ,{ "amcdb.gen  gen:newfield_charset  perns:N  comment:\"Generate code for charsets -- earlyish\"", amc::gen_newfield_charset }
        ,{ "amcdb.gen  gen:newfield_count  perns:N  comment:\"Create new fields for Count\"", amc::gen_newfield_count }
        ,{ "amcdb.gen  gen:newfield_hook  perns:N  comment:\"Create new fields for Hook\"", amc::gen_newfield_hook }
        ,{ "amcdb.gen  gen:newfield_exec  perns:N  comment:\"Create new fields for Exec\"", amc::gen_newfield_exec }
        ,{ "amcdb.gen  gen:newfield_sortfld  perns:N  comment:\"Create fcmp records for sortfld (prior to cbase!)\"", amc::gen_newfield_sortfld }
        ,{ "amcdb.gen  gen:newfield_cbase  perns:N  comment:\"Create new fields for cbase\"", amc::gen_newfield_cbase }
        ,{ "amcdb.gen  gen:newfield_ptrary  perns:N  comment:\"Create new fields for ptrary\"", amc::gen_newfield_ptrary }
        ,{ "amcdb.gen  gen:newfield_cfmt  perns:N  comment:\"Create new cfmt records\"", amc::gen_newfield_cfmt }
        ,{ "amcdb.gen  gen:newfield_dispatch  perns:N  comment:\"Create new fields for dispatch\"", amc::gen_newfield_dispatch }
        ,{ "amcdb.gen  gen:fieldid  perns:N  comment:\"Create lsit of all fields\"", amc::gen_fieldid }
        ,{ "amcdb.gen  gen:prep_field  perns:N  comment:\"Field preparation\"", amc::gen_prep_field }
        ,{ "amcdb.gen  gen:basepool  perns:N  comment:\"Create basepools based on defaults\"", amc::gen_basepool }
        ,{ "amcdb.gen  gen:check_basepool  perns:N  comment:\"Check basepool order\"", amc::gen_check_basepool }
        ,{ "amcdb.gen  gen:check_bigend  perns:N  comment:\"Check big-endians\"", amc::gen_check_bigend }
        ,{ "amcdb.gen  gen:check_reftype  perns:N  comment:\"Check that reftypes are valid\"", amc::gen_check_reftype }
        ,{ "amcdb.gen  gen:check_static  perns:N  comment:\"Check order of loading of gstatics\"", amc::gen_check_static }
        ,{ "amcdb.gen  gen:check_cheapcopy  perns:N  comment:\"Check that cheapcopy is consistently applied\"", amc::gen_check_cheapcopy }
        ,{ "amcdb.gen  gen:check_cascdel  perns:N  comment:\"\"", amc::gen_check_cascdel }
        ,{ "amcdb.gen  gen:check_cpptype  perns:N  comment:\"\"", amc::gen_check_cpptype }
        ,{ "amcdb.gen  gen:check_fcurs  perns:N  comment:\"Check that cursors can be generated\"", amc::gen_check_fcurs }
        ,{ "amcdb.gen  gen:check_prefix  perns:N  comment:\"Check field prefixes\"", amc::gen_check_prefix }
        ,{ "amcdb.gen  gen:check_bitfld  perns:N  comment:\"Check that bitfields don't overlap\"", amc::gen_check_bitfld }
        ,{ "amcdb.gen  gen:check_varlen  perns:N  comment:\"CHeck that msgtype is not cheap copy\"", amc::gen_check_varlen }
        ,{ "amcdb.gen  gen:xref_parent  perns:N  comment:\"Create p_parent links for xrefs\"", amc::gen_xref_parent }
        ,{ "amcdb.gen  gen:datafld  perns:N  comment:\"Create ctype.c_datafld\"", amc::gen_datafld }
        ,{ "amcdb.gen  gen:ctype_toposort  perns:N  comment:\"Determine ctype graph\"", amc::gen_ctype_toposort }
        ,{ "amcdb.gen  gen:prep_ctype  perns:N  comment:cpp_type,arg_type,enum_type", amc::gen_prep_ctype }
        ,{ "amcdb.gen  gen:prep_fconst  perns:N  comment:\"\"", amc::gen_prep_fconst }
        ,{ "amcdb.gen  gen:usedns  perns:N  comment:\"Namespace dependencies\"", amc::gen_usedns }
        ,{ "amcdb.gen  gen:include  perns:N  comment:\"Calculate #includes for dependent namespaces\"", amc::gen_include }
        ,{ "amcdb.gen  gen:load_gstatic  perns:N  comment:\"load static data\"", amc::gen_load_gstatic }
        ,{ "amcdb.gen  gen:copypriv  perns:N  comment:\"Prevent assignment of certain ctypes\"", amc::gen_copypriv }
        ,{ "amcdb.gen  gen:pmask  perns:N  comment:\"Generate bitsets for pmask (presence mask) fields\"", amc::gen_pmask }
        ,{ "amcdb.gen  gen:ssimdb  perns:N  comment:\"Check nsdb table consistency\"", amc::gen_ssimdb }
        ,{ "amcdb.gen  gen:xref2  perns:N  comment:\"For each ctype, calculate list of xrefs where the ctype is a child\"", amc::gen_xref2 }
        ,{ "amcdb.gen  gen:check_xref  perns:N  comment:\"Validate xrefs\"", amc::gen_check_xref }
        ,{ "amcdb.gen  gen:ns_enums  perns:N  comment:\"Output enums\"", amc::gen_ns_enums }
        ,{ "amcdb.gen  gen:ns_pkeytypedef  perns:N  comment:\"Pkey typedefs\"", amc::gen_ns_pkeytypedef }
        ,{ "amcdb.gen  gen:ns_field  perns:N  comment:\"Recursively visit all fields and generate code for them\"", amc::gen_ns_field }
        ,{ "amcdb.gen  gen:ns_fwddecl  perns:N  comment:\"Forward-declaration of steps\"", amc::gen_ns_fwddecl }
        ,{ "amcdb.gen  gen:ns_fwddecl2  perns:N  comment:\"Output forward declarations of structs\"", amc::gen_ns_fwddecl2 }
        ,{ "amcdb.gen  gen:ns_gstatic  perns:N  comment:\"Generate step function pointers for gstatic tables\"", amc::gen_ns_gstatic }
        ,{ "amcdb.gen  gen:compute_size  perns:N  comment:\"Compute sizes of all ctypes\"", amc::gen_compute_size }
        ,{ "amcdb.gen  gen:cget  perns:N  comment:\"Generate helpful Q functions based on fconsts and bools\"", amc::gen_cget }
        ,{ "amcdb.gen  gen:fcmap  perns:N  comment:\"Generate mapping between different enums using fcmap.ssim\"", amc::gen_fcmap }
        ,{ "amcdb.gen  gen:ns_include  perns:Y  comment:\"Generate includes\"", amc::gen_ns_include }
        ,{ "amcdb.gen  gen:ns_gsymbol  perns:Y  comment:\"Generate strings from tables\"", amc::gen_ns_gsymbol }
        ,{ "amcdb.gen  gen:ns_size_enums  perns:Y  comment:\"Enums for sizes of certain types (avoids circular dependency of includes)\"", amc::gen_ns_size_enums }
        ,{ "amcdb.gen  gen:ns_ctype  perns:Y  comment:\"Generate ctype functions\"", amc::gen_ns_ctype }
        ,{ "amcdb.gen  gen:ns_check_path  perns:Y  comment:\"Check x-ref paths for consistency\"", amc::gen_ns_check_path }
        ,{ "amcdb.gen  gen:ns_check_pack  perns:Y  comment:\"Recursively check packing\"", amc::gen_ns_check_pack }
        ,{ "amcdb.gen  gen:ns_check_nstype  perns:Y  comment:\"Check namespace annotations\"", amc::gen_ns_check_nstype }
        ,{ "amcdb.gen  gen:ns_check_main  perns:Y  comment:\"Check main() usage\"", amc::gen_ns_check_main }
        ,{ "amcdb.gen  gen:ns_dispatch  perns:Y  comment:\"Generate dispatch code\"", amc::gen_ns_dispatch }
        ,{ "amcdb.gen  gen:ns_pnew  perns:Y  comment:\"Generate custom constructors (placement new)\"", amc::gen_ns_pnew }
        ,{ "amcdb.gen  gen:ns_funcindex  perns:Y  comment:\"Generate index of functions per field/ctype\"", amc::gen_ns_funcindex }
        ,{ "amcdb.gen  gen:ns_print_proto  perns:Y  comment:\"Print function prototypes\"", amc::gen_ns_print_proto }
        ,{ "amcdb.gen  gen:ns_print_struct  perns:Y  comment:\"Print structs and their function declarations\"", amc::gen_ns_print_struct }
        ,{ "amcdb.gen  gen:ns_curstext  perns:Y  comment:\"Print cursor definitions\"", amc::gen_ns_curstext }
        ,{ "amcdb.gen  gen:ns_func  perns:Y  comment:\"Print all functions bodies\"", amc::gen_ns_func }
        ,{ "amcdb.gen  gen:ns_operators  perns:Y  comment:\"Generate C++ operators <<, <, >, etc.\"", amc::gen_ns_operators }
        ,{ "amcdb.gen  gen:ns_check_lim  perns:Y  comment:\"Check that no functions/fields were added after function lock\"", amc::gen_ns_check_lim }
        ,{ "amcdb.gen  gen:ns_write  perns:Y  comment:\"Output namespace data\"", amc::gen_ns_write }
        ,{NULL, NULL}
    };
    (void)data;
    amcdb::Gen gen;
    for (int i=0; data[i].s; i++) {
        (void)amcdb::Gen_ReadStrptrMaybe(gen, algo::strptr(data[i].s));
        amc::FGen *elem = gen_InsertMaybe(gen);
        vrfy(elem, tempstr("amc.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- amc.FDb.gen.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::gen_XrefMaybe(amc::FGen &row) {
    bool retval = true;
    (void)row;
    // insert gen into index zs_gen_perns
    if (row.perns) { // user-defined insert condition
        zs_gen_perns_Insert(row);
    }
    return retval;
}

// --- amc.FDb.fregx.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFregx& amc::fregx_Alloc() {
    amc::FFregx* row = fregx_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fregx  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fregx.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFregx* amc::fregx_AllocMaybe() {
    amc::FFregx *row = (amc::FFregx*)fregx_AllocMem();
    if (row) {
        new (row) amc::FFregx; // call constructor
    }
    return row;
}

// --- amc.FDb.fregx.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFregx* amc::fregx_InsertMaybe(const dmmeta::Fregx &value) {
    amc::FFregx *row = &fregx_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fregx_CopyIn(*row,const_cast<dmmeta::Fregx&>(value));
    bool ok = fregx_XrefMaybe(*row); // this may return false
    if (!ok) {
        fregx_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fregx.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fregx_AllocMem() {
    u64 new_nelems     = _db.fregx_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFregx*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fregx_lary[bsr];
        if (!lev) {
            lev=(amc::FFregx*)amc::lpool_AllocMem(sizeof(amc::FFregx) * (u64(1)<<bsr));
            _db.fregx_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fregx_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fregx.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fregx_RemoveLast() {
    u64 n = _db.fregx_n;
    if (n > 0) {
        n -= 1;
        fregx_qFind(u64(n)).~FFregx();
        _db.fregx_n = i32(n);
    }
}

// --- amc.FDb.fregx.InputMaybe
static bool amc::fregx_InputMaybe(dmmeta::Fregx &elem) {
    bool retval = true;
    retval = fregx_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fregx.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fregx_XrefMaybe(amc::FFregx &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fregx into index c_fregx
    if (true) { // user-defined insert condition
        bool success = c_fregx_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fregx"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.tclass.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTclass& amc::tclass_Alloc() {
    amc::FTclass* row = tclass_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tclass  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tclass.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTclass* amc::tclass_AllocMaybe() {
    amc::FTclass *row = (amc::FTclass*)tclass_AllocMem();
    if (row) {
        new (row) amc::FTclass; // call constructor
    }
    return row;
}

// --- amc.FDb.tclass.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTclass* amc::tclass_InsertMaybe(const amcdb::Tclass &value) {
    amc::FTclass *row = &tclass_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tclass_CopyIn(*row,const_cast<amcdb::Tclass&>(value));
    bool ok = tclass_XrefMaybe(*row); // this may return false
    if (!ok) {
        tclass_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tclass.RemoveAll
// Destroy all elements of Inlary
void amc::tclass_RemoveAll() {
    for (u64 n = _db.tclass_n; n>0; ) {
        n--;
        reinterpret_cast<amc::FTclass*>(_db.tclass_data)[n].~FTclass(); // destroy last element
        _db.tclass_n=n;
    }
}

// --- amc.FDb.tclass.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tclass_RemoveLast() {
    u64 n = _db.tclass_n;
    if (n > 0) {
        n -= 1;
        reinterpret_cast<amc::FTclass*>(_db.tclass_data)[n].~FTclass();
        _db.tclass_n = n;
    }
}

// --- amc.FDb.tclass.LoadStatic
static void amc::tclass_LoadStatic() {
    static struct _t {
        const char *s;
        void (*step)();
    } data[] = {
        { "amcdb.tclass  tclass:Atree  comment:\"X-reference: AVL tree\"", amc::tclass_Atree }
        ,{ "amcdb.tclass  tclass:Base  comment:\"Incorporate base ctype fields\"", amc::tclass_Base }
        ,{ "amcdb.tclass  tclass:Bheap  comment:\"X-reference: Binary heap built on top of ptrary.\"", amc::tclass_Bheap }
        ,{ "amcdb.tclass  tclass:Bitfld  comment:\"A field whose value is stored in the bits of another field\"", amc::tclass_Bitfld }
        ,{ "amcdb.tclass  tclass:Bitset  comment:\"\"", amc::tclass_Bitset }
        ,{ "amcdb.tclass  tclass:Blkpool  comment:\"variable size block-based allocator suitable for fifo use\"", amc::tclass_Blkpool }
        ,{ "amcdb.tclass  tclass:Charset  comment:\"\"", amc::tclass_Charset }
        ,{ "amcdb.tclass  tclass:Cmp  comment:Comparison", amc::tclass_Cmp }
        ,{ "amcdb.tclass  tclass:Count  comment:\"A cross-reference that simply counts # of children\"", amc::tclass_Count }
        ,{ "amcdb.tclass  tclass:Cppfunc  comment:\"\"", amc::tclass_Cppfunc }
        ,{ "amcdb.tclass  tclass:Cppstack  comment:\"X-reference: count of elements\"", amc::tclass_Cppstack }
        ,{ "amcdb.tclass  tclass:Ctype  comment:\"\"", amc::tclass_Ctype }
        ,{ "amcdb.tclass  tclass:Dec  comment:\"\"", amc::tclass_Dec }
        ,{ "amcdb.tclass  tclass:Delptr  comment:\"Pointer to a private cascade-delete value (like Val by starts as NULL)\"", amc::tclass_Delptr }
        ,{ "amcdb.tclass  tclass:Exec  comment:Subprocess", amc::tclass_Exec }
        ,{ "amcdb.tclass  tclass:Fbuf  comment:\"Byte buffer with epoll integration & message scanning\"", amc::tclass_Fbuf }
        ,{ "amcdb.tclass  tclass:Fcast  comment:\"\"", amc::tclass_Fcast }
        ,{ "amcdb.tclass  tclass:Fconst  comment:\"Get/Set enums\"", amc::tclass_Fconst }
        ,{ "amcdb.tclass  tclass:Field  comment:\"Base for all tclass\"", amc::tclass_Field }
        ,{ "amcdb.tclass  tclass:Field2  comment:\"Base for all tclass\"", amc::tclass_Field2 }
        ,{ "amcdb.tclass  tclass:Global  comment:\"Global variable -- root of all access paths\"", amc::tclass_Global }
        ,{ "amcdb.tclass  tclass:Hook  comment:\"Pointer to a function\"", amc::tclass_Hook }
        ,{ "amcdb.tclass  tclass:Inlary  comment:\"Zero to N values, allocated inside the parent struct\"", amc::tclass_Inlary }
        ,{ "amcdb.tclass  tclass:Io  comment:\"Load ssimfile/gstatic\"", amc::tclass_Io }
        ,{ "amcdb.tclass  tclass:Lary  comment:\"Array of 32 non-resizable arrays of values. Permanent pointers.\"", amc::tclass_Lary }
        ,{ "amcdb.tclass  tclass:Llist  comment:\"X-reference: any of 32 possible types of linked list\"", amc::tclass_Llist }
        ,{ "amcdb.tclass  tclass:Lpool  comment:\"Varlen pool, implemented as array of 32 Tpools\"", amc::tclass_Lpool }
        ,{ "amcdb.tclass  tclass:Malloc  comment:\"Pass-through for malloc / free\"", amc::tclass_Malloc }
        ,{ "amcdb.tclass  tclass:Numstr  comment:\"\"", amc::tclass_Numstr }
        ,{ "amcdb.tclass  tclass:Opt  comment:\"Optional trailing struct field occupying rest of space\"", amc::tclass_Opt }
        ,{ "amcdb.tclass  tclass:Pkey  comment:\"Primary key reference\"", amc::tclass_Pkey }
        ,{ "amcdb.tclass  tclass:Pmask  comment:\"\"", amc::tclass_Pmask }
        ,{ "amcdb.tclass  tclass:Pool  comment:\"Base for all pools\"", amc::tclass_Pool }
        ,{ "amcdb.tclass  tclass:Protocol  comment:\"\"", amc::tclass_Protocol }
        ,{ "amcdb.tclass  tclass:Ptr  comment:\"Cross-reference pointer to a future record\"", amc::tclass_Ptr }
        ,{ "amcdb.tclass  tclass:Ptrary  comment:\"Array of pointers\"", amc::tclass_Ptrary }
        ,{ "amcdb.tclass  tclass:RegxSql  comment:\"Pkey regx reference\"", amc::tclass_RegxSql }
        ,{ "amcdb.tclass  tclass:Sbrk  comment:\"Call Sbrk\"", amc::tclass_Sbrk }
        ,{ "amcdb.tclass  tclass:Smallstr  comment:\"Fixed-length string field\"", amc::tclass_Smallstr }
        ,{ "amcdb.tclass  tclass:Sort  comment:\"\"", amc::tclass_Sort }
        ,{ "amcdb.tclass  tclass:Step  comment:\"\"", amc::tclass_Step }
        ,{ "amcdb.tclass  tclass:Substr  comment:\"\"", amc::tclass_Substr }
        ,{ "amcdb.tclass  tclass:Tary  comment:\"Flat, reallocatable array of values\"", amc::tclass_Tary }
        ,{ "amcdb.tclass  tclass:Thash  comment:\"X-reference; hash built on top of ptrary.\"", amc::tclass_Thash }
        ,{ "amcdb.tclass  tclass:Tpool  comment:\"Singly linked free-list.\"", amc::tclass_Tpool }
        ,{ "amcdb.tclass  tclass:Upptr  comment:\"Pointer to a past (pre-existing) record\"", amc::tclass_Upptr }
        ,{ "amcdb.tclass  tclass:Val  comment:\"Single cascade-insert in-place value.\"", amc::tclass_Val }
        ,{ "amcdb.tclass  tclass:Varlen  comment:\"variable-length field\"", amc::tclass_Varlen }
        ,{ "amcdb.tclass  tclass:ZSListMT  comment:\"zero-terminated singly linked list with thread-safe access\"", amc::tclass_ZSListMT }
        ,{NULL, NULL}
    };
    (void)data;
    amcdb::Tclass tclass;
    for (int i=0; data[i].s; i++) {
        (void)amcdb::Tclass_ReadStrptrMaybe(tclass, algo::strptr(data[i].s));
        amc::FTclass *elem = tclass_InsertMaybe(tclass);
        vrfy(elem, tempstr("amc.static_insert_fatal_error")
        << Keyval("tuple",algo::strptr(data[i].s))
        << Keyval("comment",algo_lib::DetachBadTags()));
        elem->step = data[i].step;
    }
}

// --- amc.FDb.tclass.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tclass_XrefMaybe(amc::FTclass &row) {
    bool retval = true;
    (void)row;
    // insert tclass into index ind_tclass
    if (true) { // user-defined insert condition
        bool success = ind_tclass_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_tclass"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_tclass.Find
// Find row by key. Return NULL if not found.
amc::FTclass* amc::ind_tclass_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_tclass_buckets_n - 1);
    amc::FTclass* *e = &_db.ind_tclass_buckets_elems[index];
    amc::FTclass* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).tclass == key;
        if (done) break;
        e         = &ret->ind_tclass_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_tclass.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTclass& amc::ind_tclass_GetOrCreate(const algo::strptr& key) {
    amc::FTclass* ret = ind_tclass_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &tclass_Alloc();
        (*ret).tclass = key;
        bool good = tclass_XrefMaybe(*ret);
        if (!good) {
            tclass_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_tclass  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_tclass.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_tclass_InsertMaybe(amc::FTclass& row) {
    ind_tclass_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_tclass_next == (amc::FTclass*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.tclass) & (_db.ind_tclass_buckets_n - 1);
        amc::FTclass* *prev = &_db.ind_tclass_buckets_elems[index];
        do {
            amc::FTclass* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).tclass == row.tclass) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_tclass_next;
        } while (true);
        if (retval) {
            row.ind_tclass_next = *prev;
            _db.ind_tclass_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_tclass.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_tclass_Remove(amc::FTclass& row) {
    if (LIKELY(row.ind_tclass_next != (amc::FTclass*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.tclass) & (_db.ind_tclass_buckets_n - 1);
        amc::FTclass* *prev = &_db.ind_tclass_buckets_elems[index]; // addr of pointer to current element
        while (amc::FTclass *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_tclass_next; // unlink (singly linked list)
                _db.ind_tclass_n--;
                row.ind_tclass_next = (amc::FTclass*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_tclass_next;
        }
    }
}

// --- amc.FDb.ind_tclass.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_tclass_Reserve(int n) {
    u32 old_nbuckets = _db.ind_tclass_buckets_n;
    u32 new_nelems   = _db.ind_tclass_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FTclass*);
        u32 new_size = new_nbuckets * sizeof(amc::FTclass*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FTclass* *new_buckets = (amc::FTclass**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_tclass");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_tclass_buckets_n; i++) {
            amc::FTclass* elem = _db.ind_tclass_buckets_elems[i];
            while (elem) {
                amc::FTclass &row        = *elem;
                amc::FTclass* next       = row.ind_tclass_next;
                u32 index          = algo::Smallstr50_Hash(0, row.tclass) & (new_nbuckets-1);
                row.ind_tclass_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_tclass_buckets_elems, old_size);
        _db.ind_tclass_buckets_elems = new_buckets;
        _db.ind_tclass_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fcmp.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmp& amc::fcmp_Alloc() {
    amc::FFcmp* row = fcmp_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcmp  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcmp.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmp* amc::fcmp_AllocMaybe() {
    amc::FFcmp *row = (amc::FFcmp*)fcmp_AllocMem();
    if (row) {
        new (row) amc::FFcmp; // call constructor
    }
    return row;
}

// --- amc.FDb.fcmp.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmp* amc::fcmp_InsertMaybe(const dmmeta::Fcmp &value) {
    amc::FFcmp *row = &fcmp_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcmp_CopyIn(*row,const_cast<dmmeta::Fcmp&>(value));
    bool ok = fcmp_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcmp_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcmp.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcmp_AllocMem() {
    u64 new_nelems     = _db.fcmp_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcmp*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcmp_lary[bsr];
        if (!lev) {
            lev=(amc::FFcmp*)amc::lpool_AllocMem(sizeof(amc::FFcmp) * (u64(1)<<bsr));
            _db.fcmp_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcmp_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcmp.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcmp_RemoveLast() {
    u64 n = _db.fcmp_n;
    if (n > 0) {
        n -= 1;
        fcmp_qFind(u64(n)).~FFcmp();
        _db.fcmp_n = i32(n);
    }
}

// --- amc.FDb.fcmp.InputMaybe
static bool amc::fcmp_InputMaybe(dmmeta::Fcmp &elem) {
    bool retval = true;
    retval = fcmp_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcmp.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcmp_XrefMaybe(amc::FFcmp &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fcmp into index c_fcmp
    if (true) { // user-defined insert condition
        bool success = c_fcmp_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fcmp"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fcast.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcast& amc::fcast_Alloc() {
    amc::FFcast* row = fcast_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcast  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcast.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcast* amc::fcast_AllocMaybe() {
    amc::FFcast *row = (amc::FFcast*)fcast_AllocMem();
    if (row) {
        new (row) amc::FFcast; // call constructor
    }
    return row;
}

// --- amc.FDb.fcast.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcast* amc::fcast_InsertMaybe(const dmmeta::Fcast &value) {
    amc::FFcast *row = &fcast_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcast_CopyIn(*row,const_cast<dmmeta::Fcast&>(value));
    bool ok = fcast_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcast_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcast.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcast_AllocMem() {
    u64 new_nelems     = _db.fcast_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcast*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcast_lary[bsr];
        if (!lev) {
            lev=(amc::FFcast*)amc::lpool_AllocMem(sizeof(amc::FFcast) * (u64(1)<<bsr));
            _db.fcast_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcast_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcast.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcast_RemoveLast() {
    u64 n = _db.fcast_n;
    if (n > 0) {
        n -= 1;
        fcast_qFind(u64(n)).~FFcast();
        _db.fcast_n = i32(n);
    }
}

// --- amc.FDb.fcast.InputMaybe
static bool amc::fcast_InputMaybe(dmmeta::Fcast &elem) {
    bool retval = true;
    retval = fcast_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcast.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcast_XrefMaybe(amc::FFcast &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fcast into index c_fcast
    if (true) { // user-defined insert condition
        bool success = c_fcast_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fcast"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.noxref.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNoxref& amc::noxref_Alloc() {
    amc::FNoxref* row = noxref_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.noxref  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.noxref.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNoxref* amc::noxref_AllocMaybe() {
    amc::FNoxref *row = (amc::FNoxref*)noxref_AllocMem();
    if (row) {
        new (row) amc::FNoxref; // call constructor
    }
    return row;
}

// --- amc.FDb.noxref.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNoxref* amc::noxref_InsertMaybe(const dmmeta::Noxref &value) {
    amc::FNoxref *row = &noxref_Alloc(); // if out of memory, process dies. if input error, return NULL.
    noxref_CopyIn(*row,const_cast<dmmeta::Noxref&>(value));
    bool ok = noxref_XrefMaybe(*row); // this may return false
    if (!ok) {
        noxref_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.noxref.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::noxref_AllocMem() {
    u64 new_nelems     = _db.noxref_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNoxref*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.noxref_lary[bsr];
        if (!lev) {
            lev=(amc::FNoxref*)amc::lpool_AllocMem(sizeof(amc::FNoxref) * (u64(1)<<bsr));
            _db.noxref_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.noxref_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.noxref.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::noxref_RemoveLast() {
    u64 n = _db.noxref_n;
    if (n > 0) {
        n -= 1;
        noxref_qFind(u64(n)).~FNoxref();
        _db.noxref_n = i32(n);
    }
}

// --- amc.FDb.noxref.InputMaybe
static bool amc::noxref_InputMaybe(dmmeta::Noxref &elem) {
    bool retval = true;
    retval = noxref_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.noxref.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::noxref_XrefMaybe(amc::FNoxref &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert noxref into index c_noxref
    if (true) { // user-defined insert condition
        bool success = c_noxref_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_noxref"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.nocascdel.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNocascdel& amc::nocascdel_Alloc() {
    amc::FNocascdel* row = nocascdel_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nocascdel  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nocascdel.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNocascdel* amc::nocascdel_AllocMaybe() {
    amc::FNocascdel *row = (amc::FNocascdel*)nocascdel_AllocMem();
    if (row) {
        new (row) amc::FNocascdel; // call constructor
    }
    return row;
}

// --- amc.FDb.nocascdel.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNocascdel* amc::nocascdel_InsertMaybe(const dmmeta::Nocascdel &value) {
    amc::FNocascdel *row = &nocascdel_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nocascdel_CopyIn(*row,const_cast<dmmeta::Nocascdel&>(value));
    bool ok = nocascdel_XrefMaybe(*row); // this may return false
    if (!ok) {
        nocascdel_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nocascdel.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nocascdel_AllocMem() {
    u64 new_nelems     = _db.nocascdel_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNocascdel*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nocascdel_lary[bsr];
        if (!lev) {
            lev=(amc::FNocascdel*)amc::lpool_AllocMem(sizeof(amc::FNocascdel) * (u64(1)<<bsr));
            _db.nocascdel_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nocascdel_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nocascdel.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nocascdel_RemoveLast() {
    u64 n = _db.nocascdel_n;
    if (n > 0) {
        n -= 1;
        nocascdel_qFind(u64(n)).~FNocascdel();
        _db.nocascdel_n = i32(n);
    }
}

// --- amc.FDb.nocascdel.InputMaybe
static bool amc::nocascdel_InputMaybe(dmmeta::Nocascdel &elem) {
    bool retval = true;
    retval = nocascdel_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nocascdel.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nocascdel_XrefMaybe(amc::FNocascdel &row) {
    bool retval = true;
    (void)row;
    amc::FXref* p_xref = amc::ind_xref_Find(row.xref);
    if (UNLIKELY(!p_xref)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_xref" << Keyval("key", row.xref);
        return false;
    }
    // insert nocascdel into index c_nocascdel
    if (true) { // user-defined insert condition
        bool success = c_nocascdel_InsertMaybe(*p_xref, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FXref.c_nocascdel"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.cafter.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCafter& amc::cafter_Alloc() {
    amc::FCafter* row = cafter_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cafter  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cafter.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCafter* amc::cafter_AllocMaybe() {
    amc::FCafter *row = (amc::FCafter*)cafter_AllocMem();
    if (row) {
        new (row) amc::FCafter; // call constructor
    }
    return row;
}

// --- amc.FDb.cafter.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCafter* amc::cafter_InsertMaybe(const dmmeta::Cafter &value) {
    amc::FCafter *row = &cafter_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cafter_CopyIn(*row,const_cast<dmmeta::Cafter&>(value));
    bool ok = cafter_XrefMaybe(*row); // this may return false
    if (!ok) {
        cafter_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cafter.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cafter_AllocMem() {
    u64 new_nelems     = _db.cafter_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCafter*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cafter_lary[bsr];
        if (!lev) {
            lev=(amc::FCafter*)amc::lpool_AllocMem(sizeof(amc::FCafter) * (u64(1)<<bsr));
            _db.cafter_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cafter_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cafter.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cafter_RemoveLast() {
    u64 n = _db.cafter_n;
    if (n > 0) {
        n -= 1;
        cafter_qFind(u64(n)).~FCafter();
        _db.cafter_n = i32(n);
    }
}

// --- amc.FDb.cafter.InputMaybe
static bool amc::cafter_InputMaybe(dmmeta::Cafter &elem) {
    bool retval = true;
    retval = cafter_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cafter.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cafter_XrefMaybe(amc::FCafter &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_after = amc::ind_ctype_Find(after_Get(row));
    if (UNLIKELY(!p_after)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", after_Get(row));
        return false;
    }
    // cafter: save pointer to after
    if (true) { // user-defined insert condition
        row.p_after = p_after;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert cafter into index zd_cafter
    if (true) { // user-defined insert condition
        zd_cafter_Insert(*p_ctype, row);
    }
    return retval;
}

// --- amc.FDb.csize.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCsize& amc::csize_Alloc() {
    amc::FCsize* row = csize_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.csize  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.csize.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCsize* amc::csize_AllocMaybe() {
    amc::FCsize *row = (amc::FCsize*)csize_AllocMem();
    if (row) {
        new (row) amc::FCsize; // call constructor
    }
    return row;
}

// --- amc.FDb.csize.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCsize* amc::csize_InsertMaybe(const dmmeta::Csize &value) {
    amc::FCsize *row = &csize_Alloc(); // if out of memory, process dies. if input error, return NULL.
    csize_CopyIn(*row,const_cast<dmmeta::Csize&>(value));
    bool ok = csize_XrefMaybe(*row); // this may return false
    if (!ok) {
        csize_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.csize.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::csize_AllocMem() {
    u64 new_nelems     = _db.csize_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCsize*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.csize_lary[bsr];
        if (!lev) {
            lev=(amc::FCsize*)amc::lpool_AllocMem(sizeof(amc::FCsize) * (u64(1)<<bsr));
            _db.csize_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.csize_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.csize.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::csize_RemoveLast() {
    u64 n = _db.csize_n;
    if (n > 0) {
        n -= 1;
        csize_qFind(u64(n)).~FCsize();
        _db.csize_n = i32(n);
    }
}

// --- amc.FDb.csize.InputMaybe
static bool amc::csize_InputMaybe(dmmeta::Csize &elem) {
    bool retval = true;
    retval = csize_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.csize.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::csize_XrefMaybe(amc::FCsize &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert csize into index c_csize
    if (true) { // user-defined insert condition
        bool success = c_csize_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_csize"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.nsx.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsx& amc::nsx_Alloc() {
    amc::FNsx* row = nsx_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nsx  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nsx.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsx* amc::nsx_AllocMaybe() {
    amc::FNsx *row = (amc::FNsx*)nsx_AllocMem();
    if (row) {
        new (row) amc::FNsx; // call constructor
    }
    return row;
}

// --- amc.FDb.nsx.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsx* amc::nsx_InsertMaybe(const dmmeta::Nsx &value) {
    amc::FNsx *row = &nsx_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nsx_CopyIn(*row,const_cast<dmmeta::Nsx&>(value));
    bool ok = nsx_XrefMaybe(*row); // this may return false
    if (!ok) {
        nsx_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nsx.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nsx_AllocMem() {
    u64 new_nelems     = _db.nsx_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNsx*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nsx_lary[bsr];
        if (!lev) {
            lev=(amc::FNsx*)amc::lpool_AllocMem(sizeof(amc::FNsx) * (u64(1)<<bsr));
            _db.nsx_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nsx_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nsx.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nsx_RemoveLast() {
    u64 n = _db.nsx_n;
    if (n > 0) {
        n -= 1;
        nsx_qFind(u64(n)).~FNsx();
        _db.nsx_n = i32(n);
    }
}

// --- amc.FDb.nsx.InputMaybe
static bool amc::nsx_InputMaybe(dmmeta::Nsx &elem) {
    bool retval = true;
    retval = nsx_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nsx.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nsx_XrefMaybe(amc::FNsx &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_pool = amc::ind_field_Find(row.pool);
    if (UNLIKELY(!p_pool)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.pool);
        return false;
    }
    // nsx: save pointer to pool
    if (true) { // user-defined insert condition
        row.p_pool = p_pool;
    }
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", row.ns);
        return false;
    }
    // insert nsx into index c_nsx
    if (true) { // user-defined insert condition
        bool success = c_nsx_InsertMaybe(*p_ns, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_nsx"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fcompact.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcompact& amc::fcompact_Alloc() {
    amc::FFcompact* row = fcompact_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcompact  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcompact.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcompact* amc::fcompact_AllocMaybe() {
    amc::FFcompact *row = (amc::FFcompact*)fcompact_AllocMem();
    if (row) {
        new (row) amc::FFcompact; // call constructor
    }
    return row;
}

// --- amc.FDb.fcompact.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcompact* amc::fcompact_InsertMaybe(const dmmeta::Fcompact &value) {
    amc::FFcompact *row = &fcompact_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcompact_CopyIn(*row,const_cast<dmmeta::Fcompact&>(value));
    bool ok = fcompact_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcompact_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcompact.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcompact_AllocMem() {
    u64 new_nelems     = _db.fcompact_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcompact*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcompact_lary[bsr];
        if (!lev) {
            lev=(amc::FFcompact*)amc::lpool_AllocMem(sizeof(amc::FFcompact) * (u64(1)<<bsr));
            _db.fcompact_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcompact_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcompact.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcompact_RemoveLast() {
    u64 n = _db.fcompact_n;
    if (n > 0) {
        n -= 1;
        fcompact_qFind(u64(n)).~FFcompact();
        _db.fcompact_n = i32(n);
    }
}

// --- amc.FDb.fcompact.InputMaybe
static bool amc::fcompact_InputMaybe(dmmeta::Fcompact &elem) {
    bool retval = true;
    retval = fcompact_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcompact.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcompact_XrefMaybe(amc::FFcompact &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fcompact into index c_fcompact
    if (true) { // user-defined insert condition
        bool success = c_fcompact_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fcompact"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.findrem.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFindrem& amc::findrem_Alloc() {
    amc::FFindrem* row = findrem_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.findrem  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.findrem.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFindrem* amc::findrem_AllocMaybe() {
    amc::FFindrem *row = (amc::FFindrem*)findrem_AllocMem();
    if (row) {
        new (row) amc::FFindrem; // call constructor
    }
    return row;
}

// --- amc.FDb.findrem.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFindrem* amc::findrem_InsertMaybe(const dmmeta::Findrem &value) {
    amc::FFindrem *row = &findrem_Alloc(); // if out of memory, process dies. if input error, return NULL.
    findrem_CopyIn(*row,const_cast<dmmeta::Findrem&>(value));
    bool ok = findrem_XrefMaybe(*row); // this may return false
    if (!ok) {
        findrem_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.findrem.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::findrem_AllocMem() {
    u64 new_nelems     = _db.findrem_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFindrem*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.findrem_lary[bsr];
        if (!lev) {
            lev=(amc::FFindrem*)amc::lpool_AllocMem(sizeof(amc::FFindrem) * (u64(1)<<bsr));
            _db.findrem_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.findrem_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.findrem.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::findrem_RemoveLast() {
    u64 n = _db.findrem_n;
    if (n > 0) {
        n -= 1;
        findrem_qFind(u64(n)).~FFindrem();
        _db.findrem_n = i32(n);
    }
}

// --- amc.FDb.findrem.InputMaybe
static bool amc::findrem_InputMaybe(dmmeta::Findrem &elem) {
    bool retval = true;
    retval = findrem_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.findrem.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::findrem_XrefMaybe(amc::FFindrem &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert findrem into index c_findrem
    if (true) { // user-defined insert condition
        bool success = c_findrem_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_findrem"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fcurs.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcurs& amc::fcurs_Alloc() {
    amc::FFcurs* row = fcurs_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcurs  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcurs.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcurs* amc::fcurs_AllocMaybe() {
    amc::FFcurs *row = (amc::FFcurs*)fcurs_AllocMem();
    if (row) {
        new (row) amc::FFcurs; // call constructor
    }
    return row;
}

// --- amc.FDb.fcurs.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcurs* amc::fcurs_InsertMaybe(const dmmeta::Fcurs &value) {
    amc::FFcurs *row = &fcurs_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcurs_CopyIn(*row,const_cast<dmmeta::Fcurs&>(value));
    bool ok = fcurs_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcurs_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcurs.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcurs_AllocMem() {
    u64 new_nelems     = _db.fcurs_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcurs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcurs_lary[bsr];
        if (!lev) {
            lev=(amc::FFcurs*)amc::lpool_AllocMem(sizeof(amc::FFcurs) * (u64(1)<<bsr));
            _db.fcurs_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcurs_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcurs.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcurs_RemoveLast() {
    u64 n = _db.fcurs_n;
    if (n > 0) {
        n -= 1;
        fcurs_qFind(u64(n)).~FFcurs();
        _db.fcurs_n = i32(n);
    }
}

// --- amc.FDb.fcurs.InputMaybe
static bool amc::fcurs_InputMaybe(dmmeta::Fcurs &elem) {
    bool retval = true;
    retval = fcurs_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcurs.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcurs_XrefMaybe(amc::FFcurs &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(field_Get(row));
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", field_Get(row));
        return false;
    }
    // fcurs: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert fcurs into index c_fcurs
    if (true) { // user-defined insert condition
        c_fcurs_Insert(*p_ctype, row);
    }
    // insert fcurs into index ind_fcurs
    if (true) { // user-defined insert condition
        bool success = ind_fcurs_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fcurs"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.cdflt.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCdflt& amc::cdflt_Alloc() {
    amc::FCdflt* row = cdflt_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cdflt  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cdflt.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCdflt* amc::cdflt_AllocMaybe() {
    amc::FCdflt *row = (amc::FCdflt*)cdflt_AllocMem();
    if (row) {
        new (row) amc::FCdflt; // call constructor
    }
    return row;
}

// --- amc.FDb.cdflt.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCdflt* amc::cdflt_InsertMaybe(const dmmeta::Cdflt &value) {
    amc::FCdflt *row = &cdflt_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cdflt_CopyIn(*row,const_cast<dmmeta::Cdflt&>(value));
    bool ok = cdflt_XrefMaybe(*row); // this may return false
    if (!ok) {
        cdflt_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cdflt.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cdflt_AllocMem() {
    u64 new_nelems     = _db.cdflt_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCdflt*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cdflt_lary[bsr];
        if (!lev) {
            lev=(amc::FCdflt*)amc::lpool_AllocMem(sizeof(amc::FCdflt) * (u64(1)<<bsr));
            _db.cdflt_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cdflt_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cdflt.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cdflt_RemoveLast() {
    u64 n = _db.cdflt_n;
    if (n > 0) {
        n -= 1;
        cdflt_qFind(u64(n)).~FCdflt();
        _db.cdflt_n = i32(n);
    }
}

// --- amc.FDb.cdflt.InputMaybe
static bool amc::cdflt_InputMaybe(dmmeta::Cdflt &elem) {
    bool retval = true;
    retval = cdflt_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cdflt.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cdflt_XrefMaybe(amc::FCdflt &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert cdflt into index c_cdflt
    if (true) { // user-defined insert condition
        bool success = c_cdflt_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_cdflt"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.argvtype.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FArgvtype& amc::argvtype_Alloc() {
    amc::FArgvtype* row = argvtype_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.argvtype  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.argvtype.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FArgvtype* amc::argvtype_AllocMaybe() {
    amc::FArgvtype *row = (amc::FArgvtype*)argvtype_AllocMem();
    if (row) {
        new (row) amc::FArgvtype; // call constructor
    }
    return row;
}

// --- amc.FDb.argvtype.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FArgvtype* amc::argvtype_InsertMaybe(const dmmeta::Argvtype &value) {
    amc::FArgvtype *row = &argvtype_Alloc(); // if out of memory, process dies. if input error, return NULL.
    argvtype_CopyIn(*row,const_cast<dmmeta::Argvtype&>(value));
    bool ok = argvtype_XrefMaybe(*row); // this may return false
    if (!ok) {
        argvtype_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.argvtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::argvtype_AllocMem() {
    u64 new_nelems     = _db.argvtype_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FArgvtype*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.argvtype_lary[bsr];
        if (!lev) {
            lev=(amc::FArgvtype*)amc::lpool_AllocMem(sizeof(amc::FArgvtype) * (u64(1)<<bsr));
            _db.argvtype_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.argvtype_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.argvtype.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::argvtype_RemoveLast() {
    u64 n = _db.argvtype_n;
    if (n > 0) {
        n -= 1;
        argvtype_qFind(u64(n)).~FArgvtype();
        _db.argvtype_n = i32(n);
    }
}

// --- amc.FDb.argvtype.InputMaybe
static bool amc::argvtype_InputMaybe(dmmeta::Argvtype &elem) {
    bool retval = true;
    retval = argvtype_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.argvtype.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::argvtype_XrefMaybe(amc::FArgvtype &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert argvtype into index c_argvtype
    if (true) { // user-defined insert condition
        bool success = c_argvtype_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_argvtype"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fcmdline.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmdline& amc::fcmdline_Alloc() {
    amc::FFcmdline* row = fcmdline_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcmdline  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcmdline.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmdline* amc::fcmdline_AllocMaybe() {
    amc::FFcmdline *row = (amc::FFcmdline*)fcmdline_AllocMem();
    if (row) {
        new (row) amc::FFcmdline; // call constructor
    }
    return row;
}

// --- amc.FDb.fcmdline.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmdline* amc::fcmdline_InsertMaybe(const dmmeta::Fcmdline &value) {
    amc::FFcmdline *row = &fcmdline_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcmdline_CopyIn(*row,const_cast<dmmeta::Fcmdline&>(value));
    bool ok = fcmdline_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcmdline_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcmdline.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcmdline_AllocMem() {
    u64 new_nelems     = _db.fcmdline_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcmdline*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcmdline_lary[bsr];
        if (!lev) {
            lev=(amc::FFcmdline*)amc::lpool_AllocMem(sizeof(amc::FFcmdline) * (u64(1)<<bsr));
            _db.fcmdline_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcmdline_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcmdline.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcmdline_RemoveLast() {
    u64 n = _db.fcmdline_n;
    if (n > 0) {
        n -= 1;
        fcmdline_qFind(u64(n)).~FFcmdline();
        _db.fcmdline_n = i32(n);
    }
}

// --- amc.FDb.fcmdline.InputMaybe
static bool amc::fcmdline_InputMaybe(dmmeta::Fcmdline &elem) {
    bool retval = true;
    retval = fcmdline_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcmdline.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcmdline_XrefMaybe(amc::FFcmdline &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // fcmdline: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FNs* p_p_ns = p_ns_Get(row);
    if (UNLIKELY(!p_p_ns)) {
        algo_lib::ResetErrtext() << "amc.null_ref  xref:amc.FNs.c_fcmdline";
        return false;
    }
    // insert fcmdline into index c_fcmdline
    if (true) { // user-defined insert condition
        bool success = c_fcmdline_InsertMaybe(*p_p_ns, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_fcmdline"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_main.Find
// Find row by key. Return NULL if not found.
amc::FMain* amc::ind_main_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr16_Hash(0, key) & (_db.ind_main_buckets_n - 1);
    amc::FMain* *e = &_db.ind_main_buckets_elems[index];
    amc::FMain* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).ns == key;
        if (done) break;
        e         = &ret->ind_main_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_main.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FMain& amc::ind_main_GetOrCreate(const algo::strptr& key) {
    amc::FMain* ret = ind_main_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &main_Alloc();
        (*ret).ns = key;
        bool good = main_XrefMaybe(*ret);
        if (!good) {
            main_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_main  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_main.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_main_InsertMaybe(amc::FMain& row) {
    ind_main_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_main_next == (amc::FMain*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_main_buckets_n - 1);
        amc::FMain* *prev = &_db.ind_main_buckets_elems[index];
        do {
            amc::FMain* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).ns == row.ns) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_main_next;
        } while (true);
        if (retval) {
            row.ind_main_next = *prev;
            _db.ind_main_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_main.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_main_Remove(amc::FMain& row) {
    if (LIKELY(row.ind_main_next != (amc::FMain*)-1)) {// check if in hash already
        u32 index = algo::Smallstr16_Hash(0, row.ns) & (_db.ind_main_buckets_n - 1);
        amc::FMain* *prev = &_db.ind_main_buckets_elems[index]; // addr of pointer to current element
        while (amc::FMain *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_main_next; // unlink (singly linked list)
                _db.ind_main_n--;
                row.ind_main_next = (amc::FMain*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_main_next;
        }
    }
}

// --- amc.FDb.ind_main.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_main_Reserve(int n) {
    u32 old_nbuckets = _db.ind_main_buckets_n;
    u32 new_nelems   = _db.ind_main_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FMain*);
        u32 new_size = new_nbuckets * sizeof(amc::FMain*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FMain* *new_buckets = (amc::FMain**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_main");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_main_buckets_n; i++) {
            amc::FMain* elem = _db.ind_main_buckets_elems[i];
            while (elem) {
                amc::FMain &row        = *elem;
                amc::FMain* next       = row.ind_main_next;
                u32 index          = algo::Smallstr16_Hash(0, row.ns) & (new_nbuckets-1);
                row.ind_main_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_main_buckets_elems, old_size);
        _db.ind_main_buckets_elems = new_buckets;
        _db.ind_main_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.floadtuples.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFloadtuples& amc::floadtuples_Alloc() {
    amc::FFloadtuples* row = floadtuples_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.floadtuples  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.floadtuples.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFloadtuples* amc::floadtuples_AllocMaybe() {
    amc::FFloadtuples *row = (amc::FFloadtuples*)floadtuples_AllocMem();
    if (row) {
        new (row) amc::FFloadtuples; // call constructor
    }
    return row;
}

// --- amc.FDb.floadtuples.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFloadtuples* amc::floadtuples_InsertMaybe(const dmmeta::Floadtuples &value) {
    amc::FFloadtuples *row = &floadtuples_Alloc(); // if out of memory, process dies. if input error, return NULL.
    floadtuples_CopyIn(*row,const_cast<dmmeta::Floadtuples&>(value));
    bool ok = floadtuples_XrefMaybe(*row); // this may return false
    if (!ok) {
        floadtuples_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.floadtuples.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::floadtuples_AllocMem() {
    u64 new_nelems     = _db.floadtuples_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFloadtuples*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.floadtuples_lary[bsr];
        if (!lev) {
            lev=(amc::FFloadtuples*)amc::lpool_AllocMem(sizeof(amc::FFloadtuples) * (u64(1)<<bsr));
            _db.floadtuples_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.floadtuples_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.floadtuples.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::floadtuples_RemoveLast() {
    u64 n = _db.floadtuples_n;
    if (n > 0) {
        n -= 1;
        floadtuples_qFind(u64(n)).~FFloadtuples();
        _db.floadtuples_n = i32(n);
    }
}

// --- amc.FDb.floadtuples.InputMaybe
static bool amc::floadtuples_InputMaybe(dmmeta::Floadtuples &elem) {
    bool retval = true;
    retval = floadtuples_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.floadtuples.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::floadtuples_XrefMaybe(amc::FFloadtuples &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // floadtuples: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", ctype_Get(row));
        return false;
    }
    // insert floadtuples into index c_floadtuples
    if (true) { // user-defined insert condition
        bool success = c_floadtuples_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_floadtuples"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fcmap.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmap& amc::fcmap_Alloc() {
    amc::FFcmap* row = fcmap_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fcmap  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fcmap.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmap* amc::fcmap_AllocMaybe() {
    amc::FFcmap *row = (amc::FFcmap*)fcmap_AllocMem();
    if (row) {
        new (row) amc::FFcmap; // call constructor
    }
    return row;
}

// --- amc.FDb.fcmap.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmap* amc::fcmap_InsertMaybe(const dmmeta::Fcmap &value) {
    amc::FFcmap *row = &fcmap_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fcmap_CopyIn(*row,const_cast<dmmeta::Fcmap&>(value));
    bool ok = fcmap_XrefMaybe(*row); // this may return false
    if (!ok) {
        fcmap_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fcmap.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fcmap_AllocMem() {
    u64 new_nelems     = _db.fcmap_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFcmap*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fcmap_lary[bsr];
        if (!lev) {
            lev=(amc::FFcmap*)amc::lpool_AllocMem(sizeof(amc::FFcmap) * (u64(1)<<bsr));
            _db.fcmap_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fcmap_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fcmap.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fcmap_RemoveLast() {
    u64 n = _db.fcmap_n;
    if (n > 0) {
        n -= 1;
        fcmap_qFind(u64(n)).~FFcmap();
        _db.fcmap_n = i32(n);
    }
}

// --- amc.FDb.fcmap.InputMaybe
static bool amc::fcmap_InputMaybe(dmmeta::Fcmap &elem) {
    bool retval = true;
    retval = fcmap_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fcmap.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fcmap_XrefMaybe(amc::FFcmap &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_leftField = amc::ind_field_Find(leftField_Get(row));
    if (UNLIKELY(!p_leftField)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", leftField_Get(row));
        return false;
    }
    // fcmap: save pointer to leftField
    if (true) { // user-defined insert condition
        row.p_leftField = p_leftField;
    }
    amc::FField* p_rightField = amc::ind_field_Find(rightField_Get(row));
    if (UNLIKELY(!p_rightField)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", rightField_Get(row));
        return false;
    }
    // fcmap: save pointer to rightField
    if (true) { // user-defined insert condition
        row.p_rightField = p_rightField;
    }
    amc::FField* p_p_leftField = row.p_leftField;
    if (UNLIKELY(!p_p_leftField)) {
        algo_lib::ResetErrtext() << "amc.null_ref  xref:amc.FField.zs_fcmap";
        return false;
    }
    // insert fcmap into index zs_fcmap
    if (true) { // user-defined insert condition
        zs_fcmap_Insert(*p_p_leftField, row);
    }
    // insert fcmap into index ind_fcmap
    if (true) { // user-defined insert condition
        bool success = ind_fcmap_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_fcmap"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.zs_ordkeyfield.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_ordkeyfield_Insert(amc::FField& row) {
    if (!zs_ordkeyfield_InLlistQ(row)) {
        amc::FField* old_tail       = _db.zs_ordkeyfield_tail;
        row.zs_ordkeyfield_next  = NULL;
        _db.zs_ordkeyfield_tail = &row;
        amc::FField **new_row_a = &old_tail->zs_ordkeyfield_next;
        amc::FField **new_row_b = &_db.zs_ordkeyfield_head;
        amc::FField **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FDb.zs_ordkeyfield.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_ordkeyfield_Remove(amc::FField& row) {
    if (zs_ordkeyfield_InLlistQ(row)) {
        amc::FField* old_head       = _db.zs_ordkeyfield_head;
        (void)old_head; // in case it's not used
        amc::FField* prev=NULL;
        amc::FField* cur     = _db.zs_ordkeyfield_head;
        while (cur) {  // search for element by pointer
            amc::FField* next = cur->zs_ordkeyfield_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_ordkeyfield_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_ordkeyfield_next = next;
                } else {
                    _db.zs_ordkeyfield_head = next;
                }
                row.zs_ordkeyfield_next = (amc::FField*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FDb.zs_ordkeyfield.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_ordkeyfield_RemoveAll() {
    amc::FField* row = _db.zs_ordkeyfield_head;
    _db.zs_ordkeyfield_head = NULL;
    _db.zs_ordkeyfield_tail = NULL;
    while (row) {
        amc::FField* row_next = row->zs_ordkeyfield_next;
        row->zs_ordkeyfield_next  = (amc::FField*)-1;
        row = row_next;
    }
}

// --- amc.FDb.zs_ordkeyfield.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField* amc::zs_ordkeyfield_RemoveFirst() {
    amc::FField *row = NULL;
    row = _db.zs_ordkeyfield_head;
    if (row) {
        amc::FField *next = row->zs_ordkeyfield_next;
        _db.zs_ordkeyfield_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_ordkeyfield_tail = NULL;
        }
        row->zs_ordkeyfield_next = (amc::FField*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.nsproto.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsproto& amc::nsproto_Alloc() {
    amc::FNsproto* row = nsproto_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nsproto  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nsproto.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsproto* amc::nsproto_AllocMaybe() {
    amc::FNsproto *row = (amc::FNsproto*)nsproto_AllocMem();
    if (row) {
        new (row) amc::FNsproto; // call constructor
    }
    return row;
}

// --- amc.FDb.nsproto.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsproto* amc::nsproto_InsertMaybe(const dmmeta::Nsproto &value) {
    amc::FNsproto *row = &nsproto_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nsproto_CopyIn(*row,const_cast<dmmeta::Nsproto&>(value));
    bool ok = nsproto_XrefMaybe(*row); // this may return false
    if (!ok) {
        nsproto_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nsproto.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nsproto_AllocMem() {
    u64 new_nelems     = _db.nsproto_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNsproto*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nsproto_lary[bsr];
        if (!lev) {
            lev=(amc::FNsproto*)amc::lpool_AllocMem(sizeof(amc::FNsproto) * (u64(1)<<bsr));
            _db.nsproto_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nsproto_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nsproto.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nsproto_RemoveLast() {
    u64 n = _db.nsproto_n;
    if (n > 0) {
        n -= 1;
        nsproto_qFind(u64(n)).~FNsproto();
        _db.nsproto_n = i32(n);
    }
}

// --- amc.FDb.nsproto.InputMaybe
static bool amc::nsproto_InputMaybe(dmmeta::Nsproto &elem) {
    bool retval = true;
    retval = nsproto_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nsproto.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nsproto_XrefMaybe(amc::FNsproto &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", row.ns);
        return false;
    }
    // insert nsproto into index c_nsproto
    if (true) { // user-defined insert condition
        bool success = c_nsproto_InsertMaybe(*p_ns, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_nsproto"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.nsdb.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsdb& amc::nsdb_Alloc() {
    amc::FNsdb* row = nsdb_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nsdb  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nsdb.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsdb* amc::nsdb_AllocMaybe() {
    amc::FNsdb *row = (amc::FNsdb*)nsdb_AllocMem();
    if (row) {
        new (row) amc::FNsdb; // call constructor
    }
    return row;
}

// --- amc.FDb.nsdb.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsdb* amc::nsdb_InsertMaybe(const dmmeta::Nsdb &value) {
    amc::FNsdb *row = &nsdb_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nsdb_CopyIn(*row,const_cast<dmmeta::Nsdb&>(value));
    bool ok = nsdb_XrefMaybe(*row); // this may return false
    if (!ok) {
        nsdb_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nsdb.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nsdb_AllocMem() {
    u64 new_nelems     = _db.nsdb_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNsdb*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nsdb_lary[bsr];
        if (!lev) {
            lev=(amc::FNsdb*)amc::lpool_AllocMem(sizeof(amc::FNsdb) * (u64(1)<<bsr));
            _db.nsdb_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nsdb_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nsdb.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nsdb_RemoveLast() {
    u64 n = _db.nsdb_n;
    if (n > 0) {
        n -= 1;
        nsdb_qFind(u64(n)).~FNsdb();
        _db.nsdb_n = i32(n);
    }
}

// --- amc.FDb.nsdb.InputMaybe
static bool amc::nsdb_InputMaybe(dmmeta::Nsdb &elem) {
    bool retval = true;
    retval = nsdb_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nsdb.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nsdb_XrefMaybe(amc::FNsdb &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", row.ns);
        return false;
    }
    // insert nsdb into index c_nsdb
    if (true) { // user-defined insert condition
        bool success = c_nsdb_InsertMaybe(*p_ns, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FNs.c_nsdb"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.zd_substr_params.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zd_substr_params_Insert(amc::FSubstr& row) {
    if (!zd_substr_params_InLlistQ(row)) {
        amc::FSubstr* old_tail = _db.zd_substr_params_tail;
        row.zd_substr_params_next = NULL;
        row.zd_substr_params_prev = old_tail;
        _db.zd_substr_params_tail = &row;
        amc::FSubstr **new_row_a = &old_tail->zd_substr_params_next;
        amc::FSubstr **new_row_b = &_db.zd_substr_params_head;
        amc::FSubstr **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        _db.zd_substr_params_n++;
    }
}

// --- amc.FDb.zd_substr_params.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::zd_substr_params_Remove(amc::FSubstr& row) {
    if (zd_substr_params_InLlistQ(row)) {
        amc::FSubstr* old_head       = _db.zd_substr_params_head;
        (void)old_head; // in case it's not used
        amc::FSubstr* prev = row.zd_substr_params_prev;
        amc::FSubstr* next = row.zd_substr_params_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        amc::FSubstr **new_next_a = &prev->zd_substr_params_next;
        amc::FSubstr **new_next_b = &_db.zd_substr_params_head;
        amc::FSubstr **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        amc::FSubstr **new_prev_a = &next->zd_substr_params_prev;
        amc::FSubstr **new_prev_b = &_db.zd_substr_params_tail;
        amc::FSubstr **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        _db.zd_substr_params_n--;
        row.zd_substr_params_next=(amc::FSubstr*)-1; // not-in-list
    }
}

// --- amc.FDb.zd_substr_params.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zd_substr_params_RemoveAll() {
    amc::FSubstr* row = _db.zd_substr_params_head;
    _db.zd_substr_params_head = NULL;
    _db.zd_substr_params_tail = NULL;
    _db.zd_substr_params_n = 0;
    while (row) {
        amc::FSubstr* row_next = row->zd_substr_params_next;
        row->zd_substr_params_next  = (amc::FSubstr*)-1;
        row->zd_substr_params_prev  = NULL;
        row = row_next;
    }
}

// --- amc.FDb.zd_substr_params.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FSubstr* amc::zd_substr_params_RemoveFirst() {
    amc::FSubstr *row = NULL;
    row = _db.zd_substr_params_head;
    if (row) {
        amc::FSubstr *next = row->zd_substr_params_next;
        _db.zd_substr_params_head = next;
        amc::FSubstr **new_end_a = &next->zd_substr_params_prev;
        amc::FSubstr **new_end_b = &_db.zd_substr_params_tail;
        amc::FSubstr **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        _db.zd_substr_params_n--;
        row->zd_substr_params_next = (amc::FSubstr*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.ind_fconst_int.Find
// Find row by key. Return NULL if not found.
amc::FFconst* amc::ind_fconst_int_Find(const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (_db.ind_fconst_int_buckets_n - 1);
    amc::FFconst* *e = &_db.ind_fconst_int_buckets_elems[index];
    amc::FFconst* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).cpp_value == key;
        if (done) break;
        e         = &ret->ind_fconst_int_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fconst_int.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fconst_int_InsertMaybe(amc::FFconst& row) {
    ind_fconst_int_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fconst_int_next == (amc::FFconst*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.cpp_value) & (_db.ind_fconst_int_buckets_n - 1);
        amc::FFconst* *prev = &_db.ind_fconst_int_buckets_elems[index];
        do {
            amc::FFconst* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).cpp_value == row.cpp_value) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fconst_int_next;
        } while (true);
        if (retval) {
            row.ind_fconst_int_next = *prev;
            _db.ind_fconst_int_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fconst_int.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fconst_int_Remove(amc::FFconst& row) {
    if (LIKELY(row.ind_fconst_int_next != (amc::FFconst*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.cpp_value) & (_db.ind_fconst_int_buckets_n - 1);
        amc::FFconst* *prev = &_db.ind_fconst_int_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFconst *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fconst_int_next; // unlink (singly linked list)
                _db.ind_fconst_int_n--;
                row.ind_fconst_int_next = (amc::FFconst*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fconst_int_next;
        }
    }
}

// --- amc.FDb.ind_fconst_int.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fconst_int_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fconst_int_buckets_n;
    u32 new_nelems   = _db.ind_fconst_int_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFconst*);
        u32 new_size = new_nbuckets * sizeof(amc::FFconst*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFconst* *new_buckets = (amc::FFconst**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fconst_int");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fconst_int_buckets_n; i++) {
            amc::FFconst* elem = _db.ind_fconst_int_buckets_elems[i];
            while (elem) {
                amc::FFconst &row        = *elem;
                amc::FFconst* next       = row.ind_fconst_int_next;
                u32 index          = algo::cstring_Hash(0, row.cpp_value) & (new_nbuckets-1);
                row.ind_fconst_int_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fconst_int_buckets_elems, old_size);
        _db.ind_fconst_int_buckets_elems = new_buckets;
        _db.ind_fconst_int_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.fprefix.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFprefix& amc::fprefix_Alloc() {
    amc::FFprefix* row = fprefix_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fprefix  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fprefix.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFprefix* amc::fprefix_AllocMaybe() {
    amc::FFprefix *row = (amc::FFprefix*)fprefix_AllocMem();
    if (row) {
        new (row) amc::FFprefix; // call constructor
    }
    return row;
}

// --- amc.FDb.fprefix.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFprefix* amc::fprefix_InsertMaybe(const dmmeta::Fprefix &value) {
    amc::FFprefix *row = &fprefix_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fprefix_CopyIn(*row,const_cast<dmmeta::Fprefix&>(value));
    bool ok = fprefix_XrefMaybe(*row); // this may return false
    if (!ok) {
        fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fprefix.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fprefix_AllocMem() {
    u64 new_nelems     = _db.fprefix_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFprefix*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fprefix_lary[bsr];
        if (!lev) {
            lev=(amc::FFprefix*)amc::lpool_AllocMem(sizeof(amc::FFprefix) * (u64(1)<<bsr));
            _db.fprefix_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fprefix_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fprefix.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fprefix_RemoveLast() {
    u64 n = _db.fprefix_n;
    if (n > 0) {
        n -= 1;
        fprefix_qFind(u64(n)).~FFprefix();
        _db.fprefix_n = i32(n);
    }
}

// --- amc.FDb.fprefix.InputMaybe
static bool amc::fprefix_InputMaybe(dmmeta::Fprefix &elem) {
    bool retval = true;
    retval = fprefix_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fprefix.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fprefix_XrefMaybe(amc::FFprefix &row) {
    bool retval = true;
    (void)row;
    amc::FReftype* p_reftype = amc::ind_reftype_Find(row.reftype);
    if (UNLIKELY(!p_reftype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_reftype" << Keyval("key", row.reftype);
        return false;
    }
    // insert fprefix into index zs_fprefix
    if (true) { // user-defined insert condition
        zs_fprefix_Insert(*p_reftype, row);
    }
    // insert fprefix into index ind_prefix
    if (true) { // user-defined insert condition
        bool success = ind_prefix_InsertMaybe(row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FDb.ind_prefix"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_prefix.Find
// Find row by key. Return NULL if not found.
amc::FFprefix* amc::ind_prefix_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr5_Hash(0, key) & (_db.ind_prefix_buckets_n - 1);
    amc::FFprefix* *e = &_db.ind_prefix_buckets_elems[index];
    amc::FFprefix* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fprefix == key;
        if (done) break;
        e         = &ret->ind_prefix_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_prefix.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFprefix& amc::ind_prefix_GetOrCreate(const algo::strptr& key) {
    amc::FFprefix* ret = ind_prefix_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fprefix_Alloc();
        (*ret).fprefix = key;
        bool good = fprefix_XrefMaybe(*ret);
        if (!good) {
            fprefix_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_prefix  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_prefix.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_prefix_InsertMaybe(amc::FFprefix& row) {
    ind_prefix_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_prefix_next == (amc::FFprefix*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.fprefix) & (_db.ind_prefix_buckets_n - 1);
        amc::FFprefix* *prev = &_db.ind_prefix_buckets_elems[index];
        do {
            amc::FFprefix* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fprefix == row.fprefix) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_prefix_next;
        } while (true);
        if (retval) {
            row.ind_prefix_next = *prev;
            _db.ind_prefix_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_prefix.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_prefix_Remove(amc::FFprefix& row) {
    if (LIKELY(row.ind_prefix_next != (amc::FFprefix*)-1)) {// check if in hash already
        u32 index = algo::Smallstr5_Hash(0, row.fprefix) & (_db.ind_prefix_buckets_n - 1);
        amc::FFprefix* *prev = &_db.ind_prefix_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFprefix *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_prefix_next; // unlink (singly linked list)
                _db.ind_prefix_n--;
                row.ind_prefix_next = (amc::FFprefix*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_prefix_next;
        }
    }
}

// --- amc.FDb.ind_prefix.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_prefix_Reserve(int n) {
    u32 old_nbuckets = _db.ind_prefix_buckets_n;
    u32 new_nelems   = _db.ind_prefix_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFprefix*);
        u32 new_size = new_nbuckets * sizeof(amc::FFprefix*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFprefix* *new_buckets = (amc::FFprefix**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_prefix");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_prefix_buckets_n; i++) {
            amc::FFprefix* elem = _db.ind_prefix_buckets_elems[i];
            while (elem) {
                amc::FFprefix &row        = *elem;
                amc::FFprefix* next       = row.ind_prefix_next;
                u32 index          = algo::Smallstr5_Hash(0, row.fprefix) & (new_nbuckets-1);
                row.ind_prefix_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_prefix_buckets_elems, old_size);
        _db.ind_prefix_buckets_elems = new_buckets;
        _db.ind_prefix_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.ftrace.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFtrace& amc::ftrace_Alloc() {
    amc::FFtrace* row = ftrace_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ftrace  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ftrace.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFtrace* amc::ftrace_AllocMaybe() {
    amc::FFtrace *row = (amc::FFtrace*)ftrace_AllocMem();
    if (row) {
        new (row) amc::FFtrace; // call constructor
    }
    return row;
}

// --- amc.FDb.ftrace.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFtrace* amc::ftrace_InsertMaybe(const dmmeta::Ftrace &value) {
    amc::FFtrace *row = &ftrace_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ftrace_CopyIn(*row,const_cast<dmmeta::Ftrace&>(value));
    bool ok = ftrace_XrefMaybe(*row); // this may return false
    if (!ok) {
        ftrace_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ftrace.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ftrace_AllocMem() {
    u64 new_nelems     = _db.ftrace_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFtrace*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ftrace_lary[bsr];
        if (!lev) {
            lev=(amc::FFtrace*)amc::lpool_AllocMem(sizeof(amc::FFtrace) * (u64(1)<<bsr));
            _db.ftrace_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ftrace_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ftrace.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ftrace_RemoveLast() {
    u64 n = _db.ftrace_n;
    if (n > 0) {
        n -= 1;
        ftrace_qFind(u64(n)).~FFtrace();
        _db.ftrace_n = i32(n);
    }
}

// --- amc.FDb.ftrace.InputMaybe
static bool amc::ftrace_InputMaybe(dmmeta::Ftrace &elem) {
    bool retval = true;
    retval = ftrace_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ftrace.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ftrace_XrefMaybe(amc::FFtrace &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert ftrace into index c_ftrace
    if (true) { // user-defined insert condition
        bool success = c_ftrace_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_ftrace"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fnoremove.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFnoremove& amc::fnoremove_Alloc() {
    amc::FFnoremove* row = fnoremove_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fnoremove  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fnoremove.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFnoremove* amc::fnoremove_AllocMaybe() {
    amc::FFnoremove *row = (amc::FFnoremove*)fnoremove_AllocMem();
    if (row) {
        new (row) amc::FFnoremove; // call constructor
    }
    return row;
}

// --- amc.FDb.fnoremove.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFnoremove* amc::fnoremove_InsertMaybe(const dmmeta::Fnoremove &value) {
    amc::FFnoremove *row = &fnoremove_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fnoremove_CopyIn(*row,const_cast<dmmeta::Fnoremove&>(value));
    bool ok = fnoremove_XrefMaybe(*row); // this may return false
    if (!ok) {
        fnoremove_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fnoremove.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fnoremove_AllocMem() {
    u64 new_nelems     = _db.fnoremove_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFnoremove*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fnoremove_lary[bsr];
        if (!lev) {
            lev=(amc::FFnoremove*)amc::lpool_AllocMem(sizeof(amc::FFnoremove) * (u64(1)<<bsr));
            _db.fnoremove_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fnoremove_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fnoremove.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fnoremove_RemoveLast() {
    u64 n = _db.fnoremove_n;
    if (n > 0) {
        n -= 1;
        fnoremove_qFind(u64(n)).~FFnoremove();
        _db.fnoremove_n = i32(n);
    }
}

// --- amc.FDb.fnoremove.InputMaybe
static bool amc::fnoremove_InputMaybe(dmmeta::Fnoremove &elem) {
    bool retval = true;
    retval = fnoremove_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fnoremove.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fnoremove_XrefMaybe(amc::FFnoremove &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fnoremove into index c_fnoremove
    if (true) { // user-defined insert condition
        bool success = c_fnoremove_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fnoremove"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.c_substr_field.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_substr_field_Insert(amc::FSubstr& row) {
    if (bool_Update(row._db_c_substr_field_in_ary,true)) {
        // reserve space
        c_substr_field_Reserve(1);
        u32 n  = _db.c_substr_field_n;
        u32 at = n;
        amc::FSubstr* *elems = _db.c_substr_field_elems;
        elems[at] = &row;
        _db.c_substr_field_n = n+1;

    }
}

// --- amc.FDb.c_substr_field.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_substr_field_InsertMaybe(amc::FSubstr& row) {
    bool retval = !row._db_c_substr_field_in_ary;
    c_substr_field_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- amc.FDb.c_substr_field.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_substr_field_Remove(amc::FSubstr& row) {
    if (bool_Update(row._db_c_substr_field_in_ary,false)) {
        int lim = _db.c_substr_field_n;
        amc::FSubstr* *elems = _db.c_substr_field_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FSubstr* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FSubstr*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_substr_field_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FDb.c_substr_field.Reserve
// Reserve space in index for N more elements;
void amc::c_substr_field_Reserve(u32 n) {
    u32 old_max = _db.c_substr_field_max;
    if (UNLIKELY(_db.c_substr_field_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FSubstr*);
        u32 new_size = new_max * sizeof(amc::FSubstr*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_substr_field_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_substr_field");
        }
        _db.c_substr_field_elems = (amc::FSubstr**)new_mem;
        _db.c_substr_field_max = new_max;
    }
}

// --- amc.FDb.c_substr_field.Swap
// Swap values elem_a and elem_b
inline static void amc::c_substr_field_Swap(amc::FSubstr* &elem_a, amc::FSubstr* &elem_b) {
    amc::FSubstr *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- amc.FDb.c_substr_field.Rotleft
// Left circular shift of three-tuple
inline static void amc::c_substr_field_Rotleft(amc::FSubstr* &elem_a, amc::FSubstr* &elem_b, amc::FSubstr* &elem_c) {
    amc::FSubstr *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- amc.FDb.c_substr_field.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool amc::c_substr_field_Lt(amc::FSubstr &elem_a, amc::FSubstr &elem_b) {
    bool ret;
    ret = elem_a.range < elem_b.range;
    return ret;
}

// --- amc.FDb.c_substr_field.SortedQ
// Verify whether array is sorted
bool amc::c_substr_field_SortedQ() {
    amc::FSubstr* *elems = c_substr_field_Getary().elems;
    int n = c_substr_field_N();
    for (int i = 1; i < n; i++) {
        if (c_substr_field_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- amc.FDb.c_substr_field.IntInsertionSort
// Internal insertion sort
static void amc::c_substr_field_IntInsertionSort(amc::FSubstr* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        amc::FSubstr *tmp = elems[i];
        // shift elements up by one
        if (c_substr_field_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_substr_field_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- amc.FDb.c_substr_field.IntHeapSort
// Internal heap sort
static void amc::c_substr_field_IntHeapSort(amc::FSubstr* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_substr_field_Lt(*elems[j], *elems[k])) {
            c_substr_field_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_substr_field_Lt(*elems[l], *elems[l+1]);
            if (c_substr_field_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_substr_field_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_substr_field_Swap(elems[i],elems[k]);
        }
    }
}

// --- amc.FDb.c_substr_field.IntQuickSort
// Quick sort engine
static void amc::c_substr_field_IntQuickSort(amc::FSubstr* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_substr_field_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_substr_field_Lt(*elems[pp], *elems[pi])) {
            c_substr_field_Swap(elems[pi], elems[pp]);
        }
        if (c_substr_field_Lt(*elems[pj], *elems[pp])) {
            if (c_substr_field_Lt(*elems[pj], *elems[pi])) {
                c_substr_field_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_substr_field_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_substr_field_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        amc::FSubstr *pivot = elems[pj];
        for(;;){
            while (c_substr_field_Lt(*elems[++pi], *pivot)) {
            }
            while (c_substr_field_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_substr_field_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_substr_field_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_substr_field_IntInsertionSort(elems,n);
}

// --- amc.FDb.c_substr_field.InsertionSort
// Insertion sort
void amc::c_substr_field_InsertionSort() {
    amc::FSubstr* *elems = c_substr_field_Getary().elems;
    int n = c_substr_field_N();
    c_substr_field_IntInsertionSort(elems, n);
}

// --- amc.FDb.c_substr_field.HeapSort
// Heap sort
void amc::c_substr_field_HeapSort() {
    amc::FSubstr* *elems = c_substr_field_Getary().elems;
    int n = c_substr_field_N();
    c_substr_field_IntHeapSort(elems, n);
}

// --- amc.FDb.c_substr_field.QuickSort
// Quick sort
void amc::c_substr_field_QuickSort() {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_substr_field_N() + 1)) + 3;
    amc::FSubstr* *elems = c_substr_field_Getary().elems;
    int n = c_substr_field_N();
    c_substr_field_IntQuickSort(elems, n, max_depth);
}

// --- amc.FDb.ctypelen.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCtypelen& amc::ctypelen_Alloc() {
    amc::FCtypelen* row = ctypelen_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ctypelen  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ctypelen.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCtypelen* amc::ctypelen_AllocMaybe() {
    amc::FCtypelen *row = (amc::FCtypelen*)ctypelen_AllocMem();
    if (row) {
        new (row) amc::FCtypelen; // call constructor
    }
    return row;
}

// --- amc.FDb.ctypelen.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCtypelen* amc::ctypelen_InsertMaybe(const dmmeta::Ctypelen &value) {
    amc::FCtypelen *row = &ctypelen_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ctypelen_CopyIn(*row,const_cast<dmmeta::Ctypelen&>(value));
    bool ok = ctypelen_XrefMaybe(*row); // this may return false
    if (!ok) {
        ctypelen_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ctypelen.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ctypelen_AllocMem() {
    u64 new_nelems     = _db.ctypelen_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCtypelen*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ctypelen_lary[bsr];
        if (!lev) {
            lev=(amc::FCtypelen*)amc::lpool_AllocMem(sizeof(amc::FCtypelen) * (u64(1)<<bsr));
            _db.ctypelen_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ctypelen_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ctypelen.RemoveAll
// Remove all elements from Lary
void amc::ctypelen_RemoveAll() {
    for (u64 n = _db.ctypelen_n; n>0; ) {
        n--;
        ctypelen_qFind(u64(n)).~FCtypelen(); // destroy last element
        _db.ctypelen_n = i32(n);
    }
}

// --- amc.FDb.ctypelen.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ctypelen_RemoveLast() {
    u64 n = _db.ctypelen_n;
    if (n > 0) {
        n -= 1;
        ctypelen_qFind(u64(n)).~FCtypelen();
        _db.ctypelen_n = i32(n);
    }
}

// --- amc.FDb.ctypelen.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ctypelen_XrefMaybe(amc::FCtypelen &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert ctypelen into index c_ctypelen
    if (true) { // user-defined insert condition
        bool success = c_ctypelen_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_ctypelen"; // check for duplicate key
            return false;
        }
    }
    // insert ctypelen into index c_ctypelen
    if (true) { // user-defined insert condition
        c_ctypelen_Insert(row);
    }
    return retval;
}

// --- amc.FDb.c_ctypelen.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ctypelen_Insert(amc::FCtypelen& row) {
    if (bool_Update(row._db_c_ctypelen_in_ary,true)) {
        // reserve space
        c_ctypelen_Reserve(1);
        u32 n  = _db.c_ctypelen_n;
        u32 at = n;
        amc::FCtypelen* *elems = _db.c_ctypelen_elems;
        elems[at] = &row;
        _db.c_ctypelen_n = n+1;

    }
}

// --- amc.FDb.c_ctypelen.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_ctypelen_InsertMaybe(amc::FCtypelen& row) {
    bool retval = !row._db_c_ctypelen_in_ary;
    c_ctypelen_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- amc.FDb.c_ctypelen.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ctypelen_Remove(amc::FCtypelen& row) {
    if (bool_Update(row._db_c_ctypelen_in_ary,false)) {
        int lim = _db.c_ctypelen_n;
        amc::FCtypelen* *elems = _db.c_ctypelen_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FCtypelen* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FCtypelen*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_ctypelen_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FDb.c_ctypelen.Reserve
// Reserve space in index for N more elements;
void amc::c_ctypelen_Reserve(u32 n) {
    u32 old_max = _db.c_ctypelen_max;
    if (UNLIKELY(_db.c_ctypelen_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FCtypelen*);
        u32 new_size = new_max * sizeof(amc::FCtypelen*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_ctypelen_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_ctypelen");
        }
        _db.c_ctypelen_elems = (amc::FCtypelen**)new_mem;
        _db.c_ctypelen_max = new_max;
    }
}

// --- amc.FDb.c_ctypelen.Swap
// Swap values elem_a and elem_b
inline static void amc::c_ctypelen_Swap(amc::FCtypelen* &elem_a, amc::FCtypelen* &elem_b) {
    amc::FCtypelen *temp = elem_a;
    elem_a = elem_b;
    elem_b = temp;
}

// --- amc.FDb.c_ctypelen.Rotleft
// Left circular shift of three-tuple
inline static void amc::c_ctypelen_Rotleft(amc::FCtypelen* &elem_a, amc::FCtypelen* &elem_b, amc::FCtypelen* &elem_c) {
    amc::FCtypelen *temp = elem_a;
    elem_a = elem_b;
    elem_b = elem_c;
    elem_c = temp;
}

// --- amc.FDb.c_ctypelen.Lt
// Compare values elem_a and elem_b
// The comparison function must be anti-symmetric: if a>b, then !(b>a).
// If not, mayhem results.
static bool amc::c_ctypelen_Lt(amc::FCtypelen &elem_a, amc::FCtypelen &elem_b) {
    bool ret;
    ret = elem_a.ctype < elem_b.ctype;
    return ret;
}

// --- amc.FDb.c_ctypelen.SortedQ
// Verify whether array is sorted
bool amc::c_ctypelen_SortedQ() {
    amc::FCtypelen* *elems = c_ctypelen_Getary().elems;
    int n = c_ctypelen_N();
    for (int i = 1; i < n; i++) {
        if (c_ctypelen_Lt(*elems[i], *elems[i-1])) {
            return false;
        }
    }
    return true;
}

// --- amc.FDb.c_ctypelen.IntInsertionSort
// Internal insertion sort
static void amc::c_ctypelen_IntInsertionSort(amc::FCtypelen* *elems, int n) {
    for (int i = 1; i < n; ++i) {
        int j = i;
        amc::FCtypelen *tmp = elems[i];
        // shift elements up by one
        if (c_ctypelen_Lt(*tmp, *elems[j-1])) {
            do {
                elems[j] = elems[j-1];
                j--;
            } while (j>0 && c_ctypelen_Lt(*tmp, *elems[j-1]));
            elems[j] = tmp;
        }
    }
}

// --- amc.FDb.c_ctypelen.IntHeapSort
// Internal heap sort
static void amc::c_ctypelen_IntHeapSort(amc::FCtypelen* *elems, int n) {
    // construct max-heap.
    // k=current element
    // j=parent element
    for (int i = 1; i < n; i++) {
        int k=i;
        int j=(i-1)/2;
        while (c_ctypelen_Lt(*elems[j], *elems[k])) {
            c_ctypelen_Swap(elems[k],elems[j]);
            k=j;
            j=(k-1)/2;
        }
    }
    // remove elements from heap one-by-one,
    // deposit them in reverse order starting at the end of ARY.
    for (int i = n - 1; i>=0; i--) {
        int k = 0;
        int l = 1;
        while (l<i) {
            l += l<i-1 && c_ctypelen_Lt(*elems[l], *elems[l+1]);
            if (c_ctypelen_Lt(*elems[l], *elems[i])) {
                break;
            }
            c_ctypelen_Swap(elems[k], elems[l]);
            k = l;
            l = k*2+1;
        }
        if (i != k) {
            c_ctypelen_Swap(elems[i],elems[k]);
        }
    }
}

// --- amc.FDb.c_ctypelen.IntQuickSort
// Quick sort engine
static void amc::c_ctypelen_IntQuickSort(amc::FCtypelen* *elems, int n, int depth) {
    while (n>16) {
        // detect degenerate case and revert to heap sort
        if (depth==0) {
            c_ctypelen_IntHeapSort(elems,n);
            return;
        }
        // elements to sort initially to determine pivot.
        // choose pp=n/2 in case the input is already sorted.
        int pi = 0;
        int pp = n/2;
        int pj = n-1;
        // insertion sort for 1st, middle and last element
        if (c_ctypelen_Lt(*elems[pp], *elems[pi])) {
            c_ctypelen_Swap(elems[pi], elems[pp]);
        }
        if (c_ctypelen_Lt(*elems[pj], *elems[pp])) {
            if (c_ctypelen_Lt(*elems[pj], *elems[pi])) {
                c_ctypelen_Rotleft(elems[pi], elems[pj], elems[pp]);
            } else {
                c_ctypelen_Swap(elems[pj], elems[pp]);
            }
        }
        // deposit pivot near the end of the array and skip it.
        c_ctypelen_Swap(elems[--pj], elems[pp]);
        // copy pivot into temporary variable
        amc::FCtypelen *pivot = elems[pj];
        for(;;){
            while (c_ctypelen_Lt(*elems[++pi], *pivot)) {
            }
            while (c_ctypelen_Lt(*pivot, *elems[--pj])) {
            }
            if (pj <= pi) {
                break;
            }
            c_ctypelen_Swap(elems[pi],elems[pj]);
        }
        depth -= 1;
        c_ctypelen_IntQuickSort(elems, pi, depth);
        elems += pi;
        n -= pi;
    }
    // sort the remainder of this section
    c_ctypelen_IntInsertionSort(elems,n);
}

// --- amc.FDb.c_ctypelen.InsertionSort
// Insertion sort
void amc::c_ctypelen_InsertionSort() {
    amc::FCtypelen* *elems = c_ctypelen_Getary().elems;
    int n = c_ctypelen_N();
    c_ctypelen_IntInsertionSort(elems, n);
}

// --- amc.FDb.c_ctypelen.HeapSort
// Heap sort
void amc::c_ctypelen_HeapSort() {
    amc::FCtypelen* *elems = c_ctypelen_Getary().elems;
    int n = c_ctypelen_N();
    c_ctypelen_IntHeapSort(elems, n);
}

// --- amc.FDb.c_ctypelen.QuickSort
// Quick sort
void amc::c_ctypelen_QuickSort() {
    // compute max recursion depth based on number of elements in the array
    int max_depth = algo::CeilingLog2(u32(c_ctypelen_N() + 1)) + 3;
    amc::FCtypelen* *elems = c_ctypelen_Getary().elems;
    int n = c_ctypelen_N();
    c_ctypelen_IntQuickSort(elems, n, max_depth);
}

// --- amc.FDb.c_ctypelen.SaveSsimfile
// Save table to ssimfile
bool amc::c_ctypelen_SaveSsimfile(algo::strptr fname) {
    cstring text;
    ind_beg(amc::_db_c_ctypelen_curs, c_ctypelen, amc::_db) {
        dmmeta::Ctypelen out;
        ctypelen_CopyOut(c_ctypelen, out);
        dmmeta::Ctypelen_Print(out, text);
        text << eol;
    }ind_end;
    (void)algo::CreateDirRecurse(algo::GetDirName(fname));
    // it is a silent error if the file cannot be saved.
    return algo::SafeStringToFile(text, fname);
}

// --- amc.FDb.c_tempfield.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_tempfield_Insert(amc::FField& row) {
    if (bool_Update(row._db_c_tempfield_in_ary,true)) {
        // reserve space
        c_tempfield_Reserve(1);
        u32 n  = _db.c_tempfield_n;
        u32 at = n;
        amc::FField* *elems = _db.c_tempfield_elems;
        elems[at] = &row;
        _db.c_tempfield_n = n+1;

    }
}

// --- amc.FDb.c_tempfield.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_tempfield_InsertMaybe(amc::FField& row) {
    bool retval = !row._db_c_tempfield_in_ary;
    c_tempfield_Insert(row); // check is performed in _Insert again
    return retval;
}

// --- amc.FDb.c_tempfield.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_tempfield_Remove(amc::FField& row) {
    if (bool_Update(row._db_c_tempfield_in_ary,false)) {
        int lim = _db.c_tempfield_n;
        amc::FField* *elems = _db.c_tempfield_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FField* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FField*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                _db.c_tempfield_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FDb.c_tempfield.Reserve
// Reserve space in index for N more elements;
void amc::c_tempfield_Reserve(u32 n) {
    u32 old_max = _db.c_tempfield_max;
    if (UNLIKELY(_db.c_tempfield_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FField*);
        u32 new_size = new_max * sizeof(amc::FField*);
        void *new_mem = amc::lpool_ReallocMem(_db.c_tempfield_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.c_tempfield");
        }
        _db.c_tempfield_elems = (amc::FField**)new_mem;
        _db.c_tempfield_max = new_max;
    }
}

// --- amc.FDb.fbase.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbase& amc::fbase_Alloc() {
    amc::FFbase* row = fbase_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fbase  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fbase.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbase* amc::fbase_AllocMaybe() {
    amc::FFbase *row = (amc::FFbase*)fbase_AllocMem();
    if (row) {
        new (row) amc::FFbase; // call constructor
    }
    return row;
}

// --- amc.FDb.fbase.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbase* amc::fbase_InsertMaybe(const dmmeta::Fbase &value) {
    amc::FFbase *row = &fbase_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fbase_CopyIn(*row,const_cast<dmmeta::Fbase&>(value));
    bool ok = fbase_XrefMaybe(*row); // this may return false
    if (!ok) {
        fbase_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fbase.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fbase_AllocMem() {
    u64 new_nelems     = _db.fbase_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFbase*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fbase_lary[bsr];
        if (!lev) {
            lev=(amc::FFbase*)amc::lpool_AllocMem(sizeof(amc::FFbase) * (u64(1)<<bsr));
            _db.fbase_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fbase_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fbase.RemoveAll
// Remove all elements from Lary
void amc::fbase_RemoveAll() {
    for (u64 n = _db.fbase_n; n>0; ) {
        n--;
        fbase_qFind(u64(n)).~FFbase(); // destroy last element
        _db.fbase_n = i32(n);
    }
}

// --- amc.FDb.fbase.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fbase_RemoveLast() {
    u64 n = _db.fbase_n;
    if (n > 0) {
        n -= 1;
        fbase_qFind(u64(n)).~FFbase();
        _db.fbase_n = i32(n);
    }
}

// --- amc.FDb.fbase.InputMaybe
static bool amc::fbase_InputMaybe(dmmeta::Fbase &elem) {
    bool retval = true;
    retval = fbase_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fbase.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fbase_XrefMaybe(amc::FFbase &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fbase into index c_fbase
    if (true) { // user-defined insert condition
        bool success = c_fbase_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fbase"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fcmap.Find
// Find row by key. Return NULL if not found.
amc::FFcmap* amc::ind_fcmap_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr250_Hash(0, key) & (_db.ind_fcmap_buckets_n - 1);
    amc::FFcmap* *e = &_db.ind_fcmap_buckets_elems[index];
    amc::FFcmap* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fcmap == key;
        if (done) break;
        e         = &ret->ind_fcmap_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fcmap.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFcmap& amc::ind_fcmap_GetOrCreate(const algo::strptr& key) {
    amc::FFcmap* ret = ind_fcmap_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fcmap_Alloc();
        (*ret).fcmap = key;
        bool good = fcmap_XrefMaybe(*ret);
        if (!good) {
            fcmap_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fcmap  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fcmap.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fcmap_InsertMaybe(amc::FFcmap& row) {
    ind_fcmap_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fcmap_next == (amc::FFcmap*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.fcmap) & (_db.ind_fcmap_buckets_n - 1);
        amc::FFcmap* *prev = &_db.ind_fcmap_buckets_elems[index];
        do {
            amc::FFcmap* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fcmap == row.fcmap) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fcmap_next;
        } while (true);
        if (retval) {
            row.ind_fcmap_next = *prev;
            _db.ind_fcmap_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fcmap.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fcmap_Remove(amc::FFcmap& row) {
    if (LIKELY(row.ind_fcmap_next != (amc::FFcmap*)-1)) {// check if in hash already
        u32 index = algo::Smallstr250_Hash(0, row.fcmap) & (_db.ind_fcmap_buckets_n - 1);
        amc::FFcmap* *prev = &_db.ind_fcmap_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFcmap *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fcmap_next; // unlink (singly linked list)
                _db.ind_fcmap_n--;
                row.ind_fcmap_next = (amc::FFcmap*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fcmap_next;
        }
    }
}

// --- amc.FDb.ind_fcmap.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fcmap_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fcmap_buckets_n;
    u32 new_nelems   = _db.ind_fcmap_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFcmap*);
        u32 new_size = new_nbuckets * sizeof(amc::FFcmap*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFcmap* *new_buckets = (amc::FFcmap**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fcmap");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fcmap_buckets_n; i++) {
            amc::FFcmap* elem = _db.ind_fcmap_buckets_elems[i];
            while (elem) {
                amc::FFcmap &row        = *elem;
                amc::FFcmap* next       = row.ind_fcmap_next;
                u32 index          = algo::Smallstr250_Hash(0, row.fcmap) & (new_nbuckets-1);
                row.ind_fcmap_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fcmap_buckets_elems, old_size);
        _db.ind_fcmap_buckets_elems = new_buckets;
        _db.ind_fcmap_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.nossimfile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNossimfile& amc::nossimfile_Alloc() {
    amc::FNossimfile* row = nossimfile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nossimfile  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nossimfile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNossimfile* amc::nossimfile_AllocMaybe() {
    amc::FNossimfile *row = (amc::FNossimfile*)nossimfile_AllocMem();
    if (row) {
        new (row) amc::FNossimfile; // call constructor
    }
    return row;
}

// --- amc.FDb.nossimfile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNossimfile* amc::nossimfile_InsertMaybe(const dmmeta::Nossimfile &value) {
    amc::FNossimfile *row = &nossimfile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nossimfile_CopyIn(*row,const_cast<dmmeta::Nossimfile&>(value));
    bool ok = nossimfile_XrefMaybe(*row); // this may return false
    if (!ok) {
        nossimfile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nossimfile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nossimfile_AllocMem() {
    u64 new_nelems     = _db.nossimfile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNossimfile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nossimfile_lary[bsr];
        if (!lev) {
            lev=(amc::FNossimfile*)amc::lpool_AllocMem(sizeof(amc::FNossimfile) * (u64(1)<<bsr));
            _db.nossimfile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nossimfile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nossimfile.RemoveAll
// Remove all elements from Lary
void amc::nossimfile_RemoveAll() {
    for (u64 n = _db.nossimfile_n; n>0; ) {
        n--;
        nossimfile_qFind(u64(n)).~FNossimfile(); // destroy last element
        _db.nossimfile_n = i32(n);
    }
}

// --- amc.FDb.nossimfile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nossimfile_RemoveLast() {
    u64 n = _db.nossimfile_n;
    if (n > 0) {
        n -= 1;
        nossimfile_qFind(u64(n)).~FNossimfile();
        _db.nossimfile_n = i32(n);
    }
}

// --- amc.FDb.nossimfile.InputMaybe
static bool amc::nossimfile_InputMaybe(dmmeta::Nossimfile &elem) {
    bool retval = true;
    retval = nossimfile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nossimfile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nossimfile_XrefMaybe(amc::FNossimfile &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // insert nossimfile into index c_nossimfile
    if (true) { // user-defined insert condition
        bool success = c_nossimfile_InsertMaybe(*p_ctype, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FCtype.c_nossimfile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.gsymbol.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGsymbol& amc::gsymbol_Alloc() {
    amc::FGsymbol* row = gsymbol_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.gsymbol  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.gsymbol.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FGsymbol* amc::gsymbol_AllocMaybe() {
    amc::FGsymbol *row = (amc::FGsymbol*)gsymbol_AllocMem();
    if (row) {
        new (row) amc::FGsymbol; // call constructor
    }
    return row;
}

// --- amc.FDb.gsymbol.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGsymbol* amc::gsymbol_InsertMaybe(const dmmeta::Gsymbol &value) {
    amc::FGsymbol *row = &gsymbol_Alloc(); // if out of memory, process dies. if input error, return NULL.
    gsymbol_CopyIn(*row,const_cast<dmmeta::Gsymbol&>(value));
    bool ok = gsymbol_XrefMaybe(*row); // this may return false
    if (!ok) {
        gsymbol_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.gsymbol.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::gsymbol_AllocMem() {
    u64 new_nelems     = _db.gsymbol_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FGsymbol*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.gsymbol_lary[bsr];
        if (!lev) {
            lev=(amc::FGsymbol*)amc::lpool_AllocMem(sizeof(amc::FGsymbol) * (u64(1)<<bsr));
            _db.gsymbol_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.gsymbol_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.gsymbol.RemoveAll
// Remove all elements from Lary
void amc::gsymbol_RemoveAll() {
    for (u64 n = _db.gsymbol_n; n>0; ) {
        n--;
        gsymbol_qFind(u64(n)).~FGsymbol(); // destroy last element
        _db.gsymbol_n = i32(n);
    }
}

// --- amc.FDb.gsymbol.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::gsymbol_RemoveLast() {
    u64 n = _db.gsymbol_n;
    if (n > 0) {
        n -= 1;
        gsymbol_qFind(u64(n)).~FGsymbol();
        _db.gsymbol_n = i32(n);
    }
}

// --- amc.FDb.gsymbol.InputMaybe
static bool amc::gsymbol_InputMaybe(dmmeta::Gsymbol &elem) {
    bool retval = true;
    retval = gsymbol_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.gsymbol.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::gsymbol_XrefMaybe(amc::FGsymbol &row) {
    bool retval = true;
    (void)row;
    amc::FSsimfile* p_ssimfile = amc::ind_ssimfile_Find(ssimfile_Get(row));
    if (UNLIKELY(!p_ssimfile)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ssimfile" << Keyval("key", ssimfile_Get(row));
        return false;
    }
    // gsymbol: save pointer to ssimfile
    if (true) { // user-defined insert condition
        row.p_ssimfile = p_ssimfile;
    }
    amc::FCtype* p_symboltype = amc::ind_ctype_Find(row.symboltype);
    if (UNLIKELY(!p_symboltype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.symboltype);
        return false;
    }
    // gsymbol: save pointer to symboltype
    if (true) { // user-defined insert condition
        row.p_symboltype = p_symboltype;
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert gsymbol into index c_gsymbol
    if (true) { // user-defined insert condition
        c_gsymbol_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.sortfld.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSortfld& amc::sortfld_Alloc() {
    amc::FSortfld* row = sortfld_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.sortfld  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.sortfld.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FSortfld* amc::sortfld_AllocMaybe() {
    amc::FSortfld *row = (amc::FSortfld*)sortfld_AllocMem();
    if (row) {
        new (row) amc::FSortfld; // call constructor
    }
    return row;
}

// --- amc.FDb.sortfld.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSortfld* amc::sortfld_InsertMaybe(const dmmeta::Sortfld &value) {
    amc::FSortfld *row = &sortfld_Alloc(); // if out of memory, process dies. if input error, return NULL.
    sortfld_CopyIn(*row,const_cast<dmmeta::Sortfld&>(value));
    bool ok = sortfld_XrefMaybe(*row); // this may return false
    if (!ok) {
        sortfld_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.sortfld.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::sortfld_AllocMem() {
    u64 new_nelems     = _db.sortfld_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FSortfld*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.sortfld_lary[bsr];
        if (!lev) {
            lev=(amc::FSortfld*)amc::lpool_AllocMem(sizeof(amc::FSortfld) * (u64(1)<<bsr));
            _db.sortfld_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.sortfld_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.sortfld.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::sortfld_RemoveLast() {
    u64 n = _db.sortfld_n;
    if (n > 0) {
        n -= 1;
        sortfld_qFind(u64(n)).~FSortfld();
        _db.sortfld_n = i32(n);
    }
}

// --- amc.FDb.sortfld.InputMaybe
static bool amc::sortfld_InputMaybe(dmmeta::Sortfld &elem) {
    bool retval = true;
    retval = sortfld_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.sortfld.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::sortfld_XrefMaybe(amc::FSortfld &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_sortfld = amc::ind_field_Find(row.sortfld);
    if (UNLIKELY(!p_sortfld)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.sortfld);
        return false;
    }
    // sortfld: save pointer to sortfld
    if (true) { // user-defined insert condition
        row.p_sortfld = p_sortfld;
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert sortfld into index c_sortfld
    if (true) { // user-defined insert condition
        bool success = c_sortfld_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_sortfld"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.cget.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCget& amc::cget_Alloc() {
    amc::FCget* row = cget_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.cget  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.cget.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCget* amc::cget_AllocMaybe() {
    amc::FCget *row = (amc::FCget*)cget_AllocMem();
    if (row) {
        new (row) amc::FCget; // call constructor
    }
    return row;
}

// --- amc.FDb.cget.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCget* amc::cget_InsertMaybe(const dmmeta::Cget &value) {
    amc::FCget *row = &cget_Alloc(); // if out of memory, process dies. if input error, return NULL.
    cget_CopyIn(*row,const_cast<dmmeta::Cget&>(value));
    bool ok = cget_XrefMaybe(*row); // this may return false
    if (!ok) {
        cget_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.cget.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::cget_AllocMem() {
    u64 new_nelems     = _db.cget_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCget*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.cget_lary[bsr];
        if (!lev) {
            lev=(amc::FCget*)amc::lpool_AllocMem(sizeof(amc::FCget) * (u64(1)<<bsr));
            _db.cget_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.cget_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.cget.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::cget_RemoveLast() {
    u64 n = _db.cget_n;
    if (n > 0) {
        n -= 1;
        cget_qFind(u64(n)).~FCget();
        _db.cget_n = i32(n);
    }
}

// --- amc.FDb.cget.InputMaybe
static bool amc::cget_InputMaybe(dmmeta::Cget &elem) {
    bool retval = true;
    retval = cget_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.cget.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::cget_XrefMaybe(amc::FCget &row) {
    bool retval = true;
    (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (UNLIKELY(!p_ctype)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ctype" << Keyval("key", row.ctype);
        return false;
    }
    // cget: save pointer to ctype
    if (true) { // user-defined insert condition
        row.p_ctype = p_ctype;
    }
    return retval;
}

// --- amc.FDb.cd_temp_func.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::cd_temp_func_Insert(amc::FFunc& row) {
    if (!cd_temp_func_InLlistQ(row)) {
        if (_db.cd_temp_func_head) {
            row.cd_temp_func_next = _db.cd_temp_func_head;
            row.cd_temp_func_prev = _db.cd_temp_func_head->cd_temp_func_prev;
            row.cd_temp_func_prev->cd_temp_func_next = &row;
            row.cd_temp_func_next->cd_temp_func_prev = &row;
        } else {
            row.cd_temp_func_next = &row;
            row.cd_temp_func_prev = &row;
            _db.cd_temp_func_head = &row;
        }
        _db.cd_temp_func_n++;
    }
}

// --- amc.FDb.cd_temp_func.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::cd_temp_func_Remove(amc::FFunc& row) {
    if (cd_temp_func_InLlistQ(row)) {
        amc::FFunc* old_head       = _db.cd_temp_func_head;
        (void)old_head; // in case it's not used
        amc::FFunc *oldnext = row.cd_temp_func_next;
        amc::FFunc *oldprev = row.cd_temp_func_prev;
        oldnext->cd_temp_func_prev = oldprev; // remove element from list
        oldprev->cd_temp_func_next = oldnext;
        _db.cd_temp_func_n--;  // adjust count
        if (&row == _db.cd_temp_func_head) {
            _db.cd_temp_func_head = oldnext==&row ? NULL : oldnext; // adjust list head
        }
        row.cd_temp_func_next = (amc::FFunc*)-1; // mark element as not-in-list);
        row.cd_temp_func_prev = NULL; // clear back-pointer
    }
}

// --- amc.FDb.cd_temp_func.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::cd_temp_func_RemoveAll() {
    amc::FFunc* row = _db.cd_temp_func_head;
    amc::FFunc* head = _db.cd_temp_func_head;
    _db.cd_temp_func_head = NULL;
    _db.cd_temp_func_n = 0;
    while (row) {
        amc::FFunc* row_next = row->cd_temp_func_next;
        row->cd_temp_func_next  = (amc::FFunc*)-1;
        row->cd_temp_func_prev  = NULL;
        row = row_next != head  ? row_next : NULL;
    }
}

// --- amc.FDb.cd_temp_func.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFunc* amc::cd_temp_func_RemoveFirst() {
    amc::FFunc *row = NULL;
    row = _db.cd_temp_func_head;
    if (row) {
        bool hasmore = row!=row->cd_temp_func_next;
        _db.cd_temp_func_head = hasmore ? row->cd_temp_func_next : NULL;
        row->cd_temp_func_next->cd_temp_func_prev = row->cd_temp_func_prev;
        row->cd_temp_func_prev->cd_temp_func_next = row->cd_temp_func_next;
        row->cd_temp_func_prev = NULL;
        _db.cd_temp_func_n--;
        row->cd_temp_func_next = (amc::FFunc*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.cd_temp_func.RotateFirst
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
amc::FFunc* amc::cd_temp_func_RotateFirst() {
    amc::FFunc *row = NULL;
    row = _db.cd_temp_func_head;
    if (row) {
        _db.cd_temp_func_head = row->cd_temp_func_next;
    }
    return row;
}

// --- amc.FDb.zs_gen_perns.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_gen_perns_Insert(amc::FGen& row) {
    if (!zs_gen_perns_InLlistQ(row)) {
        amc::FGen* old_tail       = _db.zs_gen_perns_tail;
        row.zs_gen_perns_next  = NULL;
        _db.zs_gen_perns_tail = &row;
        amc::FGen **new_row_a = &old_tail->zs_gen_perns_next;
        amc::FGen **new_row_b = &_db.zs_gen_perns_head;
        amc::FGen **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FDb.zs_gen_perns.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_gen_perns_Remove(amc::FGen& row) {
    if (zs_gen_perns_InLlistQ(row)) {
        amc::FGen* old_head       = _db.zs_gen_perns_head;
        (void)old_head; // in case it's not used
        amc::FGen* prev=NULL;
        amc::FGen* cur     = _db.zs_gen_perns_head;
        while (cur) {  // search for element by pointer
            amc::FGen* next = cur->zs_gen_perns_next;
            if (cur == &row) {

                if (!next) {
                    _db.zs_gen_perns_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_gen_perns_next = next;
                } else {
                    _db.zs_gen_perns_head = next;
                }
                row.zs_gen_perns_next = (amc::FGen*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FDb.zs_gen_perns.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_gen_perns_RemoveAll() {
    amc::FGen* row = _db.zs_gen_perns_head;
    _db.zs_gen_perns_head = NULL;
    _db.zs_gen_perns_tail = NULL;
    while (row) {
        amc::FGen* row_next = row->zs_gen_perns_next;
        row->zs_gen_perns_next  = (amc::FGen*)-1;
        row = row_next;
    }
}

// --- amc.FDb.zs_gen_perns.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FGen* amc::zs_gen_perns_RemoveFirst() {
    amc::FGen *row = NULL;
    row = _db.zs_gen_perns_head;
    if (row) {
        amc::FGen *next = row->zs_gen_perns_next;
        _db.zs_gen_perns_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            _db.zs_gen_perns_tail = NULL;
        }
        row->zs_gen_perns_next = (amc::FGen*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FDb.hook.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FHook& amc::hook_Alloc() {
    amc::FHook* row = hook_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.hook  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.hook.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FHook* amc::hook_AllocMaybe() {
    amc::FHook *row = (amc::FHook*)hook_AllocMem();
    if (row) {
        new (row) amc::FHook; // call constructor
    }
    return row;
}

// --- amc.FDb.hook.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FHook* amc::hook_InsertMaybe(const dmmeta::Hook &value) {
    amc::FHook *row = &hook_Alloc(); // if out of memory, process dies. if input error, return NULL.
    hook_CopyIn(*row,const_cast<dmmeta::Hook&>(value));
    bool ok = hook_XrefMaybe(*row); // this may return false
    if (!ok) {
        hook_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.hook.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::hook_AllocMem() {
    u64 new_nelems     = _db.hook_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FHook*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.hook_lary[bsr];
        if (!lev) {
            lev=(amc::FHook*)amc::lpool_AllocMem(sizeof(amc::FHook) * (u64(1)<<bsr));
            _db.hook_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.hook_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.hook.RemoveAll
// Remove all elements from Lary
void amc::hook_RemoveAll() {
    for (u64 n = _db.hook_n; n>0; ) {
        n--;
        hook_qFind(u64(n)).~FHook(); // destroy last element
        _db.hook_n = i32(n);
    }
}

// --- amc.FDb.hook.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::hook_RemoveLast() {
    u64 n = _db.hook_n;
    if (n > 0) {
        n -= 1;
        hook_qFind(u64(n)).~FHook();
        _db.hook_n = i32(n);
    }
}

// --- amc.FDb.hook.InputMaybe
static bool amc::hook_InputMaybe(dmmeta::Hook &elem) {
    bool retval = true;
    retval = hook_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.hook.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::hook_XrefMaybe(amc::FHook &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // hook: save pointer to field
    if (true) { // user-defined insert condition
        row.p_field = p_field;
    }
    // insert hook into index c_hook
    if (true) { // user-defined insert condition
        bool success = c_hook_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_hook"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.charset.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCharset& amc::charset_Alloc() {
    amc::FCharset* row = charset_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.charset  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.charset.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FCharset* amc::charset_AllocMaybe() {
    amc::FCharset *row = (amc::FCharset*)charset_AllocMem();
    if (row) {
        new (row) amc::FCharset; // call constructor
    }
    return row;
}

// --- amc.FDb.charset.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCharset* amc::charset_InsertMaybe(const dmmeta::Charset &value) {
    amc::FCharset *row = &charset_Alloc(); // if out of memory, process dies. if input error, return NULL.
    charset_CopyIn(*row,const_cast<dmmeta::Charset&>(value));
    bool ok = charset_XrefMaybe(*row); // this may return false
    if (!ok) {
        charset_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.charset.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::charset_AllocMem() {
    u64 new_nelems     = _db.charset_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FCharset*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.charset_lary[bsr];
        if (!lev) {
            lev=(amc::FCharset*)amc::lpool_AllocMem(sizeof(amc::FCharset) * (u64(1)<<bsr));
            _db.charset_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.charset_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.charset.RemoveAll
// Remove all elements from Lary
void amc::charset_RemoveAll() {
    for (u64 n = _db.charset_n; n>0; ) {
        n--;
        charset_qFind(u64(n)).~FCharset(); // destroy last element
        _db.charset_n = i32(n);
    }
}

// --- amc.FDb.charset.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::charset_RemoveLast() {
    u64 n = _db.charset_n;
    if (n > 0) {
        n -= 1;
        charset_qFind(u64(n)).~FCharset();
        _db.charset_n = i32(n);
    }
}

// --- amc.FDb.charset.InputMaybe
static bool amc::charset_InputMaybe(dmmeta::Charset &elem) {
    bool retval = true;
    retval = charset_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.charset.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::charset_XrefMaybe(amc::FCharset &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert charset into index c_charset
    if (true) { // user-defined insert condition
        bool success = c_charset_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_charset"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.nsinclude.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsinclude& amc::nsinclude_Alloc() {
    amc::FNsinclude* row = nsinclude_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.nsinclude  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.nsinclude.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsinclude* amc::nsinclude_AllocMaybe() {
    amc::FNsinclude *row = (amc::FNsinclude*)nsinclude_AllocMem();
    if (row) {
        new (row) amc::FNsinclude; // call constructor
    }
    return row;
}

// --- amc.FDb.nsinclude.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsinclude* amc::nsinclude_InsertMaybe(const dmmeta::Nsinclude &value) {
    amc::FNsinclude *row = &nsinclude_Alloc(); // if out of memory, process dies. if input error, return NULL.
    nsinclude_CopyIn(*row,const_cast<dmmeta::Nsinclude&>(value));
    bool ok = nsinclude_XrefMaybe(*row); // this may return false
    if (!ok) {
        nsinclude_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.nsinclude.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::nsinclude_AllocMem() {
    u64 new_nelems     = _db.nsinclude_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FNsinclude*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.nsinclude_lary[bsr];
        if (!lev) {
            lev=(amc::FNsinclude*)amc::lpool_AllocMem(sizeof(amc::FNsinclude) * (u64(1)<<bsr));
            _db.nsinclude_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.nsinclude_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.nsinclude.RemoveAll
// Remove all elements from Lary
void amc::nsinclude_RemoveAll() {
    for (u64 n = _db.nsinclude_n; n>0; ) {
        n--;
        nsinclude_qFind(u64(n)).~FNsinclude(); // destroy last element
        _db.nsinclude_n = i32(n);
    }
}

// --- amc.FDb.nsinclude.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::nsinclude_RemoveLast() {
    u64 n = _db.nsinclude_n;
    if (n > 0) {
        n -= 1;
        nsinclude_qFind(u64(n)).~FNsinclude();
        _db.nsinclude_n = i32(n);
    }
}

// --- amc.FDb.nsinclude.InputMaybe
static bool amc::nsinclude_InputMaybe(dmmeta::Nsinclude &elem) {
    bool retval = true;
    retval = nsinclude_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.nsinclude.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::nsinclude_XrefMaybe(amc::FNsinclude &row) {
    bool retval = true;
    (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (UNLIKELY(!p_ns)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ns" << Keyval("key", ns_Get(row));
        return false;
    }
    // insert nsinclude into index c_nsinclude
    if (true) { // user-defined insert condition
        c_nsinclude_Insert(*p_ns, row);
    }
    return retval;
}

// --- amc.FDb.ssimvolatile.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSsimvolatile& amc::ssimvolatile_Alloc() {
    amc::FSsimvolatile* row = ssimvolatile_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.ssimvolatile  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.ssimvolatile.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FSsimvolatile* amc::ssimvolatile_AllocMaybe() {
    amc::FSsimvolatile *row = (amc::FSsimvolatile*)ssimvolatile_AllocMem();
    if (row) {
        new (row) amc::FSsimvolatile; // call constructor
    }
    return row;
}

// --- amc.FDb.ssimvolatile.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSsimvolatile* amc::ssimvolatile_InsertMaybe(const dmmeta::Ssimvolatile &value) {
    amc::FSsimvolatile *row = &ssimvolatile_Alloc(); // if out of memory, process dies. if input error, return NULL.
    ssimvolatile_CopyIn(*row,const_cast<dmmeta::Ssimvolatile&>(value));
    bool ok = ssimvolatile_XrefMaybe(*row); // this may return false
    if (!ok) {
        ssimvolatile_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.ssimvolatile.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::ssimvolatile_AllocMem() {
    u64 new_nelems     = _db.ssimvolatile_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FSsimvolatile*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.ssimvolatile_lary[bsr];
        if (!lev) {
            lev=(amc::FSsimvolatile*)amc::lpool_AllocMem(sizeof(amc::FSsimvolatile) * (u64(1)<<bsr));
            _db.ssimvolatile_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.ssimvolatile_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.ssimvolatile.RemoveAll
// Remove all elements from Lary
void amc::ssimvolatile_RemoveAll() {
    for (u64 n = _db.ssimvolatile_n; n>0; ) {
        n--;
        ssimvolatile_qFind(u64(n)).~FSsimvolatile(); // destroy last element
        _db.ssimvolatile_n = i32(n);
    }
}

// --- amc.FDb.ssimvolatile.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::ssimvolatile_RemoveLast() {
    u64 n = _db.ssimvolatile_n;
    if (n > 0) {
        n -= 1;
        ssimvolatile_qFind(u64(n)).~FSsimvolatile();
        _db.ssimvolatile_n = i32(n);
    }
}

// --- amc.FDb.ssimvolatile.InputMaybe
static bool amc::ssimvolatile_InputMaybe(dmmeta::Ssimvolatile &elem) {
    bool retval = true;
    retval = ssimvolatile_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.ssimvolatile.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::ssimvolatile_XrefMaybe(amc::FSsimvolatile &row) {
    bool retval = true;
    (void)row;
    amc::FSsimfile* p_ssimfile = amc::ind_ssimfile_Find(row.ssimfile);
    if (UNLIKELY(!p_ssimfile)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_ssimfile" << Keyval("key", row.ssimfile);
        return false;
    }
    // insert ssimvolatile into index c_ssimvolatile
    if (true) { // user-defined insert condition
        bool success = c_ssimvolatile_InsertMaybe(*p_ssimfile, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FSsimfile.c_ssimvolatile"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.funique.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFunique& amc::funique_Alloc() {
    amc::FFunique* row = funique_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.funique  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.funique.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFunique* amc::funique_AllocMaybe() {
    amc::FFunique *row = (amc::FFunique*)funique_AllocMem();
    if (row) {
        new (row) amc::FFunique; // call constructor
    }
    return row;
}

// --- amc.FDb.funique.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFunique* amc::funique_InsertMaybe(const dmmeta::Funique &value) {
    amc::FFunique *row = &funique_Alloc(); // if out of memory, process dies. if input error, return NULL.
    funique_CopyIn(*row,const_cast<dmmeta::Funique&>(value));
    bool ok = funique_XrefMaybe(*row); // this may return false
    if (!ok) {
        funique_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.funique.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::funique_AllocMem() {
    u64 new_nelems     = _db.funique_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFunique*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.funique_lary[bsr];
        if (!lev) {
            lev=(amc::FFunique*)amc::lpool_AllocMem(sizeof(amc::FFunique) * (u64(1)<<bsr));
            _db.funique_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.funique_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.funique.RemoveAll
// Remove all elements from Lary
void amc::funique_RemoveAll() {
    for (u64 n = _db.funique_n; n>0; ) {
        n--;
        funique_qFind(u64(n)).~FFunique(); // destroy last element
        _db.funique_n = i32(n);
    }
}

// --- amc.FDb.funique.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::funique_RemoveLast() {
    u64 n = _db.funique_n;
    if (n > 0) {
        n -= 1;
        funique_qFind(u64(n)).~FFunique();
        _db.funique_n = i32(n);
    }
}

// --- amc.FDb.funique.InputMaybe
static bool amc::funique_InputMaybe(dmmeta::Funique &elem) {
    bool retval = true;
    retval = funique_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.funique.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::funique_XrefMaybe(amc::FFunique &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert funique into index c_funique
    if (true) { // user-defined insert condition
        bool success = c_funique_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_funique"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.fuserinit.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFuserinit& amc::fuserinit_Alloc() {
    amc::FFuserinit* row = fuserinit_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.fuserinit  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.fuserinit.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FFuserinit* amc::fuserinit_AllocMaybe() {
    amc::FFuserinit *row = (amc::FFuserinit*)fuserinit_AllocMem();
    if (row) {
        new (row) amc::FFuserinit; // call constructor
    }
    return row;
}

// --- amc.FDb.fuserinit.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFuserinit* amc::fuserinit_InsertMaybe(const dmmeta::Fuserinit &value) {
    amc::FFuserinit *row = &fuserinit_Alloc(); // if out of memory, process dies. if input error, return NULL.
    fuserinit_CopyIn(*row,const_cast<dmmeta::Fuserinit&>(value));
    bool ok = fuserinit_XrefMaybe(*row); // this may return false
    if (!ok) {
        fuserinit_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.fuserinit.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::fuserinit_AllocMem() {
    u64 new_nelems     = _db.fuserinit_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FFuserinit*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.fuserinit_lary[bsr];
        if (!lev) {
            lev=(amc::FFuserinit*)amc::lpool_AllocMem(sizeof(amc::FFuserinit) * (u64(1)<<bsr));
            _db.fuserinit_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.fuserinit_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.fuserinit.RemoveAll
// Remove all elements from Lary
void amc::fuserinit_RemoveAll() {
    for (u64 n = _db.fuserinit_n; n>0; ) {
        n--;
        fuserinit_qFind(u64(n)).~FFuserinit(); // destroy last element
        _db.fuserinit_n = i32(n);
    }
}

// --- amc.FDb.fuserinit.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::fuserinit_RemoveLast() {
    u64 n = _db.fuserinit_n;
    if (n > 0) {
        n -= 1;
        fuserinit_qFind(u64(n)).~FFuserinit();
        _db.fuserinit_n = i32(n);
    }
}

// --- amc.FDb.fuserinit.InputMaybe
static bool amc::fuserinit_InputMaybe(dmmeta::Fuserinit &elem) {
    bool retval = true;
    retval = fuserinit_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.fuserinit.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::fuserinit_XrefMaybe(amc::FFuserinit &row) {
    bool retval = true;
    (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (UNLIKELY(!p_field)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_field" << Keyval("key", row.field);
        return false;
    }
    // insert fuserinit into index c_fuserinit
    if (true) { // user-defined insert condition
        bool success = c_fuserinit_InsertMaybe(*p_field, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FField.c_fuserinit"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fcurs.Find
// Find row by key. Return NULL if not found.
amc::FFcurs* amc::ind_fcurs_Find(const algo::strptr& key) {
    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_fcurs_buckets_n - 1);
    amc::FFcurs* *e = &_db.ind_fcurs_buckets_elems[index];
    amc::FFcurs* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).fcurs == key;
        if (done) break;
        e         = &ret->ind_fcurs_next;
    } while (true);
    return ret;
}

// --- amc.FDb.ind_fcurs.GetOrCreate
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFcurs& amc::ind_fcurs_GetOrCreate(const algo::strptr& key) {
    amc::FFcurs* ret = ind_fcurs_Find(key);
    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
        ret         = &fcurs_Alloc();
        (*ret).fcurs = key;
        bool good = fcurs_XrefMaybe(*ret);
        if (!good) {
            fcurs_RemoveLast(); // delete offending row, any existing xrefs are cleared
            ret = NULL;
        }
    }
    vrfy(ret, tempstr() << "amc.create_error  table:ind_fcurs  key:'"<<key<<"'  comment:'bad xref'");
    return *ret;
}

// --- amc.FDb.ind_fcurs.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_fcurs_InsertMaybe(amc::FFcurs& row) {
    ind_fcurs_Reserve(1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_fcurs_next == (amc::FFcurs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.fcurs) & (_db.ind_fcurs_buckets_n - 1);
        amc::FFcurs* *prev = &_db.ind_fcurs_buckets_elems[index];
        do {
            amc::FFcurs* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).fcurs == row.fcurs) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_fcurs_next;
        } while (true);
        if (retval) {
            row.ind_fcurs_next = *prev;
            _db.ind_fcurs_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FDb.ind_fcurs.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_fcurs_Remove(amc::FFcurs& row) {
    if (LIKELY(row.ind_fcurs_next != (amc::FFcurs*)-1)) {// check if in hash already
        u32 index = algo::Smallstr50_Hash(0, row.fcurs) & (_db.ind_fcurs_buckets_n - 1);
        amc::FFcurs* *prev = &_db.ind_fcurs_buckets_elems[index]; // addr of pointer to current element
        while (amc::FFcurs *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_fcurs_next; // unlink (singly linked list)
                _db.ind_fcurs_n--;
                row.ind_fcurs_next = (amc::FFcurs*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_fcurs_next;
        }
    }
}

// --- amc.FDb.ind_fcurs.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_fcurs_Reserve(int n) {
    u32 old_nbuckets = _db.ind_fcurs_buckets_n;
    u32 new_nelems   = _db.ind_fcurs_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FFcurs*);
        u32 new_size = new_nbuckets * sizeof(amc::FFcurs*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FFcurs* *new_buckets = (amc::FFcurs**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDb.ind_fcurs");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < _db.ind_fcurs_buckets_n; i++) {
            amc::FFcurs* elem = _db.ind_fcurs_buckets_elems[i];
            while (elem) {
                amc::FFcurs &row        = *elem;
                amc::FFcurs* next       = row.ind_fcurs_next;
                u32 index          = algo::Smallstr50_Hash(0, row.fcurs) & (new_nbuckets-1);
                row.ind_fcurs_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(_db.ind_fcurs_buckets_elems, old_size);
        _db.ind_fcurs_buckets_elems = new_buckets;
        _db.ind_fcurs_buckets_n = new_nbuckets;
    }
}

// --- amc.FDb.tcurs.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTcurs& amc::tcurs_Alloc() {
    amc::FTcurs* row = tcurs_AllocMaybe();
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FDb.tcurs  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FDb.tcurs.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FTcurs* amc::tcurs_AllocMaybe() {
    amc::FTcurs *row = (amc::FTcurs*)tcurs_AllocMem();
    if (row) {
        new (row) amc::FTcurs; // call constructor
    }
    return row;
}

// --- amc.FDb.tcurs.InsertMaybe
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTcurs* amc::tcurs_InsertMaybe(const amcdb::Tcurs &value) {
    amc::FTcurs *row = &tcurs_Alloc(); // if out of memory, process dies. if input error, return NULL.
    tcurs_CopyIn(*row,const_cast<amcdb::Tcurs&>(value));
    bool ok = tcurs_XrefMaybe(*row); // this may return false
    if (!ok) {
        tcurs_RemoveLast(); // delete offending row, any existing xrefs are cleared
        row = NULL; // forget this ever happened
    }
    return row;
}

// --- amc.FDb.tcurs.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::tcurs_AllocMem() {
    u64 new_nelems     = _db.tcurs_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FTcurs*  lev   = NULL;
    if (bsr < 32) {
        lev = _db.tcurs_lary[bsr];
        if (!lev) {
            lev=(amc::FTcurs*)amc::lpool_AllocMem(sizeof(amc::FTcurs) * (u64(1)<<bsr));
            _db.tcurs_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        _db.tcurs_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FDb.tcurs.RemoveAll
// Remove all elements from Lary
void amc::tcurs_RemoveAll() {
    for (u64 n = _db.tcurs_n; n>0; ) {
        n--;
        tcurs_qFind(u64(n)).~FTcurs(); // destroy last element
        _db.tcurs_n = i32(n);
    }
}

// --- amc.FDb.tcurs.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::tcurs_RemoveLast() {
    u64 n = _db.tcurs_n;
    if (n > 0) {
        n -= 1;
        tcurs_qFind(u64(n)).~FTcurs();
        _db.tcurs_n = i32(n);
    }
}

// --- amc.FDb.tcurs.InputMaybe
static bool amc::tcurs_InputMaybe(amcdb::Tcurs &elem) {
    bool retval = true;
    retval = tcurs_InsertMaybe(elem) != nullptr;
    return retval;
}

// --- amc.FDb.tcurs.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::tcurs_XrefMaybe(amc::FTcurs &row) {
    bool retval = true;
    (void)row;
    amc::FTfunc* p_tfunc = amc::ind_tfunc_Find(row.tfunc);
    if (UNLIKELY(!p_tfunc)) {
        algo_lib::ResetErrtext() << "amc.bad_xref  index:amc.FDb.ind_tfunc" << Keyval("key", row.tfunc);
        return false;
    }
    // insert tcurs into index c_tcurs
    if (true) { // user-defined insert condition
        bool success = c_tcurs_InsertMaybe(*p_tfunc, row);
        if (UNLIKELY(!success)) {
            ch_RemoveAll(algo_lib::_db.errtext);
            algo_lib::_db.errtext << "amc.duplicate_key  xref:amc.FTfunc.c_tcurs"; // check for duplicate key
            return false;
        }
    }
    return retval;
}

// --- amc.FDb.trace.RowidFind
// find trace by row id (used to implement reflection)
static algo::ImrowPtr amc::trace_RowidFind(int t) {
    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
}

// --- amc.FDb.trace.N
// Function return 1
inline static i32 amc::trace_N() {
    return 1;
}

// --- amc.FDb.bh_enumstr_len_curs.Add
static void amc::_db_bh_enumstr_len_curs_Add(_db_bh_enumstr_len_curs &curs, amc::FEnumstrLen& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    amc::FEnumstrLen* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        amc::FEnumstrLen* p = elems[j];
        if (!bh_enumstr_len_ElemLt(row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- amc.FDb.bh_enumstr_len_curs.Reserve
void amc::_db_bh_enumstr_len_curs_Reserve(_db_bh_enumstr_len_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_enumstr_len_N();
        curs.temp_elems   = (amc::FEnumstrLen**)amc::lpool_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("amc.cursor_out_of_memory  func:amc.FDb.bh_enumstr_len_curs.Reserve");
        }
        curs.temp_max       = bh_enumstr_len_N();
    }
}

// --- amc.FDb.bh_enumstr_len_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void amc::_db_bh_enumstr_len_curs_Reset(_db_bh_enumstr_len_curs &curs, amc::FDb &parent) {
    curs.parent       = &parent;
    _db_bh_enumstr_len_curs_Reserve(curs, bh_enumstr_len_N());
    curs.temp_n = 0;
    if (parent.bh_enumstr_len_n > 0) {
        amc::FEnumstrLen &first = *parent.bh_enumstr_len_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- amc.FDb.bh_enumstr_len_curs.Next
// Advance cursor.
void amc::_db_bh_enumstr_len_curs_Next(_db_bh_enumstr_len_curs &curs) {
    amc::FEnumstrLen* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        amc::FEnumstrLen* dead = elems[0];
        int i       = 0;
        amc::FEnumstrLen* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            amc::FEnumstrLen* choose = last;
            int l         = i*2+1;
            if (l<n) {
                amc::FEnumstrLen* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                amc::FEnumstrLen* er = elems[r];
                if (bh_enumstr_len_ElemLt(*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_enumstr_len_ElemLt(*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_enumstr_len_idx;
        i = (index*2+1);
        if (i < bh_enumstr_len_N()) {
            amc::FEnumstrLen &elem = *curs.parent->bh_enumstr_len_elems[i];
            _db_bh_enumstr_len_curs_Add(curs, elem);
        }
        if (i+1 < bh_enumstr_len_N()) {
            amc::FEnumstrLen &elem = *curs.parent->bh_enumstr_len_elems[i + 1];
            _db_bh_enumstr_len_curs_Add(curs, elem);
        }
    }
}

// --- amc.FDb..Init
// Set all fields to initial values.
void amc::FDb_Init() {
    _db.lpool_lock = 0;
    memset(_db.lpool_free, 0, sizeof(_db.lpool_free));
    // initialize LAry fsort (amc.FDb.fsort)
    _db.fsort_n = 0;
    memset(_db.fsort_lary, 0, sizeof(_db.fsort_lary)); // zero out all level pointers
    amc::FFsort* fsort_first = (amc::FFsort*)amc::lpool_AllocMem(sizeof(amc::FFsort) * (u64(1)<<4));
    if (!fsort_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fsort_lary[i]  = fsort_first;
        fsort_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FCfmt;
    _db.ind_cfmt_n             	= 0; // (amc.FDb.ind_cfmt)
    _db.ind_cfmt_buckets_n     	= 4; // (amc.FDb.ind_cfmt)
    _db.ind_cfmt_buckets_elems 	= (amc::FCfmt**)amc::lpool_AllocMem(sizeof(amc::FCfmt*)*_db.ind_cfmt_buckets_n); // initial buckets (amc.FDb.ind_cfmt)
    if (!_db.ind_cfmt_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_cfmt)
    }
    memset(_db.ind_cfmt_buckets_elems, 0, sizeof(amc::FCfmt*)*_db.ind_cfmt_buckets_n); // (amc.FDb.ind_cfmt)
    // initialize LAry dispfilter (amc.FDb.dispfilter)
    _db.dispfilter_n = 0;
    memset(_db.dispfilter_lary, 0, sizeof(_db.dispfilter_lary)); // zero out all level pointers
    amc::FDispfilter* dispfilter_first = (amc::FDispfilter*)amc::lpool_AllocMem(sizeof(amc::FDispfilter) * (u64(1)<<4));
    if (!dispfilter_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispfilter_lary[i]  = dispfilter_first;
        dispfilter_first    += 1ULL<<i;
    }
    // initialize LAry usertracefld (amc.FDb.usertracefld)
    _db.usertracefld_n = 0;
    memset(_db.usertracefld_lary, 0, sizeof(_db.usertracefld_lary)); // zero out all level pointers
    amc::FUsertracefld* usertracefld_first = (amc::FUsertracefld*)amc::lpool_AllocMem(sizeof(amc::FUsertracefld) * (u64(1)<<4));
    if (!usertracefld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.usertracefld_lary[i]  = usertracefld_first;
        usertracefld_first    += 1ULL<<i;
    }
    // initialize LAry cfmt (amc.FDb.cfmt)
    _db.cfmt_n = 0;
    memset(_db.cfmt_lary, 0, sizeof(_db.cfmt_lary)); // zero out all level pointers
    amc::FCfmt* cfmt_first = (amc::FCfmt*)amc::lpool_AllocMem(sizeof(amc::FCfmt) * (u64(1)<<4));
    if (!cfmt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cfmt_lary[i]  = cfmt_first;
        cfmt_first    += 1ULL<<i;
    }
    // initialize LAry dispatch (amc.FDb.dispatch)
    _db.dispatch_n = 0;
    memset(_db.dispatch_lary, 0, sizeof(_db.dispatch_lary)); // zero out all level pointers
    amc::FDispatch* dispatch_first = (amc::FDispatch*)amc::lpool_AllocMem(sizeof(amc::FDispatch) * (u64(1)<<4));
    if (!dispatch_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispatch_lary[i]  = dispatch_first;
        dispatch_first    += 1ULL<<i;
    }
    // initialize LAry dispatch_msg (amc.FDb.dispatch_msg)
    _db.dispatch_msg_n = 0;
    memset(_db.dispatch_msg_lary, 0, sizeof(_db.dispatch_msg_lary)); // zero out all level pointers
    amc::FDispatchmsg* dispatch_msg_first = (amc::FDispatchmsg*)amc::lpool_AllocMem(sizeof(amc::FDispatchmsg) * (u64(1)<<4));
    if (!dispatch_msg_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispatch_msg_lary[i]  = dispatch_msg_first;
        dispatch_msg_first    += 1ULL<<i;
    }
    // initialize LAry ctype (amc.FDb.ctype)
    _db.ctype_n = 0;
    memset(_db.ctype_lary, 0, sizeof(_db.ctype_lary)); // zero out all level pointers
    amc::FCtype* ctype_first = (amc::FCtype*)amc::lpool_AllocMem(sizeof(amc::FCtype) * (u64(1)<<4));
    if (!ctype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctype_lary[i]  = ctype_first;
        ctype_first    += 1ULL<<i;
    }
    // initialize LAry field (amc.FDb.field)
    _db.field_n = 0;
    memset(_db.field_lary, 0, sizeof(_db.field_lary)); // zero out all level pointers
    amc::FField* field_first = (amc::FField*)amc::lpool_AllocMem(sizeof(amc::FField) * (u64(1)<<4));
    if (!field_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.field_lary[i]  = field_first;
        field_first    += 1ULL<<i;
    }
    // initialize LAry basepool (amc.FDb.basepool)
    _db.basepool_n = 0;
    memset(_db.basepool_lary, 0, sizeof(_db.basepool_lary)); // zero out all level pointers
    amc::FBasepool* basepool_first = (amc::FBasepool*)amc::lpool_AllocMem(sizeof(amc::FBasepool) * (u64(1)<<4));
    if (!basepool_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.basepool_lary[i]  = basepool_first;
        basepool_first    += 1ULL<<i;
    }
    // initialize LAry llist (amc.FDb.llist)
    _db.llist_n = 0;
    memset(_db.llist_lary, 0, sizeof(_db.llist_lary)); // zero out all level pointers
    amc::FLlist* llist_first = (amc::FLlist*)amc::lpool_AllocMem(sizeof(amc::FLlist) * (u64(1)<<4));
    if (!llist_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.llist_lary[i]  = llist_first;
        llist_first    += 1ULL<<i;
    }
    // initialize LAry anonfld (amc.FDb.anonfld)
    _db.anonfld_n = 0;
    memset(_db.anonfld_lary, 0, sizeof(_db.anonfld_lary)); // zero out all level pointers
    amc::FAnonfld* anonfld_first = (amc::FAnonfld*)amc::lpool_AllocMem(sizeof(amc::FAnonfld) * (u64(1)<<4));
    if (!anonfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.anonfld_lary[i]  = anonfld_first;
        anonfld_first    += 1ULL<<i;
    }
    // initialize LAry xref (amc.FDb.xref)
    _db.xref_n = 0;
    memset(_db.xref_lary, 0, sizeof(_db.xref_lary)); // zero out all level pointers
    amc::FXref* xref_first = (amc::FXref*)amc::lpool_AllocMem(sizeof(amc::FXref) * (u64(1)<<4));
    if (!xref_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.xref_lary[i]  = xref_first;
        xref_first    += 1ULL<<i;
    }
    // initialize LAry ns (amc.FDb.ns)
    _db.ns_n = 0;
    memset(_db.ns_lary, 0, sizeof(_db.ns_lary)); // zero out all level pointers
    amc::FNs* ns_first = (amc::FNs*)amc::lpool_AllocMem(sizeof(amc::FNs) * (u64(1)<<4));
    if (!ns_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ns_lary[i]  = ns_first;
        ns_first    += 1ULL<<i;
    }
    // initialize LAry pnew (amc.FDb.pnew)
    _db.pnew_n = 0;
    memset(_db.pnew_lary, 0, sizeof(_db.pnew_lary)); // zero out all level pointers
    amc::FPnew* pnew_first = (amc::FPnew*)amc::lpool_AllocMem(sizeof(amc::FPnew) * (u64(1)<<4));
    if (!pnew_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pnew_lary[i]  = pnew_first;
        pnew_first    += 1ULL<<i;
    }
    // initialize LAry fldoffset (amc.FDb.fldoffset)
    _db.fldoffset_n = 0;
    memset(_db.fldoffset_lary, 0, sizeof(_db.fldoffset_lary)); // zero out all level pointers
    amc::FFldoffset* fldoffset_first = (amc::FFldoffset*)amc::lpool_AllocMem(sizeof(amc::FFldoffset) * (u64(1)<<4));
    if (!fldoffset_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fldoffset_lary[i]  = fldoffset_first;
        fldoffset_first    += 1ULL<<i;
    }
    // initialize LAry typefld (amc.FDb.typefld)
    _db.typefld_n = 0;
    memset(_db.typefld_lary, 0, sizeof(_db.typefld_lary)); // zero out all level pointers
    amc::FTypefld* typefld_first = (amc::FTypefld*)amc::lpool_AllocMem(sizeof(amc::FTypefld) * (u64(1)<<4));
    if (!typefld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.typefld_lary[i]  = typefld_first;
        typefld_first    += 1ULL<<i;
    }
    // initialize LAry lenfld (amc.FDb.lenfld)
    _db.lenfld_n = 0;
    memset(_db.lenfld_lary, 0, sizeof(_db.lenfld_lary)); // zero out all level pointers
    amc::FLenfld* lenfld_first = (amc::FLenfld*)amc::lpool_AllocMem(sizeof(amc::FLenfld) * (u64(1)<<4));
    if (!lenfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.lenfld_lary[i]  = lenfld_first;
        lenfld_first    += 1ULL<<i;
    }
    // initialize LAry bltin (amc.FDb.bltin)
    _db.bltin_n = 0;
    memset(_db.bltin_lary, 0, sizeof(_db.bltin_lary)); // zero out all level pointers
    amc::FBltin* bltin_first = (amc::FBltin*)amc::lpool_AllocMem(sizeof(amc::FBltin) * (u64(1)<<4));
    if (!bltin_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.bltin_lary[i]  = bltin_first;
        bltin_first    += 1ULL<<i;
    }
    // initialize LAry static_tuple (amc.FDb.static_tuple)
    _db.static_tuple_n = 0;
    memset(_db.static_tuple_lary, 0, sizeof(_db.static_tuple_lary)); // zero out all level pointers
    amc::FStatictuple* static_tuple_first = (amc::FStatictuple*)amc::lpool_AllocMem(sizeof(amc::FStatictuple) * (u64(1)<<4));
    if (!static_tuple_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.static_tuple_lary[i]  = static_tuple_first;
        static_tuple_first    += 1ULL<<i;
    }
    // initialize LAry msgtype (amc.FDb.msgtype)
    _db.msgtype_n = 0;
    memset(_db.msgtype_lary, 0, sizeof(_db.msgtype_lary)); // zero out all level pointers
    amc::FMsgtype* msgtype_first = (amc::FMsgtype*)amc::lpool_AllocMem(sizeof(amc::FMsgtype) * (u64(1)<<4));
    if (!msgtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.msgtype_lary[i]  = msgtype_first;
        msgtype_first    += 1ULL<<i;
    }
    // initialize LAry gconst (amc.FDb.gconst)
    _db.gconst_n = 0;
    memset(_db.gconst_lary, 0, sizeof(_db.gconst_lary)); // zero out all level pointers
    amc::FGconst* gconst_first = (amc::FGconst*)amc::lpool_AllocMem(sizeof(amc::FGconst) * (u64(1)<<4));
    if (!gconst_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gconst_lary[i]  = gconst_first;
        gconst_first    += 1ULL<<i;
    }
    // initialize LAry gstatic (amc.FDb.gstatic)
    _db.gstatic_n = 0;
    memset(_db.gstatic_lary, 0, sizeof(_db.gstatic_lary)); // zero out all level pointers
    amc::FGstatic* gstatic_first = (amc::FGstatic*)amc::lpool_AllocMem(sizeof(amc::FGstatic) * (u64(1)<<4));
    if (!gstatic_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gstatic_lary[i]  = gstatic_first;
        gstatic_first    += 1ULL<<i;
    }
    // initialize LAry thash (amc.FDb.thash)
    _db.thash_n = 0;
    memset(_db.thash_lary, 0, sizeof(_db.thash_lary)); // zero out all level pointers
    amc::FThash* thash_first = (amc::FThash*)amc::lpool_AllocMem(sizeof(amc::FThash) * (u64(1)<<4));
    if (!thash_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.thash_lary[i]  = thash_first;
        thash_first    += 1ULL<<i;
    }
    // outfile: initialize Tpool
    _db.outfile_free      = NULL;
    _db.outfile_blocksize = algo::BumpToPow2(64 * sizeof(amc::FOutfile)); // allocate 64-127 elements at a time
    // initialize LAry func (amc.FDb.func)
    _db.func_n = 0;
    memset(_db.func_lary, 0, sizeof(_db.func_lary)); // zero out all level pointers
    amc::FFunc* func_first = (amc::FFunc*)amc::lpool_AllocMem(sizeof(amc::FFunc) * (u64(1)<<4));
    if (!func_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.func_lary[i]  = func_first;
        func_first    += 1ULL<<i;
    }
    // initialize LAry smallstr (amc.FDb.smallstr)
    _db.smallstr_n = 0;
    memset(_db.smallstr_lary, 0, sizeof(_db.smallstr_lary)); // zero out all level pointers
    amc::FSmallstr* smallstr_first = (amc::FSmallstr*)amc::lpool_AllocMem(sizeof(amc::FSmallstr) * (u64(1)<<4));
    if (!smallstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.smallstr_lary[i]  = smallstr_first;
        smallstr_first    += 1ULL<<i;
    }
    // initialize LAry numstr (amc.FDb.numstr)
    _db.numstr_n = 0;
    memset(_db.numstr_lary, 0, sizeof(_db.numstr_lary)); // zero out all level pointers
    amc::FNumstr* numstr_first = (amc::FNumstr*)amc::lpool_AllocMem(sizeof(amc::FNumstr) * (u64(1)<<4));
    if (!numstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.numstr_lary[i]  = numstr_first;
        numstr_first    += 1ULL<<i;
    }
    // initialize LAry main (amc.FDb.main)
    _db.main_n = 0;
    memset(_db.main_lary, 0, sizeof(_db.main_lary)); // zero out all level pointers
    amc::FMain* main_first = (amc::FMain*)amc::lpool_AllocMem(sizeof(amc::FMain) * (u64(1)<<4));
    if (!main_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.main_lary[i]  = main_first;
        main_first    += 1ULL<<i;
    }
    // initialize LAry reftype (amc.FDb.reftype)
    _db.reftype_n = 0;
    memset(_db.reftype_lary, 0, sizeof(_db.reftype_lary)); // zero out all level pointers
    amc::FReftype* reftype_first = (amc::FReftype*)amc::lpool_AllocMem(sizeof(amc::FReftype) * (u64(1)<<4));
    if (!reftype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.reftype_lary[i]  = reftype_first;
        reftype_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FBltin;
    _db.ind_bltin_n             	= 0; // (amc.FDb.ind_bltin)
    _db.ind_bltin_buckets_n     	= 4; // (amc.FDb.ind_bltin)
    _db.ind_bltin_buckets_elems 	= (amc::FBltin**)amc::lpool_AllocMem(sizeof(amc::FBltin*)*_db.ind_bltin_buckets_n); // initial buckets (amc.FDb.ind_bltin)
    if (!_db.ind_bltin_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_bltin)
    }
    memset(_db.ind_bltin_buckets_elems, 0, sizeof(amc::FBltin*)*_db.ind_bltin_buckets_n); // (amc.FDb.ind_bltin)
    // initialize hash table for amc::FCtype;
    _db.ind_ctype_n             	= 0; // (amc.FDb.ind_ctype)
    _db.ind_ctype_buckets_n     	= 4; // (amc.FDb.ind_ctype)
    _db.ind_ctype_buckets_elems 	= (amc::FCtype**)amc::lpool_AllocMem(sizeof(amc::FCtype*)*_db.ind_ctype_buckets_n); // initial buckets (amc.FDb.ind_ctype)
    if (!_db.ind_ctype_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_ctype)
    }
    memset(_db.ind_ctype_buckets_elems, 0, sizeof(amc::FCtype*)*_db.ind_ctype_buckets_n); // (amc.FDb.ind_ctype)
    // initialize hash table for amc::FDispatch;
    _db.ind_dispatch_n             	= 0; // (amc.FDb.ind_dispatch)
    _db.ind_dispatch_buckets_n     	= 4; // (amc.FDb.ind_dispatch)
    _db.ind_dispatch_buckets_elems 	= (amc::FDispatch**)amc::lpool_AllocMem(sizeof(amc::FDispatch*)*_db.ind_dispatch_buckets_n); // initial buckets (amc.FDb.ind_dispatch)
    if (!_db.ind_dispatch_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_dispatch)
    }
    memset(_db.ind_dispatch_buckets_elems, 0, sizeof(amc::FDispatch*)*_db.ind_dispatch_buckets_n); // (amc.FDb.ind_dispatch)
    // initialize hash table for amc::FFunc;
    _db.ind_func_n             	= 0; // (amc.FDb.ind_func)
    _db.ind_func_buckets_n     	= 4; // (amc.FDb.ind_func)
    _db.ind_func_buckets_elems 	= (amc::FFunc**)amc::lpool_AllocMem(sizeof(amc::FFunc*)*_db.ind_func_buckets_n); // initial buckets (amc.FDb.ind_func)
    if (!_db.ind_func_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_func)
    }
    memset(_db.ind_func_buckets_elems, 0, sizeof(amc::FFunc*)*_db.ind_func_buckets_n); // (amc.FDb.ind_func)
    // initialize hash table for amc::FField;
    _db.ind_field_n             	= 0; // (amc.FDb.ind_field)
    _db.ind_field_buckets_n     	= 4; // (amc.FDb.ind_field)
    _db.ind_field_buckets_elems 	= (amc::FField**)amc::lpool_AllocMem(sizeof(amc::FField*)*_db.ind_field_buckets_n); // initial buckets (amc.FDb.ind_field)
    if (!_db.ind_field_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_field)
    }
    memset(_db.ind_field_buckets_elems, 0, sizeof(amc::FField*)*_db.ind_field_buckets_n); // (amc.FDb.ind_field)
    // initialize hash table for amc::FNs;
    _db.ind_ns_n             	= 0; // (amc.FDb.ind_ns)
    _db.ind_ns_buckets_n     	= 4; // (amc.FDb.ind_ns)
    _db.ind_ns_buckets_elems 	= (amc::FNs**)amc::lpool_AllocMem(sizeof(amc::FNs*)*_db.ind_ns_buckets_n); // initial buckets (amc.FDb.ind_ns)
    if (!_db.ind_ns_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_ns)
    }
    memset(_db.ind_ns_buckets_elems, 0, sizeof(amc::FNs*)*_db.ind_ns_buckets_n); // (amc.FDb.ind_ns)
    // initialize hash table for amc::FPnew;
    _db.ind_pnew_n             	= 0; // (amc.FDb.ind_pnew)
    _db.ind_pnew_buckets_n     	= 4; // (amc.FDb.ind_pnew)
    _db.ind_pnew_buckets_elems 	= (amc::FPnew**)amc::lpool_AllocMem(sizeof(amc::FPnew*)*_db.ind_pnew_buckets_n); // initial buckets (amc.FDb.ind_pnew)
    if (!_db.ind_pnew_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_pnew)
    }
    memset(_db.ind_pnew_buckets_elems, 0, sizeof(amc::FPnew*)*_db.ind_pnew_buckets_n); // (amc.FDb.ind_pnew)
    // initialize hash table for amc::FXref;
    _db.ind_xref_n             	= 0; // (amc.FDb.ind_xref)
    _db.ind_xref_buckets_n     	= 4; // (amc.FDb.ind_xref)
    _db.ind_xref_buckets_elems 	= (amc::FXref**)amc::lpool_AllocMem(sizeof(amc::FXref*)*_db.ind_xref_buckets_n); // initial buckets (amc.FDb.ind_xref)
    if (!_db.ind_xref_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_xref)
    }
    memset(_db.ind_xref_buckets_elems, 0, sizeof(amc::FXref*)*_db.ind_xref_buckets_n); // (amc.FDb.ind_xref)
    // initialize LAry cpptype (amc.FDb.cpptype)
    _db.cpptype_n = 0;
    memset(_db.cpptype_lary, 0, sizeof(_db.cpptype_lary)); // zero out all level pointers
    amc::FCpptype* cpptype_first = (amc::FCpptype*)amc::lpool_AllocMem(sizeof(amc::FCpptype) * (u64(1)<<4));
    if (!cpptype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cpptype_lary[i]  = cpptype_first;
        cpptype_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FCpptype;
    _db.ind_cpptype_n             	= 0; // (amc.FDb.ind_cpptype)
    _db.ind_cpptype_buckets_n     	= 4; // (amc.FDb.ind_cpptype)
    _db.ind_cpptype_buckets_elems 	= (amc::FCpptype**)amc::lpool_AllocMem(sizeof(amc::FCpptype*)*_db.ind_cpptype_buckets_n); // initial buckets (amc.FDb.ind_cpptype)
    if (!_db.ind_cpptype_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_cpptype)
    }
    memset(_db.ind_cpptype_buckets_elems, 0, sizeof(amc::FCpptype*)*_db.ind_cpptype_buckets_n); // (amc.FDb.ind_cpptype)
    // initialize LAry inlary (amc.FDb.inlary)
    _db.inlary_n = 0;
    memset(_db.inlary_lary, 0, sizeof(_db.inlary_lary)); // zero out all level pointers
    amc::FInlary* inlary_first = (amc::FInlary*)amc::lpool_AllocMem(sizeof(amc::FInlary) * (u64(1)<<4));
    if (!inlary_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.inlary_lary[i]  = inlary_first;
        inlary_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FInlary;
    _db.ind_inlary_n             	= 0; // (amc.FDb.ind_inlary)
    _db.ind_inlary_buckets_n     	= 4; // (amc.FDb.ind_inlary)
    _db.ind_inlary_buckets_elems 	= (amc::FInlary**)amc::lpool_AllocMem(sizeof(amc::FInlary*)*_db.ind_inlary_buckets_n); // initial buckets (amc.FDb.ind_inlary)
    if (!_db.ind_inlary_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_inlary)
    }
    memset(_db.ind_inlary_buckets_elems, 0, sizeof(amc::FInlary*)*_db.ind_inlary_buckets_n); // (amc.FDb.ind_inlary)
    // initialize LAry tary (amc.FDb.tary)
    _db.tary_n = 0;
    memset(_db.tary_lary, 0, sizeof(_db.tary_lary)); // zero out all level pointers
    amc::FTary* tary_first = (amc::FTary*)amc::lpool_AllocMem(sizeof(amc::FTary) * (u64(1)<<4));
    if (!tary_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tary_lary[i]  = tary_first;
        tary_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FTary;
    _db.ind_tary_n             	= 0; // (amc.FDb.ind_tary)
    _db.ind_tary_buckets_n     	= 4; // (amc.FDb.ind_tary)
    _db.ind_tary_buckets_elems 	= (amc::FTary**)amc::lpool_AllocMem(sizeof(amc::FTary*)*_db.ind_tary_buckets_n); // initial buckets (amc.FDb.ind_tary)
    if (!_db.ind_tary_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_tary)
    }
    memset(_db.ind_tary_buckets_elems, 0, sizeof(amc::FTary*)*_db.ind_tary_buckets_n); // (amc.FDb.ind_tary)
    // initialize LAry cppfunc (amc.FDb.cppfunc)
    _db.cppfunc_n = 0;
    memset(_db.cppfunc_lary, 0, sizeof(_db.cppfunc_lary)); // zero out all level pointers
    amc::FCppfunc* cppfunc_first = (amc::FCppfunc*)amc::lpool_AllocMem(sizeof(amc::FCppfunc) * (u64(1)<<4));
    if (!cppfunc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cppfunc_lary[i]  = cppfunc_first;
        cppfunc_first    += 1ULL<<i;
    }
    // initialize LAry rowid (amc.FDb.rowid)
    _db.rowid_n = 0;
    memset(_db.rowid_lary, 0, sizeof(_db.rowid_lary)); // zero out all level pointers
    amc::FRowid* rowid_first = (amc::FRowid*)amc::lpool_AllocMem(sizeof(amc::FRowid) * (u64(1)<<4));
    if (!rowid_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.rowid_lary[i]  = rowid_first;
        rowid_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FRowid;
    _db.ind_rowid_n             	= 0; // (amc.FDb.ind_rowid)
    _db.ind_rowid_buckets_n     	= 4; // (amc.FDb.ind_rowid)
    _db.ind_rowid_buckets_elems 	= (amc::FRowid**)amc::lpool_AllocMem(sizeof(amc::FRowid*)*_db.ind_rowid_buckets_n); // initial buckets (amc.FDb.ind_rowid)
    if (!_db.ind_rowid_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_rowid)
    }
    memset(_db.ind_rowid_buckets_elems, 0, sizeof(amc::FRowid*)*_db.ind_rowid_buckets_n); // (amc.FDb.ind_rowid)
    // initialize LAry cascdel (amc.FDb.cascdel)
    _db.cascdel_n = 0;
    memset(_db.cascdel_lary, 0, sizeof(_db.cascdel_lary)); // zero out all level pointers
    amc::FCascdel* cascdel_first = (amc::FCascdel*)amc::lpool_AllocMem(sizeof(amc::FCascdel) * (u64(1)<<4));
    if (!cascdel_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cascdel_lary[i]  = cascdel_first;
        cascdel_first    += 1ULL<<i;
    }
    // initialize LAry substr (amc.FDb.substr)
    _db.substr_n = 0;
    memset(_db.substr_lary, 0, sizeof(_db.substr_lary)); // zero out all level pointers
    amc::FSubstr* substr_first = (amc::FSubstr*)amc::lpool_AllocMem(sizeof(amc::FSubstr) * (u64(1)<<4));
    if (!substr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.substr_lary[i]  = substr_first;
        substr_first    += 1ULL<<i;
    }
    // initialize LAry bitfld (amc.FDb.bitfld)
    _db.bitfld_n = 0;
    memset(_db.bitfld_lary, 0, sizeof(_db.bitfld_lary)); // zero out all level pointers
    amc::FBitfld* bitfld_first = (amc::FBitfld*)amc::lpool_AllocMem(sizeof(amc::FBitfld) * (u64(1)<<4));
    if (!bitfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.bitfld_lary[i]  = bitfld_first;
        bitfld_first    += 1ULL<<i;
    }
    // initialize LAry ssimfile (amc.FDb.ssimfile)
    _db.ssimfile_n = 0;
    memset(_db.ssimfile_lary, 0, sizeof(_db.ssimfile_lary)); // zero out all level pointers
    amc::FSsimfile* ssimfile_first = (amc::FSsimfile*)amc::lpool_AllocMem(sizeof(amc::FSsimfile) * (u64(1)<<4));
    if (!ssimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimfile_lary[i]  = ssimfile_first;
        ssimfile_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FSsimfile;
    _db.ind_ssimfile_n             	= 0; // (amc.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_n     	= 4; // (amc.FDb.ind_ssimfile)
    _db.ind_ssimfile_buckets_elems 	= (amc::FSsimfile**)amc::lpool_AllocMem(sizeof(amc::FSsimfile*)*_db.ind_ssimfile_buckets_n); // initial buckets (amc.FDb.ind_ssimfile)
    if (!_db.ind_ssimfile_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_ssimfile)
    }
    memset(_db.ind_ssimfile_buckets_elems, 0, sizeof(amc::FSsimfile*)*_db.ind_ssimfile_buckets_n); // (amc.FDb.ind_ssimfile)
    // initialize LAry pack (amc.FDb.pack)
    _db.pack_n = 0;
    memset(_db.pack_lary, 0, sizeof(_db.pack_lary)); // zero out all level pointers
    amc::FPack* pack_first = (amc::FPack*)amc::lpool_AllocMem(sizeof(amc::FPack) * (u64(1)<<4));
    if (!pack_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pack_lary[i]  = pack_first;
        pack_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FPack;
    _db.ind_pack_n             	= 0; // (amc.FDb.ind_pack)
    _db.ind_pack_buckets_n     	= 4; // (amc.FDb.ind_pack)
    _db.ind_pack_buckets_elems 	= (amc::FPack**)amc::lpool_AllocMem(sizeof(amc::FPack*)*_db.ind_pack_buckets_n); // initial buckets (amc.FDb.ind_pack)
    if (!_db.ind_pack_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_pack)
    }
    memset(_db.ind_pack_buckets_elems, 0, sizeof(amc::FPack*)*_db.ind_pack_buckets_n); // (amc.FDb.ind_pack)
    // initialize hash table for amc::FSmallstr;
    _db.ind_smallstr_n             	= 0; // (amc.FDb.ind_smallstr)
    _db.ind_smallstr_buckets_n     	= 4; // (amc.FDb.ind_smallstr)
    _db.ind_smallstr_buckets_elems 	= (amc::FSmallstr**)amc::lpool_AllocMem(sizeof(amc::FSmallstr*)*_db.ind_smallstr_buckets_n); // initial buckets (amc.FDb.ind_smallstr)
    if (!_db.ind_smallstr_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_smallstr)
    }
    memset(_db.ind_smallstr_buckets_elems, 0, sizeof(amc::FSmallstr*)*_db.ind_smallstr_buckets_n); // (amc.FDb.ind_smallstr)
    // initialize LAry ptrary (amc.FDb.ptrary)
    _db.ptrary_n = 0;
    memset(_db.ptrary_lary, 0, sizeof(_db.ptrary_lary)); // zero out all level pointers
    amc::FPtrary* ptrary_first = (amc::FPtrary*)amc::lpool_AllocMem(sizeof(amc::FPtrary) * (u64(1)<<4));
    if (!ptrary_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ptrary_lary[i]  = ptrary_first;
        ptrary_first    += 1ULL<<i;
    }
    _db.c_ctype_sorted_elems = NULL; // (amc.FDb.c_ctype_sorted)
    _db.c_ctype_sorted_n = 0; // (amc.FDb.c_ctype_sorted)
    _db.c_ctype_sorted_max = 0; // (amc.FDb.c_ctype_sorted)
    // initialize LAry enumstr (amc.FDb.enumstr)
    _db.enumstr_n = 0;
    memset(_db.enumstr_lary, 0, sizeof(_db.enumstr_lary)); // zero out all level pointers
    amc::FEnumstr* enumstr_first = (amc::FEnumstr*)amc::lpool_AllocMem(sizeof(amc::FEnumstr) * (u64(1)<<4));
    if (!enumstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.enumstr_lary[i]  = enumstr_first;
        enumstr_first    += 1ULL<<i;
    }
    // initialize LAry enumstr_len (amc.FDb.enumstr_len)
    _db.enumstr_len_n = 0;
    memset(_db.enumstr_len_lary, 0, sizeof(_db.enumstr_len_lary)); // zero out all level pointers
    amc::FEnumstrLen* enumstr_len_first = (amc::FEnumstrLen*)amc::lpool_AllocMem(sizeof(amc::FEnumstrLen) * (u64(1)<<4));
    if (!enumstr_len_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.enumstr_len_lary[i]  = enumstr_len_first;
        enumstr_len_first    += 1ULL<<i;
    }
    _db.bh_enumstr_len_max   	= 0; // (amc.FDb.bh_enumstr_len)
    _db.bh_enumstr_len_n     	= 0; // (amc.FDb.bh_enumstr_len)
    _db.bh_enumstr_len_elems 	= NULL; // (amc.FDb.bh_enumstr_len)
    // initialize hash table for amc::FEnumstrLen;
    _db.ind_enumstr_len_n             	= 0; // (amc.FDb.ind_enumstr_len)
    _db.ind_enumstr_len_buckets_n     	= 4; // (amc.FDb.ind_enumstr_len)
    _db.ind_enumstr_len_buckets_elems 	= (amc::FEnumstrLen**)amc::lpool_AllocMem(sizeof(amc::FEnumstrLen*)*_db.ind_enumstr_len_buckets_n); // initial buckets (amc.FDb.ind_enumstr_len)
    if (!_db.ind_enumstr_len_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_enumstr_len)
    }
    memset(_db.ind_enumstr_len_buckets_elems, 0, sizeof(amc::FEnumstrLen*)*_db.ind_enumstr_len_buckets_n); // (amc.FDb.ind_enumstr_len)
    // initialize hash table for amc::FEnumstr;
    _db.ind_enumstr_n             	= 0; // (amc.FDb.ind_enumstr)
    _db.ind_enumstr_buckets_n     	= 4; // (amc.FDb.ind_enumstr)
    _db.ind_enumstr_buckets_elems 	= (amc::FEnumstr**)amc::lpool_AllocMem(sizeof(amc::FEnumstr*)*_db.ind_enumstr_buckets_n); // initial buckets (amc.FDb.ind_enumstr)
    if (!_db.ind_enumstr_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_enumstr)
    }
    memset(_db.ind_enumstr_buckets_elems, 0, sizeof(amc::FEnumstr*)*_db.ind_enumstr_buckets_n); // (amc.FDb.ind_enumstr)
    // initialize LAry fbitset (amc.FDb.fbitset)
    _db.fbitset_n = 0;
    memset(_db.fbitset_lary, 0, sizeof(_db.fbitset_lary)); // zero out all level pointers
    amc::FFbitset* fbitset_first = (amc::FFbitset*)amc::lpool_AllocMem(sizeof(amc::FFbitset) * (u64(1)<<4));
    if (!fbitset_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fbitset_lary[i]  = fbitset_first;
        fbitset_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFbitset;
    _db.ind_fbitset_n             	= 0; // (amc.FDb.ind_fbitset)
    _db.ind_fbitset_buckets_n     	= 4; // (amc.FDb.ind_fbitset)
    _db.ind_fbitset_buckets_elems 	= (amc::FFbitset**)amc::lpool_AllocMem(sizeof(amc::FFbitset*)*_db.ind_fbitset_buckets_n); // initial buckets (amc.FDb.ind_fbitset)
    if (!_db.ind_fbitset_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fbitset)
    }
    memset(_db.ind_fbitset_buckets_elems, 0, sizeof(amc::FFbitset*)*_db.ind_fbitset_buckets_n); // (amc.FDb.ind_fbitset)
    // initialize LAry fcleanup (amc.FDb.fcleanup)
    _db.fcleanup_n = 0;
    memset(_db.fcleanup_lary, 0, sizeof(_db.fcleanup_lary)); // zero out all level pointers
    amc::FFcleanup* fcleanup_first = (amc::FFcleanup*)amc::lpool_AllocMem(sizeof(amc::FFcleanup) * (u64(1)<<4));
    if (!fcleanup_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcleanup_lary[i]  = fcleanup_first;
        fcleanup_first    += 1ULL<<i;
    }
    // initialize LAry fdec (amc.FDb.fdec)
    _db.fdec_n = 0;
    memset(_db.fdec_lary, 0, sizeof(_db.fdec_lary)); // zero out all level pointers
    amc::FFdec* fdec_first = (amc::FFdec*)amc::lpool_AllocMem(sizeof(amc::FFdec) * (u64(1)<<4));
    if (!fdec_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fdec_lary[i]  = fdec_first;
        fdec_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFdec;
    _db.ind_fdec_n             	= 0; // (amc.FDb.ind_fdec)
    _db.ind_fdec_buckets_n     	= 4; // (amc.FDb.ind_fdec)
    _db.ind_fdec_buckets_elems 	= (amc::FFdec**)amc::lpool_AllocMem(sizeof(amc::FFdec*)*_db.ind_fdec_buckets_n); // initial buckets (amc.FDb.ind_fdec)
    if (!_db.ind_fdec_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fdec)
    }
    memset(_db.ind_fdec_buckets_elems, 0, sizeof(amc::FFdec*)*_db.ind_fdec_buckets_n); // (amc.FDb.ind_fdec)
    // initialize hash table for amc::FReftype;
    _db.ind_reftype_n             	= 0; // (amc.FDb.ind_reftype)
    _db.ind_reftype_buckets_n     	= 4; // (amc.FDb.ind_reftype)
    _db.ind_reftype_buckets_elems 	= (amc::FReftype**)amc::lpool_AllocMem(sizeof(amc::FReftype*)*_db.ind_reftype_buckets_n); // initial buckets (amc.FDb.ind_reftype)
    if (!_db.ind_reftype_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_reftype)
    }
    memset(_db.ind_reftype_buckets_elems, 0, sizeof(amc::FReftype*)*_db.ind_reftype_buckets_n); // (amc.FDb.ind_reftype)
    // initialize LAry fconst (amc.FDb.fconst)
    _db.fconst_n = 0;
    memset(_db.fconst_lary, 0, sizeof(_db.fconst_lary)); // zero out all level pointers
    amc::FFconst* fconst_first = (amc::FFconst*)amc::lpool_AllocMem(sizeof(amc::FFconst) * (u64(1)<<4));
    if (!fconst_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fconst_lary[i]  = fconst_first;
        fconst_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFconst;
    _db.ind_fconst_n             	= 0; // (amc.FDb.ind_fconst)
    _db.ind_fconst_buckets_n     	= 4; // (amc.FDb.ind_fconst)
    _db.ind_fconst_buckets_elems 	= (amc::FFconst**)amc::lpool_AllocMem(sizeof(amc::FFconst*)*_db.ind_fconst_buckets_n); // initial buckets (amc.FDb.ind_fconst)
    if (!_db.ind_fconst_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fconst)
    }
    memset(_db.ind_fconst_buckets_elems, 0, sizeof(amc::FFconst*)*_db.ind_fconst_buckets_n); // (amc.FDb.ind_fconst)
    _db.c_ns_sorted_elems = NULL; // (amc.FDb.c_ns_sorted)
    _db.c_ns_sorted_n = 0; // (amc.FDb.c_ns_sorted)
    _db.c_ns_sorted_max = 0; // (amc.FDb.c_ns_sorted)
    // initialize LAry finput (amc.FDb.finput)
    _db.finput_n = 0;
    memset(_db.finput_lary, 0, sizeof(_db.finput_lary)); // zero out all level pointers
    amc::FFinput* finput_first = (amc::FFinput*)amc::lpool_AllocMem(sizeof(amc::FFinput) * (u64(1)<<4));
    if (!finput_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.finput_lary[i]  = finput_first;
        finput_first    += 1ULL<<i;
    }
    // initialize LAry foutput (amc.FDb.foutput)
    _db.foutput_n = 0;
    memset(_db.foutput_lary, 0, sizeof(_db.foutput_lary)); // zero out all level pointers
    amc::FFoutput* foutput_first = (amc::FFoutput*)amc::lpool_AllocMem(sizeof(amc::FFoutput) * (u64(1)<<4));
    if (!foutput_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.foutput_lary[i]  = foutput_first;
        foutput_first    += 1ULL<<i;
    }
    // initialize LAry fbuf (amc.FDb.fbuf)
    _db.fbuf_n = 0;
    memset(_db.fbuf_lary, 0, sizeof(_db.fbuf_lary)); // zero out all level pointers
    amc::FFbuf* fbuf_first = (amc::FFbuf*)amc::lpool_AllocMem(sizeof(amc::FFbuf) * (u64(1)<<4));
    if (!fbuf_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fbuf_lary[i]  = fbuf_first;
        fbuf_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFbuf;
    _db.ind_fbuf_n             	= 0; // (amc.FDb.ind_fbuf)
    _db.ind_fbuf_buckets_n     	= 4; // (amc.FDb.ind_fbuf)
    _db.ind_fbuf_buckets_elems 	= (amc::FFbuf**)amc::lpool_AllocMem(sizeof(amc::FFbuf*)*_db.ind_fbuf_buckets_n); // initial buckets (amc.FDb.ind_fbuf)
    if (!_db.ind_fbuf_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fbuf)
    }
    memset(_db.ind_fbuf_buckets_elems, 0, sizeof(amc::FFbuf*)*_db.ind_fbuf_buckets_n); // (amc.FDb.ind_fbuf)
    // initialize LAry chash (amc.FDb.chash)
    _db.chash_n = 0;
    memset(_db.chash_lary, 0, sizeof(_db.chash_lary)); // zero out all level pointers
    amc::FChash* chash_first = (amc::FChash*)amc::lpool_AllocMem(sizeof(amc::FChash) * (u64(1)<<4));
    if (!chash_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.chash_lary[i]  = chash_first;
        chash_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FChash;
    _db.ind_chash_n             	= 0; // (amc.FDb.ind_chash)
    _db.ind_chash_buckets_n     	= 4; // (amc.FDb.ind_chash)
    _db.ind_chash_buckets_elems 	= (amc::FChash**)amc::lpool_AllocMem(sizeof(amc::FChash*)*_db.ind_chash_buckets_n); // initial buckets (amc.FDb.ind_chash)
    if (!_db.ind_chash_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_chash)
    }
    memset(_db.ind_chash_buckets_elems, 0, sizeof(amc::FChash*)*_db.ind_chash_buckets_n); // (amc.FDb.ind_chash)
    // initialize LAry ccmp (amc.FDb.ccmp)
    _db.ccmp_n = 0;
    memset(_db.ccmp_lary, 0, sizeof(_db.ccmp_lary)); // zero out all level pointers
    amc::FCcmp* ccmp_first = (amc::FCcmp*)amc::lpool_AllocMem(sizeof(amc::FCcmp) * (u64(1)<<4));
    if (!ccmp_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ccmp_lary[i]  = ccmp_first;
        ccmp_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FCcmp;
    _db.ind_ccmp_n             	= 0; // (amc.FDb.ind_ccmp)
    _db.ind_ccmp_buckets_n     	= 4; // (amc.FDb.ind_ccmp)
    _db.ind_ccmp_buckets_elems 	= (amc::FCcmp**)amc::lpool_AllocMem(sizeof(amc::FCcmp*)*_db.ind_ccmp_buckets_n); // initial buckets (amc.FDb.ind_ccmp)
    if (!_db.ind_ccmp_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_ccmp)
    }
    memset(_db.ind_ccmp_buckets_elems, 0, sizeof(amc::FCcmp*)*_db.ind_ccmp_buckets_n); // (amc.FDb.ind_ccmp)
    // initialize LAry fbigend (amc.FDb.fbigend)
    _db.fbigend_n = 0;
    memset(_db.fbigend_lary, 0, sizeof(_db.fbigend_lary)); // zero out all level pointers
    amc::FFbigend* fbigend_first = (amc::FFbigend*)amc::lpool_AllocMem(sizeof(amc::FFbigend) * (u64(1)<<4));
    if (!fbigend_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fbigend_lary[i]  = fbigend_first;
        fbigend_first    += 1ULL<<i;
    }
    _db.zsl_ctype_pack_tran_head = NULL; // (amc.FDb.zsl_ctype_pack_tran)
    // initialize LAry cstr (amc.FDb.cstr)
    _db.cstr_n = 0;
    memset(_db.cstr_lary, 0, sizeof(_db.cstr_lary)); // zero out all level pointers
    amc::FCstr* cstr_first = (amc::FCstr*)amc::lpool_AllocMem(sizeof(amc::FCstr) * (u64(1)<<4));
    if (!cstr_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cstr_lary[i]  = cstr_first;
        cstr_first    += 1ULL<<i;
    }
    // initialize LAry listtype (amc.FDb.listtype)
    _db.listtype_n = 0;
    memset(_db.listtype_lary, 0, sizeof(_db.listtype_lary)); // zero out all level pointers
    amc::FListtype* listtype_first = (amc::FListtype*)amc::lpool_AllocMem(sizeof(amc::FListtype) * (u64(1)<<4));
    if (!listtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.listtype_lary[i]  = listtype_first;
        listtype_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FListtype;
    _db.ind_listtype_n             	= 0; // (amc.FDb.ind_listtype)
    _db.ind_listtype_buckets_n     	= 4; // (amc.FDb.ind_listtype)
    _db.ind_listtype_buckets_elems 	= (amc::FListtype**)amc::lpool_AllocMem(sizeof(amc::FListtype*)*_db.ind_listtype_buckets_n); // initial buckets (amc.FDb.ind_listtype)
    if (!_db.ind_listtype_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_listtype)
    }
    memset(_db.ind_listtype_buckets_elems, 0, sizeof(amc::FListtype*)*_db.ind_listtype_buckets_n); // (amc.FDb.ind_listtype)
    // initialize LAry fstep (amc.FDb.fstep)
    _db.fstep_n = 0;
    memset(_db.fstep_lary, 0, sizeof(_db.fstep_lary)); // zero out all level pointers
    amc::FFstep* fstep_first = (amc::FFstep*)amc::lpool_AllocMem(sizeof(amc::FFstep) * (u64(1)<<4));
    if (!fstep_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fstep_lary[i]  = fstep_first;
        fstep_first    += 1ULL<<i;
    }
    // initialize LAry cextern (amc.FDb.cextern)
    _db.cextern_n = 0;
    memset(_db.cextern_lary, 0, sizeof(_db.cextern_lary)); // zero out all level pointers
    amc::FCextern* cextern_first = (amc::FCextern*)amc::lpool_AllocMem(sizeof(amc::FCextern) * (u64(1)<<4));
    if (!cextern_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cextern_lary[i]  = cextern_first;
        cextern_first    += 1ULL<<i;
    }
    // initialize LAry fdelay (amc.FDb.fdelay)
    _db.fdelay_n = 0;
    memset(_db.fdelay_lary, 0, sizeof(_db.fdelay_lary)); // zero out all level pointers
    amc::FFdelay* fdelay_first = (amc::FFdelay*)amc::lpool_AllocMem(sizeof(amc::FFdelay) * (u64(1)<<4));
    if (!fdelay_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fdelay_lary[i]  = fdelay_first;
        fdelay_first    += 1ULL<<i;
    }
    // initialize LAry disptrace (amc.FDb.disptrace)
    _db.disptrace_n = 0;
    memset(_db.disptrace_lary, 0, sizeof(_db.disptrace_lary)); // zero out all level pointers
    amc::FDisptrace* disptrace_first = (amc::FDisptrace*)amc::lpool_AllocMem(sizeof(amc::FDisptrace) * (u64(1)<<4));
    if (!disptrace_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.disptrace_lary[i]  = disptrace_first;
        disptrace_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFstep;
    _db.ind_fstep_n             	= 0; // (amc.FDb.ind_fstep)
    _db.ind_fstep_buckets_n     	= 4; // (amc.FDb.ind_fstep)
    _db.ind_fstep_buckets_elems 	= (amc::FFstep**)amc::lpool_AllocMem(sizeof(amc::FFstep*)*_db.ind_fstep_buckets_n); // initial buckets (amc.FDb.ind_fstep)
    if (!_db.ind_fstep_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fstep)
    }
    memset(_db.ind_fstep_buckets_elems, 0, sizeof(amc::FFstep*)*_db.ind_fstep_buckets_n); // (amc.FDb.ind_fstep)
    // initialize LAry tracefld (amc.FDb.tracefld)
    _db.tracefld_n = 0;
    memset(_db.tracefld_lary, 0, sizeof(_db.tracefld_lary)); // zero out all level pointers
    amc::FTracefld* tracefld_first = (amc::FTracefld*)amc::lpool_AllocMem(sizeof(amc::FTracefld) * (u64(1)<<4));
    if (!tracefld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tracefld_lary[i]  = tracefld_first;
        tracefld_first    += 1ULL<<i;
    }
    // initialize LAry tracerec (amc.FDb.tracerec)
    _db.tracerec_n = 0;
    memset(_db.tracerec_lary, 0, sizeof(_db.tracerec_lary)); // zero out all level pointers
    amc::FTracerec* tracerec_first = (amc::FTracerec*)amc::lpool_AllocMem(sizeof(amc::FTracerec) * (u64(1)<<4));
    if (!tracerec_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tracerec_lary[i]  = tracerec_first;
        tracerec_first    += 1ULL<<i;
    }
    // initialize LAry dispsig (amc.FDb.dispsig)
    _db.dispsig_n = 0;
    memset(_db.dispsig_lary, 0, sizeof(_db.dispsig_lary)); // zero out all level pointers
    amc::FDispsig* dispsig_first = (amc::FDispsig*)amc::lpool_AllocMem(sizeof(amc::FDispsig) * (u64(1)<<4));
    if (!dispsig_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispsig_lary[i]  = dispsig_first;
        dispsig_first    += 1ULL<<i;
    }
    _db.c_dispsig_sorted_elems = NULL; // (amc.FDb.c_dispsig_sorted)
    _db.c_dispsig_sorted_n = 0; // (amc.FDb.c_dispsig_sorted)
    _db.c_dispsig_sorted_max = 0; // (amc.FDb.c_dispsig_sorted)
    _db.zs_sig_visit_head = NULL; // (amc.FDb.zs_sig_visit)
    _db.zs_sig_visit_tail = NULL; // (amc.FDb.zs_sig_visit)
    // initialize LAry target (amc.FDb.target)
    _db.target_n = 0;
    memset(_db.target_lary, 0, sizeof(_db.target_lary)); // zero out all level pointers
    amc::FTarget* target_first = (amc::FTarget*)amc::lpool_AllocMem(sizeof(amc::FTarget) * (u64(1)<<4));
    if (!target_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.target_lary[i]  = target_first;
        target_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FTarget;
    _db.ind_target_n             	= 0; // (amc.FDb.ind_target)
    _db.ind_target_buckets_n     	= 4; // (amc.FDb.ind_target)
    _db.ind_target_buckets_elems 	= (amc::FTarget**)amc::lpool_AllocMem(sizeof(amc::FTarget*)*_db.ind_target_buckets_n); // initial buckets (amc.FDb.ind_target)
    if (!_db.ind_target_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_target)
    }
    memset(_db.ind_target_buckets_elems, 0, sizeof(amc::FTarget*)*_db.ind_target_buckets_n); // (amc.FDb.ind_target)
    // initialize LAry targdep (amc.FDb.targdep)
    _db.targdep_n = 0;
    memset(_db.targdep_lary, 0, sizeof(_db.targdep_lary)); // zero out all level pointers
    amc::FTargdep* targdep_first = (amc::FTargdep*)amc::lpool_AllocMem(sizeof(amc::FTargdep) * (u64(1)<<4));
    if (!targdep_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.targdep_lary[i]  = targdep_first;
        targdep_first    += 1ULL<<i;
    }
    _db.c_malloc = NULL;
    // initialize LAry dispctx (amc.FDb.dispctx)
    _db.dispctx_n = 0;
    memset(_db.dispctx_lary, 0, sizeof(_db.dispctx_lary)); // zero out all level pointers
    amc::FDispctx* dispctx_first = (amc::FDispctx*)amc::lpool_AllocMem(sizeof(amc::FDispctx) * (u64(1)<<4));
    if (!dispctx_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.dispctx_lary[i]  = dispctx_first;
        dispctx_first    += 1ULL<<i;
    }
    // initialize LAry pmaskfld (amc.FDb.pmaskfld)
    _db.pmaskfld_n = 0;
    memset(_db.pmaskfld_lary, 0, sizeof(_db.pmaskfld_lary)); // zero out all level pointers
    amc::FPmaskfld* pmaskfld_first = (amc::FPmaskfld*)amc::lpool_AllocMem(sizeof(amc::FPmaskfld) * (u64(1)<<4));
    if (!pmaskfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.pmaskfld_lary[i]  = pmaskfld_first;
        pmaskfld_first    += 1ULL<<i;
    }
    // initialize LAry fwddecl (amc.FDb.fwddecl)
    _db.fwddecl_n = 0;
    memset(_db.fwddecl_lary, 0, sizeof(_db.fwddecl_lary)); // zero out all level pointers
    amc::FFwddecl* fwddecl_first = (amc::FFwddecl*)amc::lpool_AllocMem(sizeof(amc::FFwddecl) * (u64(1)<<4));
    if (!fwddecl_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fwddecl_lary[i]  = fwddecl_first;
        fwddecl_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFwddecl;
    _db.ind_fwddecl_n             	= 0; // (amc.FDb.ind_fwddecl)
    _db.ind_fwddecl_buckets_n     	= 4; // (amc.FDb.ind_fwddecl)
    _db.ind_fwddecl_buckets_elems 	= (amc::FFwddecl**)amc::lpool_AllocMem(sizeof(amc::FFwddecl*)*_db.ind_fwddecl_buckets_n); // initial buckets (amc.FDb.ind_fwddecl)
    if (!_db.ind_fwddecl_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fwddecl)
    }
    memset(_db.ind_fwddecl_buckets_elems, 0, sizeof(amc::FFwddecl*)*_db.ind_fwddecl_buckets_n); // (amc.FDb.ind_fwddecl)
    // initialize LAry tfunc (amc.FDb.tfunc)
    _db.tfunc_n = 0;
    memset(_db.tfunc_lary, 0, sizeof(_db.tfunc_lary)); // zero out all level pointers
    amc::FTfunc* tfunc_first = (amc::FTfunc*)amc::lpool_AllocMem(sizeof(amc::FTfunc) * (u64(1)<<4));
    if (!tfunc_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tfunc_lary[i]  = tfunc_first;
        tfunc_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FTfunc;
    _db.ind_tfunc_n             	= 0; // (amc.FDb.ind_tfunc)
    _db.ind_tfunc_buckets_n     	= 4; // (amc.FDb.ind_tfunc)
    _db.ind_tfunc_buckets_elems 	= (amc::FTfunc**)amc::lpool_AllocMem(sizeof(amc::FTfunc*)*_db.ind_tfunc_buckets_n); // initial buckets (amc.FDb.ind_tfunc)
    if (!_db.ind_tfunc_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_tfunc)
    }
    memset(_db.ind_tfunc_buckets_elems, 0, sizeof(amc::FTfunc*)*_db.ind_tfunc_buckets_n); // (amc.FDb.ind_tfunc)
    // initialize LAry gen (amc.FDb.gen)
    _db.gen_n = 0;
    memset(_db.gen_lary, 0, sizeof(_db.gen_lary)); // zero out all level pointers
    amc::FGen* gen_first = (amc::FGen*)amc::lpool_AllocMem(sizeof(amc::FGen) * (u64(1)<<4));
    if (!gen_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gen_lary[i]  = gen_first;
        gen_first    += 1ULL<<i;
    }
    _db.c_curns = NULL;
    // initialize LAry fregx (amc.FDb.fregx)
    _db.fregx_n = 0;
    memset(_db.fregx_lary, 0, sizeof(_db.fregx_lary)); // zero out all level pointers
    amc::FFregx* fregx_first = (amc::FFregx*)amc::lpool_AllocMem(sizeof(amc::FFregx) * (u64(1)<<4));
    if (!fregx_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fregx_lary[i]  = fregx_first;
        fregx_first    += 1ULL<<i;
    }
    _db.tclass_n = 0; // tclass: initialize count
    // initialize hash table for amc::FTclass;
    _db.ind_tclass_n             	= 0; // (amc.FDb.ind_tclass)
    _db.ind_tclass_buckets_n     	= 4; // (amc.FDb.ind_tclass)
    _db.ind_tclass_buckets_elems 	= (amc::FTclass**)amc::lpool_AllocMem(sizeof(amc::FTclass*)*_db.ind_tclass_buckets_n); // initial buckets (amc.FDb.ind_tclass)
    if (!_db.ind_tclass_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_tclass)
    }
    memset(_db.ind_tclass_buckets_elems, 0, sizeof(amc::FTclass*)*_db.ind_tclass_buckets_n); // (amc.FDb.ind_tclass)
    // initialize LAry fcmp (amc.FDb.fcmp)
    _db.fcmp_n = 0;
    memset(_db.fcmp_lary, 0, sizeof(_db.fcmp_lary)); // zero out all level pointers
    amc::FFcmp* fcmp_first = (amc::FFcmp*)amc::lpool_AllocMem(sizeof(amc::FFcmp) * (u64(1)<<4));
    if (!fcmp_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcmp_lary[i]  = fcmp_first;
        fcmp_first    += 1ULL<<i;
    }
    // initialize LAry fcast (amc.FDb.fcast)
    _db.fcast_n = 0;
    memset(_db.fcast_lary, 0, sizeof(_db.fcast_lary)); // zero out all level pointers
    amc::FFcast* fcast_first = (amc::FFcast*)amc::lpool_AllocMem(sizeof(amc::FFcast) * (u64(1)<<4));
    if (!fcast_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcast_lary[i]  = fcast_first;
        fcast_first    += 1ULL<<i;
    }
    // initialize LAry noxref (amc.FDb.noxref)
    _db.noxref_n = 0;
    memset(_db.noxref_lary, 0, sizeof(_db.noxref_lary)); // zero out all level pointers
    amc::FNoxref* noxref_first = (amc::FNoxref*)amc::lpool_AllocMem(sizeof(amc::FNoxref) * (u64(1)<<4));
    if (!noxref_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.noxref_lary[i]  = noxref_first;
        noxref_first    += 1ULL<<i;
    }
    // initialize LAry nocascdel (amc.FDb.nocascdel)
    _db.nocascdel_n = 0;
    memset(_db.nocascdel_lary, 0, sizeof(_db.nocascdel_lary)); // zero out all level pointers
    amc::FNocascdel* nocascdel_first = (amc::FNocascdel*)amc::lpool_AllocMem(sizeof(amc::FNocascdel) * (u64(1)<<4));
    if (!nocascdel_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nocascdel_lary[i]  = nocascdel_first;
        nocascdel_first    += 1ULL<<i;
    }
    // initialize LAry cafter (amc.FDb.cafter)
    _db.cafter_n = 0;
    memset(_db.cafter_lary, 0, sizeof(_db.cafter_lary)); // zero out all level pointers
    amc::FCafter* cafter_first = (amc::FCafter*)amc::lpool_AllocMem(sizeof(amc::FCafter) * (u64(1)<<4));
    if (!cafter_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cafter_lary[i]  = cafter_first;
        cafter_first    += 1ULL<<i;
    }
    // initialize LAry csize (amc.FDb.csize)
    _db.csize_n = 0;
    memset(_db.csize_lary, 0, sizeof(_db.csize_lary)); // zero out all level pointers
    amc::FCsize* csize_first = (amc::FCsize*)amc::lpool_AllocMem(sizeof(amc::FCsize) * (u64(1)<<4));
    if (!csize_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.csize_lary[i]  = csize_first;
        csize_first    += 1ULL<<i;
    }
    // initialize LAry nsx (amc.FDb.nsx)
    _db.nsx_n = 0;
    memset(_db.nsx_lary, 0, sizeof(_db.nsx_lary)); // zero out all level pointers
    amc::FNsx* nsx_first = (amc::FNsx*)amc::lpool_AllocMem(sizeof(amc::FNsx) * (u64(1)<<4));
    if (!nsx_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nsx_lary[i]  = nsx_first;
        nsx_first    += 1ULL<<i;
    }
    // initialize LAry fcompact (amc.FDb.fcompact)
    _db.fcompact_n = 0;
    memset(_db.fcompact_lary, 0, sizeof(_db.fcompact_lary)); // zero out all level pointers
    amc::FFcompact* fcompact_first = (amc::FFcompact*)amc::lpool_AllocMem(sizeof(amc::FFcompact) * (u64(1)<<4));
    if (!fcompact_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcompact_lary[i]  = fcompact_first;
        fcompact_first    += 1ULL<<i;
    }
    // initialize LAry findrem (amc.FDb.findrem)
    _db.findrem_n = 0;
    memset(_db.findrem_lary, 0, sizeof(_db.findrem_lary)); // zero out all level pointers
    amc::FFindrem* findrem_first = (amc::FFindrem*)amc::lpool_AllocMem(sizeof(amc::FFindrem) * (u64(1)<<4));
    if (!findrem_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.findrem_lary[i]  = findrem_first;
        findrem_first    += 1ULL<<i;
    }
    // initialize LAry fcurs (amc.FDb.fcurs)
    _db.fcurs_n = 0;
    memset(_db.fcurs_lary, 0, sizeof(_db.fcurs_lary)); // zero out all level pointers
    amc::FFcurs* fcurs_first = (amc::FFcurs*)amc::lpool_AllocMem(sizeof(amc::FFcurs) * (u64(1)<<4));
    if (!fcurs_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcurs_lary[i]  = fcurs_first;
        fcurs_first    += 1ULL<<i;
    }
    // initialize LAry cdflt (amc.FDb.cdflt)
    _db.cdflt_n = 0;
    memset(_db.cdflt_lary, 0, sizeof(_db.cdflt_lary)); // zero out all level pointers
    amc::FCdflt* cdflt_first = (amc::FCdflt*)amc::lpool_AllocMem(sizeof(amc::FCdflt) * (u64(1)<<4));
    if (!cdflt_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cdflt_lary[i]  = cdflt_first;
        cdflt_first    += 1ULL<<i;
    }
    // initialize LAry argvtype (amc.FDb.argvtype)
    _db.argvtype_n = 0;
    memset(_db.argvtype_lary, 0, sizeof(_db.argvtype_lary)); // zero out all level pointers
    amc::FArgvtype* argvtype_first = (amc::FArgvtype*)amc::lpool_AllocMem(sizeof(amc::FArgvtype) * (u64(1)<<4));
    if (!argvtype_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.argvtype_lary[i]  = argvtype_first;
        argvtype_first    += 1ULL<<i;
    }
    // initialize LAry fcmdline (amc.FDb.fcmdline)
    _db.fcmdline_n = 0;
    memset(_db.fcmdline_lary, 0, sizeof(_db.fcmdline_lary)); // zero out all level pointers
    amc::FFcmdline* fcmdline_first = (amc::FFcmdline*)amc::lpool_AllocMem(sizeof(amc::FFcmdline) * (u64(1)<<4));
    if (!fcmdline_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcmdline_lary[i]  = fcmdline_first;
        fcmdline_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FMain;
    _db.ind_main_n             	= 0; // (amc.FDb.ind_main)
    _db.ind_main_buckets_n     	= 4; // (amc.FDb.ind_main)
    _db.ind_main_buckets_elems 	= (amc::FMain**)amc::lpool_AllocMem(sizeof(amc::FMain*)*_db.ind_main_buckets_n); // initial buckets (amc.FDb.ind_main)
    if (!_db.ind_main_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_main)
    }
    memset(_db.ind_main_buckets_elems, 0, sizeof(amc::FMain*)*_db.ind_main_buckets_n); // (amc.FDb.ind_main)
    // initialize LAry floadtuples (amc.FDb.floadtuples)
    _db.floadtuples_n = 0;
    memset(_db.floadtuples_lary, 0, sizeof(_db.floadtuples_lary)); // zero out all level pointers
    amc::FFloadtuples* floadtuples_first = (amc::FFloadtuples*)amc::lpool_AllocMem(sizeof(amc::FFloadtuples) * (u64(1)<<4));
    if (!floadtuples_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.floadtuples_lary[i]  = floadtuples_first;
        floadtuples_first    += 1ULL<<i;
    }
    // initialize LAry fcmap (amc.FDb.fcmap)
    _db.fcmap_n = 0;
    memset(_db.fcmap_lary, 0, sizeof(_db.fcmap_lary)); // zero out all level pointers
    amc::FFcmap* fcmap_first = (amc::FFcmap*)amc::lpool_AllocMem(sizeof(amc::FFcmap) * (u64(1)<<4));
    if (!fcmap_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fcmap_lary[i]  = fcmap_first;
        fcmap_first    += 1ULL<<i;
    }
    _db.lim_ind_func = u32(0);
    _db.zs_ordkeyfield_head = NULL; // (amc.FDb.zs_ordkeyfield)
    _db.zs_ordkeyfield_tail = NULL; // (amc.FDb.zs_ordkeyfield)
    // initialize LAry nsproto (amc.FDb.nsproto)
    _db.nsproto_n = 0;
    memset(_db.nsproto_lary, 0, sizeof(_db.nsproto_lary)); // zero out all level pointers
    amc::FNsproto* nsproto_first = (amc::FNsproto*)amc::lpool_AllocMem(sizeof(amc::FNsproto) * (u64(1)<<4));
    if (!nsproto_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nsproto_lary[i]  = nsproto_first;
        nsproto_first    += 1ULL<<i;
    }
    // initialize LAry nsdb (amc.FDb.nsdb)
    _db.nsdb_n = 0;
    memset(_db.nsdb_lary, 0, sizeof(_db.nsdb_lary)); // zero out all level pointers
    amc::FNsdb* nsdb_first = (amc::FNsdb*)amc::lpool_AllocMem(sizeof(amc::FNsdb) * (u64(1)<<4));
    if (!nsdb_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nsdb_lary[i]  = nsdb_first;
        nsdb_first    += 1ULL<<i;
    }
    _db.zd_substr_params_head = NULL; // (amc.FDb.zd_substr_params)
    _db.zd_substr_params_n = 0; // (amc.FDb.zd_substr_params)
    _db.zd_substr_params_tail = NULL; // (amc.FDb.zd_substr_params)
    // initialize hash table for amc::FFconst;
    _db.ind_fconst_int_n             	= 0; // (amc.FDb.ind_fconst_int)
    _db.ind_fconst_int_buckets_n     	= 4; // (amc.FDb.ind_fconst_int)
    _db.ind_fconst_int_buckets_elems 	= (amc::FFconst**)amc::lpool_AllocMem(sizeof(amc::FFconst*)*_db.ind_fconst_int_buckets_n); // initial buckets (amc.FDb.ind_fconst_int)
    if (!_db.ind_fconst_int_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fconst_int)
    }
    memset(_db.ind_fconst_int_buckets_elems, 0, sizeof(amc::FFconst*)*_db.ind_fconst_int_buckets_n); // (amc.FDb.ind_fconst_int)
    // initialize LAry fprefix (amc.FDb.fprefix)
    _db.fprefix_n = 0;
    memset(_db.fprefix_lary, 0, sizeof(_db.fprefix_lary)); // zero out all level pointers
    amc::FFprefix* fprefix_first = (amc::FFprefix*)amc::lpool_AllocMem(sizeof(amc::FFprefix) * (u64(1)<<4));
    if (!fprefix_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fprefix_lary[i]  = fprefix_first;
        fprefix_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFprefix;
    _db.ind_prefix_n             	= 0; // (amc.FDb.ind_prefix)
    _db.ind_prefix_buckets_n     	= 4; // (amc.FDb.ind_prefix)
    _db.ind_prefix_buckets_elems 	= (amc::FFprefix**)amc::lpool_AllocMem(sizeof(amc::FFprefix*)*_db.ind_prefix_buckets_n); // initial buckets (amc.FDb.ind_prefix)
    if (!_db.ind_prefix_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_prefix)
    }
    memset(_db.ind_prefix_buckets_elems, 0, sizeof(amc::FFprefix*)*_db.ind_prefix_buckets_n); // (amc.FDb.ind_prefix)
    // initialize LAry ftrace (amc.FDb.ftrace)
    _db.ftrace_n = 0;
    memset(_db.ftrace_lary, 0, sizeof(_db.ftrace_lary)); // zero out all level pointers
    amc::FFtrace* ftrace_first = (amc::FFtrace*)amc::lpool_AllocMem(sizeof(amc::FFtrace) * (u64(1)<<4));
    if (!ftrace_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ftrace_lary[i]  = ftrace_first;
        ftrace_first    += 1ULL<<i;
    }
    _db.c_ns = NULL;
    // initialize LAry fnoremove (amc.FDb.fnoremove)
    _db.fnoremove_n = 0;
    memset(_db.fnoremove_lary, 0, sizeof(_db.fnoremove_lary)); // zero out all level pointers
    amc::FFnoremove* fnoremove_first = (amc::FFnoremove*)amc::lpool_AllocMem(sizeof(amc::FFnoremove) * (u64(1)<<4));
    if (!fnoremove_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fnoremove_lary[i]  = fnoremove_first;
        fnoremove_first    += 1ULL<<i;
    }
    _db.c_substr_field_elems = NULL; // (amc.FDb.c_substr_field)
    _db.c_substr_field_n = 0; // (amc.FDb.c_substr_field)
    _db.c_substr_field_max = 0; // (amc.FDb.c_substr_field)
    // initialize LAry ctypelen (amc.FDb.ctypelen)
    _db.ctypelen_n = 0;
    memset(_db.ctypelen_lary, 0, sizeof(_db.ctypelen_lary)); // zero out all level pointers
    amc::FCtypelen* ctypelen_first = (amc::FCtypelen*)amc::lpool_AllocMem(sizeof(amc::FCtypelen) * (u64(1)<<4));
    if (!ctypelen_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ctypelen_lary[i]  = ctypelen_first;
        ctypelen_first    += 1ULL<<i;
    }
    _db.c_ctypelen_elems = NULL; // (amc.FDb.c_ctypelen)
    _db.c_ctypelen_n = 0; // (amc.FDb.c_ctypelen)
    _db.c_ctypelen_max = 0; // (amc.FDb.c_ctypelen)
    _db.c_u64 = NULL;
    _db.c_tempfield_elems = NULL; // (amc.FDb.c_tempfield)
    _db.c_tempfield_n = 0; // (amc.FDb.c_tempfield)
    _db.c_tempfield_max = 0; // (amc.FDb.c_tempfield)
    // initialize LAry fbase (amc.FDb.fbase)
    _db.fbase_n = 0;
    memset(_db.fbase_lary, 0, sizeof(_db.fbase_lary)); // zero out all level pointers
    amc::FFbase* fbase_first = (amc::FFbase*)amc::lpool_AllocMem(sizeof(amc::FFbase) * (u64(1)<<4));
    if (!fbase_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fbase_lary[i]  = fbase_first;
        fbase_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFcmap;
    _db.ind_fcmap_n             	= 0; // (amc.FDb.ind_fcmap)
    _db.ind_fcmap_buckets_n     	= 4; // (amc.FDb.ind_fcmap)
    _db.ind_fcmap_buckets_elems 	= (amc::FFcmap**)amc::lpool_AllocMem(sizeof(amc::FFcmap*)*_db.ind_fcmap_buckets_n); // initial buckets (amc.FDb.ind_fcmap)
    if (!_db.ind_fcmap_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fcmap)
    }
    memset(_db.ind_fcmap_buckets_elems, 0, sizeof(amc::FFcmap*)*_db.ind_fcmap_buckets_n); // (amc.FDb.ind_fcmap)
    // initialize LAry nossimfile (amc.FDb.nossimfile)
    _db.nossimfile_n = 0;
    memset(_db.nossimfile_lary, 0, sizeof(_db.nossimfile_lary)); // zero out all level pointers
    amc::FNossimfile* nossimfile_first = (amc::FNossimfile*)amc::lpool_AllocMem(sizeof(amc::FNossimfile) * (u64(1)<<4));
    if (!nossimfile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nossimfile_lary[i]  = nossimfile_first;
        nossimfile_first    += 1ULL<<i;
    }
    // initialize LAry gsymbol (amc.FDb.gsymbol)
    _db.gsymbol_n = 0;
    memset(_db.gsymbol_lary, 0, sizeof(_db.gsymbol_lary)); // zero out all level pointers
    amc::FGsymbol* gsymbol_first = (amc::FGsymbol*)amc::lpool_AllocMem(sizeof(amc::FGsymbol) * (u64(1)<<4));
    if (!gsymbol_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.gsymbol_lary[i]  = gsymbol_first;
        gsymbol_first    += 1ULL<<i;
    }
    // initialize LAry sortfld (amc.FDb.sortfld)
    _db.sortfld_n = 0;
    memset(_db.sortfld_lary, 0, sizeof(_db.sortfld_lary)); // zero out all level pointers
    amc::FSortfld* sortfld_first = (amc::FSortfld*)amc::lpool_AllocMem(sizeof(amc::FSortfld) * (u64(1)<<4));
    if (!sortfld_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.sortfld_lary[i]  = sortfld_first;
        sortfld_first    += 1ULL<<i;
    }
    // initialize LAry cget (amc.FDb.cget)
    _db.cget_n = 0;
    memset(_db.cget_lary, 0, sizeof(_db.cget_lary)); // zero out all level pointers
    amc::FCget* cget_first = (amc::FCget*)amc::lpool_AllocMem(sizeof(amc::FCget) * (u64(1)<<4));
    if (!cget_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.cget_lary[i]  = cget_first;
        cget_first    += 1ULL<<i;
    }
    _db.cd_temp_func_head = NULL; // (amc.FDb.cd_temp_func)
    _db.cd_temp_func_n = 0; // (amc.FDb.cd_temp_func)
    _db.zs_gen_perns_head = NULL; // (amc.FDb.zs_gen_perns)
    _db.zs_gen_perns_tail = NULL; // (amc.FDb.zs_gen_perns)
    // initialize LAry hook (amc.FDb.hook)
    _db.hook_n = 0;
    memset(_db.hook_lary, 0, sizeof(_db.hook_lary)); // zero out all level pointers
    amc::FHook* hook_first = (amc::FHook*)amc::lpool_AllocMem(sizeof(amc::FHook) * (u64(1)<<4));
    if (!hook_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.hook_lary[i]  = hook_first;
        hook_first    += 1ULL<<i;
    }
    // initialize LAry charset (amc.FDb.charset)
    _db.charset_n = 0;
    memset(_db.charset_lary, 0, sizeof(_db.charset_lary)); // zero out all level pointers
    amc::FCharset* charset_first = (amc::FCharset*)amc::lpool_AllocMem(sizeof(amc::FCharset) * (u64(1)<<4));
    if (!charset_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.charset_lary[i]  = charset_first;
        charset_first    += 1ULL<<i;
    }
    (void)Charset_ReadStrptrPlain(_db.ValidRnumPad, "0123456789+-.e");
    // initialize LAry nsinclude (amc.FDb.nsinclude)
    _db.nsinclude_n = 0;
    memset(_db.nsinclude_lary, 0, sizeof(_db.nsinclude_lary)); // zero out all level pointers
    amc::FNsinclude* nsinclude_first = (amc::FNsinclude*)amc::lpool_AllocMem(sizeof(amc::FNsinclude) * (u64(1)<<4));
    if (!nsinclude_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.nsinclude_lary[i]  = nsinclude_first;
        nsinclude_first    += 1ULL<<i;
    }
    // initialize LAry ssimvolatile (amc.FDb.ssimvolatile)
    _db.ssimvolatile_n = 0;
    memset(_db.ssimvolatile_lary, 0, sizeof(_db.ssimvolatile_lary)); // zero out all level pointers
    amc::FSsimvolatile* ssimvolatile_first = (amc::FSsimvolatile*)amc::lpool_AllocMem(sizeof(amc::FSsimvolatile) * (u64(1)<<4));
    if (!ssimvolatile_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.ssimvolatile_lary[i]  = ssimvolatile_first;
        ssimvolatile_first    += 1ULL<<i;
    }
    // initialize LAry funique (amc.FDb.funique)
    _db.funique_n = 0;
    memset(_db.funique_lary, 0, sizeof(_db.funique_lary)); // zero out all level pointers
    amc::FFunique* funique_first = (amc::FFunique*)amc::lpool_AllocMem(sizeof(amc::FFunique) * (u64(1)<<4));
    if (!funique_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.funique_lary[i]  = funique_first;
        funique_first    += 1ULL<<i;
    }
    // initialize LAry fuserinit (amc.FDb.fuserinit)
    _db.fuserinit_n = 0;
    memset(_db.fuserinit_lary, 0, sizeof(_db.fuserinit_lary)); // zero out all level pointers
    amc::FFuserinit* fuserinit_first = (amc::FFuserinit*)amc::lpool_AllocMem(sizeof(amc::FFuserinit) * (u64(1)<<4));
    if (!fuserinit_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.fuserinit_lary[i]  = fuserinit_first;
        fuserinit_first    += 1ULL<<i;
    }
    // initialize hash table for amc::FFcurs;
    _db.ind_fcurs_n             	= 0; // (amc.FDb.ind_fcurs)
    _db.ind_fcurs_buckets_n     	= 4; // (amc.FDb.ind_fcurs)
    _db.ind_fcurs_buckets_elems 	= (amc::FFcurs**)amc::lpool_AllocMem(sizeof(amc::FFcurs*)*_db.ind_fcurs_buckets_n); // initial buckets (amc.FDb.ind_fcurs)
    if (!_db.ind_fcurs_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FDb.ind_fcurs)
    }
    memset(_db.ind_fcurs_buckets_elems, 0, sizeof(amc::FFcurs*)*_db.ind_fcurs_buckets_n); // (amc.FDb.ind_fcurs)
    // initialize LAry tcurs (amc.FDb.tcurs)
    _db.tcurs_n = 0;
    memset(_db.tcurs_lary, 0, sizeof(_db.tcurs_lary)); // zero out all level pointers
    amc::FTcurs* tcurs_first = (amc::FTcurs*)amc::lpool_AllocMem(sizeof(amc::FTcurs) * (u64(1)<<4));
    if (!tcurs_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        _db.tcurs_lary[i]  = tcurs_first;
        tcurs_first    += 1ULL<<i;
    }
    _db.has_ams_fwd_declare = bool(false);

    amc::InitReflection();
    tclass_LoadStatic();
    tfunc_LoadStatic();
    gen_LoadStatic();
    reftype_LoadStatic();
}

// --- amc.FDb..Uninit
void amc::FDb_Uninit() {
    amc::FDb &row = _db; (void)row;

    // amc.FDb.tcurs.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fcurs.Uninit (Thash)  //
    // skip destruction of ind_fcurs in global scope

    // amc.FDb.fuserinit.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.funique.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ssimvolatile.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.nsinclude.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.charset.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.hook.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cget.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.sortfld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.gsymbol.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.nossimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fcmap.Uninit (Thash)  //
    // skip destruction of ind_fcmap in global scope

    // amc.FDb.fbase.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.c_tempfield.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_tempfield_elems, sizeof(amc::FField*)*_db.c_tempfield_max); // (amc.FDb.c_tempfield)

    // amc.FDb.c_ctypelen.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_ctypelen_elems, sizeof(amc::FCtypelen*)*_db.c_ctypelen_max); // (amc.FDb.c_ctypelen)

    // amc.FDb.ctypelen.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.c_substr_field.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_substr_field_elems, sizeof(amc::FSubstr*)*_db.c_substr_field_max); // (amc.FDb.c_substr_field)

    // amc.FDb.fnoremove.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ftrace.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_prefix.Uninit (Thash)  //
    // skip destruction of ind_prefix in global scope

    // amc.FDb.fprefix.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fconst_int.Uninit (Thash)  //Used only during generation
    // skip destruction of ind_fconst_int in global scope

    // amc.FDb.nsdb.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.nsproto.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcmap.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.floadtuples.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_main.Uninit (Thash)  //
    // skip destruction of ind_main in global scope

    // amc.FDb.fcmdline.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.argvtype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cdflt.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcurs.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.findrem.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcompact.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.nsx.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.csize.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cafter.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.nocascdel.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.noxref.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcast.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcmp.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_tclass.Uninit (Thash)  //
    // skip destruction of ind_tclass in global scope

    // amc.FDb.tclass.Uninit (Inlary)  //
    // skip destruction in global scope

    // amc.FDb.fregx.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.gen.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_tfunc.Uninit (Thash)  //
    // skip destruction of ind_tfunc in global scope

    // amc.FDb.tfunc.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fwddecl.Uninit (Thash)  //
    // skip destruction of ind_fwddecl in global scope

    // amc.FDb.fwddecl.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.pmaskfld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.dispctx.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.targdep.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_target.Uninit (Thash)  //
    // skip destruction of ind_target in global scope

    // amc.FDb.target.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.c_dispsig_sorted.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_dispsig_sorted_elems, sizeof(amc::FDispsig*)*_db.c_dispsig_sorted_max); // (amc.FDb.c_dispsig_sorted)

    // amc.FDb.dispsig.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.tracerec.Uninit (Lary)  //Word trace is already taken...
    // skip destruction in global scope

    // amc.FDb.tracefld.Uninit (Lary)  //Word trace is already taken...
    // skip destruction in global scope

    // amc.FDb.ind_fstep.Uninit (Thash)  //
    // skip destruction of ind_fstep in global scope

    // amc.FDb.disptrace.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fdelay.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cextern.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fstep.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_listtype.Uninit (Thash)  //
    // skip destruction of ind_listtype in global scope

    // amc.FDb.listtype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cstr.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fbigend.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_ccmp.Uninit (Thash)  //
    // skip destruction of ind_ccmp in global scope

    // amc.FDb.ccmp.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_chash.Uninit (Thash)  //
    // skip destruction of ind_chash in global scope

    // amc.FDb.chash.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fbuf.Uninit (Thash)  //
    // skip destruction of ind_fbuf in global scope

    // amc.FDb.fbuf.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.foutput.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.finput.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.c_ns_sorted.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_ns_sorted_elems, sizeof(amc::FNs*)*_db.c_ns_sorted_max); // (amc.FDb.c_ns_sorted)

    // amc.FDb.ind_fconst.Uninit (Thash)  //
    // skip destruction of ind_fconst in global scope

    // amc.FDb.fconst.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_reftype.Uninit (Thash)  //
    // skip destruction of ind_reftype in global scope

    // amc.FDb.ind_fdec.Uninit (Thash)  //
    // skip destruction of ind_fdec in global scope

    // amc.FDb.fdec.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fcleanup.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_fbitset.Uninit (Thash)  //
    // skip destruction of ind_fbitset in global scope

    // amc.FDb.fbitset.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_enumstr.Uninit (Thash)  //Index of FEnumstr by string value
    // skip destruction of ind_enumstr in global scope

    // amc.FDb.ind_enumstr_len.Uninit (Thash)  //Index of FEnumstrLen by length
    // skip destruction of ind_enumstr_len in global scope

    // amc.FDb.bh_enumstr_len.Uninit (Bheap)  //List of FEnumstrLen by length
    // skip destruction in global scope

    // amc.FDb.enumstr_len.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.enumstr.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.c_ctype_sorted.Uninit (Ptrary)  //
    amc::lpool_FreeMem(_db.c_ctype_sorted_elems, sizeof(amc::FCtype*)*_db.c_ctype_sorted_max); // (amc.FDb.c_ctype_sorted)

    // amc.FDb.ptrary.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_smallstr.Uninit (Thash)  //
    // skip destruction of ind_smallstr in global scope

    // amc.FDb.ind_pack.Uninit (Thash)  //
    // skip destruction of ind_pack in global scope

    // amc.FDb.pack.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_ssimfile.Uninit (Thash)  //
    // skip destruction of ind_ssimfile in global scope

    // amc.FDb.ssimfile.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.bitfld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.substr.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cascdel.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_rowid.Uninit (Thash)  //
    // skip destruction of ind_rowid in global scope

    // amc.FDb.rowid.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cppfunc.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_tary.Uninit (Thash)  //
    // skip destruction of ind_tary in global scope

    // amc.FDb.tary.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_inlary.Uninit (Thash)  //
    // skip destruction of ind_inlary in global scope

    // amc.FDb.inlary.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_cpptype.Uninit (Thash)  //
    // skip destruction of ind_cpptype in global scope

    // amc.FDb.cpptype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_xref.Uninit (Thash)  //
    // skip destruction of ind_xref in global scope

    // amc.FDb.ind_pnew.Uninit (Thash)  //
    // skip destruction of ind_pnew in global scope

    // amc.FDb.ind_ns.Uninit (Thash)  //
    // skip destruction of ind_ns in global scope

    // amc.FDb.ind_field.Uninit (Thash)  //
    // skip destruction of ind_field in global scope

    // amc.FDb.ind_func.Uninit (Thash)  //
    // skip destruction of ind_func in global scope

    // amc.FDb.ind_dispatch.Uninit (Thash)  //
    // skip destruction of ind_dispatch in global scope

    // amc.FDb.ind_ctype.Uninit (Thash)  //
    // skip destruction of ind_ctype in global scope

    // amc.FDb.ind_bltin.Uninit (Thash)  //
    // skip destruction of ind_bltin in global scope

    // amc.FDb.reftype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.main.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.numstr.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.smallstr.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.func.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.thash.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.gstatic.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.gconst.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.msgtype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.static_tuple.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.bltin.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.lenfld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.typefld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.fldoffset.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.pnew.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ns.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.xref.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.anonfld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.llist.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.basepool.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.field.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ctype.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.dispatch_msg.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.dispatch.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.cfmt.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.usertracefld.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.dispfilter.Uninit (Lary)  //
    // skip destruction in global scope

    // amc.FDb.ind_cfmt.Uninit (Thash)  //
    // skip destruction of ind_cfmt in global scope

    // amc.FDb.fsort.Uninit (Lary)  //
    // skip destruction in global scope
}

// --- amc.FDispatch.msghdr.CopyIn
// Copy fields in to row
void amc::dispatch_CopyIn(amc::FDispatch &row, dmmeta::Dispatch &in) {
    row.dispatch = in.dispatch;
    row.unk = in.unk;
    row.read = in.read;
    row.print = in.print;
    row.haslen = in.haslen;
    row.call = in.call;
    row.strict = in.strict;
    // comment stripped, see dmmeta.fbase:amc.FDispatch.msghdr
}

// --- amc.FDispatch.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FDispatch& dispatch) {
    algo::Smallstr16 ret(algo::Pathcomp(dispatch.dispatch, ".RL"));
    return ret;
}

// --- amc.FDispatch.name.Get
algo::Smallstr50 amc::name_Get(amc::FDispatch& dispatch) {
    algo::Smallstr50 ret(algo::Pathcomp(dispatch.dispatch, ".RR"));
    return ret;
}

// --- amc.FDispatch.c_dispatch_msg.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_dispatch_msg_Insert(amc::FDispatch& dispatch, amc::FDispatchmsg& row) {
    if (bool_Update(row.dispatch_c_dispatch_msg_in_ary,true)) {
        // reserve space
        c_dispatch_msg_Reserve(dispatch, 1);
        u32 n  = dispatch.c_dispatch_msg_n;
        u32 at = n;
        amc::FDispatchmsg* *elems = dispatch.c_dispatch_msg_elems;
        elems[at] = &row;
        dispatch.c_dispatch_msg_n = n+1;

    }
}

// --- amc.FDispatch.c_dispatch_msg.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_dispatch_msg_InsertMaybe(amc::FDispatch& dispatch, amc::FDispatchmsg& row) {
    bool retval = !row.dispatch_c_dispatch_msg_in_ary;
    c_dispatch_msg_Insert(dispatch,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FDispatch.c_dispatch_msg.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_dispatch_msg_Remove(amc::FDispatch& dispatch, amc::FDispatchmsg& row) {
    if (bool_Update(row.dispatch_c_dispatch_msg_in_ary,false)) {
        int lim = dispatch.c_dispatch_msg_n;
        amc::FDispatchmsg* *elems = dispatch.c_dispatch_msg_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FDispatchmsg* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FDispatchmsg*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                dispatch.c_dispatch_msg_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FDispatch.c_dispatch_msg.Reserve
// Reserve space in index for N more elements;
void amc::c_dispatch_msg_Reserve(amc::FDispatch& dispatch, u32 n) {
    u32 old_max = dispatch.c_dispatch_msg_max;
    if (UNLIKELY(dispatch.c_dispatch_msg_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FDispatchmsg*);
        u32 new_size = new_max * sizeof(amc::FDispatchmsg*);
        void *new_mem = amc::lpool_ReallocMem(dispatch.c_dispatch_msg_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FDispatch.c_dispatch_msg");
        }
        dispatch.c_dispatch_msg_elems = (amc::FDispatchmsg**)new_mem;
        dispatch.c_dispatch_msg_max = new_max;
    }
}

// --- amc.FDispatch..Init
// Set all fields to initial values.
void amc::FDispatch_Init(amc::FDispatch& dispatch) {
    dispatch.unk = bool(false);
    dispatch.read = bool(false);
    dispatch.print = bool(false);
    dispatch.haslen = bool(false);
    dispatch.call = bool(false);
    dispatch.strict = bool(false);
    dispatch.p_ctype_hdr = NULL;
    dispatch.p_casetype = NULL;
    dispatch.c_dispfilter = NULL;
    dispatch.p_ns = NULL;
    dispatch.c_dispatch_msg_elems = NULL; // (amc.FDispatch.c_dispatch_msg)
    dispatch.c_dispatch_msg_n = 0; // (amc.FDispatch.c_dispatch_msg)
    dispatch.c_dispatch_msg_max = 0; // (amc.FDispatch.c_dispatch_msg)
    dispatch.c_disptrace = NULL;
    dispatch.c_dispctx = NULL;
    dispatch.ns_c_dispatch_in_ary = bool(false);
    dispatch.ind_dispatch_next = (amc::FDispatch*)-1; // (amc.FDb.ind_dispatch) not-in-hash
}

// --- amc.FDispatch..Uninit
void amc::FDispatch_Uninit(amc::FDispatch& dispatch) {
    amc::FDispatch &row = dispatch; (void)row;
    ind_dispatch_Remove(row); // remove dispatch from index ind_dispatch
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_dispatch_Remove(*p_ns, row);// remove dispatch from index c_dispatch
    }

    // amc.FDispatch.c_dispatch_msg.Uninit (Ptrary)  //
    amc::lpool_FreeMem(dispatch.c_dispatch_msg_elems, sizeof(amc::FDispatchmsg*)*dispatch.c_dispatch_msg_max); // (amc.FDispatch.c_dispatch_msg)
}

// --- amc.FDispatchmsg.msghdr.CopyIn
// Copy fields in to row
void amc::dispatch_msg_CopyIn(amc::FDispatchmsg &row, dmmeta::DispatchMsg &in) {
    row.dispatch_msg = in.dispatch_msg;
    // comment stripped, see dmmeta.fbase:amc.FDispatchmsg.msghdr
}

// --- amc.FDispatchmsg.dispatch.Get
algo::Smallstr50 amc::dispatch_Get(amc::FDispatchmsg& dispatch_msg) {
    algo::Smallstr50 ret(algo::Pathcomp(dispatch_msg.dispatch_msg, "/RL"));
    return ret;
}

// --- amc.FDispatchmsg.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FDispatchmsg& dispatch_msg) {
    algo::Smallstr50 ret(algo::Pathcomp(dispatch_msg.dispatch_msg, "/RR"));
    return ret;
}

// --- amc.FDispatchmsg..Uninit
void amc::FDispatchmsg_Uninit(amc::FDispatchmsg& dispatch_msg) {
    amc::FDispatchmsg &row = dispatch_msg; (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(dispatch_Get(row));
    if (p_dispatch)  {
        c_dispatch_msg_Remove(*p_dispatch, row);// remove dispatch_msg from index c_dispatch_msg
    }
}

// --- amc.FDispctx.msghdr.CopyIn
// Copy fields in to row
void amc::dispctx_CopyIn(amc::FDispctx &row, dmmeta::Dispctx &in) {
    row.dispatch = in.dispatch;
    row.ctype = in.ctype;
    // comment stripped, see dmmeta.fbase:amc.FDispctx.msghdr
}

// --- amc.FDispctx..Uninit
void amc::FDispctx_Uninit(amc::FDispctx& dispctx) {
    amc::FDispctx &row = dispctx; (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (p_dispatch)  {
        c_dispctx_Remove(*p_dispatch, row);// remove dispctx from index c_dispctx
    }
}

// --- amc.FDispfilter.msghdr.CopyIn
// Copy fields in to row
void amc::dispfilter_CopyIn(amc::FDispfilter &row, dmmeta::Dispfilter &in) {
    row.dispatch = in.dispatch;
    row.match_all = in.match_all;
    // comment stripped, see dmmeta.fbase:amc.FDispfilter.msghdr
}

// --- amc.FDispfilter..Uninit
void amc::FDispfilter_Uninit(amc::FDispfilter& dispfilter) {
    amc::FDispfilter &row = dispfilter; (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (p_dispatch)  {
        c_dispfilter_Remove(*p_dispatch, row);// remove dispfilter from index c_dispfilter
    }
}

// --- amc.FDispsig.msghdr.CopyOut
// Copy fields out of row
void amc::dispsig_CopyOut(amc::FDispsig &row, dmmeta::Dispsig &out) {
    out.dispsig = row.dispsig;
    out.signature = row.signature;
}

// --- amc.FDispsig.msghdr.CopyIn
// Copy fields in to row
void amc::dispsig_CopyIn(amc::FDispsig &row, dmmeta::Dispsig &in) {
    row.dispsig = in.dispsig;
    row.signature = in.signature;
}

// --- amc.FDispsig.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FDispsig& dispsig) {
    algo::Smallstr16 ret(algo::Pathcomp(dispsig.dispsig, ".RL"));
    return ret;
}

// --- amc.FDispsig.name.Get
algo::Smallstr50 amc::name_Get(amc::FDispsig& dispsig) {
    algo::Smallstr50 ret(algo::Pathcomp(dispsig.dispsig, ".RR"));
    return ret;
}

// --- amc.FDispsig..Uninit
void amc::FDispsig_Uninit(amc::FDispsig& dispsig) {
    amc::FDispsig &row = dispsig; (void)row;
    c_dispsig_sorted_Remove(row); // remove dispsig from index c_dispsig_sorted
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_dispsig_Remove(*p_ns, row);// remove dispsig from index c_dispsig
    }
}

// --- amc.FDisptrace.msghdr.CopyOut
// Copy fields out of row
void amc::disptrace_CopyOut(amc::FDisptrace &row, dmmeta::Disptrace &out) {
    out.dispatch = row.dispatch;
    out.cycle = row.cycle;
    out.comment = row.comment;
}

// --- amc.FDisptrace.msghdr.CopyIn
// Copy fields in to row
void amc::disptrace_CopyIn(amc::FDisptrace &row, dmmeta::Disptrace &in) {
    row.dispatch = in.dispatch;
    row.cycle = in.cycle;
    row.comment = in.comment;
}

// --- amc.FDisptrace..Uninit
void amc::FDisptrace_Uninit(amc::FDisptrace& disptrace) {
    amc::FDisptrace &row = disptrace; (void)row;
    amc::FDispatch* p_dispatch = amc::ind_dispatch_Find(row.dispatch);
    if (p_dispatch)  {
        c_disptrace_Remove(*p_dispatch, row);// remove disptrace from index c_disptrace
    }
}

// --- amc.FEnumstr.c_fconst.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_fconst_Insert(amc::FEnumstr& enumstr, amc::FFconst& row) {
    // reserve space
    c_fconst_Reserve(enumstr, 1);
    u32 n  = enumstr.c_fconst_n;
    u32 at = n;
    amc::FFconst* *elems = enumstr.c_fconst_elems;
    elems[at] = &row;
    enumstr.c_fconst_n = n+1;

}

// --- amc.FEnumstr.c_fconst.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_fconst_ScanInsertMaybe(amc::FEnumstr& enumstr, amc::FFconst& row) {
    bool retval = true;
    u32 n  = enumstr.c_fconst_n;
    for (u32 i = 0; i < n; i++) {
        if (enumstr.c_fconst_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_fconst_Reserve(enumstr, 1);
        enumstr.c_fconst_elems[n] = &row;
        enumstr.c_fconst_n = n+1;
    }
    return retval;
}

// --- amc.FEnumstr.c_fconst.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_fconst_Remove(amc::FEnumstr& enumstr, amc::FFconst& row) {
    int lim = enumstr.c_fconst_n;
    amc::FFconst* *elems = enumstr.c_fconst_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FFconst* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FFconst*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            enumstr.c_fconst_n = lim - 1;
            break;
        }
    }
}

// --- amc.FEnumstr.c_fconst.Reserve
// Reserve space in index for N more elements;
void amc::c_fconst_Reserve(amc::FEnumstr& enumstr, u32 n) {
    u32 old_max = enumstr.c_fconst_max;
    if (UNLIKELY(enumstr.c_fconst_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFconst*);
        u32 new_size = new_max * sizeof(amc::FFconst*);
        void *new_mem = amc::lpool_ReallocMem(enumstr.c_fconst_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FEnumstr.c_fconst");
        }
        enumstr.c_fconst_elems = (amc::FFconst**)new_mem;
        enumstr.c_fconst_max = new_max;
    }
}

// --- amc.FEnumstr..Uninit
void amc::FEnumstr_Uninit(amc::FEnumstr& enumstr) {
    amc::FEnumstr &row = enumstr; (void)row;
    amc::FEnumstrLen* p_len = amc::ind_enumstr_len_Find(row.enumstr.len);
    if (p_len)  {
        bh_enumstr_Remove(*p_len, row);// remove enumstr from index bh_enumstr
    }
    ind_enumstr_Remove(row); // remove enumstr from index ind_enumstr

    // amc.FEnumstr.c_fconst.Uninit (Ptrary)  //for fconst use
    amc::lpool_FreeMem(enumstr.c_fconst_elems, sizeof(amc::FFconst*)*enumstr.c_fconst_max); // (amc.FEnumstr.c_fconst)
}

// --- amc.FEnumstrLen.bh_enumstr.Dealloc
// Remove all elements from heap and free memory used by the array.
void amc::bh_enumstr_Dealloc(amc::FEnumstrLen& enumstr_len) {
    bh_enumstr_RemoveAll(enumstr_len);
    amc::lpool_FreeMem(enumstr_len.bh_enumstr_elems, sizeof(amc::FEnumstr*)*enumstr_len.bh_enumstr_max);
    enumstr_len.bh_enumstr_max   = 0;
    enumstr_len.bh_enumstr_elems = NULL;
}

// --- amc.FEnumstrLen.bh_enumstr.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int amc::bh_enumstr_Downheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row, int idx) {
    amc::FEnumstr* *elems = enumstr_len.bh_enumstr_elems;
    int n = enumstr_len.bh_enumstr_n;
    int child = idx*2+1;
    while (child < n) {
        amc::FEnumstr* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            amc::FEnumstr* q = elems[rchild]; // right child
            if (bh_enumstr_ElemLt(enumstr_len, *q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_enumstr_ElemLt(enumstr_len, *p,row)) {
            break;
        }
        p->bh_enumstr_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- amc.FEnumstrLen.bh_enumstr.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void amc::bh_enumstr_Insert(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) {
    if (LIKELY(row.bh_enumstr_idx == -1)) {
        bh_enumstr_Reserve(enumstr_len, 1);
        int n = enumstr_len.bh_enumstr_n;
        enumstr_len.bh_enumstr_n = n + 1;
        int new_idx = bh_enumstr_Upheap(enumstr_len, row, n);
        row.bh_enumstr_idx = new_idx;
        enumstr_len.bh_enumstr_elems[new_idx] = &row;
    }
}

// --- amc.FEnumstrLen.bh_enumstr.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 amc::bh_enumstr_Reheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) {
    int old_idx = row.bh_enumstr_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_enumstr_Reserve(enumstr_len, 1);
        old_idx = enumstr_len.bh_enumstr_n++;
    }
    int new_idx = bh_enumstr_Upheap(enumstr_len, row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_enumstr_Downheap(enumstr_len, row, old_idx);
    }
    row.bh_enumstr_idx = new_idx;
    enumstr_len.bh_enumstr_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FEnumstrLen.bh_enumstr.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 amc::bh_enumstr_ReheapFirst(amc::FEnumstrLen& enumstr_len) {
    amc::FEnumstr &row = *enumstr_len.bh_enumstr_elems[0];
    i32 new_idx = bh_enumstr_Downheap(enumstr_len, row, 0);
    row.bh_enumstr_idx = new_idx;
    enumstr_len.bh_enumstr_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FEnumstrLen.bh_enumstr.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::bh_enumstr_Remove(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) {
    if (bh_enumstr_InBheapQ(row)) {
        int old_idx = row.bh_enumstr_idx;
        if (enumstr_len.bh_enumstr_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_enumstr_idx = -1;           // mark not in heap
            i32 n = enumstr_len.bh_enumstr_n - 1; // index of last element in heap
            enumstr_len.bh_enumstr_n = n;         // decrease count
            if (old_idx != n) {
                amc::FEnumstr *elem = enumstr_len.bh_enumstr_elems[n];
                int new_idx = bh_enumstr_Upheap(enumstr_len, *elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_enumstr_Downheap(enumstr_len, *elem, old_idx);
                }
                elem->bh_enumstr_idx = new_idx;
                enumstr_len.bh_enumstr_elems[new_idx] = elem;
            }
        }
    }
}

// --- amc.FEnumstrLen.bh_enumstr.RemoveAll
// Remove all elements from binary heap
void amc::bh_enumstr_RemoveAll(amc::FEnumstrLen& enumstr_len) {
    int n = enumstr_len.bh_enumstr_n;
    for (int i = n - 1; i>=0; i--) {
        enumstr_len.bh_enumstr_elems[i]->bh_enumstr_idx = -1; // mark not-in-heap
    }
    enumstr_len.bh_enumstr_n = 0;
}

// --- amc.FEnumstrLen.bh_enumstr.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FEnumstr* amc::bh_enumstr_RemoveFirst(amc::FEnumstrLen& enumstr_len) {
    amc::FEnumstr *row = NULL;
    if (enumstr_len.bh_enumstr_n > 0) {
        row = enumstr_len.bh_enumstr_elems[0];
        row->bh_enumstr_idx = -1;           // mark not in heap
        i32 n = enumstr_len.bh_enumstr_n - 1; // index of last element in heap
        enumstr_len.bh_enumstr_n = n;         // decrease count
        if (n) {
            amc::FEnumstr &elem = *enumstr_len.bh_enumstr_elems[n];
            int new_idx = bh_enumstr_Downheap(enumstr_len, elem, 0);
            elem.bh_enumstr_idx = new_idx;
            enumstr_len.bh_enumstr_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- amc.FEnumstrLen.bh_enumstr.Reserve
// Reserve space in index for N more elements
void amc::bh_enumstr_Reserve(amc::FEnumstrLen& enumstr_len, int n) {
    i32 old_max = enumstr_len.bh_enumstr_max;
    if (UNLIKELY(enumstr_len.bh_enumstr_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FEnumstr*);
        u32 new_size = new_max * sizeof(amc::FEnumstr*);
        void *new_mem = amc::lpool_ReallocMem(enumstr_len.bh_enumstr_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FEnumstrLen.bh_enumstr");
        }
        enumstr_len.bh_enumstr_elems = (amc::FEnumstr**)new_mem;
        enumstr_len.bh_enumstr_max = new_max;
    }
}

// --- amc.FEnumstrLen.bh_enumstr.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int amc::bh_enumstr_Upheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row, int idx) {
    amc::FEnumstr* *elems = enumstr_len.bh_enumstr_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        amc::FEnumstr* p = elems[j];
        if (!bh_enumstr_ElemLt(enumstr_len, row, *p)) {
            break;
        }
        p->bh_enumstr_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- amc.FEnumstrLen.bh_enumstr.ElemLt
inline static bool amc::bh_enumstr_ElemLt(amc::FEnumstrLen& enumstr_len, amc::FEnumstr &a, amc::FEnumstr &b) {
    (void)enumstr_len;
    return a.enumstr.str < b.enumstr.str;
}

// --- amc.FEnumstrLen.bh_enumstr_curs.Add
static void amc::enumstr_len_bh_enumstr_curs_Add(enumstr_len_bh_enumstr_curs &curs, amc::FEnumstr& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    amc::FEnumstr* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        amc::FEnumstr* p = elems[j];
        if (!bh_enumstr_ElemLt((*curs.parent), row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- amc.FEnumstrLen.bh_enumstr_curs.Reserve
void amc::enumstr_len_bh_enumstr_curs_Reserve(enumstr_len_bh_enumstr_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_enumstr_N((*curs.parent));
        curs.temp_elems   = (amc::FEnumstr**)amc::lpool_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("amc.cursor_out_of_memory  func:amc.FEnumstrLen.bh_enumstr_curs.Reserve");
        }
        curs.temp_max       = bh_enumstr_N((*curs.parent));
    }
}

// --- amc.FEnumstrLen.bh_enumstr_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void amc::enumstr_len_bh_enumstr_curs_Reset(enumstr_len_bh_enumstr_curs &curs, amc::FEnumstrLen &parent) {
    curs.parent       = &parent;
    enumstr_len_bh_enumstr_curs_Reserve(curs, bh_enumstr_N((*curs.parent)));
    curs.temp_n = 0;
    if (parent.bh_enumstr_n > 0) {
        amc::FEnumstr &first = *parent.bh_enumstr_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- amc.FEnumstrLen.bh_enumstr_curs.Next
// Advance cursor.
void amc::enumstr_len_bh_enumstr_curs_Next(enumstr_len_bh_enumstr_curs &curs) {
    amc::FEnumstr* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        amc::FEnumstr* dead = elems[0];
        int i       = 0;
        amc::FEnumstr* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            amc::FEnumstr* choose = last;
            int l         = i*2+1;
            if (l<n) {
                amc::FEnumstr* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                amc::FEnumstr* er = elems[r];
                if (bh_enumstr_ElemLt((*curs.parent),*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_enumstr_ElemLt((*curs.parent),*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_enumstr_idx;
        i = (index*2+1);
        if (i < bh_enumstr_N((*curs.parent))) {
            amc::FEnumstr &elem = *curs.parent->bh_enumstr_elems[i];
            enumstr_len_bh_enumstr_curs_Add(curs, elem);
        }
        if (i+1 < bh_enumstr_N((*curs.parent))) {
            amc::FEnumstr &elem = *curs.parent->bh_enumstr_elems[i + 1];
            enumstr_len_bh_enumstr_curs_Add(curs, elem);
        }
    }
}

// --- amc.FEnumstrLen..Uninit
void amc::FEnumstrLen_Uninit(amc::FEnumstrLen& enumstr_len) {
    amc::FEnumstrLen &row = enumstr_len; (void)row;
    bh_enumstr_len_Remove(row); // remove enumstr_len from index bh_enumstr_len
    ind_enumstr_len_Remove(row); // remove enumstr_len from index ind_enumstr_len

    // amc.FEnumstrLen.bh_enumstr.Uninit (Bheap)  //List of FEnumstr by string value
    amc::lpool_FreeMem((u8*)enumstr_len.bh_enumstr_elems, sizeof(amc::FEnumstr*)*enumstr_len.bh_enumstr_max); // (amc.FEnumstrLen.bh_enumstr)
}

// --- amc.FFbase.base.CopyOut
// Copy fields out of row
void amc::fbase_CopyOut(amc::FFbase &row, dmmeta::Fbase &out) {
    out.field = row.field;
    out.stripcomment = row.stripcomment;
    out.comment = row.comment;
}

// --- amc.FFbase.base.CopyIn
// Copy fields in to row
void amc::fbase_CopyIn(amc::FFbase &row, dmmeta::Fbase &in) {
    row.field = in.field;
    row.stripcomment = in.stripcomment;
    row.comment = in.comment;
}

// --- amc.FFbase..Uninit
void amc::FFbase_Uninit(amc::FFbase& fbase) {
    amc::FFbase &row = fbase; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fbase_Remove(*p_field, row);// remove fbase from index c_fbase
    }
}

// --- amc.FFbigend.msghdr.CopyOut
// Copy fields out of row
void amc::fbigend_CopyOut(amc::FFbigend &row, dmmeta::Fbigend &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFbigend.msghdr.CopyIn
// Copy fields in to row
void amc::fbigend_CopyIn(amc::FFbigend &row, dmmeta::Fbigend &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFbigend..Uninit
void amc::FFbigend_Uninit(amc::FFbigend& fbigend) {
    amc::FFbigend &row = fbigend; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fbigend_Remove(*p_field, row);// remove fbigend from index c_fbigend
    }
}

// --- amc.FFbitset.msghdr.CopyIn
// Copy fields in to row
void amc::fbitset_CopyIn(amc::FFbitset &row, dmmeta::Fbitset &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FFbitset.msghdr
}

// --- amc.FFbitset..Uninit
void amc::FFbitset_Uninit(amc::FFbitset& fbitset) {
    amc::FFbitset &row = fbitset; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fbitset_Remove(*p_field, row);// remove fbitset from index c_fbitset
    }
    ind_fbitset_Remove(row); // remove fbitset from index ind_fbitset
}

// --- amc.FFbuf.msghdr.CopyIn
// Copy fields in to row
void amc::fbuf_CopyIn(amc::FFbuf &row, dmmeta::Fbuf &in) {
    row.field = in.field;
    row.max = in.max;
    row.fbuftype = in.fbuftype;
    row.insready = in.insready;
    row.inseof = in.inseof;
    // comment stripped, see dmmeta.fbase:amc.FFbuf.msghdr
}

// --- amc.FFbuf.fbufdir.Get
algo::Smallstr50 amc::fbufdir_Get(amc::FFbuf& fbuf) {
    algo::Smallstr50 ret(algo::Pathcomp(fbuf.field, ".RR_LL"));
    return ret;
}

// --- amc.FFbuf..Uninit
void amc::FFbuf_Uninit(amc::FFbuf& fbuf) {
    amc::FFbuf &row = fbuf; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fbuf_Remove(*p_field, row);// remove fbuf from index c_fbuf
    }
    ind_fbuf_Remove(row); // remove fbuf from index ind_fbuf
}

// --- amc.FFcast.msghdr.CopyIn
// Copy fields in to row
void amc::fcast_CopyIn(amc::FFcast &row, dmmeta::Fcast &in) {
    row.field = in.field;
    row.expr = in.expr;
    // comment stripped, see dmmeta.fbase:amc.FFcast.msghdr
}

// --- amc.FFcast..Uninit
void amc::FFcast_Uninit(amc::FFcast& fcast) {
    amc::FFcast &row = fcast; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fcast_Remove(*p_field, row);// remove fcast from index c_fcast
    }
}

// --- amc.FFcleanup.msghdr.CopyIn
// Copy fields in to row
void amc::fcleanup_CopyIn(amc::FFcleanup &row, dmmeta::Fcleanup &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FFcleanup.msghdr
}

// --- amc.FFcleanup..Uninit
void amc::FFcleanup_Uninit(amc::FFcleanup& fcleanup) {
    amc::FFcleanup &row = fcleanup; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fcleanup_Remove(*p_field, row);// remove fcleanup from index c_fcleanup
    }
}

// --- amc.FFcmap.base.CopyOut
// Copy fields out of row
void amc::fcmap_CopyOut(amc::FFcmap &row, dmmeta::Fcmap &out) {
    out.fcmap = row.fcmap;
    out.bidir = row.bidir;
    out.comment = row.comment;
}

// --- amc.FFcmap.base.CopyIn
// Copy fields in to row
void amc::fcmap_CopyIn(amc::FFcmap &row, dmmeta::Fcmap &in) {
    row.fcmap = in.fcmap;
    row.bidir = in.bidir;
    row.comment = in.comment;
}

// --- amc.FFcmap.leftField.Get
algo::Smallstr100 amc::leftField_Get(amc::FFcmap& fcmap) {
    algo::Smallstr100 ret(algo::Pathcomp(fcmap.fcmap, "=LL/LL"));
    return ret;
}

// --- amc.FFcmap.leftVal.Get
algo::Smallstr40 amc::leftVal_Get(amc::FFcmap& fcmap) {
    algo::Smallstr40 ret(algo::Pathcomp(fcmap.fcmap, "=LL/LR"));
    return ret;
}

// --- amc.FFcmap.rightVal.Get
algo::Smallstr40 amc::rightVal_Get(amc::FFcmap& fcmap) {
    algo::Smallstr40 ret(algo::Pathcomp(fcmap.fcmap, "=LR/LR"));
    return ret;
}

// --- amc.FFcmap.rightField.Get
algo::Smallstr100 amc::rightField_Get(amc::FFcmap& fcmap) {
    algo::Smallstr100 ret(algo::Pathcomp(fcmap.fcmap, "=LR/LL"));
    return ret;
}

// --- amc.FFcmap..Init
// Set all fields to initial values.
void amc::FFcmap_Init(amc::FFcmap& fcmap) {
    fcmap.bidir = bool(true);
    fcmap.p_leftField = NULL;
    fcmap.p_rightField = NULL;
    fcmap.c_convfunc = NULL;
    fcmap.ind_fcmap_next = (amc::FFcmap*)-1; // (amc.FDb.ind_fcmap) not-in-hash
    fcmap.zs_fcmap_next = (amc::FFcmap*)-1; // (amc.FField.zs_fcmap) not-in-list
}

// --- amc.FFcmap..Uninit
void amc::FFcmap_Uninit(amc::FFcmap& fcmap) {
    amc::FFcmap &row = fcmap; (void)row;
    amc::FField* p_p_leftField = row.p_leftField;
    if (p_p_leftField)  {
        zs_fcmap_Remove(*p_p_leftField, row);// remove fcmap from index zs_fcmap
    }
    ind_fcmap_Remove(row); // remove fcmap from index ind_fcmap
}

// --- amc.FFcmdline.base.CopyOut
// Copy fields out of row
void amc::fcmdline_CopyOut(amc::FFcmdline &row, dmmeta::Fcmdline &out) {
    out.field = row.field;
    out.read = row.read;
    out.comment = row.comment;
}

// --- amc.FFcmdline.base.CopyIn
// Copy fields in to row
void amc::fcmdline_CopyIn(amc::FFcmdline &row, dmmeta::Fcmdline &in) {
    row.field = in.field;
    row.read = in.read;
    row.comment = in.comment;
}

// --- amc.FFcmdline..Uninit
void amc::FFcmdline_Uninit(amc::FFcmdline& fcmdline) {
    amc::FFcmdline &row = fcmdline; (void)row;
    amc::FNs* p_p_ns = p_ns_Get(row);
    if (p_p_ns)  {
        c_fcmdline_Remove(*p_p_ns, row);// remove fcmdline from index c_fcmdline
    }
}

// --- amc.FFcmp.msghdr.CopyOut
// Copy fields out of row
void amc::fcmp_CopyOut(amc::FFcmp &row, dmmeta::Fcmp &out) {
    out.field = row.field;
    out.versionsort = row.versionsort;
    out.casesens = row.casesens;
    out.extrn = row.extrn;
    out.comment = row.comment;
}

// --- amc.FFcmp.msghdr.CopyIn
// Copy fields in to row
void amc::fcmp_CopyIn(amc::FFcmp &row, dmmeta::Fcmp &in) {
    row.field = in.field;
    row.versionsort = in.versionsort;
    row.casesens = in.casesens;
    row.extrn = in.extrn;
    row.comment = in.comment;
}

// --- amc.FFcmp..Uninit
void amc::FFcmp_Uninit(amc::FFcmp& fcmp) {
    amc::FFcmp &row = fcmp; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fcmp_Remove(*p_field, row);// remove fcmp from index c_fcmp
    }
}

// --- amc.FFcompact.base.CopyOut
// Copy fields out of row
void amc::fcompact_CopyOut(amc::FFcompact &row, dmmeta::Fcompact &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFcompact.base.CopyIn
// Copy fields in to row
void amc::fcompact_CopyIn(amc::FFcompact &row, dmmeta::Fcompact &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFcompact..Uninit
void amc::FFcompact_Uninit(amc::FFcompact& fcompact) {
    amc::FFcompact &row = fcompact; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fcompact_Remove(*p_field, row);// remove fcompact from index c_fcompact
    }
}

// --- amc.FFconst.msghdr.CopyOut
// Copy fields out of row
void amc::fconst_CopyOut(amc::FFconst &row, dmmeta::Fconst &out) {
    out.fconst = row.fconst;
    out.value = row.value;
    out.comment = row.comment;
}

// --- amc.FFconst.msghdr.CopyIn
// Copy fields in to row
void amc::fconst_CopyIn(amc::FFconst &row, dmmeta::Fconst &in) {
    row.fconst = in.fconst;
    row.value = in.value;
    row.comment = in.comment;
}

// --- amc.FFconst.field.Get
algo::Smallstr100 amc::field_Get(amc::FFconst& fconst) {
    algo::Smallstr100 ret(algo::Pathcomp(fconst.fconst, "/LL"));
    return ret;
}

// --- amc.FFconst.name.Get
algo::Smallstr100 amc::name_Get(amc::FFconst& fconst) {
    algo::Smallstr100 ret(algo::Pathcomp(fconst.fconst, "/LR"));
    return ret;
}

// --- amc.FFconst..Init
// Set all fields to initial values.
void amc::FFconst_Init(amc::FFconst& fconst) {
    fconst.p_field = NULL;
    fconst.int_val = i64(0);
    fconst.field_c_fconst_in_ary = bool(false);
    fconst.ind_fconst_next = (amc::FFconst*)-1; // (amc.FDb.ind_fconst) not-in-hash
    fconst.ind_fconst_int_next = (amc::FFconst*)-1; // (amc.FDb.ind_fconst_int) not-in-hash
}

// --- amc.FFconst..Uninit
void amc::FFconst_Uninit(amc::FFconst& fconst) {
    amc::FFconst &row = fconst; (void)row;
    ind_fconst_Remove(row); // remove fconst from index ind_fconst
    amc::FField* p_field = amc::ind_field_Find(field_Get(row));
    if (p_field)  {
        c_fconst_Remove(*p_field, row);// remove fconst from index c_fconst
    }
}

// --- amc.FFcurs.base.CopyOut
// Copy fields out of row
void amc::fcurs_CopyOut(amc::FFcurs &row, dmmeta::Fcurs &out) {
    out.fcurs = row.fcurs;
    out.comment = row.comment;
}

// --- amc.FFcurs.base.CopyIn
// Copy fields in to row
void amc::fcurs_CopyIn(amc::FFcurs &row, dmmeta::Fcurs &in) {
    row.fcurs = in.fcurs;
    row.comment = in.comment;
}

// --- amc.FFcurs.field.Get
algo::Smallstr100 amc::field_Get(amc::FFcurs& fcurs) {
    algo::Smallstr100 ret(algo::Pathcomp(fcurs.fcurs, "/RL"));
    return ret;
}

// --- amc.FFcurs.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FFcurs& fcurs) {
    algo::Smallstr50 ret(algo::Pathcomp(fcurs.fcurs, "/RL.RL"));
    return ret;
}

// --- amc.FFcurs.curstype.Get
algo::Smallstr50 amc::curstype_Get(amc::FFcurs& fcurs) {
    algo::Smallstr50 ret(algo::Pathcomp(fcurs.fcurs, "/RR"));
    return ret;
}

// --- amc.FFcurs..Uninit
void amc::FFcurs_Uninit(amc::FFcurs& fcurs) {
    amc::FFcurs &row = fcurs; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_fcurs_Remove(*p_ctype, row);// remove fcurs from index c_fcurs
    }
    ind_fcurs_Remove(row); // remove fcurs from index ind_fcurs
}

// --- amc.FFdec.msghdr.CopyIn
// Copy fields in to row
void amc::fdec_CopyIn(amc::FFdec &row, dmmeta::Fdec &in) {
    row.field = in.field;
    row.nplace = in.nplace;
    row.fixedfmt = in.fixedfmt;
    // comment stripped, see dmmeta.fbase:amc.FFdec.msghdr
}

// --- amc.FFdec..Uninit
void amc::FFdec_Uninit(amc::FFdec& fdec) {
    amc::FFdec &row = fdec; (void)row;
    ind_fdec_Remove(row); // remove fdec from index ind_fdec
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fdec_Remove(*p_field, row);// remove fdec from index c_fdec
    }
}

// --- amc.FFdelay.msghdr.CopyIn
// Copy fields in to row
void amc::fdelay_CopyIn(amc::FFdelay &row, dmmeta::Fdelay &in) {
    row.fstep = in.fstep;
    row.delay = in.delay;
    row.scale = in.scale;
    // comment stripped, see dmmeta.fbase:amc.FFdelay.msghdr
}

// --- amc.FFdelay..Uninit
void amc::FFdelay_Uninit(amc::FFdelay& fdelay) {
    amc::FFdelay &row = fdelay; (void)row;
    amc::FFstep* p_fstep = amc::ind_fstep_Find(row.fstep);
    if (p_fstep)  {
        c_fdelay_Remove(*p_fstep, row);// remove fdelay from index c_fdelay
    }
}

// --- amc.FField.msghdr.CopyOut
// Copy fields out of row
void amc::field_CopyOut(amc::FField &row, dmmeta::Field &out) {
    out.field = row.field;
    out.arg = row.arg;
    out.reftype = row.reftype;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- amc.FField.msghdr.CopyIn
// Copy fields in to row
void amc::field_CopyIn(amc::FField &row, dmmeta::Field &in) {
    row.field = in.field;
    row.arg = in.arg;
    row.reftype = in.reftype;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- amc.FField.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RL"));
    return ret;
}

// --- amc.FField.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FField& field) {
    algo::Smallstr16 ret(algo::Pathcomp(field.field, ".RL.RL"));
    return ret;
}

// --- amc.FField.name.Get
algo::Smallstr50 amc::name_Get(amc::FField& field) {
    algo::Smallstr50 ret(algo::Pathcomp(field.field, ".RR"));
    return ret;
}

// --- amc.FField.c_ffunc.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ffunc_Insert(amc::FField& field, amc::FFunc& row) {
    // reserve space
    c_ffunc_Reserve(field, 1);
    u32 n  = field.c_ffunc_n;
    u32 at = n;
    amc::FFunc* *elems = field.c_ffunc_elems;
    elems[at] = &row;
    field.c_ffunc_n = n+1;

}

// --- amc.FField.c_ffunc.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_ffunc_ScanInsertMaybe(amc::FField& field, amc::FFunc& row) {
    bool retval = true;
    u32 n  = field.c_ffunc_n;
    for (u32 i = 0; i < n; i++) {
        if (field.c_ffunc_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_ffunc_Reserve(field, 1);
        field.c_ffunc_elems[n] = &row;
        field.c_ffunc_n = n+1;
    }
    return retval;
}

// --- amc.FField.c_ffunc.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ffunc_Remove(amc::FField& field, amc::FFunc& row) {
    int lim = field.c_ffunc_n;
    amc::FFunc* *elems = field.c_ffunc_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FFunc* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FFunc*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            field.c_ffunc_n = lim - 1;
            break;
        }
    }
}

// --- amc.FField.c_ffunc.Reserve
// Reserve space in index for N more elements;
void amc::c_ffunc_Reserve(amc::FField& field, u32 n) {
    u32 old_max = field.c_ffunc_max;
    if (UNLIKELY(field.c_ffunc_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFunc*);
        u32 new_size = new_max * sizeof(amc::FFunc*);
        void *new_mem = amc::lpool_ReallocMem(field.c_ffunc_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FField.c_ffunc");
        }
        field.c_ffunc_elems = (amc::FFunc**)new_mem;
        field.c_ffunc_max = new_max;
    }
}

// --- amc.FField.c_fconst.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_fconst_Insert(amc::FField& field, amc::FFconst& row) {
    if (bool_Update(row.field_c_fconst_in_ary,true)) {
        // reserve space
        c_fconst_Reserve(field, 1);
        u32 n  = field.c_fconst_n;
        u32 at = n;
        amc::FFconst* *elems = field.c_fconst_elems;
        elems[at] = &row;
        field.c_fconst_n = n+1;

    }
}

// --- amc.FField.c_fconst.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_fconst_InsertMaybe(amc::FField& field, amc::FFconst& row) {
    bool retval = !row.field_c_fconst_in_ary;
    c_fconst_Insert(field,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FField.c_fconst.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_fconst_Remove(amc::FField& field, amc::FFconst& row) {
    if (bool_Update(row.field_c_fconst_in_ary,false)) {
        int lim = field.c_fconst_n;
        amc::FFconst* *elems = field.c_fconst_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFconst* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFconst*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                field.c_fconst_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FField.c_fconst.Reserve
// Reserve space in index for N more elements;
void amc::c_fconst_Reserve(amc::FField& field, u32 n) {
    u32 old_max = field.c_fconst_max;
    if (UNLIKELY(field.c_fconst_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFconst*);
        u32 new_size = new_max * sizeof(amc::FFconst*);
        void *new_mem = amc::lpool_ReallocMem(field.c_fconst_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FField.c_fconst");
        }
        field.c_fconst_elems = (amc::FFconst**)new_mem;
        field.c_fconst_max = new_max;
    }
}

// --- amc.FField.zd_xref_keyfld.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zd_xref_keyfld_Insert(amc::FField& field, amc::FXref& row) {
    if (!zd_xref_keyfld_InLlistQ(row)) {
        amc::FXref* old_tail = field.zd_xref_keyfld_tail;
        row.zd_xref_keyfld_next = NULL;
        row.zd_xref_keyfld_prev = old_tail;
        field.zd_xref_keyfld_tail = &row;
        amc::FXref **new_row_a = &old_tail->zd_xref_keyfld_next;
        amc::FXref **new_row_b = &field.zd_xref_keyfld_head;
        amc::FXref **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
        field.zd_xref_keyfld_n++;
    }
}

// --- amc.FField.zd_xref_keyfld.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::zd_xref_keyfld_Remove(amc::FField& field, amc::FXref& row) {
    if (zd_xref_keyfld_InLlistQ(row)) {
        amc::FXref* old_head       = field.zd_xref_keyfld_head;
        (void)old_head; // in case it's not used
        amc::FXref* prev = row.zd_xref_keyfld_prev;
        amc::FXref* next = row.zd_xref_keyfld_next;
        // if element is first, adjust list head; otherwise, adjust previous element's next
        amc::FXref **new_next_a = &prev->zd_xref_keyfld_next;
        amc::FXref **new_next_b = &field.zd_xref_keyfld_head;
        amc::FXref **new_next = prev ? new_next_a : new_next_b;
        *new_next = next;
        // if element is last, adjust list tail; otherwise, adjust next element's prev
        amc::FXref **new_prev_a = &next->zd_xref_keyfld_prev;
        amc::FXref **new_prev_b = &field.zd_xref_keyfld_tail;
        amc::FXref **new_prev = next ? new_prev_a : new_prev_b;
        *new_prev = prev;
        field.zd_xref_keyfld_n--;
        row.zd_xref_keyfld_next=(amc::FXref*)-1; // not-in-list
    }
}

// --- amc.FField.zd_xref_keyfld.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zd_xref_keyfld_RemoveAll(amc::FField& field) {
    amc::FXref* row = field.zd_xref_keyfld_head;
    field.zd_xref_keyfld_head = NULL;
    field.zd_xref_keyfld_tail = NULL;
    field.zd_xref_keyfld_n = 0;
    while (row) {
        amc::FXref* row_next = row->zd_xref_keyfld_next;
        row->zd_xref_keyfld_next  = (amc::FXref*)-1;
        row->zd_xref_keyfld_prev  = NULL;
        row = row_next;
    }
}

// --- amc.FField.zd_xref_keyfld.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FXref* amc::zd_xref_keyfld_RemoveFirst(amc::FField& field) {
    amc::FXref *row = NULL;
    row = field.zd_xref_keyfld_head;
    if (row) {
        amc::FXref *next = row->zd_xref_keyfld_next;
        field.zd_xref_keyfld_head = next;
        amc::FXref **new_end_a = &next->zd_xref_keyfld_prev;
        amc::FXref **new_end_b = &field.zd_xref_keyfld_tail;
        amc::FXref **new_end = next ? new_end_a : new_end_b;
        *new_end = NULL;
        field.zd_xref_keyfld_n--;
        row->zd_xref_keyfld_next = (amc::FXref*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FField.zs_fcmap.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_fcmap_Insert(amc::FField& field, amc::FFcmap& row) {
    if (!zs_fcmap_InLlistQ(row)) {
        amc::FFcmap* old_tail       = field.zs_fcmap_tail;
        row.zs_fcmap_next  = NULL;
        field.zs_fcmap_tail = &row;
        amc::FFcmap **new_row_a = &old_tail->zs_fcmap_next;
        amc::FFcmap **new_row_b = &field.zs_fcmap_head;
        amc::FFcmap **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FField.zs_fcmap.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_fcmap_Remove(amc::FField& field, amc::FFcmap& row) {
    if (zs_fcmap_InLlistQ(row)) {
        amc::FFcmap* old_head       = field.zs_fcmap_head;
        (void)old_head; // in case it's not used
        amc::FFcmap* prev=NULL;
        amc::FFcmap* cur     = field.zs_fcmap_head;
        while (cur) {  // search for element by pointer
            amc::FFcmap* next = cur->zs_fcmap_next;
            if (cur == &row) {

                if (!next) {
                    field.zs_fcmap_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_fcmap_next = next;
                } else {
                    field.zs_fcmap_head = next;
                }
                row.zs_fcmap_next = (amc::FFcmap*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FField.zs_fcmap.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_fcmap_RemoveAll(amc::FField& field) {
    amc::FFcmap* row = field.zs_fcmap_head;
    field.zs_fcmap_head = NULL;
    field.zs_fcmap_tail = NULL;
    while (row) {
        amc::FFcmap* row_next = row->zs_fcmap_next;
        row->zs_fcmap_next  = (amc::FFcmap*)-1;
        row = row_next;
    }
}

// --- amc.FField.zs_fcmap.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFcmap* amc::zs_fcmap_RemoveFirst(amc::FField& field) {
    amc::FFcmap *row = NULL;
    row = field.zs_fcmap_head;
    if (row) {
        amc::FFcmap *next = row->zs_fcmap_next;
        field.zs_fcmap_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            field.zs_fcmap_tail = NULL;
        }
        row->zs_fcmap_next = (amc::FFcmap*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FField.bh_bitfld.Dealloc
// Remove all elements from heap and free memory used by the array.
void amc::bh_bitfld_Dealloc(amc::FField& field) {
    bh_bitfld_RemoveAll(field);
    amc::lpool_FreeMem(field.bh_bitfld_elems, sizeof(amc::FBitfld*)*field.bh_bitfld_max);
    field.bh_bitfld_max   = 0;
    field.bh_bitfld_elems = NULL;
}

// --- amc.FField.bh_bitfld.Downheap
// Find new location for ROW starting at IDX
// NOTE: Rest of heap is rearranged, but pointer to ROW is NOT stored in array.
static int amc::bh_bitfld_Downheap(amc::FField& field, amc::FBitfld& row, int idx) {
    amc::FBitfld* *elems = field.bh_bitfld_elems;
    int n = field.bh_bitfld_n;
    int child = idx*2+1;
    while (child < n) {
        amc::FBitfld* p = elems[child]; // left child
        int rchild = child+1;
        if (rchild < n) {
            amc::FBitfld* q = elems[rchild]; // right child
            if (bh_bitfld_ElemLt(field, *q,*p)) {
                child = rchild;
                p     = q;
            }
        }
        if (!bh_bitfld_ElemLt(field, *p,row)) {
            break;
        }
        p->bh_bitfld_idx   = idx;
        elems[idx]     = p;
        idx            = child;
        child          = idx*2+1;
    }
    return idx;
}

// --- amc.FField.bh_bitfld.Insert
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void amc::bh_bitfld_Insert(amc::FField& field, amc::FBitfld& row) {
    if (LIKELY(row.bh_bitfld_idx == -1)) {
        bh_bitfld_Reserve(field, 1);
        int n = field.bh_bitfld_n;
        field.bh_bitfld_n = n + 1;
        int new_idx = bh_bitfld_Upheap(field, row, n);
        row.bh_bitfld_idx = new_idx;
        field.bh_bitfld_elems[new_idx] = &row;
    }
}

// --- amc.FField.bh_bitfld.Reheap
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32 amc::bh_bitfld_Reheap(amc::FField& field, amc::FBitfld& row) {
    int old_idx = row.bh_bitfld_idx;
    bool isnew = old_idx == -1;
    if (isnew) {
        bh_bitfld_Reserve(field, 1);
        old_idx = field.bh_bitfld_n++;
    }
    int new_idx = bh_bitfld_Upheap(field, row, old_idx);
    if (!isnew && new_idx == old_idx) {
        new_idx = bh_bitfld_Downheap(field, row, old_idx);
    }
    row.bh_bitfld_idx = new_idx;
    field.bh_bitfld_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FField.bh_bitfld.ReheapFirst
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32 amc::bh_bitfld_ReheapFirst(amc::FField& field) {
    amc::FBitfld &row = *field.bh_bitfld_elems[0];
    i32 new_idx = bh_bitfld_Downheap(field, row, 0);
    row.bh_bitfld_idx = new_idx;
    field.bh_bitfld_elems[new_idx] = &row;
    return new_idx;
}

// --- amc.FField.bh_bitfld.Remove
// Remove element from index. If element is not in index, do nothing.
void amc::bh_bitfld_Remove(amc::FField& field, amc::FBitfld& row) {
    if (bh_bitfld_InBheapQ(row)) {
        int old_idx = row.bh_bitfld_idx;
        if (field.bh_bitfld_elems[old_idx] == &row) { // sanity check: heap points back to row
            row.bh_bitfld_idx = -1;           // mark not in heap
            i32 n = field.bh_bitfld_n - 1; // index of last element in heap
            field.bh_bitfld_n = n;         // decrease count
            if (old_idx != n) {
                amc::FBitfld *elem = field.bh_bitfld_elems[n];
                int new_idx = bh_bitfld_Upheap(field, *elem, old_idx);
                if (new_idx == old_idx) {
                    new_idx = bh_bitfld_Downheap(field, *elem, old_idx);
                }
                elem->bh_bitfld_idx = new_idx;
                field.bh_bitfld_elems[new_idx] = elem;
            }
        }
    }
}

// --- amc.FField.bh_bitfld.RemoveAll
// Remove all elements from binary heap
void amc::bh_bitfld_RemoveAll(amc::FField& field) {
    int n = field.bh_bitfld_n;
    for (int i = n - 1; i>=0; i--) {
        field.bh_bitfld_elems[i]->bh_bitfld_idx = -1; // mark not-in-heap
    }
    field.bh_bitfld_n = 0;
}

// --- amc.FField.bh_bitfld.RemoveFirst
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FBitfld* amc::bh_bitfld_RemoveFirst(amc::FField& field) {
    amc::FBitfld *row = NULL;
    if (field.bh_bitfld_n > 0) {
        row = field.bh_bitfld_elems[0];
        row->bh_bitfld_idx = -1;           // mark not in heap
        i32 n = field.bh_bitfld_n - 1; // index of last element in heap
        field.bh_bitfld_n = n;         // decrease count
        if (n) {
            amc::FBitfld &elem = *field.bh_bitfld_elems[n];
            int new_idx = bh_bitfld_Downheap(field, elem, 0);
            elem.bh_bitfld_idx = new_idx;
            field.bh_bitfld_elems[new_idx] = &elem;
        }
    }
    return row;
}

// --- amc.FField.bh_bitfld.Reserve
// Reserve space in index for N more elements
void amc::bh_bitfld_Reserve(amc::FField& field, int n) {
    i32 old_max = field.bh_bitfld_max;
    if (UNLIKELY(field.bh_bitfld_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FBitfld*);
        u32 new_size = new_max * sizeof(amc::FBitfld*);
        void *new_mem = amc::lpool_ReallocMem(field.bh_bitfld_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FField.bh_bitfld");
        }
        field.bh_bitfld_elems = (amc::FBitfld**)new_mem;
        field.bh_bitfld_max = new_max;
    }
}

// --- amc.FField.bh_bitfld.Upheap
// Find and return index of new location for element ROW in the heap, starting at index IDX.
// Move any elements along the way but do not modify ROW.
static int amc::bh_bitfld_Upheap(amc::FField& field, amc::FBitfld& row, int idx) {
    amc::FBitfld* *elems = field.bh_bitfld_elems;
    while (idx>0) {
        int j = (idx-1)/2;
        amc::FBitfld* p = elems[j];
        if (!bh_bitfld_ElemLt(field, row, *p)) {
            break;
        }
        p->bh_bitfld_idx = idx;
        elems[idx] = p;
        idx = j;
    }
    return idx;
}

// --- amc.FField.bh_bitfld.ElemLt
inline static bool amc::bh_bitfld_ElemLt(amc::FField& field, amc::FBitfld &a, amc::FBitfld &b) {
    (void)field;
    return a.offset < b.offset;
}

// --- amc.FField..Init
// Set all fields to initial values.
void amc::FField_Init(amc::FField& field) {
    field.reftype = algo::strptr("Val");
    field.c_fsort = NULL;
    field.c_fbitset = NULL;
    field.c_smallstr = NULL;
    field.c_ffunc_elems = NULL; // (amc.FField.c_ffunc)
    field.c_ffunc_n = 0; // (amc.FField.c_ffunc)
    field.c_ffunc_max = 0; // (amc.FField.c_ffunc)
    field.p_ctype = NULL;
    field.p_arg = NULL;
    field.c_xref = NULL;
    field.c_anonfld = NULL;
    field.c_fldoffset = NULL;
    field.c_basepool = NULL;
    field.c_llist = NULL;
    field.c_thash = NULL;
    field.c_inlary = NULL;
    field.c_tary = NULL;
    field.c_rowid = NULL;
    field.c_cascdel = NULL;
    field.rowid = double(0.0);
    field.child_rowid = double(0.0);
    field.c_gstatic = NULL;
    field.c_ptrary = NULL;
    field.c_pmaskfld = NULL;
    field.c_typefld = NULL;
    field.c_fcleanup = NULL;
    field.c_fdec = NULL;
    field.p_reftype = NULL;
    field.c_fconst_elems = NULL; // (amc.FField.c_fconst)
    field.c_fconst_n = 0; // (amc.FField.c_fconst)
    field.c_fconst_max = 0; // (amc.FField.c_fconst)
    field.c_finput = NULL;
    field.c_foutput = NULL;
    field.c_fbuf = NULL;
    field.c_fbigend = NULL;
    field.c_fstep = NULL;
    field.c_fregx = NULL;
    field.c_fcmp = NULL;
    field.c_fcast = NULL;
    field.c_gconst = NULL;
    field.c_bitfld = NULL;
    field.c_noxref = NULL;
    field.c_cppfunc = NULL;
    field.c_substr = NULL;
    field.c_fcompact = NULL;
    field.c_findrem = NULL;
    field.zd_xref_keyfld_head = NULL; // (amc.FField.zd_xref_keyfld)
    field.zd_xref_keyfld_n = 0; // (amc.FField.zd_xref_keyfld)
    field.zd_xref_keyfld_tail = NULL; // (amc.FField.zd_xref_keyfld)
    field.zs_fcmap_head = NULL; // (amc.FField.zs_fcmap)
    field.zs_fcmap_tail = NULL; // (amc.FField.zs_fcmap)
    field.c_inkey_fconst = NULL;
    field.c_fbase = NULL;
    field.c_fnoremove = NULL;
    field.c_sortfld = NULL;
    field.c_ftrace = NULL;
    field.reflect = bool(false);
    field.ctype_read = bool(false);
    field.has_substr = bool(false);
    field.need_firstchanged = bool(false);
    field.do_trace = bool(false);
    field.processed = bool(false);
    field.synthetic = bool(false);
    field.visit = bool(false);
    field.c_hook = NULL;
    field.c_charset = NULL;
    field.bh_bitfld_max   	= 0; // (amc.FField.bh_bitfld)
    field.bh_bitfld_n     	= 0; // (amc.FField.bh_bitfld)
    field.bh_bitfld_elems 	= NULL; // (amc.FField.bh_bitfld)
    field.c_funique = NULL;
    field.c_fuserinit = NULL;
    field.ctype_c_datafld_in_ary = bool(false);
    field._db_c_tempfield_in_ary = bool(false);
    field.zd_inst_next = (amc::FField*)-1; // (amc.FCtype.zd_inst) not-in-list
    field.zd_inst_prev = NULL; // (amc.FCtype.zd_inst)
    field.zd_access_next = (amc::FField*)-1; // (amc.FCtype.zd_access) not-in-list
    field.zd_access_prev = NULL; // (amc.FCtype.zd_access)
    field.ind_field_next = (amc::FField*)-1; // (amc.FDb.ind_field) not-in-hash
    field.zs_ordkeyfield_next = (amc::FField*)-1; // (amc.FDb.zs_ordkeyfield) not-in-list
}

// --- amc.FField.bh_bitfld_curs.Add
static void amc::field_bh_bitfld_curs_Add(field_bh_bitfld_curs &curs, amc::FBitfld& row) {
    u32 n = curs.temp_n;
    int i = n;
    curs.temp_n = n+1;
    amc::FBitfld* *elems = curs.temp_elems;
    while (i>0) {
        int j = (i-1)/2;
        amc::FBitfld* p = elems[j];
        if (!bh_bitfld_ElemLt((*curs.parent), row,*p)) {
            break;
        }
        elems[i]=p;
        i=j;
    }
    elems[i]=&row;
}

// --- amc.FField.bh_bitfld_curs.Reserve
void amc::field_bh_bitfld_curs_Reserve(field_bh_bitfld_curs &curs, int n) {
    if (n > curs.temp_max) {
        size_t old_size   = sizeof(void*) * curs.temp_max;
        size_t new_size   = sizeof(void*) * bh_bitfld_N((*curs.parent));
        curs.temp_elems   = (amc::FBitfld**)amc::lpool_ReallocMem(curs.temp_elems, old_size, new_size);
        if (!curs.temp_elems) {
            algo::FatalErrorExit("amc.cursor_out_of_memory  func:amc.FField.bh_bitfld_curs.Reserve");
        }
        curs.temp_max       = bh_bitfld_N((*curs.parent));
    }
}

// --- amc.FField.bh_bitfld_curs.Reset
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void amc::field_bh_bitfld_curs_Reset(field_bh_bitfld_curs &curs, amc::FField &parent) {
    curs.parent       = &parent;
    field_bh_bitfld_curs_Reserve(curs, bh_bitfld_N((*curs.parent)));
    curs.temp_n = 0;
    if (parent.bh_bitfld_n > 0) {
        amc::FBitfld &first = *parent.bh_bitfld_elems[0];
        curs.temp_elems[0] = &first; // insert first element in heap
        curs.temp_n = 1;
    }
}

// --- amc.FField.bh_bitfld_curs.Next
// Advance cursor.
void amc::field_bh_bitfld_curs_Next(field_bh_bitfld_curs &curs) {
    amc::FBitfld* *elems = curs.temp_elems;
    int n = curs.temp_n;
    if (n > 0) {
        // remove top element from heap
        amc::FBitfld* dead = elems[0];
        int i       = 0;
        amc::FBitfld* last = curs.temp_elems[n-1];
        // downheap last elem
        do {
            amc::FBitfld* choose = last;
            int l         = i*2+1;
            if (l<n) {
                amc::FBitfld* el = elems[l];
                int r     = l+1;
                r        -= r==n;
                amc::FBitfld* er = elems[r];
                if (bh_bitfld_ElemLt((*curs.parent),*er,*el)) {
                    el  = er;
                    l   = r;
                }
                bool b = bh_bitfld_ElemLt((*curs.parent),*el,*last);
                if (b) choose = el;
                if (!b) l = n;
            }
            elems[i] = choose;
            i = l;
        } while (i < n);
        curs.temp_n = n-1;
        int index = dead->bh_bitfld_idx;
        i = (index*2+1);
        if (i < bh_bitfld_N((*curs.parent))) {
            amc::FBitfld &elem = *curs.parent->bh_bitfld_elems[i];
            field_bh_bitfld_curs_Add(curs, elem);
        }
        if (i+1 < bh_bitfld_N((*curs.parent))) {
            amc::FBitfld &elem = *curs.parent->bh_bitfld_elems[i + 1];
            field_bh_bitfld_curs_Add(curs, elem);
        }
    }
}

// --- amc.FField..Uninit
void amc::FField_Uninit(amc::FField& field) {
    amc::FField &row = field; (void)row;
    ind_field_Remove(row); // remove field from index ind_field
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_field_Remove(*p_ctype, row);// remove field from index c_field
    }
    if (p_ctype)  {
        c_varlenfld_Remove(*p_ctype, row);// remove field from index c_varlenfld
    }
    if (p_ctype)  {
        c_optfld_Remove(*p_ctype, row);// remove field from index c_optfld
    }
    if (p_ctype)  {
        c_datafld_Remove(*p_ctype, row);// remove field from index c_datafld
    }
    amc::FCtype* p_arg = amc::ind_ctype_Find(row.arg);
    if (p_arg)  {
        zd_inst_Remove(*p_arg, row);// remove field from index zd_inst
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_globfld_Remove(*p_ns, row);// remove field from index c_globfld
    }
    if (p_arg)  {
        zd_access_Remove(*p_arg, row);// remove field from index zd_access
    }
    zs_ordkeyfield_Remove(row); // remove field from index zs_ordkeyfield

    // amc.FField.bh_bitfld.Uninit (Bheap)  //
    amc::lpool_FreeMem((u8*)field.bh_bitfld_elems, sizeof(amc::FBitfld*)*field.bh_bitfld_max); // (amc.FField.bh_bitfld)

    // amc.FField.c_fconst.Uninit (Ptrary)  //
    amc::lpool_FreeMem(field.c_fconst_elems, sizeof(amc::FFconst*)*field.c_fconst_max); // (amc.FField.c_fconst)

    // amc.FField.c_ffunc.Uninit (Ptrary)  //
    amc::lpool_FreeMem(field.c_ffunc_elems, sizeof(amc::FFunc*)*field.c_ffunc_max); // (amc.FField.c_ffunc)
}

// --- amc.FFindrem.base.CopyOut
// Copy fields out of row
void amc::findrem_CopyOut(amc::FFindrem &row, dmmeta::Findrem &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFindrem.base.CopyIn
// Copy fields in to row
void amc::findrem_CopyIn(amc::FFindrem &row, dmmeta::Findrem &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFindrem..Uninit
void amc::FFindrem_Uninit(amc::FFindrem& findrem) {
    amc::FFindrem &row = findrem; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_findrem_Remove(*p_field, row);// remove findrem from index c_findrem
    }
}

// --- amc.FFinput.msghdr.CopyIn
// Copy fields in to row
void amc::finput_CopyIn(amc::FFinput &row, dmmeta::Finput &in) {
    row.field = in.field;
    row.extrn = in.extrn;
    row.update = in.update;
    row.strict = in.strict;
    // comment stripped, see dmmeta.fbase:amc.FFinput.msghdr
}

// --- amc.FFinput.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FFinput& finput) {
    algo::Smallstr16 ret(algo::Pathcomp(finput.field, ".LL"));
    return ret;
}

// --- amc.FFinput..Uninit
void amc::FFinput_Uninit(amc::FFinput& finput) {
    amc::FFinput &row = finput; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_finput_Remove(*p_field, row);// remove finput from index c_finput
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_finput_Remove(*p_ns, row);// remove finput from index c_finput
    }
}

// --- amc.FFldoffset.msghdr.CopyIn
// Copy fields in to row
void amc::fldoffset_CopyIn(amc::FFldoffset &row, dmmeta::Fldoffset &in) {
    row.field = in.field;
    row.offset = in.offset;
}

// --- amc.FFldoffset..Uninit
void amc::FFldoffset_Uninit(amc::FFldoffset& fldoffset) {
    amc::FFldoffset &row = fldoffset; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fldoffset_Remove(*p_field, row);// remove fldoffset from index c_fldoffset
    }
}

// --- amc.FFloadtuples.base.CopyOut
// Copy fields out of row
void amc::floadtuples_CopyOut(amc::FFloadtuples &row, dmmeta::Floadtuples &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFloadtuples.base.CopyIn
// Copy fields in to row
void amc::floadtuples_CopyIn(amc::FFloadtuples &row, dmmeta::Floadtuples &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFloadtuples.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FFloadtuples& floadtuples) {
    algo::Smallstr50 ret(algo::Pathcomp(floadtuples.field, ".RL"));
    return ret;
}

// --- amc.FFloadtuples..Uninit
void amc::FFloadtuples_Uninit(amc::FFloadtuples& floadtuples) {
    amc::FFloadtuples &row = floadtuples; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_floadtuples_Remove(*p_ctype, row);// remove floadtuples from index c_floadtuples
    }
}

// --- amc.FFnoremove.base.CopyOut
// Copy fields out of row
void amc::fnoremove_CopyOut(amc::FFnoremove &row, dmmeta::Fnoremove &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFnoremove.base.CopyIn
// Copy fields in to row
void amc::fnoremove_CopyIn(amc::FFnoremove &row, dmmeta::Fnoremove &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFnoremove..Uninit
void amc::FFnoremove_Uninit(amc::FFnoremove& fnoremove) {
    amc::FFnoremove &row = fnoremove; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fnoremove_Remove(*p_field, row);// remove fnoremove from index c_fnoremove
    }
}

// --- amc.FFoutput.msghdr.CopyIn
// Copy fields in to row
void amc::foutput_CopyIn(amc::FFoutput &row, dmmeta::Foutput &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FFoutput.msghdr
}

// --- amc.FFoutput.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FFoutput& foutput) {
    algo::Smallstr16 ret(algo::Pathcomp(foutput.field, ".LL"));
    return ret;
}

// --- amc.FFoutput..Uninit
void amc::FFoutput_Uninit(amc::FFoutput& foutput) {
    amc::FFoutput &row = foutput; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_foutput_Remove(*p_field, row);// remove foutput from index c_foutput
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_foutput_Remove(*p_ns, row);// remove foutput from index c_foutput
    }
}

// --- amc.FFprefix.base.CopyOut
// Copy fields out of row
void amc::fprefix_CopyOut(amc::FFprefix &row, dmmeta::Fprefix &out) {
    out.fprefix = row.fprefix;
    out.reftype = row.reftype;
    out.comment = row.comment;
}

// --- amc.FFprefix.base.CopyIn
// Copy fields in to row
void amc::fprefix_CopyIn(amc::FFprefix &row, dmmeta::Fprefix &in) {
    row.fprefix = in.fprefix;
    row.reftype = in.reftype;
    row.comment = in.comment;
}

// --- amc.FFprefix..Uninit
void amc::FFprefix_Uninit(amc::FFprefix& fprefix) {
    amc::FFprefix &row = fprefix; (void)row;
    amc::FReftype* p_reftype = amc::ind_reftype_Find(row.reftype);
    if (p_reftype)  {
        zs_fprefix_Remove(*p_reftype, row);// remove fprefix from index zs_fprefix
    }
    ind_prefix_Remove(row); // remove fprefix from index ind_prefix
}

// --- amc.FFregx.msghdr.CopyIn
// Copy fields in to row
void amc::fregx_CopyIn(amc::FFregx &row, dmmeta::Fregx &in) {
    row.field = in.field;
    row.partial = in.partial;
    // comment stripped, see dmmeta.fbase:amc.FFregx.msghdr
}

// --- amc.FFregx..Uninit
void amc::FFregx_Uninit(amc::FFregx& fregx) {
    amc::FFregx &row = fregx; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fregx_Remove(*p_field, row);// remove fregx from index c_fregx
    }
}

// --- amc.FFsort.msghdr.CopyIn
// Copy fields in to row
void amc::fsort_CopyIn(amc::FFsort &row, dmmeta::Fsort &in) {
    row.field = in.field;
    row.sorttype = in.sorttype;
    row.sortfld = in.sortfld;
    // comment stripped, see dmmeta.fbase:amc.FFsort.msghdr
}

// --- amc.FFsort..Uninit
void amc::FFsort_Uninit(amc::FFsort& fsort) {
    amc::FFsort &row = fsort; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fsort_Remove(*p_field, row);// remove fsort from index c_fsort
    }
}

// --- amc.FFstep.msghdr.CopyOut
// Copy fields out of row
void amc::fstep_CopyOut(amc::FFstep &row, dmmeta::Fstep &out) {
    out.fstep = row.fstep;
    out.steptype = row.steptype;
    out.comment = row.comment;
}

// --- amc.FFstep.msghdr.CopyIn
// Copy fields in to row
void amc::fstep_CopyIn(amc::FFstep &row, dmmeta::Fstep &in) {
    row.fstep = in.fstep;
    row.steptype = in.steptype;
    row.comment = in.comment;
}

// --- amc.FFstep.field.Get
algo::Smallstr100 amc::field_Get(amc::FFstep& fstep) {
    algo::Smallstr100 ret(algo::Pathcomp(fstep.fstep, ""));
    return ret;
}

// --- amc.FFstep.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FFstep& fstep) {
    algo::Smallstr16 ret(algo::Pathcomp(fstep.fstep, ".LL"));
    return ret;
}

// --- amc.FFstep.name.Get
algo::Smallstr50 amc::name_Get(amc::FFstep& fstep) {
    algo::Smallstr50 ret(algo::Pathcomp(fstep.fstep, ".RR"));
    return ret;
}

// --- amc.FFstep..Uninit
void amc::FFstep_Uninit(amc::FFstep& fstep) {
    amc::FFstep &row = fstep; (void)row;
    amc::FField* p_field = amc::ind_field_Find(field_Get(row));
    if (p_field)  {
        c_fstep_Remove(*p_field, row);// remove fstep from index c_fstep
    }
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_fstep_Remove(*p_ns, row);// remove fstep from index c_fstep
    }
    ind_fstep_Remove(row); // remove fstep from index ind_fstep
}

// --- amc.FFtrace.base.CopyOut
// Copy fields out of row
void amc::ftrace_CopyOut(amc::FFtrace &row, dmmeta::Ftrace &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFtrace.base.CopyIn
// Copy fields in to row
void amc::ftrace_CopyIn(amc::FFtrace &row, dmmeta::Ftrace &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFtrace..Uninit
void amc::FFtrace_Uninit(amc::FFtrace& ftrace) {
    amc::FFtrace &row = ftrace; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_ftrace_Remove(*p_field, row);// remove ftrace from index c_ftrace
    }
}

// --- amc.FFunc.msghdr.CopyOut
// Copy fields out of row
void amc::func_CopyOut(amc::FFunc &row, dmmeta::Func &out) {
    out.func = row.func;
    out.inl = row.inl;
    out.proto = row.proto;
    out.body = row.body;
    out.deprecate = row.deprecate;
    out.ismacro = row.ismacro;
    out.extrn = row.extrn;
    out.glob = row.glob;
    out.priv = row.priv;
    out.ret = row.ret;
    out.comment = row.comment;
}

// --- amc.FFunc.msghdr.CopyIn
// Copy fields in to row
void amc::func_CopyIn(amc::FFunc &row, dmmeta::Func &in) {
    row.func = in.func;
    row.inl = in.inl;
    row.proto = in.proto;
    row.body = in.body;
    row.deprecate = in.deprecate;
    row.ismacro = in.ismacro;
    row.extrn = in.extrn;
    row.glob = in.glob;
    row.priv = in.priv;
    row.ret = in.ret;
    row.comment = in.comment;
}

// --- amc.FFunc.field.Get
algo::Smallstr100 amc::field_Get(amc::FFunc& func) {
    algo::Smallstr100 ret(algo::Pathcomp(func.func, ".RL"));
    return ret;
}

// --- amc.FFunc.name.Get
algo::Smallstr50 amc::name_Get(amc::FFunc& func) {
    algo::Smallstr50 ret(algo::Pathcomp(func.func, ".RR"));
    return ret;
}

// --- amc.FFunc.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FFunc& func) {
    algo::Smallstr50 ret(algo::Pathcomp(func.func, ".RL.RL"));
    return ret;
}

// --- amc.FFunc.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FFunc& func) {
    algo::Smallstr16 ret(algo::Pathcomp(func.func, ".RL.RL.RL"));
    return ret;
}

// --- amc.FFunc.funcarg.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
amc::Funcarg& amc::funcarg_Alloc(amc::FFunc& func) {
    funcarg_Reserve(func, 1);
    int n  = func.funcarg_n;
    int at = n;
    amc::Funcarg *elems = func.funcarg_elems;
    new (elems + at) amc::Funcarg(); // construct new element, default initializer
    func.funcarg_n = n+1;
    return elems[at];
}

// --- amc.FFunc.funcarg.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
amc::Funcarg& amc::funcarg_AllocAt(amc::FFunc& func, int at) {
    funcarg_Reserve(func, 1);
    int n  = func.funcarg_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("amc.bad_alloc_at  field:amc.FFunc.funcarg  comment:'index out of range'");
    }
    amc::Funcarg *elems = func.funcarg_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(amc::Funcarg));
    new (elems + at) amc::Funcarg(); // construct element, default initializer
    func.funcarg_n = n+1;
    return elems[at];
}

// --- amc.FFunc.funcarg.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<amc::Funcarg> amc::funcarg_AllocN(amc::FFunc& func, int n_elems) {
    funcarg_Reserve(func, n_elems);
    int old_n  = func.funcarg_n;
    int new_n = old_n + n_elems;
    amc::Funcarg *elems = func.funcarg_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) amc::Funcarg(); // construct new element, default initialize
    }
    func.funcarg_n = new_n;
    return algo::aryptr<amc::Funcarg>(elems + old_n, n_elems);
}

// --- amc.FFunc.funcarg.Remove
// Remove item by index. If index outside of range, do nothing.
void amc::funcarg_Remove(amc::FFunc& func, u32 i) {
    u32 lim = func.funcarg_n;
    amc::Funcarg *elems = func.funcarg_elems;
    if (i < lim) {
        elems[i].~Funcarg(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(amc::Funcarg) * (lim - (i + 1)));
        func.funcarg_n = lim - 1;
    }
}

// --- amc.FFunc.funcarg.RemoveAll
void amc::funcarg_RemoveAll(amc::FFunc& func) {
    u32 n = func.funcarg_n;
    while (n > 0) {
        n -= 1;
        func.funcarg_elems[n].~Funcarg();
        func.funcarg_n = n;
    }
}

// --- amc.FFunc.funcarg.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::funcarg_RemoveLast(amc::FFunc& func) {
    u64 n = func.funcarg_n;
    if (n > 0) {
        n -= 1;
        funcarg_qFind(func, u64(n)).~Funcarg();
        func.funcarg_n = n;
    }
}

// --- amc.FFunc.funcarg.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void amc::funcarg_AbsReserve(amc::FFunc& func, int n) {
    u32 old_max  = func.funcarg_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = amc::lpool_ReallocMem(func.funcarg_elems, old_max * sizeof(amc::Funcarg), new_max * sizeof(amc::Funcarg));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.tary_nomem  field:amc.FFunc.funcarg  comment:'out of memory'");
        }
        func.funcarg_elems = (amc::Funcarg*)new_mem;
        func.funcarg_max = new_max;
    }
}

// --- amc.FFunc.funcarg.Setary
// Copy contents of RHS to PARENT.
void amc::funcarg_Setary(amc::FFunc& func, amc::FFunc &rhs) {
    funcarg_RemoveAll(func);
    int nnew = rhs.funcarg_n;
    funcarg_Reserve(func, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (func.funcarg_elems + i) amc::Funcarg(funcarg_qFind(rhs, i));
        func.funcarg_n = i + 1;
    }
}

// --- amc.FFunc.funcarg.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<amc::Funcarg> amc::funcarg_AllocNVal(amc::FFunc& func, int n_elems, const amc::Funcarg& val) {
    funcarg_Reserve(func, n_elems);
    int old_n  = func.funcarg_n;
    int new_n = old_n + n_elems;
    amc::Funcarg *elems = func.funcarg_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) amc::Funcarg(val);
    }
    func.funcarg_n = new_n;
    return algo::aryptr<amc::Funcarg>(elems + old_n, n_elems);
}

// --- amc.FFunc.funcarg.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::funcarg_XrefMaybe(amc::Funcarg &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- amc.FFunc..Init
// Set all fields to initial values.
void amc::FFunc_Init(amc::FFunc& func) {
    func.inl = bool(false);
    func.deprecate = bool(false);
    func.ismacro = bool(false);
    func.extrn = bool(false);
    func.glob = bool(false);
    func.priv = bool(false);
    func.p_ns = NULL;
    func.funcarg_elems 	= 0; // (amc.FFunc.funcarg)
    func.funcarg_n     	= 0; // (amc.FFunc.funcarg)
    func.funcarg_max   	= 0; // (amc.FFunc.funcarg)
    func.printed = bool(false);
    func.throws = bool(false);
    func.nothrow = bool(false);
    func.member = bool(false);
    func.disable = bool(false);
    func.oper = bool(false);
    func.globns = bool(false);
    func.isalloc = bool(false);
    func.wur = bool(false);
    func.pure = bool(false);
    func.finalized = bool(false);
    func.isexplicit = bool(false);
    func.istmpl = bool(false);
    func.ns_c_func_in_ary = bool(false);
    func.ind_func_next = (amc::FFunc*)-1; // (amc.FDb.ind_func) not-in-hash
    func.cd_temp_func_next = (amc::FFunc*)-1; // (amc.FDb.cd_temp_func) not-in-list
    func.cd_temp_func_prev = NULL; // (amc.FDb.cd_temp_func)
}

// --- amc.FFunc..Uninit
void amc::FFunc_Uninit(amc::FFunc& func) {
    amc::FFunc &row = func; (void)row;
    ind_func_Remove(row); // remove func from index ind_func
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_func_Remove(*p_ns, row);// remove func from index c_func
    }
    cd_temp_func_Remove(row); // remove func from index cd_temp_func

    // amc.FFunc.funcarg.Uninit (Tary)  //Array of declared function arguments
    // remove all elements from amc.FFunc.funcarg
    funcarg_RemoveAll(func);
    // free memory for Tary amc.FFunc.funcarg
    amc::lpool_FreeMem(func.funcarg_elems, sizeof(amc::Funcarg)*func.funcarg_max); // (amc.FFunc.funcarg)
}

// --- amc.FFunique.base.CopyOut
// Copy fields out of row
void amc::funique_CopyOut(amc::FFunique &row, dmmeta::Funique &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFunique.base.CopyIn
// Copy fields in to row
void amc::funique_CopyIn(amc::FFunique &row, dmmeta::Funique &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFunique..Uninit
void amc::FFunique_Uninit(amc::FFunique& funique) {
    amc::FFunique &row = funique; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_funique_Remove(*p_field, row);// remove funique from index c_funique
    }
}

// --- amc.FFuserinit.base.CopyOut
// Copy fields out of row
void amc::fuserinit_CopyOut(amc::FFuserinit &row, dmmeta::Fuserinit &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FFuserinit.base.CopyIn
// Copy fields in to row
void amc::fuserinit_CopyIn(amc::FFuserinit &row, dmmeta::Fuserinit &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FFuserinit..Uninit
void amc::FFuserinit_Uninit(amc::FFuserinit& fuserinit) {
    amc::FFuserinit &row = fuserinit; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_fuserinit_Remove(*p_field, row);// remove fuserinit from index c_fuserinit
    }
}

// --- amc.FFwddecl.msghdr.CopyIn
// Copy fields in to row
void amc::fwddecl_CopyIn(amc::FFwddecl &row, dmmeta::Fwddecl &in) {
    row.fwddecl = in.fwddecl;
    // comment stripped, see dmmeta.fbase:amc.FFwddecl.msghdr
}

// --- amc.FFwddecl.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FFwddecl& fwddecl) {
    algo::Smallstr16 ret(algo::Pathcomp(fwddecl.fwddecl, ".LL"));
    return ret;
}

// --- amc.FFwddecl.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FFwddecl& fwddecl) {
    algo::Smallstr50 ret(algo::Pathcomp(fwddecl.fwddecl, ".LR"));
    return ret;
}

// --- amc.FFwddecl..Uninit
void amc::FFwddecl_Uninit(amc::FFwddecl& fwddecl) {
    amc::FFwddecl &row = fwddecl; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_fwddecl_Remove(*p_ns, row);// remove fwddecl from index c_fwddecl
    }
    ind_fwddecl_Remove(row); // remove fwddecl from index ind_fwddecl
}

// --- amc.FGconst.msghdr.CopyOut
// Copy fields out of row
void amc::gconst_CopyOut(amc::FGconst &row, dmmeta::Gconst &out) {
    out.field = row.field;
    out.namefld = row.namefld;
    out.idfld = row.idfld;
    out.wantenum = row.wantenum;
}

// --- amc.FGconst.msghdr.CopyIn
// Copy fields in to row
void amc::gconst_CopyIn(amc::FGconst &row, dmmeta::Gconst &in) {
    row.field = in.field;
    row.namefld = in.namefld;
    row.idfld = in.idfld;
    row.wantenum = in.wantenum;
}

// --- amc.FGconst.namefldctyp.Get
algo::Smallstr50 amc::namefldctyp_Get(amc::FGconst& gconst) {
    algo::Smallstr50 ret(algo::Pathcomp(gconst.namefld, ".RL"));
    return ret;
}

// --- amc.FGconst..Uninit
void amc::FGconst_Uninit(amc::FGconst& gconst) {
    amc::FGconst &row = gconst; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_gconst_Remove(*p_field, row);// remove gconst from index c_gconst
    }
}

// --- amc.FGen.msghdr.CopyOut
// Copy fields out of row
void amc::gen_CopyOut(amc::FGen &row, amcdb::Gen &out) {
    out.gen = row.gen;
    out.perns = row.perns;
    out.comment = row.comment;
}

// --- amc.FGen.msghdr.CopyIn
// Copy fields in to row
void amc::gen_CopyIn(amc::FGen &row, amcdb::Gen &in) {
    row.gen = in.gen;
    row.perns = in.perns;
    row.comment = in.comment;
}

// --- amc.FGen..Uninit
void amc::FGen_Uninit(amc::FGen& gen) {
    amc::FGen &row = gen; (void)row;
    zs_gen_perns_Remove(row); // remove gen from index zs_gen_perns
}

// --- amc.FGenXref.ind_seen.Find
// Find row by key. Return NULL if not found.
amc::FGenXrefSeen* amc::ind_seen_Find(amc::FGenXref& parent, const algo::strptr& key) {
    u32 index = algo::cstring_Hash(0, key) & (parent.ind_seen_buckets_n - 1);
    amc::FGenXrefSeen* *e = &parent.ind_seen_buckets_elems[index];
    amc::FGenXrefSeen* ret=NULL;
    do {
        ret       = *e;
        bool done = !ret || (*ret).value == key;
        if (done) break;
        e         = &ret->ind_seen_next;
    } while (true);
    return ret;
}

// --- amc.FGenXref.ind_seen.InsertMaybe
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool amc::ind_seen_InsertMaybe(amc::FGenXref& parent, amc::FGenXrefSeen& row) {
    ind_seen_Reserve(parent, 1);
    bool retval = true; // if already in hash, InsertMaybe returns true
    if (LIKELY(row.ind_seen_next == (amc::FGenXrefSeen*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.value) & (parent.ind_seen_buckets_n - 1);
        amc::FGenXrefSeen* *prev = &parent.ind_seen_buckets_elems[index];
        do {
            amc::FGenXrefSeen* ret = *prev;
            if (!ret) { // exit condition 1: reached the end of the list
                break;
            }
            if ((*ret).value == row.value) { // exit condition 2: found matching key
                retval = false;
                break;
            }
            prev = &ret->ind_seen_next;
        } while (true);
        if (retval) {
            row.ind_seen_next = *prev;
            parent.ind_seen_n++;
            *prev = &row;
        }
    }
    return retval;
}

// --- amc.FGenXref.ind_seen.Remove
// Remove reference to element from hash index. If element is not in hash, do nothing
void amc::ind_seen_Remove(amc::FGenXref& parent, amc::FGenXrefSeen& row) {
    if (LIKELY(row.ind_seen_next != (amc::FGenXrefSeen*)-1)) {// check if in hash already
        u32 index = algo::cstring_Hash(0, row.value) & (parent.ind_seen_buckets_n - 1);
        amc::FGenXrefSeen* *prev = &parent.ind_seen_buckets_elems[index]; // addr of pointer to current element
        while (amc::FGenXrefSeen *next = *prev) {                          // scan the collision chain for our element
            if (next == &row) {        // found it?
                *prev = next->ind_seen_next; // unlink (singly linked list)
                parent.ind_seen_n--;
                row.ind_seen_next = (amc::FGenXrefSeen*)-1;// not-in-hash
                break;
            }
            prev = &next->ind_seen_next;
        }
    }
}

// --- amc.FGenXref.ind_seen.Reserve
// Reserve enough room in the hash for N more elements. Return success code.
void amc::ind_seen_Reserve(amc::FGenXref& parent, int n) {
    u32 old_nbuckets = parent.ind_seen_buckets_n;
    u32 new_nelems   = parent.ind_seen_n + n;
    // # of elements has to be roughly equal to the number of buckets
    if (new_nelems > old_nbuckets) {
        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
        u32 old_size = old_nbuckets * sizeof(amc::FGenXrefSeen*);
        u32 new_size = new_nbuckets * sizeof(amc::FGenXrefSeen*);
        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
        // means new memory will have to be allocated anyway
        amc::FGenXrefSeen* *new_buckets = (amc::FGenXrefSeen**)amc::lpool_AllocMem(new_size);
        if (UNLIKELY(!new_buckets)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FGenXref.ind_seen");
        }
        memset(new_buckets, 0, new_size); // clear pointers
        // rehash all entries
        for (int i = 0; i < parent.ind_seen_buckets_n; i++) {
            amc::FGenXrefSeen* elem = parent.ind_seen_buckets_elems[i];
            while (elem) {
                amc::FGenXrefSeen &row        = *elem;
                amc::FGenXrefSeen* next       = row.ind_seen_next;
                u32 index          = algo::cstring_Hash(0, row.value) & (new_nbuckets-1);
                row.ind_seen_next     = new_buckets[index];
                new_buckets[index] = &row;
                elem               = next;
            }
        }
        // free old array
        amc::lpool_FreeMem(parent.ind_seen_buckets_elems, old_size);
        parent.ind_seen_buckets_elems = new_buckets;
        parent.ind_seen_buckets_n = new_nbuckets;
    }
}

// --- amc.FGenXref.seen.Alloc
// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGenXrefSeen& amc::seen_Alloc(amc::FGenXref& parent) {
    amc::FGenXrefSeen* row = seen_AllocMaybe(parent);
    if (UNLIKELY(row == NULL)) {
        FatalErrorExit("amc.out_of_mem  field:amc.FGenXref.seen  comment:'Alloc failed'");
    }
    return *row;
}

// --- amc.FGenXref.seen.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
amc::FGenXrefSeen* amc::seen_AllocMaybe(amc::FGenXref& parent) {
    amc::FGenXrefSeen *row = (amc::FGenXrefSeen*)seen_AllocMem(parent);
    if (row) {
        new (row) amc::FGenXrefSeen; // call constructor
    }
    return row;
}

// --- amc.FGenXref.seen.AllocMem
// Allocate space for one element. If no memory available, return NULL.
void* amc::seen_AllocMem(amc::FGenXref& parent) {
    u64 new_nelems     = parent.seen_n+1;
    // compute level and index on level
    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
    u64 base  = u64(1)<<bsr;
    u64 index = new_nelems-base;
    void *ret = NULL;
    // if level doesn't exist yet, create it
    amc::FGenXrefSeen*  lev   = NULL;
    if (bsr < 32) {
        lev = parent.seen_lary[bsr];
        if (!lev) {
            lev=(amc::FGenXrefSeen*)amc::lpool_AllocMem(sizeof(amc::FGenXrefSeen) * (u64(1)<<bsr));
            parent.seen_lary[bsr] = lev;
        }
    }
    // allocate element from this level
    if (lev) {
        parent.seen_n = i32(new_nelems);
        ret = lev + index;
    }
    return ret;
}

// --- amc.FGenXref.seen.RemoveAll
// Remove all elements from Lary
void amc::seen_RemoveAll(amc::FGenXref& parent) {
    for (u64 n = parent.seen_n; n>0; ) {
        n--;
        seen_qFind(parent, u64(n)).~FGenXrefSeen(); // destroy last element
        parent.seen_n = i32(n);
    }
}

// --- amc.FGenXref.seen.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::seen_RemoveLast(amc::FGenXref& parent) {
    u64 n = parent.seen_n;
    if (n > 0) {
        n -= 1;
        seen_qFind(parent, u64(n)).~FGenXrefSeen();
        parent.seen_n = i32(n);
    }
}

// --- amc.FGenXref.seen.XrefMaybe
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool amc::seen_XrefMaybe(amc::FGenXrefSeen &row) {
    bool retval = true;
    (void)row;
    return retval;
}

// --- amc.FGenXref..Init
// Set all fields to initial values.
void amc::FGenXref_Init(amc::FGenXref& parent) {
    // initialize hash table for amc::FGenXrefSeen;
    parent.ind_seen_n             	= 0; // (amc.FGenXref.ind_seen)
    parent.ind_seen_buckets_n     	= 4; // (amc.FGenXref.ind_seen)
    parent.ind_seen_buckets_elems 	= (amc::FGenXrefSeen**)amc::lpool_AllocMem(sizeof(amc::FGenXrefSeen*)*parent.ind_seen_buckets_n); // initial buckets (amc.FGenXref.ind_seen)
    if (!parent.ind_seen_buckets_elems) {
        FatalErrorExit("out of memory"); // (amc.FGenXref.ind_seen)
    }
    memset(parent.ind_seen_buckets_elems, 0, sizeof(amc::FGenXrefSeen*)*parent.ind_seen_buckets_n); // (amc.FGenXref.ind_seen)
    // initialize LAry seen (amc.FGenXref.seen)
    parent.seen_n = 0;
    memset(parent.seen_lary, 0, sizeof(parent.seen_lary)); // zero out all level pointers
    amc::FGenXrefSeen* seen_first = (amc::FGenXrefSeen*)amc::lpool_AllocMem(sizeof(amc::FGenXrefSeen) * (u64(1)<<4));
    if (!seen_first) {
        FatalErrorExit("out of memory");
    }
    for (int i = 0; i < 4; i++) {
        parent.seen_lary[i]  = seen_first;
        seen_first    += 1ULL<<i;
    }
}

// --- amc.FGenXref..Uninit
void amc::FGenXref_Uninit(amc::FGenXref& parent) {
    amc::FGenXref &row = parent; (void)row;

    // amc.FGenXref.seen.Uninit (Lary)  //
    // destroy amc.FGenXref.seen
    // destroy all elements
    seen_RemoveAll(parent);
    // destroy all levels. stop when NULL level is found -- there is nothing beyond it
    amc::lpool_FreeMem(parent.seen_lary[0],sizeof(amc::FGenXrefSeen) * (u64(1)<<4));
    for (u64 i = 4; i < 32 && parent.seen_lary[i]; i++) {
        amc::lpool_FreeMem(parent.seen_lary[i],sizeof(amc::FGenXrefSeen) * (u64(1)<<i));
    }

    // amc.FGenXref.ind_seen.Uninit (Thash)  //
    amc::lpool_FreeMem(parent.ind_seen_buckets_elems, sizeof(amc::FGenXrefSeen*)*parent.ind_seen_buckets_n); // (amc.FGenXref.ind_seen)
}

// --- amc.FGstatic.msghdr.CopyIn
// Copy fields in to row
void amc::gstatic_CopyIn(amc::FGstatic &row, dmmeta::Gstatic &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FGstatic.msghdr
}

// --- amc.FGstatic.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FGstatic& gstatic) {
    algo::Smallstr16 ret(algo::Pathcomp(gstatic.field, ".LL"));
    return ret;
}

// --- amc.FGstatic..Uninit
void amc::FGstatic_Uninit(amc::FGstatic& gstatic) {
    amc::FGstatic &row = gstatic; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_gstatic_Remove(*p_ns, row);// remove gstatic from index c_gstatic
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_gstatic_Remove(*p_field, row);// remove gstatic from index c_gstatic
    }
}

// --- amc.FGsymbol.base.CopyOut
// Copy fields out of row
void amc::gsymbol_CopyOut(amc::FGsymbol &row, dmmeta::Gsymbol &out) {
    out.gsymbol = row.gsymbol;
    out.inc = row.inc;
    out.symboltype = row.symboltype;
    out.comment = row.comment;
}

// --- amc.FGsymbol.base.CopyIn
// Copy fields in to row
void amc::gsymbol_CopyIn(amc::FGsymbol &row, dmmeta::Gsymbol &in) {
    row.gsymbol = in.gsymbol;
    row.inc = in.inc;
    row.symboltype = in.symboltype;
    row.comment = in.comment;
}

// --- amc.FGsymbol.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FGsymbol& gsymbol) {
    algo::Smallstr16 ret(algo::Pathcomp(gsymbol.gsymbol, "/RL"));
    return ret;
}

// --- amc.FGsymbol.ssimfile.Get
algo::Smallstr50 amc::ssimfile_Get(amc::FGsymbol& gsymbol) {
    algo::Smallstr50 ret(algo::Pathcomp(gsymbol.gsymbol, "/RR"));
    return ret;
}

// --- amc.FGsymbol..Uninit
void amc::FGsymbol_Uninit(amc::FGsymbol& gsymbol) {
    amc::FGsymbol &row = gsymbol; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_gsymbol_Remove(*p_ns, row);// remove gsymbol from index c_gsymbol
    }
}

// --- amc.FHook.base.CopyOut
// Copy fields out of row
void amc::hook_CopyOut(amc::FHook &row, dmmeta::Hook &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FHook.base.CopyIn
// Copy fields in to row
void amc::hook_CopyIn(amc::FHook &row, dmmeta::Hook &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FHook..Uninit
void amc::FHook_Uninit(amc::FHook& hook) {
    amc::FHook &row = hook; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_hook_Remove(*p_field, row);// remove hook from index c_hook
    }
}

// --- amc.FInlary.msghdr.CopyOut
// Copy fields out of row
void amc::inlary_CopyOut(amc::FInlary &row, dmmeta::Inlary &out) {
    out.field = row.field;
    out.min = row.min;
    out.max = row.max;
    out.comment = row.comment;
}

// --- amc.FInlary.msghdr.CopyIn
// Copy fields in to row
void amc::inlary_CopyIn(amc::FInlary &row, dmmeta::Inlary &in) {
    row.field = in.field;
    row.min = in.min;
    row.max = in.max;
    row.comment = in.comment;
}

// --- amc.FInlary..Uninit
void amc::FInlary_Uninit(amc::FInlary& inlary) {
    amc::FInlary &row = inlary; (void)row;
    ind_inlary_Remove(row); // remove inlary from index ind_inlary
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_inlary_Remove(*p_field, row);// remove inlary from index c_inlary
    }
}

// --- amc.FLenfld.msghdr.CopyOut
// Copy fields out of row
void amc::lenfld_CopyOut(amc::FLenfld &row, dmmeta::Lenfld &out) {
    out.field = row.field;
    out.extra = row.extra;
}

// --- amc.FLenfld.msghdr.CopyIn
// Copy fields in to row
void amc::lenfld_CopyIn(amc::FLenfld &row, dmmeta::Lenfld &in) {
    row.field = in.field;
    row.extra = in.extra;
}

// --- amc.FLenfld.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FLenfld& lenfld) {
    algo::Smallstr50 ret(algo::Pathcomp(lenfld.field, ".RL"));
    return ret;
}

// --- amc.FLenfld..Uninit
void amc::FLenfld_Uninit(amc::FLenfld& lenfld) {
    amc::FLenfld &row = lenfld; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_lenfld_Remove(*p_ctype, row);// remove lenfld from index c_lenfld
    }
}

// --- amc.FListtype.msghdr.CopyIn
// Copy fields in to row
void amc::listtype_CopyIn(amc::FListtype &row, dmmeta::Listtype &in) {
    row.listtype = in.listtype;
    row.circular = in.circular;
    row.haveprev = in.haveprev;
    row.instail = in.instail;
    // comment stripped, see dmmeta.fbase:amc.FListtype.msghdr
}

// --- amc.FListtype..Uninit
void amc::FListtype_Uninit(amc::FListtype& listtype) {
    amc::FListtype &row = listtype; (void)row;
    ind_listtype_Remove(row); // remove listtype from index ind_listtype
}

// --- amc.FLlist.msghdr.CopyIn
// Copy fields in to row
void amc::llist_CopyIn(amc::FLlist &row, dmmeta::Llist &in) {
    row.field = in.field;
    row.havetail = in.havetail;
    row.havecount = in.havecount;
    // comment stripped, see dmmeta.fbase:amc.FLlist.msghdr
}

// --- amc.FLlist.listtype.Get
algo::Smallstr5 amc::listtype_Get(amc::FLlist& llist) {
    algo::Smallstr5 ret(algo::Pathcomp(llist.field, ".RR_LL"));
    return ret;
}

// --- amc.FLlist..Uninit
void amc::FLlist_Uninit(amc::FLlist& llist) {
    amc::FLlist &row = llist; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_llist_Remove(*p_field, row);// remove llist from index c_llist
    }
}

// --- amc.FMain.msghdr.CopyIn
// Copy fields in to row
void amc::main_CopyIn(amc::FMain &row, dmmeta::Main &in) {
    row.ns = in.ns;
    row.ismodule = in.ismodule;
}

// --- amc.FMain..Uninit
void amc::FMain_Uninit(amc::FMain& main) {
    amc::FMain &row = main; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (p_ns)  {
        c_main_Remove(*p_ns, row);// remove main from index c_main
    }
    ind_main_Remove(row); // remove main from index ind_main
}

// --- amc.FMsgtype.msghdr.CopyIn
// Copy fields in to row
void amc::msgtype_CopyIn(amc::FMsgtype &row, dmmeta::Msgtype &in) {
    row.ctype = in.ctype;
    row.type = in.type;
}

// --- amc.FMsgtype..Uninit
void amc::FMsgtype_Uninit(amc::FMsgtype& msgtype) {
    amc::FMsgtype &row = msgtype; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_msgtype_Remove(*p_ctype, row);// remove msgtype from index c_msgtype
    }
}

// --- amc.FNocascdel.msghdr.CopyIn
// Copy fields in to row
void amc::nocascdel_CopyIn(amc::FNocascdel &row, dmmeta::Nocascdel &in) {
    row.xref = in.xref;
    // comment stripped, see dmmeta.fbase:amc.FNocascdel.msghdr
}

// --- amc.FNocascdel..Uninit
void amc::FNocascdel_Uninit(amc::FNocascdel& nocascdel) {
    amc::FNocascdel &row = nocascdel; (void)row;
    amc::FXref* p_xref = amc::ind_xref_Find(row.xref);
    if (p_xref)  {
        c_nocascdel_Remove(*p_xref, row);// remove nocascdel from index c_nocascdel
    }
}

// --- amc.FNossimfile.base.CopyOut
// Copy fields out of row
void amc::nossimfile_CopyOut(amc::FNossimfile &row, dmmeta::Nossimfile &out) {
    out.ctype = row.ctype;
    out.comment = row.comment;
}

// --- amc.FNossimfile.base.CopyIn
// Copy fields in to row
void amc::nossimfile_CopyIn(amc::FNossimfile &row, dmmeta::Nossimfile &in) {
    row.ctype = in.ctype;
    row.comment = in.comment;
}

// --- amc.FNossimfile..Uninit
void amc::FNossimfile_Uninit(amc::FNossimfile& nossimfile) {
    amc::FNossimfile &row = nossimfile; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_nossimfile_Remove(*p_ctype, row);// remove nossimfile from index c_nossimfile
    }
}

// --- amc.FNoxref.msghdr.CopyIn
// Copy fields in to row
void amc::noxref_CopyIn(amc::FNoxref &row, dmmeta::Noxref &in) {
    row.field = in.field;
    // comment stripped, see dmmeta.fbase:amc.FNoxref.msghdr
}

// --- amc.FNoxref..Uninit
void amc::FNoxref_Uninit(amc::FNoxref& noxref) {
    amc::FNoxref &row = noxref; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_noxref_Remove(*p_field, row);// remove noxref from index c_noxref
    }
}

// --- amc.FNs.msghdr.CopyOut
// Copy fields out of row
void amc::ns_CopyOut(amc::FNs &row, dmmeta::Ns &out) {
    out.ns = row.ns;
    out.nstype = row.nstype;
    out.comment = row.comment;
}

// --- amc.FNs.msghdr.CopyIn
// Copy fields in to row
void amc::ns_CopyIn(amc::FNs &row, dmmeta::Ns &in) {
    row.ns = in.ns;
    row.nstype = in.nstype;
    row.comment = in.comment;
}

// --- amc.FNs.c_ctype.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ctype_Insert(amc::FNs& ns, amc::FCtype& row) {
    if (bool_Update(row.ns_c_ctype_in_ary,true)) {
        // reserve space
        c_ctype_Reserve(ns, 1);
        u32 n  = ns.c_ctype_n;
        u32 at = n;
        amc::FCtype* *elems = ns.c_ctype_elems;
        elems[at] = &row;
        ns.c_ctype_n = n+1;

    }
}

// --- amc.FNs.c_ctype.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_ctype_InsertMaybe(amc::FNs& ns, amc::FCtype& row) {
    bool retval = !row.ns_c_ctype_in_ary;
    c_ctype_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_ctype.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ctype_Remove(amc::FNs& ns, amc::FCtype& row) {
    if (bool_Update(row.ns_c_ctype_in_ary,false)) {
        int lim = ns.c_ctype_n;
        amc::FCtype* *elems = ns.c_ctype_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FCtype* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FCtype*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_ctype_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_ctype.Reserve
// Reserve space in index for N more elements;
void amc::c_ctype_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_ctype_max;
    if (UNLIKELY(ns.c_ctype_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FCtype*);
        u32 new_size = new_max * sizeof(amc::FCtype*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_ctype_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_ctype");
        }
        ns.c_ctype_elems = (amc::FCtype**)new_mem;
        ns.c_ctype_max = new_max;
    }
}

// --- amc.FNs.c_func.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_func_Insert(amc::FNs& ns, amc::FFunc& row) {
    if (bool_Update(row.ns_c_func_in_ary,true)) {
        // reserve space
        c_func_Reserve(ns, 1);
        u32 n  = ns.c_func_n;
        u32 at = n;
        amc::FFunc* *elems = ns.c_func_elems;
        elems[at] = &row;
        ns.c_func_n = n+1;

    }
}

// --- amc.FNs.c_func.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_func_InsertMaybe(amc::FNs& ns, amc::FFunc& row) {
    bool retval = !row.ns_c_func_in_ary;
    c_func_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_func.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_func_Remove(amc::FNs& ns, amc::FFunc& row) {
    if (bool_Update(row.ns_c_func_in_ary,false)) {
        int lim = ns.c_func_n;
        amc::FFunc* *elems = ns.c_func_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFunc* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFunc*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_func_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_func.Reserve
// Reserve space in index for N more elements;
void amc::c_func_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_func_max;
    if (UNLIKELY(ns.c_func_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFunc*);
        u32 new_size = new_max * sizeof(amc::FFunc*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_func_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_func");
        }
        ns.c_func_elems = (amc::FFunc**)new_mem;
        ns.c_func_max = new_max;
    }
}

// --- amc.FNs.c_dispatch.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_dispatch_Insert(amc::FNs& ns, amc::FDispatch& row) {
    if (bool_Update(row.ns_c_dispatch_in_ary,true)) {
        // reserve space
        c_dispatch_Reserve(ns, 1);
        u32 n  = ns.c_dispatch_n;
        u32 at = n;
        amc::FDispatch* *elems = ns.c_dispatch_elems;
        elems[at] = &row;
        ns.c_dispatch_n = n+1;

    }
}

// --- amc.FNs.c_dispatch.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_dispatch_InsertMaybe(amc::FNs& ns, amc::FDispatch& row) {
    bool retval = !row.ns_c_dispatch_in_ary;
    c_dispatch_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_dispatch.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_dispatch_Remove(amc::FNs& ns, amc::FDispatch& row) {
    if (bool_Update(row.ns_c_dispatch_in_ary,false)) {
        int lim = ns.c_dispatch_n;
        amc::FDispatch* *elems = ns.c_dispatch_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FDispatch* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FDispatch*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_dispatch_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_dispatch.Reserve
// Reserve space in index for N more elements;
void amc::c_dispatch_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_dispatch_max;
    if (UNLIKELY(ns.c_dispatch_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FDispatch*);
        u32 new_size = new_max * sizeof(amc::FDispatch*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_dispatch_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_dispatch");
        }
        ns.c_dispatch_elems = (amc::FDispatch**)new_mem;
        ns.c_dispatch_max = new_max;
    }
}

// --- amc.FNs.c_gstatic.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_gstatic_Insert(amc::FNs& ns, amc::FGstatic& row) {
    if (bool_Update(row.ns_c_gstatic_in_ary,true)) {
        // reserve space
        c_gstatic_Reserve(ns, 1);
        u32 n  = ns.c_gstatic_n;
        u32 at = n;
        amc::FGstatic* *elems = ns.c_gstatic_elems;
        elems[at] = &row;
        ns.c_gstatic_n = n+1;

    }
}

// --- amc.FNs.c_gstatic.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_gstatic_InsertMaybe(amc::FNs& ns, amc::FGstatic& row) {
    bool retval = !row.ns_c_gstatic_in_ary;
    c_gstatic_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_gstatic.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_gstatic_Remove(amc::FNs& ns, amc::FGstatic& row) {
    if (bool_Update(row.ns_c_gstatic_in_ary,false)) {
        int lim = ns.c_gstatic_n;
        amc::FGstatic* *elems = ns.c_gstatic_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FGstatic* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FGstatic*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_gstatic_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_gstatic.Reserve
// Reserve space in index for N more elements;
void amc::c_gstatic_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_gstatic_max;
    if (UNLIKELY(ns.c_gstatic_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FGstatic*);
        u32 new_size = new_max * sizeof(amc::FGstatic*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_gstatic_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_gstatic");
        }
        ns.c_gstatic_elems = (amc::FGstatic**)new_mem;
        ns.c_gstatic_max = new_max;
    }
}

// --- amc.FNs.include.Alloc
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring& amc::include_Alloc(amc::FNs& ns) {
    include_Reserve(ns, 1);
    int n  = ns.include_n;
    int at = n;
    algo::cstring *elems = ns.include_elems;
    new (elems + at) algo::cstring(); // construct new element, default initializer
    ns.include_n = n+1;
    return elems[at];
}

// --- amc.FNs.include.AllocAt
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring& amc::include_AllocAt(amc::FNs& ns, int at) {
    include_Reserve(ns, 1);
    int n  = ns.include_n;
    if (UNLIKELY(u64(at) >= u64(n+1))) {
        FatalErrorExit("amc.bad_alloc_at  field:amc.FNs.include  comment:'index out of range'");
    }
    algo::cstring *elems = ns.include_elems;
    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
    new (elems + at) algo::cstring(); // construct element, default initializer
    ns.include_n = n+1;
    return elems[at];
}

// --- amc.FNs.include.AllocN
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> amc::include_AllocN(amc::FNs& ns, int n_elems) {
    include_Reserve(ns, n_elems);
    int old_n  = ns.include_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = ns.include_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(); // construct new element, default initialize
    }
    ns.include_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- amc.FNs.include.Remove
// Remove item by index. If index outside of range, do nothing.
void amc::include_Remove(amc::FNs& ns, u32 i) {
    u32 lim = ns.include_n;
    algo::cstring *elems = ns.include_elems;
    if (i < lim) {
        elems[i].~cstring(); // destroy element
        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
        ns.include_n = lim - 1;
    }
}

// --- amc.FNs.include.RemoveAll
void amc::include_RemoveAll(amc::FNs& ns) {
    u32 n = ns.include_n;
    while (n > 0) {
        n -= 1;
        ns.include_elems[n].~cstring();
        ns.include_n = n;
    }
}

// --- amc.FNs.include.RemoveLast
// Delete last element of array. Do nothing if array is empty.
void amc::include_RemoveLast(amc::FNs& ns) {
    u64 n = ns.include_n;
    if (n > 0) {
        n -= 1;
        include_qFind(ns, u64(n)).~cstring();
        ns.include_n = n;
    }
}

// --- amc.FNs.include.AbsReserve
// Make sure N elements fit in array. Process dies if out of memory
void amc::include_AbsReserve(amc::FNs& ns, int n) {
    u32 old_max  = ns.include_max;
    if (n > i32(old_max)) {
        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
        void *new_mem = amc::lpool_ReallocMem(ns.include_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.tary_nomem  field:amc.FNs.include  comment:'out of memory'");
        }
        ns.include_elems = (algo::cstring*)new_mem;
        ns.include_max = new_max;
    }
}

// --- amc.FNs.include.Setary
// Copy contents of RHS to PARENT.
void amc::include_Setary(amc::FNs& ns, amc::FNs &rhs) {
    include_RemoveAll(ns);
    int nnew = rhs.include_n;
    include_Reserve(ns, nnew); // reserve space
    for (int i = 0; i < nnew; i++) { // copy elements over
        new (ns.include_elems + i) algo::cstring(include_qFind(rhs, i));
        ns.include_n = i + 1;
    }
}

// --- amc.FNs.include.AllocNVal
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> amc::include_AllocNVal(amc::FNs& ns, int n_elems, const algo::cstring& val) {
    include_Reserve(ns, n_elems);
    int old_n  = ns.include_n;
    int new_n = old_n + n_elems;
    algo::cstring *elems = ns.include_elems;
    for (int i = old_n; i < new_n; i++) {
        new (elems + i) algo::cstring(val);
    }
    ns.include_n = new_n;
    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
}

// --- amc.FNs.c_ctype_ins.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_ctype_ins_Insert(amc::FNs& ns, amc::FCtype& row) {
    if (bool_Update(row.ns_c_ctype_ins_in_ary,true)) {
        // reserve space
        c_ctype_ins_Reserve(ns, 1);
        u32 n  = ns.c_ctype_ins_n;
        u32 at = n;
        amc::FCtype* *elems = ns.c_ctype_ins_elems;
        elems[at] = &row;
        ns.c_ctype_ins_n = n+1;

    }
}

// --- amc.FNs.c_ctype_ins.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_ctype_ins_InsertMaybe(amc::FNs& ns, amc::FCtype& row) {
    bool retval = !row.ns_c_ctype_ins_in_ary;
    c_ctype_ins_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_ctype_ins.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_ctype_ins_Remove(amc::FNs& ns, amc::FCtype& row) {
    if (bool_Update(row.ns_c_ctype_ins_in_ary,false)) {
        int lim = ns.c_ctype_ins_n;
        amc::FCtype* *elems = ns.c_ctype_ins_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FCtype* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FCtype*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_ctype_ins_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_ctype_ins.Reserve
// Reserve space in index for N more elements;
void amc::c_ctype_ins_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_ctype_ins_max;
    if (UNLIKELY(ns.c_ctype_ins_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FCtype*);
        u32 new_size = new_max * sizeof(amc::FCtype*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_ctype_ins_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_ctype_ins");
        }
        ns.c_ctype_ins_elems = (amc::FCtype**)new_mem;
        ns.c_ctype_ins_max = new_max;
    }
}

// --- amc.FNs.c_dispsig.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_dispsig_Insert(amc::FNs& ns, amc::FDispsig& row) {
    if (bool_Update(row.ns_c_dispsig_in_ary,true)) {
        // reserve space
        c_dispsig_Reserve(ns, 1);
        u32 n  = ns.c_dispsig_n;
        u32 at = n;
        amc::FDispsig* *elems = ns.c_dispsig_elems;
        elems[at] = &row;
        ns.c_dispsig_n = n+1;

    }
}

// --- amc.FNs.c_dispsig.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_dispsig_InsertMaybe(amc::FNs& ns, amc::FDispsig& row) {
    bool retval = !row.ns_c_dispsig_in_ary;
    c_dispsig_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_dispsig.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_dispsig_Remove(amc::FNs& ns, amc::FDispsig& row) {
    if (bool_Update(row.ns_c_dispsig_in_ary,false)) {
        int lim = ns.c_dispsig_n;
        amc::FDispsig* *elems = ns.c_dispsig_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FDispsig* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FDispsig*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_dispsig_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_dispsig.Reserve
// Reserve space in index for N more elements;
void amc::c_dispsig_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_dispsig_max;
    if (UNLIKELY(ns.c_dispsig_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FDispsig*);
        u32 new_size = new_max * sizeof(amc::FDispsig*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_dispsig_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_dispsig");
        }
        ns.c_dispsig_elems = (amc::FDispsig**)new_mem;
        ns.c_dispsig_max = new_max;
    }
}

// --- amc.FNs.c_parentns.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_parentns_Insert(amc::FNs& ns, amc::FNs& row) {
    // reserve space
    c_parentns_Reserve(ns, 1);
    u32 n  = ns.c_parentns_n;
    u32 at = n;
    amc::FNs* *elems = ns.c_parentns_elems;
    elems[at] = &row;
    ns.c_parentns_n = n+1;

}

// --- amc.FNs.c_parentns.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_parentns_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) {
    bool retval = true;
    u32 n  = ns.c_parentns_n;
    for (u32 i = 0; i < n; i++) {
        if (ns.c_parentns_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_parentns_Reserve(ns, 1);
        ns.c_parentns_elems[n] = &row;
        ns.c_parentns_n = n+1;
    }
    return retval;
}

// --- amc.FNs.c_parentns.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_parentns_Remove(amc::FNs& ns, amc::FNs& row) {
    int lim = ns.c_parentns_n;
    amc::FNs* *elems = ns.c_parentns_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FNs* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FNs*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ns.c_parentns_n = lim - 1;
            break;
        }
    }
}

// --- amc.FNs.c_parentns.Reserve
// Reserve space in index for N more elements;
void amc::c_parentns_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_parentns_max;
    if (UNLIKELY(ns.c_parentns_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FNs*);
        u32 new_size = new_max * sizeof(amc::FNs*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_parentns_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_parentns");
        }
        ns.c_parentns_elems = (amc::FNs**)new_mem;
        ns.c_parentns_max = new_max;
    }
}

// --- amc.FNs.c_cppincl.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_cppincl_Insert(amc::FNs& ns, amc::FNs& row) {
    // reserve space
    c_cppincl_Reserve(ns, 1);
    u32 n  = ns.c_cppincl_n;
    u32 at = n;
    amc::FNs* *elems = ns.c_cppincl_elems;
    elems[at] = &row;
    ns.c_cppincl_n = n+1;

}

// --- amc.FNs.c_cppincl.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_cppincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) {
    bool retval = true;
    u32 n  = ns.c_cppincl_n;
    for (u32 i = 0; i < n; i++) {
        if (ns.c_cppincl_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_cppincl_Reserve(ns, 1);
        ns.c_cppincl_elems[n] = &row;
        ns.c_cppincl_n = n+1;
    }
    return retval;
}

// --- amc.FNs.c_cppincl.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_cppincl_Remove(amc::FNs& ns, amc::FNs& row) {
    int lim = ns.c_cppincl_n;
    amc::FNs* *elems = ns.c_cppincl_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FNs* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FNs*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ns.c_cppincl_n = lim - 1;
            break;
        }
    }
}

// --- amc.FNs.c_cppincl.Reserve
// Reserve space in index for N more elements;
void amc::c_cppincl_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_cppincl_max;
    if (UNLIKELY(ns.c_cppincl_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FNs*);
        u32 new_size = new_max * sizeof(amc::FNs*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_cppincl_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_cppincl");
        }
        ns.c_cppincl_elems = (amc::FNs**)new_mem;
        ns.c_cppincl_max = new_max;
    }
}

// --- amc.FNs.c_hdrincl.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_hdrincl_Insert(amc::FNs& ns, amc::FNs& row) {
    // reserve space
    c_hdrincl_Reserve(ns, 1);
    u32 n  = ns.c_hdrincl_n;
    u32 at = n;
    amc::FNs* *elems = ns.c_hdrincl_elems;
    elems[at] = &row;
    ns.c_hdrincl_n = n+1;

}

// --- amc.FNs.c_hdrincl.ScanInsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool amc::c_hdrincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) {
    bool retval = true;
    u32 n  = ns.c_hdrincl_n;
    for (u32 i = 0; i < n; i++) {
        if (ns.c_hdrincl_elems[i] == &row) {
            retval = false;
            break;
        }
    }
    if (retval) {
        // reserve space
        c_hdrincl_Reserve(ns, 1);
        ns.c_hdrincl_elems[n] = &row;
        ns.c_hdrincl_n = n+1;
    }
    return retval;
}

// --- amc.FNs.c_hdrincl.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_hdrincl_Remove(amc::FNs& ns, amc::FNs& row) {
    int lim = ns.c_hdrincl_n;
    amc::FNs* *elems = ns.c_hdrincl_elems;
    // search backward, so that most recently added element is found first.
    // if found, shift array.
    for (int i = lim-1; i>=0; i--) {
        amc::FNs* elem = elems[i]; // fetch element
        if (elem == &row) {
            int j = i + 1;
            size_t nbytes = sizeof(amc::FNs*) * (lim - j);
            memmove(elems + i, elems + j, nbytes);
            ns.c_hdrincl_n = lim - 1;
            break;
        }
    }
}

// --- amc.FNs.c_hdrincl.Reserve
// Reserve space in index for N more elements;
void amc::c_hdrincl_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_hdrincl_max;
    if (UNLIKELY(ns.c_hdrincl_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FNs*);
        u32 new_size = new_max * sizeof(amc::FNs*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_hdrincl_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_hdrincl");
        }
        ns.c_hdrincl_elems = (amc::FNs**)new_mem;
        ns.c_hdrincl_max = new_max;
    }
}

// --- amc.FNs.c_fwddecl.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_fwddecl_Insert(amc::FNs& ns, amc::FFwddecl& row) {
    if (bool_Update(row.ns_c_fwddecl_in_ary,true)) {
        // reserve space
        c_fwddecl_Reserve(ns, 1);
        u32 n  = ns.c_fwddecl_n;
        u32 at = n;
        amc::FFwddecl* *elems = ns.c_fwddecl_elems;
        elems[at] = &row;
        ns.c_fwddecl_n = n+1;

    }
}

// --- amc.FNs.c_fwddecl.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_fwddecl_InsertMaybe(amc::FNs& ns, amc::FFwddecl& row) {
    bool retval = !row.ns_c_fwddecl_in_ary;
    c_fwddecl_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_fwddecl.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_fwddecl_Remove(amc::FNs& ns, amc::FFwddecl& row) {
    if (bool_Update(row.ns_c_fwddecl_in_ary,false)) {
        int lim = ns.c_fwddecl_n;
        amc::FFwddecl* *elems = ns.c_fwddecl_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFwddecl* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFwddecl*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_fwddecl_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_fwddecl.Reserve
// Reserve space in index for N more elements;
void amc::c_fwddecl_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_fwddecl_max;
    if (UNLIKELY(ns.c_fwddecl_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFwddecl*);
        u32 new_size = new_max * sizeof(amc::FFwddecl*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_fwddecl_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_fwddecl");
        }
        ns.c_fwddecl_elems = (amc::FFwddecl**)new_mem;
        ns.c_fwddecl_max = new_max;
    }
}

// --- amc.FNs.c_pnew.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_pnew_Insert(amc::FNs& ns, amc::FPnew& row) {
    if (bool_Update(row.ns_c_pnew_in_ary,true)) {
        // reserve space
        c_pnew_Reserve(ns, 1);
        u32 n  = ns.c_pnew_n;
        u32 at = n;
        amc::FPnew* *elems = ns.c_pnew_elems;
        elems[at] = &row;
        ns.c_pnew_n = n+1;

    }
}

// --- amc.FNs.c_pnew.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_pnew_InsertMaybe(amc::FNs& ns, amc::FPnew& row) {
    bool retval = !row.ns_c_pnew_in_ary;
    c_pnew_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_pnew.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_pnew_Remove(amc::FNs& ns, amc::FPnew& row) {
    if (bool_Update(row.ns_c_pnew_in_ary,false)) {
        int lim = ns.c_pnew_n;
        amc::FPnew* *elems = ns.c_pnew_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FPnew* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FPnew*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_pnew_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_pnew.Reserve
// Reserve space in index for N more elements;
void amc::c_pnew_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_pnew_max;
    if (UNLIKELY(ns.c_pnew_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FPnew*);
        u32 new_size = new_max * sizeof(amc::FPnew*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_pnew_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_pnew");
        }
        ns.c_pnew_elems = (amc::FPnew**)new_mem;
        ns.c_pnew_max = new_max;
    }
}

// --- amc.FNs.c_outfile.Cascdel
// Delete all elements pointed to by the index.
void amc::c_outfile_Cascdel(amc::FNs& ns) {
    // Clear c_outfile_n so that calls to amc.FNs.c_outfile.Remove do not have to scan
    // the array for pointers or shift anything.
    // This is somewhat of a hack.
    i32 n = ns.c_outfile_n;
    ns.c_outfile_n = 0;
    for (i32 i = n - 1; i >= 0; i--) {
        amc::FOutfile &row = *ns.c_outfile_elems[i];
        row.ns_c_outfile_in_ary = false;
        outfile_Delete(row);
    }
}

// --- amc.FNs.c_outfile.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_outfile_Insert(amc::FNs& ns, amc::FOutfile& row) {
    if (bool_Update(row.ns_c_outfile_in_ary,true)) {
        // reserve space
        c_outfile_Reserve(ns, 1);
        u32 n  = ns.c_outfile_n;
        u32 at = n;
        amc::FOutfile* *elems = ns.c_outfile_elems;
        elems[at] = &row;
        ns.c_outfile_n = n+1;

    }
}

// --- amc.FNs.c_outfile.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_outfile_InsertMaybe(amc::FNs& ns, amc::FOutfile& row) {
    bool retval = !row.ns_c_outfile_in_ary;
    c_outfile_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_outfile.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_outfile_Remove(amc::FNs& ns, amc::FOutfile& row) {
    if (bool_Update(row.ns_c_outfile_in_ary,false)) {
        int lim = ns.c_outfile_n;
        amc::FOutfile* *elems = ns.c_outfile_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FOutfile* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FOutfile*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_outfile_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_outfile.Reserve
// Reserve space in index for N more elements;
void amc::c_outfile_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_outfile_max;
    if (UNLIKELY(ns.c_outfile_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FOutfile*);
        u32 new_size = new_max * sizeof(amc::FOutfile*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_outfile_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_outfile");
        }
        ns.c_outfile_elems = (amc::FOutfile**)new_mem;
        ns.c_outfile_max = new_max;
    }
}

// --- amc.FNs.c_finput.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_finput_Insert(amc::FNs& ns, amc::FFinput& row) {
    if (bool_Update(row.ns_c_finput_in_ary,true)) {
        // reserve space
        c_finput_Reserve(ns, 1);
        u32 n  = ns.c_finput_n;
        u32 at = n;
        amc::FFinput* *elems = ns.c_finput_elems;
        elems[at] = &row;
        ns.c_finput_n = n+1;

    }
}

// --- amc.FNs.c_finput.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_finput_InsertMaybe(amc::FNs& ns, amc::FFinput& row) {
    bool retval = !row.ns_c_finput_in_ary;
    c_finput_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_finput.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_finput_Remove(amc::FNs& ns, amc::FFinput& row) {
    if (bool_Update(row.ns_c_finput_in_ary,false)) {
        int lim = ns.c_finput_n;
        amc::FFinput* *elems = ns.c_finput_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFinput* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFinput*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_finput_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_finput.Reserve
// Reserve space in index for N more elements;
void amc::c_finput_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_finput_max;
    if (UNLIKELY(ns.c_finput_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFinput*);
        u32 new_size = new_max * sizeof(amc::FFinput*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_finput_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_finput");
        }
        ns.c_finput_elems = (amc::FFinput**)new_mem;
        ns.c_finput_max = new_max;
    }
}

// --- amc.FNs.c_foutput.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_foutput_Insert(amc::FNs& ns, amc::FFoutput& row) {
    if (bool_Update(row.ns_c_foutput_in_ary,true)) {
        // reserve space
        c_foutput_Reserve(ns, 1);
        u32 n  = ns.c_foutput_n;
        u32 at = n;
        amc::FFoutput* *elems = ns.c_foutput_elems;
        elems[at] = &row;
        ns.c_foutput_n = n+1;

    }
}

// --- amc.FNs.c_foutput.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_foutput_InsertMaybe(amc::FNs& ns, amc::FFoutput& row) {
    bool retval = !row.ns_c_foutput_in_ary;
    c_foutput_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_foutput.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_foutput_Remove(amc::FNs& ns, amc::FFoutput& row) {
    if (bool_Update(row.ns_c_foutput_in_ary,false)) {
        int lim = ns.c_foutput_n;
        amc::FFoutput* *elems = ns.c_foutput_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFoutput* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFoutput*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_foutput_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_foutput.Reserve
// Reserve space in index for N more elements;
void amc::c_foutput_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_foutput_max;
    if (UNLIKELY(ns.c_foutput_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFoutput*);
        u32 new_size = new_max * sizeof(amc::FFoutput*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_foutput_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_foutput");
        }
        ns.c_foutput_elems = (amc::FFoutput**)new_mem;
        ns.c_foutput_max = new_max;
    }
}

// --- amc.FNs.c_fstep.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_fstep_Insert(amc::FNs& ns, amc::FFstep& row) {
    if (bool_Update(row.ns_c_fstep_in_ary,true)) {
        // reserve space
        c_fstep_Reserve(ns, 1);
        u32 n  = ns.c_fstep_n;
        u32 at = n;
        amc::FFstep* *elems = ns.c_fstep_elems;
        elems[at] = &row;
        ns.c_fstep_n = n+1;

    }
}

// --- amc.FNs.c_fstep.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_fstep_InsertMaybe(amc::FNs& ns, amc::FFstep& row) {
    bool retval = !row.ns_c_fstep_in_ary;
    c_fstep_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_fstep.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_fstep_Remove(amc::FNs& ns, amc::FFstep& row) {
    if (bool_Update(row.ns_c_fstep_in_ary,false)) {
        int lim = ns.c_fstep_n;
        amc::FFstep* *elems = ns.c_fstep_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FFstep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FFstep*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_fstep_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_fstep.Reserve
// Reserve space in index for N more elements;
void amc::c_fstep_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_fstep_max;
    if (UNLIKELY(ns.c_fstep_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FFstep*);
        u32 new_size = new_max * sizeof(amc::FFstep*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_fstep_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_fstep");
        }
        ns.c_fstep_elems = (amc::FFstep**)new_mem;
        ns.c_fstep_max = new_max;
    }
}

// --- amc.FNs.c_gsymbol.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_gsymbol_Insert(amc::FNs& ns, amc::FGsymbol& row) {
    if (bool_Update(row.ns_c_gsymbol_in_ary,true)) {
        // reserve space
        c_gsymbol_Reserve(ns, 1);
        u32 n  = ns.c_gsymbol_n;
        u32 at = n;
        amc::FGsymbol* *elems = ns.c_gsymbol_elems;
        elems[at] = &row;
        ns.c_gsymbol_n = n+1;

    }
}

// --- amc.FNs.c_gsymbol.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_gsymbol_InsertMaybe(amc::FNs& ns, amc::FGsymbol& row) {
    bool retval = !row.ns_c_gsymbol_in_ary;
    c_gsymbol_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_gsymbol.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_gsymbol_Remove(amc::FNs& ns, amc::FGsymbol& row) {
    if (bool_Update(row.ns_c_gsymbol_in_ary,false)) {
        int lim = ns.c_gsymbol_n;
        amc::FGsymbol* *elems = ns.c_gsymbol_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FGsymbol* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FGsymbol*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_gsymbol_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_gsymbol.Reserve
// Reserve space in index for N more elements;
void amc::c_gsymbol_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_gsymbol_max;
    if (UNLIKELY(ns.c_gsymbol_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FGsymbol*);
        u32 new_size = new_max * sizeof(amc::FGsymbol*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_gsymbol_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_gsymbol");
        }
        ns.c_gsymbol_elems = (amc::FGsymbol**)new_mem;
        ns.c_gsymbol_max = new_max;
    }
}

// --- amc.FNs.c_nsinclude.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_nsinclude_Insert(amc::FNs& ns, amc::FNsinclude& row) {
    if (bool_Update(row.ns_c_nsinclude_in_ary,true)) {
        // reserve space
        c_nsinclude_Reserve(ns, 1);
        u32 n  = ns.c_nsinclude_n;
        u32 at = n;
        amc::FNsinclude* *elems = ns.c_nsinclude_elems;
        elems[at] = &row;
        ns.c_nsinclude_n = n+1;

    }
}

// --- amc.FNs.c_nsinclude.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_nsinclude_InsertMaybe(amc::FNs& ns, amc::FNsinclude& row) {
    bool retval = !row.ns_c_nsinclude_in_ary;
    c_nsinclude_Insert(ns,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FNs.c_nsinclude.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_nsinclude_Remove(amc::FNs& ns, amc::FNsinclude& row) {
    if (bool_Update(row.ns_c_nsinclude_in_ary,false)) {
        int lim = ns.c_nsinclude_n;
        amc::FNsinclude* *elems = ns.c_nsinclude_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FNsinclude* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FNsinclude*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                ns.c_nsinclude_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FNs.c_nsinclude.Reserve
// Reserve space in index for N more elements;
void amc::c_nsinclude_Reserve(amc::FNs& ns, u32 n) {
    u32 old_max = ns.c_nsinclude_max;
    if (UNLIKELY(ns.c_nsinclude_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FNsinclude*);
        u32 new_size = new_max * sizeof(amc::FNsinclude*);
        void *new_mem = amc::lpool_ReallocMem(ns.c_nsinclude_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FNs.c_nsinclude");
        }
        ns.c_nsinclude_elems = (amc::FNsinclude**)new_mem;
        ns.c_nsinclude_max = new_max;
    }
}

// --- amc.FNs..Init
// Set all fields to initial values.
void amc::FNs_Init(amc::FNs& ns) {
    ns.nhash = i32(0);
    ns.c_ctype_elems = NULL; // (amc.FNs.c_ctype)
    ns.c_ctype_n = 0; // (amc.FNs.c_ctype)
    ns.c_ctype_max = 0; // (amc.FNs.c_ctype)
    ns.c_func_elems = NULL; // (amc.FNs.c_func)
    ns.c_func_n = 0; // (amc.FNs.c_func)
    ns.c_func_max = 0; // (amc.FNs.c_func)
    ns.c_dispatch_elems = NULL; // (amc.FNs.c_dispatch)
    ns.c_dispatch_n = 0; // (amc.FNs.c_dispatch)
    ns.c_dispatch_max = 0; // (amc.FNs.c_dispatch)
    ns.c_globfld = NULL;
    ns.c_gstatic_elems = NULL; // (amc.FNs.c_gstatic)
    ns.c_gstatic_n = 0; // (amc.FNs.c_gstatic)
    ns.c_gstatic_max = 0; // (amc.FNs.c_gstatic)
    ns.c_main = NULL;
    ns.hdr = NULL;
    ns.inl = NULL;
    ns.cpp = NULL;
    ns.include_elems 	= 0; // (amc.FNs.include)
    ns.include_n     	= 0; // (amc.FNs.include)
    ns.include_max   	= 0; // (amc.FNs.include)
    ns.c_ctype_ins_elems = NULL; // (amc.FNs.c_ctype_ins)
    ns.c_ctype_ins_n = 0; // (amc.FNs.c_ctype_ins)
    ns.c_ctype_ins_max = 0; // (amc.FNs.c_ctype_ins)
    ns.topo_visited = bool(false);
    ns.c_dispsig_elems = NULL; // (amc.FNs.c_dispsig)
    ns.c_dispsig_n = 0; // (amc.FNs.c_dispsig)
    ns.c_dispsig_max = 0; // (amc.FNs.c_dispsig)
    ns.c_parentns_elems = NULL; // (amc.FNs.c_parentns)
    ns.c_parentns_n = 0; // (amc.FNs.c_parentns)
    ns.c_parentns_max = 0; // (amc.FNs.c_parentns)
    ns.c_cppincl_elems = NULL; // (amc.FNs.c_cppincl)
    ns.c_cppincl_n = 0; // (amc.FNs.c_cppincl)
    ns.c_cppincl_max = 0; // (amc.FNs.c_cppincl)
    ns.c_hdrincl_elems = NULL; // (amc.FNs.c_hdrincl)
    ns.c_hdrincl_n = 0; // (amc.FNs.c_hdrincl)
    ns.c_hdrincl_max = 0; // (amc.FNs.c_hdrincl)
    ns.c_fwddecl_elems = NULL; // (amc.FNs.c_fwddecl)
    ns.c_fwddecl_n = 0; // (amc.FNs.c_fwddecl)
    ns.c_fwddecl_max = 0; // (amc.FNs.c_fwddecl)
    ns.select = bool(false);
    ns.c_nsx = NULL;
    ns.c_target = NULL;
    ns.c_pnew_elems = NULL; // (amc.FNs.c_pnew)
    ns.c_pnew_n = 0; // (amc.FNs.c_pnew)
    ns.c_pnew_max = 0; // (amc.FNs.c_pnew)
    ns.c_fcmdline = NULL;
    ns.c_nsproto = NULL;
    ns.c_nsdb = NULL;
    ns.c_outfile_elems = NULL; // (amc.FNs.c_outfile)
    ns.c_outfile_n = 0; // (amc.FNs.c_outfile)
    ns.c_outfile_max = 0; // (amc.FNs.c_outfile)
    ns.c_finput_elems = NULL; // (amc.FNs.c_finput)
    ns.c_finput_n = 0; // (amc.FNs.c_finput)
    ns.c_finput_max = 0; // (amc.FNs.c_finput)
    ns.c_foutput_elems = NULL; // (amc.FNs.c_foutput)
    ns.c_foutput_n = 0; // (amc.FNs.c_foutput)
    ns.c_foutput_max = 0; // (amc.FNs.c_foutput)
    ns.c_fstep_elems = NULL; // (amc.FNs.c_fstep)
    ns.c_fstep_n = 0; // (amc.FNs.c_fstep)
    ns.c_fstep_max = 0; // (amc.FNs.c_fstep)
    ns.c_gsymbol_elems = NULL; // (amc.FNs.c_gsymbol)
    ns.c_gsymbol_n = 0; // (amc.FNs.c_gsymbol)
    ns.c_gsymbol_max = 0; // (amc.FNs.c_gsymbol)
    ns.c_nsinclude_elems = NULL; // (amc.FNs.c_nsinclude)
    ns.c_nsinclude_n = 0; // (amc.FNs.c_nsinclude)
    ns.c_nsinclude_max = 0; // (amc.FNs.c_nsinclude)
    ns.ind_ns_next = (amc::FNs*)-1; // (amc.FDb.ind_ns) not-in-hash
}

// --- amc.FNs..Uninit
void amc::FNs_Uninit(amc::FNs& ns) {
    amc::FNs &row = ns; (void)row;
    c_outfile_Cascdel(ns); // dmmeta.cascdel:amc.FNs.c_outfile
    ind_ns_Remove(row); // remove ns from index ind_ns

    // amc.FNs.c_nsinclude.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_nsinclude_elems, sizeof(amc::FNsinclude*)*ns.c_nsinclude_max); // (amc.FNs.c_nsinclude)

    // amc.FNs.c_gsymbol.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_gsymbol_elems, sizeof(amc::FGsymbol*)*ns.c_gsymbol_max); // (amc.FNs.c_gsymbol)

    // amc.FNs.c_fstep.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_fstep_elems, sizeof(amc::FFstep*)*ns.c_fstep_max); // (amc.FNs.c_fstep)

    // amc.FNs.c_foutput.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_foutput_elems, sizeof(amc::FFoutput*)*ns.c_foutput_max); // (amc.FNs.c_foutput)

    // amc.FNs.c_finput.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_finput_elems, sizeof(amc::FFinput*)*ns.c_finput_max); // (amc.FNs.c_finput)

    // amc.FNs.c_outfile.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_outfile_elems, sizeof(amc::FOutfile*)*ns.c_outfile_max); // (amc.FNs.c_outfile)

    // amc.FNs.c_pnew.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_pnew_elems, sizeof(amc::FPnew*)*ns.c_pnew_max); // (amc.FNs.c_pnew)

    // amc.FNs.c_fwddecl.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_fwddecl_elems, sizeof(amc::FFwddecl*)*ns.c_fwddecl_max); // (amc.FNs.c_fwddecl)

    // amc.FNs.c_hdrincl.Uninit (Ptrary)  //List of .h includes
    amc::lpool_FreeMem(ns.c_hdrincl_elems, sizeof(amc::FNs*)*ns.c_hdrincl_max); // (amc.FNs.c_hdrincl)

    // amc.FNs.c_cppincl.Uninit (Ptrary)  //List of .cpp includes
    amc::lpool_FreeMem(ns.c_cppincl_elems, sizeof(amc::FNs*)*ns.c_cppincl_max); // (amc.FNs.c_cppincl)

    // amc.FNs.c_parentns.Uninit (Ptrary)  //Namespaces implied by targdep
    amc::lpool_FreeMem(ns.c_parentns_elems, sizeof(amc::FNs*)*ns.c_parentns_max); // (amc.FNs.c_parentns)

    // amc.FNs.c_dispsig.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_dispsig_elems, sizeof(amc::FDispsig*)*ns.c_dispsig_max); // (amc.FNs.c_dispsig)

    // amc.FNs.c_ctype_ins.Uninit (Ptrary)  //Ctypes that can be inserted with LoadTuples, in right order
    amc::lpool_FreeMem(ns.c_ctype_ins_elems, sizeof(amc::FCtype*)*ns.c_ctype_ins_max); // (amc.FNs.c_ctype_ins)

    // amc.FNs.include.Uninit (Tary)  //
    // remove all elements from amc.FNs.include
    include_RemoveAll(ns);
    // free memory for Tary amc.FNs.include
    amc::lpool_FreeMem(ns.include_elems, sizeof(algo::cstring)*ns.include_max); // (amc.FNs.include)

    // amc.FNs.c_gstatic.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_gstatic_elems, sizeof(amc::FGstatic*)*ns.c_gstatic_max); // (amc.FNs.c_gstatic)

    // amc.FNs.c_dispatch.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_dispatch_elems, sizeof(amc::FDispatch*)*ns.c_dispatch_max); // (amc.FNs.c_dispatch)

    // amc.FNs.c_func.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_func_elems, sizeof(amc::FFunc*)*ns.c_func_max); // (amc.FNs.c_func)

    // amc.FNs.c_ctype.Uninit (Ptrary)  //
    amc::lpool_FreeMem(ns.c_ctype_elems, sizeof(amc::FCtype*)*ns.c_ctype_max); // (amc.FNs.c_ctype)
}

// --- amc.FNsdb.base.CopyOut
// Copy fields out of row
void amc::nsdb_CopyOut(amc::FNsdb &row, dmmeta::Nsdb &out) {
    out.ns = row.ns;
    out.comment = row.comment;
}

// --- amc.FNsdb.base.CopyIn
// Copy fields in to row
void amc::nsdb_CopyIn(amc::FNsdb &row, dmmeta::Nsdb &in) {
    row.ns = in.ns;
    row.comment = in.comment;
}

// --- amc.FNsdb..Uninit
void amc::FNsdb_Uninit(amc::FNsdb& nsdb) {
    amc::FNsdb &row = nsdb; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (p_ns)  {
        c_nsdb_Remove(*p_ns, row);// remove nsdb from index c_nsdb
    }
}

// --- amc.FNsinclude.base.CopyOut
// Copy fields out of row
void amc::nsinclude_CopyOut(amc::FNsinclude &row, dmmeta::Nsinclude &out) {
    out.nsinclude = row.nsinclude;
    out.sys = row.sys;
    out.comment = row.comment;
}

// --- amc.FNsinclude.base.CopyIn
// Copy fields in to row
void amc::nsinclude_CopyIn(amc::FNsinclude &row, dmmeta::Nsinclude &in) {
    row.nsinclude = in.nsinclude;
    row.sys = in.sys;
    row.comment = in.comment;
}

// --- amc.FNsinclude.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FNsinclude& nsinclude) {
    algo::Smallstr16 ret(algo::Pathcomp(nsinclude.nsinclude, "/LL"));
    return ret;
}

// --- amc.FNsinclude.name.Get
algo::Smallstr50 amc::name_Get(amc::FNsinclude& nsinclude) {
    algo::Smallstr50 ret(algo::Pathcomp(nsinclude.nsinclude, "/LR"));
    return ret;
}

// --- amc.FNsinclude..Uninit
void amc::FNsinclude_Uninit(amc::FNsinclude& nsinclude) {
    amc::FNsinclude &row = nsinclude; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_nsinclude_Remove(*p_ns, row);// remove nsinclude from index c_nsinclude
    }
}

// --- amc.FNsproto.base.CopyOut
// Copy fields out of row
void amc::nsproto_CopyOut(amc::FNsproto &row, dmmeta::Nsproto &out) {
    out.ns = row.ns;
    out.comment = row.comment;
}

// --- amc.FNsproto.base.CopyIn
// Copy fields in to row
void amc::nsproto_CopyIn(amc::FNsproto &row, dmmeta::Nsproto &in) {
    row.ns = in.ns;
    row.comment = in.comment;
}

// --- amc.FNsproto..Uninit
void amc::FNsproto_Uninit(amc::FNsproto& nsproto) {
    amc::FNsproto &row = nsproto; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (p_ns)  {
        c_nsproto_Remove(*p_ns, row);// remove nsproto from index c_nsproto
    }
}

// --- amc.FNsx.base.CopyOut
// Copy fields out of row
void amc::nsx_CopyOut(amc::FNsx &row, dmmeta::Nsx &out) {
    out.ns = row.ns;
    out.genthrow = row.genthrow;
    out.correct_getorcreate = row.correct_getorcreate;
    out.pool = row.pool;
    out.sortxref = row.sortxref;
    out.pack = row.pack;
    out.fldoffset_asserts = row.fldoffset_asserts;
    out.comment = row.comment;
}

// --- amc.FNsx.base.CopyIn
// Copy fields in to row
void amc::nsx_CopyIn(amc::FNsx &row, dmmeta::Nsx &in) {
    row.ns = in.ns;
    row.genthrow = in.genthrow;
    row.correct_getorcreate = in.correct_getorcreate;
    row.pool = in.pool;
    row.sortxref = in.sortxref;
    row.pack = in.pack;
    row.fldoffset_asserts = in.fldoffset_asserts;
    row.comment = in.comment;
}

// --- amc.FNsx..Uninit
void amc::FNsx_Uninit(amc::FNsx& nsx) {
    amc::FNsx &row = nsx; (void)row;
    amc::FNs* p_ns = amc::ind_ns_Find(row.ns);
    if (p_ns)  {
        c_nsx_Remove(*p_ns, row);// remove nsx from index c_nsx
    }
}

// --- amc.FNumstr.msghdr.CopyIn
// Copy fields in to row
void amc::numstr_CopyIn(amc::FNumstr &row, dmmeta::Numstr &in) {
    row.field = in.field;
    row.numtype = in.numtype;
    row.base = in.base;
    row.min_len = in.min_len;
}

// --- amc.FNumstr..Uninit
void amc::FNumstr_Uninit(amc::FNumstr& numstr) {
    amc::FNumstr &row = numstr; (void)row;
    amc::FSmallstr* p_field = amc::ind_smallstr_Find(row.field);
    if (p_field)  {
        c_numstr_Remove(*p_field, row);// remove numstr from index c_numstr
    }
}

// --- amc.FOutfile.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FOutfile& outfile) {
    algo::Smallstr16 ret(algo::Pathcomp(outfile.outfile, "/RR_RL"));
    return ret;
}

// --- amc.FOutfile..Uninit
void amc::FOutfile_Uninit(amc::FOutfile& outfile) {
    amc::FOutfile &row = outfile; (void)row;
    amc::FNs* p_p_ns = row.p_ns;
    if (p_p_ns)  {
        c_outfile_Remove(*p_p_ns, row);// remove outfile from index c_outfile
    }
}

// --- amc.FPack.msghdr.CopyIn
// Copy fields in to row
void amc::pack_CopyIn(amc::FPack &row, dmmeta::Pack &in) {
    row.ctype = in.ctype;
    // comment stripped, see dmmeta.fbase:amc.FPack.msghdr
}

// --- amc.FPack..Uninit
void amc::FPack_Uninit(amc::FPack& pack) {
    amc::FPack &row = pack; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_pack_Remove(*p_ctype, row);// remove pack from index c_pack
    }
    ind_pack_Remove(row); // remove pack from index ind_pack
}

// --- amc.FPmaskfld.msghdr.CopyOut
// Copy fields out of row
void amc::pmaskfld_CopyOut(amc::FPmaskfld &row, dmmeta::Pmaskfld &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FPmaskfld.msghdr.CopyIn
// Copy fields in to row
void amc::pmaskfld_CopyIn(amc::FPmaskfld &row, dmmeta::Pmaskfld &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FPmaskfld.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FPmaskfld& pmaskfld) {
    algo::Smallstr50 ret(algo::Pathcomp(pmaskfld.field, ".RL"));
    return ret;
}

// --- amc.FPmaskfld..Uninit
void amc::FPmaskfld_Uninit(amc::FPmaskfld& pmaskfld) {
    amc::FPmaskfld &row = pmaskfld; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_pmaskfld_Remove(*p_ctype, row);// remove pmaskfld from index c_pmaskfld
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_pmaskfld_Remove(*p_field, row);// remove pmaskfld from index c_pmaskfld
    }
}

// --- amc.FPnew.msghdr.CopyIn
// Copy fields in to row
void amc::pnew_CopyIn(amc::FPnew &row, dmmeta::Pnew &in) {
    row.pnew = in.pnew;
    // comment stripped, see dmmeta.fbase:amc.FPnew.msghdr
}

// --- amc.FPnew.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FPnew& pnew) {
    algo::Smallstr16 ret(algo::Pathcomp(pnew.pnew, "/LL"));
    return ret;
}

// --- amc.FPnew.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FPnew& pnew) {
    algo::Smallstr50 ret(algo::Pathcomp(pnew.pnew, "/LR.RL"));
    return ret;
}

// --- amc.FPnew.buftype.Get
algo::Smallstr50 amc::buftype_Get(amc::FPnew& pnew) {
    algo::Smallstr50 ret(algo::Pathcomp(pnew.pnew, "/LR.RR"));
    return ret;
}

// --- amc.FPnew..Uninit
void amc::FPnew_Uninit(amc::FPnew& pnew) {
    amc::FPnew &row = pnew; (void)row;
    ind_pnew_Remove(row); // remove pnew from index ind_pnew
    amc::FNs* p_ns = amc::ind_ns_Find(ns_Get(row));
    if (p_ns)  {
        c_pnew_Remove(*p_ns, row);// remove pnew from index c_pnew
    }
}

// --- amc.FPtrary.msghdr.CopyIn
// Copy fields in to row
void amc::ptrary_CopyIn(amc::FPtrary &row, dmmeta::Ptrary &in) {
    row.field = in.field;
    row.unique = in.unique;
}

// --- amc.FPtrary..Uninit
void amc::FPtrary_Uninit(amc::FPtrary& ptrary) {
    amc::FPtrary &row = ptrary; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_ptrary_Remove(*p_field, row);// remove ptrary from index c_ptrary
    }
}

// --- amc.FReftype.msghdr.CopyIn
// Copy fields in to row
void amc::reftype_CopyIn(amc::FReftype &row, dmmeta::Reftype &in) {
    row.reftype = in.reftype;
    row.isval = in.isval;
    row.cascins = in.cascins;
    row.usebasepool = in.usebasepool;
    row.cancopy = in.cancopy;
    row.isxref = in.isxref;
    row.del = in.del;
    row.up = in.up;
    row.isnew = in.isnew;
    row.hasalloc = in.hasalloc;
    row.inst = in.inst;
    row.varlen = in.varlen;
}

// --- amc.FReftype.zs_fprefix.Insert
// Insert row into linked list. If row is already in linked list, do nothing.
void amc::zs_fprefix_Insert(amc::FReftype& reftype, amc::FFprefix& row) {
    if (!zs_fprefix_InLlistQ(row)) {
        amc::FFprefix* old_tail       = reftype.zs_fprefix_tail;
        row.zs_fprefix_next  = NULL;
        reftype.zs_fprefix_tail = &row;
        amc::FFprefix **new_row_a = &old_tail->zs_fprefix_next;
        amc::FFprefix **new_row_b = &reftype.zs_fprefix_head;
        amc::FFprefix **new_row = old_tail ? new_row_a : new_row_b;
        *new_row = &row;
    }
}

// --- amc.FReftype.zs_fprefix.Remove
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void amc::zs_fprefix_Remove(amc::FReftype& reftype, amc::FFprefix& row) {
    if (zs_fprefix_InLlistQ(row)) {
        amc::FFprefix* old_head       = reftype.zs_fprefix_head;
        (void)old_head; // in case it's not used
        amc::FFprefix* prev=NULL;
        amc::FFprefix* cur     = reftype.zs_fprefix_head;
        while (cur) {  // search for element by pointer
            amc::FFprefix* next = cur->zs_fprefix_next;
            if (cur == &row) {

                if (!next) {
                    reftype.zs_fprefix_tail = prev;  // adjust tail pointer
                }
                // disconnect element from linked list
                if (prev) {
                    prev->zs_fprefix_next = next;
                } else {
                    reftype.zs_fprefix_head = next;
                }
                row.zs_fprefix_next = (amc::FFprefix*)-1; // not-in-list
                break;
            }
            prev = cur;
            cur  = next;
        }
    }
}

// --- amc.FReftype.zs_fprefix.RemoveAll
// Empty the index. (The rows are not deleted)
void amc::zs_fprefix_RemoveAll(amc::FReftype& reftype) {
    amc::FFprefix* row = reftype.zs_fprefix_head;
    reftype.zs_fprefix_head = NULL;
    reftype.zs_fprefix_tail = NULL;
    while (row) {
        amc::FFprefix* row_next = row->zs_fprefix_next;
        row->zs_fprefix_next  = (amc::FFprefix*)-1;
        row = row_next;
    }
}

// --- amc.FReftype.zs_fprefix.RemoveFirst
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFprefix* amc::zs_fprefix_RemoveFirst(amc::FReftype& reftype) {
    amc::FFprefix *row = NULL;
    row = reftype.zs_fprefix_head;
    if (row) {
        amc::FFprefix *next = row->zs_fprefix_next;
        reftype.zs_fprefix_head = next;
        // clear list's tail pointer if list is empty.
        if (!next) {
            reftype.zs_fprefix_tail = NULL;
        }
        row->zs_fprefix_next = (amc::FFprefix*)-1; // mark as not-in-list
    }
    return row;
}

// --- amc.FReftype..Init
// Set all fields to initial values.
void amc::FReftype_Init(amc::FReftype& reftype) {
    reftype.reftype = algo::strptr("Val");
    reftype.isval = bool(false);
    reftype.cascins = bool(false);
    reftype.usebasepool = bool(false);
    reftype.cancopy = bool(false);
    reftype.isxref = bool(false);
    reftype.del = bool(false);
    reftype.up = bool(false);
    reftype.isnew = bool(false);
    reftype.hasalloc = bool(false);
    reftype.inst = bool(false);
    reftype.varlen = bool(false);
    reftype.p_tclass = NULL;
    reftype.zs_fprefix_head = NULL; // (amc.FReftype.zs_fprefix)
    reftype.zs_fprefix_tail = NULL; // (amc.FReftype.zs_fprefix)
    reftype.ind_reftype_next = (amc::FReftype*)-1; // (amc.FDb.ind_reftype) not-in-hash
}

// --- amc.FReftype..Uninit
void amc::FReftype_Uninit(amc::FReftype& reftype) {
    amc::FReftype &row = reftype; (void)row;
    ind_reftype_Remove(row); // remove reftype from index ind_reftype
}

// --- amc.FRowid.msghdr.CopyOut
// Copy fields out of row
void amc::rowid_CopyOut(amc::FRowid &row, dmmeta::Rowid &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FRowid.msghdr.CopyIn
// Copy fields in to row
void amc::rowid_CopyIn(amc::FRowid &row, dmmeta::Rowid &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FRowid..Uninit
void amc::FRowid_Uninit(amc::FRowid& rowid) {
    amc::FRowid &row = rowid; (void)row;
    ind_rowid_Remove(row); // remove rowid from index ind_rowid
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_rowid_Remove(*p_field, row);// remove rowid from index c_rowid
    }
}

// --- amc.FSmallstr.msghdr.CopyIn
// Copy fields in to row
void amc::smallstr_CopyIn(amc::FSmallstr &row, dmmeta::Smallstr &in) {
    row.field = in.field;
    row.length = in.length;
    row.strtype = in.strtype;
    row.pad = in.pad;
    row.strict = in.strict;
}

// --- amc.FSmallstr.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FSmallstr& smallstr) {
    algo::Smallstr50 ret(algo::Pathcomp(smallstr.field, ".RL"));
    return ret;
}

// --- amc.FSmallstr..Uninit
void amc::FSmallstr_Uninit(amc::FSmallstr& smallstr) {
    amc::FSmallstr &row = smallstr; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_smallstr_Remove(*p_field, row);// remove smallstr from index c_smallstr
    }
    ind_smallstr_Remove(row); // remove smallstr from index ind_smallstr
}

// --- amc.FSortfld.msghdr.CopyIn
// Copy fields in to row
void amc::sortfld_CopyIn(amc::FSortfld &row, dmmeta::Sortfld &in) {
    row.field = in.field;
    row.sortfld = in.sortfld;
}

// --- amc.FSortfld..Uninit
void amc::FSortfld_Uninit(amc::FSortfld& sortfld) {
    amc::FSortfld &row = sortfld; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_sortfld_Remove(*p_field, row);// remove sortfld from index c_sortfld
    }
}

// --- amc.FSsimfile.msghdr.CopyIn
// Copy fields in to row
void amc::ssimfile_CopyIn(amc::FSsimfile &row, dmmeta::Ssimfile &in) {
    row.ssimfile = in.ssimfile;
    row.ctype = in.ctype;
}

// --- amc.FSsimfile.ssimns.Get
algo::Smallstr16 amc::ssimns_Get(amc::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- amc.FSsimfile.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FSsimfile& ssimfile) {
    algo::Smallstr16 ret(algo::Pathcomp(ssimfile.ssimfile, ".LL"));
    return ret;
}

// --- amc.FSsimfile.name.Get
algo::Smallstr50 amc::name_Get(amc::FSsimfile& ssimfile) {
    algo::Smallstr50 ret(algo::Pathcomp(ssimfile.ssimfile, ".RR"));
    return ret;
}

// --- amc.FSsimfile..Uninit
void amc::FSsimfile_Uninit(amc::FSsimfile& ssimfile) {
    amc::FSsimfile &row = ssimfile; (void)row;
    ind_ssimfile_Remove(row); // remove ssimfile from index ind_ssimfile
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_ssimfile_Remove(*p_ctype, row);// remove ssimfile from index c_ssimfile
    }
}

// --- amc.FSsimvolatile.base.CopyOut
// Copy fields out of row
void amc::ssimvolatile_CopyOut(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &out) {
    out.ssimfile = row.ssimfile;
    out.comment = row.comment;
}

// --- amc.FSsimvolatile.base.CopyIn
// Copy fields in to row
void amc::ssimvolatile_CopyIn(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &in) {
    row.ssimfile = in.ssimfile;
    row.comment = in.comment;
}

// --- amc.FSsimvolatile..Uninit
void amc::FSsimvolatile_Uninit(amc::FSsimvolatile& ssimvolatile) {
    amc::FSsimvolatile &row = ssimvolatile; (void)row;
    amc::FSsimfile* p_ssimfile = amc::ind_ssimfile_Find(row.ssimfile);
    if (p_ssimfile)  {
        c_ssimvolatile_Remove(*p_ssimfile, row);// remove ssimvolatile from index c_ssimvolatile
    }
}

// --- amc.FStatictuple..Uninit
void amc::FStatictuple_Uninit(amc::FStatictuple& static_tuple) {
    amc::FStatictuple &row = static_tuple; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(row.ctype);
    if (p_ctype)  {
        c_static_Remove(*p_ctype, row);// remove static_tuple from index c_static
    }
}

// --- amc.FSubstr.msghdr.CopyOut
// Copy fields out of row
void amc::substr_CopyOut(amc::FSubstr &row, dmmeta::Substr &out) {
    out.field = row.field;
    out.expr = row.expr;
    out.srcfield = row.srcfield;
}

// --- amc.FSubstr.msghdr.CopyIn
// Copy fields in to row
void amc::substr_CopyIn(amc::FSubstr &row, dmmeta::Substr &in) {
    row.field = in.field;
    row.expr = in.expr;
    row.srcfield = in.srcfield;
}

// --- amc.FSubstr..Uninit
void amc::FSubstr_Uninit(amc::FSubstr& substr) {
    amc::FSubstr &row = substr; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_substr_Remove(*p_field, row);// remove substr from index c_substr
    }
    zd_substr_params_Remove(row); // remove substr from index zd_substr_params
}

// --- amc.FTargdep.msghdr.CopyIn
// Copy fields in to row
void amc::targdep_CopyIn(amc::FTargdep &row, dev::Targdep &in) {
    row.targdep = in.targdep;
    // comment stripped, see dmmeta.fbase:amc.FTargdep.msghdr
}

// --- amc.FTargdep.target.Get
algo::Smallstr16 amc::target_Get(amc::FTargdep& targdep) {
    algo::Smallstr16 ret(algo::Pathcomp(targdep.targdep, ".RL"));
    return ret;
}

// --- amc.FTargdep.parent.Get
algo::Smallstr16 amc::parent_Get(amc::FTargdep& targdep) {
    algo::Smallstr16 ret(algo::Pathcomp(targdep.targdep, ".RR"));
    return ret;
}

// --- amc.FTargdep..Uninit
void amc::FTargdep_Uninit(amc::FTargdep& targdep) {
    amc::FTargdep &row = targdep; (void)row;
    amc::FTarget* p_target = amc::ind_target_Find(target_Get(row));
    if (p_target)  {
        c_targdep_Remove(*p_target, row);// remove targdep from index c_targdep
    }
}

// --- amc.FTarget.msghdr.CopyIn
// Copy fields in to row
void amc::target_CopyIn(amc::FTarget &row, dev::Target &in) {
    row.target = in.target;
    row.license = in.license;
    row.compat = in.compat;
}

// --- amc.FTarget.c_targdep.Insert
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void amc::c_targdep_Insert(amc::FTarget& target, amc::FTargdep& row) {
    if (bool_Update(row.target_c_targdep_in_ary,true)) {
        // reserve space
        c_targdep_Reserve(target, 1);
        u32 n  = target.c_targdep_n;
        u32 at = n;
        amc::FTargdep* *elems = target.c_targdep_elems;
        elems[at] = &row;
        target.c_targdep_n = n+1;

    }
}

// --- amc.FTarget.c_targdep.InsertMaybe
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool amc::c_targdep_InsertMaybe(amc::FTarget& target, amc::FTargdep& row) {
    bool retval = !row.target_c_targdep_in_ary;
    c_targdep_Insert(target,row); // check is performed in _Insert again
    return retval;
}

// --- amc.FTarget.c_targdep.Remove
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void amc::c_targdep_Remove(amc::FTarget& target, amc::FTargdep& row) {
    if (bool_Update(row.target_c_targdep_in_ary,false)) {
        int lim = target.c_targdep_n;
        amc::FTargdep* *elems = target.c_targdep_elems;
        // search backward, so that most recently added element is found first.
        // if found, shift array.
        for (int i = lim-1; i>=0; i--) {
            amc::FTargdep* elem = elems[i]; // fetch element
            if (elem == &row) {
                int j = i + 1;
                size_t nbytes = sizeof(amc::FTargdep*) * (lim - j);
                memmove(elems + i, elems + j, nbytes);
                target.c_targdep_n = lim - 1;
                break;
            }
        }
    }
}

// --- amc.FTarget.c_targdep.Reserve
// Reserve space in index for N more elements;
void amc::c_targdep_Reserve(amc::FTarget& target, u32 n) {
    u32 old_max = target.c_targdep_max;
    if (UNLIKELY(target.c_targdep_n + n > old_max)) {
        u32 new_max  = u32_Max(4, old_max * 2);
        u32 old_size = old_max * sizeof(amc::FTargdep*);
        u32 new_size = new_max * sizeof(amc::FTargdep*);
        void *new_mem = amc::lpool_ReallocMem(target.c_targdep_elems, old_size, new_size);
        if (UNLIKELY(!new_mem)) {
            FatalErrorExit("amc.out_of_memory  field:amc.FTarget.c_targdep");
        }
        target.c_targdep_elems = (amc::FTargdep**)new_mem;
        target.c_targdep_max = new_max;
    }
}

// --- amc.FTarget..Uninit
void amc::FTarget_Uninit(amc::FTarget& target) {
    amc::FTarget &row = target; (void)row;
    ind_target_Remove(row); // remove target from index ind_target
    amc::FNs* p_target = amc::ind_ns_Find(row.target);
    if (p_target)  {
        c_target_Remove(*p_target, row);// remove target from index c_target
    }

    // amc.FTarget.c_targdep.Uninit (Ptrary)  //
    amc::lpool_FreeMem(target.c_targdep_elems, sizeof(amc::FTargdep*)*target.c_targdep_max); // (amc.FTarget.c_targdep)
}

// --- amc.FTary.msghdr.CopyIn
// Copy fields in to row
void amc::tary_CopyIn(amc::FTary &row, dmmeta::Tary &in) {
    row.field = in.field;
    row.aliased = in.aliased;
    // comment stripped, see dmmeta.fbase:amc.FTary.msghdr
}

// --- amc.FTary..Uninit
void amc::FTary_Uninit(amc::FTary& tary) {
    amc::FTary &row = tary; (void)row;
    ind_tary_Remove(row); // remove tary from index ind_tary
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_tary_Remove(*p_field, row);// remove tary from index c_tary
    }
}

// --- amc.FTcurs.base.CopyOut
// Copy fields out of row
void amc::tcurs_CopyOut(amc::FTcurs &row, amcdb::Tcurs &out) {
    out.tfunc = row.tfunc;
    out.dflt = row.dflt;
    out.comment = row.comment;
}

// --- amc.FTcurs.base.CopyIn
// Copy fields in to row
void amc::tcurs_CopyIn(amc::FTcurs &row, amcdb::Tcurs &in) {
    row.tfunc = in.tfunc;
    row.dflt = in.dflt;
    row.comment = in.comment;
}

// --- amc.FTcurs.curstype.Get
algo::Smallstr50 amc::curstype_Get(amc::FTcurs& tcurs) {
    algo::Smallstr50 ret(algo::Pathcomp(tcurs.tfunc, ".RR"));
    return ret;
}

// --- amc.FTcurs..Uninit
void amc::FTcurs_Uninit(amc::FTcurs& tcurs) {
    amc::FTcurs &row = tcurs; (void)row;
    amc::FTfunc* p_tfunc = amc::ind_tfunc_Find(row.tfunc);
    if (p_tfunc)  {
        c_tcurs_Remove(*p_tfunc, row);// remove tcurs from index c_tcurs
    }
}

// --- amc.FTfunc.msghdr.CopyOut
// Copy fields out of row
void amc::tfunc_CopyOut(amc::FTfunc &row, amcdb::Tfunc &out) {
    out.tfunc = row.tfunc;
    out.hasthrow = row.hasthrow;
    out.leaf = row.leaf;
    out.poolfunc = row.poolfunc;
    out.inl = row.inl;
    out.wur = row.wur;
    out.pure = row.pure;
    out.ismacro = row.ismacro;
    out.comment = row.comment;
}

// --- amc.FTfunc.msghdr.CopyIn
// Copy fields in to row
void amc::tfunc_CopyIn(amc::FTfunc &row, amcdb::Tfunc &in) {
    row.tfunc = in.tfunc;
    row.hasthrow = in.hasthrow;
    row.leaf = in.leaf;
    row.poolfunc = in.poolfunc;
    row.inl = in.inl;
    row.wur = in.wur;
    row.pure = in.pure;
    row.ismacro = in.ismacro;
    row.comment = in.comment;
}

// --- amc.FTfunc.tclass.Get
algo::Smallstr50 amc::tclass_Get(amc::FTfunc& tfunc) {
    algo::Smallstr50 ret(algo::Pathcomp(tfunc.tfunc, ".RL"));
    return ret;
}

// --- amc.FTfunc.name.Get
algo::Smallstr50 amc::name_Get(amc::FTfunc& tfunc) {
    algo::Smallstr50 ret(algo::Pathcomp(tfunc.tfunc, ".RR"));
    return ret;
}

// --- amc.FTfunc..Init
// Set all fields to initial values.
void amc::FTfunc_Init(amc::FTfunc& tfunc) {
    tfunc.hasthrow = bool(false);
    tfunc.leaf = bool(true);
    tfunc.poolfunc = bool(false);
    tfunc.inl = bool(false);
    tfunc.wur = bool(false);
    tfunc.pure = bool(false);
    tfunc.ismacro = bool(false);
    tfunc.c_tcurs = NULL;
    tfunc.tclass_c_tfunc_in_ary = bool(false);
    tfunc.ind_tfunc_next = (amc::FTfunc*)-1; // (amc.FDb.ind_tfunc) not-in-hash
    tfunc.step = NULL;
}

// --- amc.FTfunc..Uninit
void amc::FTfunc_Uninit(amc::FTfunc& tfunc) {
    amc::FTfunc &row = tfunc; (void)row;
    ind_tfunc_Remove(row); // remove tfunc from index ind_tfunc
    amc::FTclass* p_tclass = amc::ind_tclass_Find(tclass_Get(row));
    if (p_tclass)  {
        c_tfunc_Remove(*p_tclass, row);// remove tfunc from index c_tfunc
    }
}

// --- amc.FThash.msghdr.CopyIn
// Copy fields in to row
void amc::thash_CopyIn(amc::FThash &row, dmmeta::Thash &in) {
    row.field = in.field;
    row.hashfld = in.hashfld;
    row.unique = in.unique;
    // comment stripped, see dmmeta.fbase:amc.FThash.msghdr
}

// --- amc.FThash..Uninit
void amc::FThash_Uninit(amc::FThash& thash) {
    amc::FThash &row = thash; (void)row;
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_thash_Remove(*p_field, row);// remove thash from index c_thash
    }
}

// --- amc.FTracefld.msghdr.CopyOut
// Copy fields out of row
void amc::tracefld_CopyOut(amc::FTracefld &row, dmmeta::Tracefld &out) {
    out.tracefld = row.tracefld;
    out.comment = row.comment;
}

// --- amc.FTracefld.msghdr.CopyIn
// Copy fields in to row
void amc::tracefld_CopyIn(amc::FTracefld &row, dmmeta::Tracefld &in) {
    row.tracefld = in.tracefld;
    row.comment = in.comment;
}

// --- amc.FTracefld.tracerec.Get
algo::Smallstr50 amc::tracerec_Get(amc::FTracefld& tracefld) {
    algo::Smallstr50 ret(algo::Pathcomp(tracefld.tracefld, ".RL"));
    return ret;
}

// --- amc.FTracefld.name.Get
algo::Smallstr50 amc::name_Get(amc::FTracefld& tracefld) {
    algo::Smallstr50 ret(algo::Pathcomp(tracefld.tracefld, ".RR"));
    return ret;
}

// --- amc.FTracerec.msghdr.CopyOut
// Copy fields out of row
void amc::tracerec_CopyOut(amc::FTracerec &row, dmmeta::Tracerec &out) {
    out.tracerec = row.tracerec;
    out.comment = row.comment;
}

// --- amc.FTracerec.msghdr.CopyIn
// Copy fields in to row
void amc::tracerec_CopyIn(amc::FTracerec &row, dmmeta::Tracerec &in) {
    row.tracerec = in.tracerec;
    row.comment = in.comment;
}

// --- amc.FTracerec.name.Get
algo::Smallstr50 amc::name_Get(amc::FTracerec& tracerec) {
    algo::Smallstr50 ret(algo::Pathcomp(tracerec.tracerec, ".LL"));
    return ret;
}

// --- amc.FTypefld.msghdr.CopyOut
// Copy fields out of row
void amc::typefld_CopyOut(amc::FTypefld &row, dmmeta::Typefld &out) {
    out.field = row.field;
    out.comment = row.comment;
}

// --- amc.FTypefld.msghdr.CopyIn
// Copy fields in to row
void amc::typefld_CopyIn(amc::FTypefld &row, dmmeta::Typefld &in) {
    row.field = in.field;
    row.comment = in.comment;
}

// --- amc.FTypefld.ctype.Get
algo::Smallstr50 amc::ctype_Get(amc::FTypefld& typefld) {
    algo::Smallstr50 ret(algo::Pathcomp(typefld.field, ".RL"));
    return ret;
}

// --- amc.FTypefld..Uninit
void amc::FTypefld_Uninit(amc::FTypefld& typefld) {
    amc::FTypefld &row = typefld; (void)row;
    amc::FCtype* p_ctype = amc::ind_ctype_Find(ctype_Get(row));
    if (p_ctype)  {
        c_typefld_Remove(*p_ctype, row);// remove typefld from index c_typefld
    }
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_typefld_Remove(*p_field, row);// remove typefld from index c_typefld
    }
}

// --- amc.FUsertracefld.msghdr.CopyOut
// Copy fields out of row
void amc::usertracefld_CopyOut(amc::FUsertracefld &row, dmmeta::Usertracefld &out) {
    out.tracefld = row.tracefld;
    out.comment = row.comment;
}

// --- amc.FUsertracefld.msghdr.CopyIn
// Copy fields in to row
void amc::usertracefld_CopyIn(amc::FUsertracefld &row, dmmeta::Usertracefld &in) {
    row.tracefld = in.tracefld;
    row.comment = in.comment;
}

// --- amc.FXref.msghdr.CopyIn
// Copy fields in to row
void amc::xref_CopyIn(amc::FXref &row, dmmeta::Xref &in) {
    row.field = in.field;
    row.inscond = in.inscond;
    row.via = in.via;
}

// --- amc.FXref.name.Get
algo::Smallstr50 amc::name_Get(amc::FXref& xref) {
    algo::Smallstr50 ret(algo::Pathcomp(xref.field, ".RR"));
    return ret;
}

// --- amc.FXref.ns.Get
algo::Smallstr16 amc::ns_Get(amc::FXref& xref) {
    algo::Smallstr16 ret(algo::Pathcomp(xref.field, ".LL"));
    return ret;
}

// --- amc.FXref.viafld.Get
algo::Smallstr100 amc::viafld_Get(amc::FXref& xref) {
    algo::Smallstr100 ret(algo::Pathcomp(xref.via, "/LL"));
    return ret;
}

// --- amc.FXref.keyfld.Get
algo::Smallstr100 amc::keyfld_Get(amc::FXref& xref) {
    algo::Smallstr100 ret(algo::Pathcomp(xref.via, "/RR"));
    return ret;
}

// --- amc.FXref..Init
// Set all fields to initial values.
void amc::FXref_Init(amc::FXref& xref) {
    xref.inscond = dmmeta::CppExpr("true");
    xref.p_field = NULL;
    xref.p_ctype = NULL;
    xref.c_nocascdel = NULL;
    xref.p_viafld = NULL;
    xref.p_keyfld = NULL;
    xref.zs_xref_next = (amc::FXref*)-1; // (amc.FCtype.zs_xref) not-in-list
    xref.ind_xref_next = (amc::FXref*)-1; // (amc.FDb.ind_xref) not-in-hash
    xref.zd_xref_keyfld_next = (amc::FXref*)-1; // (amc.FField.zd_xref_keyfld) not-in-list
    xref.zd_xref_keyfld_prev = NULL; // (amc.FField.zd_xref_keyfld)
}

// --- amc.FXref..Uninit
void amc::FXref_Uninit(amc::FXref& xref) {
    amc::FXref &row = xref; (void)row;
    ind_xref_Remove(row); // remove xref from index ind_xref
    amc::FField* p_field = amc::ind_field_Find(row.field);
    if (p_field)  {
        c_xref_Remove(*p_field, row);// remove xref from index c_xref
    }
    amc::FField* p_keyfld = amc::ind_field_Find(keyfld_Get(row));
    if (p_keyfld)  {
        zd_xref_keyfld_Remove(*p_keyfld, row);// remove xref from index zd_xref_keyfld
    }
}

// --- amc.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* amc::value_ToCstr(const amc::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case amc_FieldId_value             : ret = "value";  break;
        case amc_FieldId_len               : ret = "len";  break;
        case amc_FieldId_str               : ret = "str";  break;
    }
    return ret;
}

// --- amc.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void amc::value_Print(const amc::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- amc.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool amc::value_SetStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('l','e','n'): {
                    value_SetEnum(parent,amc_FieldId_len); ret = true; break;
                }
                case LE_STR3('s','t','r'): {
                    value_SetEnum(parent,amc_FieldId_str); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,amc_FieldId_value); ret = true; break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- amc.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void amc::value_SetStrptr(amc::FieldId& parent, algo::strptr rhs, amc_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- amc.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool amc::value_ReadStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- amc.FieldId..ReadStrptrMaybe
// Read fields of amc::FieldId from an ascii string.
// The format of the string is the format of the amc::FieldId's only field
bool amc::FieldId_ReadStrptrMaybe(amc::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && amc::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- amc.FieldId..Print
// print string representation of amc::FieldId to string LHS, no header -- cprint:amc.FieldId.String
void amc::FieldId_Print(amc::FieldId & row, algo::cstring &str) {
    amc::value_Print(row, str);
}

// --- amc.Genpnew..Init
// Set all fields to initial values.
void amc::Genpnew_Init(amc::Genpnew& parent) {
    parent.p_func = NULL;
    parent.req_pack = bool(false);
    parent.p_ctype = NULL;
    parent.p_optfld = NULL;
    parent.p_varlenfld = NULL;
    parent.optnolen = bool(false);
    parent.hasret = bool(true);
}

// --- amc.TableId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* amc::value_ToCstr(const amc::TableId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case amc_TableId_dmmeta_Anonfld    : ret = "dmmeta.Anonfld";  break;
        case amc_TableId_dmmeta_Argvtype   : ret = "dmmeta.Argvtype";  break;
        case amc_TableId_dmmeta_Basepool   : ret = "dmmeta.Basepool";  break;
        case amc_TableId_dmmeta_Bitfld     : ret = "dmmeta.Bitfld";  break;
        case amc_TableId_amcdb_Bltin       : ret = "amcdb.Bltin";  break;
        case amc_TableId_dmmeta_Cafter     : ret = "dmmeta.Cafter";  break;
        case amc_TableId_dmmeta_Cascdel    : ret = "dmmeta.Cascdel";  break;
        case amc_TableId_dmmeta_Ccmp       : ret = "dmmeta.Ccmp";  break;
        case amc_TableId_dmmeta_Cdflt      : ret = "dmmeta.Cdflt";  break;
        case amc_TableId_dmmeta_Cextern    : ret = "dmmeta.Cextern";  break;
        case amc_TableId_dmmeta_Cfmt       : ret = "dmmeta.Cfmt";  break;
        case amc_TableId_dmmeta_Cget       : ret = "dmmeta.Cget";  break;
        case amc_TableId_dmmeta_Charset    : ret = "dmmeta.Charset";  break;
        case amc_TableId_dmmeta_Chash      : ret = "dmmeta.Chash";  break;
        case amc_TableId_dmmeta_Cppfunc    : ret = "dmmeta.Cppfunc";  break;
        case amc_TableId_dmmeta_Cpptype    : ret = "dmmeta.Cpptype";  break;
        case amc_TableId_dmmeta_Csize      : ret = "dmmeta.Csize";  break;
        case amc_TableId_dmmeta_Cstr       : ret = "dmmeta.Cstr";  break;
        case amc_TableId_dmmeta_Ctype      : ret = "dmmeta.Ctype";  break;
        case amc_TableId_dmmeta_Dispatch   : ret = "dmmeta.Dispatch";  break;
        case amc_TableId_dmmeta_DispatchMsg: ret = "dmmeta.DispatchMsg";  break;
        case amc_TableId_dmmeta_Dispctx    : ret = "dmmeta.Dispctx";  break;
        case amc_TableId_dmmeta_Dispfilter : ret = "dmmeta.Dispfilter";  break;
        case amc_TableId_dmmeta_Disptrace  : ret = "dmmeta.Disptrace";  break;
        case amc_TableId_dmmeta_Fbase      : ret = "dmmeta.Fbase";  break;
        case amc_TableId_dmmeta_Fbigend    : ret = "dmmeta.Fbigend";  break;
        case amc_TableId_dmmeta_Fbitset    : ret = "dmmeta.Fbitset";  break;
        case amc_TableId_dmmeta_Fbuf       : ret = "dmmeta.Fbuf";  break;
        case amc_TableId_dmmeta_Fcast      : ret = "dmmeta.Fcast";  break;
        case amc_TableId_dmmeta_Fcleanup   : ret = "dmmeta.Fcleanup";  break;
        case amc_TableId_dmmeta_Fcmap      : ret = "dmmeta.Fcmap";  break;
        case amc_TableId_dmmeta_Fcmdline   : ret = "dmmeta.Fcmdline";  break;
        case amc_TableId_dmmeta_Fcmp       : ret = "dmmeta.Fcmp";  break;
        case amc_TableId_dmmeta_Fcompact   : ret = "dmmeta.Fcompact";  break;
        case amc_TableId_dmmeta_Fconst     : ret = "dmmeta.Fconst";  break;
        case amc_TableId_dmmeta_Fcurs      : ret = "dmmeta.Fcurs";  break;
        case amc_TableId_dmmeta_Fdec       : ret = "dmmeta.Fdec";  break;
        case amc_TableId_dmmeta_Fdelay     : ret = "dmmeta.Fdelay";  break;
        case amc_TableId_dmmeta_Field      : ret = "dmmeta.Field";  break;
        case amc_TableId_dmmeta_Findrem    : ret = "dmmeta.Findrem";  break;
        case amc_TableId_dmmeta_Finput     : ret = "dmmeta.Finput";  break;
        case amc_TableId_dmmeta_Fldoffset  : ret = "dmmeta.Fldoffset";  break;
        case amc_TableId_dmmeta_Floadtuples: ret = "dmmeta.Floadtuples";  break;
        case amc_TableId_dmmeta_Fnoremove  : ret = "dmmeta.Fnoremove";  break;
        case amc_TableId_dmmeta_Foutput    : ret = "dmmeta.Foutput";  break;
        case amc_TableId_dmmeta_Fprefix    : ret = "dmmeta.Fprefix";  break;
        case amc_TableId_dmmeta_Fregx      : ret = "dmmeta.Fregx";  break;
        case amc_TableId_dmmeta_Fsort      : ret = "dmmeta.Fsort";  break;
        case amc_TableId_dmmeta_Fstep      : ret = "dmmeta.Fstep";  break;
        case amc_TableId_dmmeta_Ftrace     : ret = "dmmeta.Ftrace";  break;
        case amc_TableId_dmmeta_Func       : ret = "dmmeta.Func";  break;
        case amc_TableId_dmmeta_Funique    : ret = "dmmeta.Funique";  break;
        case amc_TableId_dmmeta_Fuserinit  : ret = "dmmeta.Fuserinit";  break;
        case amc_TableId_dmmeta_Fwddecl    : ret = "dmmeta.Fwddecl";  break;
        case amc_TableId_dmmeta_Gconst     : ret = "dmmeta.Gconst";  break;
        case amc_TableId_dmmeta_Gstatic    : ret = "dmmeta.Gstatic";  break;
        case amc_TableId_dmmeta_Gsymbol    : ret = "dmmeta.Gsymbol";  break;
        case amc_TableId_dmmeta_Hook       : ret = "dmmeta.Hook";  break;
        case amc_TableId_dmmeta_Inlary     : ret = "dmmeta.Inlary";  break;
        case amc_TableId_dmmeta_Lenfld     : ret = "dmmeta.Lenfld";  break;
        case amc_TableId_dmmeta_Listtype   : ret = "dmmeta.Listtype";  break;
        case amc_TableId_dmmeta_Llist      : ret = "dmmeta.Llist";  break;
        case amc_TableId_dmmeta_Main       : ret = "dmmeta.Main";  break;
        case amc_TableId_dmmeta_Msgtype    : ret = "dmmeta.Msgtype";  break;
        case amc_TableId_dmmeta_Nocascdel  : ret = "dmmeta.Nocascdel";  break;
        case amc_TableId_dmmeta_Nossimfile : ret = "dmmeta.Nossimfile";  break;
        case amc_TableId_dmmeta_Noxref     : ret = "dmmeta.Noxref";  break;
        case amc_TableId_dmmeta_Ns         : ret = "dmmeta.Ns";  break;
        case amc_TableId_dmmeta_Nsdb       : ret = "dmmeta.Nsdb";  break;
        case amc_TableId_dmmeta_Nsinclude  : ret = "dmmeta.Nsinclude";  break;
        case amc_TableId_dmmeta_Nsproto    : ret = "dmmeta.Nsproto";  break;
        case amc_TableId_dmmeta_Nsx        : ret = "dmmeta.Nsx";  break;
        case amc_TableId_dmmeta_Numstr     : ret = "dmmeta.Numstr";  break;
        case amc_TableId_dmmeta_Pack       : ret = "dmmeta.Pack";  break;
        case amc_TableId_dmmeta_Pmaskfld   : ret = "dmmeta.Pmaskfld";  break;
        case amc_TableId_dmmeta_Pnew       : ret = "dmmeta.Pnew";  break;
        case amc_TableId_dmmeta_Ptrary     : ret = "dmmeta.Ptrary";  break;
        case amc_TableId_dmmeta_Rowid      : ret = "dmmeta.Rowid";  break;
        case amc_TableId_dmmeta_Smallstr   : ret = "dmmeta.Smallstr";  break;
        case amc_TableId_dmmeta_Sortfld    : ret = "dmmeta.Sortfld";  break;
        case amc_TableId_dmmeta_Ssimfile   : ret = "dmmeta.Ssimfile";  break;
        case amc_TableId_dmmeta_Ssimvolatile: ret = "dmmeta.Ssimvolatile";  break;
        case amc_TableId_dmmeta_Substr     : ret = "dmmeta.Substr";  break;
        case amc_TableId_dev_Targdep       : ret = "dev.Targdep";  break;
        case amc_TableId_dev_Target        : ret = "dev.Target";  break;
        case amc_TableId_dmmeta_Tary       : ret = "dmmeta.Tary";  break;
        case amc_TableId_amcdb_Tcurs       : ret = "amcdb.Tcurs";  break;
        case amc_TableId_dmmeta_Thash      : ret = "dmmeta.Thash";  break;
        case amc_TableId_dmmeta_Typefld    : ret = "dmmeta.Typefld";  break;
        case amc_TableId_dmmeta_Usertracefld: ret = "dmmeta.Usertracefld";  break;
        case amc_TableId_dmmeta_Xref       : ret = "dmmeta.Xref";  break;
    }
    return ret;
}

// --- amc.TableId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void amc::value_Print(const amc::TableId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- amc.TableId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool amc::value_SetStrptrMaybe(amc::TableId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ns); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"s",1)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ns); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,amc_TableId_dev_Target); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"et",2)==0) { value_SetEnum(parent,amc_TableId_dev_target); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"sx",2)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nsx); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"sx",2)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nsx); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('a','m','c','d','b','.','B','l'): {
                    if (memcmp(rhs.elems+8,"tin",3)==0) { value_SetEnum(parent,amc_TableId_amcdb_Bltin); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','c','d','b','.','T','c'): {
                    if (memcmp(rhs.elems+8,"urs",3)==0) { value_SetEnum(parent,amc_TableId_amcdb_Tcurs); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','c','d','b','.','b','l'): {
                    if (memcmp(rhs.elems+8,"tin",3)==0) { value_SetEnum(parent,amc_TableId_amcdb_bltin); ret = true; break; }
                    break;
                }
                case LE_STR8('a','m','c','d','b','.','t','c'): {
                    if (memcmp(rhs.elems+8,"urs",3)==0) { value_SetEnum(parent,amc_TableId_amcdb_tcurs); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','T','a','r','g'): {
                    if (memcmp(rhs.elems+8,"dep",3)==0) { value_SetEnum(parent,amc_TableId_dev_Targdep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','e','v','.','t','a','r','g'): {
                    if (memcmp(rhs.elems+8,"dep",3)==0) { value_SetEnum(parent,amc_TableId_dev_targdep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"cmp",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ccmp); ret = true; break; }
                    if (memcmp(rhs.elems+8,"fmt",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cfmt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"get",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cget); ret = true; break; }
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"buf",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fbuf); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmp",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcmp); ret = true; break; }
                    if (memcmp(rhs.elems+8,"dec",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fdec); ret = true; break; }
                    if (memcmp(rhs.elems+8,"unc",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Func); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','H'): {
                    if (memcmp(rhs.elems+8,"ook",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Hook); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','M'): {
                    if (memcmp(rhs.elems+8,"ain",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Main); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"sdb",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nsdb); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','P'): {
                    if (memcmp(rhs.elems+8,"ack",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Pack); ret = true; break; }
                    if (memcmp(rhs.elems+8,"new",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Pnew); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','T'): {
                    if (memcmp(rhs.elems+8,"ary",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Tary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','X'): {
                    if (memcmp(rhs.elems+8,"ref",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Xref); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"cmp",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ccmp); ret = true; break; }
                    if (memcmp(rhs.elems+8,"fmt",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cfmt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"get",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cget); ret = true; break; }
                    if (memcmp(rhs.elems+8,"str",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"buf",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fbuf); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmp",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcmp); ret = true; break; }
                    if (memcmp(rhs.elems+8,"dec",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fdec); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','h'): {
                    if (memcmp(rhs.elems+8,"ook",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_hook); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','m'): {
                    if (memcmp(rhs.elems+8,"ain",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_main); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"sdb",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nsdb); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','p'): {
                    if (memcmp(rhs.elems+8,"ack",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_pack); ret = true; break; }
                    if (memcmp(rhs.elems+8,"new",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_pnew); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','t'): {
                    if (memcmp(rhs.elems+8,"ary",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_tary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','x'): {
                    if (memcmp(rhs.elems+8,"ref",3)==0) { value_SetEnum(parent,amc_TableId_dmmeta_xref); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"dflt",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cdflt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"hash",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Chash); ret = true; break; }
                    if (memcmp(rhs.elems+8,"size",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Csize); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"base",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fbase); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cast",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcast); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmap",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcmap); ret = true; break; }
                    if (memcmp(rhs.elems+8,"curs",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcurs); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Field); ret = true; break; }
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fregx); ret = true; break; }
                    if (memcmp(rhs.elems+8,"sort",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fsort); ret = true; break; }
                    if (memcmp(rhs.elems+8,"step",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fstep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','L'): {
                    if (memcmp(rhs.elems+8,"list",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Llist); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','R'): {
                    if (memcmp(rhs.elems+8,"owid",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Rowid); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','T'): {
                    if (memcmp(rhs.elems+8,"hash",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Thash); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"dflt",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cdflt); ret = true; break; }
                    if (memcmp(rhs.elems+8,"hash",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_chash); ret = true; break; }
                    if (memcmp(rhs.elems+8,"size",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_csize); ret = true; break; }
                    if (memcmp(rhs.elems+8,"type",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ctype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"base",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fbase); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cast",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcast); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmap",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcmap); ret = true; break; }
                    if (memcmp(rhs.elems+8,"curs",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcurs); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ield",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_field); ret = true; break; }
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fregx); ret = true; break; }
                    if (memcmp(rhs.elems+8,"sort",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fsort); ret = true; break; }
                    if (memcmp(rhs.elems+8,"step",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fstep); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','l'): {
                    if (memcmp(rhs.elems+8,"list",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_llist); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','r'): {
                    if (memcmp(rhs.elems+8,"owid",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_rowid); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','t'): {
                    if (memcmp(rhs.elems+8,"hash",4)==0) { value_SetEnum(parent,amc_TableId_dmmeta_thash); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 13: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','B'): {
                    if (memcmp(rhs.elems+8,"itfld",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Bitfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"after",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cafter); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"const",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fconst); ret = true; break; }
                    if (memcmp(rhs.elems+8,"delay",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fdelay); ret = true; break; }
                    if (memcmp(rhs.elems+8,"input",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Finput); ret = true; break; }
                    if (memcmp(rhs.elems+8,"trace",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ftrace); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','G'): {
                    if (memcmp(rhs.elems+8,"const",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Gconst); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','I'): {
                    if (memcmp(rhs.elems+8,"nlary",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Inlary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','L'): {
                    if (memcmp(rhs.elems+8,"enfld",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Lenfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"oxref",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Noxref); ret = true; break; }
                    if (memcmp(rhs.elems+8,"umstr",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Numstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','P'): {
                    if (memcmp(rhs.elems+8,"trary",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ptrary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Substr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','b'): {
                    if (memcmp(rhs.elems+8,"itfld",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_bitfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"after",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cafter); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"const",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fconst); ret = true; break; }
                    if (memcmp(rhs.elems+8,"delay",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fdelay); ret = true; break; }
                    if (memcmp(rhs.elems+8,"input",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_finput); ret = true; break; }
                    if (memcmp(rhs.elems+8,"trace",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ftrace); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','g'): {
                    if (memcmp(rhs.elems+8,"const",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_gconst); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','i'): {
                    if (memcmp(rhs.elems+8,"nlary",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_inlary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','l'): {
                    if (memcmp(rhs.elems+8,"enfld",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_lenfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"oxref",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_noxref); ret = true; break; }
                    if (memcmp(rhs.elems+8,"umstr",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_numstr); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','p'): {
                    if (memcmp(rhs.elems+8,"trary",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ptrary); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"ubstr",5)==0) { value_SetEnum(parent,amc_TableId_dmmeta_substr); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','A'): {
                    if (memcmp(rhs.elems+8,"nonfld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Anonfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','C'): {
                    if (memcmp(rhs.elems+8,"ascdel",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cascdel); ret = true; break; }
                    if (memcmp(rhs.elems+8,"extern",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cextern); ret = true; break; }
                    if (memcmp(rhs.elems+8,"harset",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Charset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ppfunc",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cppfunc); ret = true; break; }
                    if (memcmp(rhs.elems+8,"pptype",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Cpptype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"ispctx",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Dispctx); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"bigend",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fbigend); ret = true; break; }
                    if (memcmp(rhs.elems+8,"bitset",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fbitset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"indrem",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Findrem); ret = true; break; }
                    if (memcmp(rhs.elems+8,"output",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Foutput); ret = true; break; }
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fprefix); ret = true; break; }
                    if (memcmp(rhs.elems+8,"unique",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Funique); ret = true; break; }
                    if (memcmp(rhs.elems+8,"wddecl",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fwddecl); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','G'): {
                    if (memcmp(rhs.elems+8,"static",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Gstatic); ret = true; break; }
                    if (memcmp(rhs.elems+8,"symbol",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Gsymbol); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','M'): {
                    if (memcmp(rhs.elems+8,"sgtype",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Msgtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"sproto",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nsproto); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"ortfld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Sortfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','T'): {
                    if (memcmp(rhs.elems+8,"ypefld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Typefld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','a'): {
                    if (memcmp(rhs.elems+8,"nonfld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_anonfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','c'): {
                    if (memcmp(rhs.elems+8,"ascdel",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cascdel); ret = true; break; }
                    if (memcmp(rhs.elems+8,"extern",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cextern); ret = true; break; }
                    if (memcmp(rhs.elems+8,"harset",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_charset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"ppfunc",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cppfunc); ret = true; break; }
                    if (memcmp(rhs.elems+8,"pptype",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_cpptype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','d'): {
                    if (memcmp(rhs.elems+8,"ispctx",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_dispctx); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"bigend",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fbigend); ret = true; break; }
                    if (memcmp(rhs.elems+8,"bitset",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fbitset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"indrem",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_findrem); ret = true; break; }
                    if (memcmp(rhs.elems+8,"output",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_foutput); ret = true; break; }
                    if (memcmp(rhs.elems+8,"prefix",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fprefix); ret = true; break; }
                    if (memcmp(rhs.elems+8,"unique",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_funique); ret = true; break; }
                    if (memcmp(rhs.elems+8,"wddecl",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fwddecl); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','g'): {
                    if (memcmp(rhs.elems+8,"static",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_gstatic); ret = true; break; }
                    if (memcmp(rhs.elems+8,"symbol",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_gsymbol); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','m'): {
                    if (memcmp(rhs.elems+8,"sgtype",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_msgtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"sproto",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nsproto); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"ortfld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_sortfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','t'): {
                    if (memcmp(rhs.elems+8,"ypefld",6)==0) { value_SetEnum(parent,amc_TableId_dmmeta_typefld); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 15: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','A'): {
                    if (memcmp(rhs.elems+8,"rgvtype",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Argvtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','B'): {
                    if (memcmp(rhs.elems+8,"asepool",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Basepool); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"ispatch",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Dispatch); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"cleanup",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcleanup); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmdline",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcmdline); ret = true; break; }
                    if (memcmp(rhs.elems+8,"compact",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fcompact); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','L'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','P'): {
                    if (memcmp(rhs.elems+8,"maskfld",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Pmaskfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"mallstr",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Smallstr); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ssimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','a'): {
                    if (memcmp(rhs.elems+8,"rgvtype",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_argvtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','b'): {
                    if (memcmp(rhs.elems+8,"asepool",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_basepool); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','d'): {
                    if (memcmp(rhs.elems+8,"ispatch",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_dispatch); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"cleanup",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcleanup); ret = true; break; }
                    if (memcmp(rhs.elems+8,"cmdline",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcmdline); ret = true; break; }
                    if (memcmp(rhs.elems+8,"compact",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fcompact); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','l'): {
                    if (memcmp(rhs.elems+8,"isttype",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_listtype); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','p'): {
                    if (memcmp(rhs.elems+8,"maskfld",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_pmaskfld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"mallstr",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_smallstr); ret = true; break; }
                    if (memcmp(rhs.elems+8,"simfile",7)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ssimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 16: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"isptrace",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Disptrace); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"ldoffset",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fldoffset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"noremove",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fnoremove); ret = true; break; }
                    if (memcmp(rhs.elems+8,"userinit",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Fuserinit); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"ocascdel",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nocascdel); ret = true; break; }
                    if (memcmp(rhs.elems+8,"sinclude",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nsinclude); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','d'): {
                    if (memcmp(rhs.elems+8,"isptrace",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_disptrace); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"ldoffset",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fldoffset); ret = true; break; }
                    if (memcmp(rhs.elems+8,"noremove",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fnoremove); ret = true; break; }
                    if (memcmp(rhs.elems+8,"userinit",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_fuserinit); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"ocascdel",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nocascdel); ret = true; break; }
                    if (memcmp(rhs.elems+8,"sinclude",8)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nsinclude); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"ispfilter",9)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Dispfilter); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','N'): {
                    if (memcmp(rhs.elems+8,"ossimfile",9)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Nossimfile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','d'): {
                    if (memcmp(rhs.elems+8,"ispfilter",9)==0) { value_SetEnum(parent,amc_TableId_dmmeta_dispfilter); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','n'): {
                    if (memcmp(rhs.elems+8,"ossimfile",9)==0) { value_SetEnum(parent,amc_TableId_dmmeta_nossimfile); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 18: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','D'): {
                    if (memcmp(rhs.elems+8,"ispatchMsg",10)==0) { value_SetEnum(parent,amc_TableId_dmmeta_DispatchMsg); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','F'): {
                    if (memcmp(rhs.elems+8,"loadtuples",10)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Floadtuples); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','f'): {
                    if (memcmp(rhs.elems+8,"loadtuples",10)==0) { value_SetEnum(parent,amc_TableId_dmmeta_floadtuples); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 19: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('d','m','m','e','t','a','.','S'): {
                    if (memcmp(rhs.elems+8,"simvolatile",11)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Ssimvolatile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','U'): {
                    if (memcmp(rhs.elems+8,"sertracefld",11)==0) { value_SetEnum(parent,amc_TableId_dmmeta_Usertracefld); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','d'): {
                    if (memcmp(rhs.elems+8,"ispatch_msg",11)==0) { value_SetEnum(parent,amc_TableId_dmmeta_dispatch_msg); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','s'): {
                    if (memcmp(rhs.elems+8,"simvolatile",11)==0) { value_SetEnum(parent,amc_TableId_dmmeta_ssimvolatile); ret = true; break; }
                    break;
                }
                case LE_STR8('d','m','m','e','t','a','.','u'): {
                    if (memcmp(rhs.elems+8,"sertracefld",11)==0) { value_SetEnum(parent,amc_TableId_dmmeta_usertracefld); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- amc.TableId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void amc::value_SetStrptr(amc::TableId& parent, algo::strptr rhs, amc_TableIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- amc.TableId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool amc::value_ReadStrptrMaybe(amc::TableId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- amc.TableId..ReadStrptrMaybe
// Read fields of amc::TableId from an ascii string.
// The format of the string is the format of the amc::TableId's only field
bool amc::TableId_ReadStrptrMaybe(amc::TableId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && amc::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- amc.TableId..Print
// print string representation of amc::TableId to string LHS, no header -- cprint:amc.TableId.String
void amc::TableId_Print(amc::TableId & row, algo::cstring &str) {
    amc::value_Print(row, str);
}

// --- amc...SizeCheck
inline static void amc::SizeCheck() {
}

// --- amc...main
int main(int argc, char **argv) {
    try {
        lib_json::FDb_Init();
        algo_lib::FDb_Init();
        amc::FDb_Init();
        algo_lib::_db.argc = argc;
        algo_lib::_db.argv = argv;
        algo_lib::IohookInit();
        amc::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:amc
    } catch(algo_lib::ErrorX &x) {
        prerr("amc.error  " << x); // there may be additional hints in DetachBadTags
        algo_lib::_db.exit_code = 1;
    }
    if (algo_lib::_db.last_signal) {
        algo_lib::_db.exit_code = 1;
    }
    try {
        amc::FDb_Uninit();
        algo_lib::FDb_Uninit();
        lib_json::FDb_Uninit();
    } catch(algo_lib::ErrorX &) {
        // don't print anything, might crash
        algo_lib::_db.exit_code = 1;
    }
    // only the lower 1 byte makes it to the outside world
    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
    return algo_lib::_db.exit_code;
}

// --- amc...WinMain
#if defined(WIN32)
int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int) {
    return main(__argc,__argv);
}
#endif
