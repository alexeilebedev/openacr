## AMC Strings


### String types and how to use them
<a href="#string-types-and-how-to-use-them"></a>

Throughout the code base, you will see several string types in use.
They are fairly straightforward, and they're all described below.

* `algo::strptr`: Length-delimited string pointer.
There are two fields in this struct: `char *elems, int n_elems`;
The string is just n chars starting at elems;
No null-termination is assumed or allowed.
It's safe to use strptr in function prototypes when the argument isn't
  modified by the function -- all other string types can be converted
  to such temporary strptr and passed to a function.
amc's hash find uses strptr as argument type whenever the key type is some
kind of string.

* `algo::cstring`: Tary of char. Contents can be cast to strptr.
Fields are: `char *ch, int ch_n, int ch_max`.
operator = is defined for cstring, so these can be assigned like values

* `algo::tempstr`: cstring, to be used only as the return type of a function,
in order to avoid copying data. Has the property that when assigned to
cstring, the contents are moved instead ("move constructor semantics").

- DO NOT assign tempstr, cstring, or a temporary variable to a strptr, since strptr
is just a pointer.
- DO NOT pass cstring& to a function when strptr is sufficient.
- DO NOT return cstring from functions, it will result in extra alloc/copy/delete.
 Return tempstr instead.

In addition to these string types, which are fully sufficient for all practical purposes,
there are many possible fixed-length string types that are generated by amc, mostly
for protocol-handling and database interoperability purposes.

### Amc-generated String Types
<a href="#amc-generated-string-types"></a>

A lot of these are are already defined, but new ones can be built as  needed.
use "acr smallstr" for the full list. Brief explanation below.

* `algo::SmallstrN`: pascal string with N characters. Both data and length
are part of the struct. Don't send this over the wire, because unused
portions of the string may contain garbage from the stack.

* `algo::RspaceStr{1..255}`: Fixed-length string field padded on the right with spaces.
Can be sent over the wire (included in protocol types)
* `algo::RnullStr{1..255}`
* `algo::LspaceStr{1..255}`: similar to the above

* `algo::LnumStr{1..N}_U{32,64}`: Fixed-length string field, padded on the left with '0'
(ascii character '0', not the NUL character). Includes functions to convert to/from a u32/u64.
Number cannot be negative, because left-padding with 0 prevents that.

* `LnumStr{1..N}_U{32,64}_Base{B}`: Same as above, but different base.

### Small Strings
<a href="#small-strings"></a>
`amc` can generate code to handle small (fixed-length) strings that are either left- or right-padded.
Use a field with `arg:char` and `reftype:Smallstr`, and provide a `smallstr` record to specify additional
information:

```
dmmeta.field  field:algo.LspaceStr5_I16.ch  arg:char  reftype:Smallstr  dflt:""  comment:""
dmmeta.smallstr  field:algo.LspaceStr5_I16.ch  length:5  strtype:leftpad  pad:"' '"  strict:Y
```

In the example above, a field of 5 characters is specified, padded on the left with `' '`.
The following functions are generated:

```
inline-command: amc algo.LspaceStr5.ch% -proto -report:N
// Access string as array of chars
// func:algo.LspaceStr5.ch.Getary
algo::aryptr<char>   ch_Getary(const algo::LspaceStr5& parent) __attribute__((nothrow));
// func:algo.LspaceStr5.ch.HashStrptr
u32                  LspaceStr5_Hash(u32 prev, const algo::strptr &str);
// func:algo.LspaceStr5.ch.Init
void                 ch_Init(algo::LspaceStr5 &parent) __attribute__((nothrow));
// always return constant 5
// func:algo.LspaceStr5.ch.Max
int                  ch_Max(algo::LspaceStr5& parent) __attribute__((nothrow));
// func:algo.LspaceStr5.ch.N
int                  ch_N(const algo::LspaceStr5& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// func:algo.LspaceStr5.ch.Print
void                 ch_Print(algo::LspaceStr5& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:algo.LspaceStr5.ch.ReadStrptrMaybe
bool                 ch_ReadStrptrMaybe(algo::LspaceStr5& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
// func:algo.LspaceStr5.ch.SetStrptr
void                 ch_SetStrptr(algo::LspaceStr5& parent, const algo::strptr& rhs) __attribute__((nothrow));
// Copy from strptr (operator=)
// func:algo.LspaceStr5.ch.AssignStrptr
void                 algo::LspaceStr5::operator =(const algo::strptr &str) __attribute__((nothrow));
// Copy from same type
// Copy value from RHS.
// func:algo.LspaceStr5.ch.Set
void                 algo::LspaceStr5::operator =(const algo::LspaceStr5& parent) __attribute__((nothrow));
// func:algo.LspaceStr5.ch.Ctor
algo::LspaceStr5::LspaceStr5(const algo::LspaceStr5 &rhs) __attribute__((nothrow));
// func:algo.LspaceStr5.ch.CtorStrptr
algo::LspaceStr5::LspaceStr5(const algo::strptr &rhs) __attribute__((nothrow));
// func:algo.LspaceStr5.ch.Cast
operator algo::strptr () const __attribute__((nothrow));

```

For any small string field, you can also add `numstr` to generate functions for converting to/from a
desired integer type:

```
dmmeta.numstr  field:algo.LspaceStr5_I16.ch  numtype:u16  base:10  min_len:5
```

The above specifies that the field is encoded as base-10, and converts to a u16.
The `min_len` attribute controls the number of leading zeros when converting number to string.
If it is set to 0, the unused portion will be filled with spaces. Given that it's `5` in the above example,
the field will be effectively left-padded with `'0'` characters.

The following functions are generated for the example above:

```
inline-command: amc algo.LspaceStr5_I16.ch% -proto -report:N
// Access string as array of chars
// func:algo.LspaceStr5_I16.ch.Getary
algo::aryptr<char>   ch_Getary(const algo::LspaceStr5_I16& parent) __attribute__((nothrow));
// func:algo.LspaceStr5_I16.ch.HashStrptr
u32                  LspaceStr5_I16_Hash(u32 prev, const algo::strptr &str);
// func:algo.LspaceStr5_I16.ch.Init
void                 ch_Init(algo::LspaceStr5_I16 &parent) __attribute__((nothrow));
// always return constant 5
// func:algo.LspaceStr5_I16.ch.Max
int                  ch_Max(algo::LspaceStr5_I16& parent) __attribute__((nothrow));
// func:algo.LspaceStr5_I16.ch.N
int                  ch_N(const algo::LspaceStr5_I16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// func:algo.LspaceStr5_I16.ch.Print
void                 ch_Print(algo::LspaceStr5_I16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:algo.LspaceStr5_I16.ch.ReadStrptrMaybe
bool                 ch_ReadStrptrMaybe(algo::LspaceStr5_I16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
// func:algo.LspaceStr5_I16.ch.SetStrptr
void                 ch_SetStrptr(algo::LspaceStr5_I16& parent, const algo::strptr& rhs) __attribute__((nothrow));
// Copy from strptr (operator=)
// func:algo.LspaceStr5_I16.ch.AssignStrptr
void                 algo::LspaceStr5_I16::operator =(const algo::strptr &str) __attribute__((nothrow));
// Copy from same type
// Copy value from RHS.
// func:algo.LspaceStr5_I16.ch.Set
void                 algo::LspaceStr5_I16::operator =(const algo::LspaceStr5_I16& parent) __attribute__((nothrow));
// func:algo.LspaceStr5_I16.ch.Ctor
algo::LspaceStr5_I16::LspaceStr5_I16(const algo::LspaceStr5_I16 &rhs) __attribute__((nothrow));
// func:algo.LspaceStr5_I16.ch.CtorStrptr
algo::LspaceStr5_I16::LspaceStr5_I16(const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
// func:algo.LspaceStr5_I16.ch.Getnum
u16                  ch_Getnum(algo::LspaceStr5_I16& parent, bool &and_ok) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
// func:algo.LspaceStr5_I16.ch.GetnumDflt
u16                  ch_GetnumDflt(algo::LspaceStr5_I16& parent, u16 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
// func:algo.LspaceStr5_I16.ch.Geti64
i64                  ch_Geti64(algo::LspaceStr5_I16& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
// func:algo.LspaceStr5_I16.ch.SetnumMaybe
bool                 ch_SetnumMaybe(algo::LspaceStr5_I16& parent, i64 rhs) __attribute__((nothrow));
// func:algo.LspaceStr5_I16.ch.Cast
operator algo::strptr () const __attribute__((nothrow));

```

### Reading and Printing
<a href="#reading-and-printing"></a>

Amc can generate conversion functions for mapping between each ctype and a variety of formats.
Conversion code is requested with `cmft` record:

```
dmmeta.cfmt  cfmt:atf.Testrun.String          printfmt:Tuple  read:Y  print:Y  sep:""   genop:Y  comment:""
```

The primary key for cfmt is a combination of `ctype` and `strfmt`, where `strfmt` may be
`String`, `Json`, `Argv`, or `Tuple`.

Additionally, when `strfmt` is `String`,
`printfmt` field (somewhat confusinlgy confusingly named in a similar way to `strfmt`)
may be `Sep`, `CompactSep`, `Tuple` and `Auto`.

For all other conversion types, recognized values are `Extern` and `Auto`.
If `printfmt` is `Extern`, then a forward declaration is created for the underlying ctype
and nothing else is done.

### Strfmt:String with printfmt:Tuple
<a href="#strfmtstring-with-printfmttuple"></a>

This is the main generator of code for reading and printing ctypes.
The tuple format is the default format for amc/acr types, and is the format used for all ssimfiles.
Each line has a type tag, which is just the name of the ctype, following by
space-separated key-value pairs. For instance,

```
dmmeta.ctype  ctype:amc.FCtype  comment:""
```

The key-value pairs may appear in any order. The value may contain any characters, using the same
character escape rules as c++. Amc supports efficient reading of tuples even for structs that contain
hundreds of fields using `FieldId` type.

For printing, the following rules hold:

- Only fields with reftype `Varlen`, `Val`, `Inlary`, `Smallstr`, `Ptr`, `Opt`, `Bitfld`, `RegSql` are considered.
- `Substr` and `Cppfunc` fields are not printed.
- `Srcfield` (underlying type for bitfields) is not printed as Tuple.
- `Pmaskfld` (field containing presence mask bits) is not printed as Tuple.
- `Lenfld` and `Typefld` are not printed as Tuple.
- If the ctype has a presence mask (`pmask`), then each field is printed only if present.
- Any bool stored as a bitfield whose underlying storage is `anonfld` is printed only if its value is true.
- An `Opt` field is printed only if present
- Inlary fields are not printed.
- `Varlen` fields of type `char` or `u8` are printed as a string (with correct escaping of characters)
- Elements of `Varlen` fields whose type is not char or u8 are printed using names and
successive integers, e.g. if the varlen
field has 2 elements with values x and y, attributes `name.0:x  name.1:y` are printed.

Thus, the tuple will always contain all field values, except for `false` bitfields  defined over
`anonfld` and unset fields with presence mask.

### Strfmt:String with printfmt:Sep or CompactSep
<a href="#strfmtstring-with-printfmtsep-or-compactsep"></a>

Amc generates code to print the ctype as a set of values (i.e. field names are not printed).
With `printfmt` equal to `Sep`, the length of `sep` attribute must be equal to the number
of fields in the struct minus one. The fields are printed one by one, separated by individual characters
as described by sep.

If `printfmt` is `CompactSep`, then the `sep` field is the separator string, and the same
separator string is placed between each field. When using `CompactSep`, `RegxSql` and `Val`
fields whose value is equal to their default are printed as empty strings.

### Strfmt:Json
<a href="#strfmtjson"></a>

Code is generated to print the ctype as a valid Json string.

### Strfmt:Argv
<a href="#strfmtargv"></a>

Code is generated to convert the ctype to a unix command line (array of pointers to C strings).
This is used to generate correct command line for subprocess invocation.

### Strfmt:Tuple
<a href="#strfmttuple"></a>

Code is generated to convert the ctype directly to a Tuple (array of key-value pairs).

