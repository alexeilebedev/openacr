## amc_vis - Internals


### Table Of Contents
<a href="#table-of-contents"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Toc -->
* [Description](#description)
* [Sources](#sources)
* [Dependencies](#dependencies)
* [In Memory DB](#in-memory-db)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Toc -->

### Description
<a href="#description"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Description -->
for usage, see [amc_vis - Draw access path diagrams](/txt/exe/amc_vis/README.md)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Description -->

### Sources
<a href="#sources"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Sources -->
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/amc/amc_vis.cpp](/cpp/amc/amc_vis.cpp)||
|[cpp/gen/amc_vis_gen.cpp](/cpp/gen/amc_vis_gen.cpp)||
|[include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)||
|[include/gen/amc_vis_gen.inl.h](/include/gen/amc_vis_gen.inl.h)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Sources -->

### Dependencies
<a href="#dependencies"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Dependencies -->
The build target depends on the following libraries
|Target|Comment|
|---|---|
|[algo_lib](/txt/lib/algo_lib/README.md)|Support library for all executables|

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Dependencies -->

### In Memory DB
<a href="#in-memory-db"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Imdb -->
`amc_vis` generated code creates the tables below.
All allocations are done through global `amc_vis::_db` [amc_vis.FDb](#amc_vis-fdb) structure
|Ctype|Ssimfile|Create|Access|
|---|---|---|---|
|[amc_vis.FCtype](#amc_vis-fctype)|[dmmeta.ctype](/txt/ssimdb/dmmeta/ctype.md)|FDb.ctype (Lary)|ctype (Lary, by rowid)|ind_ctype (Thash, hash field ctype)|zd_select (Llist)|
||||FCtype.p_base (Upptr)|
||||FField.p_ctype (Upptr)|
||||FField.p_arg (Upptr)|
||||FNode.p_ctype (Upptr)|
|[amc_vis.FDb](#amc_vis-fdb)||FDb._db (Global)|
|[amc_vis.FField](#amc_vis-ffield)|[dmmeta.field](/txt/ssimdb/dmmeta/field.md)|FDb.field (Lary)|field (Lary, by rowid)|ind_field (Thash, hash field field)|
||||FCtype.c_field (Ptrary)|
|[amc_vis.FFinput](#amc_vis-ffinput)|[dmmeta.finput](/txt/ssimdb/dmmeta/finput.md)|FDb.finput (Lary)|finput (Lary, by rowid)|
||||FField.c_finput (Ptr)|
|[amc_vis.Linkkey](#amc_vis-linkkey)||
|[amc_vis.FLink](#amc_vis-flink)||FDb.link (Lary)|link (Lary, by rowid)|ind_link (Thash, hash field link)|c_linklist (Ptrary)|bh_link (Bheap, sort field linkkey)|
||||FLinkdep.p_link_from (Upptr)|
||||FLinkdep.p_link_to (Upptr)|
||||FNode.c_bottom (Ptr)|
||||FNode.c_top (Ptr)|
||||FNode.zd_link_out (Llist)|
||||FNode.zd_link_in (Llist)|
|[amc_vis.FLinkdep](#amc_vis-flinkdep)||FDb.linkdep (Lary)|linkdep (Lary, by rowid)|
||||FLink.zd_linkdep_out (Llist)|
||||FLink.zd_linkdep_in (Llist)|
|[amc_vis.Nodekey](#amc_vis-nodekey)||
|[amc_vis.FNode](#amc_vis-fnode)||FDb.node (Lary)|node (Lary, by rowid)|ind_node (Thash, hash field node)|bh_node (Bheap, sort field nodekey)|
||||FLink.p_node1 (Upptr)|
||||FLink.p_node2 (Upptr)|
||||FNodedep.p_node1 (Upptr)|
||||FNodedep.p_node2 (Upptr)|
|[amc_vis.FNodedep](#amc_vis-fnodedep)||FDb.nodedep (Lary)|nodedep (Lary, by rowid)|
||||FNode.zd_nodedep_out (Llist)|
||||FNode.zd_nodedep_in (Llist)|
|[amc_vis.FOutrow](#amc_vis-foutrow)||FDb.outrow (Lary)|outrow (Lary, by rowid)|
|[amc_vis.FReftype](#amc_vis-freftype)|[dmmeta.reftype](/txt/ssimdb/dmmeta/reftype.md)|FDb.reftype (Lary)|reftype (Lary, by rowid)|ind_reftype (Thash, hash field reftype)|
||||FField.p_reftype (Upptr)|

#### amc_vis.FCtype - Struct
<a href="#amc_vis-fctype"></a>

#### amc_vis.FCtype Fields
<a href="#amc_vis-fctype-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FCtype.msghdr|[dmmeta.Ctype](/txt/ssimdb/dmmeta/ctype.md)|[Base](/txt/ssimdb/dmmeta/ctype.md)|||
|amc_vis.FCtype.cpp_type|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||type name to use in c++|
|amc_vis.FCtype.p_base|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FCtype.c_field|[amc_vis.FField](/txt/exe/amc_vis/internals.md#amc_vis-ffield)|[Ptrary](/txt/exe/amc/reftypes.md#ptrary)|||
|amc_vis.FCtype.mm_id|i32|[Val](/txt/exe/amc/reftypes.md#val)||Model matrix ID|
|amc_vis.FCtype.isinput|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FCtype.userselect|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FCtype.color|u16|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FCtype
<a href="#struct-fctype"></a>
*Note:* field ``amc_vis.FCtype.msghdr`` has reftype ``base`` so the fields of [dmmeta.Ctype](/txt/ssimdb/dmmeta/ctype.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FCtype { // amc_vis.FCtype
    algo::Smallstr100   ctype;               // Identifier. must be ns.typename
    algo::Comment       comment;             //
    algo::cstring       cpp_type;            // type name to use in c++
    amc_vis::FCtype*    p_base;              // reference to parent row
    amc_vis::FField**   c_field_elems;       // array of pointers
    u32                 c_field_n;           // array of pointers
    u32                 c_field_max;         // capacity of allocated array
    i32                 mm_id;               //   0  Model matrix ID
    bool                isinput;             //   false
    bool                userselect;          //   false
    u16                 color;               //   0
    amc_vis::FCtype*    ind_ctype_next;      // hash next
    u32                 ind_ctype_hashval;   // hash value
    amc_vis::FCtype*    zd_select_next;      // zslist link; -1 means not-in-list
    amc_vis::FCtype*    zd_select_prev;      // previous element
    // reftype Ptrary of amc_vis.FCtype.c_field prohibits copy
    // func:amc_vis.FCtype..AssignOp
    amc_vis::FCtype&     operator =(const amc_vis::FCtype &rhs) = delete;
    // reftype Ptrary of amc_vis.FCtype.c_field prohibits copy
    // func:amc_vis.FCtype..CopyCtor
    FCtype(const amc_vis::FCtype &rhs) = delete;
private:
    // func:amc_vis.FCtype..Ctor
    inline               FCtype() __attribute__((nothrow));
    // func:amc_vis.FCtype..Dtor
    inline               ~FCtype() __attribute__((nothrow));
    friend amc_vis::FCtype&     ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FCtype*     ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FDb - In-memory database for amc_vis
<a href="#amc_vis-fdb"></a>

#### amc_vis.FDb Fields
<a href="#amc_vis-fdb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FDb.lpool|u8|[Lpool](/txt/exe/amc/reftypes.md#lpool)||private memory pool|
|amc_vis.FDb.cmdline|[command.amc_vis](/txt/protocol/command/README.md#command-amc_vis)|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FDb.ctype|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.field|[amc_vis.FField](/txt/exe/amc_vis/internals.md#amc_vis-ffield)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb._db|[amc_vis.FDb](/txt/exe/amc_vis/internals.md#amc_vis-fdb)|[Global](/txt/exe/amc/reftypes.md#global)|||
|amc_vis.FDb.ind_ctype|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|amc_vis.FDb.ind_field|[amc_vis.FField](/txt/exe/amc_vis/internals.md#amc_vis-ffield)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|amc_vis.FDb.node|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.ind_node|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|amc_vis.FDb.link|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.ind_link|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|amc_vis.FDb.linkdep|[amc_vis.FLinkdep](/txt/exe/amc_vis/internals.md#amc_vis-flinkdep)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.c_linklist|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Ptrary](/txt/exe/amc/reftypes.md#ptrary)|||
|amc_vis.FDb.bh_node|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Bheap](/txt/exe/amc/reftypes.md#bheap)||Heap of ctypes, used to compute columns|
|amc_vis.FDb.bh_link|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Bheap](/txt/exe/amc/reftypes.md#bheap)||Heap of links, used to place links|
|amc_vis.FDb.reftype|[amc_vis.FReftype](/txt/exe/amc_vis/internals.md#amc_vis-freftype)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.ind_reftype|[amc_vis.FReftype](/txt/exe/amc_vis/internals.md#amc_vis-freftype)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|amc_vis.FDb.nodedep|[amc_vis.FNodedep](/txt/exe/amc_vis/internals.md#amc_vis-fnodedep)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.outrow|[amc_vis.FOutrow](/txt/exe/amc_vis/internals.md#amc_vis-foutrow)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.zd_select|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|amc_vis.FDb.finput|[amc_vis.FFinput](/txt/exe/amc_vis/internals.md#amc_vis-ffinput)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|amc_vis.FDb.term_hei|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FDb.term_wid|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FDb.usecolor|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FDb.hastty|bool|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FDb
<a href="#struct-fdb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FDb { // amc_vis.FDb: In-memory database for amc_vis
    lpool_Lpblock*        lpool_free[36];              // Lpool levels
    command::amc_vis      cmdline;                     //
    amc_vis::FCtype*      ctype_lary[32];              // level array
    i32                   ctype_n;                     // number of elements in array
    amc_vis::FField*      field_lary[32];              // level array
    i32                   field_n;                     // number of elements in array
    amc_vis::FCtype**     ind_ctype_buckets_elems;     // pointer to bucket array
    i32                   ind_ctype_buckets_n;         // number of elements in bucket array
    i32                   ind_ctype_n;                 // number of elements in the hash table
    amc_vis::FField**     ind_field_buckets_elems;     // pointer to bucket array
    i32                   ind_field_buckets_n;         // number of elements in bucket array
    i32                   ind_field_n;                 // number of elements in the hash table
    amc_vis::FNode*       node_lary[32];               // level array
    i32                   node_n;                      // number of elements in array
    amc_vis::FNode**      ind_node_buckets_elems;      // pointer to bucket array
    i32                   ind_node_buckets_n;          // number of elements in bucket array
    i32                   ind_node_n;                  // number of elements in the hash table
    amc_vis::FLink*       link_lary[32];               // level array
    i32                   link_n;                      // number of elements in array
    amc_vis::FLink**      ind_link_buckets_elems;      // pointer to bucket array
    i32                   ind_link_buckets_n;          // number of elements in bucket array
    i32                   ind_link_n;                  // number of elements in the hash table
    amc_vis::FLinkdep*    linkdep_lary[32];            // level array
    i32                   linkdep_n;                   // number of elements in array
    amc_vis::FLink**      c_linklist_elems;            // array of pointers
    u32                   c_linklist_n;                // array of pointers
    u32                   c_linklist_max;              // capacity of allocated array
    amc_vis::FNode**      bh_node_elems;               // binary heap by nodekey
    i32                   bh_node_n;                   // number of elements in the heap
    i32                   bh_node_max;                 // max elements in bh_node_elems
    amc_vis::FLink**      bh_link_elems;               // binary heap by linkkey
    i32                   bh_link_n;                   // number of elements in the heap
    i32                   bh_link_max;                 // max elements in bh_link_elems
    amc_vis::FReftype*    reftype_lary[32];            // level array
    i32                   reftype_n;                   // number of elements in array
    amc_vis::FReftype**   ind_reftype_buckets_elems;   // pointer to bucket array
    i32                   ind_reftype_buckets_n;       // number of elements in bucket array
    i32                   ind_reftype_n;               // number of elements in the hash table
    amc_vis::FNodedep*    nodedep_lary[32];            // level array
    i32                   nodedep_n;                   // number of elements in array
    amc_vis::FOutrow*     outrow_lary[32];             // level array
    i32                   outrow_n;                    // number of elements in array
    amc_vis::FCtype*      zd_select_head;              // zero-terminated doubly linked list
    i32                   zd_select_n;                 // zero-terminated doubly linked list
    amc_vis::FCtype*      zd_select_tail;              // pointer to last element
    amc_vis::FFinput*     finput_lary[32];             // level array
    i32                   finput_n;                    // number of elements in array
    i32                   term_hei;                    //   0
    i32                   term_wid;                    //   0
    bool                  usecolor;                    //   false
    bool                  hastty;                      //   false
    amc_vis::trace        trace;                       //
};
```

#### amc_vis.FField - Specify field of a struct
<a href="#amc_vis-ffield"></a>

#### amc_vis.FField Fields
<a href="#amc_vis-ffield-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FField.msghdr|[dmmeta.Field](/txt/ssimdb/dmmeta/field.md)|[Base](/txt/ssimdb/dmmeta/field.md)|||
|amc_vis.FField.p_ctype|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FField.p_arg|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FField.p_reftype|[amc_vis.FReftype](/txt/exe/amc_vis/internals.md#amc_vis-freftype)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FField.c_finput|[amc_vis.FFinput](/txt/exe/amc_vis/internals.md#amc_vis-ffinput)|[Ptr](/txt/exe/amc/reftypes.md#ptr)|||

#### Struct FField
<a href="#struct-ffield"></a>
*Note:* field ``amc_vis.FField.msghdr`` has reftype ``base`` so the fields of [dmmeta.Field](/txt/ssimdb/dmmeta/field.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FField { // amc_vis.FField
    amc_vis::FField*     ind_field_next;         // hash next
    u32                  ind_field_hashval;      // hash value
    algo::Smallstr100    field;                  // Primary key, as ctype.name
    algo::Smallstr100    arg;                    // Type of field
    algo::Smallstr50     reftype;                //   "Val"  Type constructor
    algo::CppExpr        dflt;                   // Default value (c++ expression)
    algo::Comment        comment;                //
    amc_vis::FCtype*     p_ctype;                // reference to parent row
    amc_vis::FCtype*     p_arg;                  // reference to parent row
    amc_vis::FReftype*   p_reftype;              // reference to parent row
    amc_vis::FFinput*    c_finput;               // optional pointer
    bool                 ctype_c_field_in_ary;   //   false  membership flag
    // x-reference on amc_vis.FField.p_ctype prevents copy
    // x-reference on amc_vis.FField.p_arg prevents copy
    // x-reference on amc_vis.FField.p_reftype prevents copy
    // x-reference on amc_vis.FField.c_finput prevents copy
    // func:amc_vis.FField..AssignOp
    amc_vis::FField&     operator =(const amc_vis::FField &rhs) = delete;
    // x-reference on amc_vis.FField.p_ctype prevents copy
    // x-reference on amc_vis.FField.p_arg prevents copy
    // x-reference on amc_vis.FField.p_reftype prevents copy
    // x-reference on amc_vis.FField.c_finput prevents copy
    // func:amc_vis.FField..CopyCtor
    FField(const amc_vis::FField &rhs) = delete;
private:
    // func:amc_vis.FField..Ctor
    inline               FField() __attribute__((nothrow));
    // func:amc_vis.FField..Dtor
    inline               ~FField() __attribute__((nothrow));
    friend amc_vis::FField&     field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FField*     field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FFinput - Describe input table of a program
<a href="#amc_vis-ffinput"></a>

#### amc_vis.FFinput Fields
<a href="#amc_vis-ffinput-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FFinput.msghdr|[dmmeta.Finput](/txt/ssimdb/dmmeta/finput.md)|[Base](/txt/ssimdb/dmmeta/finput.md)|||

#### Struct FFinput
<a href="#struct-ffinput"></a>
*Note:* field ``amc_vis.FFinput.msghdr`` has reftype ``base`` so the fields of [dmmeta.Finput](/txt/ssimdb/dmmeta/finput.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FFinput { // amc_vis.FFinput
    algo::Smallstr100   field;     // Target field to read
    bool                extrn;     //   false  Call user-provided function
    bool                update;    //   false
    bool                strict;    //   true  Exist process if record contains error
    algo::Comment       comment;   //
    // func:amc_vis.FFinput..AssignOp
    inline amc_vis::FFinput& operator =(const amc_vis::FFinput &rhs) = delete;
    // func:amc_vis.FFinput..CopyCtor
    inline               FFinput(const amc_vis::FFinput &rhs) = delete;
private:
    // func:amc_vis.FFinput..Ctor
    inline               FFinput() __attribute__((nothrow));
    // func:amc_vis.FFinput..Dtor
    inline               ~FFinput() __attribute__((nothrow));
    friend amc_vis::FFinput&    finput_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FFinput*    finput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 finput_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.Linkkey - Heap key for selecting next link to render - fields quantify selection criteria
<a href="#amc_vis-linkkey"></a>

#### amc_vis.Linkkey Fields
<a href="#amc_vis-linkkey-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.Linkkey.n_link_in|u32|[Val](/txt/exe/amc/reftypes.md#val)||Number of incoming dependencies|
|amc_vis.Linkkey.samecol|i32|[Val](/txt/exe/amc/reftypes.md#val)||Set on links that lead to the same column|
|amc_vis.Linkkey.colweight|i32|[Val](/txt/exe/amc/reftypes.md#val)||Heavier columns are scheduled first|

#### Struct Linkkey
<a href="#struct-linkkey"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct Linkkey { // amc_vis.Linkkey: Heap key for selecting next link to render - fields quantify selection criteria
    u32   n_link_in;   //   0  Number of incoming dependencies
    i32   samecol;     //   0  Set on links that lead to the same column
    i32   colweight;   //   0  Heavier columns are scheduled first
    // func:amc_vis.Linkkey..EqOp
    inline bool          operator ==(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..NeOp
    inline bool          operator !=(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..LtOp
    inline bool          operator <(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..GtOp
    inline bool          operator >(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..LeOp
    inline bool          operator <=(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..GeOp
    inline bool          operator >=(const amc_vis::Linkkey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Linkkey..Ctor
    inline               Linkkey() __attribute__((nothrow));
    // func:amc_vis.Linkkey..FieldwiseCtor
    explicit inline               Linkkey(u32 in_n_link_in, i32 in_samecol, i32 in_colweight) __attribute__((nothrow));
};
```

#### amc_vis.FLink - Correspodns to a ctype
<a href="#amc_vis-flink"></a>

#### amc_vis.FLink Fields
<a href="#amc_vis-flink-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FLink.link|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Primary key|
|amc_vis.FLink.label1|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Label in column 1|
|amc_vis.FLink.label2|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Label in column 2|
|amc_vis.FLink.linkkey|[amc_vis.Linkkey](/txt/exe/amc_vis/internals.md#amc_vis-linkkey)|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FLink.outrow|i32|[Val](/txt/exe/amc/reftypes.md#val)||Outrow #|
|amc_vis.FLink.p_node1|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FLink.p_node2|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FLink.upptr|bool|[Val](/txt/exe/amc/reftypes.md#val)||Up-arrow (not a constraint)|
|amc_vis.FLink.zd_linkdep_out|[amc_vis.FLinkdep](/txt/exe/amc_vis/internals.md#amc_vis-flinkdep)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrow from this ctype|
|amc_vis.FLink.zd_linkdep_in|[amc_vis.FLinkdep](/txt/exe/amc_vis/internals.md#amc_vis-flinkdep)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrows to this ctype|

#### Struct FLink
<a href="#struct-flink"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FLink { // amc_vis.FLink: Correspodns to a ctype
    amc_vis::FLink*      ind_link_next;           // hash next
    u32                  ind_link_hashval;        // hash value
    i32                  bh_link_idx;             // index in heap; -1 means not-in-heap
    algo::cstring        link;                    // Primary key
    algo::cstring        label1;                  // Label in column 1
    algo::cstring        label2;                  // Label in column 2
    amc_vis::Linkkey     linkkey;                 //
    i32                  outrow;                  //   0  Outrow #
    amc_vis::FNode*      p_node1;                 // reference to parent row
    amc_vis::FNode*      p_node2;                 // reference to parent row
    bool                 upptr;                   //   false  Up-arrow (not a constraint)
    amc_vis::FLinkdep*   zd_linkdep_out_head;     // zero-terminated doubly linked list
    amc_vis::FLinkdep*   zd_linkdep_out_tail;     // pointer to last element
    amc_vis::FLinkdep*   zd_linkdep_in_head;      // zero-terminated doubly linked list
    amc_vis::FLinkdep*   zd_linkdep_in_tail;      // pointer to last element
    bool                 c_linklist_in_ary;       //   false  membership flag
    amc_vis::FLink*      node_zd_link_out_next;   // zslist link; -1 means not-in-list
    amc_vis::FLink*      node_zd_link_out_prev;   // previous element
    amc_vis::FLink*      node_zd_link_in_next;    // zslist link; -1 means not-in-list
    amc_vis::FLink*      node_zd_link_in_prev;    // previous element
    // reftype Llist of amc_vis.FLink.zd_linkdep_out prohibits copy
    // reftype Llist of amc_vis.FLink.zd_linkdep_in prohibits copy
    // func:amc_vis.FLink..AssignOp
    amc_vis::FLink&      operator =(const amc_vis::FLink &rhs) = delete;
    // reftype Llist of amc_vis.FLink.zd_linkdep_out prohibits copy
    // reftype Llist of amc_vis.FLink.zd_linkdep_in prohibits copy
    // func:amc_vis.FLink..CopyCtor
    FLink(const amc_vis::FLink &rhs) = delete;
private:
    // func:amc_vis.FLink..Ctor
    inline               FLink() __attribute__((nothrow));
    // func:amc_vis.FLink..Dtor
    inline               ~FLink() __attribute__((nothrow));
    friend amc_vis::FLink&      link_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FLink*      link_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 link_RemoveAll() __attribute__((nothrow));
    friend void                 link_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FLinkdep - Corresponds to a field
<a href="#amc_vis-flinkdep"></a>

#### amc_vis.FLinkdep Fields
<a href="#amc_vis-flinkdep-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FLinkdep.row|[amc_vis.FOutrow](/txt/exe/amc_vis/internals.md#amc_vis-foutrow)|[Pkey](/txt/exe/amc/reftypes.md#pkey)|||
|amc_vis.FLinkdep.rowid|i32|[Val](/txt/exe/amc/reftypes.md#val)||Id|
|amc_vis.FLinkdep.up|bool|[Val](/txt/exe/amc/reftypes.md#val)||Points up|
|amc_vis.FLinkdep.inst|bool|[Val](/txt/exe/amc/reftypes.md#val)||Instance (vs. index)|
|amc_vis.FLinkdep.p_link_from|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||Source ctype|
|amc_vis.FLinkdep.p_link_to|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||Target ctype|

#### Struct FLinkdep
<a href="#struct-flinkdep"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FLinkdep { // amc_vis.FLinkdep: Corresponds to a field
    amc_vis::FLinkdep*   link_zd_linkdep_out_next;   // zslist link; -1 means not-in-list
    amc_vis::FLinkdep*   link_zd_linkdep_out_prev;   // previous element
    amc_vis::FLinkdep*   link_zd_linkdep_in_next;    // zslist link; -1 means not-in-list
    amc_vis::FLinkdep*   link_zd_linkdep_in_prev;    // previous element
    i32                  row;                        //   0
    i32                  rowid;                      //   0  Id
    bool                 up;                         //   false  Points up
    bool                 inst;                       //   false  Instance (vs. index)
    amc_vis::FLink*      p_link_from;                // reference to parent row
    amc_vis::FLink*      p_link_to;                  // reference to parent row
    // func:amc_vis.FLinkdep..AssignOp
    inline amc_vis::FLinkdep& operator =(const amc_vis::FLinkdep &rhs) = delete;
    // func:amc_vis.FLinkdep..CopyCtor
    inline               FLinkdep(const amc_vis::FLinkdep &rhs) = delete;
    // func:amc_vis.FLinkdep..FieldwiseCtor
    explicit inline               FLinkdep(i32 in_row, i32 in_rowid, bool in_up, bool in_inst, amc_vis::FLink* in_p_link_from, amc_vis::FLink* in_p_link_to) __attribute__((nothrow));
private:
    // func:amc_vis.FLinkdep..Ctor
    inline               FLinkdep() __attribute__((nothrow));
    // func:amc_vis.FLinkdep..Dtor
    inline               ~FLinkdep() __attribute__((nothrow));
    friend amc_vis::FLinkdep&   linkdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FLinkdep*   linkdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 linkdep_RemoveAll() __attribute__((nothrow));
    friend void                 linkdep_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.Nodekey - Correspodns to a ctype
<a href="#amc_vis-nodekey"></a>

#### amc_vis.Nodekey Fields
<a href="#amc_vis-nodekey-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.Nodekey.n_ct_in|u32|[Val](/txt/exe/amc/reftypes.md#val)||Number of incoming dependencies|
|amc_vis.Nodekey.idx|i32|[Val](/txt/exe/amc/reftypes.md#val)||Set to -rowid|

#### Struct Nodekey
<a href="#struct-nodekey"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct Nodekey { // amc_vis.Nodekey: Correspodns to a ctype
    u32   n_ct_in;   //   0  Number of incoming dependencies
    i32   idx;       //   0  Set to -rowid
    // func:amc_vis.Nodekey..EqOp
    inline bool          operator ==(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..NeOp
    inline bool          operator !=(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..LtOp
    inline bool          operator <(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..GtOp
    inline bool          operator >(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..LeOp
    inline bool          operator <=(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..GeOp
    inline bool          operator >=(const amc_vis::Nodekey &rhs) const __attribute__((nothrow));
    // func:amc_vis.Nodekey..Ctor
    inline               Nodekey() __attribute__((nothrow));
    // func:amc_vis.Nodekey..FieldwiseCtor
    explicit inline               Nodekey(u32 in_n_ct_in, i32 in_idx) __attribute__((nothrow));
};
```

#### amc_vis.FNode - Corresponds to a ctype
<a href="#amc_vis-fnode"></a>

#### amc_vis.FNode Fields
<a href="#amc_vis-fnode-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FNode.node|[algo.Smallstr100](/txt/protocol/algo/README.md#algo-smallstr100)|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FNode.nodekey|[amc_vis.Nodekey](/txt/exe/amc_vis/internals.md#amc_vis-nodekey)|[Val](/txt/exe/amc/reftypes.md#val)||Sort key for columns|
|amc_vis.FNode.label|[algo.Smallstr100](/txt/protocol/algo/README.md#algo-smallstr100)|[Val](/txt/exe/amc/reftypes.md#val)||Display label|
|amc_vis.FNode.xpos|i32|[Val](/txt/exe/amc/reftypes.md#val)|0||
|amc_vis.FNode.label2|[algo.Smallstr100](/txt/protocol/algo/README.md#algo-smallstr100)|[Val](/txt/exe/amc/reftypes.md#val)||Display label|
|amc_vis.FNode.c_bottom|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Ptr](/txt/exe/amc/reftypes.md#ptr)||Bottom|
|amc_vis.FNode.c_top|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Ptr](/txt/exe/amc/reftypes.md#ptr)||Top|
|amc_vis.FNode.p_ctype|[amc_vis.FCtype](/txt/exe/amc_vis/internals.md#amc_vis-fctype)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|amc_vis.FNode.rowid|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FNode.zd_nodedep_out|[amc_vis.FNodedep](/txt/exe/amc_vis/internals.md#amc_vis-fnodedep)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrow from this ctype|
|amc_vis.FNode.zd_nodedep_in|[amc_vis.FNodedep](/txt/exe/amc_vis/internals.md#amc_vis-fnodedep)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrows to this ctype|
|amc_vis.FNode.zd_link_out|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrow from this ctype|
|amc_vis.FNode.zd_link_in|[amc_vis.FLink](/txt/exe/amc_vis/internals.md#amc_vis-flink)|[Llist](/txt/exe/amc/reftypes.md#llist)||Arrow from this ctype|

#### Struct FNode
<a href="#struct-fnode"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FNode { // amc_vis.FNode: Corresponds to a ctype
    amc_vis::FNode*      ind_node_next;         // hash next
    u32                  ind_node_hashval;      // hash value
    i32                  bh_node_idx;           // index in heap; -1 means not-in-heap
    algo::Smallstr100    node;                  //
    amc_vis::Nodekey     nodekey;               // Sort key for columns
    algo::Smallstr100    label;                 // Display label
    i32                  xpos;                  //   0
    algo::Smallstr100    label2;                // Display label
    amc_vis::FLink*      c_bottom;              // Bottom. optional pointer
    amc_vis::FLink*      c_top;                 // Top. optional pointer
    amc_vis::FCtype*     p_ctype;               // reference to parent row
    i32                  rowid;                 //   0
    amc_vis::FNodedep*   zd_nodedep_out_head;   // zero-terminated doubly linked list
    amc_vis::FNodedep*   zd_nodedep_out_tail;   // pointer to last element
    amc_vis::FNodedep*   zd_nodedep_in_head;    // zero-terminated doubly linked list
    i32                  zd_nodedep_in_n;       // zero-terminated doubly linked list
    amc_vis::FNodedep*   zd_nodedep_in_tail;    // pointer to last element
    amc_vis::FLink*      zd_link_out_head;      // zero-terminated doubly linked list
    i32                  zd_link_out_n;         // zero-terminated doubly linked list
    amc_vis::FLink*      zd_link_out_tail;      // pointer to last element
    amc_vis::FLink*      zd_link_in_head;       // zero-terminated doubly linked list
    i32                  zd_link_in_n;          // zero-terminated doubly linked list
    amc_vis::FLink*      zd_link_in_tail;       // pointer to last element
    // reftype Llist of amc_vis.FNode.zd_nodedep_out prohibits copy
    // reftype Llist of amc_vis.FNode.zd_nodedep_in prohibits copy
    // reftype Llist of amc_vis.FNode.zd_link_out prohibits copy
    // reftype Llist of amc_vis.FNode.zd_link_in prohibits copy
    // func:amc_vis.FNode..AssignOp
    amc_vis::FNode&      operator =(const amc_vis::FNode &rhs) = delete;
    // reftype Llist of amc_vis.FNode.zd_nodedep_out prohibits copy
    // reftype Llist of amc_vis.FNode.zd_nodedep_in prohibits copy
    // reftype Llist of amc_vis.FNode.zd_link_out prohibits copy
    // reftype Llist of amc_vis.FNode.zd_link_in prohibits copy
    // func:amc_vis.FNode..CopyCtor
    FNode(const amc_vis::FNode &rhs) = delete;
private:
    // func:amc_vis.FNode..Ctor
    inline               FNode() __attribute__((nothrow));
    // func:amc_vis.FNode..Dtor
    inline               ~FNode() __attribute__((nothrow));
    friend amc_vis::FNode&      node_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FNode*      node_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 node_RemoveAll() __attribute__((nothrow));
    friend void                 node_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FNodedep - Edge for computing node dependencies
<a href="#amc_vis-fnodedep"></a>

#### amc_vis.FNodedep Fields
<a href="#amc_vis-fnodedep-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FNodedep.row|[amc_vis.FOutrow](/txt/exe/amc_vis/internals.md#amc_vis-foutrow)|[Pkey](/txt/exe/amc/reftypes.md#pkey)|||
|amc_vis.FNodedep.rowid|i32|[Val](/txt/exe/amc/reftypes.md#val)||Id|
|amc_vis.FNodedep.up|bool|[Val](/txt/exe/amc/reftypes.md#val)||Points up|
|amc_vis.FNodedep.inst|bool|[Val](/txt/exe/amc/reftypes.md#val)||Instance (vs. index)|
|amc_vis.FNodedep.p_node1|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||Source ctype|
|amc_vis.FNodedep.p_node2|[amc_vis.FNode](/txt/exe/amc_vis/internals.md#amc_vis-fnode)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||Target ctype|
|amc_vis.FNodedep.name|[algo.Smallstr50](/txt/protocol/algo/README.md#algo-smallstr50)|[Val](/txt/exe/amc/reftypes.md#val)|||
|amc_vis.FNodedep.reftype|[dmmeta.Reftype](/txt/ssimdb/dmmeta/reftype.md)|[Pkey](/txt/exe/amc/reftypes.md#pkey)|||

#### Struct FNodedep
<a href="#struct-fnodedep"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FNodedep { // amc_vis.FNodedep: Edge for computing node dependencies
    amc_vis::FNodedep*   node_zd_nodedep_out_next;   // zslist link; -1 means not-in-list
    amc_vis::FNodedep*   node_zd_nodedep_out_prev;   // previous element
    amc_vis::FNodedep*   node_zd_nodedep_in_next;    // zslist link; -1 means not-in-list
    amc_vis::FNodedep*   node_zd_nodedep_in_prev;    // previous element
    i32                  row;                        //   0
    i32                  rowid;                      //   0  Id
    bool                 up;                         //   false  Points up
    bool                 inst;                       //   false  Instance (vs. index)
    amc_vis::FNode*      p_node1;                    // reference to parent row
    amc_vis::FNode*      p_node2;                    // reference to parent row
    algo::Smallstr50     name;                       //
    algo::Smallstr50     reftype;                    //
    // func:amc_vis.FNodedep..AssignOp
    inline amc_vis::FNodedep& operator =(const amc_vis::FNodedep &rhs) = delete;
    // func:amc_vis.FNodedep..CopyCtor
    inline               FNodedep(const amc_vis::FNodedep &rhs) = delete;
    // func:amc_vis.FNodedep..FieldwiseCtor
    explicit inline               FNodedep(i32 in_row, i32 in_rowid, bool in_up, bool in_inst, amc_vis::FNode* in_p_node1, amc_vis::FNode* in_p_node2, const algo::strptr& in_name, const algo::strptr& in_reftype) __attribute__((nothrow));
private:
    // func:amc_vis.FNodedep..Ctor
    inline               FNodedep() __attribute__((nothrow));
    // func:amc_vis.FNodedep..Dtor
    inline               ~FNodedep() __attribute__((nothrow));
    friend amc_vis::FNodedep&   nodedep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FNodedep*   nodedep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nodedep_RemoveAll() __attribute__((nothrow));
    friend void                 nodedep_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FOutrow - One line of text
<a href="#amc_vis-foutrow"></a>

#### amc_vis.FOutrow Fields
<a href="#amc_vis-foutrow-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FOutrow.rowid|i32|[Val](/txt/exe/amc/reftypes.md#val)||FOutrow pkey|
|amc_vis.FOutrow.text|u16|[Tary](/txt/exe/amc/reftypes.md#tary)||Lower byte=text; Upper byte=color|

#### Struct FOutrow
<a href="#struct-foutrow"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FOutrow { // amc_vis.FOutrow: One line of text
    i32    rowid;        //   0  FOutrow pkey
    u16*   text_elems;   // pointer to elements
    u32    text_n;       // number of elements in array
    u32    text_max;     // max. capacity of array before realloc
    // func:amc_vis.FOutrow..AssignOp
    amc_vis::FOutrow&    operator =(const amc_vis::FOutrow &rhs) __attribute__((nothrow));
    // func:amc_vis.FOutrow..CopyCtor
    FOutrow(const amc_vis::FOutrow &rhs) __attribute__((nothrow));
private:
    // func:amc_vis.FOutrow..Ctor
    inline               FOutrow() __attribute__((nothrow));
    // func:amc_vis.FOutrow..Dtor
    inline               ~FOutrow() __attribute__((nothrow));
    friend amc_vis::FOutrow&    outrow_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FOutrow*    outrow_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 outrow_RemoveAll() __attribute__((nothrow));
    friend void                 outrow_RemoveLast() __attribute__((nothrow));
};
```

#### amc_vis.FReftype - Field type constructor (e.g. reference type)
<a href="#amc_vis-freftype"></a>

#### amc_vis.FReftype Fields
<a href="#amc_vis-freftype-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|amc_vis.FReftype.msghdr|[dmmeta.Reftype](/txt/ssimdb/dmmeta/reftype.md)|[Base](/txt/ssimdb/dmmeta/reftype.md)|||

#### Struct FReftype
<a href="#struct-freftype"></a>
*Note:* field ``amc_vis.FReftype.msghdr`` has reftype ``base`` so the fields of [dmmeta.Reftype](/txt/ssimdb/dmmeta/reftype.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/amc_vis_gen.h](/include/gen/amc_vis_gen.h)
```
struct FReftype { // amc_vis.FReftype
    amc_vis::FReftype*   ind_reftype_next;      // hash next
    u32                  ind_reftype_hashval;   // hash value
    algo::Smallstr50     reftype;               //   "Val"
    bool                 isval;                 //   false  True if field makes values of target type
    bool                 cascins;               //   false  Field is cascade-insert
    bool                 usebasepool;           //   false  Fields with this type make use of dmmeta.basepool
    bool                 cancopy;               //   false  This type of field can be copied
    bool                 isxref;                //   false  This type of field is an x-ref
    bool                 del;                   //   false  Supports random deletion?
    bool                 up;                    //   false  This type of field is a reference
    bool                 isnew;                 //   false  If set, skip this relation in amc_vis
    bool                 hasalloc;              //   false  Generte Alloc/Delete functions for arg type
    bool                 inst;                  //   false  Field creates an instance of arg type (directly or indirectly)
    bool                 varlen;                //   false  This pool supports varlen allocations
    // func:amc_vis.FReftype..AssignOp
    amc_vis::FReftype&   operator =(const amc_vis::FReftype &rhs) = delete;
    // func:amc_vis.FReftype..CopyCtor
    FReftype(const amc_vis::FReftype &rhs) = delete;
private:
    // func:amc_vis.FReftype..Ctor
    inline               FReftype() __attribute__((nothrow));
    // func:amc_vis.FReftype..Dtor
    inline               ~FReftype() __attribute__((nothrow));
    friend amc_vis::FReftype&   reftype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc_vis::FReftype*   reftype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 reftype_RemoveLast() __attribute__((nothrow));
};
```

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Imdb -->

