## src_func - Internals


### Table Of Contents
<a href="#table-of-contents"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Toc -->
* [Description](#description)
* [Sources](#sources)
* [Dependencies](#dependencies)
* [In Memory DB](#in-memory-db)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Toc -->

### Description
<a href="#description"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Description -->
for usage, see [src_func - Access / edit functions](/txt/exe/src_func/README.md)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Description -->

### Sources
<a href="#sources"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Sources -->
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/gen/src_func_gen.cpp](/cpp/gen/src_func_gen.cpp)||
|[cpp/src_func/edit.cpp](/cpp/src_func/edit.cpp)|Implementation of -e|
|[cpp/src_func/fileloc.cpp](/cpp/src_func/fileloc.cpp)|Location in file, for each function|
|[cpp/src_func/header.cpp](/cpp/src_func/header.cpp)|Generate prototypes in header|
|[cpp/src_func/iffy.cpp](/cpp/src_func/iffy.cpp)|Check iffy function prototypes|
|[cpp/src_func/list.cpp](/cpp/src_func/list.cpp)|Print list of functions|
|[cpp/src_func/main.cpp](/cpp/src_func/main.cpp)|Main file|
|[cpp/src_func/nextfile.cpp](/cpp/src_func/nextfile.cpp)|Find next file in target|
|[cpp/src_func/scan.cpp](/cpp/src_func/scan.cpp)|Scan sources to collect functions|
|[include/gen/src_func_gen.h](/include/gen/src_func_gen.h)||
|[include/gen/src_func_gen.inl.h](/include/gen/src_func_gen.inl.h)||
|[include/src_func.h](/include/src_func.h)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Sources -->

### Dependencies
<a href="#dependencies"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Dependencies -->
The build target depends on the following libraries
|Target|Comment|
|---|---|
|[algo_lib](/txt/lib/algo_lib/README.md)|Support library for all executables|

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Dependencies -->

### In Memory DB
<a href="#in-memory-db"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Imdb -->
`src_func` generated code creates the tables below.
All allocations are done through global `src_func::_db` [src_func.FDb](#src_func-fdb) structure
|Ctype|Ssimfile|Create|Access|
|---|---|---|---|
|[src_func.FCtypelen](#src_func-fctypelen)|[dmmeta.ctypelen](/txt/ssimdb/dmmeta/ctypelen.md)|FDb.ctypelen (Lary)|ctypelen (Lary, by rowid)|ind_ctypelen (Thash, hash field ctype)|
|[src_func.FDb](#src_func-fdb)||FDb._db (Global)|
|[src_func.FFunc](#src_func-ffunc)||FDb.func (Lary)|func (Lary, by rowid)|ind_func (Thash, hash field func)|bh_func (Bheap, sort field sortkey)|
||||FTargsrc.zd_func (Llist)|
||||FUserfunc.zd_func (Llist)|
|[src_func.FGenaffix](#src_func-fgenaffix)||FDb.genaffix (Lary)|genaffix (Lary, by rowid)|ind_genaffix (Thash, hash field genaffix)|
|[src_func.FTarget](#src_func-ftarget)|[dev.target](/txt/ssimdb/dev/target.md)|FDb.target (Lary)|target (Lary, by rowid)|ind_target (Thash, hash field target)|
||||FTargsrc.p_target (Upptr)|
|[src_func.FTargsrc](#src_func-ftargsrc)|[dev.targsrc](/txt/ssimdb/dev/targsrc.md)|FDb.targsrc (Lary)|targsrc (Lary, by rowid)|c_cur_targsrc (Ptr)|
||||FFunc.p_targsrc (Upptr)|
||||FFunc.p_written_to (Upptr)|
||||FTarget.cd_targsrc (Llist)|
|[src_func.FUserfunc](#src_func-fuserfunc)|[dmmeta.userfunc](/txt/ssimdb/dmmeta/userfunc.md)|FDb.userfunc (Lary)|userfunc (Lary, by rowid)|ind_userfunc (Thash, hash field userfunc)|ind_userfunc_cppname (Thash, hash field cppname)|
||||FFunc.p_userfunc (Upptr)|

#### src_func.FCtypelen - Size of Ctype
<a href="#src_func-fctypelen"></a>

#### src_func.FCtypelen Fields
<a href="#src_func-fctypelen-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FCtypelen.base|[dmmeta.Ctypelen](/txt/ssimdb/dmmeta/ctypelen.md)|[Base](/txt/ssimdb/dmmeta/ctypelen.md)|||

#### Struct FCtypelen
<a href="#struct-fctypelen"></a>
*Note:* field ``src_func.FCtypelen.base`` has reftype ``base`` so the fields of [dmmeta.Ctypelen](/txt/ssimdb/dmmeta/ctypelen.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FCtypelen { // src_func.FCtypelen
    algo::Smallstr100      ctype;                  // Identifies the Ctype
    u32                    len;                    //   0  (calculated) length of the C++ struct in bytes
    i32                    alignment;              //   0  (calculated) alignment for the struct
    i32                    padbytes;               //   0  (calculated) total # of pad bytes
    bool                   plaindata;              //   false  (calculated) this struct can me safely memcpy'ed
    src_func::FCtypelen*   ind_ctypelen_next;      // hash next
    u32                    ind_ctypelen_hashval;   // hash value
    // func:src_func.FCtypelen..AssignOp
    inline src_func::FCtypelen& operator =(const src_func::FCtypelen &rhs) = delete;
    // func:src_func.FCtypelen..CopyCtor
    inline               FCtypelen(const src_func::FCtypelen &rhs) = delete;
private:
    // func:src_func.FCtypelen..Ctor
    inline               FCtypelen() __attribute__((nothrow));
    // func:src_func.FCtypelen..Dtor
    inline               ~FCtypelen() __attribute__((nothrow));
    friend src_func::FCtypelen& ctypelen_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FCtypelen* ctypelen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctypelen_RemoveAll() __attribute__((nothrow));
    friend void                 ctypelen_RemoveLast() __attribute__((nothrow));
};
```

#### src_func.FDb - In-memory database for src_func
<a href="#src_func-fdb"></a>

#### src_func.FDb Fields
<a href="#src_func-fdb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FDb.report|[report.src_func](/txt/protocol/report/README.md#report-src_func)|[Val](/txt/exe/amc/reftypes.md#val)||Final report|
|src_func.FDb._db|[src_func.FDb](/txt/exe/src_func/internals.md#src_func-fdb)|[Global](/txt/exe/amc/reftypes.md#global)|||
|src_func.FDb.cmdline|[command.src_func](/txt/protocol/command/README.md#command-src_func)|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FDb.targsrc|[src_func.FTargsrc](/txt/exe/src_func/internals.md#src_func-ftargsrc)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.target|[src_func.FTarget](/txt/exe/src_func/internals.md#src_func-ftarget)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.ind_target|[src_func.FTarget](/txt/exe/src_func/internals.md#src_func-ftarget)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|src_func.FDb.func|[src_func.FFunc](/txt/exe/src_func/internals.md#src_func-ffunc)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.ind_func|[src_func.FFunc](/txt/exe/src_func/internals.md#src_func-ffunc)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|src_func.FDb.bh_func|[src_func.FFunc](/txt/exe/src_func/internals.md#src_func-ffunc)|[Bheap](/txt/exe/amc/reftypes.md#bheap)|||
|src_func.FDb.c_cur_targsrc|[src_func.FTargsrc](/txt/exe/src_func/internals.md#src_func-ftargsrc)|[Ptr](/txt/exe/amc/reftypes.md#ptr)|||
|src_func.FDb.cur_line|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FDb.ignore_funcstart|[algo_lib.Regx](/txt/lib/algo_lib/README.md#algo_lib-regx)|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FDb.ctypelen|[src_func.FCtypelen](/txt/exe/src_func/internals.md#src_func-fctypelen)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.ind_ctypelen|[src_func.FCtypelen](/txt/exe/src_func/internals.md#src_func-fctypelen)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|src_func.FDb.printed_user_impl_notice|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FDb.userfunc|[src_func.FUserfunc](/txt/exe/src_func/internals.md#src_func-fuserfunc)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.ind_userfunc|[src_func.FUserfunc](/txt/exe/src_func/internals.md#src_func-fuserfunc)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|src_func.FDb.ind_userfunc_cppname|[src_func.FUserfunc](/txt/exe/src_func/internals.md#src_func-fuserfunc)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|src_func.FDb.editloc|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||List of locations to edit|
|src_func.FDb.genaffix|[src_func.FGenaffix](/txt/exe/src_func/internals.md#src_func-fgenaffix)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|src_func.FDb.ind_genaffix|[src_func.FGenaffix](/txt/exe/src_func/internals.md#src_func-fgenaffix)|[Thash](/txt/exe/amc/reftypes.md#thash)|||

#### Struct FDb
<a href="#struct-fdb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FDb { // src_func.FDb: In-memory database for src_func
    report::src_func        report;                               // Final report
    command::src_func       cmdline;                              //
    src_func::FTargsrc*     targsrc_lary[32];                     // level array
    i32                     targsrc_n;                            // number of elements in array
    src_func::FTarget*      target_lary[32];                      // level array
    i32                     target_n;                             // number of elements in array
    src_func::FTarget**     ind_target_buckets_elems;             // pointer to bucket array
    i32                     ind_target_buckets_n;                 // number of elements in bucket array
    i32                     ind_target_n;                         // number of elements in the hash table
    src_func::FFunc*        func_lary[32];                        // level array
    i32                     func_n;                               // number of elements in array
    src_func::FFunc**       ind_func_buckets_elems;               // pointer to bucket array
    i32                     ind_func_buckets_n;                   // number of elements in bucket array
    i32                     ind_func_n;                           // number of elements in the hash table
    src_func::FFunc**       bh_func_elems;                        // binary heap by sortkey
    i32                     bh_func_n;                            // number of elements in the heap
    i32                     bh_func_max;                          // max elements in bh_func_elems
    src_func::FTargsrc*     c_cur_targsrc;                        // optional pointer
    i32                     cur_line;                             //   0
    algo_lib::Regx          ignore_funcstart;                     //
    src_func::FCtypelen*    ctypelen_lary[32];                    // level array
    i32                     ctypelen_n;                           // number of elements in array
    src_func::FCtypelen**   ind_ctypelen_buckets_elems;           // pointer to bucket array
    i32                     ind_ctypelen_buckets_n;               // number of elements in bucket array
    i32                     ind_ctypelen_n;                       // number of elements in the hash table
    bool                    printed_user_impl_notice;             //   false
    src_func::FUserfunc*    userfunc_lary[32];                    // level array
    i32                     userfunc_n;                           // number of elements in array
    src_func::FUserfunc**   ind_userfunc_buckets_elems;           // pointer to bucket array
    i32                     ind_userfunc_buckets_n;               // number of elements in bucket array
    i32                     ind_userfunc_n;                       // number of elements in the hash table
    src_func::FUserfunc**   ind_userfunc_cppname_buckets_elems;   // pointer to bucket array
    i32                     ind_userfunc_cppname_buckets_n;       // number of elements in bucket array
    i32                     ind_userfunc_cppname_n;               // number of elements in the hash table
    algo::cstring           editloc;                              // List of locations to edit
    src_func::FGenaffix*    genaffix_lary[32];                    // level array
    i32                     genaffix_n;                           // number of elements in array
    src_func::FGenaffix**   ind_genaffix_buckets_elems;           // pointer to bucket array
    i32                     ind_genaffix_buckets_n;               // number of elements in bucket array
    i32                     ind_genaffix_n;                       // number of elements in the hash table
    src_func::trace         trace;                                //
};
```

#### src_func.FFunc - 
<a href="#src_func-ffunc"></a>

#### src_func.FFunc Fields
<a href="#src_func-ffunc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FFunc.func|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||First line of function -- primary key|
|src_func.FFunc.name|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Function name in the form ns.name|
|src_func.FFunc.args|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Argument list -- everything beyond first open parenthesis|
|src_func.FFunc.sortkey|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FFunc.body|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Function body|
|src_func.FFunc.p_targsrc|[src_func.FTargsrc](/txt/exe/src_func/internals.md#src_func-ftargsrc)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||Pointer to source file|
|src_func.FFunc.line|i32|[Val](/txt/exe/amc/reftypes.md#val)||Line number where function started|
|src_func.FFunc.precomment|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)||Comments that appeare before function body|
|src_func.FFunc.isstatic|bool|[Val](/txt/exe/amc/reftypes.md#val)||Static?|
|src_func.FFunc.isinline|bool|[Val](/txt/exe/amc/reftypes.md#val)||Inline?|
|src_func.FFunc.select|bool|[Val](/txt/exe/amc/reftypes.md#val)||Select for further processing|
|src_func.FFunc.iffy|bool|[Val](/txt/exe/amc/reftypes.md#val)||Something wrong with the declaration|
|src_func.FFunc.mystery|bool|[Val](/txt/exe/amc/reftypes.md#val)||Non-static and missing a comment|
|src_func.FFunc.p_written_to|[src_func.FTargsrc](/txt/exe/src_func/internals.md#src_func-ftargsrc)|[Upptr](/txt/exe/amc/reftypes.md#upptr)||If non-NULL, header where this function is written|
|src_func.FFunc.p_userfunc|[src_func.FUserfunc](/txt/exe/src_func/internals.md#src_func-fuserfunc)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||

#### Struct FFunc
<a href="#struct-ffunc"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FFunc { // src_func.FFunc
    src_func::FFunc*       ind_func_next;           // hash next
    u32                    ind_func_hashval;        // hash value
    i32                    bh_func_idx;             // index in heap; -1 means not-in-heap
    algo::cstring          func;                    // First line of function -- primary key
    algo::cstring          name;                    // Function name in the form ns.name
    algo::cstring          args;                    // Argument list -- everything beyond first open parenthesis
    algo::cstring          sortkey;                 //
    algo::cstring          body;                    // Function body
    src_func::FTargsrc*    p_targsrc;               // reference to parent row
    i32                    line;                    //   0  Line number where function started
    algo::cstring          precomment;              // Comments that appeare before function body
    bool                   isstatic;                //   false  Static?
    bool                   isinline;                //   false  Inline?
    bool                   select;                  //   false  Select for further processing
    bool                   iffy;                    //   false  Something wrong with the declaration
    bool                   mystery;                 //   false  Non-static and missing a comment
    src_func::FTargsrc*    p_written_to;            // reference to parent row
    src_func::FUserfunc*   p_userfunc;              // reference to parent row
    src_func::FFunc*       targsrc_zd_func_next;    // zslist link; -1 means not-in-list
    src_func::FFunc*       targsrc_zd_func_prev;    // previous element
    src_func::FFunc*       userfunc_zd_func_next;   // zslist link; -1 means not-in-list
    src_func::FFunc*       userfunc_zd_func_prev;   // previous element
    // func:src_func.FFunc..AssignOp
    src_func::FFunc&     operator =(const src_func::FFunc &rhs) = delete;
    // func:src_func.FFunc..CopyCtor
    FFunc(const src_func::FFunc &rhs) = delete;
private:
    // func:src_func.FFunc..Ctor
    inline               FFunc() __attribute__((nothrow));
    // func:src_func.FFunc..Dtor
    inline               ~FFunc() __attribute__((nothrow));
    friend src_func::FFunc&     func_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FFunc*     func_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 func_RemoveAll() __attribute__((nothrow));
    friend void                 func_RemoveLast() __attribute__((nothrow));
};
```

#### src_func.FGenaffix - Prefix or suffix of a generated function -- skip generating prototype
<a href="#src_func-fgenaffix"></a>

#### src_func.FGenaffix Fields
<a href="#src_func-fgenaffix-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FGenaffix.genaffix|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FGenaffix
<a href="#struct-fgenaffix"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FGenaffix { // src_func.FGenaffix: Prefix or suffix of a generated function -- skip generating prototype
    src_func::FGenaffix*   ind_genaffix_next;      // hash next
    u32                    ind_genaffix_hashval;   // hash value
    algo::cstring          genaffix;               //
    // func:src_func.FGenaffix..AssignOp
    inline src_func::FGenaffix& operator =(const src_func::FGenaffix &rhs) = delete;
    // func:src_func.FGenaffix..CopyCtor
    inline               FGenaffix(const src_func::FGenaffix &rhs) = delete;
private:
    // func:src_func.FGenaffix..Ctor
    inline               FGenaffix() __attribute__((nothrow));
    // func:src_func.FGenaffix..Dtor
    inline               ~FGenaffix() __attribute__((nothrow));
    friend src_func::FGenaffix& genaffix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FGenaffix* genaffix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 genaffix_RemoveAll() __attribute__((nothrow));
    friend void                 genaffix_RemoveLast() __attribute__((nothrow));
};
```

#### src_func.FTarget - Build target
<a href="#src_func-ftarget"></a>

#### src_func.FTarget Fields
<a href="#src_func-ftarget-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FTarget.base|[dev.Target](/txt/ssimdb/dev/target.md)|[Base](/txt/ssimdb/dev/target.md)|||
|src_func.FTarget.cd_targsrc|[src_func.FTargsrc](/txt/exe/src_func/internals.md#src_func-ftargsrc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||

#### Struct FTarget
<a href="#struct-ftarget"></a>
*Note:* field ``src_func.FTarget.base`` has reftype ``base`` so the fields of [dev.Target](/txt/ssimdb/dev/target.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FTarget { // src_func.FTarget
    src_func::FTarget*    ind_target_next;      // hash next
    u32                   ind_target_hashval;   // hash value
    algo::Smallstr16      target;               // Primary key - name of target
    src_func::FTargsrc*   cd_targsrc_head;      // zero-terminated doubly linked list
    i32                   cd_targsrc_n;         // zero-terminated doubly linked list
    // reftype Llist of src_func.FTarget.cd_targsrc prohibits copy
    // func:src_func.FTarget..AssignOp
    inline src_func::FTarget& operator =(const src_func::FTarget &rhs) = delete;
    // reftype Llist of src_func.FTarget.cd_targsrc prohibits copy
    // func:src_func.FTarget..CopyCtor
    inline               FTarget(const src_func::FTarget &rhs) = delete;
private:
    // func:src_func.FTarget..Ctor
    inline               FTarget() __attribute__((nothrow));
    // func:src_func.FTarget..Dtor
    inline               ~FTarget() __attribute__((nothrow));
    friend src_func::FTarget&   target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FTarget*   target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
};
```

#### src_func.FTargsrc - List of sources for target
<a href="#src_func-ftargsrc"></a>

#### src_func.FTargsrc Fields
<a href="#src_func-ftargsrc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FTargsrc.base|[dev.Targsrc](/txt/ssimdb/dev/targsrc.md)|[Base](/txt/ssimdb/dev/targsrc.md)|||
|src_func.FTargsrc.zd_func|[src_func.FFunc](/txt/exe/src_func/internals.md#src_func-ffunc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|src_func.FTargsrc.p_target|[src_func.FTarget](/txt/exe/src_func/internals.md#src_func-ftarget)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|src_func.FTargsrc.select|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|src_func.FTargsrc.counter|i32|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FTargsrc
<a href="#struct-ftargsrc"></a>
*Note:* field ``src_func.FTargsrc.base`` has reftype ``base`` so the fields of [dev.Targsrc](/txt/ssimdb/dev/targsrc.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FTargsrc { // src_func.FTargsrc
    src_func::FTargsrc*   target_cd_targsrc_next;   // zslist link; -1 means not-in-list
    src_func::FTargsrc*   target_cd_targsrc_prev;   // previous element
    algo::Smallstr100     targsrc;                  //
    algo::Comment         comment;                  //
    src_func::FFunc*      zd_func_head;             // zero-terminated doubly linked list
    i32                   zd_func_n;                // zero-terminated doubly linked list
    src_func::FFunc*      zd_func_tail;             // pointer to last element
    src_func::FTarget*    p_target;                 // reference to parent row
    bool                  select;                   //   false
    i32                   counter;                  //   0
    // reftype Llist of src_func.FTargsrc.zd_func prohibits copy
    // x-reference on src_func.FTargsrc.p_target prevents copy
    // func:src_func.FTargsrc..AssignOp
    src_func::FTargsrc&  operator =(const src_func::FTargsrc &rhs) = delete;
    // reftype Llist of src_func.FTargsrc.zd_func prohibits copy
    // x-reference on src_func.FTargsrc.p_target prevents copy
    // func:src_func.FTargsrc..CopyCtor
    FTargsrc(const src_func::FTargsrc &rhs) = delete;
private:
    // func:src_func.FTargsrc..Ctor
    inline               FTargsrc() __attribute__((nothrow));
    // func:src_func.FTargsrc..Dtor
    inline               ~FTargsrc() __attribute__((nothrow));
    friend src_func::FTargsrc&  targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FTargsrc*  targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
};
```

#### src_func.FUserfunc - 
<a href="#src_func-fuserfunc"></a>

#### src_func.FUserfunc Fields
<a href="#src_func-fuserfunc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|src_func.FUserfunc.base|[dmmeta.Userfunc](/txt/ssimdb/dmmeta/userfunc.md)|[Base](/txt/ssimdb/dmmeta/userfunc.md)|||
|src_func.FUserfunc.zd_func|[src_func.FFunc](/txt/exe/src_func/internals.md#src_func-ffunc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||

#### Struct FUserfunc
<a href="#struct-fuserfunc"></a>
*Note:* field ``src_func.FUserfunc.base`` has reftype ``base`` so the fields of [dmmeta.Userfunc](/txt/ssimdb/dmmeta/userfunc.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/src_func_gen.h](/include/gen/src_func_gen.h)
```
struct FUserfunc { // src_func.FUserfunc
    src_func::FUserfunc*   ind_userfunc_next;              // hash next
    u32                    ind_userfunc_hashval;           // hash value
    src_func::FUserfunc*   ind_userfunc_cppname_next;      // hash next
    u32                    ind_userfunc_cppname_hashval;   // hash value
    algo::Smallstr50       userfunc;                       //
    algo::Smallstr200      acrkey;                         //
    algo::Smallstr100      cppname;                        //
    algo::Comment          comment;                        //
    src_func::FFunc*       zd_func_head;                   // zero-terminated doubly linked list
    i32                    zd_func_n;                      // zero-terminated doubly linked list
    src_func::FFunc*       zd_func_tail;                   // pointer to last element
    // reftype Llist of src_func.FUserfunc.zd_func prohibits copy
    // func:src_func.FUserfunc..AssignOp
    inline src_func::FUserfunc& operator =(const src_func::FUserfunc &rhs) = delete;
    // reftype Llist of src_func.FUserfunc.zd_func prohibits copy
    // func:src_func.FUserfunc..CopyCtor
    inline               FUserfunc(const src_func::FUserfunc &rhs) = delete;
private:
    // func:src_func.FUserfunc..Ctor
    inline               FUserfunc() __attribute__((nothrow));
    // func:src_func.FUserfunc..Dtor
    inline               ~FUserfunc() __attribute__((nothrow));
    friend src_func::FUserfunc& userfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend src_func::FUserfunc* userfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 userfunc_RemoveAll() __attribute__((nothrow));
    friend void                 userfunc_RemoveLast() __attribute__((nothrow));
};
```

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Imdb -->

