## atf_unit - Internals


### Table Of Contents
<a href="#table-of-contents"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Toc -->
* [Description](#description)
* [Sources](#sources)
* [Dependencies](#dependencies)
* [In Memory DB](#in-memory-db)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Toc -->

### Description
<a href="#description"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Description -->
for usage, see [atf_unit - Unit tests (see unittest table)](/txt/exe/atf_unit/README.md)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Description -->

### Sources
<a href="#sources"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Sources -->
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/atf_unit/acr.cpp](/cpp/atf_unit/acr.cpp)||
|[cpp/atf_unit/algo_fmt.cpp](/cpp/atf_unit/algo_fmt.cpp)||
|[cpp/atf_unit/algo_lib.cpp](/cpp/atf_unit/algo_lib.cpp)||
|[cpp/atf_unit/algo_txttbl.cpp](/cpp/atf_unit/algo_txttbl.cpp)||
|[cpp/atf_unit/ams.cpp](/cpp/atf_unit/ams.cpp)||
|[cpp/atf_unit/bash.cpp](/cpp/atf_unit/bash.cpp)||
|[cpp/atf_unit/charset.cpp](/cpp/atf_unit/charset.cpp)||
|[cpp/atf_unit/decimal.cpp](/cpp/atf_unit/decimal.cpp)||
|[cpp/atf_unit/fm.cpp](/cpp/atf_unit/fm.cpp)||
|[cpp/atf_unit/lib_ams.cpp](/cpp/atf_unit/lib_ams.cpp)||
|[cpp/atf_unit/lib_exec.cpp](/cpp/atf_unit/lib_exec.cpp)||
|[cpp/atf_unit/lib_json.cpp](/cpp/atf_unit/lib_json.cpp)||
|[cpp/atf_unit/lib_sql.cpp](/cpp/atf_unit/lib_sql.cpp)||
|[cpp/atf_unit/line.cpp](/cpp/atf_unit/line.cpp)||
|[cpp/atf_unit/lockfile.cpp](/cpp/atf_unit/lockfile.cpp)||
|[cpp/atf_unit/main.cpp](/cpp/atf_unit/main.cpp)||
|[cpp/atf_unit/parsenum.cpp](/cpp/atf_unit/parsenum.cpp)||
|[cpp/atf_unit/regx.cpp](/cpp/atf_unit/regx.cpp)||
|[cpp/atf_unit/string.cpp](/cpp/atf_unit/string.cpp)||
|[cpp/atf_unit/time.cpp](/cpp/atf_unit/time.cpp)||
|[cpp/atf_unit/tuple.cpp](/cpp/atf_unit/tuple.cpp)||
|[cpp/gen/atf_unit_gen.cpp](/cpp/gen/atf_unit_gen.cpp)||
|[include/atf_unit.h](/include/atf_unit.h)||
|[include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)||
|[include/gen/atf_unit_gen.inl.h](/include/gen/atf_unit_gen.inl.h)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Sources -->

### Dependencies
<a href="#dependencies"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Dependencies -->
The build target depends on the following libraries
|Target|Comment|
|---|---|
|[lib_ams](/txt/lib/lib_ams/README.md)|Library for AMS middleware, supporting file format & messaging|
|[lib_exec](/txt/lib/lib_exec/README.md)|Build and run a dag of subprocesses with N parallel jobs|
|[lib_fm](/txt/lib/lib_fm/README.md)|Library for dynamic alarm management|
|[lib_json](/txt/lib/lib_json/README.md)|Full json support library|
|[lib_sql](/txt/lib/lib_sql/README.md)|SQL formatting functions|

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Dependencies -->

### In Memory DB
<a href="#in-memory-db"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Imdb -->
`atf_unit` generated code creates the tables below.
All allocations are done through global `atf_unit::_db` [atf_unit.FDb](#atf_unit-fdb) structure
|Ctype|Ssimfile|Create|Access|
|---|---|---|---|
|[atf_unit.Cstr](#atf_unit-cstr)||
|[atf_unit.Dbl](#atf_unit-dbl)||FPerfSort.orig (Tary)|FPerfSort.sorted (Tary)|
|[atf_unit.FDb](#atf_unit-fdb)||FDb._db (Global)|
|[atf_unit.FNumber](#atf_unit-fnumber)||FDb.number (Tpool)|tr_number (Atree, sort field num)|
|[atf_unit.FPerfSort](#atf_unit-fperfsort)||
|[atf_unit.FUnittest](#atf_unit-funittest)|[atfdb.unittest](/txt/ssimdb/atfdb/unittest.md)|FDb.unittest (Lary)|**static**|unittest (Lary, by rowid)|ind_unittest (Thash, hash field unittest)|c_curtest (Ptr)|
|[atf_unit.TypeA](#atf_unit-typea)||
|[atf_unit.TypeB](#atf_unit-typeb)||
|[atf_unit.TestJson](#atf_unit-testjson)||

#### atf_unit.Cstr - 
<a href="#atf_unit-cstr"></a>

#### atf_unit.Cstr Fields
<a href="#atf_unit-cstr-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.Cstr.val|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct Cstr
<a href="#struct-cstr"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct Cstr { // atf_unit.Cstr
    algo::cstring   val;   //
    // func:atf_unit.Cstr.val.Cast
    inline               operator algo::strptr() const __attribute__((nothrow));
    // func:atf_unit.Cstr..Ctor
    inline               Cstr() __attribute__((nothrow));
    // func:atf_unit.Cstr..FieldwiseCtor
    explicit inline               Cstr(const algo::strptr& in_val) __attribute__((nothrow));
};
```

#### atf_unit.Dbl - 
<a href="#atf_unit-dbl"></a>

#### atf_unit.Dbl Fields
<a href="#atf_unit-dbl-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.Dbl.val|double|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct Dbl
<a href="#struct-dbl"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct Dbl { // atf_unit.Dbl
    double   val;   //   0.0
    // func:atf_unit.Dbl.val.Cast
    inline               operator double() const __attribute__((nothrow));
    // func:atf_unit.Dbl..EqOp
    inline bool          operator ==(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..NeOp
    inline bool          operator !=(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..LtOp
    inline bool          operator <(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..GtOp
    inline bool          operator >(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..LeOp
    inline bool          operator <=(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..GeOp
    inline bool          operator >=(const atf_unit::Dbl &rhs) const __attribute__((nothrow));
    // func:atf_unit.Dbl..Ctor
    inline               Dbl() __attribute__((nothrow));
    // func:atf_unit.Dbl..FieldwiseCtor
    explicit inline               Dbl(double in_val) __attribute__((nothrow));
};
```

#### atf_unit.FDb - In-memory database for atf_unit
<a href="#atf_unit-fdb"></a>

#### atf_unit.FDb Fields
<a href="#atf_unit-fdb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.FDb.acr_ed|[command.acr_ed](/txt/protocol/command/README.md#command-acr_ed)|[Exec](/txt/exe/amc/reftypes.md#exec)|||
|atf_unit.FDb.number|[atf_unit.FNumber](/txt/exe/atf_unit/internals.md#atf_unit-fnumber)|[Tpool](/txt/exe/amc/reftypes.md#tpool)|||
|atf_unit.FDb.tr_number|[atf_unit.FNumber](/txt/exe/atf_unit/internals.md#atf_unit-fnumber)|[Atree](/txt/exe/amc/reftypes.md#atree)|||
|atf_unit.FDb.unittest|[atf_unit.FUnittest](/txt/exe/atf_unit/internals.md#atf_unit-funittest)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|atf_unit.FDb._db|[atf_unit.FDb](/txt/exe/atf_unit/internals.md#atf_unit-fdb)|[Global](/txt/exe/amc/reftypes.md#global)|||
|atf_unit.FDb.ind_unittest|[atf_unit.FUnittest](/txt/exe/atf_unit/internals.md#atf_unit-funittest)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|atf_unit.FDb.cmdline|[command.atf_unit](/txt/protocol/command/README.md#command-atf_unit)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FDb.curdir|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FDb.c_curtest|[atf_unit.FUnittest](/txt/exe/atf_unit/internals.md#atf_unit-funittest)|[Ptr](/txt/exe/amc/reftypes.md#ptr)||Currently running test|
|atf_unit.FDb.cur_teststep|[algo.Smallstr100](/txt/protocol/algo/README.md#algo-smallstr100)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FDb.report|[report.atf_unit](/txt/protocol/report/README.md#report-atf_unit)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FDb.perf_cycle_budget|u64|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FDb.tempdir|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FDb
<a href="#struct-fdb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct FDb { // atf_unit.FDb: In-memory database for atf_unit
    algo::cstring           acr_ed_path;                  //   "bin/acr_ed"  path for executable
    command::acr_ed         acr_ed_cmd;                   // command line for child process
    algo::cstring           acr_ed_fstdin;                // redirect for stdin
    algo::cstring           acr_ed_fstdout;               // redirect for stdout
    algo::cstring           acr_ed_fstderr;               // redirect for stderr
    pid_t                   acr_ed_pid;                   //   0  pid of running child process
    i32                     acr_ed_timeout;               //   0  optional timeout for child process
    i32                     acr_ed_status;                //   0  last exit status of child process
    u64                     number_blocksize;             // # bytes per block
    atf_unit::FNumber*      number_free;                  //
    atf_unit::FNumber*      tr_number_root;               // Root of the tree
    i32                     tr_number_n;                  // number of elements in the tree
    atf_unit::FUnittest*    unittest_lary[32];            // level array
    i32                     unittest_n;                   // number of elements in array
    atf_unit::FUnittest**   ind_unittest_buckets_elems;   // pointer to bucket array
    i32                     ind_unittest_buckets_n;       // number of elements in bucket array
    i32                     ind_unittest_n;               // number of elements in the hash table
    command::atf_unit       cmdline;                      //
    algo::cstring           curdir;                       //
    atf_unit::FUnittest*    c_curtest;                    // Currently running test. optional pointer
    algo::Smallstr100       cur_teststep;                 //
    report::atf_unit        report;                       //
    u64                     perf_cycle_budget;            //   0
    algo::cstring           tempdir;                      //
    atf_unit::trace         trace;                        //
};
```

#### atf_unit.FNumber - 
<a href="#atf_unit-fnumber"></a>

#### atf_unit.FNumber Fields
<a href="#atf_unit-fnumber-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.FNumber.num|i32|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FNumber
<a href="#struct-fnumber"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct FNumber { // atf_unit.FNumber
    atf_unit::FNumber*   number_next;       // Pointer to next free element int tpool
    atf_unit::FNumber*   tr_number_up;      // pointer to parent
    atf_unit::FNumber*   tr_number_left;    // Left child
    atf_unit::FNumber*   tr_number_right;   // Right child
    i32                  tr_number_depth;   // Depth
    i32                  num;               //   0
    // func:atf_unit.FNumber..AssignOp
    inline atf_unit::FNumber& operator =(const atf_unit::FNumber &rhs) = delete;
    // func:atf_unit.FNumber..CopyCtor
    inline               FNumber(const atf_unit::FNumber &rhs) = delete;
private:
    // func:atf_unit.FNumber..Ctor
    inline               FNumber() __attribute__((nothrow));
    // func:atf_unit.FNumber..Dtor
    inline               ~FNumber() __attribute__((nothrow));
    friend atf_unit::FNumber&   number_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_unit::FNumber*   number_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 number_Delete(atf_unit::FNumber &row) __attribute__((nothrow));
};
```

#### atf_unit.FPerfSort - Function to test double sorting
<a href="#atf_unit-fperfsort"></a>

#### atf_unit.FPerfSort Fields
<a href="#atf_unit-fperfsort-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.FPerfSort.orig|[atf_unit.Dbl](/txt/exe/atf_unit/internals.md#atf_unit-dbl)|[Tary](/txt/exe/amc/reftypes.md#tary)|||
|atf_unit.FPerfSort.sorted|[atf_unit.Dbl](/txt/exe/atf_unit/internals.md#atf_unit-dbl)|[Tary](/txt/exe/amc/reftypes.md#tary)|||
|atf_unit.FPerfSort.index|i32|[Tary](/txt/exe/amc/reftypes.md#tary)|||

#### Struct FPerfSort
<a href="#struct-fperfsort"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct FPerfSort { // atf_unit.FPerfSort: Function to test double sorting
    atf_unit::Dbl*   orig_elems;     // pointer to elements
    u32              orig_n;         // number of elements in array
    u32              orig_max;       // max. capacity of array before realloc
    atf_unit::Dbl*   sorted_elems;   // pointer to elements
    u32              sorted_n;       // number of elements in array
    u32              sorted_max;     // max. capacity of array before realloc
    i32*             index_elems;    // pointer to elements
    u32              index_n;        // number of elements in array
    u32              index_max;      // max. capacity of array before realloc
    // func:atf_unit.FPerfSort..AssignOp
    atf_unit::FPerfSort& operator =(const atf_unit::FPerfSort &rhs) __attribute__((nothrow));
    // func:atf_unit.FPerfSort..Ctor
    inline               FPerfSort() __attribute__((nothrow));
    // func:atf_unit.FPerfSort..Dtor
    inline               ~FPerfSort() __attribute__((nothrow));
    // func:atf_unit.FPerfSort..CopyCtor
    FPerfSort(const atf_unit::FPerfSort &rhs) __attribute__((nothrow));
};
```

#### atf_unit.FUnittest - Test function
<a href="#atf_unit-funittest"></a>

#### atf_unit.FUnittest Fields
<a href="#atf_unit-funittest-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.FUnittest.base|[atfdb.Unittest](/txt/ssimdb/atfdb/unittest.md)|[Base](/txt/ssimdb/atfdb/unittest.md)|||
|atf_unit.FUnittest.select|bool|[Val](/txt/exe/amc/reftypes.md#val)||Select test for running?|
|atf_unit.FUnittest.step||[Hook](/txt/exe/amc/reftypes.md#hook)|||
|atf_unit.FUnittest.success|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FUnittest.error|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.FUnittest.c_syscmd|[lib_exec.FSyscmd](/txt/lib/lib_exec/README.md#lib_exec-fsyscmd)|[Ptr](/txt/exe/amc/reftypes.md#ptr)|||

#### Struct FUnittest
<a href="#struct-funittest"></a>
*Note:* field ``atf_unit.FUnittest.base`` has reftype ``base`` so the fields of [atfdb.Unittest](/txt/ssimdb/atfdb/unittest.md) above are included into the resulting struct.

Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct FUnittest { // atf_unit.FUnittest: Test function
    atf_unit::FUnittest*           ind_unittest_next;   // hash next
    algo::Smallstr50               unittest;            //
    algo::Comment                  comment;             //
    bool                           select;              //   false  Select test for running?
    atf_unit::unittest_step_hook   step;                //   NULL  Pointer to a function
    bool                           success;             //   false
    algo::cstring                  error;               //
    lib_exec::FSyscmd*             c_syscmd;            // optional pointer
    // reftype Hook of atf_unit.FUnittest.step prohibits copy
    // func:atf_unit.FUnittest..AssignOp
    atf_unit::FUnittest& operator =(const atf_unit::FUnittest &rhs) = delete;
    // reftype Hook of atf_unit.FUnittest.step prohibits copy
    // func:atf_unit.FUnittest..CopyCtor
    FUnittest(const atf_unit::FUnittest &rhs) = delete;
private:
    // func:atf_unit.FUnittest..Ctor
    inline               FUnittest() __attribute__((nothrow));
    // func:atf_unit.FUnittest..Dtor
    inline               ~FUnittest() __attribute__((nothrow));
    friend atf_unit::FUnittest& unittest_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_unit::FUnittest* unittest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 unittest_RemoveAll() __attribute__((nothrow));
    friend void                 unittest_RemoveLast() __attribute__((nothrow));
};
```

#### atf_unit.TypeA - 
<a href="#atf_unit-typea"></a>

#### atf_unit.TypeA Fields
<a href="#atf_unit-typea-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.TypeA.typea|i32|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct TypeA
<a href="#struct-typea"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct TypeA { // atf_unit.TypeA
    i32   typea;   //   0
    // func:atf_unit.TypeA..EqOp
    inline bool          operator ==(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..NeOp
    inline bool          operator !=(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..LtOp
    inline bool          operator <(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..GtOp
    inline bool          operator >(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..LeOp
    inline bool          operator <=(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..GeOp
    inline bool          operator >=(const atf_unit::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeA..Ctor
    inline               TypeA() __attribute__((nothrow));
};
```

#### atf_unit.TypeB - 
<a href="#atf_unit-typeb"></a>

#### atf_unit.TypeB Fields
<a href="#atf_unit-typeb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.TypeB.typea|[atf_unit.TypeA](/txt/exe/atf_unit/internals.md#atf_unit-typea)|[Pkey](/txt/exe/amc/reftypes.md#pkey)|||
|atf_unit.TypeB.j|i32|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct TypeB
<a href="#struct-typeb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct TypeB { // atf_unit.TypeB
    i32   typea;   //   0
    i32   j;       //   0
    // func:atf_unit.TypeB..EqOp
    inline bool          operator ==(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..NeOp
    inline bool          operator !=(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..LtOp
    inline bool          operator <(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..GtOp
    inline bool          operator >(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..LeOp
    inline bool          operator <=(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..GeOp
    inline bool          operator >=(const atf_unit::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_unit.TypeB..Ctor
    inline               TypeB() __attribute__((nothrow));
};
```

#### atf_unit.TestJson - 
<a href="#atf_unit-testjson"></a>

#### atf_unit.TestJson Fields
<a href="#atf_unit-testjson-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_unit.TestJson.fld_bool|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_u8|u8|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_i8|i8|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_u16|u16|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_i16|i16|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_u32|u32|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_i32|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_u64|u64|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_i64|i64|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_float|float|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_double|double|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_char|char|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_strptr|[algo.strptr](/txt/protocol/algo/strptr.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_cstring|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_unit.TestJson.fld_atftypea|[atf_unit.TypeA](/txt/exe/atf_unit/internals.md#atf_unit-typea)|[Val](/txt/exe/amc/reftypes.md#val)||wrapped integer|
|atf_unit.TestJson.fld_atfcstr|[atf_unit.Cstr](/txt/exe/atf_unit/internals.md#atf_unit-cstr)|[Val](/txt/exe/amc/reftypes.md#val)||wrapped cstring|
|atf_unit.TestJson.fld_atfdbl|[atf_unit.Dbl](/txt/exe/atf_unit/internals.md#atf_unit-dbl)|[Val](/txt/exe/amc/reftypes.md#val)||wrapped double|
|atf_unit.TestJson.fld_atftypeb|[atf_unit.TypeB](/txt/exe/atf_unit/internals.md#atf_unit-typeb)|[Val](/txt/exe/amc/reftypes.md#val)||wrapped complex type|

#### Struct TestJson
<a href="#struct-testjson"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_unit_gen.h](/include/gen/atf_unit_gen.h)
```
struct TestJson { // atf_unit.TestJson
    bool              fld_bool;       //   false
    u8                fld_u8;         //   0
    i8                fld_i8;         //   0
    u16               fld_u16;        //   0
    i16               fld_i16;        //   0
    u32               fld_u32;        //   0
    i32               fld_i32;        //   0
    u64               fld_u64;        //   0
    i64               fld_i64;        //   0
    float             fld_float;      //   0.f
    double            fld_double;     //   0.0
    char              fld_char;       //   0
    algo::strptr      fld_strptr;     //
    algo::cstring     fld_cstring;    //
    atf_unit::TypeA   fld_atftypea;   // wrapped integer
    atf_unit::Cstr    fld_atfcstr;    // wrapped cstring
    atf_unit::Dbl     fld_atfdbl;     // wrapped double
    atf_unit::TypeB   fld_atftypeb;   // wrapped complex type
    // func:atf_unit.TestJson..Ctor
    inline               TestJson() __attribute__((nothrow));
};
```

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Imdb -->

