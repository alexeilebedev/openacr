## atf_exp - Internals


### Sources
<a href="#sources"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Sources -->
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/atf_exp/atf_exp.cpp](/cpp/atf_exp/atf_exp.cpp)||
|[cpp/gen/atf_exp_gen.cpp](/cpp/gen/atf_exp_gen.cpp)||
|[include/atf_exp.h](/include/atf_exp.h)||
|[include/gen/atf_exp_gen.h](/include/gen/atf_exp_gen.h)||
|[include/gen/atf_exp_gen.inl.h](/include/gen/atf_exp_gen.inl.h)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Sources -->

### Dependencies
<a href="#dependencies"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Dependencies -->
The build target depends on the following libraries
|Target|Comment|
|---|---|
|[algo_lib](/txt/lib/algo_lib/README.md)|Support library for all executables|
|[lib_prot](/txt/lib/lib_prot/README.md)|Library covering all protocols|

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Dependencies -->

### In Memory DB
<a href="#in-memory-db"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Imdb -->
`atf_exp` generated code creates the tables below.
All allocations are done through global `atf_exp::_db` [atf_exp.FDb](#atf_exp-fdb) structure
|Ctype|Ssimfile|Create|Access|
|---|---|---|---|
|[atf_exp.FDb](#atf_exp-fdb)||FDb._db (Global)|
|[atf_exp.FFdin](#atf_exp-ffdin)||FDb.fdin (Tpool)|cd_fdin_eof (Llist)|cd_fdin_read (Llist)|cd_fdin_suspend (Llist)|
|[atf_exp.FProc](#atf_exp-fproc)||FDb.proc (Tpool)|ind_proc (Thash, hash field proc)|zd_proc (Llist)|cd_proc_read (Llist)|cd_proc_outflow (Llist)|ind_proc_pid (Thash, hash field pid)|c_proc_read (Ptr)|
|[atf_exp.Proc](#atf_exp-proc)||
||||FProc.base (Base)|

#### atf_exp.FDb - 
<a href="#atf_exp-fdb"></a>

#### atf_exp.FDb Fields
<a href="#atf_exp-fdb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_exp.FDb._db|[atf_exp.FDb](/txt/exe/atf_exp/internals.md#atf_exp-fdb)|[Global](/txt/exe/amc/reftypes.md#global)|||
|atf_exp.FDb.cmdline|[command.atf_exp](/txt/protocol/command/README.md#command-atf_exp)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FDb.proc|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Tpool](/txt/exe/amc/reftypes.md#tpool)|||
|atf_exp.FDb.ind_proc|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|atf_exp.FDb.zd_proc|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|atf_exp.FDb.cd_proc_read|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|atf_exp.FDb.cd_proc_outflow|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|atf_exp.FDb.R|[algo_lib.Replscope](/txt/lib/algo_lib/README.md#algo_lib-replscope)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FDb.ind_proc_pid|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|atf_exp.FDb.c_proc_read|[atf_exp.FProc](/txt/exe/atf_exp/internals.md#atf_exp-fproc)|[Ptr](/txt/exe/amc/reftypes.md#ptr)|||
|atf_exp.FDb.proc_read_until|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FDb.fdin|[atf_exp.FFdin](/txt/exe/atf_exp/internals.md#atf_exp-ffdin)|[Tpool](/txt/exe/amc/reftypes.md#tpool)||input|
|atf_exp.FDb.cd_fdin_eof|[atf_exp.FFdin](/txt/exe/atf_exp/internals.md#atf_exp-ffdin)|[Llist](/txt/exe/amc/reftypes.md#llist)||End reading from stdin|
|atf_exp.FDb.cd_fdin_read|[atf_exp.FFdin](/txt/exe/atf_exp/internals.md#atf_exp-ffdin)|[Llist](/txt/exe/amc/reftypes.md#llist)||Read next message from file descriptor|
|atf_exp.FDb.cd_fdin_suspend|[atf_exp.FFdin](/txt/exe/atf_exp/internals.md#atf_exp-ffdin)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|atf_exp.FDb.timeout|[algo_lib.FTimehook](/txt/lib/algo_lib/README.md#algo_lib-ftimehook)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FDb.vars_file|[algo_lib.FFildes](/txt/lib/algo_lib/README.md#algo_lib-ffildes)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FDb
<a href="#struct-fdb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_exp_gen.h](/include/gen/atf_exp_gen.h)
```
struct FDb { // atf_exp.FDb
    command::atf_exp      cmdline;                      //
    u64                   proc_blocksize;               // # bytes per block
    atf_exp::FProc*       proc_free;                    //
    atf_exp::FProc**      ind_proc_buckets_elems;       // pointer to bucket array
    i32                   ind_proc_buckets_n;           // number of elements in bucket array
    i32                   ind_proc_n;                   // number of elements in the hash table
    atf_exp::FProc*       zd_proc_head;                 // zero-terminated doubly linked list
    i32                   zd_proc_n;                    // zero-terminated doubly linked list
    atf_exp::FProc*       zd_proc_tail;                 // pointer to last element
    atf_exp::FProc*       cd_proc_read_head;            // zero-terminated doubly linked list
    i32                   cd_proc_read_n;               // zero-terminated doubly linked list
    atf_exp::FProc*       cd_proc_outflow_head;         // zero-terminated doubly linked list
    i32                   cd_proc_outflow_n;            // zero-terminated doubly linked list
    algo_lib::Replscope   R;                            //
    atf_exp::FProc**      ind_proc_pid_buckets_elems;   // pointer to bucket array
    i32                   ind_proc_pid_buckets_n;       // number of elements in bucket array
    i32                   ind_proc_pid_n;               // number of elements in the hash table
    algo::SchedTime       ind_proc_pid_next;            // atf_exp.FDb.ind_proc_pid              Next invocation time
    algo::SchedTime       ind_proc_pid_delay;           // atf_exp.FDb.ind_proc_pid              Delay between invocations
    atf_exp::FProc*       c_proc_read;                  // optional pointer
    algo::cstring         proc_read_until;              //
    u64                   fdin_blocksize;               // # bytes per block
    atf_exp::FFdin*       fdin_free;                    //
    atf_exp::FFdin*       cd_fdin_eof_head;             // zero-terminated doubly linked list
    i32                   cd_fdin_eof_n;                // zero-terminated doubly linked list
    atf_exp::FFdin*       cd_fdin_read_head;            // zero-terminated doubly linked list
    i32                   cd_fdin_read_n;               // zero-terminated doubly linked list
    atf_exp::FFdin*       cd_fdin_suspend_head;         // zero-terminated doubly linked list
    i32                   cd_fdin_suspend_n;            // zero-terminated doubly linked list
    algo_lib::FTimehook   timeout;                      //
    algo_lib::FFildes     vars_file;                    //
    atf_exp::trace        trace;                        //
};
```

#### atf_exp.FFdin - FD input (normally stdin)
<a href="#atf_exp-ffdin"></a>

#### atf_exp.FFdin Fields
<a href="#atf_exp-ffdin-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_exp.FFdin.in|char|[Fbuf](/txt/exe/amc/reftypes.md#fbuf)|'\n'||

#### Struct FFdin
<a href="#struct-ffdin"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_exp_gen.h](/include/gen/atf_exp_gen.h)
```
struct FFdin { // atf_exp.FFdin: FD input (normally stdin)
    atf_exp::FFdin*     fdin_next;              // Pointer to next free element int tpool
    atf_exp::FFdin*     cd_fdin_eof_next;       // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_eof_prev;       // previous element
    atf_exp::FFdin*     cd_fdin_read_next;      // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_read_prev;      // previous element
    atf_exp::FFdin*     cd_fdin_suspend_next;   // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_suspend_prev;   // previous element
    u8*                 in_elems;               //   NULL  pointer to elements of indirect array
    u32                 in_max;                 //   0  current length of allocated array
    i32                 in_start;               // beginning of valid bytes (in bytes)
    i32                 in_end;                 // end of valid bytes (in bytes)
    i32                 in_msglen;              // current message length
    algo::Errcode       in_err;                 // system error code
    algo_lib::FIohook   in_iohook;              // edge-triggered hook for the buffer
    bool                in_eof;                 // no more data will be written to buffer
    bool                in_msgvalid;            // current message is valid
    bool                in_epoll_enable;        // use epoll?
    // field atf_exp.FFdin.in prevents copy
    // func:atf_exp.FFdin..AssignOp
    inline atf_exp::FFdin& operator =(const atf_exp::FFdin &rhs) = delete;
    // field atf_exp.FFdin.in prevents copy
    // func:atf_exp.FFdin..CopyCtor
    inline               FFdin(const atf_exp::FFdin &rhs) = delete;
private:
    // func:atf_exp.FFdin..Ctor
    inline               FFdin() __attribute__((nothrow));
    // func:atf_exp.FFdin..Dtor
    inline               ~FFdin() __attribute__((nothrow));
    friend atf_exp::FFdin&      fdin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_exp::FFdin*      fdin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdin_Delete(atf_exp::FFdin &row) __attribute__((nothrow));
};
```

#### atf_exp.FProc - 
<a href="#atf_exp-fproc"></a>

#### atf_exp.FProc Fields
<a href="#atf_exp-fproc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_exp.FProc.base|[atf_exp.Proc](/txt/exe/atf_exp/internals.md#atf_exp-proc)|[Base](#atf_exp-proc-fields)|||
|atf_exp.FProc.bash|[command.bash_proc](/txt/protocol/command/README.md#command-bash_proc)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FProc.in|char|[Fbuf](/txt/exe/amc/reftypes.md#fbuf)|'\n'||
|atf_exp.FProc.out|char|[Fbuf](/txt/exe/amc/reftypes.md#fbuf)|'\n'||
|atf_exp.FProc.pid|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FProc.out_delay_close|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FProc.output|[algo.ByteAry](/txt/protocol/algo/README.md#algo-byteary)|[Val](/txt/exe/amc/reftypes.md#val)|||
|atf_exp.FProc.wait|bool|[Val](/txt/exe/amc/reftypes.md#val)|||
#### atf_exp.Proc Fields
<a href="#atf_exp-proc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_exp.Proc.proc|[algo.Smallstr50](/txt/protocol/algo/README.md#algo-smallstr50)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FProc
<a href="#struct-fproc"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_exp_gen.h](/include/gen/atf_exp_gen.h)
```
struct FProc { // atf_exp.FProc
    atf_exp::FProc*      proc_next;              // Pointer to next free element int tpool
    atf_exp::FProc*      ind_proc_next;          // hash next
    u32                  ind_proc_hashval;       // hash value
    atf_exp::FProc*      zd_proc_next;           // zslist link; -1 means not-in-list
    atf_exp::FProc*      zd_proc_prev;           // previous element
    atf_exp::FProc*      cd_proc_read_next;      // zslist link; -1 means not-in-list
    atf_exp::FProc*      cd_proc_read_prev;      // previous element
    atf_exp::FProc*      cd_proc_outflow_next;   // zslist link; -1 means not-in-list
    atf_exp::FProc*      cd_proc_outflow_prev;   // previous element
    atf_exp::FProc*      ind_proc_pid_next;      // hash next
    u32                  ind_proc_pid_hashval;   // hash value
    algo::Smallstr50     proc;                   //
    command::bash_proc   bash;                   //
    u8*                  in_elems;               //   NULL  pointer to elements of indirect array
    u32                  in_max;                 //   0  current length of allocated array
    i32                  in_start;               // beginning of valid bytes (in bytes)
    i32                  in_end;                 // end of valid bytes (in bytes)
    i32                  in_msglen;              // current message length
    algo::Errcode        in_err;                 // system error code
    algo_lib::FIohook    in_iohook;              // edge-triggered hook for the buffer
    bool                 in_eof;                 // no more data will be written to buffer
    bool                 in_msgvalid;            // current message is valid
    bool                 in_epoll_enable;        // use epoll?
    u8*                  out_elems;              //   NULL  pointer to elements of indirect array
    u32                  out_max;                //   0  current length of allocated array
    i32                  out_start;              // beginning of valid bytes (in bytes)
    i32                  out_end;                // end of valid bytes (in bytes)
    i32                  out_msglen;             // current message length
    algo::Errcode        out_err;                // system error code
    algo_lib::FIohook    out_iohook;             // edge-triggered hook for the buffer
    u64                  out_n_eagain;           // eagain counter
    bool                 out_eof;                // no more data will be written to buffer
    bool                 out_msgvalid;           // current message is valid
    bool                 out_epoll_enable;       // use epoll?
    bool                 out_zerocopy;           // support zero-copy optimization
    i32                  pid;                    //   0
    bool                 out_delay_close;        //   false
    algo::ByteAry        output;                 //
    bool                 wait;                   //   false
    // value field atf_exp.FProc.bash is not copiable
    // field atf_exp.FProc.in prevents copy
    // field atf_exp.FProc.out prevents copy
    // func:atf_exp.FProc..AssignOp
    inline atf_exp::FProc& operator =(const atf_exp::FProc &rhs) = delete;
    // value field atf_exp.FProc.bash is not copiable
    // field atf_exp.FProc.in prevents copy
    // field atf_exp.FProc.out prevents copy
    // func:atf_exp.FProc..CopyCtor
    inline               FProc(const atf_exp::FProc &rhs) = delete;
private:
    // func:atf_exp.FProc..Ctor
    inline               FProc() __attribute__((nothrow));
    // func:atf_exp.FProc..Dtor
    inline               ~FProc() __attribute__((nothrow));
    friend atf_exp::FProc&      proc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_exp::FProc*      proc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 proc_Delete(atf_exp::FProc &row) __attribute__((nothrow));
};
```

#### atf_exp.Proc - 
<a href="#atf_exp-proc"></a>

#### atf_exp.Proc Fields
<a href="#atf_exp-proc-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|atf_exp.Proc.proc|[algo.Smallstr50](/txt/protocol/algo/README.md#algo-smallstr50)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct Proc
<a href="#struct-proc"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/atf_exp_gen.h](/include/gen/atf_exp_gen.h)
```
struct Proc { // atf_exp.Proc
    algo::Smallstr50   proc;   //
    // func:atf_exp.Proc..Ctor
    inline               Proc() __attribute__((nothrow));
};
```

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Imdb -->

