## acr_dm - Internals


### Table Of Contents
<a href="#table-of-contents"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Toc -->
* [Description](#description)
* [Sources](#sources)
* [Dependencies](#dependencies)
* [In Memory DB](#in-memory-db)
* [Tests](#tests)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Toc -->

### Description
<a href="#description"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Description -->
for usage, see [acr_dm - ACR Diff/Merge](/txt/exe/acr_dm/README.md)

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Description -->

### Sources
<a href="#sources"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Sources -->
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/acr_dm/acr_dm.cpp](/cpp/acr_dm/acr_dm.cpp)||
|[cpp/gen/acr_dm_gen.cpp](/cpp/gen/acr_dm_gen.cpp)||
|[include/acr_dm.h](/include/acr_dm.h)||
|[include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)||
|[include/gen/acr_dm_gen.inl.h](/include/gen/acr_dm_gen.inl.h)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Sources -->

### Dependencies
<a href="#dependencies"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Dependencies -->
The build target depends on the following libraries
|Target|Comment|
|---|---|
|[algo_lib](/txt/lib/algo_lib/README.md)|Support library for all executables|

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Dependencies -->

### In Memory DB
<a href="#in-memory-db"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Imdb -->
`acr_dm` generated code creates the tables below.
All allocations are done through global `acr_dm::_db` [acr_dm.FDb](#acr_dm-fdb) structure
|Ctype|Ssimfile|Create|Access|
|---|---|---|---|
|[acr_dm.FAttr](#acr_dm-fattr)||FDb.attr (Lary)|attr (Lary, by rowid)|
||||FTuple.zs_attr (Llist)|
||||FValue.p_attr (Upptr)|
|[acr_dm.FDb](#acr_dm-fdb)||FDb._db (Global)|
|[acr_dm.Rowid](#acr_dm-rowid)||
|[acr_dm.Source](#acr_dm-source)||
|[acr_dm.FTuple](#acr_dm-ftuple)||FDb.tuple (Lary)|tuple (Lary, by rowid)|ind_tuple (Thash, hash field key)|bh_tuple (Bheap, sort field rowid)|
||||FAttr.p_tuple (Upptr)|
|[acr_dm.FValue](#acr_dm-fvalue)||FDb.value (Lary)|value (Lary, by rowid)|
||||FAttr.zs_value (Llist)|

#### acr_dm.FAttr - 
<a href="#acr_dm-fattr"></a>

#### acr_dm.FAttr Fields
<a href="#acr_dm-fattr-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.FAttr.name|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.FAttr.p_tuple|[acr_dm.FTuple](/txt/exe/acr_dm/internals.md#acr_dm-ftuple)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|acr_dm.FAttr.zs_value|[acr_dm.FValue](/txt/exe/acr_dm/internals.md#acr_dm-fvalue)|[Llist](/txt/exe/amc/reftypes.md#llist)|||

#### Struct FAttr
<a href="#struct-fattr"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct FAttr { // acr_dm.FAttr
    algo::cstring     name;            //
    acr_dm::FTuple*   p_tuple;         // reference to parent row
    acr_dm::FValue*   zs_value_head;   // zero-terminated singly linked list
    i32               zs_value_n;      // zero-terminated singly linked list
    acr_dm::FValue*   zs_value_tail;   // pointer to last element
    acr_dm::FAttr*    zs_attr_next;    // zslist link; -1 means not-in-list
    // reftype Llist of acr_dm.FAttr.zs_value prohibits copy
    // func:acr_dm.FAttr..AssignOp
    inline acr_dm::FAttr& operator =(const acr_dm::FAttr &rhs) = delete;
    // reftype Llist of acr_dm.FAttr.zs_value prohibits copy
    // func:acr_dm.FAttr..CopyCtor
    inline               FAttr(const acr_dm::FAttr &rhs) = delete;
private:
    // func:acr_dm.FAttr..Ctor
    inline               FAttr() __attribute__((nothrow));
    // func:acr_dm.FAttr..Dtor
    inline               ~FAttr() __attribute__((nothrow));
    friend acr_dm::FAttr&       attr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_dm::FAttr*       attr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 attr_RemoveAll() __attribute__((nothrow));
    friend void                 attr_RemoveLast() __attribute__((nothrow));
};
```

#### acr_dm.FDb - In-memory database for acr_dm
<a href="#acr_dm-fdb"></a>

#### acr_dm.FDb Fields
<a href="#acr_dm-fdb-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.FDb._db|[acr_dm.FDb](/txt/exe/acr_dm/internals.md#acr_dm-fdb)|[Global](/txt/exe/amc/reftypes.md#global)|||
|acr_dm.FDb.cmdline|[command.acr_dm](/txt/protocol/command/README.md#command-acr_dm)|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.FDb.tuple|[acr_dm.FTuple](/txt/exe/acr_dm/internals.md#acr_dm-ftuple)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|acr_dm.FDb.ind_tuple|[acr_dm.FTuple](/txt/exe/acr_dm/internals.md#acr_dm-ftuple)|[Thash](/txt/exe/amc/reftypes.md#thash)|||
|acr_dm.FDb.attr|[acr_dm.FAttr](/txt/exe/acr_dm/internals.md#acr_dm-fattr)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|acr_dm.FDb.value|[acr_dm.FValue](/txt/exe/acr_dm/internals.md#acr_dm-fvalue)|[Lary](/txt/exe/amc/reftypes.md#lary)|||
|acr_dm.FDb.bh_tuple|[acr_dm.FTuple](/txt/exe/acr_dm/internals.md#acr_dm-ftuple)|[Bheap](/txt/exe/amc/reftypes.md#bheap)|||

#### Struct FDb
<a href="#struct-fdb"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct FDb { // acr_dm.FDb: In-memory database for acr_dm
    command::acr_dm    cmdline;                   //
    acr_dm::FTuple*    tuple_lary[32];            // level array
    i32                tuple_n;                   // number of elements in array
    acr_dm::FTuple**   ind_tuple_buckets_elems;   // pointer to bucket array
    i32                ind_tuple_buckets_n;       // number of elements in bucket array
    i32                ind_tuple_n;               // number of elements in the hash table
    acr_dm::FAttr*     attr_lary[32];             // level array
    i32                attr_n;                    // number of elements in array
    acr_dm::FValue*    value_lary[32];            // level array
    i32                value_n;                   // number of elements in array
    acr_dm::FTuple**   bh_tuple_elems;            // binary heap by rowid
    i32                bh_tuple_n;                // number of elements in the heap
    i32                bh_tuple_max;              // max elements in bh_tuple_elems
    acr_dm::trace      trace;                     //
};
```

#### acr_dm.Rowid - 
<a href="#acr_dm-rowid"></a>

#### acr_dm.Rowid Fields
<a href="#acr_dm-rowid-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.Rowid.f1|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.Rowid.f2|i32|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.Rowid.f3|i32|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct Rowid
<a href="#struct-rowid"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct Rowid { // acr_dm.Rowid
    i32   f1;   //   0
    i32   f2;   //   0
    i32   f3;   //   0
    // func:acr_dm.Rowid..EqOp
    inline bool          operator ==(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..NeOp
    inline bool          operator !=(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..LtOp
    inline bool          operator <(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..GtOp
    inline bool          operator >(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..LeOp
    inline bool          operator <=(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..GeOp
    inline bool          operator >=(const acr_dm::Rowid &rhs) const __attribute__((nothrow));
    // func:acr_dm.Rowid..Ctor
    inline               Rowid() __attribute__((nothrow));
    // func:acr_dm.Rowid..FieldwiseCtor
    explicit inline               Rowid(i32 in_f1, i32 in_f2, i32 in_f3) __attribute__((nothrow));
};
```

#### acr_dm.Source - 
<a href="#acr_dm-source"></a>

#### acr_dm.Source Fields
<a href="#acr_dm-source-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.Source.source|u8|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct Source
<a href="#struct-source"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct Source { // acr_dm.Source
    u8   source;   //   0
    // func:acr_dm.Source..Ctor
    inline               Source() __attribute__((nothrow));
};
```

#### acr_dm.FTuple - 
<a href="#acr_dm-ftuple"></a>

#### acr_dm.FTuple Fields
<a href="#acr_dm-ftuple-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.FTuple.key|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.FTuple.rowid|[acr_dm.Rowid](/txt/exe/acr_dm/internals.md#acr_dm-rowid)|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.FTuple.zs_attr|[acr_dm.FAttr](/txt/exe/acr_dm/internals.md#acr_dm-fattr)|[Llist](/txt/exe/amc/reftypes.md#llist)|||
|acr_dm.FTuple.source|[acr_dm.Source](/txt/exe/acr_dm/internals.md#acr_dm-source)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FTuple
<a href="#struct-ftuple"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct FTuple { // acr_dm.FTuple
    acr_dm::FTuple*   ind_tuple_next;   // hash next
    i32               bh_tuple_idx;     // index in heap; -1 means not-in-heap
    algo::cstring     key;              //
    acr_dm::Rowid     rowid;            //
    acr_dm::FAttr*    zs_attr_head;     // zero-terminated singly linked list
    i32               zs_attr_n;        // zero-terminated singly linked list
    acr_dm::FAttr*    zs_attr_tail;     // pointer to last element
    acr_dm::Source    source;           //
    // reftype Llist of acr_dm.FTuple.zs_attr prohibits copy
    // func:acr_dm.FTuple..AssignOp
    inline acr_dm::FTuple& operator =(const acr_dm::FTuple &rhs) = delete;
    // reftype Llist of acr_dm.FTuple.zs_attr prohibits copy
    // func:acr_dm.FTuple..CopyCtor
    inline               FTuple(const acr_dm::FTuple &rhs) = delete;
private:
    // func:acr_dm.FTuple..Ctor
    inline               FTuple() __attribute__((nothrow));
    // func:acr_dm.FTuple..Dtor
    inline               ~FTuple() __attribute__((nothrow));
    friend acr_dm::FTuple&      tuple_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_dm::FTuple*      tuple_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tuple_RemoveAll() __attribute__((nothrow));
    friend void                 tuple_RemoveLast() __attribute__((nothrow));
};
```

#### acr_dm.FValue - 
<a href="#acr_dm-fvalue"></a>

#### acr_dm.FValue Fields
<a href="#acr_dm-fvalue-fields"></a>
|Field|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|acr_dm.FValue.value|[algo.cstring](/txt/protocol/algo/cstring.md)|[Val](/txt/exe/amc/reftypes.md#val)|||
|acr_dm.FValue.p_attr|[acr_dm.FAttr](/txt/exe/acr_dm/internals.md#acr_dm-fattr)|[Upptr](/txt/exe/amc/reftypes.md#upptr)|||
|acr_dm.FValue.source|[acr_dm.Source](/txt/exe/acr_dm/internals.md#acr_dm-source)|[Val](/txt/exe/amc/reftypes.md#val)|||

#### Struct FValue
<a href="#struct-fvalue"></a>
Generated by [amc](/txt/exe/amc/README.md) into [include/gen/acr_dm_gen.h](/include/gen/acr_dm_gen.h)
```
struct FValue { // acr_dm.FValue
    acr_dm::FValue*   zs_value_next;   // zslist link; -1 means not-in-list
    algo::cstring     value;           //
    acr_dm::FAttr*    p_attr;          // reference to parent row
    acr_dm::Source    source;          //
    // func:acr_dm.FValue..AssignOp
    inline acr_dm::FValue& operator =(const acr_dm::FValue &rhs) = delete;
    // func:acr_dm.FValue..CopyCtor
    inline               FValue(const acr_dm::FValue &rhs) = delete;
private:
    // func:acr_dm.FValue..Ctor
    inline               FValue() __attribute__((nothrow));
    // func:acr_dm.FValue..Dtor
    inline               ~FValue() __attribute__((nothrow));
    friend acr_dm::FValue&      value_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_dm::FValue*      value_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 value_RemoveAll() __attribute__((nothrow));
    friend void                 value_RemoveLast() __attribute__((nothrow));
};
```

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Imdb -->

### Tests
<a href="#tests"></a>
<!-- dev.mdmark  mdmark:MDSECTION  state:BEG_AUTO  param:Tests -->
The following component tests are defined for `acr_dm`.
These can be executed with `atf_comp <comptest> -v`
|Comptest|Comment|
|---|---|
|[acr_dm.Conflict](/test/atf_comp/acr_dm.Conflict)||
|[acr_dm.Merge](/test/atf_comp/acr_dm.Merge)||
|[acr_dm.RenameTuple](/test/atf_comp/acr_dm.RenameTuple)||

<!-- dev.mdmark  mdmark:MDSECTION  state:END_AUTO  param:Tests -->

