## lib_fm - Library for dynamic alarm management


### Table Of Contents
<a href="#table-of-contents"></a>
* [Introduction](#introduction)
* [Restrictions and limitations](#restrictions-and-limitations)
* [Concepts](#concepts)
* [Lib_fm](#lib_fm)
* [Ctypes](#ctypes)
* [Functions](#functions)
* [Sources](#sources)
* [Inputs](#inputs)

### Introduction
<a href="#introduction"></a>

Fault management is dynamyc fault management functionality aligned
(but not constrained) to telecom and computing world.
Conceptual specification is RFC 8632, which summarizes specifications
from different institutions and decades of experience.

For theory in deep refer:
- [RFC 8632](https://datatracker.ietf.org/doc/html/rfc8632)
  - chapter 3 - general concepts
  - appendix G - alarm usability requirements
- ITU-T G.7710, ITU-T M.3100, ITU-T M.3400, ITU-T X.733 - telecom
- 3GPP alarm IRP - mobile
- GR-474-CORE - North America

### Restrictions and limitations
<a href="#restrictions-and-limitations"></a>

We use concepts adapted to current project needs.
The following features are supported:
- Resource lifecycle - full support
- Operator lifecycle - unsupported
- Administrator lifecycle - limited support
- Shelving - unsupported
- Profiles - limited support
- Logging - supported
- Event notifications - supported

### Concepts
<a href="#concepts"></a>

**Alarm** (the general concept):  An alarm signifies an undesirable state
in an object that requires corrective action.

**Fault:**  A fault is the underlying cause of an undesired behavior.
There is no trivial one-to-one mapping between faults and alarms.
One fault may result in several alarms in case the system lacks
root-cause and correlation capabilities.  An alarm might not have
an underlying fault as a cause.

**Alarm Code:**  An alarm code identifies a possible unique alarm state
for an object.

**Alarm Inventory:** A list of all possible alarm codes generated by the system.

**Alarm Object:**  A fine-grained identification of the alarming object,
for example, a process, or a connection.

**Alarm Instance:**  The alarm state for a specific object and alarm
code. An entry in the alarm list.

**Alarm Service Effect:** An alarm service effect shows whether service
is interrupted (affected) or not.

**Alarm Severity:** An alarm severity indicates importance of alarm.
This helps to determine an order in which raised alarms should be investigated.

  - **Critical Alarm:** A Critical **(CR)** alarm generally indicates severe,
service-affecting trouble that needs immediate correction.

  - **Major Alarm:** A Major **(MJ)** alarm is a serious alarm, but the trouble has less impact.

  - **Minor Alarm:** A Minor **(MN)** alarms generally are those that do not affect service.

**Raised Alarm:** A raised alarm is an alarm where the system
considers the undesired state to be raised.

**Cleared Alarm**:  A cleared alarm is an alarm where the system
considers the undesired state to be cleared.

**Alarm Occurrence:** A fact of raising alarm.
New alarm (first occurrence) or re-raising of cleared alarm.

**Active Alarm:** A raised alarm.

**Historic Alarm:** A cleared alarm.

**Fault Cause Persistence:**
In order to avoid alarm flapping, the system shall perform fault cause persistence check
before it declares corresponding alarm raised or cleared.
Undesired state or its absence shall persist continuously
for a certain period of time.
Timings shall be defined according to the fault cause nature:
  - for raise, consider how fast the trouble shall be detected
and brought to the operator (typical requirement is 2..3 sec),
this time should be enough to protect from temporary failure (and thus false alarm);
  - for clear, the time shall be enough to prove stability of the trouble
solution as result of taken measures - 10 sec for reference.

**Defect correlations**: The defect correlations provide mechanism for data reduction.
In situation where many defects are detected as a consequence of single root cause,
these defects shall be considered as "correlated" and thus suppressed
in presence of this root cause.

**Alarm Severity Assignment:** Process of assigning severity for the alarm instance being raised.

**Alarm Severity Assignment Profile:** A profile that defines rules for alarm severity assignment.
At least one system-defined (default) alarm severity assignment profile shall exist.

**Alarm List:** A list of all alarm instances in the system, each record represents current state
for active alarm, or last state for cleared alarm. Note that subsequent raise of cleared (historic) alarm
shall reuse of existing historic record for new occurrence.

**Alarm Logging:** Each state change of alarm is logged in the alarm log.

**Alarm Event Notification:** A notification on any alarm state change.

**Alarm Administration:** Purge unwanted (old) alarms, compress alarm log.

NOTE WELL:

- Alarms are viewed as states on objects and not as discrete notifications.

- Alarms are raised and cleared by the system only,
not by the operator or by administrator.

- Alarm severity and raised/cleared status are orthogonal categories,
cleared alarm preserves its severity.

- Usable alarms always require attention. Every single occurrence of temporary failure
does not need attention, but high rate of such failures for a period of time requires,
and shall be considered as single occurrence.

#### Alarm Inventory, Alarm Severity Assignment Profile
<a href="#alarm-inventory--alarm-severity-assignment-profile"></a>

Fault types are defined on the table:

```
inline-command: acr fmdb.alm_code
fmdb.alm_code  alm_code:TEST-EXER  severity:major  source:UnitTest  summary:"Test exercise"
report.acr  n_select:1  n_insert:0  n_delete:0  n_ignore:0  n_update:0  n_file_mod:0
```

This table plays the role of alarm inventory, and alarm severity assignment profile.
Only one profile (system-default) is supported.

Fault code is represented as mnemonic, must be kept as short as possible but understandable by trained personnel.
Use of standard and industry-specific abbreviations is appreciated.

Summary shall literally define the code, making the code understandable for untrained personnel.

Severity is defined as follows:
```
inline-command: acr dmmeta.fconst:fm.Severity.value/%
dmmeta.fconst  fconst:fm.Severity.value/critical  value:"'0'"  comment:"Service-affecting fault, immediate attention"
dmmeta.fconst  fconst:fm.Severity.value/major     value:"'1'"  comment:"Service-affecting fault, urgent attention"
dmmeta.fconst  fconst:fm.Severity.value/minor     value:"'2'"  comment:"Non-service affecting fault, need attention"
report.acr  n_select:3  n_insert:0  n_delete:0  n_ignore:0  n_update:0  n_file_mod:0
```

Source identifies the fragment of source code where this alarm code is managed (raised,cleared).
This may be class name, module, library, tool, etc.
The field is usable where it is required to clear all alarms for this source.

Source is defined as follows:
```
inline-command: acr fmdb.alm_source
fmdb.alm_source  alm_source:UnitTest  comment:"Unit test"
report.acr  n_select:1  n_insert:0  n_delete:0  n_ignore:0  n_update:0  n_file_mod:0
```

#### Alarm Instance
<a href="#alarm-instance"></a>

Alarm instance is defined as follows.

```
inline-command: acr dmmeta.field:fmdb.Alarm.%
dmmeta.field  field:fmdb.Alarm.alarm            arg:algo.Smallstr200  reftype:Val  dflt:""  comment:"Alarm identity: code@object"
dmmeta.field  field:fmdb.Alarm.code             arg:fm.Code           reftype:Val  dflt:""  comment:"Alarm code"
dmmeta.field  field:fmdb.Alarm.object           arg:algo.Smallstr200  reftype:Val  dflt:""  comment:"Alarmed object: objtype.objinst"
dmmeta.field  field:fmdb.Alarm.objtype          arg:fm.Objtype        reftype:Val  dflt:""  comment:"Alarmed object type"
dmmeta.field  field:fmdb.Alarm.objinst          arg:fm.Objinst        reftype:Val  dflt:""  comment:"Alarmed object instance"
dmmeta.field  field:fmdb.Alarm.objprefix        arg:algo.Smallstr50   reftype:Val  dflt:""  comment:"Prefix of alarmed object instance (service name)"
dmmeta.field  field:fmdb.Alarm.flag             arg:fm.Flag           reftype:Val  dflt:""  comment:"Flag: raised or cleared"
dmmeta.field  field:fmdb.Alarm.severity         arg:fm.Severity       reftype:Val  dflt:""  comment:"Perceived severity"
dmmeta.field  field:fmdb.Alarm.n_occurred       arg:i32               reftype:Val  dflt:""  comment:"How many times the alarm occurred since first_time"
dmmeta.field  field:fmdb.Alarm.first_time       arg:algo.UnTime       reftype:Val  dflt:""  comment:"Time of first occurrence"
dmmeta.field  field:fmdb.Alarm.last_time        arg:algo.UnTime       reftype:Val  dflt:""  comment:"Time of last occurrence"
dmmeta.field  field:fmdb.Alarm.clear_time       arg:algo.UnTime       reftype:Val  dflt:""  comment:"Time when the alarm has beed cleared (only for cleared alarms"
dmmeta.field  field:fmdb.Alarm.update_time      arg:algo.UnTime       reftype:Val  dflt:""  comment:"Time of last update"
dmmeta.field  field:fmdb.Alarm.objtype_summary  arg:fm.Summary        reftype:Val  dflt:""  comment:"Object type explained"
dmmeta.field  field:fmdb.Alarm.summary          arg:fm.Summary        reftype:Val  dflt:""  comment:"Alarm summary from inventory"
dmmeta.field  field:fmdb.Alarm.description      arg:fm.Description    reftype:Val  dflt:""  comment:"Alarm message from object"
dmmeta.field  field:fmdb.Alarm.source           arg:fm.Source         reftype:Val  dflt:""  comment:"Subsystem where alarm has been detected"
report.acr  n_select:17  n_insert:0  n_delete:0  n_ignore:0  n_update:0  n_file_mod:0
```

Primary key `alarm` has  the following format: `CODE@OBJECT`.

OBJECT has format: `OBJTYPE.OBJINST`

Various objects may have same addressing, thus object type qualifies instance, and defined as:

```
inline-command: acr fmdb.alm_objtype
fmdb.alm_objtype  alm_objtype:SYS  summary:System
report.acr  n_select:1  n_insert:0  n_delete:0  n_ignore:0  n_update:0  n_file_mod:0
```

Note that `code`, `object`, `objtype`, `objinst`, `objprefix` are substrings of `alarm` primary key.

### Lib_fm
<a href="#lib_fm"></a>

Lib_fm library facilitates working with alarms.

#### Initialization
<a href="#initialization"></a>

```
    void FmInit(
        algo::strptr object_prefix  // object prefix
    );
```
Object prefix is optional higher level context to be put ahead of object instance
generated by the code (separated by dot), host name is an example.

#### Raise/Clear Alarm
<a href="#raise-clear-alarm"></a>

`SetAlarm` API raises and clears alarms:

```
    // Set or clear alarm, return alarm record created or updated, NULL if none
    lib_fm::FAlarm *SetAlarm(
        bool raise,           // true for raise, false for clear
        algo::UnTime time,    // current time
        algo::strptr code,    // alarm code, from fmdb.alm_code
        algo::strptr objtype, // object type, from fmdb.alm_objtype
        algo::strptr objinst, // object instance
        algo::strptr message  // fault description message
    );

```
Note message is unused when raise is false.

Guidelines:

1. Put in description message exact condition which triggered the alarm, it should add new info to alarm summary.
  * If alarm summary is clear enough, leave blank - no need to duplicate it.
  * Example: BAD: "Missed heartbeats", GOOD: "Missed 3 heartbeats for 10 seconds"
2. Respect fault cause persistence - do not flap.
3. Respect defect correlations - clear correlated alarms.
4. Respect usability - do not raise alarms too early, do not raise temporary conditions as alarms.
5. Clear all alarms for the object when it is being voluntarily put out of service.

#### Alarm List
<a href="#alarm-list"></a>

`lib_fm::_db.alarm` holds alarm list.

#### Walk and clear alarms
<a href="#walk-and-clear-alarms"></a>

Walk `lib_fm::_db.alarm` and call `lib_fm::ClearAlarm()` as appropriate.
Clearing alarms does not delete them, so is safe.

#### Alarm Logging, Alarm Event Notification
<a href="#alarm-logging--alarm-event-notification"></a>

Register hook `lib_fm.FDb.h_alarm`, which is called on every update of `lib_fm::_db.alarm`.
Use hook to write to alarm log and send notifications.

#### Alarm Administration
<a href="#alarm-administration"></a>

`GatherAlarmHistory` API facilitates alarm administration (purge and, state history compress).
API must be called on application initialization phase.
It does the following:
1. Find most recent log file, not older that N days.
2. Replay it, drop alarms with update time older than N days.
3. Clear all raised alarms.
4. Write start-of-day snapshot to current log file, if not already exists.

```
    void GatherAlarmHistory(
        algo::strptr file_prefix,   // file prefix
        algo::UnTime time,          // current time (find log file, clear time)
        int days_old                // N
   );
```

Alarm log file name follows the convention:
```
   file_prefix%Y-%b-%d.ssim
```

### Ctypes
<a href="#ctypes"></a>
Other ctypes in this namespace which don't have own readme files

#### lib_fm.FAlarm - 
<a href="#lib_fm-falarm"></a>

|Name|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|base|[fmdb.Alarm](/txt/ssimdb/fmdb/alarm.md)|Base|

#### lib_fm.FAlmCode - 
<a href="#lib_fm-falmcode"></a>

|Name|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|base|[fmdb.AlmCode](/txt/ssimdb/fmdb/alm_code.md)|Base|

#### lib_fm.FAlmObjtype - 
<a href="#lib_fm-falmobjtype"></a>

|Name|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|base|[fmdb.AlmObjtype](/txt/ssimdb/fmdb/alm_objtype.md)|Base|

#### lib_fm.FDb - In-memory database for lib_fm
<a href="#lib_fm-fdb"></a>

|Name|[Type](/txt/ssimdb/dmmeta/ctype.md)|[Reftype](/txt/ssimdb/dmmeta/reftype.md)|Default|Comment|
|---|---|---|---|---|
|_db|lib_fm.FDb|Global|
|alarm|lib_fm.FAlarm|Lary|
|ind_alarm|lib_fm.FAlarm|Thash|
|alm_code|lib_fm.FAlmCode|Lary|
|ind_alm_code|lib_fm.FAlmCode|Thash|
|object_prefix|algo.cstring|Val|
|alm_objtype|lib_fm.FAlmObjtype|Lary|
|ind_alm_objtype|lib_fm.FAlmObjtype|Thash|
|h_alarm|lib_fm.FAlarm|Hook|

### Functions
<a href="#functions"></a>
Functions exported from this namespace:

```c++
// Initialize FM library
// prefix - automatically add prefix to object instance ID
void lib_fm::FmInit(algo::strptr object_prefix) 
```

```c++
// Compose log file name from file_prefix and date:
// file_prefix%Y-%b-%d.ssim
tempstr lib_fm::LogFile(algo::strptr file_prefix, algo::UnTime date) 
```

```c++
// Find most recent log file, load alarms from it, clears all raised alarms,
// and if today's file does not exist, create it and dump snapshot.
// This function calls h_alarm user hook for all alarms for resutling snapshot,
// could be useful for other subsystems.
void lib_fm::GatherAlarmHistory(algo::strptr file_prefix, algo::UnTime time, int days_old) 
```

```c++
// clear existing alarm, return true if cleared, false if not
bool lib_fm::ClearAlarm(lib_fm::FAlarm &alarm, algo::UnTime time) 
```

```c++
// Set or clear alarm, return alarm record created or updated, NULL if none
// TIME: current time, e.g. algo::CurrUnTime()
// CODE: alarm code; one of the constants from fmdb.alm_code table, e.g. lib_fm::fmdb_alm_code_MEM_ULK
// OBJTYPE: object type; one of the constants from fmdb.alm_objtype table, e.g. lib_fm::fmdb_alm_objtype_PROC
// OBJINST: object instance; key identifying the object.
// MESSAGE: user-readable message.
lib_fm::FAlarm *lib_fm::SetAlarm(bool raise, algo::UnTime time, algo::strptr code, algo::strptr objtype, algo::strptr objinst, algo::strptr message) 
```

```c++
// copy alarm to message
void lib_fm::CopyToMsg(lib_fm::FAlarm &from, fm::AlarmMsg &to) 
```

```c++
// update from message
void lib_fm::UpdateFromMsg(fm::AlarmMsg &msg) 
```

```c++
// dump all alarms (for debugging purpose)
void lib_fm::DumpAlarms() 
```

### Sources
<a href="#sources"></a>
The source code license is GPL
The following source files are part of this tool:

|Source File|Comment|
|---|---|
|[cpp/gen/lib_fm_gen.cpp](/cpp/gen/lib_fm_gen.cpp)||
|[cpp/lib/lib_fm.cpp](/cpp/lib/lib_fm.cpp)||
|[include/gen/lib_fm_gen.h](/include/gen/lib_fm_gen.h)||
|[include/gen/lib_fm_gen.inl.h](/include/gen/lib_fm_gen.inl.h)||
|[include/lib_fm.h](/include/lib_fm.h)||

### Inputs
<a href="#inputs"></a>
`lib_fm` takes the following tables on input:
|ssimfile|comment|
|---|---|
|[fmdb.alm_objtype](/txt/ssimdb/fmdb/alm_objtype.md)|Alarm resource type|
|[fmdb.alm_code](/txt/ssimdb/fmdb/alm_code.md)||
|[dmmeta.dispsigcheck](/txt/ssimdb/dmmeta/dispsigcheck.md)|Check signature of input data against executable's version|

